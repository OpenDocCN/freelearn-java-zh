<html><head></head><body>
		<div id="_idContainer204">
			<h1 id="_idParaDest-357"><em class="italic"><a id="_idTextAnchor356"/>Chapter 17</em>: Best Practices for Writing High-Quality Code</h1>
			<p>When programmers talk to each other, they often use jargon that cannot be understood by non-programmers, or is vaguely understood by the programmers of different programming languages. But those who use the same programming language understand each other just fine. Sometimes, it may also depend on how knowledgeable a programmer is. A novice may not understand what an experienced programmer is talking about, while a seasoned colleague nods and responds in kind. This chapter is designed to fill this gap and improve the understanding between programmers of different levels. In this chapter, we will discuss some Java programming jargon – the Java idioms that describe certain features, functionality, design solutions, and so on. You will also learn about the most popular and useful practices for designing and writing application code.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Java idioms, their implementation, and their usage</li>
				<li>The <strong class="source-inline">equals()</strong>, <strong class="source-inline">hashCode()</strong>, <strong class="source-inline">compareTo()</strong>, and <strong class="source-inline">clone()</strong> methods</li>
				<li>The <strong class="source-inline">StringBuffer</strong> and <strong class="source-inline">StringBuilder</strong> classes</li>
				<li>The <strong class="source-inline">try</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong> clauses</li>
				<li>Best design practices</li>
				<li>Code is written for people</li>
				<li>Use well-established frameworks and libraries</li>
				<li>Testing is the shortest path to quality code</li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of what other Java programmers are talking about while discussing their design decisions and the functionality they use.</p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor357"/>Technical requirements</h1>
			<p>To execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with either Microsoft Windows, Apple macOS, or Linux </li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor of your choice</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a><em class="italic">,</em> <em class="italic">Getting Started with Java 17</em>. The files containing the code examples for this chapter are available on GitHub at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the examples/src/main/java/com/packt/learnjava/ch17_bestpractices folder and in the <strong class="source-inline">spring</strong> and <strong class="source-inline">reactive</strong> folders. </p>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor358"/>Java idioms, their implementation, and their usage</h1>
			<p>In addition to serving as a means of communication among professionals, programming idioms are also proven programming solutions and common practices not directly derived from the language specification but born out of the programming experience. In this section, we are going to discuss the ones that are used most often. You can find and study the full list of idioms in the <a id="_idIndexMarker1936"/>official Java documentation (<a href="https://docs.oracle.com/javase/tutorial">https://docs.oracle.com/javase/tutorial</a>).</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor359"/>The equals() and hashCode() methods</h2>
			<p>The <a id="_idIndexMarker1937"/>default implementation of the <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods in<a id="_idIndexMarker1938"/> the <strong class="source-inline">java.lang.Object</strong> class looks as follows:</p>
			<pre class="source-code">public boolean equals(Object obj) {</pre>
			<pre class="source-code">    return (this == obj);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">/**</pre>
			<pre class="source-code">* Whenever it is invoked on the same object more than once during</pre>
			<pre class="source-code">* an execution of a Java application, the hashCode method</pre>
			<pre class="source-code">* must consistently return the same integer...</pre>
			<pre class="source-code">* As far as is reasonably practical, the hashCode method defined</pre>
			<pre class="source-code">* by class Object returns distinct integers for distinct objects.</pre>
			<pre class="source-code">*/</pre>
			<pre class="source-code">@HotSpotIntrinsicCandidate</pre>
			<pre class="source-code">public native int hashCode();</pre>
			<p>As you can <a id="_idIndexMarker1939"/>see, the default implementation of the <strong class="source-inline">equals()</strong> method only compares memory references that point to the addresses where the objects are stored. Similarly, as you can see from the comments (quoted from the source code), the <strong class="source-inline">hashCode()</strong> method <a id="_idIndexMarker1940"/>returns the same integer for the same object and a different integer for different objects. Let’s demonstrate this using the <strong class="source-inline">Person</strong> class:</p>
			<pre class="source-code">public class Person {</pre>
			<pre class="source-code">  private int age;</pre>
			<pre class="source-code">  private String firstName, lastName;</pre>
			<pre class="source-code">  public Person(int age, String firstName, String lastName){</pre>
			<pre class="source-code">      this.age = age;</pre>
			<pre class="source-code">      this.lastName = lastName;</pre>
			<pre class="source-code">      this.firstName = firstName;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public int getAge() { return age; }</pre>
			<pre class="source-code">  public String getFirstName() { return firstName; }</pre>
			<pre class="source-code">  public String getLastName() { return lastName; }</pre>
			<pre class="source-code">}</pre>
			<p>Here is an <a id="_idIndexMarker1941"/>example of how the default <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods<a id="_idIndexMarker1942"/> behave:</p>
			<pre class="source-code">Person person1 = new Person(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">Person person2 = person1;</pre>
			<pre class="source-code">Person person3 = new Person(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">System.out.println(person1.equals(person2)); //prints: true</pre>
			<pre class="source-code">System.out.println(person1.equals(person3)); //prints: false</pre>
			<pre class="source-code">System.out.println(person1.hashCode());</pre>
			<pre class="source-code">                                            //prints: 777874839</pre>
			<pre class="source-code">System.out.println(person2.hashCode());</pre>
			<pre class="source-code">                                            //prints: 777874839</pre>
			<pre class="source-code">System.out.println(person3.hashCode());</pre>
			<pre class="source-code">                                            //prints: 596512129</pre>
			<p>The output in your system might be slightly different.</p>
			<p>The <strong class="source-inline">person1</strong> and <strong class="source-inline">person2</strong> references and their hash codes are equal because they point to the same object (the same area of memory and the same address), while the <strong class="source-inline">person3</strong> reference points to another object.</p>
			<p>In practice, though, as we described in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, we would like the equality of the object to be based on the value of all or some of the object properties. So, here is a typical implementation of the <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public boolean equals(Object o) {</pre>
			<pre class="source-code">    if (this == o) return true;</pre>
			<pre class="source-code">    if (o == null) return false;</pre>
			<pre class="source-code">    if(!(o instanceof Person)) return false;</pre>
			<pre class="source-code">    Person person = (Person)o;</pre>
			<pre class="source-code">    return getAge() == person.getAge() &amp;&amp;</pre>
			<pre class="source-code">       Objects.equals(getFirstName(), person.getFirstName()) &amp;&amp;</pre>
			<pre class="source-code">           Objects.equals(getLastName(), person.getLastName());</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public int hashCode() {</pre>
			<pre class="source-code">  return Objects.hash(getAge(), getFirstName(), getLastName());</pre>
			<pre class="source-code">}</pre>
			<p>It used to be more involved, but using <strong class="source-inline">java.util.Objects</strong> utilities makes it much easier, especially if you notice that the <strong class="source-inline">Objects.equals()</strong> method handles <strong class="source-inline">null</strong> too.</p>
			<p>Here, we have<a id="_idIndexMarker1943"/> added the<a id="_idIndexMarker1944"/> described implementation of the <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods to the <strong class="source-inline">Person1</strong> class and executed the same comparisons:</p>
			<pre class="source-code">Person1 person1 = new Person1(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">Person1 person2 = person1;</pre>
			<pre class="source-code">Person1 person3 = new Person1(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">System.out.println(person1.equals(person2)); //prints: true</pre>
			<pre class="source-code">System.out.println(person1.equals(person3)); //prints: true</pre>
			<pre class="source-code">System.out.println(person1.hashCode());</pre>
			<pre class="source-code">                                           //prints: 2115012528</pre>
			<pre class="source-code">System.out.println(person2.hashCode());</pre>
			<pre class="source-code">                                           //prints: 2115012528</pre>
			<pre class="source-code">System.out.println(person3.hashCode());</pre>
			<pre class="source-code">                                           //prints: 2115012528</pre>
			<p>As you can see, the change we have made not only makes the same objects equal but makes two different objects with the same values of the properties equal too. Furthermore, the hash code value is now based on the values of the same properties as well.</p>
			<p>In <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, we explained why it is important to implement the <strong class="source-inline">hasCode()</strong> method while implementing the <strong class="source-inline">equals()</strong> method.</p>
			<p>The same set of properties must be used for establishing equality in the <strong class="source-inline">equals()</strong> method <a id="_idIndexMarker1945"/>and for the <a id="_idIndexMarker1946"/>hash calculation in the <strong class="source-inline">hashCode()</strong> method.</p>
			<p>Having the <strong class="source-inline">@Override</strong> annotation in front of these methods assures that they override the default implementation in the <strong class="source-inline">Object</strong> class. Otherwise, a typo in the method’s name may create the illusion that the new implementation is being used when it isn’t. Debugging such cases has proved much more difficult and costly than just adding the <strong class="source-inline">@Override</strong> annotation, which generates an error if the method does not override anything.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor360"/>The compareTo() method</h2>
			<p>In <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, we used the <strong class="source-inline">compareTo()</strong> method (the only method of the <strong class="source-inline">Comparable</strong> interface) extensively and pointed out <a id="_idIndexMarker1947"/>that the order that is established based on this <a id="_idIndexMarker1948"/>method (its implementation by the elements of a collection) is called a <strong class="bold">natural order</strong>.</p>
			<p>To demonstrate this, we created the <strong class="source-inline">Person2</strong> class:</p>
			<pre class="source-code">  public class Person2 implements Comparable&lt;Person2&gt; {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String firstName, lastName;</pre>
			<pre class="source-code">    public Person2(int age, String firstName, String lastName)</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.lastName = lastName;</pre>
			<pre class="source-code">        this.firstName = firstName;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge() { return age; }</pre>
			<pre class="source-code">    public String getFirstName() { return firstName; }</pre>
			<pre class="source-code">    public String getLastName() { return lastName; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public int compareTo(Person2 p) {</pre>
			<pre class="source-code">        int result = Objects.compare(getFirstName(), </pre>
			<pre class="source-code">                  p.getFirstName(), Comparator.naturalOrder());</pre>
			<pre class="source-code">        if (result != 0) {</pre>
			<pre class="source-code">            return result;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        result = Objects.compare(getLastName(), </pre>
			<pre class="source-code">                   p.getLastName(), Comparator.naturalOrder());</pre>
			<pre class="source-code">        if (result != 0) {</pre>
			<pre class="source-code">            return result;</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        return Objects.compare(age, p.getAge(), </pre>
			<pre class="source-code">                                    Comparator.naturalOrder());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        return firstName + " " + lastName + ", " + age;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<p>Then, we<a id="_idIndexMarker1949"/> composed a list of <strong class="source-inline">Person2</strong> objects and sorted it:</p>
			<pre class="source-code">Person2 p1 = new Person2(15, "Zoe", "Adams");</pre>
			<pre class="source-code">Person2 p2 = new Person2(25, "Nick", "Brook");</pre>
			<pre class="source-code">Person2 p3 = new Person2(42, "Nick", "Samoylov");</pre>
			<pre class="source-code">Person2 p4 = new Person2(50, "Ada", "Valentino");</pre>
			<pre class="source-code">Person2 p6 = new Person2(50, "Bob", "Avalon");</pre>
			<pre class="source-code">Person2 p5 = new Person2(10, "Zoe", "Adams");</pre>
			<pre class="source-code">List&lt;Person2&gt; list = </pre>
			<pre class="source-code">       new ArrayList&lt;&gt;(List.of(p5, p2, p6, p1, p4, p3));</pre>
			<pre class="source-code">Collections.sort(list);</pre>
			<pre class="source-code">list.stream().forEach(System.out::println); </pre>
			<p>The result looks as follows:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B18388_Figure_17.1.jpg" alt=""/>
				</div>
			</div>
			<p>There are three things worth noting:</p>
			<ul>
				<li>According to the <strong class="source-inline">Comparable</strong> interface, the <strong class="source-inline">compareTo()</strong> method must return a negative integer, zero, or a positive integer if the object is less than, equal to, or greater than another object. In our implementation, we returned the result immediately if the values of the same property of two objects were different. We already know that this object is <em class="italic">bigger</em> or <em class="italic">smaller</em>, regardless of what the other properties are. But the sequence in which you compare the properties of two objects, affects the final result. It defines the precedence in which the property value affects the order.</li>
				<li>We have put the result of <strong class="source-inline">List.of()</strong> into a <strong class="source-inline">new ArrayList()</strong> object. We did so because, as we mentioned in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>, the collection that’s created by the <strong class="source-inline">of()</strong> factory method is unmodifiable. No elements can be added or removed from it and the order of the elements cannot be changed either, while we need to sort the created collection. We only used the <strong class="source-inline">of()</strong> method because it is more convenient and provides a shorter notation. </li>
				<li>Finally, using <strong class="source-inline">java.util.Objects</strong> for comparing properties makes the implementation much easier and more reliable than custom coding.</li>
			</ul>
			<p>While<a id="_idIndexMarker1950"/> implementing the <strong class="source-inline">compareTo()</strong> method, it is important to make sure that the following rules are not violated:</p>
			<ul>
				<li><strong class="source-inline">obj1.compareTo(obj2)</strong> returns the same value as <strong class="source-inline">obj2.compareTo(obj1)</strong>, but only when the returned value is <strong class="source-inline">0</strong>.</li>
				<li>If the returned value is not <strong class="source-inline">0</strong>, <strong class="source-inline">obj1.compareTo(obj2)</strong> has the opposite sign of <strong class="source-inline">obj2.compareTo(obj1)</strong>.</li>
				<li>If <strong class="source-inline">obj1.compareTo(obj2) &gt; 0</strong> and <strong class="source-inline">obj2.compareTo(obj3) &gt; 0</strong>, then <strong class="source-inline">obj1.compareTo(obj3) &gt; 0</strong>.</li>
				<li>If <strong class="source-inline">obj1.compareTo(obj2) &lt; 0</strong> and <strong class="source-inline">obj2.compareTo(obj3) &lt; 0</strong>, then <strong class="source-inline">obj1.compareTo(obj3) &lt; 0</strong>.</li>
				<li>If <strong class="source-inline">obj1.compareTo(obj2) == 0</strong>, then <strong class="source-inline">obj2.compareTo(obj3)</strong> and <strong class="source-inline">obj1.compareTo(obj3) &gt; 0</strong> have the same sign.</li>
				<li>Both <strong class="source-inline">obj1.compareTo(obj2)</strong> and <strong class="source-inline">obj2.compareTo(obj1)</strong> throw the same exceptions, if any.</li>
			</ul>
			<p>It is also <a id="_idIndexMarker1951"/>recommended, but not always required, that if <strong class="source-inline">obj1.equals(obj2)</strong>, then <strong class="source-inline">obj1.compareTo(obj2) == 0</strong> and, at the same time, if <strong class="source-inline">obj1.compareTo(obj2) == 0</strong>, then <strong class="source-inline">obj1.equals(obj2)</strong>.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor361"/>The clone() method</h2>
			<p>The <strong class="source-inline">clone()</strong> method’s <a id="_idIndexMarker1952"/>implementation in the <strong class="source-inline">java.lang.Object</strong> class looks like this:</p>
			<pre class="source-code">@HotSpotIntrinsicCandidate</pre>
			<pre class="source-code">protected native Object clone() throws CloneNotSupportedException;</pre>
			<p>The comment shown in the preceding code states the following:</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code"> * Creates and returns a copy of this object.  The precise </pre>
			<pre class="source-code"> * meaning of "copy" may depend on the class of the object.</pre>
			<pre class="source-code"> ***/</pre>
			<p>The default result of this method returns a copy of the object fields as-is, which is fine if the values are of primitive types. However, if an object property holds a reference to another object, only the reference itself will be copied, not the referred object. That is why such a copy is <a id="_idIndexMarker1953"/>called a <strong class="bold">shallow copy</strong>. To get a <strong class="bold">deep copy</strong>, you must override the <strong class="source-inline">clone()</strong> method and clone each of the object<a id="_idIndexMarker1954"/> properties that refers to an object. </p>
			<p>In any case, to be able to clone an object, it must implement the <strong class="source-inline">Cloneable</strong> interface and make sure that all the objects along the inheritance tree (and the properties that are objects) implement the <strong class="source-inline">Cloneable</strong> interface too (except the <strong class="source-inline">java.lang.Object</strong> class). The <strong class="source-inline">Cloneable</strong> interface is just a marker interface that tells the compiler that the programmer made a conscious decision to allow this object to be cloned (whether it’s because the shallow copy was good enough or because the <strong class="source-inline">clone()</strong> method was overridden). An attempt to call <strong class="source-inline">clone()</strong> on an object that does not implement the <strong class="source-inline">Cloneable</strong> interface will result in a <strong class="source-inline">CloneNotSupportedException</strong>.</p>
			<p>It looks complex already, but in practice, there are even more pitfalls. For example, let’s say that the <strong class="source-inline">Person</strong> class has an <strong class="source-inline">address</strong> property of the <strong class="source-inline">Address</strong> type. The shallow copy, <strong class="source-inline">p2</strong>, of the <strong class="source-inline">Person</strong> object, <strong class="source-inline">p1</strong>, will refer to the same object of <strong class="source-inline">Address</strong> so that <strong class="source-inline">p1.address == p2.address</strong>. Here is an example. The <strong class="source-inline">Address</strong> class looks as follows:</p>
			<pre class="source-code">  class Address {</pre>
			<pre class="source-code">    private String street, city;</pre>
			<pre class="source-code">    public Address(String street, String city) {</pre>
			<pre class="source-code">        this.street = street;</pre>
			<pre class="source-code">        this.city = city;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setStreet(String street){ </pre>
			<pre class="source-code">                                        this.street = street; }</pre>
			<pre class="source-code">    public String getStreet() { return street; }</pre>
			<pre class="source-code">    public String getCity() { return city; }</pre>
			<pre class="source-code">  }</pre>
			<p>The <strong class="source-inline">Person3</strong> class <a id="_idIndexMarker1955"/>uses it like this:</p>
			<pre class="source-code">  class Person3 implements Cloneable{</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private Address address;</pre>
			<pre class="source-code">    private String firstName, lastName;</pre>
			<pre class="source-code">    public Person3(int age, String firstName, </pre>
			<pre class="source-code">                            String lastName, Address address) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.address = address;</pre>
			<pre class="source-code">        this.lastName = lastName;</pre>
			<pre class="source-code">        this.firstName = firstName;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge() { return age; }</pre>
			<pre class="source-code">    public Address getAddress() { return address; }</pre>
			<pre class="source-code">    public String getLastName() { return lastName; }</pre>
			<pre class="source-code">    public String getFirstName() { return firstName; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public Person3 clone() throws CloneNotSupportedException{</pre>
			<pre class="source-code">        return (Person3) super.clone();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<p>Notice that the <strong class="source-inline">clone()</strong> method <a id="_idIndexMarker1956"/>does a shallow copy because it does not clone the <strong class="source-inline">address</strong> property. Here is the result of using such a <strong class="source-inline">clone()</strong> method implementation:</p>
			<pre class="source-code">Person3 p1 = new Person3(42, "Nick", "Samoylov",</pre>
			<pre class="source-code">                      new Address("25 Main Street", "Denver"));</pre>
			<pre class="source-code">Person3 p2 = p1.clone();</pre>
			<pre class="source-code">System.out.println(p1.getAge() == p2.getAge());</pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName() == p2.getLastName()); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName().equals(p2.getLastName())); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getAddress() == p2.getAddress());   </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet());  </pre>
			<pre class="source-code">                                       //prints: 25 Main Street</pre>
			<pre class="source-code">p1.getAddress().setStreet("42 Dead End");</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet());  </pre>
			<pre class="source-code">                                          //prints: 42 Dead End</pre>
			<p>As you can see, after the cloning is complete, the change that was made to the <strong class="source-inline">address</strong> property<a id="_idIndexMarker1957"/> of the source object is reflected in the same property of the clone. That isn’t very intuitive, is it? While cloning, we expected an independent copy, didn’t we? </p>
			<p>To avoid sharing the <strong class="source-inline">Address</strong> object, you must clone it explicitly too. To do so, you must make the <strong class="source-inline">Address</strong> object cloneable, as follows:</p>
			<pre class="source-code">  public class Address implements Cloneable{</pre>
			<pre class="source-code">    private String street, city;</pre>
			<pre class="source-code">    public Address(String street, String city) {</pre>
			<pre class="source-code">        this.street = street;</pre>
			<pre class="source-code">        this.city = city;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setStreet(String street){ </pre>
			<pre class="source-code">                                        this.street = street; }</pre>
			<pre class="source-code">    public String getStreet() { return street; }</pre>
			<pre class="source-code">    public String getCity() { return city; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public Address clone() throws CloneNotSupportedException {</pre>
			<pre class="source-code">        return (Address)super.clone();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<p>With that implementation in place, we can now add the <strong class="source-inline">address</strong> property for cloning:</p>
			<pre class="source-code">  class Person4 implements Cloneable{</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private Address address;</pre>
			<pre class="source-code">    private String firstName, lastName;</pre>
			<pre class="source-code">    public Person4(int age, String firstName, </pre>
			<pre class="source-code">                            String lastName, Address address) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.address = address;</pre>
			<pre class="source-code">        this.lastName = lastName;</pre>
			<pre class="source-code">        this.firstName = firstName;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getAge() { return age; }</pre>
			<pre class="source-code">    public Address getAddress() { return address; }</pre>
			<pre class="source-code">    public String getLastName() { return lastName; }</pre>
			<pre class="source-code">    public String getFirstName() { return firstName; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public Person4 clone() throws CloneNotSupportedException{</pre>
			<pre class="source-code">        Person4 cl = (Person4) super.clone();</pre>
			<pre class="source-code"><strong class="bold">        cl.address = this.address.clone();</strong></pre>
			<pre class="source-code">        return cl;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<p>Now, if we run the <a id="_idIndexMarker1958"/>same test, the results are going to be as we expected them originally:</p>
			<pre class="source-code">Person4 p1 = new Person4(42, "Nick", "Samoylov",</pre>
			<pre class="source-code">                      new Address("25 Main Street", "Denver"));</pre>
			<pre class="source-code">Person4 p2 = p1.clone();</pre>
			<pre class="source-code">System.out.println(p1.getAge() == p2.getAge());         // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName() == p2.getLastName()); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName().equals(p2.getLastName())); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getAddress() == p2.getAddress());  </pre>
			<pre class="source-code">                                                       // false</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet()); </pre>
			<pre class="source-code">                                       //prints: 25 Main Street</pre>
			<pre class="source-code">p1.getAddress().setStreet("42 Dead End");</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet()); </pre>
			<pre class="source-code">                                       //prints: 25 Main Street</pre>
			<p>So, if the application expects all the properties to be deeply copied, all the objects involved must be cloneable. That is fine so long as none of the related objects, whether it’s a property in the current object or the parent class (and their properties and parents), do not acquire a new object property without making them cloneable and are cloned explicitly in<a id="_idIndexMarker1959"/> the <strong class="source-inline">clone()</strong> method of the container object. This last statement is complex. The reason for its complexity is due to the underlying complexity of the cloning process. That is why programmers often stay away from making objects cloneable.</p>
			<p>Instead, they prefer to clone the object manually, if need be, as shown in the following code:</p>
			<pre class="source-code">Person4 p1 = new Person4(42, "Nick", "Samoylov",</pre>
			<pre class="source-code">                      new Address("25 Main Street", "Denver"));</pre>
			<pre class="source-code">Address address = new Address(p1.getAddress().getStreet(), </pre>
			<pre class="source-code">                                    p1.getAddress().getCity());</pre>
			<pre class="source-code">Person4 p2 = new Person4(p1.getAge(), p1.getFirstName(), </pre>
			<pre class="source-code">                                    p1.getLastName(), address);</pre>
			<pre class="source-code">System.out.println(p1.getAge() == p2.getAge());</pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName() == p2.getLastName()); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getLastName().equals(p2.getLastName())); </pre>
			<pre class="source-code">                                                        // true</pre>
			<pre class="source-code">System.out.println(p1.getAddress() == p2.getAddress());// false</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet()); </pre>
			<pre class="source-code">                                       //prints: 25 Main Street</pre>
			<pre class="source-code">p1.getAddress().setStreet("42 Dead End");</pre>
			<pre class="source-code">System.out.println(p2.getAddress().getStreet()); </pre>
			<pre class="source-code">                                       //prints: 25 Main Street</pre>
			<p>This approach still requires code changes if another property is added to any related object. However, it provides more <a id="_idIndexMarker1960"/>control over the result and has less chance of unexpected consequences.</p>
			<p>Fortunately, the <strong class="source-inline">clone()</strong> method is not used very often. You may never encounter a need to use it.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor362"/>The StringBuffer and StringBuilder classes</h2>
			<p>We <a id="_idIndexMarker1961"/>talked about the <a id="_idIndexMarker1962"/>difference between the <strong class="source-inline">StringBuffer</strong> and <strong class="source-inline">StringBuilder</strong> classes in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>. We are not going to repeat this here. Instead, we will just mention that, in a single-threaded process (which is the vast majority of cases), the <strong class="source-inline">StringBuilder</strong> class is the preferred choice because it is faster.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor363"/>The try, catch, and finally clauses</h2>
			<p><a href="B18388_04_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>, <em class="italic">Exception Handling</em>, is <a id="_idIndexMarker1963"/>dedicated to using the <strong class="source-inline">try</strong>, <strong class="source-inline">catch</strong>, and <strong class="source-inline">finally</strong> clauses, so<a id="_idIndexMarker1964"/> we are not going to repeat this here. We would like<a id="_idIndexMarker1965"/> to repeat that using a <strong class="source-inline">try-with-resources</strong> statement is the preferred way to release resources (traditionally done in a <strong class="source-inline">finally</strong> block). Deferring the library makes the code simpler and more reliable.</p>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor364"/>Best design practices</h1>
			<p>The term <em class="italic">best</em> is often<a id="_idIndexMarker1966"/> subjective and context-dependent. That is why we would like to disclose that the following recommendations are based on the vast majority of cases in mainstream programming. However, they should not be followed blindly and unconditionally because there are cases when some of these practices, in some contexts, are useless or even wrong. Before following them, try to understand the motivation behind them and use it as a guide for your decisions. For example, size matters. If the application is not going to grow beyond a few thousand lines of code, a simple monolith with laundry-list-style code is good enough. But if there are complicated pockets of code and several people working on it, breaking the code into specialized pieces would be beneficial for code understanding, maintenance, and even scaling, if one particular code area requires more resources than others.</p>
			<p>We will start with higher-level design decisions in no particular order.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor365"/>Identifying loosely coupled functional areas</h2>
			<p>These design<a id="_idIndexMarker1967"/> decisions can be made very early on, based just on the general understanding of the main parts of the future system, their functionality, and the data they produce and exchange. There are several benefits of doing this:</p>
			<ul>
				<li>You can identify the structure of the future system, which has bearings on the further design steps and implementation</li>
				<li>You can specialize in and analyze parts deeply</li>
				<li>You can develop parts in parallel</li>
				<li>You can<a id="_idIndexMarker1968"/> have a better understanding of the data flow</li>
			</ul>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor366"/>Breaking the functional area into traditional tiers</h2>
			<p>With each<a id="_idIndexMarker1969"/> functional area in place, specializations based on the technical aspects and technologies can be used. The traditional separation of technical specialization is as follows:</p>
			<ul>
				<li>The frontend (user graphic or web interface)</li>
				<li>The middle tier with extensive business logic</li>
				<li>The backend (data storage or data source)</li>
			</ul>
			<p>The benefits of doing this include the following:</p>
			<ul>
				<li>You can deploy and scale by tiers</li>
				<li>You can gain programmer specialization based on your expertise</li>
				<li>You can develop parts in parallel</li>
			</ul>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor367"/>Coding to an interface</h2>
			<p>The specialized <a id="_idIndexMarker1970"/>parts, based on the decisions described in the previous two subsections, must be described in an interface that hides the implementation details. The benefits of such a design lie in the foundations of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and were described in detail in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>, so we are not going to repeat this here.</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor368"/>Using factories</h2>
			<p>We talked<a id="_idIndexMarker1971"/> about this in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>, too. An interface, by definition, does not and cannot describe the constructor of a class that implements the interface. Using factories allows you to close this gap and expose just an interface to a client.</p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor369"/>Preferring composition over inheritance</h2>
			<p>Originally, OOP <a id="_idIndexMarker1972"/>focused on inheritance as a way to share the common functionality between objects. Inheritance is even one of the four OOP principles, as we have described in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>. In practice, however, this method of functionality sharing creates too much dependency between classes included in the same inheritance line. The evolution of application functionality is often unpredictable, and some of the classes in the inheritance chain start to acquire functionality that’s unrelated to the original purpose of the class chain. We can argue that there are design solutions that allow us not to do this and keep the original classes intact. But, in practice, such things happen all the time, and the subclasses may suddenly change behavior just because they acquired new functionality through inheritance. We cannot choose our parents, can we? Besides, it breaks encapsulation this way, which is another foundational principle of OOP.</p>
			<p>Composition, on the other hand, allows us to choose and control which functionality of the class to use and which to ignore. It also allows the object to stay light and not be burdened by the inheritance. Such a design is more flexible, extensible, and predictable.</p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor370"/>Using libraries</h2>
			<p>Throughout<a id="_idIndexMarker1973"/> this book, we have mentioned that using the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>) and<a id="_idIndexMarker1974"/> external (to the <strong class="bold">Java Development Kit</strong> (<strong class="bold">JDK</strong>)) Java libraries makes programming much easier and produces code of higher quality. <a href="B18388_07_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 7</em></a>, <em class="italic">Java Standard and External Libraries</em>, contains an overview of the most popular Java libraries. People who create libraries invest a lot of time and effort, so you should take advantage of them any time you can.</p>
			<p>In <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>, we described standard functional interfaces that reside in the <strong class="source-inline">java.util.function</strong> package of JCL. That is another way to take advantage of a library – by using its set of well-known and shared interfaces, instead of defining your own.</p>
			<p>This last statement is a good segue to the next topic about writing code that can easily be understood by other people.</p>
			<h1 id="_idParaDest-372"><a id="_idTextAnchor371"/>Code is written for people</h1>
			<p>The <a id="_idIndexMarker1975"/>first decades of programming required writing machine commands so that electronic devices could execute them. Not only was it a tedious and error-prone endeavor, but it also required you to write the instructions in a manner that yielded the best performance possible. This is because the computers were slow and did not do much code optimization, if at all.</p>
			<p>Since then, we have made a lot of progress in terms of both hardware and programming. The modern compiler went a long way toward making the submitted code work as fast as possible, even when a programmer did not think about it. We talked about this with specific examples in the previous chapter. </p>
			<p>It allowed programmers to write more lines of code without thinking much about optimization. But tradition and many books about programming continued to call for it, and some programmers still worry about their code performance – more so than the results it produces. It is easier to follow tradition than to break away from it. That is why programmers tend to pay more attention to the way they write code than to the business they automate, although good code that implements incorrect business logic is useless.</p>
			<p>However, back to the topic. With modern JVM, the need for code optimization by a programmer is not as pressing as it used to be. Nowadays, a programmer must pay attention mostly to the big picture, to avoid structural mistakes that lead to poor code performance and to code that is used multiple times. The latter becomes less pressing as the JVM becomes more sophisticated, observing the code in real time, and just returning the results (without execution) when the same code block is called several times with the same input.</p>
			<p>That leaves us with the only conclusion possible – while writing code, you must make sure it is easy to read and understand for a human, not for a computer. Those who have worked in the industry for some time have been puzzled over code they wrote a few years prior. You can improve your code-writing style via clarity and the transparency<a id="_idIndexMarker1976"/> of its intent.</p>
			<p>Now, let’s discuss the need for comments. We do not need comments that echo what the code does, as shown in the following example:</p>
			<pre class="source-code">//Initialize variable</pre>
			<pre class="source-code">int i = 0;</pre>
			<p>The <a id="_idIndexMarker1977"/>comments that explain the intent are much more valuable:</p>
			<pre class="source-code">// In case of x &gt; 0, we are looking for a matching group </pre>
			<pre class="source-code">// because we would like to reuse the data from the account.</pre>
			<pre class="source-code">// If we find the matching group, we either cancel it and </pre>
			<pre class="source-code">// clone, or add the x value to the group, or bail out.</pre>
			<pre class="source-code">// If we do not find the matching group,</pre>
			<pre class="source-code">// we create a new group using data of the matched group.</pre>
			<p>The commented code can be very complex. Good comments explain the intent and provide guidance that helps us understand the code. Yet, programmers often do not bother to write comments. The argument against writing comments typically includes two statements:</p>
			<ul>
				<li>Comments must be maintained and evolve along with the code; otherwise, they may become misleading. However, no tool can prompt the programmer to adjust the comments along with changing the code. Thus, comments are dangerous.</li>
				<li>The code itself must be written (including name selection for variables and methods) so that no extra explanation is needed.</li>
			</ul>
			<p>Both statements <a id="_idIndexMarker1978"/>are true, but it is also true that comments can be very helpful, especially those that capture the intent. Besides, such comments tend to require fewer adjustments because the code intent doesn’t change often, if ever.</p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor372"/>Use well-established frameworks and libraries</h1>
			<p>Programmers<a id="_idIndexMarker1979"/> are not always given a chance to select the framework and libraries to develop the software. Often, the company prefers to stay with the set of software and development tools they have already used for other projects. But when you get such a possibility of choosing, the variety of available products may be overwhelming. It may also be tempting to select the latest new offer that is trending in the programming community. Nevertheless, experience proves time and again that the best course of action would be to select something well–established and proven to be production-strong. Besides, using solid software with a long history requires typically writing less boilerplate code.</p>
			<p>To demonstrate this point, we created two projects:</p>
			<ul>
				<li>Using the Spring Boot framework</li>
				<li>Using the <strong class="bold">Vert.x</strong> toolkit</li>
			</ul>
			<p>We start with <a id="_idIndexMarker1980"/>Spring Boot. It is an open source Java-based framework, developed by the Pivotal Team for building standalone production-strong applications. By default, it does not need an external web server, because it embeds a web server (Tomcat or Netty). As a result, the Spring Boot user does not need to write any non-business code. You don’t need even to create configuration, as in Spring. You just define which non-business features you need (such as health check, metrics, or swagger doc, for example) using the properties file and tune them using annotation. </p>
			<p>Naturally, because there is so much implemented behind the scenes, Spring Boot is very opinionated. But you would be hard-pressed to find a case when it cannot be used to produce a solid efficient application. Most probably, limitations of Spring Boot will manifest themselves in large-scale projects. The best approach for using Spring Boot is to embrace its way to do things, because by doing this you will save a lot of time and will get a robust and well-optimized solution.  </p>
			<p>To simplify <a id="_idIndexMarker1981"/>dependency management, Spring Boot provides the required third-party dependencies for each type of application in the so-called <strong class="source-inline">starter</strong> JAR file. For example, spring-boot-starter-web brings into the project all the libraries necessary for Spring MVC (Model-View-Controller) and the Tomcat web server. Based on the selected starter package, Spring Boot automatically configures the application. </p>
			<p>You can find comprehensive and well-written information for programmers of all levels – from beginners to experienced <a id="_idIndexMarker1982"/>professionals – at <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a>. If you plan to use Spring Boot in your line of work, we encourage you to read it.  </p>
			<p>To demonstrate Spring Boot capabilities and advantages, we created a project in the <strong class="source-inline">spring</strong> folder. To run this sample application, you need the database, created in <a href="B18388_10_ePub.xhtml#_idTextAnchor230"><em class="italic">Chapter 10</em></a>, <em class="italic">Managing Data in a Database, </em>of this book, up and running. The sample application manages (creates, reads, updates, deletes) records of persons in the database. This functionality is accessible via the UI (HTML pages), which is human-oriented. In addition, we implemented access to the same functionality via RESTful services, which can be used by other applications.  </p>
			<p>You can run the<a id="_idIndexMarker1983"/> application from an IDE by executing <a id="_idIndexMarker1984"/>the <strong class="source-inline">Application</strong> class. Alternatively, you can start the application from the command line. There are two command files in the <strong class="source-inline">spring</strong> folder: <strong class="source-inline">mvnw</strong> (for Unix/Linux/Mac systems) and <strong class="source-inline">mvnw.cmd </strong>(for Windows). They can be used to launch the application as follows: </p>
			<ul>
				<li>For Unix/Linux/Mac systems:   <p class="source-code">./mvnw spring-boot:run </p></li>
				<li>For Windows:  <p class="source-code">.\mvnw.cmd spring-boot:run </p></li>
			</ul>
			<p>When you do it the first time, you may get an error:  </p>
			<pre class="source-code">java.lang.ClassNotFoundException: org.apache.maven.wrapper.MavenWrapperMain </pre>
			<p>If that happens, install the Maven wrapper by executing the following command: </p>
			<p class="source-code">mvn -N io.takari:maven:wrapper </p>
			<p>Alternatively, you can build the executable <strong class="source-inline">.jar</strong> file:  </p>
			<ul>
				<li>For Unix/Linux/Mac systems:   <p class="source-code">./mvnw clean package </p></li>
				<li>For Windows:  <p class="source-code">.\mvnw.cmd clean package </p></li>
			</ul>
			<p>Then you can put the created <strong class="source-inline">.jar</strong> file on any computer that has Java 17 installed and run it, using the following command: </p>
			<p class="source-code">java -jar target/spring-0.0.1-SNAPSHOT.jar </p>
			<p>After the application is running, execute the following command: </p>
			<p class="source-code">curl –XPOST localhost:8083/ws/new                  \ </p>
			<p class="source-code">       -H 'Content-Type: application/json'         \ </p>
			<p class="source-code">       -d '{"dob":"2002-08-14",                    \ </p>
			<p class="source-code">            "firstName":"Mike","lastName":"Brown"}' </p>
			<p>The <strong class="source-inline">curl</strong> command requires the application to create a new person record. The expected response looks as follows (the <strong class="source-inline">id</strong> value will be different every time you run this command): </p>
			<p class="source-code">  Person{id=42, dob=2002-08-14, firstName='Mike', </p>
			<p class="source-code">                        lastName='Brown'} successfully updated. </p>
			<p>To see the<a id="_idIndexMarker1985"/> HTTP code in the response, add the<a id="_idIndexMarker1986"/> option <strong class="source-inline">-v</strong> to the command. The HTTP code 200 indicates successful processing of the request.</p>
			<p>Now let’s execute the <strong class="source-inline">update</strong> command: </p>
			<p class="source-code">curl –XPUT localhost:8083/ws/update              \ </p>
			<p class="source-code">   -H 'Content-Type: application/json'           \ </p>
			<p class="source-code">   -d '{"id":42,"dob":"2002-08-14",              \ </p>
			<p class="source-code">            "firstName":"Nick","lastName":"Brown"}' </p>
			<p>The application responds to this command as follows: </p>
			<pre class="source-code">  Person{id=42, dob=2002-08-14, firstName='Nick', </pre>
			<pre class="source-code">                        lastName='Brown'} successfully updated. </pre>
			<p>Notice that not all fields in the payload have to be populated. Only the <strong class="source-inline">id</strong> value is required and has to match with one of the existing records. The application retrieves the current <strong class="source-inline">Person</strong> record by the provided <strong class="source-inline">id</strong> value and updates only those properties that are provided.</p>
			<p>The <strong class="source-inline">delete</strong> endpoint is similarly constructed. The difference is that the data (the <strong class="source-inline">Person</strong> record identity number <strong class="source-inline">id</strong>) is passed as part of the URL. Now let’s execute the following command: </p>
			<p class="source-code"> </p>
			<p class="source-code">curl localhost:8083/ws/delete/1 </p>
			<p class="source-code"> </p>
			<p>The application responds to this command with the following message: </p>
			<pre class="source-code">  Person{id=42, dob=2002-08-14, firstName='Nick', </pre>
			<pre class="source-code">                        lastName='Brown'} successfully deleted. </pre>
			<pre class="source-code"> </pre>
			<p>The list of all <a id="_idIndexMarker1987"/>the existing records can be retrieved with <a id="_idIndexMarker1988"/>the following command: </p>
			<pre class="source-code">curl localhost:8083/ws/list </pre>
			<p>All the preceding functionalities can be accessed via the UI. Type in the browser the URL <strong class="source-inline">http://localhost:8083/ui/list</strong> and click the corresponding links. </p>
			<p>You can also type <strong class="source-inline">http://localhost:8083</strong> in the browser URL and access the following page: </p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B18388_Figure_17.2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p>Then again, click any of the available links. The <strong class="source-inline">Home</strong> page presents information about the current application version and its heath. The <strong class="source-inline">http://localhost:8083/swagger-ui.html</strong> URL brings up the list of all the application endoints.</p>
			<p>We highly encourage you to study the application code and read the Spring Boot documentation on the <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a> website.</p>
			<p>Now let us look in the project in the <strong class="source-inline">reactive</strong> folder. It demonstrates the reactive methods of communication, using Vert.x, which is an event-driven non-blocking lightweight polyglot toolkit. It allows you to write components in Java, JavaScript, Groovy, Ruby, Scala, Kotlin, and Ceylon. It supports an asynchronous programming model and a distributed event bus that reaches into the JavaScript browser, thus allowing the creation of real-time web applications. However, because of the focus of this book, we are going to use Java only.</p>
			<p>To demonstrate how a reactive system of <a id="_idIndexMarker1989"/>microservices may look if implemented using the <strong class="bold">Vert</strong>.x toolkit, we<a id="_idIndexMarker1990"/> have created an HTTP server that can accept a REST-based request to the system, send an EventBus-based message to another <em class="italic">verticle</em> (the fundamental processing unit in the <strong class="bold">Vert</strong>.x toolkit that can be deployed), receive a reply, and send the response back to the original request. </p>
			<p>We created two verticles: </p>
			<ul>
				<li><strong class="source-inline">HttpServerVert</strong>, which acts as a server and receives HTTP messages, which then sends them to a particular address via the EventBus(a lightweight distributed messaging system)</li>
				<li><strong class="source-inline">MessageRcvVert</strong>, which <a id="_idIndexMarker1991"/>listens messages<a id="_idIndexMarker1992"/> on a particular event-bus address</li>
			</ul>
			<p>Now we can deploy them as follows:</p>
			<pre class="source-code">public class ReactiveSystemDemo { </pre>
			<pre class="source-code">   public static void main(String... args) { </pre>
			<pre class="source-code">     Vertx vertx = Vertx.vertx(); </pre>
			<pre class="source-code">     RxHelper.deployVerticle(vertx,  </pre>
			<pre class="source-code">                    new MessageRcvVert("1", "One")); </pre>
			<pre class="source-code">     RxHelper.deployVerticle(vertx,  </pre>
			<pre class="source-code">                    new MessageRcvVert("2", "One")); </pre>
			<pre class="source-code">     RxHelper.deployVerticle(vertx,  </pre>
			<pre class="source-code">                    new MessageRcvVert("3", "Two")); </pre>
			<pre class="source-code">     RxHelper.deployVerticle(vertx, </pre>
			<pre class="source-code">                    new HttpServerVert(8082)); </pre>
			<pre class="source-code">   } </pre>
			<pre class="source-code"> } </pre>
			<p>To execute this code, run the <strong class="source-inline">ReactiveSystemDemo</strong> class. The result is expected to be as follows:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B18388_Figure_17.3.jpg" alt=""/>
				</div>
			</div>
			<p>Let’s now start sending HTTP requests to our system. First, let’s send the same HTTP <strong class="source-inline">GET</strong> request three times: </p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B18388_Figure_17.4.jpg" alt=""/>
				</div>
			</div>
			<p>If there are<a id="_idIndexMarker1993"/> several verticles registered with <a id="_idIndexMarker1994"/>the same address (as it is in our case: we have registered two verticles with the same <strong class="source-inline">One</strong> address), the system uses a round-robin algorithm to select the verticle that should receive the next message. </p>
			<p>The first request went to the receiver with <strong class="source-inline">ID="1"</strong>, the second request went to the receiver with <strong class="source-inline">ID="2"</strong>, and the third request went to the receiver with <strong class="source-inline">ID="1"</strong> again. </p>
			<p>We get the same results using the HTTP <strong class="source-inline">POST</strong> request for the <strong class="source-inline">/some/path/send</strong> path:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B18388_Figure_17.5.jpg" alt=""/>
				</div>
			</div>
			<p>Again, the receiver of the message is rotated using the round-robin algorithm. Now, let’s publish a message to our system twice. </p>
			<p>Since the receiver’s reply cannot propagate back to the system user, we need to take a look at the messages that are logged on the backend: </p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B18388_Figure_17.6.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, the <strong class="source-inline">publish()</strong> method sends the message to all verticles that are registered to the<a id="_idIndexMarker1995"/> specified address. And note that the<a id="_idIndexMarker1996"/> verticle with <strong class="source-inline">ID="3"</strong> (registered with the <strong class="source-inline">Two</strong> address) never received a message. </p>
			<p>Before we wrap up this reactive system demonstration, it is worth mentioning that the <strong class="bold">Vert.x</strong> toolkit allows you<a id="_idIndexMarker1997"/> to easily cluster verticles. You can read about this feature in the <strong class="bold">Vert.x</strong> documentation at <a href="https://vertx.io/docs/vertx-core/java">https://vertx.io/docs/vertx-core/java</a>. </p>
			<p>These two examples demonstrated how little code you have to write in order to create a complete web application if you use a well-established framework. It does not mean that you cannot explore the latest and greatest of frameworks. By any means, you can and should do it to stay abreast with progress in your industry. Just keep in mind that it takes some time for a new product to mature and become reliable and helpful enough for creating a production-strong software solution.  </p>
			<h1 id="_idParaDest-374"><a id="_idTextAnchor373"/>Testing is the shortest path to quality code</h1>
			<p>The last best practice <a id="_idIndexMarker1998"/>we will discuss is this statement: <em class="italic">testing is not an overhead or a burden; it is the programmer’s guide to success</em>. The only question is when to write the test. </p>
			<p>There is a compelling argument that requires writing a test before any line of code is written. If you can do it, that is great. We are not going to try and talk you out of it. But if you do not do it, try to start writing a test after you have written one, or all, the lines of code you have been tasked to write.</p>
			<p>In practice, many experienced programmers find it helpful to start writing testing code after some of the new functionality is implemented. This is because that is when the programmer understands better how the new code fits into the existing context. They may even try and hardcode some values to see how well the new code is integrated with the code that calls the new method. After making sure the new code is well integrated, the programmer can continue implementing and tuning it, all while testing the new implementation against the requirements in the context of the calling code.</p>
			<p>One important qualification must be added – while writing the <a id="_idIndexMarker1999"/>test, it is better if the input data and the test criteria are set not by you, but by the person who assigned you the task or the tester. Setting the test according to the results the code produces is a well-known programmer’s trap. Objective self-assessment is not easy, if at all possible. </p>
			<h1 id="_idParaDest-375"><a id="_idTextAnchor374"/>Summary</h1>
			<p>In this chapter, we discussed the Java idioms that a mainstream programmer encounters daily. We also discussed the best design practices and related recommendations, including code-writing styles and testing.</p>
			<p>You also learned about the most popular Java idioms related to certain features, functionalities, and design solutions. These idioms were demonstrated with practical examples, where you learned how to incorporate them into your code and the professional language that’s used to communicate with other programmers.</p>
			<p>This chapter concludes this book about Java 17 and its usage for writing effective application code. If you have read all of it, then you should have a very good overview of this topic and acquired valuable programming knowledge and skills you can immediately apply professionally. If you found this material valuable, then it makes us happy to know that we have achieved our goal. Thank you for reading. </p>
			<h1 id="_idParaDest-376"><a id="_idTextAnchor375"/>Quiz</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li>Select all the correct statements:<ol><li>Idioms can be used to communicate the code’s intent.</li><li>Idioms can be used to explain what the code does.</li><li>Idioms can be misused and obscure the topic of conversation.</li><li>Idioms should be avoided to express the idea clearly.</li></ol></li>
				<li>Is it necessary to implement <strong class="source-inline">hasCode()</strong> every time <strong class="source-inline">equals()</strong> is implemented?</li>
				<li>If <strong class="source-inline">obj1.compareTo(obj2)</strong> returns a negative value, what does this mean?</li>
				<li>Does the deep copy notion apply to a primitive value during cloning?</li>
				<li>Which is faster, <strong class="source-inline">StringBuffer</strong> or <strong class="source-inline">StringBuilder</strong>?</li>
				<li>What are the benefits of coding to an interface?</li>
				<li>What are the benefits of using composition versus inheritance?</li>
				<li>What is the advantage of using libraries versus writing your own code?</li>
				<li>Who is the target audience of your code?</li>
				<li>Is testing required?</li>
			</ol>
		</div>
	</body></html>