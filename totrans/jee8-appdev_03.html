<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Object Relational Mapping with the Java Persistence API</h1>
                </header>
            
            <article>
                
<p>Any non-trivial Java EE application will persist data to a relational database. In this chapter, we will cover how to connect to a database and perform CRUD (Create, Read, Update, Delete) <span>operations</span><span>.</span></p>
<p>The <strong>Java Persistence API</strong> (<strong>JPA</strong>) is the standard Java EE <strong>Object Relational Mapping</strong> (<strong>ORM</strong>) tool. We will discuss this API in detail in this chapter.</p>
<p>Some of the topics covered in this chapter include:</p>
<ul>
<li>Retrieving data from a database through JPA</li>
<li>Inserting data into a database through JPA</li>
<li>Updating data in a database through JPA</li>
<li>Deleting data in a database through JPA</li>
<li>Building queries programmatically through the JPA Criteria API</li>
<li>Automating data validation through JPA 2.0's Bean Validation support</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Customer database</h1>
                </header>
            
            <article>
                
<p>Examples in this chapter will use a database called <kbd>CUSTOMERDB</kbd>. This database contains tables to track customer and order information for a fictitious store. The database uses JavaDB for its RDBMS, since it comes bundled with GlassFish, but it can be easily adapted to any other RDBMS.</p>
<p>A script is included with this book's code download to create this database and pre-populate some of its tables. Instructions on how to execute the script, and add a connection pool and data source to access it are included in the download as well.</p>
<p>The schema for the <kbd>CUSTOMERDB</kbd> database is depicted in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/44c73028-7fc2-4764-9968-89f35310ae54.png"/></div>
<p>As can be seen in the diagram, the database contains tables to store customer information such as name, address, and email address. It also contains tables to store order and item information.</p>
<p class="mce-root">The <kbd>ADDRESS_TYPES</kbd> table will store values such as "Home", "Mailing", and "Shipping", to distinguish the type of address in the <kbd>ADDRESSES</kbd> table; similarly, the <kbd>TELEPHONE_TYPES</kbd> table stores the "Cell", "Home", and "Work" <span>values.</span> These two tables are prepopulated when creating the database, as well as the <kbd>US_STATES</kbd> table.</p>
<div class="packt_infobox">For simplicity, our database only deals with U.S. addresses.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Java Persistence API</h1>
                </header>
            
            <article>
                
<p><span class="URLPACKT">The</span> <strong>Java Persistence API (JPA)</strong> <span class="URLPACKT">was introduced to Java EE in version 5 of the specification. Like its name implies, it is used to persist data to a relational database management system. JPA is a replacement for the Entity Beans that were used in J2EE. Java EE Entities are regular Java classes; the Java EE container knows these classes are Entities because they are decorated with the</span> <kbd>@Entity</kbd> <span class="URLPACKT">annotation. Let's look at an Entity mapping to the</span> <kbd>CUSTOMER</kbd> <span class="URLPACKT">table in the</span> <kbd>CUSTOMERDB</kbd> <span class="URLPACKT">database:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jpaintro.entity; 
 
import java.io.Serializable; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.Table; 
 
<strong>@Entity 
@Table(name = "CUSTOMERS")</strong> 
public class Customer implements Serializable 
{ 
  <strong>@Id 
  @Column(name = "CUSTOMER_ID")</strong> 
  private Long customerId; 
 
 <strong> @Column(name = "FIRST_NAME")</strong> 
  private String firstName; 
 
 <strong> @Column(name = "LAST_NAME")</strong> 
  private String lastName; 
 
  private String email; 
 
  public Long getCustomerId() 
  { 
    return customerId; 
  } 
  public void setCustomerId(Long customerId) 
  { 
    this.customerId = customerId; 
  } 
  public String getEmail() 
  { 
    return email; 
  } 
  public void setEmail(String email) 
  { 
    this.email = email; 
  } 
  public String getFirstName() 
  { 
    return firstName; 
  } 
  public void setFirstName(String firstName) 
  { 
    this.firstName = firstName; 
  } 
  public String getLastName() 
  { 
    return lastName; 
  } 
  public void setLastName(String lastName) 
  { 
    this.lastName = lastName; 
  } 
} </pre>
<p><span class="URLPACKT">In the preceding code, the</span> <kbd>@Entity</kbd> <span class="URLPACKT">annotation lets any other Java EE-compliant application server know that this class is a JPA entity.</span></p>
<p><span class="URLPACKT">The</span> <kbd>@Table(name = "CUSTOMERS")</kbd> <span class="URLPACKT">annotation lets the application server know what table to map the entity to. The value of the</span> <kbd>name</kbd> <span class="URLPACKT">element contains the name of the database table that the entity maps to. This annotation is optional; if the name of the class maps the name of the database table, then it isn't necessary to specify what table the entity maps to.</span></p>
<p><span class="URLPACKT">The</span> <kbd>@Id</kbd> <span class="URLPACKT">annotation indicates that the</span> <kbd>customerId</kbd> <span class="URLPACKT">field maps to the primary key.</span></p>
<p><span class="URLPACKT">The</span> <kbd>@Column</kbd> <span class="URLPACKT">annotation maps each field to a column in the table. If the name of the field matches the name of the database column, then this annotation is not needed. This is the reason why the</span> <kbd>email</kbd> <span class="URLPACKT">field is not annotated.</span></p>
<p><span class="URLPACKT">The</span> <kbd>EntityManager</kbd> <span class="URLPACKT">class (this is actually an interface; each Java EE compliant application server provides its own implementation) is used to persist entities to a database. The following example illustrates its usage:</span></p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jpaintro.namedbean; 
 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.transaction.HeuristicMixedException; 
import javax.transaction.HeuristicRollbackException; 
import javax.transaction.NotSupportedException; 
import javax.transaction.RollbackException; 
import javax.transaction.SystemException; 
import javax.transaction.UserTransaction; 
import net.ensode.javaee8book.jpaintro.entity.Customer; 
 
@Named 
@RequestScoped 
public class JpaDemoBean { 
 
<strong>    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction;</strong> 
 
    public String updateDatabase() { 
 
        String retVal = "confirmation"; 
 
        Customer customer = new Customer(); 
        Customer customer2 = new Customer(); 
        Customer customer3; 
 
        customer.setCustomerId(3L); 
        customer.setFirstName("James"); 
        customer.setLastName("McKenzie"); 
        customer.setEmail("jamesm@notreal.com"); 
 
        customer2.setCustomerId(4L); 
        customer2.setFirstName("Charles"); 
        customer2.setLastName("Jonson"); 
        customer2.setEmail("cjohnson@phony.org"); 
 
        try { 
            <strong>userTransaction.begin(); 
            entityManager.persist(customer); 
            entityManager.persist(customer2); 
            customer3 = entityManager.find(Customer.class, 4L); 
            customer3.setLastName("Johnson"); 
            entityManager.persist(customer3); 
            entityManager.remove(customer);</strong> 
 
          <strong>  userTransaction.commit();</strong> 
        } catch (HeuristicMixedException | 
                HeuristicRollbackException | 
                IllegalStateException | 
                NotSupportedException | 
                RollbackException | 
                SecurityException | 
                SystemException e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
} </pre>
<p>The preceding CDI named bean obtains an instance of a class implementing the <kbd>javax.persistence.EntityManager</kbd> <span class="URLPACKT">interface via dependency injection. This is done by decorating the</span> <kbd>EntityManager</kbd> <span class="URLPACKT">variable with the</span> <kbd>@PersistenceContext</kbd> <span class="URLPACKT">annotation.</span></p>
<p><span class="URLPACKT">An instance of a class implementing the</span> <kbd>javax.transaction.UserTransaction</kbd> <span class="URLPACKT">interface is then injected via the</span> <kbd>@Resource</kbd> <span class="URLPACKT">annotation. This object is necessary, since, without it invoking calls to persist Entities to the database, the code would throw a</span> <kbd>javax.persistence.TransactionRequiredException</kbd> <span class="URLPACKT">.</span></p>
<p><kbd>EntityManager</kbd> <span class="URLPACKT">performs many database-related tasks, such as finding entities in the database, updating them, or deleting them.</span></p>
<p><span class="URLPACKT">Since JPA Entities are</span> <strong>plain old Java objects</strong> <span class="URLPACKT">(</span> <strong>POJOs</strong> <span class="URLPACKT">), they can be instantiated via the</span> <kbd>new</kbd> <span class="URLPACKT">operator.</span></p>
<div class="packt_infobox"><span class="URLPACKT">The call to the</span> <kbd>setCustomerId()</kbd> <span class="URLPACKT">method takes advantage of autoboxing, a feature added to the Java language in JDK 1.5. Notice that the method takes an instance of</span> <kbd>java.lang.Long</kbd> <span class="URLPACKT">as its parameter, but we are using</span> <kbd>long</kbd> <span class="URLPACKT">primitives. The code compiles and executes properly thanks to this feature.</span></div>
<p><span class="URLPACKT">Calls to the</span> <kbd>persist()</kbd> <span class="URLPACKT">method on</span> <kbd>EntityManager</kbd> <span class="URLPACKT">must be in a transaction, therefore it is necessary to start one by calling the</span> <kbd>begin()</kbd> <span class="URLPACKT">method on</span> <kbd>UserTransaction</kbd>.</p>
<p><span class="URLPACKT">We then insert two new rows to the</span> <kbd>CUSTOMERS</kbd> <span class="URLPACKT">table by calling the</span> <kbd>persist()</kbd> <span class="URLPACKT">method on</span> <kbd>entityManager</kbd> <span class="URLPACKT">for the two instances of the <kbd>Customer</kbd> class we populated earlier in the code.</span></p>
<p><span class="URLPACKT">After persisting the data contained in the</span> <kbd>customer</kbd> <span class="URLPACKT">and</span> <kbd>customer2</kbd> <span class="URLPACKT">objects, we search the database for a row in the</span> <kbd>CUSTOMERS</kbd> <span class="URLPACKT">table with a primary key of four. We do this by invoking the</span> <kbd>find()</kbd> <span class="URLPACKT">method on</span> <kbd>entityManager</kbd><span class="URLPACKT">. This method takes the class of the Entity we are searching for as its first parameter, and the primary key of the row corresponding to the object we want to obtain. This method is roughly equivalent to the</span> <kbd>findByPrimaryKey()</kbd> <span class="URLPACKT">method on an entity bean's home interface.</span></p>
<p><span class="URLPACKT">The primary key we set for the</span> <kbd>customer2</kbd> <span class="URLPACKT">object was 4, therefore what we have now is a copy of this object. The last name for this customer was misspelled when we originally inserted his data into the database. We can now correct Mr. Johnson's last name by invoking the</span> <kbd>setLastName()</kbd> <span class="URLPACKT">method on</span> <kbd>customer3</kbd><span class="URLPACKT">, then we can update the information in the database by invoking</span> <kbd>entityManager.persist()</kbd><span class="URLPACKT">.</span></p>
<p><span class="URLPACKT">We then delete the information for the</span> <kbd>customer</kbd> <span class="URLPACKT">object by invoking</span> <kbd>entityManager.remove()</kbd> <span class="URLPACKT">and passing the</span> <kbd>customer</kbd> <span class="URLPACKT">object as a parameter.</span></p>
<p><span class="URLPACKT">Finally, we commit the changes to the database by invoking the</span> <kbd>commit()</kbd> <span class="URLPACKT">method on</span> <kbd>userTransaction</kbd><span class="URLPACKT">.</span></p>
<p><span class="URLPACKT">In order for the preceding code to work as expected, an XML configuration file named</span> <kbd>persistence.xml</kbd> <span class="URLPACKT">must be deployed in the WAR file containing the previously-named bean. This file must be placed in the</span> <kbd>WEB-INF/classes/META-INF/</kbd> <span class="URLPACKT">directory inside the WAR file. The contents of this file for the preceding code are shown here:</span></p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;persistence version="2.2"   xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd"&gt; 
  &lt;persistence-unit name="<a>customerPersistenceUnit</a>"&gt; 
    &lt;jta-data-source&gt;jdbc/__CustomerDBPool&lt;/jta-data-source&gt; 
  &lt;/persistence-unit&gt; 
&lt;/persistence&gt; </pre>
<p><kbd>persistence.xml</kbd> <span class="URLPACKT">must contain at least one</span> <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element. Each</span> <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element must provide a value for its</span> <kbd>name</kbd> <span class="URLPACKT">attribute and must contain a</span> <kbd>&lt;jta-data-source&gt;</kbd> <span class="URLPACKT">child element whose value is the JNDI name of the data source to be used for the persistence unit.</span></p>
<p>The reason more than one <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element is allowed is because an application may access more than one database. A</span> <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element is required for each database the application will access. If the application defines more than one</span> <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element, then the</span> <kbd>@PersistenceContext</kbd> <span class="URLPACKT">annotation used to inject</span> <kbd>EntityManager</kbd> <span class="URLPACKT">must provide a value for its</span> <kbd>unitName</kbd> <span class="URLPACKT">element; the value for this element must match the name attribute of the corresponding</span> <kbd>&lt;persistence-unit&gt;</kbd> <span class="URLPACKT">element in</span> <kbd>persistence.xml</kbd><span class="URLPACKT">.</span></p>
<div class="packt_tip"><span class="packt_screen"><span class="URLPACKT">Cannot persist detached object</span> Exception</span>: <span class="URLPACKT">Frequently, an application will retrieve a JPA entity via the</span> <kbd>EntityManager.find()</kbd> <span class="URLPACKT">method, then pass this entity to a business or user interface layer, where it will potentially be modified, and later the database data corresponding to the entity will be updated. In cases such as this, invoking</span> <kbd>EntityManager.persist()</kbd> <span class="URLPACKT">will result in an exception. In order to update JPA entities this way, we need to invoke</span> <kbd>EntityManager.merge()</kbd><span class="URLPACKT">. This method takes an instance of the JPA entity as its single argument and updates the corresponding row in the database with the data stored in it.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Entity relationships</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how to retrieve, insert, update, and delete single entities from the database. Entities are rarely isolated; in the vast majority of cases they are related to other entities.</p>
<p>Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.</p>
<p>In the <kbd><span class="NormalPACKTChar">CustomerDB</span></kbd> database, for example, there is a one-to-one relationship between the <kbd>LOGIN_INFO</kbd> and the <kbd>CUSTOMERS</kbd> tables. This means that each customer has exactly one corresponding row in the login info table. There is also a one-to-many relationship between the <kbd>CUSTOMERS</kbd> table and the <kbd>ORDERS</kbd> table. This is because a customer can place many orders, but each order belongs only to a single customer. Additionally, there is a many-to-many relationships between the <kbd>ORDERS</kbd> table and the <kbd>ITEMS</kbd> table. This is because an order can contain many items and an item can be on many orders.</p>
<p>In the next few sections, we will discuss how to establish relationships between JPA entities<span class="URLPACKT">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-to-one relationships</h1>
                </header>
            
            <article>
                
<p>One-to-one relationships occur when an instance of an entity can have zero or one corresponding instance of another entity.</p>
<p>One-to-one entity relationships can be bidirectional (each entity is aware of the relationship) or unidirectional (only one of the entities is aware of the relationship). In the <kbd>CUSTOMERDB</kbd> database, the one-to-one mapping between the <kbd>LOGIN_INFO</kbd> and the <kbd>CUSTOMERS</kbd> tables is unidirectional, since the <kbd>LOGIN_INFO</kbd> table has a foreign key to the <kbd>CUSTOMERS</kbd> table, but not the other way around. As we will soon see, this fact does not stop us from creating a bidirectional one-to-one relationship between the <kbd>Customer</kbd> entity and the <kbd>LoginInfo</kbd> entity.</p>
<p>The source code for the <kbd>LoginInfo</kbd> entity, which maps to the <kbd>LOGIN_INFO</kbd> table, can be seen here:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.JoinColumn; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "LOGIN_INFO") 
public class LoginInfo 
{ 
  @Id 
  @Column(name = "LOGIN_INFO_ID") 
  private Long loginInfoId; 
 
  @Column(name = "LOGIN_NAME") 
  private String loginName; 
 
  private String password; 
 
<strong>  @OneToOne</strong><strong>  <br/>  @JoinColumn(name="CUSTOMER_ID")</strong><strong> <br/>  private Customer customer;</strong> 
  public Long getLoginInfoId() 
  { 
    return loginInfoId; 
  } 
 
  public void setLoginInfoId(Long loginInfoId) 
  { 
    this.loginInfoId = loginInfoId; 
  } 
 
  public String getPassword() 
  { 
    return password; 
  } 
 
  public void setPassword(String password) 
  { 
    this.password = password; 
  } 
 
  public String getLoginName() 
  { 
    return loginName; 
  } 
 
  public void setLoginName(String userName) 
  { 
    this.loginName = userName; 
  } 
 
  public Customer getCustomer() 
  { 
    return customer; 
  } 
 
  public void setCustomer(Customer customer) 
  { 
    this.customer = customer; 
  } 
 
} </pre>
<p>The code for this entity is very similar to the code for the <kbd>Customer</kbd> entity. It defines fields that map to database columns. Each field whose name does not match the database column name is decorated with the <kbd>@Column</kbd> annotation; in addition to that, the primary key is decorated with the <kbd>@Id</kbd> annotation.</p>
<p>Where the preceding code gets interesting is the declaration of the <kbd>customer</kbd> field. As can be seen in the code, the <kbd>customer</kbd> field is decorated with the <kbd>@OneToOne</kbd> annotation; this lets the application server know that there is a one-to-one relationship between this entity and the <kbd>Customer</kbd> entity. The customer field is also decorated with the <kbd>@JoinColumn</kbd> annotation. This annotation lets the container know which column in the <kbd>LOGIN_INFO</kbd> table is the foreign key corresponding to the primary key on the <kbd>CUSTOMER</kbd> table. Since <kbd>LOGIN_INFO</kbd>, the table that the <kbd>LoginInfo</kbd> entity maps to, has a foreign key to the <kbd>CUSTOMER</kbd> table, the <kbd>LoginInfo</kbd> entity owns the relationship. If the relationship were unidirectional, we wouldn't have to make any changes to the <kbd>Customer</kbd> entity. However, since we would like to have a bidirectional relationship between these two entities, we need to add a <kbd>LoginInfo</kbd> field to the <kbd>Customer</kbd> entity, along with the corresponding getter and setter methods.</p>
<p>Like we mentioned before, in order to make the one-to-one relationship between the <kbd>Customer</kbd> and <kbd>LoginInfo</kbd> entities bidirectional, we need to make a few simple changes to the <kbd>Customer</kbd> entity:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import java.io.Serializable; 
import java.util.Set; 
 
import javax.persistence.CascadeType; 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.OneToMany; 
import javax.persistence.OneToOne; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "CUSTOMERS") 
public class Customer implements Serializable 
{ 
  @Id 
  @Column(name = "CUSTOMER_ID") 
  private Long customerId; 
 
  @Column(name = "FIRST_NAME") 
  private String firstName; 
 
  @Column(name = "LAST_NAME") 
  private String lastName; 
 
  private String email; 
 
<strong>  @OneToOne(mappedBy = "customer")</strong><strong> <br/>  private LoginInfo loginInfo;</strong><strong>  <br/>  public LoginInfo getLoginInfo()</strong><strong> <br/>  {</strong><strong>   <br/>    return loginInfo;</strong><strong>  <br/>  }</strong><strong> <br/>  public void setLoginInfo(LoginInfo loginInfo)</strong><strong>  <br/>  {</strong><strong>   <br/>    this.loginInfo = loginInfo;</strong><strong> <br/>  }</strong> 
   //Additional setters and getters omitted for brevity 
} </pre>
<p>The only change we need to make to the <kbd>Customer</kbd> entity to make the one-to-one relationship bidirectional is to add a <kbd>LoginInfo</kbd> field to it, along with the corresponding setter and getter methods. The <kbd>loginInfo</kbd> field is decorated with the <kbd>@OneToOne</kbd> annotation. Since the <kbd>Customer</kbd> entity does not own the relationship (the table it maps to does not have a foreign key to the corresponding table), the <kbd>mappedBy</kbd> element of the <kbd>@OneToOne</kbd> annotation needs to be added. This element specifies which field in the corresponding entity has the other end of the relationship. In this particular case, the customer field in the <kbd>LoginInfo</kbd> entity corresponds to the other end of this one-to-one relationship.</p>
<p>The following Java class illustrates the use of the preceding entity:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.namedbean; 
 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.transaction.HeuristicMixedException; 
import javax.transaction.HeuristicRollbackException; 
import javax.transaction.NotSupportedException; 
import javax.transaction.RollbackException; 
import javax.transaction.SystemException; 
import javax.transaction.UserTransaction; 
import net.ensode.javaee8book.entityrelationship.entity.Customer; 
import net.ensode.javaee8book.entityrelationship.entity.LoginInfo; 
 
@Named 
@RequestScoped 
public class OneToOneRelationshipDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction; 
 
    public String updateDatabase() { 
        String retVal = "confirmation"; 
        Customer customer; 
        LoginInfo loginInfo = new LoginInfo(); 
 
        loginInfo.setLoginInfoId(1L); 
        loginInfo.setLoginName("charlesj"); 
        loginInfo.setPassword("iwonttellyou"); 
 
        try { 
            userTransaction.begin(); 
 
           <strong> customer = entityManager.find(Customer.class, 4L); 
            loginInfo.setCustomer(customer); 
</strong> 
            entityManager.persist(loginInfo); 
 
            userTransaction.commit(); 
 
        } catch (NotSupportedException | 
                SystemException | 
                SecurityException | 
                IllegalStateException | 
                RollbackException | 
                HeuristicMixedException | 
                HeuristicRollbackException e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
} </pre>
<p>In this example, we first create an instance of the <kbd>LoginInfo</kbd> entity and populate it with some data. We then obtain an instance of the <kbd>Customer</kbd> entity from the database by invoking the <kbd>find()</kbd> method of <kbd>EntityManager</kbd> (data for this entity was inserted into the <kbd>CUSTOMERS</kbd> table in one of the previous examples). We then invoke the <kbd>setCustomer()</kbd> method on the <kbd>LoginInfo</kbd> entity, passing the customer object as a parameter. Finally, we invoke the <kbd>EntityManager.persist()</kbd> method to save the data in the database.</p>
<p>What happens behind the scenes is that the <kbd>CUSTOMER_ID</kbd> column of the <kbd>LOGIN_INFO</kbd> table gets populated with the primary key of the corresponding row in the <kbd>CUSTOMERS</kbd> table. This can be easily verified by querying the <kbd>CUSTOMERDB</kbd> database.</p>
<div class="packt_infobox">Notice how the call to <kbd>EntityManager.find()</kbd> to obtain the customer entity is inside the same transaction from where we call <kbd>EntityManager.persist()</kbd>. This must be the case; otherwise, the database will not be updated successfully.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-to-many relationships</h1>
                </header>
            
            <article>
                
<p>JPA one-to-many entity relationships can be bidirectional (one entity contains a many-to-one relationship and the corresponding entity contains an inverse one-to-many relationship).</p>
<p>With SQL, one-to-many relationships are defined by foreign keys in one of the tables. The <kbd>many</kbd> part of the relationship is the one containing a foreign key to the <kbd>one</kbd> part of the relationship. One-to-many relationships defined in an RDBMS are typically unidirectional, since making them bidirectional usually results in denormalized data.</p>
<p>Just like when defining a unidirectional one-to-many relationship in an RDBMS, in JPA the many part of the relationship is the one that has a reference to the <kbd>one</kbd> part of the relationship, therefore the annotation used to decorate the appropriate <kbd>setter</kbd> method is <kbd>@ManyToOne</kbd><span class="URLPACKT">.</span></p>
<p>In the <kbd>CUSTOMERDB</kbd> database, there is a unidirectional one-to-many relationship between customers and orders. We define this relationship in the <kbd>Order</kbd> entity:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.JoinColumn; 
import javax.persistence.ManyToOne; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "ORDERS") 
public class Order 
{ 
  @Id 
  @Column(name = "ORDER_ID") 
  private Long orderId; 
 
  @Column(name = "ORDER_NUMBER") 
  private String orderNumber; 
 
  @Column(name = "ORDER_DESCRIPTION") 
  private String orderDescription; 
 
<strong>  @ManyToOne</strong><strong>  @JoinColumn(name = "CUSTOMER_ID")</strong><strong>  <br/>  private Customer customer;</strong> 
 
  public Customer getCustomer() 
  { 
    return customer; 
  } 
 
  public void setCustomer(Customer customer) 
  { 
    this.customer = customer; 
  } 
 
  public String getOrderDescription() 
  { 
    return orderDescription; 
  } 
 
  public void setOrderDescription(String orderDescription) 
  { 
    this.orderDescription = orderDescription; 
  } 
 
  public Long getOrderId() 
  { 
    return orderId; 
  } 
 
  public void setOrderId(Long orderId) 
  { 
    this.orderId = orderId; 
  } 
 
  public String getOrderNumber() 
  { 
    return orderNumber; 
  } 
 
  public void setOrderNumber(String orderNumber) 
  { 
    this.orderNumber = orderNumber; 
  } 
} </pre>
<p>If we were to define a unidirectional many-to-one relationship between the <kbd>Orders</kbd> entity and the <kbd>Customer</kbd> entity, we wouldn't need to make any changes to the <kbd>Customer</kbd> entity. To define a bidirectional one-to-many relationship between the two entities, a new field decorated with the <kbd>@OneToMany</kbd> annotation needs to be added to the <kbd>Customer</kbd> entity:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import java.io.Serializable; 
import java.util.Set; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.OneToMany; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "CUSTOMERS") 
public class Customer implements Serializable 
{ 
  @Id 
  @Column(name = "CUSTOMER_ID") 
  private Long customerId; 
 
  @Column(name = "FIRST_NAME") 
  private String firstName; 
 
  @Column(name = "LAST_NAME") 
  private String lastName; 
 
  private String email; 
 
  @OneToOne(mappedBy = "customer") 
  private LoginInfo loginInfo; 
 
<strong>  @OneToMany(mappedBy="customer")</strong><strong>  <br/>  private Set&lt;Order&gt; orders;</strong> 
 
  public Long getCustomerId() 
  { 
    return customerId; 
  } 
 
  public void setCustomerId(Long customerId) 
  { 
    this.customerId = customerId; 
  } 
 
  public String getEmail() 
  { 
    return email; 
  } 
 
  public void setEmail(String email) 
  { 
    this.email = email; 
  } 
 
  public String getFirstName() 
  { 
    return firstName; 
  } 
 
  public void setFirstName(String firstName) 
  { 
    this.firstName = firstName; 
  } 
 
  public String getLastName() 
  { 
    return lastName; 
  } 
 
  public void setLastName(String lastName) 
  { 
    this.lastName = lastName; 
  } 
 
  public LoginInfo getLoginInfo() 
  { 
    return loginInfo; 
  } 
 
  public void setLoginInfo(LoginInfo loginInfo) 
  { 
    this.loginInfo = loginInfo; 
  } 
 
<strong>  public Set&lt;Order&gt; getOrders() <br/></strong><strong>  {</strong><strong>  <br/>    return orders;</strong><strong>  <br/>  }</strong><strong>  <br/>  public void setOrders(Set&lt;Order&gt; orders)</strong><strong> <br/>  {</strong><strong>    <br/>    this.orders = orders;</strong><strong>  <br/>  }</strong> 
} </pre>
<p>The only difference between this version of the <kbd>Customer</kbd> entity and the previous one is the addition of the <kbd>orders</kbd> field and related <kbd>getter</kbd> and <kbd>setter</kbd> methods. Of special interest is the <kbd>@OneToMany</kbd> annotation decorating this field. The <kbd>mappedBy</kbd> attribute must match the name of the corresponding field in the entity corresponding to the <kbd>many</kbd> part of the relationship. In simple terms, the value of the <kbd>mappedBy</kbd> attribute must match the name of the field decorated with the <kbd>@ManyToOne</kbd> annotation in the bean at the other side of the relationship.</p>
<p>The following example code illustrates how to persist one-to-many relationships to the database:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.namedbean; 
 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.transaction.HeuristicMixedException; 
import javax.transaction.HeuristicRollbackException; 
import javax.transaction.NotSupportedException; 
import javax.transaction.RollbackException; 
import javax.transaction.SystemException; 
import javax.transaction.UserTransaction; 
import net.ensode.javaee8book.entityrelationship.entity.Customer; 
import net.ensode.javaee8book.entityrelationship.entity.Order; 
 
@Named 
@RequestScoped 
public class OneToManyRelationshipDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction; 
 
    public String updateDatabase() { 
        String retVal = "confirmation"; 
 
        Customer customer; 
        Order order1; 
        Order order2; 
 
        order1 = new Order(); 
        order1.setOrderId(1L); 
        order1.setOrderNumber("SFX12345"); 
        order1.setOrderDescription("Dummy order."); 
 
        order2 = new Order(); 
        order2.setOrderId(2L); 
        order2.setOrderNumber("SFX23456"); 
        order2.setOrderDescription("Another dummy order."); 
 
        try { 
            userTransaction.begin(); 
 
            <strong>customer = entityManager.find(Customer.class, 4L); 
 
            order1.setCustomer(customer); 
            order2.setCustomer(customer); 
 
            entityManager.persist(order1); 
            entityManager.persist(order2);</strong> 
 
            userTransaction.commit(); 
 
        } catch (NotSupportedException | 
                SystemException | 
                SecurityException | 
                IllegalStateException | 
                RollbackException | 
                HeuristicMixedException | 
                HeuristicRollbackException e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
} </pre>
<p>The preceding code is pretty similar to the previous example. It instantiates two instances of the <kbd>Order</kbd> entity, populates them with some data, then in a transaction an instance of the <kbd>Customer</kbd> entity is located and used as the parameter of the <kbd>setCustomer()</kbd> method of both instances of the <kbd>Order</kbd> entity. We then persist both <kbd>Order</kbd> entities by invoking <kbd>EntityManager.persist()</kbd> for each one of them.</p>
<p>Just like when dealing with one-to-one relationships, what happens behind the scenes is that the <kbd><span class="NormalPACKTChar">CUSTOMER_ID</span></kbd> column of the <kbd>ORDERS</kbd> table in the <kbd>CUSTOMERDB</kbd> database is populated with the primary key corresponding to the related row in the <kbd>CUSTOMERS</kbd> table.</p>
<p>Since the relationship is bidirectional, we can obtain all orders related to a customer by invoking the <kbd>getOrders()</kbd> method on the <kbd>Customer</kbd> entity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Many-to-many relationships</h1>
                </header>
            
            <article>
                
<p>In the <kbd>CUSTOMERDB</kbd> database, there is a many-to-many relationship between the <kbd>ORDERS</kbd> table and the <kbd>ITEMS</kbd> table. We can map this relationship by adding a new <kbd>Collection&lt;Item&gt;</kbd> field to the <kbd>Order</kbd> entity and decorating it with the <kbd>@ManyToMany</kbd> annotation:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import java.util.Collection; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.JoinColumn; 
import javax.persistence.JoinTable; 
import javax.persistence.ManyToMany; 
import javax.persistence.ManyToOne; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "ORDERS") 
public class Order 
{ 
  @Id 
  @Column(name = "ORDER_ID") 
  private Long orderId; 
 
  @Column(name = "ORDER_NUMBER") 
  private String orderNumber; 
 
  @Column(name = "ORDER_DESCRIPTION") 
  private String orderDescription; 
 
  @ManyToOne 
  @JoinColumn(name = "CUSTOMER_ID") 
  private Customer customer; 
 
<strong>  @ManyToMany</strong><strong> <br/>  @JoinTable(name = "ORDER_ITEMS", </strong><strong>      <br/>   joinColumns = @JoinColumn(name = "ORDER_ID", </strong><strong>       <br/>    referencedColumnName = "ORDER_ID"), </strong><strong>        <br/>     inverseJoinColumns = @JoinColumn(name = "ITEM_ID", </strong><strong>                <br/>      referencedColumnName = "ITEM_ID"))<br/></strong><strong>  private Collection&lt;Item&gt; items;</strong> 
 
  public Customer getCustomer() 
  { 
    return customer; 
  } 
 
  public void setCustomer(Customer customer) 
  { 
    this.customer = customer; 
  } 
 
  public String getOrderDescription() 
  { 
    return orderDescription; 
  } 
 
  public void setOrderDescription(String orderDescription) 
  { 
    this.orderDescription = orderDescription; 
  } 
 
  public Long getOrderId() 
  { 
    return orderId; 
  } 
 
  public void setOrderId(Long orderId) 
  { 
    this.orderId = orderId; 
  } 
 
  public String getOrderNumber() 
  { 
    return orderNumber; 
  } 
 
  public void setOrderNumber(String orderNumber) 
  { 
    this.orderNumber = orderNumber; 
  } 
 
<strong>  public Collection&lt;Item&gt; getItems()</strong><strong> <br/>  {</strong><strong>  <br/>    return items;</strong><strong> <br/>  }<br/></strong><strong>  public void setItems(Collection&lt;Item&gt; items)<br/></strong><strong>  {</strong><strong>   <br/>    this.items = items;</strong><strong> <br/>  }<br/></strong><strong>}</strong></pre>
<p>As we can see in the preceding code, in addition to being decorated with the <kbd>@ManyToMany</kbd> annotation, the <kbd>items</kbd> field is also decorated with the <kbd>@JoinTable</kbd> annotation. Like its name suggests, this annotation lets the application server know what table is used as a join table to create the many-to-many relationship between the two entities. This annotation has three relevant elements: the name element, which defines the name of the join table, and the <kbd>joinColumns</kbd> and <kbd>inverseJoinColumns</kbd> elements, which define the columns that serve as foreign keys in the join table pointing to the entities' primary keys. Values for the <kbd>joinColumns</kbd> and <kbd>inverseJoinColumns</kbd> elements are yet another annotation: the <kbd>@JoinColumn</kbd> annotation. This annotation has two relevant elements: the name element, which defines the name of the column in the join table, and the <kbd>referencedColumnName</kbd> element, which defines the name of the column in the entity table.</p>
<p>The <kbd>Item</kbd> entity is a simple entity mapping to the <kbd>ITEMS</kbd> table in the <kbd>CUSTOMERDB</kbd> database:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.entity; 
 
import java.util.Collection; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.ManyToMany; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "ITEMS") 
public class Item 
{ 
  @Id 
  @Column(name = "ITEM_ID") 
  private Long itemId; 
 
  @Column(name = "ITEM_NUMBER") 
  private String itemNumber; 
 
  @Column(name = "ITEM_SHORT_DESC") 
  private String itemShortDesc; 
 
  @Column(name = "ITEM_LONG_DESC") 
  private String itemLongDesc; 
 
<strong>  @ManyToMany(mappedBy="items") <br/></strong><strong>  private Collection&lt;Order&gt; orders;</strong><strong> <br/>  public Collection&lt;Order&gt; getOrders()</strong><strong>  <br/>  {</strong><strong>  <br/>    return orders;</strong><strong> <br/>  }</strong><strong>  <br/>  public void setOrders(Collection&lt;Order&gt; orders)<br/></strong><strong>  {</strong><strong>   <br/>    this.orders = orders;</strong><strong> <br/>  }</strong> 
   
  //additional setters and getters removed for brevity 
} </pre>
<p>Just like one-to-one and one-to-many relationships, many-to-many relationships can be unidirectional or bidirectional. Since we would like the many-to-many relationship between the <kbd>Order</kbd> and <kbd>Item</kbd> entities to be bidirectional, we added a <kbd>Collection&lt;Order&gt;</kbd> field and decorated it with the <kbd>@ManyToMany</kbd> annotation. Since the corresponding field in the <kbd>Order</kbd> entity already has the join table defined, it is not necessary to do it again here. The entity containing the <kbd>@JoinTable</kbd> annotation is said to own the relationship; in a many-to-many relationship, either entity can own the relationship. In our example, the <kbd>Order</kbd> entity owns it, since its <kbd>Collection&lt;Item&gt;</kbd> field is decorated with the <kbd>@JoinTable</kbd> annotation.</p>
<p>Just like with one-to-one and one-to-many relationships, the <kbd>@ManyToMany</kbd> annotation in the non-owning side of a bidirectional many-to-many relationship must contain a <kbd>mappedBy</kbd> element indicating which field in the owning entity defines the relationship.</p>
<p>Now that we have seen the changes necessary to establish a bidirectional many-to-many relationship between the <kbd>Order</kbd> and <kbd>Item</kbd> entities, we can see the relationship in action in the following example:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.entityrelationship.namedbean; 
 
import java.util.ArrayList; 
import java.util.Collection; 
import javax.annotation.Resource; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.transaction.HeuristicMixedException; 
import javax.transaction.HeuristicRollbackException; 
import javax.transaction.NotSupportedException; 
import javax.transaction.RollbackException; 
import javax.transaction.SystemException; 
import javax.transaction.UserTransaction; 
import net.ensode.javaee8book.entityrelationship.entity.Item; 
import net.ensode.javaee8book.entityrelationship.entity.Order; 
 
@Named 
@RequestScoped 
public class ManyToManyRelationshipDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction; 
 
    public String updateDatabase() { 
        String retVal = "confirmation"; 
 
        Order order; 
        Collection&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); 
        Item item1 = new Item(); 
        Item item2 = new Item(); 
 
        item1.setItemId(1L); 
        item1.setItemNumber("BCD1234"); 
        item1.setItemShortDesc("Notebook Computer"); 
        item1.setItemLongDesc("64 bit Quad core CPU, 4GB memory"); 
 
        item2.setItemId(2L); 
        item2.setItemNumber("CDF2345"); 
        item2.setItemShortDesc("Cordless Mouse"); 
        item2.setItemLongDesc("Three button, infrared, " 
                + "vertical and horizontal scrollwheels"); 
 
        items.add(item1); 
        items.add(item2); 
 
        try { 
            userTransaction.begin(); 
 
<strong>            entityManager.persist(item1);</strong><strong>    <br/>            entityManager.persist(item2);</strong><strong>           <br/>            order = entityManager.find(Order.class, 1L);</strong><strong>             <br/>            order.setItems(items);</strong><strong>       <br/>            entityManager.persist(order);</strong> 
 
            userTransaction.commit(); 
 
        } catch (NotSupportedException | 
                SystemException | 
                SecurityException | 
                IllegalStateException | 
                RollbackException | 
                HeuristicMixedException | 
                HeuristicRollbackException e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
} </pre>
<p>The preceding code creates two instances of the <kbd>Item</kbd> entity and populates them with some data. It then adds these two instances to a collection. A transaction is then started and the two <kbd>Item</kbd> instances are persisted to the database. Then an instance of the <kbd>Order</kbd> entity is retrieved from the database. The <kbd>setItems()</kbd> method of the <kbd>Order</kbd> entity instance is then invoked, passing the collection containing the two <kbd>Item</kbd> instances as a parameter. The <kbd>Customer</kbd> instance is then persisted into the database. At this point, two rows are created behind the scenes to the <kbd>ORDER_ITEMS</kbd> table, which is the join table between the <kbd>ORDERS</kbd> and <kbd>ITEMS</kbd> tables.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composite primary keys</h1>
                </header>
            
            <article>
                
<p>Most tables in the <kbd>CUSTOMERDB</kbd> database have a column with the sole purpose of serving as a primary key (this type of primary key is sometimes referred to as a surrogate primary key or as an artificial primary key). However, some databases are not designed this way; instead a column in the database that is known to be unique across rows is used as the primary key. If there is no column whose value is not guaranteed to be unique across rows, then a combination of two or more columns is used as the table's primary key. It is possible to map this kind of primary key to JPA entities by using a <kbd>primary key</kbd> class.</p>
<p>There is one table in the <kbd>CUSTOMERDB</kbd> database that does not have a surrogate primary key: the <kbd>ORDER_ITEMS</kbd> table. This table serves as a join table between the <kbd>ORDERS</kbd> and the <kbd>ITEMS</kbd> tables, in addition to having foreign keys for these two tables, this table has an additional column called <kbd>ITEM_QTY</kbd> ;this column stores the quantity of each item in an order. Since this table does not have a surrogate primary key, the JPA entity mapping to it must have a custom <kbd>primary key</kbd> class. In this table, the combination of the <kbd>ORDER_ID</kbd> and the <kbd>ITEM_ID</kbd> columns must be unique, therefore this is a good combination for a composite primary key:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.compositeprimarykeys.entity; 
 
import java.io.Serializable; 
 
public class OrderItemPK implements Serializable 
{ 
  public Long orderId; 
  public Long itemId; 
 
  public OrderItemPK() 
  { 
 
  } 
 
  public OrderItemPK(Long orderId, Long itemId) 
  { 
    this.orderId = orderId; 
    this.itemId = itemId; 
  } 
 
  @Override 
  public boolean equals(Object obj) 
  { 
    boolean returnVal = false; 
 
    if (obj == null) 
    { 
      returnVal = false; 
    } 
    else if (!obj.getClass().equals(this.getClass())) 
    { 
      returnVal = false; 
    } 
    else 
    { 
      OrderItemPK other = (OrderItemPK) obj; 
 
      if (this == other) 
      { 
        returnVal = true; 
      } 
      else if (orderId != null &amp;&amp; other.orderId != null 
          &amp;&amp; this.orderId.equals(other.orderId)) 
      { 
        if (itemId != null &amp;&amp; other.itemId != null 
            &amp;&amp; itemId.equals(other.itemId)) 
        { 
          returnVal = true; 
        } 
      } 
      else 
      { 
        returnVal = false; 
      } 
    } 
 
    return returnVal; 
  } 
 
  @Override 
  public int hashCode() 
  { 
    if (orderId == null || itemId == null) 
    { 
      return 0; 
    } 
    else 
    { 
      return orderId.hashCode() ^ itemId.hashCode(); 
    } 
  } 
} </pre>
<p>A custom <kbd>primary key</kbd> class must satisfy the following requirements:</p>
<ul>
<li>The class must be public</li>
<li>It must implement <kbd>java.io.Serializable</kbd></li>
<li>It must have a public constructor that takes no arguments</li>
<li>Its fields must be <kbd>public</kbd> or <kbd>protected</kbd></li>
<li>Its field names and types must match those of the entity</li>
<li>It must override the default <kbd>hashCode()</kbd> and <kbd>equals()</kbd> methods defined in the <kbd>java.lang.Object</kbd> class</li>
</ul>
<p>The preceding <kbd>OrderPK</kbd> class meets all of these requirements. It also has a convenience constructor that takes two <kbd>Long</kbd> objects to initialize its <kbd>orderId</kbd> and <kbd>itemId</kbd> fields. This constructor was added for convenience; this is not a prerequisite for the class to be used as a primary key class.</p>
<p>When an entity uses a custom <kbd>primary key</kbd> class, it must be decorated with the <kbd>@IdClass</kbd> annotation. Since the <kbd>OrderItem</kbd> class uses <kbd>OrderItemPK</kbd> as its custom <kbd>primary key</kbd> class, it must be decorated with the aforementioned annotation:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.compositeprimarykeys.entity; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.IdClass; 
import javax.persistence.Table; 
 
@Entity 
@Table(name = "ORDER_ITEMS") 
<strong>@IdClass(value = OrderItemPK.class)</strong> 
public class OrderItem 
{ 
<strong>  @Id</strong> 
  @Column(name = "ORDER_ID") 
  private Long orderId; 
 
<strong>  @Id</strong> 
  @Column(name = "ITEM_ID") 
  private Long itemId; 
 
  @Column(name = "ITEM_QTY") 
  private Long itemQty; 
 
  public Long getItemId() 
  { 
    return itemId; 
  } 
 
  public void setItemId(Long itemId) 
  { 
    this.itemId = itemId; 
  } 
 
  public Long getItemQty() 
  { 
    return itemQty; 
  } 
 
  public void setItemQty(Long itemQty) 
  { 
    this.itemQty = itemQty; 
  } 
 
  public Long getOrderId() 
  { 
    return orderId; 
  } 
 
  public void setOrderId(Long orderId) 
  { 
    this.orderId = orderId; 
  } 
} </pre>
<p>There are two differences between the preceding entity and the previous entities we have seen. The first difference is that this entity is decorated with the <kbd>@IdClass</kbd> annotation, indicating the primary key class corresponding to it. The second difference is that the preceding entity has more than one field decorated with the <kbd>@Id</kbd> annotation. Since this entity has a composite primary key, each field that is part of the primary key must be decorated with this annotation.</p>
<p>Obtaining a reference of an entity with a composite primary key is not much different from obtaining a reference to an entity with a primary key consisting of a single field. The following example demonstrates how to do this:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.compositeprimarykeys.namedbean; 
 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import net.ensode.javaee8book.compositeprimarykeys.entity.OrderItem; 
import net.ensode.javaee8book.compositeprimarykeys.entity.OrderItemPK; 
 
@Named 
@RequestScoped 
public class CompositePrimaryKeyDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    private OrderItem orderItem; 
 
    public String findOrderItem() { 
        String retVal = "confirmation"; 
 
        try { 
<strong>            orderItem = entityManager.find(OrderItem.class, </strong><strong>                                                                  <br/>            new OrderItemPK(1L, 2L));</strong> 
        } catch (Exception e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
 
    public OrderItem getOrderItem() { 
        return orderItem; 
    } 
 
    public void setOrderItem(OrderItem orderItem) { 
        this.orderItem = orderItem; 
    } 
 
} </pre>
<p>As can be seen in this example, the only difference between locating an entity with a composite primary key and an entity with a primary key consisting of a single field is that an instance of the custom <kbd>primary key</kbd> class must be passed as the second argument of the <kbd>EntityManager.find()</kbd> method. Fields for this instance must be populated with the appropriate values for each field that is part of the primary key.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java Persistence Query Language</h1>
                </header>
            
            <article>
                
<p>All of our examples that obtain entities from the database so far have conveniently assumed that the primary key for the entity is known ahead of time. We all know that frequently this is not the case. Whenever we need to search for an entity by a field other than the entity's primary key, we must use the <strong>Java Persistence Query Language</strong> (<strong>JPQL</strong>).</p>
<p>JPQL is a SQL-like language used for retrieving, updating, and deleting entities in a database. The following example illustrates how to use JPQL to retrieve a subset of states from the <kbd>US_STATES</kbd> table in the <kbd>CUSTOMERDB</kbd> database:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jpql.namedbean; 
 
import java.util.List; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.persistence.Query; 
import net.ensode.javaee8book.jpql.entity.UsState; 
 
@Named 
@RequestScoped 
public class SelectQueryDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    private Stream&lt;UsState&gt; matchingStatesStream; 
    private List&lt;UsState&gt; matchingStatesList; 
 
    public String findStates() { 
        String retVal = "confirmation"; 
 
        try { 
<strong>            Query query = entityManager</strong><strong>           <br/>            .createQuery(</strong><strong>                   <br/>             "SELECT s FROM UsState s WHERE s.usStateNm "</strong><strong>          <br/>              + "LIKE :name");</strong><strong>            <br/>            query.setParameter("name", "New%");</strong><strong>       <br/>            matchingStatesStream = query.getResultStream();</strong><strong>         <br/>            if (matchingStatesStream != null) {</strong><strong>             <br/>             matchingStatesList =<br/>              matchingStatesStream.collect(Collectors.toList());</strong><strong>         <br/>            }</strong> 
        } catch (Exception e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
        return retVal; 
    } 
 
    public List&lt;UsState&gt; getMatchingStatesList() { 
        return matchingStatesList; 
    } 
 
    public void setMatchingStatesList(List&lt;UsState&gt; matchingStatesList) { 
        this.matchingStatesList = matchingStatesList; 
    } 
 
} </pre>
<p>The preceding code invokes the <kbd>EntityManager.createQuery()</kbd> method, passing a <kbd>String</kbd> containing a JPQL query as a parameter. This method returns an instance of <kbd>javax.persistence.Query</kbd>. The query retrieves all <kbd>UsState</kbd> entities whose name starts with the word <kbd>New</kbd>.</p>
<p>As can be seen in the preceding code, JPQL is similar to SQL; however, there are some differences that may confuse readers with some knowledge of SQL. The equivalent SQL code for the query in the code would be:</p>
<pre style="padding-left: 60px">SELECT * from US_STATES s where s.US_STATE_NM like 'New%' </pre>
<p>The first difference between JPQL and SQL is that in JPQL we always reference entity names, wherein SQL table names are referenced. The <kbd>s</kbd> after the entity name in the JPQL query is an alias for the entity. Table aliases are optional in SQL, but entity aliases are required in JPQL. Keeping these differences in mind, the JPQL query should now be a lot less confusing.</p>
<p>The <kbd>:name</kbd> in the query is a <strong>named parameter;</strong> named parameters are meant to be substituted with actual values. This is done by invoking the <kbd>setParameter()</kbd> method in the instance of <kbd>javax.persistence.Query</kbd> returned by the call to <kbd>EntityManager.createQuery()</kbd>. A JPQL query can have multiple named parameters.</p>
<p>To actually run the query and retrieve the entities from the database, the <kbd>getResultList()</kbd> method must be invoked in the instance of <kbd>javax.persistence.Query</kbd> obtained from <kbd>EntityManager.createQuery()</kbd>. This method returns an instance of a class implementing the <kbd>java.util.List</kbd> interface; this list contains the entities matching the query criteria. If no entities match the criteria, then an empty list is returned.</p>
<p>If we are certain that the query will return exactly one entity, then the <kbd>getSingleResult()</kbd> method may be alternatively called on <kbd>Query</kbd> ; this method returns an <kbd>Object</kbd> that must be cast to the appropriate entity.</p>
<p>The preceding example uses the <kbd>LIKE</kbd> operator to find entities whose names start with the word "New". This is accomplished by substituting the query's named parameter with the value "New%". The percent sign at the end of the parameter value means that any number of characters after the word "New" will match the expression. The percent sign can be used anywhere in the parameter value, for example, a value of "%Dakota" would match any entities whose name end in "Dakota", a value of "A%a" would match any states whose name starts with a capital "A" and end with a lowercase "a". There can be more than one % sign in a parameter value. The underscore sign, (_), can be used to match a single character; all the rules for the % sign apply to the underscore as well.</p>
<p>In addition to the <kbd>LIKE</kbd> operator, there are other operators that can be used to retrieve entities from the database:</p>
<ul>
<li>The <kbd>=</kbd> operator will retrieve entities whose field at the left of the operator exactly match as the value to the right of the operator</li>
<li>The <kbd>&gt;</kbd> operator will retrieve entities whose field at the left of the operator is greater than the value to the right of the operator</li>
<li>The <kbd>&lt;</kbd> operator will retrieve entities whose field at the left of the operator is less than the value to the right of the operator</li>
<li>The <kbd>&gt;=</kbd> operator will retrieve entities whose field at the left of the operator is greater than or equal to the value to the right of the operator</li>
<li>The <kbd>&lt;=</kbd> operator will retrieve entities whose field at the left of the operator is less than or equal to the value to the right of the operator</li>
</ul>
<p>All of the preceding operators work the same way as the equivalent operators in SQL. Just like in SQL, these operators can be combined with the <kbd>AND</kbd> and <kbd>OR</kbd> operators. Conditions combined with the <kbd>AND</kbd> operator match if both conditions are true; conditions combined with the <kbd>OR</kbd> operator match if at least one of the conditions is true.</p>
<p>If we intend to use a query many times, it can be stored in a <strong>named query</strong>. Named queries can be defined by decorating the relevant entity class with the <kbd>@NamedQuery</kbd> annotation. This annotation has two elements: a <kbd>name</kbd> element used to set the name of the query, and a <kbd>query</kbd> element defining the query itself. To execute a named query, the <kbd>createNamedQuery()</kbd> method must be invoked in an instance of <kbd>EntityManager</kbd>. This method takes a <kbd>String</kbd> containing the query name as its sole parameter, and returns an instance of <kbd>javax.persistence.Query</kbd>.</p>
<p>In addition to retrieving entities, JPQL can be used to modify or delete entities. However, entity modification and deletion can be done programmatically via the <kbd>EntityManager</kbd> interface; doing so results in code that tends to be more readable than when using JPQL. Because of this, we will not cover entity modification and deletion via JPQL. Readers interested in writing JPQL queries to modify and delete entities, as well as readers wishing to know more about JPQL, are encouraged to review the Java Persistence 2.2 specification. This specification can be downloaded at <a href="http://jcp.org/en/jsr/detail?id=338"><span class="URLPACKT">http://jcp.org/en/jsr/detail?id=338</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Criteria API</h1>
                </header>
            
            <article>
                
<p>One of the main additions to JPA in the 2.0 specification was the introduction of the <strong>Criteria API</strong>. The Criteria API is meant as a complement to JPQL.</p>
<p>Although JPQL is very flexible, it has some problems that make working with it more difficult than necessary. For starters, JPQL queries are stored as strings, and the compiler has no way of validating the JPQL syntax. Additionally, JPQL is not type-safe: we could write a JPQL query in which our where clause could have a string value for a numeric property and our code would compile and deploy just fine.</p>
<p>To get around the JPQL limitations described in the previous paragraph, the Criteria API was introduced to JPA in version 2.0 of the specification. The Criteria API allows us to write JPA queries programmatically, without having to rely on JPQL.</p>
<p>The following code example illustrates how to use the Criteria API in our Java EE applications:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.criteriaapi.namedbean; 
 
import java.util.List; 
import javax.enterprise.context.RequestScoped; 
import javax.inject.Named; 
import javax.persistence.EntityManager; 
import javax.persistence.PersistenceContext; 
import javax.persistence.TypedQuery; 
import javax.persistence.criteria.CriteriaBuilder; 
import javax.persistence.criteria.CriteriaQuery; 
import javax.persistence.criteria.Path; 
import javax.persistence.criteria.Predicate; 
import javax.persistence.criteria.Root; 
import javax.persistence.metamodel.EntityType; 
import javax.persistence.metamodel.Metamodel; 
import javax.persistence.metamodel.SingularAttribute; 
import net.ensode.javaee8book.criteriaapi.entity.UsState; 
 
@Named 
@RequestScoped 
public class CriteriaApiDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    private List&lt;UsState&gt; matchingStatesList; 
    private List&lt;UsState&gt; matchingStatesList; 
 
    public String findStates() { 
        String retVal = "confirmation"; 
        try { 
<strong>            CriteriaBuilder criteriaBuilder = entityManager.</strong><strong>                     <br/>             getCriteriaBuilder();</strong><strong>        <br/>            CriteriaQuery&lt;UsState&gt; criteriaQuery = criteriaBuilder.</strong><strong>                     <br/>             createQuery(UsState.class);</strong><strong>         <br/>            Root&lt;UsState&gt; root = criteriaQuery.from(UsState.class);</strong><strong>  <br/>            Metamodel metamodel = entityManager.getMetamodel();</strong><strong>             <br/>            EntityType&lt;UsState&gt; usStateEntityType = <br/>             metamodel.entity(</strong><strong>                     <br/>              UsState.class);</strong><strong>         <br/>            SingularAttribute&lt;UsState, String&gt; usStateAttribute</strong><strong>=</strong><strong>                   <br/>             usStateEntityType.getDeclaredSingularAttribute(</strong><strong>                     <br/>             "usStateNm",</strong><strong>             <br/>              String.class);</strong><strong>        <br/>            Path&lt;String&gt; path = root.get(usStateAttribute);</strong><strong>        <br/>            Predicate predicate = criteriaBuilder.like(</strong><strong>path,<br/>            "New%");</strong><strong>             <br/>            criteriaQuery = criteriaQuery.where(predicate);</strong><strong>     <br/>            TypedQuery typedQuery = entityManager.createQuery(</strong><strong>                     <br/>             criteriaQuery);</strong><strong>        <br/>            matchingStatesStream = typedQuery.getResultStream();</strong><strong>      <br/>            if (matchingStatesStream != null) {</strong><strong>         <br/>             matchingStatesList =<br/>             matchingStatesStream.collect(Collectors.toList());</strong><strong>        <br/>            }</strong> 
 
        } catch (Exception e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
 
        return retVal; 
    } 
 
    public List&lt;UsState&gt; getMatchingStatesList() { 
        return matchingStatesList; 
    } 
 
    public void setMatchingStatesList(List&lt;UsState&gt; <br/>     matchingStatesList) { 
        this.matchingStatesList = matchingStatesList; 
    } 
 
} </pre>
<p>The preceding example is equivalent to the JPQL example we saw earlier in this chapter. This example, however, takes advantage of the Criteria API instead of relying on JPQL.</p>
<p>When writing code using the Criteria API, the first thing we need to do is obtain an instance of a class implementing the <kbd>javax.persistence.criteria.CriteriaBuilder</kbd> interface; as we can see in the preceding example, we need to obtain this instance by invoking the <kbd>getCriteriaBuilder()</kbd> method on our <kbd>EntityManager</kbd>.</p>
<p>From our <kbd>CriteriaBuilder</kbd> implementation, we need to obtain an instance of a class implementing the <kbd>javax.persistence.criteria.CriteriaQuery</kbd> interface. We do this by invoking the <kbd>createQuery()</kbd> method in our <kbd>CriteriaBuilder</kbd> implementation. Notice that <kbd>CriteriaQuery</kbd> is generically typed. The generic type argument dictates the type of result that our <kbd>CriteriaQuery</kbd> implementation will return upon execution. By taking advantage of generics in this way, the Criteria API allows us to write type-safe code.</p>
<p>Once we have obtained a <kbd>CriteriaQuery</kbd> implementation, from it we can obtain an instance of a class implementing the <kbd>javax.persistence.criteria.Root</kbd> interface. The root implementation dictates which JPA Entity we will be querying from. It is analogous to the <kbd>FROM</kbd> query in JPQL (and SQL).</p>
<p>The next two lines in our example take advantage of another new addition to the JPA specification: the <strong>Metamodel API</strong>. In order to take advantage of the Metamodel API, we need to obtain an implementation of the <kbd>javax.persistence.metamodel.Metamodel</kbd> interface by invoking the <kbd>getMetamodel()</kbd> method on our <a><kbd>EntityManager</kbd></a>.</p>
<p>From our <kbd>Metamodel</kbd> implementation, we can obtain a generically typed instance of the <kbd>javax.persistence.metamodel.EntityType</kbd> interface. The generic type argument indicates the JPA entity our <kbd>EntityType</kbd> implementation corresponds to. <kbd>EntityType</kbd> allows us to browse the <kbd>persistent</kbd> attributes of our JPA entities at runtime. This is exactly what we do in the next line in our example. In our case, we get an instance of <kbd>SingularAttribute</kbd>, which maps to a simple, singular attribute in our JPA entity. <kbd>EntityType</kbd> has methods to obtain attributes that map to collections, sets, lists, and maps. Obtaining these attribute types is very similar to obtaining a <kbd>SingularAttribute</kbd>, therefore we won't be covering those directly. Please refer to the Java EE 8 API documentation at <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a> for more information.</p>
<p>As we can see in our example, <kbd>SingularAttribute</kbd> contains two generic type arguments. The first argument dictates the JPA entity we are working with, and the second one indicates the type of the attribute. We obtain our <kbd>SingularAttribute</kbd> by invoking the <kbd>getDeclaredSingularAttribute()</kbd> method on our <kbd>EntityType</kbd> implementation and passing the attribute name (as declared in our JPA entity) as a string.</p>
<p>Once we have obtained our <kbd>SingularAttribute</kbd> implementation, we need to obtain an import <kbd>javax.persistence.criteria.Path</kbd> implementation by invoking the <kbd>get()</kbd> method in our <kbd>Root</kbd> instance, and passing our <kbd>SingularAttribute</kbd> as a parameter.</p>
<p>In our example, we will get a list of all the <em>new</em> states in the United States; that is, all states whose names start with <kbd>New</kbd>. This, of course, is a job for a "like" condition. We can do this with the criteria API by invoking the <kbd>like()</kbd> method on our <kbd>CriteriaBuilder</kbd> implementation. The <kbd>like()</kbd> method takes our <kbd>Path</kbd> implementation as its first parameter, and the value to search for as its second parameter.</p>
<p><kbd>CriteriaBuilder</kbd> has a number of methods that are analogous to SQL and JPQL clauses, such as <kbd>equals()</kbd>, <kbd>greaterThan()</kbd>, <kbd>lessThan()</kbd>, <kbd>and()</kbd>, and <kbd>or()</kbd> (for the complete list, refer to the Java EE 8 documentation at <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a>). These methods can be combined to create complex queries via the Criteria API.</p>
<p>The <kbd>like()</kbd> method in <kbd>CriteriaBuilder</kbd> returns an implementation of the <kbd>javax.persistence.criteria.Predicate</kbd> interface, which we need to pass to the <kbd>where()</kbd> method in our <kbd>CriteriaQuery</kbd> implementation. This method returns a new instance of <kbd>CriteriaBuilder</kbd>, which we assign to our <kbd>criteriaBuilder</kbd> variable.</p>
<p>At this point we are ready to build our query. When working with the Criteria API, we deal with the <kbd>javax.persistence.TypedQuery</kbd> interface, which can be thought of as a type-safe version of the <kbd>Query</kbd> interface we use with JPQL. We obtain an instance of <kbd>TypedQuery</kbd> by invoking the <kbd>createQuery()</kbd> method in <kbd>EntityManager</kbd>, and passing our <kbd>CriteriaQuery</kbd> implementation as a parameter.</p>
<p>To obtain our query results as a list, we simply invoke <kbd>getResultList()</kbd> on our <kbd>TypedQuery</kbd> implementation. It is worth reiterating that the Criteria API is type-safe, therefore attempting to assign the results of <kbd>getResultList()</kbd> to a list of the wrong type would result in a compilation error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating data with the Criteria API</h1>
                </header>
            
            <article>
                
<p>When the JPA Criteria API was initially added to JPA 2.0, it only supported selecting data from the database. Modifying existing data was not supported.</p>
<p>JPA 2.1, introduced in Java EE 7, added support for updating database data via the <kbd>CriteriaUpdate</kbd> interface; the following example illustrates how to use it:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.criteriaupdate.namedbean; 
 
//imports omitted for brevity 
 
@Named 
@RequestScoped 
public class CriteriaUpdateDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction; 
 
    private int updatedRows; 
 
    public String updateData() { 
        String retVal = "confirmation"; 
 
        try { 
 
            userTransaction.begin(); 
            insertTempData(); 
 
<strong>            CriteriaBuilder criteriaBuilder =</strong><strong>                 <br/>             entityManager.getCriteriaBuilder();</strong><strong>         <br/>            CriteriaUpdate&lt;Address&gt; criteriaUpdate =</strong><strong>                 <br/>             criteriaBuilder.createCriteriaUpdate(Address.class);</strong><strong>            <br/>            Root&lt;Address&gt; root = <br/>             criteriaUpdate.from(Address.class);</strong><strong>             <br/>            criteriaUpdate.set("city", "New York");</strong><strong>             <br/>            criteriaUpdate.where(criteriaBuilder.equal(</strong><strong>               <br/>             root.get("city"), "New Yorc"));</strong><strong>       <br/>            Query query =<br/>             entityManager.createQuery(criteriaUpdate);</strong><strong>             <br/>            updatedRows = query.executeUpdate();</strong> 
            userTransaction.commit(); 
        } catch (Exception e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
        return retVal; 
    } 
 
    public int getUpdatedRows() { 
        return updatedRows; 
    } 
 
    public void setUpdatedRows(int updatedRows) { 
        this.updatedRows = updatedRows; 
    } 
 
    private void insertTempData() throws NotSupportedException, 
            SystemException, RollbackException, HeuristicMixedException, 
            HeuristicRollbackException { 
      //body omitted since it is not relevant to the discussion at hand 
      //full source code available as part of this book's code download 
} </pre>
<p>What this example is actually doing is finding all of the database rows with "New Yorc" (a typo) as a city, and replacing the value with the correct spelling of "New York".</p>
<p>Just like in the previous example, we obtain an instance of a class implementing the <kbd>CriteriaBuilder</kbd> interface by invoking the <kbd>getCriteriaBuilder()</kbd> method on our <kbd>EntityManager</kbd> instance.</p>
<p>We then obtain an instance of a class implementing <kbd>CriteriaUpdate</kbd> by invoking <kbd>createCriteriaUpdate()</kbd> on our <kbd>CriteriaBuilder</kbd> instance.</p>
<p>The next step is to obtain an instance of a class implementing <kbd>Root</kbd> by invoking the <kbd>from()</kbd> method on our <kbd>CriteriaUpdate</kbd> instance.</p>
<p>We then invoke the <kbd>set()</kbd> method on <kbd>CriteriaUpdate</kbd> to specify the new values our rows will have after they have been updated; the first parameter of the <kbd>set()</kbd> method must be a <kbd>String</kbd> matching the property name in the <kbd>Entity</kbd> class, and the second parameter must be the new value.</p>
<p>At this point, we build the where clause by invoking the <kbd>where()</kbd> method on <kbd>CriteriaUpdate</kbd>, and passing the <kbd>Predicate</kbd> returned by the <kbd>equal()</kbd> method invoked in <kbd>CriteriaBuilder</kbd>.</p>
<p>Then we get a <kbd>Query</kbd> implementation by invoking <kbd>createQuery()</kbd> on <kbd>EntityManager</kbd>, and passing our <kbd>CriteriaUpdate</kbd> instance as a parameter.</p>
<p>Finally, we execute our query as usual by invoking <kbd>executeUpdate()</kbd> on our <kbd>Query</kbd> implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting data with the Criteria API</h1>
                </header>
            
            <article>
                
<p>In addition to adding support for data updates via the Criteria API, JPA 2.1 added the ability to bulk-delete database rows with the new <kbd>CriteriaDelete</kbd> interface. The following code snippet illustrates its usage:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.criteriadelete.namedbean; 
 
//imports omitted 
 
@Named 
@RequestScoped 
public class CriteriaDeleteDemoBean { 
 
    @PersistenceContext 
    private EntityManager entityManager; 
 
    @Resource 
    private UserTransaction userTransaction; 
 
    private int deletedRows; 
 
    public String deleteData() { 
        String retVal = "confirmation"; 
 
        try { 
 
            userTransaction.begin(); 
 
            CriteriaBuilder criteriaBuilder = <br/>            entityManager.getCriteriaBuilder(); 
           <strong> CriteriaDelete&lt;Address&gt; criteriaDelete 
            = criteriaBuilder.createCriteriaDelete(Address.class); 
            Root&lt;Address&gt; root =<br/>            criteriaDelete.from(Address.class); 
            criteriaDelete.where(criteriaBuilder.or<br/>            (criteriaBuilder.equal(root.get("city"), "New York"), 
             criteriaBuilder.equal(root.get("city"), "New York"))); 
 
            Query query = <br/>            entityManager.createQuery(criteriaDelete);</strong> 
 
            deletedRows = query.executeUpdate(); 
            userTransaction.commit(); 
        } catch (Exception e) { 
            retVal = "error"; 
            e.printStackTrace(); 
        } 
        return retVal; 
    } 
 
    public int getDeletedRows() { 
        return deletedRows; 
    } 
 
    public void setDeletedRows(int updatedRows) { 
        this.deletedRows = updatedRows; 
    } 
} </pre>
<p>To use <kbd>CriteriaDelete</kbd>, we first obtain an instance of <kbd>CriteriaBuilder</kbd> as usual, then invoke the <kbd>createCriteriaDelete()</kbd> method on our <kbd>CriteriaBuilder</kbd> instance to obtain an implementation of <kbd>CriteriaDelete</kbd>.</p>
<p>Once we have an instance of <kbd>CriteriaDelete</kbd>, we build the where clause in the normal way with the Criteria API.</p>
<p>Once we have built our where clause, we obtain an implementation of the <kbd>Query</kbd> interface and invoke <kbd>executeUpdate()</kbd> on it as usual.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bean Validation support</h1>
                </header>
            
            <article>
                
<p>Another feature introduced in JPA 2.0 is support for JSR 303 <strong>Bean Validation</strong>. Bean Validation support allows us to annotate our JPA entities with Bean Validation annotations. These annotations allow us to easily validate user input and perform data sanitation.</p>
<p>Taking advantage of Bean Validation is very simple; all we need to do is annotate our JPA Entity fields or getter methods with any of the validation annotations defined in the <kbd>javax.validation.constraints</kbd> package. Once our fields are annotated as appropriate, the <kbd>EntityManager</kbd> will prevent non-validating data from being persisted.</p>
<p>The following code example is a modified version of the <kbd>Customer</kbd> JPA entity we saw earlier in this chapter. It has been modified to take advantage of Bean Validation in some of its fields:</p>
<pre style="padding-left: 60px">net.ensode.javaee8book.beanvalidation.entity; 
 
import java.io.Serializable; 
 
import javax.persistence.Column; 
import javax.persistence.Entity; 
import javax.persistence.Id; 
import javax.persistence.Table; 
import javax.validation.constraints.NotNull; 
import javax.validation.constraints.Size; 
 
@Entity 
@Table(name = "CUSTOMERS") 
public class Customer implements Serializable 
{ 
  @Id 
  @Column(name = "CUSTOMER_ID") 
  private Long customerId; 
 
  @Column(name = "FIRST_NAME") 
<strong>  @NotNull</strong><strong>  @Size(min=2, max=20)</strong> 
  private String firstName; 
 
  @Column(name = "LAST_NAME") 
<strong>  @NotNull</strong><strong>  @Size(min=2, max=20)</strong> 
  private String lastName; 
 
  private String email; 
 
  public Long getCustomerId() 
  { 
    return customerId; 
  } 
 
  public void setCustomerId(Long customerId) 
  { 
    this.customerId = customerId; 
  } 
 
  public String getEmail() 
  { 
    return email; 
  } 
 
  public void setEmail(String email) 
  { 
    this.email = email; 
  } 
 
  public String getFirstName() 
  { 
    return firstName; 
  } 
 
  public void setFirstName(String firstName) 
  { 
    this.firstName = firstName; 
  } 
 
  public String getLastName() 
  { 
    return lastName; 
  } 
 
  public void setLastName(String lastName) 
  { 
    this.lastName = lastName; 
  } 
} </pre>
<p>In this example, we used the <kbd>@NotNull</kbd> annotation to prevent the <kbd>firstName</kbd> and <kbd>lastName</kbd> of our entity from being persisted with <kbd>null</kbd> values. We also used the <kbd>@Size</kbd> annotation to restrict the minimum and maximum length of these fields.</p>
<p>That is all we need to do to take advantage of Bean Validation in JPA. If our code attempts to persist or update an instance of our entity that does not pass the declared validation, an exception of type <kbd>javax.validation.ConstraintViolationException</kbd> will be thrown, and the entity will not be persisted.</p>
<p>As we can see, Bean Validation pretty much automates data validation, freeing us from having to manually write validation code.</p>
<p>In addition to the two annotations discussed in the previous example, the <kbd>javax.validation.constraints</kbd> package contains several additional annotations we can use to automate validation on our JPA entities. Please refer to the Java EE 8 API documentation at <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a> for the complete list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final notes</h1>
                </header>
            
            <article>
                
<p>In the examples for this chapter, we showed database access performed directly from CDI named beans serving as controllers. We did this to get the point across without getting mired in the details; however, in general, this is not a good practice. Database access code should be encapsulated in <strong>Data Access Objects</strong> (<strong>DAOs</strong>).</p>
<div class="packt_infobox"><span class="WW-DefaultParagraphFont11">For more information on the DAO design pattern, see</span> <a href="http://www.oracle.com/technetwork/java/dao-138818.html"><span class="URLPACKT">http://www.oracle.com/technetwork/java/dao-138818.html.</span></a></div>
<p>Named beans typically assume the role of controllers and/or model when using the <strong>Model-View-Controller</strong> (<strong>MVC</strong>) design pattern, a practice so common that it has become the de facto standard for Java EE applications.</p>
<div class="packt_infobox">For more information about the MVC design pattern, see <a href="http://www.oracle.com/technetwork/java/mvc-140477.html"><span class="URLPACKT">http://www.oracle.com/technetwork/java/mvc-140477.html.</span></a></div>
<p>Additionally, we chose not to show any user interface code in our examples since it is irrelevant to the topic at hand. However, code downloads for this chapter include JSF pages that invoke named beans in this chapter, and display a confirmation page once the named bean invocation finishes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered how to access data in a database via the Java Persistence API (JPA).</p>
<p>We covered how to mark a Java class as a JPA entity by decorating it with the <kbd>@Entity</kbd> annotation. Additionally, we covered how to map an entity to a database table via the <kbd>@Table</kbd> annotation. We also covered how to map entity fields to database columns via the <kbd>@Column</kbd> annotation, as well as declaring an entity's primary key via the <kbd>@Id</kbd> annotation.</p>
<p>Using the <kbd>javax.persistence.EntityManager</kbd> interface to find, persist, and update JPA entities was also covered.</p>
<p>Defining both unidirectional and bidirectional one-to-one, one-to-many, and many-to-many relationships between JPA entities was covered as well.</p>
<p>Additionally, we explored how to use JPA composite primary keys by developing custom primary key classes.</p>
<p>Also, we covered how to retrieve entities from a database by using the Java Persistence Query Language (JPQL).</p>
<p>We discussed additional JPA features such as the Criteria API, which allows us to build JPA queries programmatically; the Metamodel API, which allows us to take advantage of Java's type safety when working with JPA; and Bean Validation, which allows us to easily validate input by simply annotating our JPA entity fields.</p>


            </article>

            
        </section>
    </body></html>