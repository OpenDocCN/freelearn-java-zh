- en: Appendix A. JSF with HTML5, Resources, and Faces Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix contains a quick reference to the JSF library in two parts. The
    first part covers the reference material on the library, architecture resource
    library contracts, and internationalization configuration. The second part is
    dedicated to writing Faces Flows using the Java API.
  prefs: []
  type: TYPE_NORMAL
- en: An HTML5 friendly markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After Java EE 7 and the release of JSF 2.2, the framework always renders the
    HTML5 document type: `<DOCTYPE html>`. This is the default behavior for the modern
    digital websites. With the HTML5 support, developers can just write the content
    in a Facelets view (a `*.xhtml` file) that is compatible with the rendering engines
    in a modern web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSF 2.2 provides two types of attributes for the HTML elements: `pass-through`
    attributes and `pass-through` elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The pass-through attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pass-through` attributes enable JSF to seamlessly support the new and extended
    attributes that are defined by the HTML5\. These attributes are applicable to
    the JSF HTML render kit custom tags such as `<h:inputText>`. In order to use the
    `pass-through` attributes, we will define a JSF namespace at the top of the Facelets
    view that references the URL [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example that uses the HTML5 attributes for a placeholder text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `pass-through` attribute in the preceding example is demarcated with the
    full namespace, `p:placeholder` and `p:type`. One input field annotates for the
    date format and the other for the e-mail address. The value of placeholder provides
    the customer/user with a visual hint about how to fill in the field. The JSF render
    kit will pass this attribute minus the XML namespace to the rendered tag output.
    The value of type overrides the default render kit setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some JavaScript frameworks also rely on extended attributes such as AngularJS
    or certain JQuery plugins. JSF allows page content writers and interface developers
    to pass these values as attributes. The value of the pass-through attribute may
    be dynamic and can also be derived from an EL. We can thus write the following
    markup to validate for a secured loan amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code extract, the `pass-through` attribute `p:type` as a
    range value causes the modern browsers to render a slider control instead of a
    text control. There is a backing bean named `loanHelper` that dynamically supplies
    the minimum, maximum, and step unit values to the control.
  prefs: []
  type: TYPE_NORMAL
- en: The pass-through elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The drawback of the `pass-through` attributes is that they do not look at the
    standard HTML5 attributes that are available in a modern web browser. An input
    field that is defined with a rapid UX markup such as `<h:inputText>` is not directly
    viewable by a stakeholder client without a microservice already running in the
    background process.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the `pass-through` elements in our Facelets view, we must first define
    the JSF namespace `http://xmns.jcp.org/jsf`. In order to trigger a `pass-through`
    element, at least one of the attributes of an HTML element must be in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works in practice with a Facelets view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The HTML elements—`head`, `body`, `form`, `input`, and `button`—have at least
    one JSF namespace attribute. JSF detects the attribute and adds a component to
    its rendering tree. The name of the element determines the type of the component
    that is added. So, the head element is in fact rendered by the equivalent of the
    `<h:head>` custom tag, and the body element is also rendered by the equivalent
    JSF `<h:body>` custom tag. The HTML input type is treated specially and rendered
    with `<h:inputText>`. The `id` and `value` attribute are passed with the JSF namespace.
    The placeholder attributes are passed as normal attributes without the JSF namespace.
    They are surprisingly supplied and treated like `pass-through` attributes!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add validation to what looks like normal HTML5 elements. Here is the
    code to ensure that the user enters at least six characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will insert `<f:validateLength>` as the direct body content of the HTML input
    element. The HTML5 support ensures that the tag is translated as a JSF input component.
    The support also extends to the AJAX tags and library functions.
  prefs: []
  type: TYPE_NORMAL
- en: Resource identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JSF 2.0, a resource is an image, document, or some other digital asset.
    They are placed under the `resources` folder at the web context folder. In a Gradle
    or Maven project, a particular resource lives on the path, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A resource may also be stored in a JAR file under the `WEB-INF/lib` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the resource is stored in a JAR file, it must be located in the `META-INF`
    folder such that it can be located with the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`RESOURCE-IDENTIFIER` can be further divided into separate paths. The widest
    case supports full internalization. The constituent parts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The subterms allow the resource identifiers to be easily identified and separated
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `LOCALE-PREFIX` term represents a locale such as `en_gb` (British
    English) or `de` (Germany).
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional `LIBRARY-NAME` term specifies a library name. You can define the
    library name and use it in the JSF custom tags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example retrieves an application style sheet that is appropriate
    to the library. This helps to distinguish the different parts of your digital
    application. The resource lookup may resolve to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These URLs map to the following source file assets in a conventional project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Developers do not specify the library version. Instead, the JSF Resource Lookup
    mechanism searches for the highest version files of the respective resources.
    The version number of the folder name must match the regex: `\d_\d`. Therefore,
    the `version` folder name `2_0` is greater than `1_5`, which in turn, is higher
    than `1_0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Resource Library Contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.2 introduces the concept of Resource Library Contracts, which allows a
    digital developer to organize a library of assets and templates in a reusable
    set of resources. A resource library contract must reside in the contracts directory
    folder in the application's web context root. In the standard Maven or Gradle
    build convention, this folder is `src/main/webapp/contracts`. Each subfolder in
    the contracts folder represents a named resource contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup for the [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows
    and Finesse"), *JSF Flows and Finesse* used a layout for the Resource Library
    Contracts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/default/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/default/template.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/default/styles/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/default/images/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/victoria/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/victoria/template.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/victoria/styles/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/src/main/webapp/contracts/victoria/images/`'
  prefs: []
  type: TYPE_NORMAL
- en: Every contract must have at least one declared `template.xhtml` file. A contract
    may have more than one template for its own customization. The declared template
    has at least one declared insertion point, which is defined as the `<ui:insert>`
    tag. A template usually relies on the digital assets, and these are known as declared
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contracts can be packaged in the JAR files for a customer''s use. A resource
    library contract must be placed in the `META-INF/contracts` folder of the JAR
    file. So, we could repackage the flow examples in the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/default/javax.faces.contract.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/default/template.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/default/styles/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/default/images/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/victoria/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/victoria/javax.faces.contract.xml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/victoria/template.xhtml`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/victoria/styles/app.css`'
  prefs: []
  type: TYPE_NORMAL
- en: '`META-INF/contracts/victoria/images/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add an empty marker file to each contract, `javax.faces.contract.xml`.
    The reference for this filename is found in the static `string: javax.faces.application.ResourceHandler.RESOURCE_CONTRACT_XML`.'
  prefs: []
  type: TYPE_NORMAL
- en: A Faces servlet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JSF, FacesServlet acts as the front controller, is the conduit for all the
    requests, and also sends the response back to the client. This servlet is a subclass
    of `javax.servlet.Servlet`.
  prefs: []
  type: TYPE_NORMAL
- en: A web browser client sends an HTTP request to the servlet container. If it is
    a Faces request, then the servlet container invokes the `service()` method of
    FacesServlet. The method hands over the processing of the request to a member
    instance `javax.faces.lifecycle.LifeCycle` object. The method also creates a FacesContext
    instance. The `LifeCycle` instance is responsible for the processing of a request
    to all of the JSF phases described in [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer
    Faces Lifecycle"), *JavaServer Faces Lifecycle* and the rendering of the response.
  prefs: []
  type: TYPE_NORMAL
- en: Reconfiguration of the resource paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to change the path name of the resource lookup and contract folders
    as well by configuring the web XML deployment descriptor. The constants are defined
    in the `javax.faces.application.ResourceHandler` class. The `WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME`
    string constant defines the resource directory property's name and `WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`
    defines the contract directory property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can redefine the JSF web application defaults with the following `web.xml`
    settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can specify the initial parameters on the Faces servlet in overriding the
    default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: A JSF-specific configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Faces servlet understands several other configuration parameters. Here
    is a table of the possible parameter names. These are prefixed with `javax.faces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CONFIG_FILES` | This specifies a comma-delimited list of the additional
    context related resource paths that are loaded automatically with `WEB-INF/faces-config.xml`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DEFAULT_SUFFIX` | This sets the suffix for the JSF files; the default is
    `*.xhtml`. If you change this configuration, then I recommend that you also change
    welcome-file-list in `web.xml`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DISABLE_FACELET_JSF_VIEW_HANDLER` | If this parameter is set to `true`,
    then it disables Facelets as the default page declaration language. The default
    is `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `FACELETS_BUFFER_SIZE` | This specifies the buffer size for a JSF response.
    The default size is `-1`, which means an unlimited size. |'
  prefs: []
  type: TYPE_TB
- en: '| `FACELETS_REFRESH_PERIOD` | This sets the interval time in seconds that the
    JSF compiler should check for changes. In the production mode, this value is set
    to `-1`, which means that the JSF compiler should not check; otherwise, the default
    is set to `2` in the reference implementation. |'
  prefs: []
  type: TYPE_TB
- en: '| `FACELETS_SKIP_COMMENT` | This is a Boolean value that determines if the
    XML comments in a Facelets view is included in a response. The default value is
    `true`. |'
  prefs: []
  type: TYPE_TB
- en: '| `FACELETS_LIBRARIES` | This specifies a semicolon delimited list collection
    of the Facelets tag libraries by a path. |'
  prefs: []
  type: TYPE_TB
- en: '| `LIFECYCLE_ID` | This overrides the default implementation of the JSF `javax.faces.lifecycle.Lifecycle`
    instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `PROJECT_STAGE` | This specifies the development project stage. The acceptable
    values are `Development`, `UnitTest`, `SystemTest`, or `Production`. |'
  prefs: []
  type: TYPE_TB
- en: '| `STATE_SAVING_METHOD` | This specifies the location where a state is saved
    in a JSF application. The acceptable values are `client` and `server`. |'
  prefs: []
  type: TYPE_TB
- en: '| `WEBAPP_CONTRACTS_DIRECTORY` | This overrides the default location of the
    JSF resource contracts. The default is `<web-context>/contracts`. |'
  prefs: []
  type: TYPE_TB
- en: '| `WEBAPP_RESOURCES_DIRECTORY` | This overrides the default location of the
    JSF resources reserved for the digital assets. The default is `<web-context>/resources`.
    |'
  prefs: []
  type: TYPE_TB
- en: These settings are best configured in the web deployment descriptor file (`web.xml`).
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A JSF application can be internationalized with standard resource bundles (`java.util.ResourceBundle`)
    and messages. Resource bundles are suitable to internationalize the text on the
    components, controls, and digital assets; whereas message files are meant to internationalize
    the JSF validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: In a Gradle or Maven project, we will add a resource bundle or message file
    to the `src/main/resources` project location with the necessary Java package as
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: Resource bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will configure the resource bundles in the Faces configuration file, `/WEB-INF/faces-config.xml`,
    for the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the contact details application in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*, we have two
    resource bundle files in English and German: `appMessages.properties` and `appMessage_de.properties`
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the English language bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the German language bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use these bundles in our JSF bundle, we will configure the Faces
    configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will define a resource bundle configuration in `/WEB-INF/faces-config.xml`
    for our application messages. In this file, we can define an application scope
    variable for our bundle, namely `appMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can use the bundle with an EL syntax. Here is the code for the
    house number in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we use dots (`.`) in our property name, we must use the map EL syntax so
    as to obtain the required message: `#{appMessages[''contactForm.houseOrFlatNumber'']}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resource bundles may also contain parameterized message properties with formatted
    token arguments. The token arguments are expanded during message resolution by
    the JSF framework or through application custom code. Here is an example of parameterized
    message property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use the `<h:outputFormat>` tag to render the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Message bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The backing code in the JSF applications in general may generate messages for
    the output that can also be internationalized. The messages are stored in the
    FacesContext object. We will need to ensure that a user can see all or some of
    these messages. We will do this with the `<h:messages>` or `<h:message>` JSF tags.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX*, we already looked at `faces-config.xml` for the message
    bundles.
  prefs: []
  type: TYPE_NORMAL
- en: A browser configured locale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For many digital sites, the user's browser determines the locale of the website.
    Developers can inform JSF about the languages that are supported in an application
    in the `/WEB/faces-config.xml file`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the setting for the contact details application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we will specify that our default locale is English and the supported
    locales are French and German.
  prefs: []
  type: TYPE_NORMAL
- en: An application controlled locale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are certain digital sites where the requirement is to allow the user to
    switch between two or more locales. So, we must programmatically achieve this
    goal. For each rendered view in JSF, we will need to set the locale in the controller
    method. We will use FacesContext to gain access to the root view UI in the Faces
    response and set the locale here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we are working for a sports automotive manufacturer with their
    offices in London, UK, and Heidelberg, Southern Germany; then, we can write the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The view will be set to the German locale.
  prefs: []
  type: TYPE_NORMAL
- en: An individual page controlled locale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the stakeholder wants a digital site where each individual page may have
    its own configured locale, then JSF can achieve this goal. Developers can use
    the `<f:view>` view tag to override the locale for a page. Before the JSF 2.0
    standard, the view tag wrapped the content and acted as a container element. In
    JSF 2.0 and later versions, this is now unnecessary and the view tag can set the
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code extract that retrieves the locale from a user profile bean with
    a property called `primaryLocale`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the session-scoped bean that goes with the page view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A web deployment descriptor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is to go to a separate appendix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a reference development XML deployment descriptor for JSF 2.2 and Java
    EE 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Programmatic Faces Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this appendix, we will provide a quick reference to the JavaServer Faces
    Flow. A flow is as per user and per web application finite state machine is with
    nodes. There is a default entry node and at least one exit node.
  prefs: []
  type: TYPE_NORMAL
- en: View types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and Finesse"),
    *JSF Flows and Finesse*, we discussed the building of the flow navigation from
    the Faces configuration XML file. The JSF 2.2 specification describes the convention
    to store and set up the flows with a directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of nodes. They are tabulated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Node type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| View Node | This node represents a view. The JSF provider renders the view,
    the flow is still active. |'
  prefs: []
  type: TYPE_TB
- en: '| Return Node | This node represents an exit point from the flow to the outside
    of this flow. The current flow terminates on the invocation of this node. |'
  prefs: []
  type: TYPE_TB
- en: '| Flow Call Node | This node represents an invocation to another nested flow.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Method Call Node | This node represents an invocation to a method call in
    a flow-scoped bean. After leaving this method call, the current flow is still
    active. |'
  prefs: []
  type: TYPE_TB
- en: '| Switch Node | This node represents a selectable conditional state. Depending
    on the state, the flow may move to one or more alternative states and there is
    a default outcome. The current flow is still active. |'
  prefs: []
  type: TYPE_TB
- en: '| Navigation Case Node | This node represents a generalized conditional state
    with navigation. Depending on the state, the flow may move to a new outcome or
    execute an HTTP redirect out of the flow. |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By comparing the Faces Flows with the other flows or business process technology,
    it should be acknowledged that there is no so-called initial node.
  prefs: []
  type: TYPE_NORMAL
- en: The Faces Flows programmatic interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Faces Flows are powered by CDI. It is possible to write programmatic flows
    by declaring a POJO that produces a Faces Flow. In order to generate a flow dynamically,
    we must annotate a bean as a CDI producer and generate a flow instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic `SimpleFlowFactory` class that supplies a Faces Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will annotate the `createFlow()` method as a CDI producer with the special
    qualifier, `@FlowDefinition`. We will also supply this method with a single argument,
    `FlowBuilder`, which is also annotated with `@FlowBuilderParameter`. These definitions,
    by the way, are found in the reserved imported package: `javax.faces.flow.builder`.
    We use an injected `FlowBuilder` to generate a specific flow. The actual node
    types are found in the `javax.faces.flow` package.'
  prefs: []
  type: TYPE_NORMAL
- en: A Faces Flow requires a flow identifier, which is `simpleFlow`. We can optionally
    also define a specific document ID. We will use a dependent generator instance
    to demonstrate how this works. If there is no need for a document ID, then supply
    an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Faces Flow requires at least one view, which is usually the default name
    in the XML configuration. In order to complete the first view node, we will define
    a ViewNode and the URI for the flow''s view template: `/simpleFlow/simpleFlow.xhtml`.
    We will also need to set the flow''s start node with the call set to `markAsStartNode()`,
    because a Faces Flow requires an initial node. The API for `FlowBuilder` is taken
    from the fluent builder pattern. At the end of the `createFlow()` method, we will
    generate a flow instance and return it. The JSF provider takes over the flow definition
    from this point onwards.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that as we are building the flow ourselves, we don't have to follow
    all the rules of the XML configuration exactly. However, all the view templates
    for a flow definition must fall under one single folder in the root context of
    the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just because we defined a flow definition producer, we will still require the
    actually flow-scoped bean, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will look at the specifics of each node type in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following UML class diagram illustrates the key types in the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Faces Flows programmatic interface](img/image00428.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: UML class diagram for the Faces Flow API
  prefs: []
  type: TYPE_NORMAL
- en: ViewNode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `FlowBuilder`, we can define the ViewNode instances. The actual type is
    a subclass of `javax.faces.faces.ViewNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example of a code extends the last flow instance and provides
    additional view nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `viewNode()` method accepts two arguments. The first argument is the view
    node ID, which we will write in and refer to in the view content. The second argument
    is the view description language document identifier, which translates to the
    URI of the Facelets view.
  prefs: []
  type: TYPE_NORMAL
- en: The path of the URI can also be a relative URL. This means the eventual path
    is relative to the flow URI path. Otherwise, the URI must be absolute in terms
    of the web context root path, as we can see in the preceding code extract.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewNode()` method returns a `ViewBuilder` type, which has only one additional
    `markAsStartNode()` method.
  prefs: []
  type: TYPE_NORMAL
- en: ReturnNode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also generate a ReturnNode instance from `FlowBuilder`. This is straightforward
    with the `returnNode()` method. The actual type is a subclass of `javax.faces.faces.ReturnNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an extract of the `createFlow()` method that specifies a return node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `returnNode()` method accepts a single argument the view node ID and returns
    an instance of `ReturnBuilder`. The `fromOutcome()` method call specifies the
    view name of the outcome that we navigate to after returning from the current
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: MethodCall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the `FlowBuilder` instance, we can also create a method call node and
    add it to the Faces Flow. The actual type is a subclass of `javax.faces.faces.MethodCallNode`.
    Here is the POJO class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `methodCallNode()` call accepts a view node ID and creates a `MethodCallBuilder`
    instance. This node requires an expression that informs JSF about the name of
    the bean and the method to invoke. Here, the method is `verifyCustomer()` on an
    accessible backing bean controller `loanController`. We can also pass the account
    record in the customer's details using an expression language. In case the target
    method invocation returns null or an empty string, we can specify a default outcome
    view identifier.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you should reduce the coupling in a layered architecture as
    much as possible. Be careful about mixing too much presentation tier information
    with the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: FlowCall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a flow call node using the same abstract class type `FlowBuilder`.
    This node type invokes a nested Faces Flow. The `flowCallNode()` method accepts
    a single argument in the view node ID and returns a `FlowCallBuilder` instance.
    The actual type is a subclass of `javax.faces.faces.FlowCallNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code extract, which is based on the *Industrial sector carbon footprint*
    discussion from [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and
    Finesse"), *JSF Flows and Finesse*, we will rewrite the flow definition XML file
    called `footprint-flow.xml` as the following `SectorFlowFactory` POJO class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the node is identified as `callFootprintFlow`. We must
    provide the node ID of the nest flow through a `flowReference()` method. The first
    argument of `flowReference()` is the flow document ID, which is an empty string
    here. The nested flow is identified as footprint-flow by the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `outboundParameter()` method on `FlowCallBuilder` in order to
    declare the outbound parameters that pass the data from the calling sector-flow
    to the nested footprint-flow. The first argument to `outboundParameter()` is the
    parameter name and the second argument is a literal string or an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also rewrite the flow definition XML file from the nested flow programmatically.
    Here is an extract of the `FootprintFlowFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we notice that the footprint-flow ID must match the caller reference
    ID. For this Faces Flow, we will declare the inbound parameters with the `inboundParameter()`
    method call. The first argument is the parameter name and the second is an expression
    language reference that defines where the value is stored.
  prefs: []
  type: TYPE_NORMAL
- en: SwitchNode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `FlowBuilder` to create the declaration of a switch node. These node
    types are composed of an association between a conditional statement and the outcome.
    The outcome is the view ID. A switch node has one or more conditional statements.
    It may also have a default outcome. During the processing of the flow, JSF executes
    each conditional statement in turn. If it evaluates to true (or rather, `Boolean.TRUE`),
    then the associated outcome is the chosen one. The actual type is a subclass of
    `javax.faces.faces.SwitchNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let ''s see an example of the switch node in action in a POJO. Here is another
    class for a monetary loan decision maker called `LoanDecisionFlowFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the `createFlow()` method, we will create a Faces Flow identified as loan-application.
    We will then create a switch node declaration with `switchNode()` and identified
    as loan-decision. This method returns a `SwitchBuilder` type. This builder type
    has `switchCase()` that returns `SwitchCaseBuilder`. The other overloaded methods
    included are called `defaultCome()`.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you also declare a default outcome with the `defaultOutcome()`
    method, which accepts a view ID. In this way, the flow always moves to the next
    viable location.
  prefs: []
  type: TYPE_NORMAL
- en: Given the `SwitchBuilder` builder type, we will declare the individual cases
    with the `condition()` and `fromOutCome()` methods. The `condition()` call accepts
    an expression string and it returns `SwitchCaseBuilder`. The only property on
    this builder is a valid outcome, which is a view identifier.
  prefs: []
  type: TYPE_NORMAL
- en: NavigationCase node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final builder type in the API relates to a general abstract class type `NavigationCaseBuilder`.
    We can create a navigation case node with `FlowBuilder`. The actual type is a
    subclass of `javax.faces.faces.FlowNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a POJO from the financial services domain that is designed to allow
    the back office staff in an investment bank to post the process trades in a workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this `PostProcessTradeFlowFactory` POJO, we again have a `createFlow()` method,
    but this time we will call `navigationCase()` twice. This method has no arguments
    and returns a `NavigationCaseBuilder` type that creates the specified Faces Flow.
    A navigation case flow requires a trigger point, a conditional expression, and
    an outcome or redirection response.
  prefs: []
  type: TYPE_NORMAL
- en: In the first flow, we will call the `fromOutcome()` method on `NavigationCaseBuilder`
    in order to declare the JSF view ID that triggers the check. The `condition()`
    method defines the expression that must return a Boolean value. The `toViewId()`
    method defines the outcome view ID to navigate if the conditional expression evaluates
    as `Boolean.TRUE`. So, therefore, if the trade value exceeds the firm-wide exposure
    limit (`trade.amount > global.risk.limit`), then the flow navigates to the exceptional
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the second flow declaration, we will define a navigation case to handle
    an out-of-currency deal, which might be a Swap, Bond, or some other derivative.
    With the same trigger outcome trade check, we will trap on the expression for
    the currencies that settles in non-US dollars: `trade.settlementCcy != ''USD''`.
    With this navigation case node, we will execute an HTTP redirect that causes the
    customer to exit the entire flow. We will invoke `redirect()` and it will return
    `NavigationCaseBuilder.RedirectBuilder`. This nested abstract class has two methods:
    `includeViewParams()` and `parameter()`. The `includeViewParams()` method adds
    all of the view parameters to the redirect URL. The `parameter()` method adds
    the name and value pairs to the redirect URL. Remember that after the flow is
    completed, from a security digital developer''s point of view, these parameters
    will be highly visible in the URL of the eventual HTTP GET request!'
  prefs: []
  type: TYPE_NORMAL
- en: Builder types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The builder types—`ViewBuilder`, `ReturnBuilder`, `MethodCallBuilder`, `FlowCallBuilder`,
    `SwitchBuilder`, `SwitchCaseBuilder`, and `NavigationCaseBuilder` are abstract
    classes. They are implementations of the `javax.faces.flow.builder.NodeBuilder`
    interface. The Faces Flow API is an example of an embedded Domain Specific Language.
  prefs: []
  type: TYPE_NORMAL
