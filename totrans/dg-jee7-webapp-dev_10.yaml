- en: Appendix A. JSF with HTML5, Resources, and Faces Flows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. JSF与HTML5、资源和Faces Flows
- en: This appendix contains a quick reference to the JSF library in two parts. The
    first part covers the reference material on the library, architecture resource
    library contracts, and internationalization configuration. The second part is
    dedicated to writing Faces Flows using the Java API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录包含JSF库的快速参考，分为两部分。第一部分涵盖了库的参考资料、架构资源库合同和国际化配置。第二部分专门介绍使用Java API编写Faces Flows。
- en: An HTML5 friendly markup
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个HTML5友好的标记
- en: 'After Java EE 7 and the release of JSF 2.2, the framework always renders the
    HTML5 document type: `<DOCTYPE html>`. This is the default behavior for the modern
    digital websites. With the HTML5 support, developers can just write the content
    in a Facelets view (a `*.xhtml` file) that is compatible with the rendering engines
    in a modern web browser.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java EE 7和JSF 2.2发布之后，框架始终渲染HTML5文档类型：`<DOCTYPE html>`。这是现代数字网站的默认行为。有了HTML5支持，开发者只需在Facelets视图（一个`*.xhtml`文件）中编写内容，该视图与现代网络浏览器的渲染引擎兼容。
- en: 'JSF 2.2 provides two types of attributes for the HTML elements: `pass-through`
    attributes and `pass-through` elements.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2为HTML元素提供了两种类型的属性：`pass-through`属性和`pass-through`元素。
- en: The pass-through attributes
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透传属性
- en: The `pass-through` attributes enable JSF to seamlessly support the new and extended
    attributes that are defined by the HTML5\. These attributes are applicable to
    the JSF HTML render kit custom tags such as `<h:inputText>`. In order to use the
    `pass-through` attributes, we will define a JSF namespace at the top of the Facelets
    view that references the URL [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass-through`属性使JSF能够无缝支持由HTML5定义的新和扩展属性。这些属性适用于JSF HTML渲染套件的自定义标签，如`<h:inputText>`。为了使用`pass-through`属性，我们将在Facelets视图的顶部定义一个JSF命名空间，该命名空间引用URL
    [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough)。'
- en: 'Let''s take an example that uses the HTML5 attributes for a placeholder text:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个使用HTML5属性作为占位文本的例子：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `pass-through` attribute in the preceding example is demarcated with the
    full namespace, `p:placeholder` and `p:type`. One input field annotates for the
    date format and the other for the e-mail address. The value of placeholder provides
    the customer/user with a visual hint about how to fill in the field. The JSF render
    kit will pass this attribute minus the XML namespace to the rendered tag output.
    The value of type overrides the default render kit setting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`pass-through`属性使用完整的命名空间`p:placeholder`和`p:type`进行标记。一个输入字段用于日期格式，另一个用于电子邮件地址。占位符的值向客户/用户提供了一个视觉提示，说明如何填写字段。JSF渲染套件会将此属性（减去XML命名空间）传递给渲染的标签输出。类型值覆盖了默认渲染套件的设置。
- en: 'Some JavaScript frameworks also rely on extended attributes such as AngularJS
    or certain JQuery plugins. JSF allows page content writers and interface developers
    to pass these values as attributes. The value of the pass-through attribute may
    be dynamic and can also be derived from an EL. We can thus write the following
    markup to validate for a secured loan amount:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些JavaScript框架也依赖于扩展属性，例如AngularJS或某些JQuery插件。JSF允许页面内容编写者和界面开发者将这些值作为属性传递。透传属性的值可能是动态的，也可以从EL中派生。因此，我们可以编写以下标记来验证安全的贷款金额：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the preceding code extract, the `pass-through` attribute `p:type` as a
    range value causes the modern browsers to render a slider control instead of a
    text control. There is a backing bean named `loanHelper` that dynamically supplies
    the minimum, maximum, and step unit values to the control.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`pass-through`属性`p:type`作为范围值会导致现代浏览器渲染滑动控件而不是文本控件。有一个名为`loanHelper`的后备bean，它动态地向控件提供最小值、最大值和步进单位值。
- en: The pass-through elements
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透传元素
- en: The drawback of the `pass-through` attributes is that they do not look at the
    standard HTML5 attributes that are available in a modern web browser. An input
    field that is defined with a rapid UX markup such as `<h:inputText>` is not directly
    viewable by a stakeholder client without a microservice already running in the
    background process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`pass-through`属性的缺点是它们不考虑现代网络浏览器中可用的标准HTML5属性。使用快速UX标记（如`<h:inputText>`）定义的输入字段，如果没有在后台运行微服务，则利益相关者客户端无法直接查看。'
- en: To enable the `pass-through` elements in our Facelets view, we must first define
    the JSF namespace `http://xmns.jcp.org/jsf`. In order to trigger a `pass-through`
    element, at least one of the attributes of an HTML element must be in the namespace.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用我们的Facelets视图中的`pass-through`元素，我们首先必须定义JSF命名空间`http://xmlns.jcp.org/jsf`。为了触发`pass-through`元素，至少一个HTML元素的属性必须在命名空间中。
- en: 'Let''s see how this works in practice with a Facelets view:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在实际的Facelets视图中它是如何工作的：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The HTML elements—`head`, `body`, `form`, `input`, and `button`—have at least
    one JSF namespace attribute. JSF detects the attribute and adds a component to
    its rendering tree. The name of the element determines the type of the component
    that is added. So, the head element is in fact rendered by the equivalent of the
    `<h:head>` custom tag, and the body element is also rendered by the equivalent
    JSF `<h:body>` custom tag. The HTML input type is treated specially and rendered
    with `<h:inputText>`. The `id` and `value` attribute are passed with the JSF namespace.
    The placeholder attributes are passed as normal attributes without the JSF namespace.
    They are surprisingly supplied and treated like `pass-through` attributes!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素（`head`、`body`、`form`、`input`和`button`）至少有一个JSF命名空间属性。JSF检测该属性并向其渲染树添加一个组件。元素名称决定了添加的组件类型。因此，`head`元素实际上是通过等效的`<h:head>`自定义标签渲染的，而`body`元素也是通过等效的JSF
    `<h:body>`自定义标签渲染的。HTML输入类型被特别处理，并使用`<h:inputText>`渲染。`id`和`value`属性通过JSF命名空间传递。占位符属性作为正常属性传递，不带JSF命名空间。它们意外地被提供并像`pass-through`属性一样处理！
- en: 'We can add validation to what looks like normal HTML5 elements. Here is the
    code to ensure that the user enters at least six characters:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为看起来像是正常的HTML5元素添加验证。以下代码确保用户至少输入六个字符：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will insert `<f:validateLength>` as the direct body content of the HTML input
    element. The HTML5 support ensures that the tag is translated as a JSF input component.
    The support also extends to the AJAX tags and library functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把`<f:validateLength>`作为HTML输入元素的直接体内容插入。HTML5支持确保该标签被翻译为JSF输入组件。支持还扩展到AJAX标签和库函数。
- en: Resource identifiers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源标识符
- en: 'In JSF 2.0, a resource is an image, document, or some other digital asset.
    They are placed under the `resources` folder at the web context folder. In a Gradle
    or Maven project, a particular resource lives on the path, as shown:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.0中，资源是一个图像、文档或其他数字资产。它们被放置在Web上下文文件夹下的`resources`文件夹中。在一个Gradle或Maven项目中，特定的资源位于路径上，如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A resource may also be stored in a JAR file under the `WEB-INF/lib` folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个资源也可以存储在`WEB-INF/lib`文件夹下的JAR文件中：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the resource is stored in a JAR file, it must be located in the `META-INF`
    folder such that it can be located with the path:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源存储在JAR文件中，它必须位于`META-INF`文件夹中，以便可以通过路径找到：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`RESOURCE-IDENTIFIER` can be further divided into separate paths. The widest
    case supports full internalization. The constituent parts are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESOURCE-IDENTIFIER`可以进一步细分为单独的路径。最广泛的情况支持完全本地化。组成部分如下：'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The subterms allow the resource identifiers to be easily identified and separated
    out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 子术语允许轻松识别和分离资源标识符。
- en: The optional `LOCALE-PREFIX` term represents a locale such as `en_gb` (British
    English) or `de` (Germany).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`LOCALE-PREFIX`术语表示一个区域设置，例如`en_gb`（英国英语）或`de`（德国）。
- en: 'The optional `LIBRARY-NAME` term specifies a library name. You can define the
    library name and use it in the JSF custom tags, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`LIBRARY-NAME`术语指定了一个库名称。你可以定义库名称并在JSF自定义标签中使用它，如下所示：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding example retrieves an application style sheet that is appropriate
    to the library. This helps to distinguish the different parts of your digital
    application. The resource lookup may resolve to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例检索了适合库的应用样式表。这有助于区分你的数字应用的不同部分。资源查找可能解析为以下内容：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These URLs map to the following source file assets in a conventional project:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些URL映射到传统项目中的以下源文件资产：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Developers do not specify the library version. Instead, the JSF Resource Lookup
    mechanism searches for the highest version files of the respective resources.
    The version number of the folder name must match the regex: `\d_\d`. Therefore,
    the `version` folder name `2_0` is greater than `1_5`, which in turn, is higher
    than `1_0`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者不指定库版本。相反，JSF资源查找机制搜索相应资源的最高版本文件。文件夹名称的版本号必须匹配正则表达式：`\d_\d`。因此，`version`文件夹名称`2_0`大于`1_5`，而`1_5`又大于`1_0`。
- en: Resource Library Contracts
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源库合同
- en: JSF 2.2 introduces the concept of Resource Library Contracts, which allows a
    digital developer to organize a library of assets and templates in a reusable
    set of resources. A resource library contract must reside in the contracts directory
    folder in the application's web context root. In the standard Maven or Gradle
    build convention, this folder is `src/main/webapp/contracts`. Each subfolder in
    the contracts folder represents a named resource contract.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2引入了资源库合同的概念，允许数字开发者将资产和模板组织成一个可重用的资源集。资源库合同必须位于应用程序的web上下文根目录中的合同目录文件夹中。在标准的Maven或Gradle构建约定中，这个文件夹是`src/main/webapp/contracts`。合同文件夹中的每个子文件夹代表一个命名的资源合同。
- en: 'The setup for the [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows
    and Finesse"), *JSF Flows and Finesse* used a layout for the Resource Library
    Contracts, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章](part0057.xhtml#aid-1MBG21 "第6章。JSF流程和技巧")的设置，*JSF流程和技巧*使用了资源库合同的布局，如下所示：'
- en: '`/src/main/webapp/contracts/`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/`'
- en: '`/src/main/webapp/contracts/default/`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/default/`'
- en: '`/src/main/webapp/contracts/default/template.xhtml`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/default/template.xhtml`'
- en: '`/src/main/webapp/contracts/default/styles/app.css`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/default/styles/app.css`'
- en: '`/src/main/webapp/contracts/default/images/`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/default/images/`'
- en: '`/src/main/webapp/contracts/victoria/`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/victoria/`'
- en: '`/src/main/webapp/contracts/victoria/template.xhtml`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/victoria/template.xhtml`'
- en: '`/src/main/webapp/contracts/victoria/styles/app.css`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/victoria/styles/app.css`'
- en: '`/src/main/webapp/contracts/victoria/images/`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src/main/webapp/contracts/victoria/images/`'
- en: Every contract must have at least one declared `template.xhtml` file. A contract
    may have more than one template for its own customization. The declared template
    has at least one declared insertion point, which is defined as the `<ui:insert>`
    tag. A template usually relies on the digital assets, and these are known as declared
    resources.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合同至少必须有一个声明的`template.xhtml`文件。合同可以拥有多个模板以进行自定义。声明的模板至少有一个声明的插入点，这被定义为`<ui:insert>`标签。模板通常依赖于数字资产，这些被称为声明的资源。
- en: 'Contracts can be packaged in the JAR files for a customer''s use. A resource
    library contract must be placed in the `META-INF/contracts` folder of the JAR
    file. So, we could repackage the flow examples in the following layout:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 合同可以被打包成JAR文件供客户使用。资源库合同必须放置在JAR文件的`META-INF/contracts`文件夹中。因此，我们可以按照以下布局重新打包流程示例：
- en: '`META-INF/contracts/`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/`'
- en: '`META-INF/contracts/default/javax.faces.contract.xml`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/default/javax.faces.contract.xml`'
- en: '`META-INF/contracts/default/template.xhtml`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/default/template.xhtml`'
- en: '`META-INF/contracts/default/styles/app.css`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/default/styles/app.css`'
- en: '`META-INF/contracts/default/images/`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/default/images/`'
- en: '`META-INF/contracts/victoria/`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/victoria/`'
- en: '`META-INF/contracts/victoria/javax.faces.contract.xml`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/victoria/javax.faces.contract.xml`'
- en: '`META-INF/contracts/victoria/template.xhtml`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/victoria/template.xhtml`'
- en: '`META-INF/contracts/victoria/styles/app.css`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/victoria/styles/app.css`'
- en: '`META-INF/contracts/victoria/images/`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`META-INF/contracts/victoria/images/`'
- en: 'We will need to add an empty marker file to each contract, `javax.faces.contract.xml`.
    The reference for this filename is found in the static `string: javax.faces.application.ResourceHandler.RESOURCE_CONTRACT_XML`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为每个合同添加一个空的标记文件，`javax.faces.contract.xml`。这个文件名的引用可以在静态字符串`javax.faces.application.ResourceHandler.RESOURCE_CONTRACT_XML`中找到。
- en: A Faces servlet
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个Faces servlet
- en: In JSF, FacesServlet acts as the front controller, is the conduit for all the
    requests, and also sends the response back to the client. This servlet is a subclass
    of `javax.servlet.Servlet`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF中，FacesServlet充当前端控制器，是所有请求的通道，同时也将响应发送回客户端。这个servlet是`javax.servlet.Servlet`的子类。
- en: A web browser client sends an HTTP request to the servlet container. If it is
    a Faces request, then the servlet container invokes the `service()` method of
    FacesServlet. The method hands over the processing of the request to a member
    instance `javax.faces.lifecycle.LifeCycle` object. The method also creates a FacesContext
    instance. The `LifeCycle` instance is responsible for the processing of a request
    to all of the JSF phases described in [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer
    Faces Lifecycle"), *JavaServer Faces Lifecycle* and the rendering of the response.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网络浏览器客户端向 servlet 容器发送 HTTP 请求。如果是 Faces 请求，则 servlet 容器调用 FacesServlet 的 `service()`
    方法。该方法将请求的处理交给一个成员实例 `javax.faces.lifecycle.LifeCycle` 对象。该方法还创建了一个 FacesContext
    实例。`LifeCycle` 实例负责处理请求到所有在 [第 2 章](part0025.xhtml#aid-NQU22 "第 2 章. JavaServer
    Faces 生命周期") 中描述的 JSF 阶段，即 *JavaServer Faces 生命周期* 以及响应的渲染。
- en: Reconfiguration of the resource paths
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源路径的重配置
- en: It is possible to change the path name of the resource lookup and contract folders
    as well by configuring the web XML deployment descriptor. The constants are defined
    in the `javax.faces.application.ResourceHandler` class. The `WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME`
    string constant defines the resource directory property's name and `WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`
    defines the contract directory property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置 web XML 部署描述符，还可以更改资源查找和合同文件夹的路径名称。常量定义在 `javax.faces.application.ResourceHandler`
    类中。`WEBAPP_RESOURCES_DIRECTORY_PARAM_NAME` 字符串常量定义了资源目录属性名称，而 `WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`
    定义了合同目录属性。
- en: 'We can redefine the JSF web application defaults with the following `web.xml`
    settings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 `web.xml` 设置重新定义 JSF 网络应用程序的默认值：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can specify the initial parameters on the Faces servlet in overriding the
    default configuration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在覆盖默认配置的情况下在 Faces servlet 上指定初始参数。
- en: A JSF-specific configuration
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSF 特定配置
- en: 'The Faces servlet understands several other configuration parameters. Here
    is a table of the possible parameter names. These are prefixed with `javax.faces`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Faces servlet 理解其他几个配置参数。以下是可能的参数名称列表。这些名称以 `javax.faces` 为前缀：
- en: '| Parameter name | Description |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 参数名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CONFIG_FILES` | This specifies a comma-delimited list of the additional
    context related resource paths that are loaded automatically with `WEB-INF/faces-config.xml`.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `CONFIG_FILES` | 这指定了一个逗号分隔的列表，包含与上下文相关的附加资源路径，这些路径会自动与 `WEB-INF/faces-config.xml`
    一起加载。 |'
- en: '| `DEFAULT_SUFFIX` | This sets the suffix for the JSF files; the default is
    `*.xhtml`. If you change this configuration, then I recommend that you also change
    welcome-file-list in `web.xml`. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `DEFAULT_SUFFIX` | 这设置了 JSF 文件的后缀；默认为 `*.xhtml`。如果您更改此配置，则建议您也更改 `web.xml`
    中的 welcome-file-list。'
- en: '| `DISABLE_FACELET_JSF_VIEW_HANDLER` | If this parameter is set to `true`,
    then it disables Facelets as the default page declaration language. The default
    is `false`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `DISABLE_FACELET_JSF_VIEW_HANDLER` | 如果此参数设置为 `true`，则禁用 Facelets 作为默认页面声明语言。默认值为
    `false`。 |'
- en: '| `FACELETS_BUFFER_SIZE` | This specifies the buffer size for a JSF response.
    The default size is `-1`, which means an unlimited size. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `FACELETS_BUFFER_SIZE` | 这指定了 JSF 响应的缓冲区大小。默认大小为 `-1`，表示无限制大小。 |'
- en: '| `FACELETS_REFRESH_PERIOD` | This sets the interval time in seconds that the
    JSF compiler should check for changes. In the production mode, this value is set
    to `-1`, which means that the JSF compiler should not check; otherwise, the default
    is set to `2` in the reference implementation. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `FACELETS_REFRESH_PERIOD` | 这设置 JSF 编译器检查更改的间隔时间（秒）。在生产模式下，此值设置为 `-1`，表示
    JSF 编译器不应检查；否则，在参考实现中默认设置为 `2`。 |'
- en: '| `FACELETS_SKIP_COMMENT` | This is a Boolean value that determines if the
    XML comments in a Facelets view is included in a response. The default value is
    `true`. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `FACELETS_SKIP_COMMENT` | 这是一个布尔值，用于确定 Facelets 视图中的 XML 注释是否包含在响应中。默认值为
    `true`。 |'
- en: '| `FACELETS_LIBRARIES` | This specifies a semicolon delimited list collection
    of the Facelets tag libraries by a path. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `FACELETS_LIBRARIES` | 这指定了一个分号分隔的列表集合，通过路径指定 Facelets 标签库。 |'
- en: '| `LIFECYCLE_ID` | This overrides the default implementation of the JSF `javax.faces.lifecycle.Lifecycle`
    instance. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `LIFECYCLE_ID` | 这覆盖了 JSF `javax.faces.lifecycle.Lifecycle` 实例的默认实现。 |'
- en: '| `PROJECT_STAGE` | This specifies the development project stage. The acceptable
    values are `Development`, `UnitTest`, `SystemTest`, or `Production`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `PROJECT_STAGE` | 这指定了开发项目阶段。可接受值为 `Development`、`UnitTest`、`SystemTest`
    或 `Production`。 |'
- en: '| `STATE_SAVING_METHOD` | This specifies the location where a state is saved
    in a JSF application. The acceptable values are `client` and `server`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `STATE_SAVING_METHOD` | 这指定了在JSF应用程序中保存状态的位置。可接受的值是`client`和`server`。|'
- en: '| `WEBAPP_CONTRACTS_DIRECTORY` | This overrides the default location of the
    JSF resource contracts. The default is `<web-context>/contracts`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `WEBAPP_CONTRACTS_DIRECTORY` | 这覆盖了JSF资源合同的默认位置。默认是`<web-context>/contracts`。|'
- en: '| `WEBAPP_RESOURCES_DIRECTORY` | This overrides the default location of the
    JSF resources reserved for the digital assets. The default is `<web-context>/resources`.
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `WEBAPP_RESOURCES_DIRECTORY` | 这覆盖了JSF为数字资产保留的资源的默认位置。默认是`<web-context>/resources`。|'
- en: These settings are best configured in the web deployment descriptor file (`web.xml`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置最好在Web部署描述符文件（`web.xml`）中进行配置。
- en: Internationalization
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: A JSF application can be internationalized with standard resource bundles (`java.util.ResourceBundle`)
    and messages. Resource bundles are suitable to internationalize the text on the
    components, controls, and digital assets; whereas message files are meant to internationalize
    the JSF validation errors.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个JSF应用程序可以使用标准资源包（`java.util.ResourceBundle`）和消息进行国际化。资源包适合用于国际化组件、控件和数字资产上的文本；而消息文件旨在国际化JSF验证错误。
- en: In a Gradle or Maven project, we will add a resource bundle or message file
    to the `src/main/resources` project location with the necessary Java package as
    folders.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle或Maven项目中，我们将添加一个资源包或消息文件到`src/main/resources`项目位置，并使用必要的Java包作为文件夹。
- en: Resource bundles
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源包
- en: We will configure the resource bundles in the Faces configuration file, `/WEB-INF/faces-config.xml`,
    for the web application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Web应用程序的配置文件`/WEB-INF/faces-config.xml`中配置资源包。
- en: 'For the contact details application in [Chapter 4](part0043.xhtml#aid-190861
    "Chapter 4. JSF Validation and AJAX"), *JSF Validation and AJAX*, we have two
    resource bundle files in English and German: `appMessages.properties` and `appMessage_de.properties`
    respectively.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第4章中关于联系详情的应用程序[第4章](part0043.xhtml#aid-190861 "第4章。JSF验证和AJAX")，我们有两个英语和德语文言包文件：`appMessages.properties`和`appMessage_de.properties`。
- en: 'Here is the English language bundle:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是英语语言包：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is the German language bundle:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是德语文言包：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to use these bundles in our JSF bundle, we will configure the Faces
    configuration as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的JSF包中使用这些包，我们将按照以下方式配置Faces配置：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will define a resource bundle configuration in `/WEB-INF/faces-config.xml`
    for our application messages. In this file, we can define an application scope
    variable for our bundle, namely `appMessages`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`/WEB-INF/faces-config.xml`中为我们的应用程序消息定义一个资源包配置。在这个文件中，我们可以为我们的包定义一个应用范围变量，即`appMessages`。
- en: 'From here, we can use the bundle with an EL syntax. Here is the code for the
    house number in the application:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以使用EL语法使用这个包。以下是应用程序中房屋号码的代码：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we use dots (`.`) in our property name, we must use the map EL syntax so
    as to obtain the required message: `#{appMessages[''contactForm.houseOrFlatNumber'']}`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在属性名中使用点（`.`），我们必须使用映射EL语法来获取所需的消息：`#{appMessages['contactForm.houseOrFlatNumber']}`。
- en: 'Resource bundles may also contain parameterized message properties with formatted
    token arguments. The token arguments are expanded during message resolution by
    the JSF framework or through application custom code. Here is an example of parameterized
    message property:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 资源包也可能包含带有格式化标记参数的参数化消息属性。标记参数在消息解析过程中由JSF框架或通过应用程序自定义代码进行展开。以下是一个参数化消息属性的示例：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we will use the `<h:outputFormat>` tag to render the output, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`<h:outputFormat>`标签来渲染输出，如下所示：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Message bundles
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息包
- en: The backing code in the JSF applications in general may generate messages for
    the output that can also be internationalized. The messages are stored in the
    FacesContext object. We will need to ensure that a user can see all or some of
    these messages. We will do this with the `<h:messages>` or `<h:message>` JSF tags.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF应用程序中，后端代码通常可以生成输出消息，这些消息也可以进行国际化。这些消息存储在FacesContext对象中。我们需要确保用户可以看到所有或部分这些消息。我们将使用`<h:messages>`或`<h:message>`
    JSF标签来实现这一点。
- en: In [Chapter 4](part0043.xhtml#aid-190861 "Chapter 4. JSF Validation and AJAX"),
    *JSF Validation and AJAX*, we already looked at `faces-config.xml` for the message
    bundles.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](part0043.xhtml#aid-190861 "第4章。JSF验证和AJAX")中，我们已经查看了消息包的`faces-config.xml`。
- en: A browser configured locale
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器配置的区域设置
- en: For many digital sites, the user's browser determines the locale of the website.
    Developers can inform JSF about the languages that are supported in an application
    in the `/WEB/faces-config.xml file`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多数字站点，用户的浏览器决定了网站的语言环境。开发者可以在`/WEB/faces-config.xml`文件中通知JSF关于应用程序支持的语言。
- en: 'Here is the setting for the contact details application:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是联系详情应用的设置：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this file, we will specify that our default locale is English and the supported
    locales are French and German.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，我们将指定我们的默认语言环境为英语，支持的语言环境有法语和德语。
- en: An application controlled locale
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序控制的语言环境
- en: There are certain digital sites where the requirement is to allow the user to
    switch between two or more locales. So, we must programmatically achieve this
    goal. For each rendered view in JSF, we will need to set the locale in the controller
    method. We will use FacesContext to gain access to the root view UI in the Faces
    response and set the locale here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 某些数字站点的要求是允许用户在两个或多个语言环境之间切换。因此，我们必须通过编程实现这个目标。对于JSF中渲染的每个视图，我们都需要在控制器方法中设置语言环境。我们将使用FacesContext来访问Faces响应中的根视图UI，并在此处设置语言环境。
- en: 'Suppose that we are working for a sports automotive manufacturer with their
    offices in London, UK, and Heidelberg, Southern Germany; then, we can write the
    following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们为一家在英国伦敦和德国南部海德堡设有办事处的运动汽车制造商工作；那么，我们可以编写以下代码：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The view will be set to the German locale.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 视图将被设置为德语语言环境。
- en: An individual page controlled locale
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个页面控制的语言环境
- en: If the stakeholder wants a digital site where each individual page may have
    its own configured locale, then JSF can achieve this goal. Developers can use
    the `<f:view>` view tag to override the locale for a page. Before the JSF 2.0
    standard, the view tag wrapped the content and acted as a container element. In
    JSF 2.0 and later versions, this is now unnecessary and the view tag can set the
    locale.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果利益相关者想要一个数字站点，其中每个单独的页面都可以有自己的配置语言环境，那么JSF可以实现这个目标。开发者可以使用`<f:view>`视图标签来覆盖页面的语言环境。在JSF
    2.0标准之前，视图标签包装了内容并充当容器元素。在JSF 2.0及以后的版本中，这现在是多余的，视图标签可以设置语言环境。
- en: 'Here is a code extract that retrieves the locale from a user profile bean with
    a property called `primaryLocale`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从具有名为`primaryLocale`属性的配置文件中检索语言环境的代码片段：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the session-scoped bean that goes with the page view:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是与页面视图相关的会话范围bean：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A web deployment descriptor
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络部署描述符
- en: This is to go to a separate appendix.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了进入一个单独的附录。
- en: 'Here is a reference development XML deployment descriptor for JSF 2.2 and Java
    EE 7:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JSF 2.2和Java EE 7的参考开发XML部署描述符：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Programmatic Faces Flows
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程式Faces流程
- en: In this appendix, we will provide a quick reference to the JavaServer Faces
    Flow. A flow is as per user and per web application finite state machine is with
    nodes. There is a default entry node and at least one exit node.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，我们将提供JavaServer Faces流程的快速参考。一个流程是根据用户和每个Web应用程序的有限状态机，具有节点。有一个默认的入口节点和至少一个出口节点。
- en: View types
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图类型
- en: In [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and Finesse"),
    *JSF Flows and Finesse*, we discussed the building of the flow navigation from
    the Faces configuration XML file. The JSF 2.2 specification describes the convention
    to store and set up the flows with a directory structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](part0057.xhtml#aid-1MBG21 "第6章。JSF流程和优雅")，“JSF流程和优雅”，我们讨论了从Faces配置XML文件构建流程导航。JSF
    2.2规范描述了使用目录结构存储和设置流程的约定。
- en: 'There are several types of nodes. They are tabulated in the following table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种类型的节点。它们在以下表中列出：
- en: '| Node type | Description |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 节点类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| View Node | This node represents a view. The JSF provider renders the view,
    the flow is still active. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 视图节点 | 此节点表示一个视图。JSF提供者渲染视图，流程仍然活跃。|'
- en: '| Return Node | This node represents an exit point from the flow to the outside
    of this flow. The current flow terminates on the invocation of this node. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 返回节点 | 此节点表示从流程中退出到此流程外部的一个出口点。当前流程在调用此节点时终止。|'
- en: '| Flow Call Node | This node represents an invocation to another nested flow.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 流程调用节点 | 此节点表示对另一个嵌套流程的调用。|'
- en: '| Method Call Node | This node represents an invocation to a method call in
    a flow-scoped bean. After leaving this method call, the current flow is still
    active. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 方法调用节点 | 此节点表示在流程范围内的bean中对方法调用的调用。离开此方法调用后，当前流程仍然活跃。|'
- en: '| Switch Node | This node represents a selectable conditional state. Depending
    on the state, the flow may move to one or more alternative states and there is
    a default outcome. The current flow is still active. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 切换节点 | 此节点表示一个可选择的条件状态。根据状态，流程可能移动到一个或多个替代状态，并且有一个默认结果。当前流程仍然有效。|'
- en: '| Navigation Case Node | This node represents a generalized conditional state
    with navigation. Depending on the state, the flow may move to a new outcome or
    execute an HTTP redirect out of the flow. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 导航情况节点 | 此节点表示一个具有导航的通用条件状态。根据状态，流程可能移动到新的结果或执行流程外的 HTTP 重定向。|'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By comparing the Faces Flows with the other flows or business process technology,
    it should be acknowledged that there is no so-called initial node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Faces Flows 与其他流程或业务流程技术进行比较，应该承认没有所谓的初始节点。
- en: The Faces Flows programmatic interface
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Faces Flows 程序化接口
- en: The Faces Flows are powered by CDI. It is possible to write programmatic flows
    by declaring a POJO that produces a Faces Flow. In order to generate a flow dynamically,
    we must annotate a bean as a CDI producer and generate a flow instance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flows 由 CDI 驱动。可以通过声明一个生成 Faces Flow 的 POJO 来编写程序化流程。为了动态生成流程，我们必须将一个
    Bean 标注为 CDI 生成器并生成一个流程实例。
- en: 'Here is a basic `SimpleFlowFactory` class that supplies a Faces Flow:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的 `SimpleFlowFactory` 类，它提供 Faces Flow：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will annotate the `createFlow()` method as a CDI producer with the special
    qualifier, `@FlowDefinition`. We will also supply this method with a single argument,
    `FlowBuilder`, which is also annotated with `@FlowBuilderParameter`. These definitions,
    by the way, are found in the reserved imported package: `javax.faces.flow.builder`.
    We use an injected `FlowBuilder` to generate a specific flow. The actual node
    types are found in the `javax.faces.flow` package.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `createFlow()` 方法标注为具有特殊限定符的 CDI 生成器，即 `@FlowDefinition`。我们还将为此方法提供一个单一参数，即
    `FlowBuilder`，它也被标注为 `@FlowBuilderParameter`。顺便说一下，这些定义可以在保留的导入包 `javax.faces.flow.builder`
    中找到。我们使用注入的 `FlowBuilder` 来生成特定的流程。实际的节点类型可以在 `javax.faces.flow` 包中找到。
- en: A Faces Flow requires a flow identifier, which is `simpleFlow`. We can optionally
    also define a specific document ID. We will use a dependent generator instance
    to demonstrate how this works. If there is no need for a document ID, then supply
    an empty string.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flow 需要一个流程标识符，即 `simpleFlow`。我们可以选择性地也定义一个特定的文档 ID。我们将使用一个依赖生成器实例来演示它是如何工作的。如果没有必要提供文档
    ID，则提供一个空字符串。
- en: 'A Faces Flow requires at least one view, which is usually the default name
    in the XML configuration. In order to complete the first view node, we will define
    a ViewNode and the URI for the flow''s view template: `/simpleFlow/simpleFlow.xhtml`.
    We will also need to set the flow''s start node with the call set to `markAsStartNode()`,
    because a Faces Flow requires an initial node. The API for `FlowBuilder` is taken
    from the fluent builder pattern. At the end of the `createFlow()` method, we will
    generate a flow instance and return it. The JSF provider takes over the flow definition
    from this point onwards.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flow 至少需要一个视图，这通常在 XML 配置中是默认名称。为了完成第一个视图节点，我们将定义一个 ViewNode 和流程视图模板的
    URI：`/simpleFlow/simpleFlow.xhtml`。我们还需要设置流程的起始节点，调用设置为 `markAsStartNode()`，因为
    Faces Flow 需要一个初始节点。`FlowBuilder` 的 API 来自流畅构建器模式。在 `createFlow()` 方法的末尾，我们将生成一个流程实例并返回它。从这一点开始，JSF
    提供者接管流程定义。
- en: Remember that as we are building the flow ourselves, we don't have to follow
    all the rules of the XML configuration exactly. However, all the view templates
    for a flow definition must fall under one single folder in the root context of
    the web application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然我们自己在构建流程，但我们不必完全遵循 XML 配置的所有规则。然而，一个流程定义的所有视图模板必须位于 Web 应用程序根上下文下的一个单独文件夹中。
- en: 'Just because we defined a flow definition producer, we will still require the
    actually flow-scoped bean, namely:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们定义了流程定义生成器，我们仍然需要实际的流程作用域 Bean，即：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will look at the specifics of each node type in the following sections.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中查看每种节点类型的详细信息。
- en: 'The following UML class diagram illustrates the key types in the API:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 类图说明了 API 中的关键类型：
- en: '![The Faces Flows programmatic interface](img/image00428.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![The Faces Flows programmatic interface](img/image00428.jpeg)'
- en: UML class diagram for the Faces Flow API
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Faces Flow API 的 UML 类图
- en: ViewNode
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewNode
- en: With `FlowBuilder`, we can define the ViewNode instances. The actual type is
    a subclass of `javax.faces.faces.ViewNode`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FlowBuilder`，我们可以定义 ViewNode 实例。实际类型是 `javax.faces.faces.ViewNode` 的子类。
- en: 'The following example of a code extends the last flow instance and provides
    additional view nodes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例扩展了最后一个流实例并提供了额外的视图节点：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `viewNode()` method accepts two arguments. The first argument is the view
    node ID, which we will write in and refer to in the view content. The second argument
    is the view description language document identifier, which translates to the
    URI of the Facelets view.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewNode()`方法接受两个参数。第一个参数是视图节点ID，我们将在视图内容中写入并引用它。第二个参数是视图描述语言文档标识符，它对应于Facelets视图的URI。'
- en: The path of the URI can also be a relative URL. This means the eventual path
    is relative to the flow URI path. Otherwise, the URI must be absolute in terms
    of the web context root path, as we can see in the preceding code extract.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: URI的路径也可以是一个相对URL。这意味着最终路径相对于流URI路径是相对的。否则，URI必须相对于Web上下文根路径是绝对的，正如我们可以在前面的代码摘录中看到的那样。
- en: The `viewNode()` method returns a `ViewBuilder` type, which has only one additional
    `markAsStartNode()` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewNode()`方法返回一个`ViewBuilder`类型，它只有一个额外的`markAsStartNode()`方法。'
- en: ReturnNode
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ReturnNode
- en: We can also generate a ReturnNode instance from `FlowBuilder`. This is straightforward
    with the `returnNode()` method. The actual type is a subclass of `javax.faces.faces.ReturnNode`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`FlowBuilder`生成一个`ReturnNode`实例。使用`returnNode()`方法非常简单。实际类型是`javax.faces.faces.ReturnNode`的子类。
- en: 'This is an extract of the `createFlow()` method that specifies a return node:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`createFlow()`方法的摘录，它指定了一个返回节点：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `returnNode()` method accepts a single argument the view node ID and returns
    an instance of `ReturnBuilder`. The `fromOutcome()` method call specifies the
    view name of the outcome that we navigate to after returning from the current
    flow.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`returnNode()`方法接受一个参数，即视图节点ID，并返回一个`ReturnBuilder`实例。`fromOutcome()`方法调用指定了返回当前流后要导航到的结果视图的名称。'
- en: MethodCall
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MethodCall
- en: 'With the `FlowBuilder` instance, we can also create a method call node and
    add it to the Faces Flow. The actual type is a subclass of `javax.faces.faces.MethodCallNode`.
    Here is the POJO class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FlowBuilder`实例，我们还可以创建一个方法调用节点并将其添加到Faces Flow中。实际类型是`javax.faces.faces.MethodCallNode`的子类。以下是POJO类：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `methodCallNode()` call accepts a view node ID and creates a `MethodCallBuilder`
    instance. This node requires an expression that informs JSF about the name of
    the bean and the method to invoke. Here, the method is `verifyCustomer()` on an
    accessible backing bean controller `loanController`. We can also pass the account
    record in the customer's details using an expression language. In case the target
    method invocation returns null or an empty string, we can specify a default outcome
    view identifier.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`methodCallNode()`调用接受一个视图节点ID并创建一个`MethodCallBuilder`实例。此节点需要一个表达式来通知JSF关于要调用的bean的名称和方法。在这里，方法是在可访问的后备bean控制器`loanController`上的`verifyCustomer()`。我们还可以使用表达式语言传递客户的详细信息中的账户记录。如果目标方法调用返回null或空字符串，我们可以指定一个默认的结果视图标识符。'
- en: I recommend that you should reduce the coupling in a layered architecture as
    much as possible. Be careful about mixing too much presentation tier information
    with the business logic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在分层架构中尽可能减少耦合。注意不要将太多表示层信息与业务逻辑混合。
- en: FlowCall
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlowCall
- en: We will create a flow call node using the same abstract class type `FlowBuilder`.
    This node type invokes a nested Faces Flow. The `flowCallNode()` method accepts
    a single argument in the view node ID and returns a `FlowCallBuilder` instance.
    The actual type is a subclass of `javax.faces.faces.FlowCallNode`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的抽象类类型`FlowBuilder`创建一个流调用节点。此节点类型调用嵌套的Faces Flow。`flowCallNode()`方法接受一个视图节点ID参数，并返回一个`FlowCallBuilder`实例。实际类型是`javax.faces.faces.FlowCallNode`的子类。
- en: 'In this code extract, which is based on the *Industrial sector carbon footprint*
    discussion from [Chapter 6](part0057.xhtml#aid-1MBG21 "Chapter 6. JSF Flows and
    Finesse"), *JSF Flows and Finesse*, we will rewrite the flow definition XML file
    called `footprint-flow.xml` as the following `SectorFlowFactory` POJO class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基于[第6章](part0057.xhtml#aid-1MBG21 "第6章。JSF流和优雅") *工业部门碳足迹*讨论的代码摘录中，我们将重写名为`footprint-flow.xml`的流定义XML文件，如下面的`SectorFlowFactory`
    POJO类所示：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, the node is identified as `callFootprintFlow`. We must
    provide the node ID of the nest flow through a `flowReference()` method. The first
    argument of `flowReference()` is the flow document ID, which is an empty string
    here. The nested flow is identified as footprint-flow by the second argument.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，节点被标识为`callFootprintFlow`。我们必须通过`flowReference()`方法提供嵌套流的节点ID。`flowReference()`的第一个参数是流文档ID，这里是一个空字符串。嵌套流通过第二个参数被标识为足迹流。
- en: We will use the `outboundParameter()` method on `FlowCallBuilder` in order to
    declare the outbound parameters that pass the data from the calling sector-flow
    to the nested footprint-flow. The first argument to `outboundParameter()` is the
    parameter name and the second argument is a literal string or an expression.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`FlowCallBuilder`上使用`outboundParameter()`方法来声明出站参数，这些参数将数据从调用者sector-flow传递到嵌套足迹流。`outboundParameter()`的第一个参数是参数名称，第二个参数是字面字符串或表达式。
- en: 'We can also rewrite the flow definition XML file from the nested flow programmatically.
    Here is an extract of the `FootprintFlowFactory` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过编程方式重写嵌套流的流定义XML文件。以下是`FootprintFlowFactory`类的摘录：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code, we notice that the footprint-flow ID must match the caller reference
    ID. For this Faces Flow, we will declare the inbound parameters with the `inboundParameter()`
    method call. The first argument is the parameter name and the second is an expression
    language reference that defines where the value is stored.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们注意到足迹流ID必须与调用者引用ID匹配。对于此Faces Flow，我们将使用`inboundParameter()`方法调用声明入站参数。第一个参数是参数名称，第二个参数是一个表达式语言引用，它定义了值存储的位置。
- en: SwitchNode
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SwitchNode
- en: We can use `FlowBuilder` to create the declaration of a switch node. These node
    types are composed of an association between a conditional statement and the outcome.
    The outcome is the view ID. A switch node has one or more conditional statements.
    It may also have a default outcome. During the processing of the flow, JSF executes
    each conditional statement in turn. If it evaluates to true (or rather, `Boolean.TRUE`),
    then the associated outcome is the chosen one. The actual type is a subclass of
    `javax.faces.faces.SwitchNode`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`FlowBuilder`来创建声明切换节点的声明。这些节点类型由条件语句和结果之间的关联组成。结果是视图ID。切换节点有一个或多个条件语句。它也可能有一个默认结果。在流的处理过程中，JSF依次执行每个条件语句。如果它评估为真（或者更确切地说，`Boolean.TRUE`），那么相关的结果就是选择的结果。实际类型是`javax.faces.faces.SwitchNode`的子类。
- en: 'Let ''s see an example of the switch node in action in a POJO. Here is another
    class for a monetary loan decision maker called `LoanDecisionFlowFactory`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在POJO中切换节点实际操作的例子。这是另一个名为`LoanDecisionFlowFactory`的货币贷款决策者类：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `createFlow()` method, we will create a Faces Flow identified as loan-application.
    We will then create a switch node declaration with `switchNode()` and identified
    as loan-decision. This method returns a `SwitchBuilder` type. This builder type
    has `switchCase()` that returns `SwitchCaseBuilder`. The other overloaded methods
    included are called `defaultCome()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createFlow()`方法中，我们将创建一个标识为loan-application的Faces Flow。然后我们将使用`switchNode()`创建一个切换节点声明，并标识为loan-decision。此方法返回一个`SwitchBuilder`类型。此构建器类型具有`switchCase()`，它返回`SwitchCaseBuilder`。其他包含的重载方法被称为`defaultCome()`。
- en: It is recommended that you also declare a default outcome with the `defaultOutcome()`
    method, which accepts a view ID. In this way, the flow always moves to the next
    viable location.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您还使用`defaultOutcome()`方法声明一个默认结果，它接受一个视图ID。这样，流总是移动到下一个可行的位置。
- en: Given the `SwitchBuilder` builder type, we will declare the individual cases
    with the `condition()` and `fromOutCome()` methods. The `condition()` call accepts
    an expression string and it returns `SwitchCaseBuilder`. The only property on
    this builder is a valid outcome, which is a view identifier.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`SwitchBuilder`构建器类型，我们将使用`condition()`和`fromOutCome()`方法声明单个案例。`condition()`调用接受一个表达式字符串，并返回`SwitchCaseBuilder`。此构建器上的唯一属性是有效的结果，它是一个视图标识符。
- en: NavigationCase node
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航情况节点
- en: The final builder type in the API relates to a general abstract class type `NavigationCaseBuilder`.
    We can create a navigation case node with `FlowBuilder`. The actual type is a
    subclass of `javax.faces.faces.FlowNode`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: API中的最后一个构建器类型与一个通用抽象类类型`NavigationCaseBuilder`相关。我们可以使用`FlowBuilder`创建导航情况节点。实际类型是`javax.faces.faces.FlowNode`的子类。
- en: 'Here is a POJO from the financial services domain that is designed to allow
    the back office staff in an investment bank to post the process trades in a workflow:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个来自金融服务领域的POJO，它被设计成允许投资银行的后台工作人员在工作流中发布流程交易：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this `PostProcessTradeFlowFactory` POJO, we again have a `createFlow()` method,
    but this time we will call `navigationCase()` twice. This method has no arguments
    and returns a `NavigationCaseBuilder` type that creates the specified Faces Flow.
    A navigation case flow requires a trigger point, a conditional expression, and
    an outcome or redirection response.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`PostProcessTradeFlowFactory` POJO中，我们再次有一个`createFlow()`方法，但这次我们将调用`navigationCase()`两次。这个方法没有参数，并返回一个`NavigationCaseBuilder`类型的对象，该对象创建指定的Faces
    Flow。导航案例流程需要一个触发点、一个条件表达式和一个结果或重定向响应。
- en: In the first flow, we will call the `fromOutcome()` method on `NavigationCaseBuilder`
    in order to declare the JSF view ID that triggers the check. The `condition()`
    method defines the expression that must return a Boolean value. The `toViewId()`
    method defines the outcome view ID to navigate if the conditional expression evaluates
    as `Boolean.TRUE`. So, therefore, if the trade value exceeds the firm-wide exposure
    limit (`trade.amount > global.risk.limit`), then the flow navigates to the exceptional
    view.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个流程中，我们将对`NavigationCaseBuilder`调用`fromOutcome()`方法，以声明触发检查的JSF视图ID。`condition()`方法定义了必须返回布尔值的表达式。`toViewId()`方法定义了如果条件表达式评估为`Boolean.TRUE`，则导航到的结果视图ID。因此，如果交易价值超过公司范围内的风险限制（`trade.amount
    > global.risk.limit`），则流程将导航到异常视图。
- en: 'With the second flow declaration, we will define a navigation case to handle
    an out-of-currency deal, which might be a Swap, Bond, or some other derivative.
    With the same trigger outcome trade check, we will trap on the expression for
    the currencies that settles in non-US dollars: `trade.settlementCcy != ''USD''`.
    With this navigation case node, we will execute an HTTP redirect that causes the
    customer to exit the entire flow. We will invoke `redirect()` and it will return
    `NavigationCaseBuilder.RedirectBuilder`. This nested abstract class has two methods:
    `includeViewParams()` and `parameter()`. The `includeViewParams()` method adds
    all of the view parameters to the redirect URL. The `parameter()` method adds
    the name and value pairs to the redirect URL. Remember that after the flow is
    completed, from a security digital developer''s point of view, these parameters
    will be highly visible in the URL of the eventual HTTP GET request!'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个流程声明中，我们将定义一个导航案例来处理一种货币交易，这可能是一个掉期、债券或其他衍生品。使用相同的触发结果交易检查，我们将捕获非美元货币的表达式：`trade.settlementCcy
    != 'USD'`。使用这个导航案例节点，我们将执行一个HTTP重定向，导致客户退出整个流程。我们将调用`redirect()`，它将返回`NavigationCaseBuilder.RedirectBuilder`。这个嵌套的抽象类有两个方法：`includeViewParams()`和`parameter()`。`includeViewParams()`方法将所有视图参数添加到重定向URL中。`parameter()`方法将名称和值对添加到重定向URL中。记住，在流程完成后，从安全数字开发者的角度来看，这些参数将在最终的HTTP
    GET请求的URL中非常明显！
- en: Builder types
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建器类型
- en: The builder types—`ViewBuilder`, `ReturnBuilder`, `MethodCallBuilder`, `FlowCallBuilder`,
    `SwitchBuilder`, `SwitchCaseBuilder`, and `NavigationCaseBuilder` are abstract
    classes. They are implementations of the `javax.faces.flow.builder.NodeBuilder`
    interface. The Faces Flow API is an example of an embedded Domain Specific Language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器类型——`ViewBuilder`、`ReturnBuilder`、`MethodCallBuilder`、`FlowCallBuilder`、`SwitchBuilder`、`SwitchCaseBuilder`和`NavigationCaseBuilder`是抽象类。它们是`javax.faces.flow.builder.NodeBuilder`接口的实现。Faces
    Flow API是嵌入式领域特定语言的例子。
