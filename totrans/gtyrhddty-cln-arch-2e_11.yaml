- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Taking Shortcuts Consciously
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有意识地走捷径
- en: In the preface of this book, I cursed the fact that we feel forced to take shortcuts
    all the time, building up a great heap of technical debt we never have the chance
    to pay back.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的序言中，我诅咒了这样一个事实，那就是我们感觉被迫一直走捷径，积累了一大堆我们永远没有机会偿还的技术债务。
- en: To prevent shortcuts, we must be able to identify them. So, the goal of this
    chapter is to raise awareness of some potential shortcuts and discuss their effects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止走捷径，我们必须能够识别它们。因此，本章的目标是提高人们对一些潜在捷径的认识，并讨论它们的影响。
- en: With this information, we can identify and fix accidental shortcuts. Or, if
    justified, we can even consciously opt in to the effects of a shortcut.[1](#footnote-037)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个信息，我们可以识别并修复意外的捷径。或者，如果合理的话，我们甚至可以有意选择捷径的影响。[1](#footnote-037)
- en: '[1](#footnote-037-backlink) Imagine talking about shortcuts in a book about
    construction engineering or, even scarier, in a book about avionics! Most of us,
    however, are not building the software equivalent of a skyscraper or an airplane.
    And software is soft and can be changed more easily than hardware, so sometimes
    it’s actually more economic to (consciously!) take a shortcut first and fix it
    later (or never).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-037-backlink) 想象一下在一本关于土木工程的书或，甚至更可怕，在一本关于航空电子学的书中谈论捷径！然而，我们中的大多数人并不是在建造软件高楼大厦或飞机。软件是软的，比硬件更容易改变，所以有时（有意识地！）先走捷径，然后再修复（或永不修复）实际上是更经济的。'
- en: Why shortcuts are like broken windows
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么捷径就像破窗
- en: In 1969, psychologist *Philip Zimbardo* conducted an experiment to test a theory
    that later became known as the [**Broken** **Windows Theor**](https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/)**y**.[2](#footnote-036)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在1969年，心理学家*菲利普·津巴多*进行了一项实验，以测试后来被称为[**破窗** **理论**](https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/)**y**的理论。[2](#footnote-036)
- en: '[2](#footnote-036-backlink) The Broken Windows Theory: [https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/](https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-036-backlink) 破窗理论：[https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/](https://www.theatlantic.com/magazine/archive/1982/03/broken-windows/304465/)。'
- en: His team parked one car without license plates in a Bronx neighborhood and another
    in an allegedly “better” neighborhood in Palo Alto. Then, they waited.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 他的团队在布朗克斯的一个街区停了一辆没有车牌的车，另一辆在帕洛阿尔托一个所谓的“更好”的街区。然后，他们等待。
- en: The car in the Bronx was picked clean of valuable parts within 24 hours and
    then passersby started to randomly destroy it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 布朗克斯的车在24小时内被洗劫一空，然后路人开始随意破坏它。
- en: The car in Palo Alto was not touched for a week, so Zimbardo’s team smashed
    a window. From then on, the car had a similar fate to the car in the Bronx and
    was destroyed in the same short amount of time by people walking by.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 帕洛阿尔托的车一周内没有被触及，所以津巴多团队砸了一扇窗户。从那时起，这辆车和布朗克斯的那辆车有相似的命运，在很短的时间内被路过的行人破坏。
- en: The people taking part in looting and destroying the cars came from across all
    social classes and included people who were otherwise law-abiding and well-behaved
    citizens.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 参与抢劫和破坏汽车的人来自所有社会阶层，包括那些在其他方面守法且行为良好的公民。
- en: 'This human behavior has become known as the Broken Windows Theory. In my own
    words:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种人类行为被称为“破窗理论”。用我自己的话说：
- en: '*As soon as something looks run-down, damaged, [insert negative adjective here],
    or generally untended, the human brain feels that it’s OK to make it more run-down,
    damaged, or [insert negative* *adjective here].*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*一旦某物看起来破旧、损坏、[插入负面形容词]，或者总体上无人照管，人类大脑就会觉得让它变得更破旧、损坏、或者[插入负面形容词]是合理的。*'
- en: 'This theory applies to many areas of life:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论适用于生活的许多领域：
- en: In a neighborhood where vandalism is common, the threshold to loot or damage
    an untended car is low.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个常见的破坏行为的社区，掠夺或损坏无人照料的汽车的门槛很低。
- en: When a car has a broken window, the threshold to damage it further is low, even
    in a “good” neighborhood.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一辆车有破窗时，即使在“好”的街区，进一步破坏它的门槛也很低。
- en: In an untidy bedroom, the threshold to throw our clothes on the ground instead
    of putting them into the wardrobe is low.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个杂乱的卧室里，把衣服扔在地上而不是放进衣柜的门槛很低。
- en: In a classroom where students often disrupt the lesson, the threshold to crack
    another joke to classmates is low.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个学生经常打断课程的教室里，向同学讲一个笑话的门槛很低。
- en: 'Applied to working with code, this means the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将其应用于代码工作，意味着以下内容：
- en: When working on a low-quality code base, the threshold to add more low-quality
    code is low.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个低质量的代码库上工作时，增加更多低质量代码的门槛很低。
- en: When working on a code base with a lot of coding violations, the threshold to
    add another coding violation is low.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个有很多编码违规的代码库上工作时，增加另一个编码违规的门槛很低。
- en: When working on a code base with a lot of shortcuts, the threshold to add another
    shortcut is low.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在一个有很多捷径的代码库上工作时，增加另一个捷径的门槛很低。
- en: With all this in mind, is it really a surprise that the quality of many so-called
    “legacy” code bases has eroded so badly over time?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，许多所谓的“遗留”代码库的质量随着时间的推移而严重下降，这真的令人惊讶吗？
- en: The responsibility of starting clean
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始的责任
- en: While working with code doesn’t really feel like looting a car, we all are unconsciously
    subject to the Broken Windows psychology. This makes it important to start a project
    clean, with as few shortcuts and as little technical debt as possible. This is
    because, as soon as a shortcut creeps in, it acts as a broken window and attracts
    more shortcuts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与代码打交道并不真的感觉像是抢劫一辆车，但我们所有人都在不知不觉中受到“破窗”心理的影响。这使得项目开始时尽可能干净、尽可能少地采取捷径和尽可能少的技术债务变得非常重要。这是因为，一旦出现捷径，它就会像破窗一样吸引更多的捷径。
- en: Since a software project often is a very expensive and long-running endeavor,
    keeping broken windows at bay is a huge responsibility for us as software developers.
    We may not even be the ones finishing the project and others have to take over.
    For them, it’s a legacy code base they don’t have a connection to yet, lowering
    the threshold for creating broken windows even further.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件项目通常是一项非常昂贵且持续时间长的努力，因此作为软件开发者，防止出现“破窗”现象是一项巨大的责任。我们甚至可能不是完成项目的最后一批人，其他人需要接手。对他们来说，这是一个他们还没有建立联系的遗留代码库，进一步降低了创建“破窗”现象的门槛。
- en: There are times, however, when we decide a shortcut is the pragmatic thing to
    do, be it because the part of the code we’re working on is not that important
    to the project as a whole, because we’re prototyping, or for economical reasons.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们决定采取捷径是务实的选择，无论是由于我们正在工作的代码部分对整个项目来说并不那么重要，我们正在做原型设计，还是出于经济原因。
- en: We should take great care to document such consciously added shortcuts, for
    example, in the form of **Architecture Decision Records** (**ADRs**), as proposed
    by *Michael Nygard* i[n hi](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)s
    blog.[3](#footnote-035) We owe that to our future selves and our successors. If
    every member of the team is aware of this documentation, it will even reduce the
    Broken Windows effect because the team will know that the shortcuts have been
    taken consciously and for good reason.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该非常小心地记录这些有意识添加的捷径，例如，以**架构决策记录**（**ADRs**）的形式，正如*迈克尔·尼加德*在他的博客[i[n hi](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions)]中提出的。[3](#footnote-035)
    我们应该对我们的未来自己和我们的继任者负责。如果团队中的每个成员都了解这份文档，它甚至可以减少“破窗”效应，因为团队将知道这些捷径是经过深思熟虑并且有充分的理由而采取的。
- en: '[3](#footnote-035-backlink) Architecture Decision Records: [http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions](B19916_11.xhtml).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](#footnote-035-backlink) 架构决策记录：[http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions](B19916_11.xhtml)。'
- en: The following sections each discuss a pattern that can be considered a shortcut
    in the Hexagonal Architecture style presented in this book. We’ll have a look
    at the effects of the shortcuts and the arguments that speak for and against taking
    them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节将讨论一种可以被视为本书中提出的六边形架构风格中的捷径的模式。我们将探讨这些捷径的影响以及支持或反对采取这些捷径的论点。
- en: Sharing models between use cases
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在用例之间共享模型
- en: In [*Chapter 5*](B19916_05.xhtml#_idTextAnchor044), *Implementing a Use Case*,
    I argued that different use cases should have different **input and output models**,
    meaning that the types of the input parameters and the types of the return values
    should be different.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B19916_05.xhtml#_idTextAnchor044)《实现用例》中，我论证了不同的用例应该有不同的**输入和输出模型**，这意味着输入参数的类型和返回值的类型应该是不同的。
- en: '*Figure 11**.1* shows an example where two use cases share the same input model:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.1*展示了两个用例共享相同输入模型的一个示例：'
- en: '![Figure 11.1 – Sharing the input or output model between use cases leads to
    coupling between the use cases](img/Figure_11.1_B19916.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 在用例之间共享输入或输出模型会导致用例之间的耦合](img/Figure_11.1_B19916.jpg)'
- en: Figure 11.1 – Sharing the input or output model between use cases leads to coupling
    between the use cases
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 在用例之间共享输入或输出模型会导致用例之间的耦合
- en: The effect of sharing in this case is that `SendMoneyUseCase` and `RevokeActivityUseCase`
    are coupled to each other. If we change something within the shared `SendMoneyCommand`
    class, both use cases are affected. They share a reason to change in terms of
    the Single Responsibility Principle (which should be named the “Single Reason
    to Change Principle,” as discussed in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029)*,
    Inverting Dependencies*). The same is true if both use cases share the same output
    model.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，共享的影响是`SendMoneyUseCase`和`RevokeActivityUseCase`相互耦合。如果我们对共享的`SendMoneyCommand`类中的某个部分进行更改，这两个用例都会受到影响。它们在单一责任原则（如第[*3章*](B19916_03.xhtml#_idTextAnchor029)*，反转依赖关系*）的层面上共享一个改变的理由。如果两个用例共享相同的输出模型，情况也是如此。
- en: Sharing input and output models between use cases is valid if the use cases
    are functionally coupled, that is, if they share a certain requirement. In this
    case, we actually want both use cases to be affected if we change a certain detail.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用例在功能上是耦合的，即它们共享一定的需求，那么在用例之间共享输入和输出模型是有效的。在这种情况下，如果我们改变某些细节，我们实际上希望两个用例都受到影响。
- en: If both use cases should be able to evolve separately from each other, however,
    this is a shortcut. In this case, we should separate the use cases from the start,
    even if it means duplicating input and output classes if they look the same at
    the start.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果两个用例都应该能够独立于彼此进化，那么这是一个捷径。在这种情况下，我们应该从一开始就分离用例，即使这意味着如果它们一开始看起来相同，也需要复制输入和输出类。
- en: So, when building multiple use cases around a similar concept, it’s worthwhile
    to regularly ask the question of whether the use cases should evolve separately
    from each other. As soon as the answer becomes “yes,” it’s time to separate the
    input and output models.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当围绕一个类似的概念构建多个用例时，定期询问用例是否应该独立于彼此进化是有意义的。一旦答案变成“是”，就是时候分离输入和输出模型了。
- en: Using domain entities as the input or output model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用领域实体作为输入或输出模型
- en: If we have an `Account` domain entity and an incoming port, `SendMoneyUseCase`,
    we might be tempted to use the entity as the input and/or output model of the
    incoming port, as *Figure* *11**.2* shows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个`Account`领域实体和一个传入端口`SendMoneyUseCase`，我们可能会倾向于使用该实体作为传入端口的输入和/或输出模型，如图*11**.2*所示。
- en: '![Figure 11.2 – Using a domain entity as the input or output model of a use
    case couples the domain entity to the use case](img/Figure_11.2._B19916.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 使用领域实体作为用例的输入或输出模型会将领域实体耦合到用例中](img/Figure_11.2._B19916.jpg)'
- en: Figure 11.2 – Using a domain entity as the input or output model of a use case
    couples the domain entity to the use case
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 将领域实体用作用例的输入或输出模型会将领域实体耦合到用例中
- en: The incoming port has a dependency on the domain entity. The consequence of
    this is that we’ve added another reason for the `Account` entity to change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 传入端口依赖于领域实体。这种依赖的结果是，我们又为`Account`实体增加了一个改变的理由。
- en: Wait, the `Account` entity doesn’t have a dependency on the `SendMoneyUseCase`
    incoming port (it’s the other way around), so how can the incoming port be a reason
    to change for the entity?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，`Account`实体并不依赖于`SendMoneyUseCase`传入端口（情况相反），那么传入端口怎么能成为改变实体的原因呢？
- en: Say we need some information about an account in the use case that is not currently
    available in the `Account` entity. This information is ultimately not to be stored
    in the `Account` entity, however, but in a different domain or bounded context.
    We’re tempted to add a new field to the `Account` entity nevertheless, because
    it’s already available in the use case interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在用例中需要一些关于账户的信息，而这些信息目前不在`Account`实体中。然而，这些信息最终不应该存储在`Account`实体中，而应该存储在不同的领域或边界上下文中。尽管如此，我们仍然倾向于向`Account`实体添加一个新字段，因为它已经在用例接口中可用。
- en: For simple create or update use cases, a domain entity in the use case interface
    may be fine since the entity contains exactly the information we need to persist
    its state in the database.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的创建或更新用例，在用例接口中的领域实体可能就足够了，因为实体包含了我们持久化其状态在数据库中所需的确切信息。
- en: As soon as a use case is not simply about updating a couple of fields in the
    database, but instead implements more complex domain logic (potentially delegating
    part of the domain logic to a rich domain entity), we should use a dedicated input
    and output model for the use case interface, because we don’t want changes in
    the use case to propagate to the domain entity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个用例不仅仅是更新数据库中的几个字段，而是实现更复杂的领域逻辑（可能将部分领域逻辑委托给丰富的领域实体），我们就应该为用例接口使用专门的输入和输出模型，因为我们不希望用例的变化传播到领域实体。
- en: What makes this shortcut dangerous is the fact that many use cases start their
    lives as a simple create or update use case only to become beasts of complex domain
    logic over time. This is especially true in an agile environment where we start
    with a minimum viable product and add complexity as we move forward. So, if we
    used a domain entity as the input model at the start, we must find the point in
    time to replace it with a dedicated input model that is independent of the domain
    entity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种快捷方式之所以危险，是因为许多用例最初只是作为一个简单的创建或更新用例开始，但随着时间的推移，它们变成了复杂的领域逻辑的怪物。这在敏捷环境中尤其如此，我们从一个最小可行产品开始，随着前进添加复杂性。因此，如果我们最初使用领域实体作为输入模型，我们必须找到在何时用独立于领域实体的专用输入模型替换它的时机。
- en: Skipping incoming ports
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过输入端口
- en: While the outgoing ports are necessary to invert the dependency between the
    application layer and the outgoing adapters (to make the dependencies point inward),
    we don’t need the incoming ports for dependency inversion. We could decide to
    let the incoming adapters access our application or domain services directly,
    without incoming ports in between, as shown in *Figure 11**.3*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然输出端口对于反转应用程序层和输出适配器之间的依赖关系（使依赖关系指向内部）是必要的，但我们不需要输入端口来实现依赖反转。我们可以决定让输入适配器直接访问我们的应用程序或领域服务，而不在之间使用输入端口，如图*图12.3*所示。
- en: '![Figure 11.3 – Without incoming ports, we lose clearly marked entry points
    to the domain logic](img/Figure_11.3._B19916.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3 – 没有输入端口，我们失去了对领域逻辑的清晰标记的入口点](img/Figure_11.3._B19916.jpg)'
- en: Figure 11.3 – Without incoming ports, we lose clearly marked entry points to
    the domain logic
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 没有输入端口，我们失去了对领域逻辑的清晰标记的入口点
- en: By removing the incoming ports, we have reduced a layer of abstraction between
    incoming adapters and the application layer. Removing layers of abstraction usually
    feels rather good.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除输入端口，我们减少了输入适配器和应用程序层之间的抽象层。移除抽象层通常感觉相当不错。
- en: The incoming ports, however, define the entry points into our application core.
    Once we remove them, we must know more about the internals of our application
    to find out which service method we can call to implement a certain use case.
    By maintaining dedicated incoming ports, we can identify the entry points to the
    application at a glance. This makes it especially easy for new developers to get
    their bearings in the code base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，输入端口定义了进入我们应用程序核心的入口点。一旦我们移除了它们，我们必须更多地了解我们应用程序的内部结构，以找出我们可以调用以实现特定用例的服务方法。通过维护专门的输入端口，我们可以一眼就识别出应用程序的入口点。这使得新开发者更容易在代码库中找到方向。
- en: Another reason to keep the incoming ports is that they allow us to easily enforce
    architecture. With the enforcement options we’ll learn about in [*Chapter 12*](B19916_12.xhtml#_idTextAnchor105),
    *Enforcing Architecture Boundaries*, we can make certain that incoming adapters
    only call incoming ports and not application services. This makes every entry
    point into the application layer a very conscious decision. We can no longer accidentally
    call a service method that was not meant to be called from an incoming adapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 保持输入端口的另一个原因是它们使我们能够轻松地强制执行架构。在[第12章](B19916_12.xhtml#_idTextAnchor105)“强制执行架构边界”中，我们将学习到的强制执行选项，我们可以确保输入适配器只调用输入端口，而不是应用程序服务。这使得每个进入应用程序层的入口点都是一个非常明智的决定。我们不能再意外调用一个本不应该从输入适配器调用的服务方法。
- en: If an application is small enough or only has a single incoming adapter and
    we can grasp the whole control flow without the help of incoming ports, we might
    want to do without incoming ports. However, how often can we say that we know
    that an application will stay small or will only ever have a single incoming adapter
    over its whole lifetime?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序足够小，或者只有一个输入适配器，并且我们可以在不借助输入端口的情况下掌握整个控制流，我们可能希望不使用输入端口。然而，我们有多少时候可以说我们知道一个应用程序将始终保持小规模，或者在其整个生命周期中只会有一个输入适配器呢？
- en: Skipping services
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过服务
- en: Aside from the incoming ports, for certain use cases, we might want to skip
    the service layer as a whole, as *Figure* *11**.4* shows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了入站端口之外，对于某些用例，我们可能希望完全跳过服务层，如图*11**.4*所示。
- en: "![Figure 11.4 – Without services, we don’t have a representation of a use case\
    \ in our code\uFEFF base anymore](img/Figure_11.4._B19916.jpg)"
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 没有服务，我们的代码库中不再有用例的表示](img/Figure_11.4._B19916.jpg)'
- en: Figure 11.4 – Without services, we don’t have a representation of a use case
    in our code base anymore
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 没有服务，我们的代码库中不再有用例的表示
- en: Here, the `AccountPersistenceAdapter` class within an outgoing adapter directly
    implements an incoming port and replaces the service that usually implements an
    incoming port.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，出站适配器中的`AccountPersistenceAdapter`类直接实现了一个入站端口，并取代了通常实现入站端口的那个服务。
- en: It is very tempting to do this for simple CRUD use cases since in this case
    a service usually only forwards a create, update, or delete request to the persistence
    adapter, without adding any domain logic. Instead of forwarding, we can let the
    persistence adapter implement the use case directly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的CRUD用例来说，这样做是非常有诱惑力的，因为在这种情况下，服务通常只将创建、更新或删除请求转发给持久化适配器，而不添加任何领域逻辑。我们可以让持久化适配器直接实现用例，而不是转发。
- en: This, however, requires a shared model between the incoming adapter and the
    outgoing adapter, which is the `Account` domain entity in this case, so it usually
    means that we’re using the domain model as the input model, as described previously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这需要入站适配器和出站适配器之间的共享模型，在这种情况下是`Account`领域实体，因此通常意味着我们正在使用之前描述的领域模型作为输入模型。
- en: Furthermore, we no longer have a representation of the use case within our application
    core. If a CRUD use case grows to something more complex over time, it’s tempting
    to add domain logic directly to the outgoing adapter since the use case has already
    been implemented there. This decentralizes the domain logic, making it harder
    to find and maintain.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不再在我们的应用程序核心中有用例的表示。如果CRUD用例随着时间的推移变得更加复杂，由于用例已经在那里实现，因此直接将领域逻辑添加到出站适配器中是有诱惑力的。这分散了领域逻辑，使其更难找到和维护。
- en: In the end, to prevent boilerplate pass-through services, we might choose to
    skip the services for simple CRUD use cases after all. Then, however, the team
    should develop clear guidelines to introduce a service as soon as the use case
    is expected to do more than just create, update, or delete an entity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了防止样板式的传递服务，我们最终可能选择在简单CRUD用例中跳过服务。然而，然后团队应该制定明确的指南，一旦用例预期要做的事情不仅仅是创建、更新或删除实体，就立即引入服务。
- en: How does this help me build maintainable software?
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: There are times when shortcuts make sense from an economic point of view. This
    chapter provided some insights into the consequences some shortcuts might have
    to help decide whether to take them or not.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，从经济角度来看，走捷径是有意义的。本章提供了一些关于某些捷径可能带来的后果的见解，以帮助决定是否采取这些捷径。
- en: The discussion shows that it’s tempting to introduce shortcuts for simple CRUD
    use cases since, for them, implementing the whole architecture feels like overkill
    (and the shortcuts don’t feel like shortcuts). Since all applications start small,
    however, it’s very important for the team to agree on when a use case grows out
    of its CRUD state. Only then can the team replace the shortcuts with an architecture
    that is more maintainable in the long run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论表明，对于简单的CRUD用例来说，引入捷径是有诱惑力的，因为对于它们来说，实现整个架构感觉像是过度杀鸡（而且捷径并不感觉像捷径）。然而，由于所有应用程序都是从小的开始的，因此对于团队来说，在用例超出其CRUD状态时达成一致非常重要。只有这样，团队才能用长期更易于维护的架构替换捷径。
- en: Some use cases will never grow out of their CRUD state. For them, it might be
    more pragmatic to keep the shortcuts in place forever, as they don’t really entail
    a maintenance overhead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用例永远不会超出它们的CRUD状态。对于它们来说，永远保留捷径可能更实用，因为它们实际上并不涉及维护开销。
- en: In any case, we should document the architecture and the decisions why we chose
    a certain shortcut so that we (or our successors) can re-evaluate the decisions
    in the future.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，我们都应该记录架构和选择特定捷径的原因，以便我们（或我们的继任者）可以在未来重新评估这些决定。
- en: Even though shortcuts may be acceptable at times, we want to make the decision
    to take a shortcut consciously. That means that we should define one “right” way
    of doing things and enforce this way, so that we can deviate from that way if
    there are good reasons to do so. In the next chapter, we’ll look at some ways
    of enforcing our architecture.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有时捷径是可以接受的，我们仍然希望有意识地做出走捷径的决定。这意味着我们应该定义一种“正确”的做事方式，并强制执行这种方式，以便在有充分理由的情况下我们可以偏离这种方式。在下一章中，我们将探讨一些强制执行我们架构的方法。
