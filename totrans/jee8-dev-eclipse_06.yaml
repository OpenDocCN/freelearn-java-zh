- en: Creating JEE Applications with EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned some techniques to debug JEE applications from
    Eclipse. In this chapter, we will shift our focus back to JEE application development
    and learn how to create and use **Enterprise JavaBeans** (**EJB**). If you recall
    the architecture of database applications in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications,* we had JSP or a JSF page calling a JSP bean
    or a managed bean. The beans then called DAOs to execute the data access code.
    This separated code for the user interface, the business logic, and the database
    nicely. This would work for small or medium applications, but may prove to be
    a bottleneck in large enterprise applications; the application may not scale very
    well. If processing of the business logic is time consuming then it would make
    more sense to distribute it on different servers for better scalability and resilience.
    If code for the user interface, the business logic, and the data access is all
    on the same machine, then it may affect scalability of the application; that is,
    it may not perform well under the load.
  prefs: []
  type: TYPE_NORMAL
- en: Using EJB for implementing the business logic is ideal in scenarios where you
    want components processing the business logic to be distributed across different
    servers. However, this is just one of the advantages of EJB. Even if you use EJBs
    on the same server as the web application, you may gain from a number of services
    that the EJB container provides; you can specify the security constraints for
    calling EJB methods declaratively (using annotations) and can easily specify transaction
    boundaries (specify a set of method calls from a part of one transaction) using
    annotations. Furthermore, the container handles the life cycle of EJBs, including
    pooling of certain types of EJB objects so that more objects can be created when
    load on the application increases.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, we created a *Course Management* web application using
    simple JavaBeans. In this chapter, we will create the same application using EJBs
    and deploy it on the GlassFish Server. However, before that we need to understand
    some basic concepts of EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following broad topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding different types of EJBs and how they can be accessed from different
    client deployment scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring GlassFish Server for testing EJB applications in Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and testing EJB projects from Eclipse with and without Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EJB can be of the following types according to the EJB3 specification:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Session bean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful session bean
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless session bean
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton session bean
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Message-driven bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss **message-driven bean** (**MDB**) in detail in a [Chapter 10](part0208.html#66BL00-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Asynchronous Programming with JMS*, when we learn about asynchronous processing
    of requests in the JEE application. In this chapter, we will focus on session
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: Session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, session beans are meant to contain methods to execute the main business
    logic of the enterprise application. Any **Plain Old Java Object** (**POJO**) can
    be annotated with the appropriate EJB3-specific annotations to make it a session
    bean. Session beans come in three types.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One stateful session bean serves requests for one client only. There is one-to-one
    mapping between the stateful session bean and the client. Therefore, stateful
    beans can hold the state data for the client between multiple method calls. In
    our *Course Management* application, we could use a stateful bean for holding
    student data (student profile and courses taken by her/him) after a student logs
    in. The state maintained by the stateful bean is lost when the server restarts
    or when the session times out. Since there is one stateful bean per client, using
    a stateful bean might impact scalability of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `@Stateful` annotation on the class to mark it as a stateful session
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stateless session bean does not hold any state information for the client.
    Therefore, one session bean can be shared across multiple clients. The EJB container
    maintains pools of stateless beans, and when a client request comes, it takes
    a bean out of the pool, executes methods, and returns the bean to the pool again.
    Stateless session beans provide excellent scalability because they can be shared
    and they need not be created for each client.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `@Stateless` annotation on the class to mark it as a stateless session
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, there is only one instance of a singleton bean class in
    the EJB container (this is true in the clustered environment too; each EJB container
    will have one instance of a singleton bean). This means that they are shared by
    multiple clients, and they are not pooled by EJB containers (because there can
    be only one instance). Since a singleton session bean is a shared resource, we
    need to manage concurrency in it. Java EE provides two concurrency management
    options for singleton session beans, namely container-managed concurrency and
    bean-managed concurrency. Container-managed concurrency can be easily specified
    by annotations.
  prefs: []
  type: TYPE_NORMAL
- en: See [https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ](https://javaee.github.io/tutorial/ejb-basicexamples003.html#GIPSZ) for
    more information on managing concurrency in singleton session beans.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a singleton bean could have an impact on the scalability of the application
    if there are resource contentions.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `@Singleton` annotation on the class to mark it as a singleton session
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing session beans from a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session beans can be designed to be accessed locally (client and bean in the
    same application), remotely (from a client running in a different application
    or JVM), or both. In the case of remote access, session beans are required to
    implement a remote interface. For local access, session beans can implement a
    local interface or implement no interface (no-interface view of a session bean).
    The remote and local interfaces that the session bean implements are sometimes
    also called **business interfaces** because they typically expose the primary
    business functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a no-interface session bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a session bean with the no-interface view, create a POJO and annotate
    it with the appropriate EJB annotation type and `@LocalBean`. For example, we
    can create a local stateful `Student` bean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Accessing session beans using dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access session beans either using the `@EJB` annotation (which injects
    the bean in the client class) or by performing the **Java Naming and Directory
    Interface** (**JNDI**) lookup. EJB containers are required to make JNDI URLs of
    the EJBs available to clients.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting session beans using `@EJB` works only for managed components, that
    is, components of the application whose life cycle is managed by the EJB container.
    When a component is managed by the container, it is created (instantiated) and
    destroyed by the container. You do not create managed components using the `new`
    operator. JEE-managed components that support direct injection of EJBs are servlets,
    managed beans of JSF pages, and EJBs themselves (one EJB can have another EJB
    injected into it). Unfortunately, you cannot have a web container inject EJBs
    in JSPs or JSP beans. Furthermore, you cannot have EJBs injected into any custom
    classes that you create and that are instantiated using the `new` operator. Later
    in the chapter, we will see how to use JNDI to access EJBs from objects that are
    not managed by the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use a student bean (created previously) from a managed bean of a JSF
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you create an EJB with no-interface view, then all `public` methods
    in that EJB will be exposed to the client. If you want to control the methods
    that could be called by the client, then you should implement a business interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating session beans using local business interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Business interface for the EJB is a simple Java interface annotated either
    with `@Remote` or `@Local`. Therefore, we can create a local interface for a student
    bean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can implement a session bean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The client can access the `Student` EJB only through the local interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A session bean can implement multiple business interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing session beans using JNDI lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although accessing EJB using dependency injection is the easiest way, it works
    only if the container manages the class that accesses the EJB. If you want to
    access EJB from a POJO that is not a managed bean, then dependency injection will
    not work. Another scenario where dependency injection does not work is when EJB
    is deployed in a separate JVM (could be on a remote server). In such cases, you
    will have to access the EJB using JNDI lookup (visit [https://docs.oracle.com/javase/tutorial/jndi/](https://docs.oracle.com/javase/tutorial/jndi/)
    for more information on JNDI).
  prefs: []
  type: TYPE_NORMAL
- en: 'JEE applications could be packaged in **Enterprise Application aRchive** (**EAR**),
    which contains a `.jar` file for EJBs and a `.war` file for web applications (and
    a `lib` folder containing libraries required for both). If, for example, the name
    of the EAR file is `CourseManagement.ear` and the name of the EJB JAR in it is
    `CourseManagementEJBs.jar`, then the name of the application is `CourseManagement`
    (name of the EAR file) and the module name is `CourseManagementEJBs`. The EJB
    container uses these names to create JNDI URL for looking up EJBs. A global JNDI
    URL for EJB is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the different parameters used in the preceding code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java:global`: This indicates that it is a global JNDI URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<application_name>`: This is typically the name of the EAR file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<module_name>`: This is the name of the EJB JAR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<bean_name>`: This is the name of the EJB bean class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<bean_interface>`: This is optional if EJB has a no-interface view, or if
    EJB implements only one business interface. Otherwise it is a fully qualified
    name of the business interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EJB containers are required to publish two more variations of JNDI URLs for
    each EJB. These are not global URLs, which means that they can''t be used to access
    EJBs from clients that are not in the same JEE application (in the same EAR):'
  prefs: []
  type: TYPE_NORMAL
- en: '`java:app/[<module_name>]/<bean_name>![<bean_interface>]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java:module/<bean_name>![<bean_interface>]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first URL can be used if the EJB client is in the same application, and
    the second URL can be used if the client is in the same module (the same `.jar`
    file as the EJB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you look up any URL in a JNDI server, you need to create `InitialContext`,
    which includes, among other things, information such as the hostname of the JNDI
    server and the port on which it is running. If you create `InitialContext` in
    the same server, then there is no need to specify these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following JNDI URLs to access a no-interface (`LocalBean`) `Student`
    EJB (assuming that the name of the EAR file is `CourseManagement` and the name
    of the `.jar` file for EJBs is `CourseManagementEJBs`):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **When to use** |'
  prefs: []
  type: TYPE_TB
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | The client
    can be anywhere in the EAR file, because we use the global URL. Note that we haven''t
    specified the interface name because we are assuming that the student bean provides
    a no-interface view in this example. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:app/CourseManagementEJBs/Student` | The client can be anywhere in the
    EAR. We skipped application name because the client is expected to be in the same
    application, because the namespace of the URL is `java:app`. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:module/Student` | The client must be in the same `.jar` file as EJB.
    |'
  prefs: []
  type: TYPE_TB
- en: 'We can use the following JNDI URLs for accessing `Student` EJB that implemented
    a local interface called `StudentLocal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **When to use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | The client can be anywhere in the EAR file, because we use a global URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student` | The client
    can be anywhere in the EAR. We skipped the interface name because the bean implements
    only one business interface. Note that the object returned from this call will
    be of `StudentLocal` type, and not `Student` type. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:app/CourseManagementEJBs/Student`Or`java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentLocal`
    | The client can be anywhere in the EAR. We skipped the application name because
    the JNDI namespace is `java:app`. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:module/Student`Or`java:module/Student!packt.jee.book.ch6.StudentLocal`
    | The client must be in the same EAR as the EJB. |'
  prefs: []
  type: TYPE_TB
- en: 'Here is an example of how we can call the student bean with a local business
    interface from one of the objects (that is not managed by the web container) in
    our web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating session beans using remote business interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the session bean that you create is going to be accessed by a client object
    that is not in the same JVM as the bean, then the bean needs to implement a remote
    business interface. You create a remote business interface by annotating the class
    with `@Remote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The EJB implementing the remote interface is also annotated with `@Remote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remote EJBs can be injected into managed objects in the same application using
    the `@EJB` annotation. For example, a JSF bean can access the previously mentioned
    student bean (in the same application) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Accessing remote session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For accessing a remote `Student` EJB, we can use the following JNDI URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **When to use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `java:global/CourseManagement/ CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | The client can be in the same application or remote. In the case of a remote
    client, we need to set up proper `InitialContext` parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:global/CourseManagement/CourseManagementEJBs/Student` | The client
    can be in the same application or remote. We skipped the interface name because
    the bean implements only one business interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:app/CourseManagementEJBs/Student`Or`java:app/CourseManagementEJBs/Student!packt.jee.book.ch6.StudentRemote`
    | The client can be anywhere in the EAR. We skipped the application name because
    the JNDI namespace is `java:app`. |'
  prefs: []
  type: TYPE_TB
- en: '| `java:module/Student`Or`java:module/Student!packt.jee.book.ch6.StudentRemote`
    | The client must be in the same EAR as the EJB. |'
  prefs: []
  type: TYPE_TB
- en: 'To access EJBs from a remote client, you need to use the JNDI lookup method.
    Furthermore, you need to set up `InitialContext` with certain properties; some
    of them are JEE application server specific. If the remote EJB and the client
    are both deployed in GlassFish (different instances of GlassFish), then you can
    look up the remote EJB as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the GlassFish Server in Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use the GlassFish application server in this chapter. We have
    already seen how to install GlassFish in the *Installing GlassFish Server* section
    of [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Introducing
    JEE and Eclipse*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first configure the GlassFish Server in Eclipse JEE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the GlassFish Server in Eclipse EE, make sure that you are in
    the Java EE perspective in Eclipse. Right-click on the Servers view and select
    New | Server. It you do not see the GlassFish Server group in the list of server
    types, then expand Oracle node and select and install GlassFish Tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Installing GlassFish Tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have already installed GlassFish Tools, or if GlassFish Server type
    is available in the list, then expand that and select the GlassFish option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Creating GlassFish Server instance in Eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next. Enter the path of the GlassFish Server on your local machine in
    the Domain path field. Enter admin name and password, if applicable, and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00155.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Defining GlassFish Server properties'
  prefs: []
  type: TYPE_NORMAL
- en: The next page allows you to deploy the existing Java EE projects in GlassFish.
    We don't have any projects to add at this point, so just click Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server is added to the Servers view. Right-click on the server and select
    Start. If the server is installed and configured properly, then the server status
    should change to Started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To open the admin page of the server, right-click on the server and select GlassFish
    | View Admin Console. The admin page is opened in the built-in Eclipse browser.
    You can browse to the server home page by opening the `http://localhost:8080 URL`.
    `8080` is the default GlassFish port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Course Management application using EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create the *Course Management* application that we created in [Chapter
    4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating JEE Database
    Applications,* this time using EJBs. In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, we created service classes (which were POJOs)
    for writing the business logic. We will replace them with EJBs. We will start
    by creating Eclipse projects for EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating EJB projects in Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EJBs are packaged in a JAR file. Web applications are packaged in a **Web Application
    aRchive** (**WAR**). If EJBs are to be accessed remotely, then the client needs
    to have access to business interfaces. Therefore, EJB business interfaces and
    shared objects are packaged in a separate JAR, called EJB client JAR. Furthermore,
    if EJBs and web applications are to be deployed as one single application, then
    they need to be packaged in an EAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in most cases the application with EJBs is not a single project, but four
    different projects:'
  prefs: []
  type: TYPE_NORMAL
- en: EJB project that creates EJB JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJB client project that contains business classes and shared (between EJB and
    client) classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web project that generates WAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EAR project that generates EAR containing EBJ JAR, EJB client JAR, and WAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create each of these projects independently and integrate them. However,
    Eclipse gives you the option to create EJB projects, EJB client projects, and
    EAR projects with one wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select File | New | EJB Project. Type `CourseManagementEJBs` in the Project
    name textbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00156.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: New EJB Project wizard'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure Target runtime is GlassFish 5 and EJB module version is 3.2 or later.
    From the Configuration drop-down list, select Default Configuration for GlassFish
    5\. In the EAR membership group, check the Add project to an EAR box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Next. On the next page, specify source and output folders for the classes.
    Leave the defaults unchanged on this page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Select source and output folders'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source Java files in this project would be created in the `ejbModule` folder.
    Click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00158.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Creating an EJB client project'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse gives you the option to create an EJB client project. Select the option
    and click Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we are building a web application, we will create a web project. Select
    File | Dynamic Web Project. Set the project name as `CourseManagementWeb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: New Dynamic Web Project'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Add Project to an EAR checkbox. Since we have only one EAR project
    in the workspace, Eclipse selects this project from the drop-down list. Click
    Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now have the following four projects in the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Course Management projects'
  prefs: []
  type: TYPE_NORMAL
- en: In the course management application, we will create a stateless EJB called
    `CourseBean`. We will use **Java Persistence API**s (JPA) for data access and
    create a `Course` entity. See [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, for details on using JPAs. The `CourseManagementEJBClient`
    project will contain the EJB business interface and shared classes. In `CourseManagementWeb`,
    we will create a JSF page and a managed bean that will access the `Course` EJB
    in the `CourseManagementEJBs` project to get a list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring datasources in GlassFish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications,* we created the JDBC datasource locally in the application.
    In this chapter, we will create a JDBC datasource in GlassFish. GlassFish Server
    is not packaged with the JDBC driver for MySQL. So, we need to place the `.jar`
    file for `MySQLDriver` in the path where GlassFish can find it. You can place
    such external libraries in the `lib`/`ext` folder of the GlassFish domain in which
    you want to deploy your application. For this example, we will copy the JAR in
    `<glassfish_home>/glassfish/domains/domain1/lib/ext`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not have the MySQL JDBC driver, you can download it from `http://dev.mysql.com/downloads/connector/j/`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the GlassFish admin console, either by right-clicking on the server in
    the Servers view and selecting GlassFish | View Admin Console (this opens the
    admin console inside Eclipse) or browsing to `http://localhost:4848` (`4848` is
    the default port to which the GlassFish admin console application listens). In
    the admin console, select Resources | JDBC | JDBC Connection Pools. Click the New
    button on the JDBC Connection Pool page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00161.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Create JDBC Connection Pool in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set Pool Name as `MySQLconnectionPool` and select javax.sql.DataSource as Resource
    Type. Select MySql from the Database Driver Vendor list and click Next. In the
    next page, select the correct Datasource Classname (com.mysql.jdbc.jdbc2.optional.MysqlDatasource):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: JDBC Connection Pool settings in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set the hostname, port, username, and password of MySQL. In the
    admin page, scroll down to the Additional Properties section and set the following
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Properties** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Port/PortNumber | `3306` |'
  prefs: []
  type: TYPE_TB
- en: '| DatabaseName | `<schemaname_of_coursemanagement>`, for example,`course_management`.
    See [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, for details on creating the MySQL schema for the *Course
    Management* database. |'
  prefs: []
  type: TYPE_TB
- en: '| Password | MySQL database password. |'
  prefs: []
  type: TYPE_TB
- en: '| URL/Url | `jdbc:mysql://:3306/<database_name>` , for example,`jdbc:mysql://:3306/course_management`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ServerName | `localhost` |'
  prefs: []
  type: TYPE_TB
- en: '| User | MySQL username |'
  prefs: []
  type: TYPE_TB
- en: 'Click Finish. The new connection pool is added to the list in the left pane.
    Click on the newly added connection pool. In the General tab, click on the Ping
    button and make sure that the ping is successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Test JDBC Connection Pool in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a JNDI resource for this connection pool so that it
    can be accessed from the client application. Select the Resources | JDBC | JDBC Resources
    node in the left pane. Click the New button to create a new JDBC resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Test JDBC Connection Pool in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: Set JNDI Name as `jdbc/CourseManagement`. From the Pool Name drop-down list,
    select the connection pool that we created for MySQL, `MySQLconnectionPool`. Click
    Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring JPA in an Eclipse project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now configure our EJB project to use JPA to access the MySQL database.
    We have already learned how to enable JPA for an Eclipse project in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, we will briefly cover the steps
    again here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `CourseManagementEJBs` project in Project Explorer and select
    Configure | Convert to JPA Project. Eclipse opens the Project Facets window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00165.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Eclipse Project Facets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next to go to the JPA Facet page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: JPA Facet'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the default values unchanged, and click Finish. Eclipse adds `persistence.xml`,
    required by JPA, to the project under the JPA Content group in Project Explorer.
    We need to configure the JPA datasource in `persistence.xml`. Open `persistence.xml`
    and click on the Connection tab. Set Transaction Type to `JTA`. In the JTA datasource
    textbox, type the JNDI name that we set up for our MySQL database in the previous
    section, which was `jdbc/CourseManagement`. Save the file. Note that the actual
    location of `persistence.xml` is `ejbModule`/`META-INF`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a database connection in Eclipse and link it with JPA properties
    of the project so that we can create JPA entities from the database tables. Right-click
    on the `CourseManagementEJBs` project and select Properties. This opens the Project
    Properties window. Click on the JPA node to see the details page. Click on the Add
    connection link just below the Connection drop-down box. We have already seen
    how to set up a database connection in the *Using Eclipse Data Source Explorer*
    section of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*. However, we will quickly recap the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Connection Profile window, select MySQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00167.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: New DB Connection Profile'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `CourseManagementDBConnection` in the name textbox and click Next. In
    the New Connection Profile window, click on the new connection profile button
    (the circle next to the Drivers drop-down box) to open the New Driver Definition
    window. Select the appropriate MySQL JDBC Driver version and click on the JAR
    List tab. In the case of any error, remove any existing `.jar` and click on the
    Add JAR/Zip button. Browse to the MySQL JDBC driver JAR that we saved in the `<glassfish_home>/glassfish/domains/domain1/lib/ext`
    folder. Click OK. Back in the New Connection Profile window, enter the database
    name, modify the connection URL, and enter User name and Password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00168.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Configuring MySQL database connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Save password checkbox. Click the Test Connection button and make
    sure that the test is successful. Click the Finish button. Back in the JPA properties
    page, the new connection is added and appropriate schema is selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Connection added to JPA project properties'
  prefs: []
  type: TYPE_NORMAL
- en: Click OK to save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a JPA entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create the entity class for `Course`, using Eclipse JPA tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `CourseManagementEJBs` project and select JPA Tool | Generate
    Entities from Tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Creating entity from tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the Course table and click Next. Click Next in the Table Associations
    window. On the next page, select `identity` as Key generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Customizing JPA entity details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the package name. We do not want to change anything on the next page,
    so click Finish. Notice that the wizard creates a `findAll` query for the class
    that we can use to get all courses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating stateless EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now create the stateless EJB for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the `ejbModule` folder in the `CourseManagementEJBs` project
    in Project Explorer and select New | Session Bean (3.x). Type `packt.book.jee.eclipse.ch7.ejb`
    in the Java package textbox and `CourseBean` in Class name. Select the Remote
    checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Creating a stateless session bean'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next. No change is required on the next page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Stateless session bean information'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. A `CourseBean` class is created with `@Stateless` and `@Localbean`
    annotations. The class also implements the `CourseBeanRemote` interface, which
    is defined in the `CourseManagementEJBClient` project. This interface is a shared
    interface (a client calling EJB needs to access this interface):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface is annotated with `@Remote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, the question is how do we return `Course` information from our EJB? The
    EJB will call JPA APIs to get instances of the `Course` entity, but do we want
    EJB to return instances of the `Course` entity or should it return instances of
    lightweight **data transfer object** (**DTO**)? Each has its own advantages. If
    we return a `Course` entity, then we do not need to transfer data between objects;
    which we will have to do in the case of DTO (transfer data from the entity to
    the corresponding DTO). However, passing entities between layers may not be a
    good idea if the EJB client is not in the same application, and you may not want
    to expose your data model to external applications. Furthermore, by passing back
    JPA entities you are forcing the client application to depend on JPA libraries
    in its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: DTOs are lightweight, and you can expose only those fields that you want your
    clients to use. However, you will have to transfer data between entities and DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: If your EJBs are going to be used by the client in the same application, then
    it could be easier to transfer entities to the client from the EJBs. However,
    if your client is not part of the same EJB application, or when you want to expose
    the EJB as a web service (we will learn how to create web services in [Chapter
    9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating Web Services*),
    then you may need to use DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we will see examples of both the approaches, that is, an
    EJB method returning JPA entities as well as DTOs. Remember that we have created
    `CourseBean` as a remote as well as a local bean (no-interface view). Implementation
    of the remote interface method will return DTOs and that of the local method will
    return JPA entities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add the `getCourses` method to the EJB. We will create `CourseDTO`,
    a data transfer object, which is a POJO, and returns instances of the DTO from
    the `getCourses` method. This DTO needs to be in the `CourseManagementEJBsClient`
    project because it will be shared between the EJB and its client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following class in the `packt.book.jee.eclipse.ch7.dto` package
    in the `CourseManagementEJBsClient` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following method to `CourseBeanRemote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to implement this method in `CourseBean` EJB. To get the courses from
    the database, the EJB needs to first get an instance of `EntityManager`. Recall
    that in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications,* we created `EntityManagerFactory` and got an instance
    of `EntityManager` from it. Then, we passed that instance to the service class,
    which actually got the data from the database using JPA APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'JEE application servers make injecting `EntityManager` very easy. You just
    need to create the `EntityManager` field in the EJB class and annotate it with
    `@PersistenceContext(unitName="<name_as_specified_in_persistence.xml>")`. The
    `unitName` attribute is optional if there is only one persistence unit defined
    in `persistence.xml`. Open the `CourseBean` class and add the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: EJBs are managed objects, and the EJB container injects `EntityManager` after
    EJBs are created.
  prefs: []
  type: TYPE_NORMAL
- en: Auto injection of objects is a part of JEE features called **Context and Dependency
    Injection** (**CDI**). See [https://javaee.github.io/tutorial/cdi-basic.html#GIWHB](https://javaee.github.io/tutorial/cdi-basic.html#GIWHB) for
    information on CDI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add a method to `CourseBean` EJB that will return a list of `Course`
    entities. We will name this method `getCourseEntities`. This method will be called
    by the `getCourses` method in the same EJB, which will then convert the list of
    entities to DTOs. The method `getCourseEntities` can also be called by any web
    application, because the EJB exposes no-interface view (using the `@LocalBean`
    annotation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After implementing the `getCourses` method (defined in our remote business
    interface called `CourseBeanRemote`), we have `CourseBean`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating JSF and managed beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a JSF page to display courses in the `CourseManagementWeb`
    project. We will also create a managed bean that will call the `getCourses` method
    of `CourseEJB`. See the *Java Server Faces* section in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, for details about JSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*, we need to add JSF Servlet and mapping
    to `web.xml`. Open `web.xml` from the `CourseManagementWeb` project. You can open
    this file either by double-clicking the Deployment Descriptor: CourseManagementWeb
    node (under the project in Project Explorer) or from the `WebContent/Web-INF`
    folder (again, under the project in Project Explorer). Add the following servlet
    declaration and mapping (within the `web-app` node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CourseManagementWeb` project needs to access the business interface of
    EJB, which is in `CourseManagementEJBsClient`. So, we need to add the reference
    of `CourseManagementEJBsClient` to `CourseManagementWeb`. Open the project properties
    of `CourseManagementWeb` (right-click on the `CourseManagementWeb` project and
    select Properties) and select Java Build Path. Click on the Projects tab, and
    then click the Add... button. Select `CourseManagementEJBsClient` from the list
    and click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Adding project reference'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a managed bean for the JSF that we are going to create later.
    Create a `CourseJSFBean` class in the `packt.book.jee.eclipse.ch7.web.bean` package
    in the `CourseManagementWeb` project (Java source files go in the `src` folder
    under the Java Resources group):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: JSF beans are managed beans, so we can have the container inject EJBs using
    the `@EJB` annotation. In the preceding code we have referenced `CourseBean` with
    its remote interface, `CourseBeanRemote`. We then created a method called `getCourses`,
    which calls the method with the same name on `Course` EJB and returns the list
    of `CourseDTO` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have set the `name` attribute in the `@ManagedBean` annotation.
    This managed bean would be accessed from JSF as variable `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create the JSF page, `course.xhtml`. Right-click on WebContent
    group in the `CourseManagementWeb` project, and select New | File. Create `courses.xhtml` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The page uses the `dataTable` tag ([https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html](https://docs.oracle.com/javaee/7/javaserver-faces-2-2/vdldocs-jsp/h/dataTable.html)),
    which receives the data to populate from the `Course` managed bean (which is actually
    the `CourseJSFBean` class). `Course.courses` in the expression language syntax
    is a short-form for `Course.getCourses()`. This results in a call to the `getCourses`
    method of the `CourseJSFBean` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each element of the list returned by `Course.courses`, which is `List` of `CourseDTO`,
    is represented by the `course` variable (in the `var` attribute value). We then
    display the name and credits of each course in the table using the `column` child
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: Running the example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can run the example, we need to start the GlassFish Server and deploy
    our JEE application in it:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the GlassFish Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once it is started, right-click on the GlassFish Server in the Servers view
    and select the Add and Remove... menu option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Adding a project to GlassFish for deployment'
  prefs: []
  type: TYPE_NORMAL
- en: Select the EAR project and click on the Add button. Then, click Finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The selected EAR application will be deployed in the server:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: Application deployed in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: To run the JSF page, `course.xhtml`, right-click on it in Project Explorer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: and select Run As | Run on Server. The page will be opened in the internal Eclipse
    browser and courses in the MySQL database will be displayed on the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we can use `CourseBean` (EJB) as a local bean in `CourseJSFBean`,
    because they are in the same application deployed on the same server. To do this,
    add a reference of the `CourseManagementEJBs` project in the build path of `CourseManagementWeb`
    (open the project properties of `CourseManagementWeb`, select Java Build Path,
    select the Projects tab, and click the Add... button. Select the `CourseManagementEJBs`
    project and add its reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `CourseJSFBean` class, remove the declaration of `CourseBeanRemote`
    and add one for `CourseBean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When you make any changes in the code, the EAR project needs to be redeployed
    in the GlassFish Server. In Servers view, you can see whether redeployment is
    needed by checking the status of the server. If it is [Started, Synchronized],
    then no redeployment is needed. However, if it is [Started, Republish], then redeployment
    is required. Just click on the server node and select the Publish menu option.
  prefs: []
  type: TYPE_NORMAL
- en: Creating EAR for deployment outside Eclipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we learned how to deploy an application to GlassFish from
    Eclipse. This works fine during development, but finally you will need to create
    the EAR file for deployment to an external server. To create the EAR file from
    the project, right-click on the EAR project (in our example, it is `CourseManagementEJBsEAR`)
    and select Export | EAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Exporting to EAR file'
  prefs: []
  type: TYPE_NORMAL
- en: Select the destination folder and click Finish. This file can then be deployed
    in GlassFish using the management console or by copying it to the `autodeploy`
    folder in GlassFish.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JEE project using Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to create JEE projects with EJBs using Maven.
    Creating Maven projects may be preferable to Eclipse JEE projects because builds
    can be automated. We have seen many details of creating EJBs, JPA entities, and
    other classes in the previous section, so we won''t repeat all that information
    here. We have also learned how to create Maven projects in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application,* and [Chapter 3](part0057.html#1MBG20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Source Control Management in Eclipse,* so the basic details of creating a Maven
    project will not be repeated either. We will focus mainly on how to create EJB
    projects using Maven. We will create the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CourseManagementMavenEJBs`: This project contains EJBs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CourseManagementMavenEJBClient`: This project contains shared interfaces and
    objects between an EJB project and the client projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CourseManagementMavenWAR`: This is a web project containing a JSF page and
    a managed bean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CourseManagementMavenEAR`: This project creates the EAR file that can be deployed
    in GlassFish'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CourseManagement`: This project is the overall parent project that builds
    all the previously mentioned projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We still start with `CourseManagementMavenEJBs`. This project should generate
    the EJB JAR file. Let''s create a Maven project with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ** Field** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  prefs: []
  type: TYPE_TB
- en: '| Artifact ID | CourseManagementMavenEJBClient |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging | jar |'
  prefs: []
  type: TYPE_TB
- en: 'We need to add the dependency of JEE APIs to our EJB project. Let''s add the
    dependency of `javax.javaee-api`. Since we are going to deploy this project in
    GlassFish, which comes with its own JEE implementation and libraries, we will
    scope this dependency as provided. Add the following in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create the EJBs in this project, we need to create local or remote
    business interfaces in a shared project (client project). Therefore, we will create
    `CourseManagementMavenEJBClient` with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  prefs: []
  type: TYPE_TB
- en: '| Artifact ID | CourseManagementMavenEJBs |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging | jar |'
  prefs: []
  type: TYPE_TB
- en: This shared project also needs to access EJB annotations. So, add the same dependency
    for `javax.javaee-api` that we added previously to the `pom.xml` file of the `CourseManagementMavenEJBClient`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a `packt.book.jee.eclipse.ch7.ejb` package in this project and
    create a remote interface. Create a `CourseBeanRemote` interface (just as we created
    in the *Creating stateless EJB* section of this chapter). Furthermore, create
    a `CourseDTO` class in the `packt.book.jee.eclipse.ch7.dto` package. This class
    is the same as the one that we created in the *Creating stateless EJB* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a `Course` JPA entity in the `CourseManagementMavenEJBs` project.
    Before we do that, let''s convert this project to a JPA project. Right-click on
    the project in Package Explorer and select Configure | Convert to JPA Project.
    In the JPA configuration wizard, select the following JPA facet details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Platform | Generic 2.1 |'
  prefs: []
  type: TYPE_TB
- en: '| JPA Implementation | Disable Library Configuration |'
  prefs: []
  type: TYPE_TB
- en: JPA wizard creates a `META-INF` folder in the `src` folder of the project and
    creates `persistence.xml`. Open `persistence.xml` and click on the Connection
    tab. We have already created the MySQL datasource in GlassFish (see the *Configuring
    datasource in GlassFish* section). Enter the JNDI name of the datasource, `jdbc/CourseManagement`,
    in the JTA data source field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Course` entity in `packt.book.jee.eclipse.ch7.jpa`, as described
    in the *Creating JPA entity* section. Before we create the EJB in this project,
    let''s add an EJB facet to this project. Right-click on the project and select
    Properties. Click on the Project Facets group and select the EJB Module checkbox.
    Set version to the latest one (at the time of writing, the latest version was
    3.2). We will now create the implementation class of the remote session bean interface
    that we created previously. Right-click on the `CourseManagementMavenEJBs` project
    and select the New | Session Bean menu. Create the EJB class with the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Java package | packt.book.jee.eclipse.ch7.ejb |'
  prefs: []
  type: TYPE_TB
- en: '| Class name | CourseBean |'
  prefs: []
  type: TYPE_TB
- en: '| State type | Stateless |'
  prefs: []
  type: TYPE_TB
- en: 'Do not select any business interface, because we have already created the business
    interface in the `CourseManagementMavenEJBClient` project. Click Next. On the
    next page, select `CourseBeanRemote`. Eclipse will show errors at this point because
    `CourseManagementMavenEJBs` does not know about `CourseManagementMavenEJBClient`,
    which contains the `CourseBeanRemote` interface, used by `CourseBean` in the EJB
    project. Adding the Maven dependency (in `pom.xml`) for `CourseManagementMavenEJBClient`
    in `CourseManagementMavenEJBs` and implementing the `getCourses` method in the
    EJB class should fix the compilation errors. Now complete the implementation of
    the `CourseBean` class as described in the *Creating stateless EJB* section of
    this chapter. Make sure that EJB is marked as `Remote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a web application project for course management using Maven.
    Create a Maven project with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  prefs: []
  type: TYPE_TB
- en: '| Artifact ID | CourseManagementMavenWebApp |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging | war |'
  prefs: []
  type: TYPE_TB
- en: To create `web.xml` in this project, right-click on the project and select Java
    EE
  prefs: []
  type: TYPE_NORMAL
- en: Tools | Generate Deployment Descriptor Stub. The `web.xml` file is created in
    the `src/main/webapp/WEB-INF` folder. Open `web.xml` and add the servlet definition
    and mapping for JSF (see the *Creating JSF and managed bean* section of this chapter).
    Add the dependency of the `CourseManagementMavenEJBClient` project and `javax`.
    `javaee-api` in `pom.xml` of the `CourseManagementMavenWebApp` project so that
    the web project has access to the EJB business interface declared in the shared
    project and also to EJB annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a `CourseJSFBean` class in the web project as described in
    the *Creating JSF and managed bean* section. Note that this will reference the
    remote interface of the EJB in the managed bean, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Create `course.xhtml` in the `webapp` folder as described in the *Creating JSF
    and managed bean* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a `CourseManagementMavenEAR` project with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  prefs: []
  type: TYPE_TB
- en: '| Artifact ID | CourseManagementMavenEAR |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging | ear |'
  prefs: []
  type: TYPE_TB
- en: 'You will have to type `ear` in the Packaging file; there is no `ear` option
    in the drop-down list. Add dependencies of `web`, `ejb`, and client projects to `pom.xml`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to set `<type>` of each dependency properly. You also need to update
    JNDI URLs for any name changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven does not have built-in support to package EAR. However, there is a Maven
    plugin for EAR. You can find details of this plugin at [https://maven.apache.org/plugins/maven-ear-plugin/](https://maven.apache.org/plugins/maven-ear-plugin/)
    and [https://maven.apache.org/plugins/maven-ear-plugin/modules.html](https://maven.apache.org/plugins/maven-ear-plugin/modules.html).
    We need to add this plugin to our `pom.xml` and configure its parameters. Our
    EAR file will contain the JAR for the EJB project, the client project, and the
    WAR for the web project. Right-click on `pom.xml` of the EAR project, and select
    Maven | Add Plugin. Type `ear` in the Filter box, and select the latest plugin
    version under maven-ear-plugin. Make sure that you also install the maven-acr-plugin
    plugin. Configure the EAR plugin in the `pom.xml` details, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After modifying `pom.xml`, sometimes Eclipse may display the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In such cases, right-click on the project and select Maven | Update Project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last project that we create in this section is `CourseManagement`, which
    will be the container project for all other EJB projects. When this project is
    installed, it should build and install all the contained projects. Create a Maven
    project with the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Fields** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Group ID | packt.book.jee.eclipse.ch7.maven |'
  prefs: []
  type: TYPE_TB
- en: '| Artifact ID | CourseManagement |'
  prefs: []
  type: TYPE_TB
- en: '| Version | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Packaging | Pom |'
  prefs: []
  type: TYPE_TB
- en: 'Open `pom.xml` and click on the Overview tab. Expand the Modules group, and
    add all the other projects as modules. The following modules should be listed
    in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Right-click on the `CourseManagement` project and select Run As | Maven Install.
    This builds all EJB projects, and an EAR file is created in the target folder
    of the `CourseManagementMavenEAR` project. You can deploy this EAR in GlassFish
    from its management console, or you can right-click on the configured GlassFish
    Server in the Servers view of Eclipse, select the Add and Remove... option, and
    deploy the EAR project from within Eclipse. Browse to `http://localhost:8080/CourseManagementMavenWebApp/course.xhtml`
    to see the list of courses displayed by the `course.xhtml` JSF page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EJBs are ideal for writing business logic in web applications. They can act
    as the perfect bridge between web interface components such as JSF, servlet, or
    JSP and data access objects such as JDO. EJBs can be distributed across multiple
    JEE application servers (this could improve application scalability), and their
    life cycle is managed by the container. EJBs can be easily injected into managed
    objects or can be looked up using JNDI.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse JEE makes creating and consuming EJBs very easy. Just like we saw how
    Tomcat can be configured and managed within Eclipse, JEE application servers,
    such as GlassFish, can also be managed from within Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to create web applications using Spring
    MVC. Although Spring is not part of JEE, it is a popular framework to implement
    the MVC pattern in JEE web applications. Spring can also work with many of the
    JEE specifications.
  prefs: []
  type: TYPE_NORMAL
