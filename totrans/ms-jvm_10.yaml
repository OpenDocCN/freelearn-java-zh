- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraalVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the ever-evolving landscape of JVMs, GraalVM stands out as a revolutionary
    and versatile alternative. This chapter delves into the intricacies of GraalVM,
    unraveling its unique features and shedding light on its role as a game-changer
    in the realm of JVM internals. GraalVM, developed by Oracle Labs, transcends the
    traditional boundaries of a conventional JVM by providing a polyglot runtime that
    supports multiple languages, including Java, JavaScript, Python, Ruby, and more.
    This flexibility opens up new avenues for developers, allowing them to integrate
    different languages within a single application seamlessly. As we navigate the
    pages of this chapter, you’ll gain a comprehensive understanding of GraalVM’s
    architecture, its distinctive components, and its pivotal role in reshaping the
    landscape of Java development.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM’s architecture is a testament not only to its engineering prowess but
    also to its commitment to performance and efficiency. The chapter not only explores
    the underlying architecture and components of GraalVM but also highlights its
    innovative JIT compiler, which is at the heart of its efficiency. Understanding
    the nuts and bolts of GraalVM’s architecture is essential for developers looking
    to harness its power to optimize and enhance the performance of their applications.
    Additionally, we’ll delve into real-world use cases, showcasing scenarios where
    GraalVM excels and the unique problems it addresses. Whether you’re aiming to
    boost the execution speed of your Java applications or seeking a seamless integration
    of multiple languages, GraalVM emerges as a compelling solution, and this chapter
    will guide you through its capabilities and potential applications. Get ready
    to explore the cutting-edge features of GraalVM and unlock a new dimension of
    possibilities in the ever-evolving landscape of JVM internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll explore the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Native Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM 21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any preferred IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter’s GitHub repository, found at - [https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07](https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraalVM overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this enlightening section, we’ll embark on a journey through the groundbreaking
    landscape of GraalVM, an innovation that has redefined the expectations of a JVM.
    GraalVM’s rise to prominence can be attributed to its sensational features, with
    a special emphasis on its high-performance compiler, **ahead-of-time** (**AOT**)
    compilation, and prowess in managing diverse language runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: At the heart of GraalVM’s exceptional performance lies its state-of-the-art
    JIT compiler. This compiler is meticulously engineered to optimize the execution
    of Java applications, pushing the boundaries of speed and efficiency. Unlike traditional
    JVMs, GraalVM’s JIT compiler boasts advanced techniques and optimizations, resulting
    in faster startup times and reduced memory footprint. Therefore, developers experience
    a significant boost in the overall performance of their applications, making GraalVM
    an invaluable tool for those striving for excellence in execution speed.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM introduces a paradigm shift with its AOT compilation, enabling developers
    to pre-compile their programs into native machine code. This approach eliminates
    the need for JIT compilation during runtime, resulting in faster startup times
    and lower memory consumption. AOT compilation opens up new horizons for GraalVM,
    making it an ideal choice for scenarios where rapid startup and reduced latency
    are critical. This section will explore the intricacies of AOT compilation and
    guide you on harnessing its power to optimize your applications.
  prefs: []
  type: TYPE_NORMAL
- en: GraalVM transcends the confines of a traditional JVM by offering a multilingual
    runtime environment. This means developers can seamlessly integrate and execute
    programs written in multiple languages within the same application. From Java
    and JavaScript to Python, Ruby, and more, GraalVM supports various languages,
    fostering a polyglot ecosystem. This section will delve into the implications
    of polyglot capabilities, demonstrating how developers can leverage this feature
    to build versatile and efficient applications that transcend language barriers.
  prefs: []
  type: TYPE_NORMAL
- en: While GraalVM brings many innovative features, like any technology, it comes
    with trade-offs. This section aims to shed light on these considerations, helping
    developers make informed decisions on when and where to harness the power of GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'While balancing benefits such as enhanced runtime and polyglot capabilities,
    developers must also consider factors like increased memory usage, longer compilation
    times, and compatibility nuances. Exploring these trade-offs will empower developers
    to make informed decisions tailored to their project requirements. Understanding
    these intricacies enables a strategic application of GraalVM’s strengths while
    mitigating potential challenges in specific use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory overhead**: A slight increase in memory usage often accompanies GraalVM’s
    impressive performance gains. The advanced optimizations and versatile language
    support contribute to a more substantial memory footprint than some traditional
    JVMs. Developers must weigh the performance benefits against the potential impact
    on memory resources, particularly in environments with stringent memory constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compilation time**: While GraalVM’s JIT compiler is a powerhouse for runtime
    performance, it’s worth noting that the initial compilation time may be longer
    compared to other JVMs. Developers working on short-lived applications or scenarios
    where quick startup is critical should carefully assess whether the benefits of
    runtime performance outweigh the longer compilation times during application initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility**: While GraalVM supports a wide array of languages, certain
    language features or libraries might not be fully compatible. Developers need
    to consider their projects’ specific language requirements and ensure that GraalVM
    provides adequate support. Compatibility issues may require additional effort
    in adapting or optimizing code to work seamlessly with GraalVM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identifying the optimal scenarios for leveraging GraalVM’s strengths requires
    a targeted assessment of best use cases. In microservices and serverless architectures,
    GraalVM’s superior performance and reduced memory footprint align seamlessly with
    the agility demands of these environments. Its polyglot capabilities make it ideal
    for projects involving multiple languages, fostering a cohesive runtime environment.
    High-performance computing applications benefit from GraalVM’s advanced JIT compilation,
    accelerating computation-intensive tasks. Additionally, resource-intensive applications
    in cloud environments can capitalize on GraalVM’s efficiency in resource utilization
    without compromising performance. Developers can strategically employ GraalVM
    to maximize its advantages in diverse application scenarios by pinpointing these
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microservices and serverless architectures**: GraalVM’s impressive performance
    gains and reduced memory footprint make it well-suited for microservices and serverless
    architectures. The faster startup times and efficient resource utilization align
    with the demands of these environments where agility and responsiveness are paramount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyglot applications**: The polyglot capabilities of GraalVM shine in scenarios
    where applications are built using multiple programming languages. If your project
    involves components written in Java, JavaScript, Python, Ruby, and more, GraalVM’s
    ability to seamlessly integrate these languages within a single runtime environment
    becomes a decisive advantage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-performance computing**: Applications with a focus on high-performance
    computing, such as scientific simulations or data processing, can benefit from
    GraalVM’s advanced JIT compilation. The enhanced runtime performance can significantly
    accelerate computation-intensive tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource-intensive applications**: GraalVM’s efficiency in resource utilization
    makes it an excellent choice for resource-intensive applications, particularly
    in cloud-based environments. Developers can leverage GraalVM to optimize resource
    consumption without compromising on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, GraalVM presents a compelling option for various scenarios, especially
    where the trade-offs align with the project’s priorities and constraints. By carefully
    evaluating the application’s specific needs, developers can harness the full potential
    of GraalVM in scenarios where its strengths shine the brightest.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude our exploration of GraalVM and its nuanced considerations, it
    becomes evident that this innovative JVM alternative is a force to be reckoned
    with in the ever-evolving landscape of Java development. From its high-performance
    JIT compiler to polyglot language runtimes, GraalVM offers a compelling set of
    features that can elevate application development to new heights. While we’ve
    discussed the trade-offs involved, it’s crucial to recognize that these considerations
    are integral to making informed decisions in line with specific project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, our journey through GraalVM’s best use cases has unveiled scenarios
    where its strengths shine brightest, from microservices architectures to resource-intensive
    cloud applications. However, the story doesn’t end here. GraalVM’s Native Image
    functionality takes the narrative further by allowing developers to compile applications
    ahead of time into standalone executables, completely sidestepping the need for
    a JVM during deployment. It sets the stage for a deeper dive into Native Image,
    where GraalVM’s capabilities are extended to provide an even more streamlined,
    efficient, and resource-friendly approach to application deployment. As we unravel
    the possibilities unlocked by GraalVM’s Native Image, reshaping the landscape
    of Java development with unparalleled efficiency and innovation.
  prefs: []
  type: TYPE_NORMAL
- en: Native Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to an illuminating session dedicated to GraalVM, a game-changing technology
    that transcends the conventional boundaries of JVMs. Developed by Oracle Labs,
    GraalVM emerges as a multifaceted solution, introducing revolutionary features
    that redefine the application development landscape. This section serves as your
    gateway to understanding the key facets of GraalVM, from its high-performance
    JIT compiler to its polyglot language runtimes and innovative AOT compilation.
    As we delve into GraalVM’s architecture and capabilities, you’ll gain insights
    into how it addresses the evolving needs of modern applications. Join us on this
    exploration of GraalVM, where innovation meets versatility, and discover how it
    empowers developers to create efficient, polyglot applications that push the boundaries
    of what’s possible in the Java ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most distinctive features of GraalVM is its Native Image functionality,
    a transformative capability that propels application deployment into a new era.
    Unlike traditional Java applications running on a JVM, GraalVM’s Native Image
    empowers developers to compile their applications ahead of time into standalone
    executables. Instead of relying on a JVM during deployment, the application is
    packaged as a self-contained binary directly interacting with the operating system,
    bypassing the need for an intermediary virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of the Native Image approach lies in its efficiency gains
    during both startup time and runtime performance. By eliminating the need for
    a JVM to interpret and execute the code, Native Image significantly reduces the
    application’s startup time, making it ideal for scenarios where rapid responsiveness
    is crucial. Moreover, the absence of a JVM reduces the application’s memory footprint,
    enhancing resource utilization and making it more suitable for resource-constrained
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it should also be highlighted that AOT compilation removes the exact
    benefits of JIT compilation as the bytecode is no longer available at runtime
    to optimize the code concerning changing code behavior. In many cases where applications
    run for a longer time, the gain of a quick startup, while notable, may be partially
    offset because the overall performance is lower due to the absence of dynamic
    runtime optimizations. For a detailed exploration of this trade-off between AOT
    and JIT, you can refer to this insightful presentation: [https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/](https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While GraalVM’s Native Image feature brings notable advantages in terms of
    startup time, memory efficiency, and resource utilization, it also comes with
    trade-offs that developers should carefully consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build time and complexity**: Creating a Native Image involves AOT compilation,
    which occurs during the build phase. This compilation process is more time-consuming
    compared to traditional JIT compilation used in JVM-based applications. Additionally,
    configuring the Native Image build can be more intricate, requiring developers
    to manage native libraries, reflective access, and other considerations to achieve
    optimal results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic class loading and reflection**: Native Image requires a static analysis
    of the application’s code during compilation, which can pose challenges for applications
    that heavily rely on dynamic class loading or reflection. Since the Native Image
    compiler needs to know the complete set of classes and methods at build time,
    dynamically loaded or generated code may need special handling, potentially requiring
    adjustments to the application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited runtime profile**: AOT compilation necessitates a comprehensive understanding
    of the application’s behavior during the build phase. It can be challenging for
    applications with complex runtime behaviors or those dynamically adapting to various
    scenarios. In such cases, the Native Image may not capture the complete runtime
    profile, leading to potential performance trade-offs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform dependencies**: Native Image produces platform-specific binaries,
    potentially introducing challenges for cross-platform compatibility. While GraalVM
    provides some level of cross-compilation support, developers must be mindful of
    potential platform dependencies and thoroughly test their applications on target
    platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The footprint of included libraries**: Including certain libraries in a Native
    Image can increase size, potentially offsetting some of the gains in memory efficiency.
    Developers must carefully choose and optimize the dependencies included in the
    native image to strike the right balance between footprint and functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Navigating the landscape of application deployment, it becomes essential to
    comprehend the fundamental distinctions between Native Image applications and
    those running on a JVM. The divergence lies in their approach to execution and
    resource utilization. Native Image applications, crafted through GraalVM’s innovative
    AOT compilation, stand out for their streamlined startup times and reduced memory
    footprints. They eschew the need for a JVM during deployment, directly interacting
    with the operating system as standalone executables. In contrast, JVM-based applications
    boast portability across platforms and can run on any environment equipped with
    a compatible JVM. Next, we’ll delve into the nuances of these differences, shedding
    light on considerations such as startup time, memory efficiency, and the impact
    on application portability. By unraveling these distinctions, developers can make
    informed choices tailored to the specific demands of their projects, unlocking
    the optimal balance between performance, portability, and resource utilization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup time**: Native Image applications excel in terms of startup time
    as they eliminate the overhead associated with initializing a JVM. This is particularly
    advantageous for short-lived applications or microservices where rapid responsiveness
    is paramount. In contrast, JVM-based applications typically have a longer startup
    time as the JVM needs to interpret and compile the code at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory footprint**: Native Image applications generally have a smaller memory
    footprint compared to their JVM counterparts. Without the need for a JVM, the
    overhead associated with running the virtual machine is eliminated, resulting
    in more efficient resource utilization. This makes Native Image applications well-suited
    for environments with stringent memory constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: JVM applications are known for their portability – the ability
    to run on any platform with a compatible JVM. On the other hand, Native Image
    applications, being compiled to platform-specific binaries, may have platform
    dependencies. While GraalVM provides some level of cross-compilation support,
    it’s essential to consider platform-specific implications when using Native Image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Diving into the intricate decision-making process of application deployment,
    the following comparison table illuminates the distinctive characteristics between
    Native Image applications and those operating on a JVM. Each column encapsulates
    crucial aspects that influence performance, resource utilization, and adaptability.
    Native Image applications, sculpted through GraalVM’s innovative AOT compilation,
    boast expedited startup times and diminished memory footprints, making them particularly
    adept for scenarios prioritizing efficiency. In contrast, JVM-based applications
    offer the advantage of cross-platform compatibility and dynamic adaptability,
    leveraging JIT compilation. This table serves as a compass for developers, providing
    a concise yet comprehensive guide to navigate the trade-offs and make informed
    decisions based on the specific needs of their projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Native** **Image Applications** | **JVM-Based Applications**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Startup Time** | Generally faster | May be slower, depending on the JIT
    compilation |'
  prefs: []
  type: TYPE_TB
- en: '| **Memory Footprint** | Smaller | Larger |'
  prefs: []
  type: TYPE_TB
- en: '| **Build Time** | Longer due to AOT compilation | Shorter due to the JIT compilation
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Dynamic** **Class Loading** | Limited; requires careful handling | More
    flexible |'
  prefs: []
  type: TYPE_TB
- en: '| **Reflection** | Limited; requires careful handling | More flexible |'
  prefs: []
  type: TYPE_TB
- en: '| **Platform Portability** | Platform-specific binaries | Cross-platform with
    a compatible JVM |'
  prefs: []
  type: TYPE_TB
- en: '| **Resource Utilization** | Efficient; lower overheads | May have higher overheads
    depending on the JVM |'
  prefs: []
  type: TYPE_TB
- en: '| **Dependency Inclusion** | Need to optimize to manage size | Easier management
    with dependency managers |'
  prefs: []
  type: TYPE_TB
- en: '| **Adaptability to** **Runtime Changes** | Less dynamic; needs careful handling
    | More adaptive with JIT compilation |'
  prefs: []
  type: TYPE_TB
- en: '| **Build Complexity** | Higher; requires configuration | Lower; generally
    handled by the JVM |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.1: Native Image versus JVM'
  prefs: []
  type: TYPE_NORMAL
- en: This table provides a high-level overview of the key differences between Native
    Image and JVM-based applications. It’s important to note that the choice between
    the two depends on specific project requirements, considering factors such as
    startup time, memory efficiency, platform portability, and flexibility needed
    in dynamic features.
  prefs: []
  type: TYPE_NORMAL
- en: On exploring the differences between Native Image applications and their counterparts,
    it becomes clear that the path to optimal application deployment is nuanced and
    multifaceted. This comparative journey has uncovered both approaches’ unique strengths
    and considerations, guiding developers toward informed decisions that align with
    project priorities. Now, with a richer understanding of the trade-offs and benefits,
    we stand at the threshold of hands-on mastery.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming session, we’ll delve into the practical realm of creating a
    Native Image using GraalVM. We’ll unravel the intricacies of the AOT compilation
    process, demystifying the steps to transform a Java application into a standalone
    executable. From optimizing dependencies to navigating platform specific considerations,
    this hands-on exploration will empower you to harness the efficiency gains of
    Native Image deployment. Join us in the next section as we embark on a practical
    journey toward unlocking the potential of Native Image, reshaping the landscape
    of application deployment with GraalVM’s groundbreaking capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Native Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this immersive and hands-on section, we delve into mastering the creation
    of Native Images using GraalVM. Building upon the insights gained in our comparative
    exploration of Native Image applications and JVM counterparts, this section is
    your gateway to the practical realm of application deployment efficiency. As we
    shift from theory to practice, our focus now centers on empowering you to wield
    the transformative capabilities of Native Image compilation. Prepare to embark
    on a journey where we demystify the AOT compilation process, offering step-by-step
    guidance on transforming a Java application into a standalone executable.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we will delve into the intricacies of optimizing dependencies,
    navigating platform-specific considerations, and unleashing the full potential
    of Native Image deployment. Whether you’re a seasoned developer seeking to enhance
    application performance or an enthusiast eager to explore the cutting-edge of
    GraalVM technology, this hands-on experience will equip you with the practical
    skills to integrate Native Image compilation seamlessly into your development
    toolkit. Let’s dive in and turn theory into practice as we navigate the creation
    of Native Images, reshaping the landscape of application deployment with GraalVM’s
    revolutionary capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this hands-on practice section, we’ll dive into the exciting world of Native
    Image compilation by working on a whimsically simple yet illustrative Java application.
    The `App` class is designed to print a greeting to the world and, in a super silly
    twist, reverse a given string. As we explore the code, you’ll notice it’s not
    your typical “Hello, World!” example. Instead, it introduces a method called `reverseString`
    that recursively reverses a given string. The application starts by printing a
    greeting and then reverses the string “Native Image is awesome” using the `reverseString`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This playful sample serves as the canvas for our Native Image experiment. Through
    this exercise, we’ll not only witness the creation of a Native Image but also
    gain insights into the optimization process and the resulting efficiency gains.
    So, buckle up as we traverse the creation of a Native Image for this super silly
    yet instructive Java application. Let’s make the whimsical tangible and explore
    the magic of Native Image with GraalVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Setting up GraalVM is a crucial step in our journey toward mastering Native
    Image compilation. To streamline this process and manage different Java versions
    effortlessly, we’ll leverage the SDKMan project. SDKMan simplifies the installation
    and switching between different Java versions, providing a seamless experience
    for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For manual installation, you can refer to the official GraalVM documentation.
    However, to make our lives easier, let’s use SDKMan to install GraalVM. At the
    time of writing, we’re opting for version 21.0.1 with GraalVM support. Execute
    the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command fetches and installs GraalVM version 21.0.1 through SDKMan. Once
    established, you can either set it as the default Java version for your system
    or use it selectively in the current terminal session. If you wish to set it as
    the default, employ the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, with GraalVM seamlessly integrated into your development environment, we’re
    well-prepared to explore Native Image creation. Let’s embark on the next steps
    of this hands-on journey, where we’ll combine the power of GraalVM with the simplicity
    of SDKMan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Native Image is the pivotal next step in our exploration, and the
    process involves a series of commands to compile, package, and, finally, generate
    the native image. Let’s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile the** **App class**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command compiles the `App` class and stores the compiled files in the `build`
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create a** **JAR file**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we package the compiled files into a JAR file named `App.jar` and specify
    the main class as `expert.os.App`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Create the** **Native Image**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Utilizing GraalVM’s `native-image` tool, we generate the native image from the
    JAR file. This step involves AOD compilation, resulting in a standalone executable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Execute the** **Native Image**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the native image created, we can run the executable. Upon execution, the
    console will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You’ve successfully navigated the process of creating a Native
    Image using GraalVM, turning our whimsically simple Java application into a streamlined,
    standalone executable. This hands-on experience sets the stage for further exploration
    of the efficiency gains and optimization possibilities offered by Native Image
    compilation. Let’s revel in the results and continue our journey into the dynamic
    realm of GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude this section on Native Image creation with GraalVM, it’s evident
    that we’ve embarked on a transformative journey in application deployment. By
    seamlessly integrating the power of GraalVM, we’ve transformed a playful Java
    application into a standalone executable, unlocking efficiency gains in startup
    time and resource utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Through meticulous compilation steps and the magic of AOT processing, we’ve
    witnessed the birth of a native image. The output of our executable not only echoes
    the familiar “Hello, World!” greeting but also showcases the whimsical reversal
    of a string – a testament to the versatility of GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: This hands-on experience lays a solid foundation for further exploration. Armed
    with a Native Image, developers can delve into real-world applications, optimizing
    performance and navigating the intricacies of efficient resource utilization.
    The journey doesn’t end here, though; it extends into the dynamic landscapes of
    GraalVM’s capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: As we celebrate the successful execution of our native image, let this be a
    catalyst for your continued exploration into the possibilities and efficiencies
    unlocked by GraalVM. The adventure continues, and the next chapters await, promising
    deeper insights and mastery in the fascinating world of Java application development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the transformative capabilities of GraalVM,
    from its high-performance compiler to the creation of a Native Image. Witnessing
    the efficiency gains achievable through AOT compilation marked a significant milestone,
    showcasing GraalVM’s versatility in reshaping the Java development landscape.
  prefs: []
  type: TYPE_NORMAL
- en: As we conclude, this chapter served as a stepping stone to the broader exploration
    of the JVM ecosystem and alternative JVMs in the next chapter. The diverse options
    beyond conventional JVMs, such as OpenJ9 and Azul Zing, will be unraveled, providing
    insights into their unique features and contributions to the ever-evolving Java
    ecosystem. Join us in the next chapter as we navigate the diverse paths within
    the JVM landscape, informed by the knowledge we’ve gained from our exploration
    of GraalVM.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the primary benefit of GraalVM’s Native Image compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increased memory footprint
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Slower startup time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Platform portability
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited language support
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to compile the **App** class in the GraalVM Native Image
    creation process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**compile -****class App**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**javac -d** **build src/main/java/expert/os/App.java**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**native-image --****compile App**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**graalvm-compile App.java**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the **reverseString** method in the provided Java application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Concatenates strings
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reverses a given string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checks for a palindrome
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Removes whitespace from a string
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How does GraalVM’s Native Image differ from JVM-based applications in terms
    of startup time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Native Image has a slower startup time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both have similar startup times
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Native Image has a faster startup time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JVM-based applications have a faster startup time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is SDKMan used for in the context of GraalVM installation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing Java versions and installations
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating native images
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Debugging Java applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing Docker images
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the **native-image** command do in the GraalVM Native Image creation
    process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiles Java source code
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates a standalone executable
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloads Java dependencies
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Executes the Java application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: C. Platform portability
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. **javac -d** **build src/main/java/expert/os/App.java**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Reverses a given string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C. Native Image has a faster startup time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Managing Java versions and installations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B. Generates a standalone executable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
