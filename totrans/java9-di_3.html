<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection with Spring</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have learned why modularity is so important in writing cleaner and maintainable code. In <a href="part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 1</a>, <em class="calibre13">Why Dependency Injection?</em>, we learned about the <strong class="calibre4">Dependency Inversion Principle</strong> (<strong class="calibre4">DIP</strong>), <strong class="calibre4">IoC</strong> (a design methodology to implement DIP), and various design patterns to implement IoC. <strong class="calibre4">Dependency Injection</strong> (<strong class="calibre4">DI</strong>) is one of the design patterns to achieve IoC.</p>
<p class="calibre2">In the <a href="part0037.html#1394Q0-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 2</a>, <em class="calibre13">Dependency Injection in Java 9</em>, we learned how modular framework and DI are facilitated in Java 9. In this chapter, we will continue our journey to learn DI in Spring—one of the most popular and widely used frameworks to implement enterprise applications.</p>
<p class="calibre2">In this chapter, we will explore the following topics:</p>
<ul class="calibre9">
<li class="calibre10">A brief introduction to Spring framework</li>
<li class="calibre10">Bean management in Spring</li>
<li class="calibre10">How to achieve DI with Spring</li>
<li class="calibre10"><span>Auto wiring:</span> he feature of resolving dependency automatically</li>
<li class="calibre10">Annotation-based DI implementation</li>
<li class="calibre10">DI implementation with Java-based configuration</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">A brief introduction to Spring framework</h1>
                
            
            <article>
                
<p class="calibre2">Spring is a lightweight and open source enterprise framework created way back in 2003. Modularity is the heart of Spring framework. Because of this, Spring can be used from the presentation layer to the persistence layer.</p>
<p class="calibre2">The good thing is, Spring doesn't force you to use Spring in all layers. For example, if you use Spring in the persistence layer, you are free to use any other framework in presentation of the controller layer.</p>
<p class="calibre2">Another good part of Spring is its <strong class="calibre4">Plain Old Java Object</strong> (<span class="calibre11"><strong class="calibre4">POJO</strong>)</span> model-based framework. Unlike other frameworks, Spring doesn't force your class to extend or implement any base class or interface of Spring API; however, Spring does provide a set of classes to use other frameworks, such as ORM frameworks, logging framework, Quartz timers, and other third-party libraries, which will help you to integrate those frameworks with Spring.</p>
<p class="calibre2">More on this: Spring allows you to change the similar framework without changing the code. For example, you can choose different persistence frameworks just by changing the configuration. This is also applicable to third-party API integration with Spring.</p>
<div class="packt_infobox"><span class="calibre18">Spring is a POJO-based framework; a servlet container is suffice to run your application and a fully-fledged application server is not required.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring framework architecture</h1>
                
            
            <article>
                
<p class="calibre2">Spring is a modular framework. This brings great flexibility to choosing the modules that you need instead of bringing all of them together in your code. Spring comprises around 20 modules that are logically grouped into the following layers:</p>
<ul class="calibre9">
<li class="calibre22">Core container layer</li>
<li class="calibre22">Data access/integration layer</li>
<li class="calibre22">Web layer</li>
<li class="calibre22">Test layer</li>
<li class="calibre22">Miscellaneous layer</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Core container layer</h1>
                
            
            <article>
                
<p class="calibre2">Being a main part of the framework, the core container covers the following modules:</p>
<p class="calibre2"><strong class="calibre4">Spring core</strong>:<strong class="calibre4"> </strong>As its name suggests, it provides core functionalities of the framework, including an IoC container and DI mechanism. An <span class="calibre11">IoC container isolates the configuration and dependencies management from the application code.</span></p>
<p class="calibre2"><strong class="calibre4">Spring beans</strong>:<strong class="calibre4"> </strong>This module provides the bean factory to create and manage the life cycle of beans (objects). It is a factory pattern implementation.</p>
<p class="calibre2"><strong class="calibre4">Spring context</strong>: This module is built on top of core and bean modules. Its entry point is to load the configuration and access the objects. On top of bean modules, the context module provides some additional features such as event propagation, creating context on the fly, internationalization, and so on.</p>
<p class="calibre2"><strong class="calibre4">Spring Expression Language</strong> (<strong class="calibre4">SpEL</strong>): This is an expression language to access and manipulate objects on the fly in JSP.<strong class="calibre4"> </strong>It's an extension of <strong class="calibre4">Expression Language</strong> (<span class="calibre11"><strong class="calibre4">EL</strong>) </span>of JSP 2.1 specification. Using SpEL makes the JSP code cleaner, more readable, and maintainable. Major benefits of using SpEL are:</p>
<ul class="calibre9">
<li class="calibre10">The setting of and getting properties' values of objects with ease</li>
<li class="calibre10">It can directly invoke controller methods to get the data</li>
<li class="calibre10">It's used to retrieve objects directly from Spring's application context (IoC container)</li>
<li class="calibre10">It supports various list operations such as projection, selection, iteration, and aggregation</li>
<li class="calibre10">It provides logical and arithmetic operations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data access/integration layer</h1>
                
            
            <article>
                
<p class="calibre2">Spring data access and the integration layer is used for data manipulation and other integration. It covers the following modules:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Transaction</strong>:<strong class="calibre1"> </strong>This module helps maintain transactions in a programmatic and declarative manner. This module supports ORM and JDBC modules.</li>
<li class="calibre10"><strong class="calibre1">Object XML mapping</strong> (<strong class="calibre1">OXM</strong>):<strong class="calibre1"> </strong>This module provides abstraction of Object/XML processing, which can be used by various OXM implementation such as JAXB, XMLBeans, and so on, to integrate with Spring.</li>
<li class="calibre10"><strong class="calibre1">Object Relationship Mapping</strong> (<strong class="calibre1">ORM</strong>):<strong class="calibre1"> </strong>Spring doesn't provide its own ORM framework; instead it facilitates integration with ORM frameworks such as Hibernate, JPA, JDO, and so on, with this module.</li>
<li class="calibre10"><strong class="calibre1">Java Database Connectivity</strong> (<strong class="calibre1">JDBC</strong>):<strong class="calibre1"> </strong>This module provides all low-level boilerplate code to deal with JDBC. You can use it to interact with databases with standard JDBC API.</li>
<li class="calibre10"><strong class="calibre1">Java Messaging Service</strong> (<strong class="calibre1">JMS</strong>):<strong class="calibre1"> </strong>This module supports integration of messaging systems in Spring.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring web layer</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Spring web layer</strong> is used to create web-based applications. It is comprised of the following modules:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Web</strong>:<strong class="calibre1"> </strong>This module provides basic web-related features such as multipart file upload (with the help of Spring custom tags in JSP). It is also responsible for initialization of IoC containers in web context.</li>
<li class="calibre10"><strong class="calibre1">Servlet: </strong>This module provides implementation of Spring MVC (Model View Controller) for web-based applications. It provides clear separation of views (presentation layer) from models (business logic), and controls the flow between them with controllers. </li>
<li class="calibre10"><strong class="calibre1">Portlet: </strong>This module provides MVC implementation for a portlet, and it is mainly used in portal environments.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring test</h1>
                
            
            <article>
                
<p class="calibre2">This provides support for unit and integration testing with various unit-testing frameworks, such as JUnit and TestNg. We will see how to perform unit testing with Spring in upcoming sections in this chapter, so keep reading. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Miscellaneous</h1>
                
            
            <article>
                
<p class="calibre2">Some additional modules are also part of the Spring framework:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Aspect and AOP: </strong>These modules provide a facility to apply common logic (called <em class="calibre28">concerns</em> in AOP terminology) across multiple application layers dynamically </li>
<li class="calibre10"><strong class="calibre1">Instrumentation:</strong> This module provides a class instrumentation facility and class loader implementation</li>
<li class="calibre10"><strong class="calibre1">Messaging: </strong>This module provides support for <strong class="calibre1">Streaming Text-Oriented Messaging Protocol</strong> (<strong class="calibre1">STOMP</strong>) for communicating with various STOMP-based clients</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bean management in Spring container</h1>
                
            
            <article>
                
<p class="calibre2">When any software application is being executed, a set of objects are created and interact with each other to achieve specific business goals.<span class="calibre11"> </span><span class="calibre11">Being a POJO-based programming model, the Spring framework treats all the objects of classes in your application as POJO or beans (in a Spring-friendly way). </span></p>
<p class="calibre2">These objects or beans should be independent in a manner that they can be re-used or changed without causing the ripple effect of changing others. Being loosely coupled this way, it also provides the benefit of doing testing without much worry of any dependency.</p>
<p class="calibre2">Spring provides an IoC container, which is used to automate the process of supplying external dependency to your class. You need to give instruction (in the form of configuration) about your client and dependencies. Spring will manage and resolve all your dependencies at runtime. Moreover, Spring provides a facility to keep availability of your dependencies at various application scopes, such as request, session, application, and so on.</p>
<p class="calibre2">It's essential to understand how Spring manages the life cycle (the process of creating, managing, and destroying) of objects before getting an idea about injecting dependency. In Spring, all these responsibilities are performed by the Spring IoC container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring IoC container</h1>
                
            
            <article>
                
<p class="calibre2">In Spring, the<span class="calibre11"> </span><kbd class="calibre12">org.springframework.beans.factory.BeanFactory</kbd><span class="calibre11"> </span>interface defines the basic IoC container, while the<span class="calibre11"> </span><kbd class="calibre12">org.springframework.context.ApplicationContext</kbd><span class="calibre11"> </span>interface represents an advanced IoC container.<span class="calibre11"> </span><kbd class="calibre12">ApplicationContext</kbd><span class="calibre11"> </span>is a super set of<span class="calibre11"> </span><kbd class="calibre12">BeanFactory</kbd>. It provides some additional enterprise-level functionalities on top of basic IoC features by<span class="calibre11"> </span><kbd class="calibre12">BeanFactory</kbd>. </p>
<p class="calibre2">To cater for different types of applications, Spring provides various implementations of<span class="calibre11"> </span><kbd class="calibre12">ApplicationContext</kbd><span class="calibre11"> </span>out of the box. <span class="calibre11">For standalone applications, you can use the</span> <kbd class="calibre12">FileSystemXmlApplicationContext</kbd> or <kbd class="calibre12">ClassPathXmlApplicationContext</kbd> class. They are both implementations of <kbd class="calibre12">ApplicationConext</kbd>.</p>
<p class="calibre2">While working with Spring, you need to pass one XML file as an entry point for these containers. This file is called the <strong class="calibre4">Spring Application Context file</strong>. When the Spring container starts, it loads this XML file and starts configuring your beans (either with XML-based bean definition in this file, or annotation-based definition in your POJO Java class).</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">FileSystemXmlApplicationContext</kbd>: This container loads the Spring XML file and processes it. You need to give the full path of the XML file.</li>
<li class="calibre10"><kbd class="calibre12">ClassPathXmlApplicationContext</kbd>: This container works similarly to <kbd class="calibre12">FileSystemXmlApplicationContext</kbd><span>; however, it assumes that the Spring XML file is available in <kbd class="calibre12">CLASSPATH</kbd>. You do not need to pass a root-level path for it.</span></li>
<li class="calibre10"><kbd class="calibre12">WebXmlApplicationContext</kbd>: This container is generally used within web applications. </li>
</ul>
<p class="calibre2">Spring's IoC container is responsible for instantiating, configuring, maintaining, and accumulating the beans (objects in your application). You need to provide configuration metadata about the objects you want to assemble with the IoC container. The following diagram depicts a high-level flow of how the IoC container gets this work done:</p>
<div class="mce-root"><img src="../images/00027.jpeg" class="calibre44"/></div>
<p class="calibre2">We provide <strong class="calibre4">Pojo Classes</strong> (or bean definitions) and <strong class="calibre4">Configuration metadata</strong> (set of instructions) as an input. The Spring IoC container will create and manage the objects (or beans) in a way that they produce a ready-to-use system. In short, an IoC container performs all low-level tasks (of managing beans and dependencies) so that you can write business logic in your <span class="calibre11"><span class="calibre11">POJO</span></span> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuration</h1>
                
            
            <article>
                
<p class="calibre2">You need to give instructions to Spring's container about how you want to configure your beans based on your application needs. These instructions should be in the form of configuration metadata, and they should tell the following things to the IoC container:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Instantiation</strong>:<span> </span>How to create the objects from bean definitions.</li>
<li class="calibre10"><strong class="calibre1">Lifespan</strong>:<span> </span>Till what time these objects are available.</li>
<li class="calibre10"><strong class="calibre1">Dependencies</strong>:<span> </span>Do they need someone else?</li>
</ul>
<p class="calibre2">Spring provides a great amount of flexibility, even in defining the configuration metadata. You can supply it to the IoC container in the following three ways:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">XML format:</strong> One or more entries with configuration metadata about beans in Spring's Application Context (XML) file.</li>
<li class="calibre10"><strong class="calibre1">Java annotation:</strong> Put the configuration metadata in the form of an annotation in a Java class.</li>
<li class="calibre10"><strong class="calibre1">pure Java code:<span> </span></strong><span>From version 3.0, Spring started support of defining configuration with Java code. You can define beans outside of your application classes by using Java rather than XML files.</span></li>
</ul>
<p class="calibre2">When the Spring application starts, it will load the application context (XML) file first. This file looks as follows:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- All your bean and its configuration metadata goes here --&gt;<br class="title-page-name"/>    &lt;bean id="..." class="..."&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">This file must be present for both XML-based and annotation-based configuration metadata. In the case of XML-based configuration, you need to define your bean with the <kbd class="calibre12">&lt;bean&gt;</kbd> element under top-level <kbd class="calibre12">&lt;beans&gt;</kbd> elements in this file. One or multiple <kbd class="calibre12">&lt;bean&gt;</kbd> entries can be defined. The configuration metadata will go along with the <kbd class="calibre12">&lt;bean&gt;</kbd> element.</p>
<p class="calibre2">In the preceding bean definition, the <kbd class="calibre12">id</kbd> attribute defines the identity of that bean. The container will use it to point out the specific bean, so it must be unique. While the <kbd class="calibre12">class</kbd> attribute defines the type of bean, you need to give its fully qualified class name here.</p>
<p class="calibre2">Each bean is associated with an actual object through the <kbd class="calibre12">class</kbd> attribute. You can define beans for <span class="calibre11">any type of class, </span>such as your custom service layer classes, DAO layer classes, presentation classes, and so on. Spring's container will use the <kbd class="calibre12">class</kbd> attribute to instantiate the objects, and it applies the configuration metadata associated with the corresponding <kbd class="calibre12">&lt;bean&gt;</kbd> element.</p>
<p class="calibre2">In case of annotation-based configuration, your metadata will be defined to actual Java classes and in this (XML) file; you need to just specify the base package name with the <span class="calibre11"><kbd class="calibre12">&lt;context:component-scan base-package="org.example"/&gt;</kbd></span> element. We will see more on this in an upcoming section, <em class="calibre13">Annotation-based DI</em>, in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Containers in action</h1>
                
            
            <article>
                
<p class="calibre2">To understand the flow of Spring-based applications with ease, we will take an example of standalone application containers: <span class="calibre11"><kbd class="calibre12">ClassPathXmlApplicationContext</kbd>, or <kbd class="calibre12">FileSystemXmlApplicationContext</kbd>. </span>The whole process of dealing with Spring comprises the following three steps:</p>
<ul class="calibre9">
<li class="calibre10">Defining POJOs</li>
<li class="calibre10">Creating application context (XML) files with configuration metadata</li>
<li class="calibre10">Initializing the container</li>
</ul>
<p class="calibre2"><strong class="calibre4">Defining POJOs: </strong>As we have seen in previous sections of this chapter, Spring considers each object in your application as a POJO. So, first you need to define POJOs. We will use simple examples to understand the concepts as per the following snippet:</p>
<pre class="calibre17">package com.packet.spring.contaner.check;<br class="title-page-name"/>public class Car{<br class="title-page-name"/>    public void showType(){<br class="title-page-name"/>        System.out.println("This is patrol car..");<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre2"><strong class="calibre4">Providing application context (XML) files</strong>: Create one XML file and name it <kbd class="calibre12">application-context.xml</kbd>. <span class="calibre11">For the sake of simplicity, we use XML-based configuration metadata.</span> We will see another two ways (annotation-based and Java code-based) of setting configuration metadata in upcoming sections.</p>
<p class="calibre2"><span class="calibre11">Define <kbd class="calibre12">&lt;bean&gt;</kbd> for each of your module classes along with their configuration metadata in the application context file (</span><kbd class="calibre12">application-context.xml</kbd><span class="calibre11">), as per the following snippet:</span></p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- All your bean and its configuration metadata goes here --&gt;<br class="title-page-name"/>    &lt;bean id="myCar" class="com.packet.spring.contaner.check.Car"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">We have defined <kbd class="calibre12">&lt;bean&gt;</kbd> for our POJO <kbd class="calibre12">-Car</kbd> with <kbd class="calibre12">id="myCar"</kbd>. The Spring container uses this ID to get the object of the <kbd class="calibre12">Car</kbd> bean.</p>
<p class="calibre2"><strong class="calibre4">Initializing container: </strong>In case of a web-based application, the container (<kbd class="calibre12">WebXmlApplicationContext</kbd>) will be initialized by a web listener when an application is loaded into the servlet container. In case of a standalone application, you need to initialize the containers (<kbd class="calibre12">ClassPathXmlApplicationContext</kbd> or <kbd class="calibre12">FileSystemXmlApplicationContext</kbd>) with Java code, as per the following snippet:</p>
<pre class="calibre17">ApplicationContext context = new ClassPathXmlApplicationContext("application-context.xml");</pre>
<p class="calibre2"><kbd class="calibre12">ClassPathXmlApplicationContext</kbd> and <kbd class="calibre12">FileSystemXmlApplicationContext</kbd> take resource String as an input parameter in the constructor. This resource string represents <span class="calibre11">the application context (XML) file from the classpath (in the preceding snippet), or from the local filesystem (in case of the</span> <kbd class="calibre12">FileSystemXmlApplicationContext</kbd> <span class="calibre11">container).</span></p>
<div class="packt_infobox">There are other overloaded constructors of <kbd class="calibre37">ClassPathXmlApplicationContext</kbd> and <kbd class="calibre37">FileSystemXmlApplicationContext</kbd> containers, such as a no-argument constructor and string array argument constructor, which is used to load more than one application context (XML) file.</div>
<p class="calibre2">Soon after the Spring container is loaded into memory, it processes the application context (XML) file and creates the objects for corresponding <kbd class="calibre12">&lt;bean&gt;</kbd> definition. You can get the instance of your bean with the help of a container, as per the following snippet:</p>
<pre class="calibre17">// create and configure beans<br class="title-page-name"/>ApplicationContext context = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/><br class="title-page-name"/>// retrieve configured instance<br class="title-page-name"/>Car carObj = context.getBean("myCar");<br class="title-page-name"/><br class="title-page-name"/>// use configured instance<br class="title-page-name"/>carObj.showType(); </pre>
<p class="calibre2">When you call the <kbd class="calibre12">getBean</kbd> method, the container internally calls its constructor to create the object, which is equivalent to calling the <kbd class="calibre12">new()</kbd> operator. This is how Spring's IoC container creates, maintains, and assembles the objects corresponding to each <kbd class="calibre12">&lt;bean&gt;</kbd> definition in Spring's application context(XML) file.</p>
<div class="packt_infobox">By default, Spring creates the object of each <kbd class="calibre37">&lt;bean&gt;</kbd> element with a Singleton fashion. It means a container creates and holds just one object of each <kbd class="calibre37">&lt;bean&gt;</kbd> unless you explicitly tell it not to. When you ask a container for the object of <kbd class="calibre37">&lt;bean&gt;</kbd> with the <kbd class="calibre37">getBean()</kbd> method, it gives the reference of the same object every time after creating it the first time.</div>
<p class="calibre2">When a container creates the object corresponding to the <kbd class="calibre12">&lt;bean&gt;</kbd> definition, you do not need to implement any specific interface, or extend any class or code in a specific way. Simply specifying the <kbd class="calibre12">class</kbd> attribute of <kbd class="calibre12">&lt;bean&gt;</kbd> is suffice. Spring is capable enough to create an object of any type. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection (DI) in Spring</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">After getting an idea of how Spring manages bean life cycle, next we will learn how Spring provides and maintains the dependencies in your application.</span></p>
<p class="calibre2"><strong class="calibre4">DI</strong> is a process of providing the dependent objects to other objects that need it. In Spring, the container supplies the dependencies. The flow of creating and managing the dependencies is inverted from client to container. That is the reason we call it an <strong class="calibre4">IoC container</strong>.</p>
<p class="calibre2"><span class="calibre11">A Spring IoC container </span><span class="calibre11">uses the Dependency Injection (DI) mechanism to provide the dependency at runtime. </span>In <a href="part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16" class="calibre8">Chapter 1</a>,  <em class="calibre13">Why Dependency Injection?,</em> we saw various DI types such as constructor, setter method, and interface-based. Let's see how we can implement the constructor and setter-based DI through Spring's IoC container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor-based DI</h1>
                
            
            <article>
                
<p class="calibre2">Constructor-based dependency is generally used where you want to pass mandatory dependencies before the object is instantiated. It's provided by a container through a constructor with different arguments, and each represents dependency.</p>
<p class="calibre2">When a container starts, it checks wheather any constructor-based DI is defined for <kbd class="calibre12">&lt;bean&gt;</kbd>. It will create the dependency objects first, and then pass them to the current object's constructor. We will understand this by taking the classic example of using logging. It is good practice to put the log statement at various places in code to trace the flow of execution.</p>
<p class="calibre2">Let's say you have an <kbd class="calibre12">EmployeeService</kbd> class where you need to put a log in each of its methods. To achieve separation of concern, you put the log functionality in a separated class called <kbd class="calibre12">Logger</kbd>. To make sure the <kbd class="calibre12">EmployeeService</kbd> and <kbd class="calibre12">Logger</kbd> are independent and loosely coupled, you need to inject the <kbd class="calibre12">Logger</kbd> object into the <kbd class="calibre12">EmployeeService</kbd> object. Let's see how to achieve this by constructor-based injection:</p>
<pre class="calibre17">public class EmployeeService {<br class="title-page-name"/>     private Logger log;<br class="title-page-name"/>     //Constructor<br class="title-page-name"/>      public EmployeeService(Logger log) {<br class="title-page-name"/>          this.log = log;<br class="title-page-name"/>      }<br class="title-page-name"/>      <br class="title-page-name"/>      //Service method.<br class="title-page-name"/>      public void showEmployeeName() {<br class="title-page-name"/>        log.info("showEmployeeName method is called ....");<br class="title-page-name"/>        log.debug("This is Debuggin point");<br class="title-page-name"/>        log.error("Some Exception occured here ...");<br class="title-page-name"/>      }<br class="title-page-name"/><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Logger {<br class="title-page-name"/>  public void info(String msg){<br class="title-page-name"/>       System.out.println("Logger INFO: "+msg);<br class="title-page-name"/>    }<br class="title-page-name"/>  public void debug(String msg){<br class="title-page-name"/>      System.out.println("Logger DEBUG: "+msg);<br class="title-page-name"/>    }<br class="title-page-name"/>  public void error(String msg){<br class="title-page-name"/>      System.out.println("Logger ERROR: "+msg);<br class="title-page-name"/>    }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>public class DIWithConstructorCheck {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    <br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    EmployeeService employeeService = (EmployeeService) springContext.getBean("employeeService");<br class="title-page-name"/>    employeeService.showEmployeeName();<br class="title-page-name"/><br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">As per the preceding code, when these objects are configured with Spring, the <kbd class="calibre12">EmployeeService</kbd> object expects the Spring container to inject the object of <kbd class="calibre12">Logger</kbd> through the constructor. To achieve this, you need to set the configuration metadata as per the following snippet:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;!-- All your bean and its configuration metadata goes here --&gt;<br class="title-page-name"/>    &lt;bean id="employeeService" class="com.packet.spring.constructor.di.EmployeeService"&gt;<br class="title-page-name"/>        &lt;constructor-arg ref="logger"/&gt; <br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;bean id="logger" class="com.packet.spring.constructor.di.Logger"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">In the preceding configuration, the <kbd class="calibre12">Logger</kbd> bean is injected into the <kbd class="calibre12">employee</kbd> bean through the <kbd class="calibre12">constructor-arg</kbd> element. It has a <kbd class="calibre12">ref</kbd> attribute, which is used to point to other beans with a matching <kbd class="calibre12">id</kbd> value.  This configuration instructs Spring to pass the object of <kbd class="calibre12">Logger</kbd> into the constructor of the <kbd class="calibre12">EmployeeService</kbd> bean.</p>
<div class="packt_infobox">You can put the <kbd class="calibre37">&lt;bean&gt;</kbd> definition in any order here. Spring will create the objects of <kbd class="calibre37">&lt;bean&gt;</kbd> based on need, and not as per the order they are defined here.</div>
<p class="calibre2"><span class="calibre11">For more than one constructor argument, you can pass additional <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> elements. The order is not important as far as the object type (class attribute of referred bean) is not ambiguous. </span></p>
<p class="calibre2">Spring also supports DI with primitive constructor arguments. Spring provides the facility to pass the primitive values in a constructor from an application context (XML) file. Let's say you want to create an object of the <kbd class="calibre12">Camera</kbd> class with a default value, as per the following snippet:</p>
<pre class="calibre17">public class Camera {<br class="title-page-name"/>  private int resolution;<br class="title-page-name"/>  private String mode;<br class="title-page-name"/>  private boolean smileShot;<br class="title-page-name"/>  <br class="title-page-name"/>  //Constructor.<br class="title-page-name"/>  public Camera(int resolution, String mode, boolean smileShot) {<br class="title-page-name"/>    this.resolution = resolution;<br class="title-page-name"/>    this.mode = mode;<br class="title-page-name"/>    this.smileShot = smileShot;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  //Public method<br class="title-page-name"/>  public void showSettings() {<br class="title-page-name"/>    System.out.println("Resolution:"+resolution+"px mode:"+mode+" smileShot:"+smileShot);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The <kbd class="calibre12">Camera</kbd> class has three properties: <kbd class="calibre12">resolution</kbd>, <kbd class="calibre12">mode</kbd>, and <kbd class="calibre12">smileShot</kbd>. Its constructor takes three primitive arguments to create a camera object with default values. You need to give configuration metadata in the following way, so that Spring can create instances of the <kbd class="calibre12">Camera</kbd> object with default primitive values:</p>
<pre class="calibre17">&lt;bean id="camera" class="com.packet.spring.constructor.di.Camera"&gt;<br class="title-page-name"/>      &lt;constructor-arg type="int" value="12" /&gt;<br class="title-page-name"/>      &lt;constructor-arg type="java.lang.String" value="normal" /&gt;<br class="title-page-name"/>      &lt;constructor-arg type="boolean" value="false" /&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">We pass three <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> elements under <kbd class="calibre12">&lt;bean&gt;</kbd>, corresponding to each constructor argument. Since these are primitive, Spring has no idea about its type while passing the value. So, we need to explicitly pass the <kbd class="calibre12">type</kbd> attribute, which defines the type of primitive constructor argument.</p>
<p class="calibre2">In case of primitive also, there is no fixed order to pass the value of the constructor argument, as long as the type is not ambiguous. In previous cases, all three types are different, so Spring intelligently picks up the right constructor argument, no matter which order you pass them.</p>
<p class="calibre2">Now we are adding one more attribute to the <kbd class="calibre12">Camera</kbd> class called <kbd class="calibre12">flash</kbd>, as per the following snippet:</p>
<pre class="calibre17">//Constructor.<br class="title-page-name"/>  public Camera(int resolution, String mode, boolean smileShot, boolean flash) {<br class="title-page-name"/>    this.resolution = resolution;<br class="title-page-name"/>    this.mode = mode;<br class="title-page-name"/>    this.smileShot = smileShot;<br class="title-page-name"/>    this.flash = flash;<br class="title-page-name"/>  }</pre>
<p class="calibre2">In this case, the constructor arguments <kbd class="calibre12">smileShot</kbd> and <kbd class="calibre12">flash</kbd> are of the same type (Boolean), and you pass the constructor argument value from XML configuration as per the following snippet:</p>
<pre class="calibre17">      &lt;constructor-arg type="java.lang.String" value="normal"/&gt;<br class="title-page-name"/>      &lt;constructor-arg type="boolean" value="true" /&gt;<br class="title-page-name"/>      &lt;constructor-arg type="int" value="12" /&gt;<br class="title-page-name"/>      &lt;constructor-arg type="boolean" value="false" /&gt; </pre>
<p class="calibre2">In the preceding scenario, Spring will pick up the following:</p>
<ul class="calibre9">
<li class="calibre10">int value for resolution</li>
<li class="calibre10">String value for mode</li>
<li class="calibre10">First Boolean value <span>(true) </span>in sequence for first Boolean argument—<kbd class="calibre12">smileShot</kbd></li>
<li class="calibre10">Second Boolean value <span>(false)</span> in sequence for second Boolean argument—flash</li>
</ul>
<p class="calibre2">In short, for similar types in constructor arguments, Spring will pick the first value that comes in the sequence. So sequence does matter in this case. </p>
<p class="calibre2">This may lead to logical errors, as you are passing wrong values to the right argument. To avoid such accidental mistakes, Spring provides the facility to define a zero-based index in the <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> element, as per the following snippet:</p>
<pre class="calibre17">      &lt;constructor-arg type="java.lang.String" value="normal"<br class="title-page-name"/>      index="1"/&gt;<br class="title-page-name"/>      &lt;constructor-arg type="boolean" value="true" index="3"/&gt;<br class="title-page-name"/>      &lt;constructor-arg type="int" value="12" index="0"/&gt;<br class="title-page-name"/>      &lt;constructor-arg type="boolean" value="false" index="2"/&gt;</pre>
<p class="calibre2">This is more readable and less error prone. Now Spring will pick up the last value (with <kbd class="calibre12">index=2</kbd>) for <kbd class="calibre12">smileShot</kbd>, and the second value (with <kbd class="calibre12">index=3</kbd>) for <kbd class="calibre12">flash</kbd> arguments. Index attributes resolves the ambiguity of two constructor arguments having the same type.</p>
<p class="calibre2">If the <kbd class="calibre12">type</kbd> you defined in <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> is not compatible with the actual type of constructor argument in that index, then Spring will raise an error. So just make sure about this while using index attribute.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setter-based DI</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Setter-based DI</strong> is generally used for optional dependencies. In case of setter-based DI, the container first creates an instance of your bean, either by calling a no-argument constructor or static <kbd class="calibre12">factory</kbd> method. It then passes the said dependencies through each setter method. Dependencies injected through the setter method can be re-injected or changed at a later stage of application.</p>
<p class="calibre2">We will understand setter-based DI with the following code base:</p>
<pre class="calibre17">public class DocumentBase {<br class="title-page-name"/>  private DocFinder docFinder;<br class="title-page-name"/> //Setter method to inject dependency. <br class="title-page-name"/> public void setDocFinder(DocFinder docFinder) {<br class="title-page-name"/>    this.docFinder = docFinder;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void performSearch() {<br class="title-page-name"/>    this.docFinder.doFind();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class DocFinder {<br class="title-page-name"/>  public void doFind() {<br class="title-page-name"/>    System.out.println(" Finding in Document Base ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class DIWithSetterCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    DocumentBase docBase = (DocumentBase) springContext.getBean("docBase");<br class="title-page-name"/>    docBase.performSearch();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The  <kbd class="calibre12">DocumentBase</kbd> class depends on <kbd class="calibre12">DocFinder</kbd>, and we are passing it through the <kbd class="calibre12">setter</kbd> method. You need to define the configuration metadata for Spring, as per the following snippet:</p>
<pre class="calibre17">    &lt;bean id="docBase" class="com.packet.spring.setter.di.DocumentBase"&gt;<br class="title-page-name"/>        &lt;property name="docFinder" ref="docFinder" /&gt; <br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;bean id="docFinder" class="com.packet.spring.setter.di.DocFinder"&gt;<br class="title-page-name"/>    &lt;/bean&gt;</pre>
<p class="calibre2">Setter-based DI can be defined through the <kbd class="calibre12">&lt;property&gt;</kbd> element under <kbd class="calibre12">&lt;bean&gt;</kbd>. The <kbd class="calibre12">name</kbd> attribute denotes the name of the <kbd class="calibre12">setter</kbd> name. In our case, the <kbd class="calibre12">name</kbd> attribute of the <kbd class="calibre12">property</kbd> element is <kbd class="calibre12">docFinder</kbd>, so Spring will call the <kbd class="calibre12">setDocFinder</kbd> method to inject the dependency. The pattern to find the <kbd class="calibre12">setter</kbd> method is to prepend <kbd class="calibre12">set</kbd> and make the first character capital.</p>
<p class="calibre2">The <kbd class="calibre12">name</kbd> attribute of the <kbd class="calibre12">&lt;property&gt;</kbd> element is case-sensitive. So, if you set the name to <kbd class="calibre12">docfinder</kbd>, Spring will try to call the <kbd class="calibre12">setDocfinder</kbd> method and will show an error.</p>
<p class="calibre2">Just like constructor DI, Setter DI also supports supplying the value for primitives, as per the following snippet:</p>
<pre class="calibre17">&lt;bean id="docBase" class="com.packet.spring.setter.di.DocumentBase"&gt;<br class="title-page-name"/>        &lt;property name="buildNo" value="1.2.6" /&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">Since the <kbd class="calibre12">setter</kbd> method takes only one argument, there is no scope of argument ambiguity. Whatever value you are passing here, Spring will convert it to an actual primitive type of the <kbd class="calibre12">setter</kbd> method parameter. If it's not compatible, it will show an error. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spring DI with the factory method</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have seen that the Spring container takes care of creating the instances of <kbd class="calibre12">bean</kbd>. In some scenarios, you need to take control of creating an instance of <kbd class="calibre12">bean</kbd> with custom code. Spring supports this feature with the help of the <kbd class="calibre12">factory</kbd> method.</p>
<p class="calibre2">You can write your custom logic to create the instance in the <kbd class="calibre12">factory</kbd> method, and just instruct Spring to use it. When Spring encounters such instructions, it will call the <kbd class="calibre12">factory</kbd> method to create the instance. So, the <kbd class="calibre12">factory</kbd> method is kind of a callback function. </p>
<p class="calibre2">There are two flavors of the <kbd class="calibre12">factory</kbd> method: static, and instance (non-static).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Static factory method </h1>
                
            
            <article>
                
<p class="calibre2">When you want to encapsulate the logic of creating the instance in a static way to custom methods, you can use a static <kbd class="calibre12">factory</kbd> method. In this case, Spring will use the <kbd class="calibre12">Class</kbd> attribute of <kbd class="calibre12">&lt;bean&gt;</kbd> to call the <kbd class="calibre12">factory</kbd> method and generate instances. Let's understand this by looking at the following example:</p>
<pre class="calibre17">public class SearchableFactory {<br class="title-page-name"/>  private static SearchableFactory searchableFactory;<br class="title-page-name"/>  <br class="title-page-name"/>  //Static factory method to get instance of Searchable Factory.<br class="title-page-name"/>  public static SearchableFactory getSearchableFactory() {<br class="title-page-name"/>    if(searchableFactory == null) {<br class="title-page-name"/>      searchableFactory = new SearchableFactory();<br class="title-page-name"/>    }<br class="title-page-name"/>    System.out.println("Factory method is used: getSearchableFactory() ");<br class="title-page-name"/>    return searchableFactory;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>public class DIWithFactoryCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    SearchableFactory searchableFactory = (SearchableFactory)springContext.getBean("searchableFactory");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous code snippet, the <kbd class="calibre12">SearchableFactory</kbd> class has one static method, <kbd class="calibre12">getSearchableFactory</kbd>, which returns the object of the same class. This behaves as a <kbd class="calibre12">factory</kbd> method. The preceding code can be configured in Spring, as per the following snippet:</p>
<pre class="calibre17">&lt;bean id="searchableFactory"    class="com.packet.spring.factory.di.SearchableFactory" factory-method="getSearchableFactory"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">In the previous configuration, Spring will always use the <kbd class="calibre12">getSearchableFactory</kbd> method to create the instance of bean irrespective of any scope. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Instance (non-static) factory method</h1>
                
            
            <article>
                
<p class="calibre2">You can use an instance <kbd class="calibre12">factory</kbd> method to shift the control of creating the instance from a container to your custom object. The only difference between an instance <kbd class="calibre12">factory</kbd> method and a static <kbd class="calibre12">factory</kbd> method is that the former can only be invoked with an instance of bean. Let's understand this by taking the following example:</p>
<pre class="calibre17">public class Employee {<br class="title-page-name"/>  private String type;<br class="title-page-name"/>  public Employee(String type) {<br class="title-page-name"/>    this.type = type;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void showType() {<br class="title-page-name"/>    System.out.println("Type is :"+type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Developer extends Employee {<br class="title-page-name"/>  public Developer(String type) {<br class="title-page-name"/>    super(type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Manager extends Employee {<br class="title-page-name"/>  public Manager(String type) {<br class="title-page-name"/>    super(type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Factory Bean who has Factory method.<br class="title-page-name"/>public class EmployeeService {<br class="title-page-name"/>  <br class="title-page-name"/>  //Instance Factory method<br class="title-page-name"/>  public Employee getEmployee(String type) {<br class="title-page-name"/>    Employee employee = null;<br class="title-page-name"/>    if("developer".equalsIgnoreCase(type)) {<br class="title-page-name"/>      employee = new Developer("developer");<br class="title-page-name"/>    }else if("manager".equalsIgnoreCase(type)) {<br class="title-page-name"/>      employee = new Manager("manager");<br class="title-page-name"/>    }<br class="title-page-name"/>    return employee;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class SalaryService {<br class="title-page-name"/>  private Employee employee;<br class="title-page-name"/>  public void setEmployee(Employee employee) {<br class="title-page-name"/>    this.employee = employee;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void showEmployeeType() {<br class="title-page-name"/>    if(this.employee !=null) {<br class="title-page-name"/>      this.employee.showType();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class DIWithInstanceFactoryCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    SalaryService salaryService = (SalaryService)springContext.getBean("salaryService");<br class="title-page-name"/>    salaryService.showEmployeeType();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre12">Employee</kbd> is a generic class that has a <kbd class="calibre12">type</kbd> instance variable. <kbd class="calibre12">Developer</kbd> and <kbd class="calibre12">Manager</kbd> extend <kbd class="calibre12">Employee</kbd>, and they pass the <kbd class="calibre12">type</kbd> in the constructor. <kbd class="calibre12">EmployeeService</kbd> is a class that has a <kbd class="calibre12">factory</kbd> method: <kbd class="calibre12">getEmployee</kbd>. This method takes a String argument, and generates either <kbd class="calibre12">Developer</kbd> or <kbd class="calibre12">Manager</kbd> objects. </p>
<p class="calibre2">These objects can be configured in Spring as per the following snippet:</p>
<pre class="calibre17">&lt;bean id="employeeService"               class="com.packet.spring.factory.di.EmployeeService"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="developerBean" factory-method="getEmployee" factory-bean="employeeService"&gt;<br class="title-page-name"/>      &lt;constructor-arg value="developer"&gt;&lt;/constructor-arg&gt; <br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="salaryService" class="com.packet.spring.factory.di.SalaryService"&gt;<br class="title-page-name"/>      &lt;property name="employee" ref="developerBean"/&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">The <kbd class="calibre12">employeeService</kbd> is defined with normal bean definition. The <kbd class="calibre12">developerBean</kbd> is defined with <kbd class="calibre12">factory-method</kbd> and <kbd class="calibre12">factory-bean</kbd> attributes. <span class="calibre11">The <kbd class="calibre12">factory-bean</kbd> attribute represents the reference of bean in which the <kbd class="calibre12">factory</kbd> method is defined. </span></p>
<p class="calibre2">In previous cases, <kbd class="calibre12">developerBean</kbd> is created by calling the <kbd class="calibre12">factory</kbd> method <kbd class="calibre12">getEmployee</kbd> on bean <kbd class="calibre12">employeeService</kbd>. The argument passed through <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> to <kbd class="calibre12">developerBean</kbd> actually goes to the <kbd class="calibre12">factory</kbd> method. You will also notice that we haven't defined a <kbd class="calibre12">class</kbd> attribute for <kbd class="calibre12">developerBean</kbd>, because when <kbd class="calibre12">factory-bean</kbd> is defined for bean, Spring will consider the class as a returned type from the <kbd class="calibre12">factory</kbd> method (defined in factory bean), rather than considering the bean's class. </p>
<p class="calibre2">This way, <kbd class="calibre12">developerBean</kbd> is a kind of virtual bean that is generated by the <kbd class="calibre12">factory</kbd> method of another class. Lastly, we have created <kbd class="calibre12">salaryService</kbd>, and passed the <kbd class="calibre12">developerBean</kbd> as a setter injection. When you execute this code, it shows the type as a <kbd class="calibre12">developer</kbd>. This is how we can use the instance <kbd class="calibre12">factory</kbd> method.</p>
<div class="packt_infobox">The type of class returned by the<kbd class="calibre37">factory</kbd> method need not be the same as the class in which the <kbd class="calibre37">factory</kbd> method is defined. If you have used a different class, you need to cast with the class that is being returned from the <kbd class="calibre37">factory</kbd> method, while calling the <kbd class="calibre37">getBean()</kbd> method of <kbd class="calibre37">ApplicationContext</kbd>.</div>
<p class="calibre2"><span class="calibre11">By default, Spring uses</span> <kbd class="calibre12">singleton</kbd><span class="calibre11"> scope for each of the beans. It means Spring will create just one object of each bean. For other scopes such as</span> <kbd class="calibre12">prototype</kbd><span class="calibre11">, Spring creates a new instance every time you make a call to the</span> <kbd class="calibre12">getBean</kbd> <span class="calibre11">method. But if you specify which <kbd class="calibre12">factory</kbd> method, Spring will call the <kbd class="calibre12">factory</kbd> method to get the object all the time.</span></p>
<p class="calibre2">In our case, we are using the <kbd class="calibre12">factory</kbd> method to make sure Spring creates just one object of our bean, irrespective of the bean's scope. This is just one example. This way you can use the <kbd class="calibre12">factory</kbd> method with any custom logic while creating the instance. It basically encapsulates the object instantiation process. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Auto-wiring in Spring</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have learned how to <span class="calibre11">define configuration metadata along with</span> <kbd class="calibre12">&lt;bean&gt;</kbd> <span class="calibre11">to</span> set the dependencies. How good would it be if everything was settled down without giving any instruction in the form of configuration? That is a cool idea, and the good news is that Spring supports it.</p>
<p class="calibre2">This feature is called autowire (in Spring terminology), which automates the process of binding relations between beans. This greatly reduces the effort of providing configuration metadata at either properties or constructor arguments.</p>
<p class="calibre2">The autowire feature can be enabled in XML-based configuration metadata by defining the <kbd class="calibre12">autowire</kbd> attribute of the <kbd class="calibre12">&lt;bean&gt;</kbd> element. It can be specified with the following three modes: name, type, and constructor. By default, autowire is set off for all beans.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Auto-wiring by name</h1>
                
            
            <article>
                
<p class="calibre2">As its name suggests, in this mode, Spring does the wiring of beans by name. Spring looks for beans with the same name (ID) as the property that needs to be autowired. In other words, dependencies are auto-bound with the bean that has the same name (value of ID attribute) as the property name. Let's understand this by looking at the following example:</p>
<pre class="calibre17">public class UserService {<br class="title-page-name"/>  public void getUserDetail() {<br class="title-page-name"/>    System.out.println(" This is user detail ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class AccountService {<br class="title-page-name"/>  private UserService userService=null;<br class="title-page-name"/>  <br class="title-page-name"/>  public void setUserService(UserService userService) {<br class="title-page-name"/>    this.userService = userService;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  //Setter DI method.<br class="title-page-name"/>  public void processUserAccount() {<br class="title-page-name"/>    if(userService !=null) {<br class="title-page-name"/>      userService.getUserDetail();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class DIAutoWireCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    AccountService accountService = (AccountService)springContext.getBean("accountService");<br class="title-page-name"/>    accountService.processUserAccount();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the preceding code, <kbd class="calibre12">AccountService</kbd> depends on <kbd class="calibre12">UserService</kbd>. <kbd class="calibre12">AccountService</kbd> has a setter method through which Spring will inject the dependency of <kbd class="calibre12">UserService</kbd>. The preceding scenario can be configured in Spring as follows:</p>
<pre class="calibre17">&lt;bean id="userService" class="com.packet.spring.autowire.di.UserService"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="accountService" class="com.packet.spring.autowire.di.AccountService" autowire="byName"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">In typical setter-based DI configuration, we would have used the <kbd class="calibre12">&lt;property&gt;</kbd> element for the <kbd class="calibre12">accountService</kbd> bean, and defined the <kbd class="calibre12">ref</kbd> attribute to refer to the <kbd class="calibre12">userService</kbd> bean. But in previous cases, we haven't used the property element, and <kbd class="calibre12">userService</kbd> is still injected into <kbd class="calibre12">accountService</kbd> by Spring.</p>
<p class="calibre2">This magic is done by the attribute <kbd class="calibre12">autowire="byName"</kbd>. How does this work? Well, when Spring reads this attribute in <kbd class="calibre12">&lt;bean&gt;</kbd>, it will try to search the bean with the same <kbd class="calibre12">name(id)</kbd> as the property (setter method) name. If found, it will inject that bean to the current bean's setter method on which the <kbd class="calibre12">autowire</kbd> attribute is defined. </p>
<p class="calibre2">In our case, <kbd class="calibre12">autowire="byName"</kbd> is set on the <kbd class="calibre12">accountService</kbd> bean, which has setter method <kbd class="calibre12">setUserService</kbd> to set the instance of <kbd class="calibre12">userService</kbd>. Spring will try to find any bean with the ID <kbd class="calibre12">userService</kbd> and, if found, it will inject the instance of the <kbd class="calibre12">userService</kbd> bean through this setter method.</p>
<p class="calibre2">In this case, the autowire happens with the name of the setter method instead of the property name. For example, if you set the setter method name as <kbd class="calibre12">setUserService1</kbd>, Spring will try to find the bean with <kbd class="calibre12">id=userService1</kbd>, irrespective of the actual property name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Auto-wiring by type</h1>
                
            
            <article>
                
<p class="calibre2">In this mode, Spring does binding of beans based on type. Here, the type means the <kbd class="calibre12">class</kbd> attribute of <kbd class="calibre12">&lt;bean&gt;</kbd>. <span class="calibre11">Spring looks for the bean with the same type as the property that needs to be autowired. In other words, dependencies are auto bound with the bean having the same type.</span></p>
<p class="calibre2"><span class="calibre11">If more than one bean of the same type exists, Spring shows exception. If Spring doesn't find the bean with a matching type, nothing happens; simply, the property will not be set. Let's understand this by looking at the following example:</span></p>
<pre class="calibre17">public class EmailService {<br class="title-page-name"/>  public void sendEmail() {<br class="title-page-name"/>    System.out.println(" Sending Email ..!! ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  private EmailService emailService = null;<br class="title-page-name"/>  //Setter DI method.<br class="title-page-name"/>  public void setEmailService(EmailService emailService) {<br class="title-page-name"/>    this.emailService = emailService;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>public void initiateSeparation() {<br class="title-page-name"/>    //Business logic for sepration process<br class="title-page-name"/>    <br class="title-page-name"/>    if(emailService !=null) {<br class="title-page-name"/>      emailService.sendEmail();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">In the preceding code, <kbd class="calibre12">HRService</kbd> depends on <kbd class="calibre12">EmailService</kbd>. <kbd class="calibre12">HRService</kbd> has a setter method through which Spring will inject the dependency of <kbd class="calibre12">EmailService</kbd>. Previous scenarios can be configured in Spring as follows:</span></p>
<pre class="calibre17">&lt;!-- Example of autowire byType --&gt;<br class="title-page-name"/>&lt;bean id="emailService" class="com.packet.spring.autowire.di.EmailService"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="hrService" class="com.packet.spring.autowire.di.HRService" autowire="byType"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">When Spring reads the <kbd class="calibre12">autowire="byType"</kbd> attribute in the <kbd class="calibre12">hrService</kbd> bean, it will try to search the bean with the same type as the property of <kbd class="calibre12">hrService</kbd>. Spring expects just one such bean. If found, it will inject that bean. </p>
<div class="packt_infobox">Since this is autowire by type, Spring relies on the type of property to inject the dependency, and not on the name of the setter method. Spring only expects that the method should take the reference of dependency as a parameter to set it with the property of the bean.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Auto-wiring by constructor</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">This mode is identical to autowire by type. The only difference is, in this case, the autowire happens to constructor arguments rather than properties of the bean. When Spring encounters autowire with constructor mode, it will try to search and bind the bean's constructor argument with exactly one bean of the same type. Let's understand this by looking at the following example:</span></p>
<pre class="calibre17">public class StudentService {<br class="title-page-name"/>  public void getStudentDetail() {<br class="title-page-name"/>    System.out.println(" This is Student details.. ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ExamService {<br class="title-page-name"/>  private StudentService studentService;<br class="title-page-name"/>  private String examServiceType;<br class="title-page-name"/>  <br class="title-page-name"/>  public ExamService(StudentService studentService, String examServiceType) {<br class="title-page-name"/>    this.studentService=studentService;<br class="title-page-name"/>    this.examServiceType = examServiceType;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public void getExamDetails() {<br class="title-page-name"/>    if(studentService !=null) {<br class="title-page-name"/>      //Business logic to get exam details.<br class="title-page-name"/>      <br class="title-page-name"/>      studentService.getStudentDetail();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">In the preceding code, <kbd class="calibre12">ExamService</kbd>  depends on <kbd class="calibre12">StudentService</kbd>. <kbd class="calibre12">ExamService</kbd> has a constructor through which Spring will inject the dependency of <kbd class="calibre12">StudentService</kbd>. The previous scenario can be configured in Spring as follows:</span></p>
<pre class="calibre17"> &lt;!-- Example of autowire by Constructor --&gt;<br class="title-page-name"/>&lt;bean id="studentService" class="com.packet.spring.autowire.di.StudentService"&gt;<br class="title-page-name"/> &lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="examService" class="com.packet.spring.autowire.di.ExamService" autowire="constructor"&gt;<br class="title-page-name"/>     &lt;constructor-arg value="Science Exam"/&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">When Spring scans the attribute <kbd class="calibre12">autowire="constructor"</kbd> for the bean <kbd class="calibre12">examService</kbd>, it will search and inject any bean with the same type as <kbd class="calibre12">examService</kbd>'s constructor. In our case, we are using one constructor argument of the <kbd class="calibre12">StudentService</kbd> class, so Spring will inject the instance of the <kbd class="calibre12">studentService</kbd> bean, which we defined in the previous XML file.</p>
<p class="calibre2">Similar to autowire by type mode, if there is more than one bean with a matching type to the constructor argument type, Spring will throw an error. Along with <kbd class="calibre12">autowire = constructor</kbd> mode, you can still pass any additional arguments through the <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> element shown in the previous configuration. If we hadn't used autowire here, we would have passed the <kbd class="calibre12">studentService</kbd> with the <kbd class="calibre12">&lt;constructor-arg&gt;</kbd> element. </p>
<p class="calibre2">In spite of the preceding advantages, the autowire feature should be used with a little caution. Following are the points you need to take into consideration while using it:</p>
<ul class="calibre9">
<li class="calibre10">Autowire can't be applied to primitive types.</li>
<li class="calibre10">In case there are multiple beans of the same type, it will cause errors while using autowire by type and constructor, though there are options to avoid this.</li>
<li class="calibre10">Since autowiring happens silently by Spring, sometimes it's difficult to find the logical issue when there are plenty of beans defined in the Spring application context files. </li>
<li class="calibre10">People still prefer explicit mapping rather than autowiring, because explicit mapping is somewhat more accurate, clear, and more readable as well.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Annotation-based DI</h1>
                
            
            <article>
                
<p class="calibre2">From the beginning, the most common way of defining configuration in Spring has been XML-based. But when the complexity grew and navigation of beans became exhausted in the jungle of angle brackets, there was a demand for a second option to define configuration. As a result, Spring started support for annotation.</p>
<p class="calibre2"><span class="calibre11">A</span><span class="calibre11">nnotation-based configuration is a</span>n alternate of XML-based configuration, and i<span class="calibre11">t </span><span class="calibre11">relies on bytecode metadata.</span> Spring started support for annotation with version 2.5. <span class="calibre11">With annotation, the configuration moves from an XML to component class. Annotation can be declared on classes, methods, or at field level.</span></p>
<p class="calibre2">Let's understand the process of defining configuration through annotation. We will first understand this process through XML configuration, and then will gradually move to annotation-based configuration in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DI through XML configuration</h1>
                
            
            <article>
                
<p class="calibre2">It's always good to start with the most common option. So first, we will take an example of pure XML-based configuration, as per the following snippet:</p>
<pre class="calibre17">public class Professor {<br class="title-page-name"/>  private String name;<br class="title-page-name"/>  //Constructor<br class="title-page-name"/>  public Professor() {<br class="title-page-name"/>    System.out.println("Object of Professor is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return name;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setName(String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Subject {<br class="title-page-name"/>  private Professor professor;<br class="title-page-name"/>  public Subject() {<br class="title-page-name"/>    System.out.println("Object of Subject is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  //Setter injection method<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void taughtBy() {<br class="title-page-name"/>    if(professor !=null) {<br class="title-page-name"/>      System.out.println("This subject is taught by "+professor.getName());<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/>public class DIAutoWireCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    Subject subject = (Subject)springContext.getBean("subject");<br class="title-page-name"/>    subject.taughtBy();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous code snippet, the <kbd class="calibre12">Subject</kbd> class depends on <kbd class="calibre12">Professor</kbd>. The object of the <kbd class="calibre12">Professor</kbd> class is injected into <kbd class="calibre12">Subject</kbd> through the setter injection. The XML-based configuration can be done with Spring as follows:</p>
<pre class="calibre17">&lt;bean id="professor" class="com.packet.spring.annotation.di.Professor"&gt;<br class="title-page-name"/>      &lt;property name="name" value="Nilang" /&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="subject" class="com.packet.spring.annotation.di.Subject"&gt;<br class="title-page-name"/>      &lt;property name="professor" ref="professor" /&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">The object of the <kbd class="calibre12">Professor</kbd> bean will be created followed by setting the <kbd class="calibre12">name</kbd> property through the setter injection. Since the <kbd class="calibre12">name</kbd> property is primitive, we directly gave the value. Once the object of the <kbd class="calibre12">professor</kbd> bean is ready, it's injected into the object of the <kbd class="calibre12">subject</kbd> bean through the setter injection. To recall, in XML-based configuration, the setter injection can be performed by the <kbd class="calibre12">ref</kbd> attribute of the <kbd class="calibre12">&lt;property&gt;</kbd> element. Once you run this code, you will get output similar to the following:</p>
<pre class="calibre17">...<br class="title-page-name"/>INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>Object of Subject is created<br class="title-page-name"/>setting the professor through setter method injection <br class="title-page-name"/>This subject is taught by Nilang</pre>
<p class="calibre2">This is typical XML-based metadata, and we want to convert it into annotation-based configuration. The first annotation we will use in the previous example is <kbd class="calibre12">@Autowired</kbd>. It works similarly to its XML counterpart, <kbd class="calibre12">autowire</kbd>. It can be configured at field, constructor, and method level.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining annotation</h1>
                
            
            <article>
                
<p class="calibre2">Let's define <kbd class="calibre12">@Autowired</kbd> for the previous example. Our goal is to remove the XML configuration <kbd class="calibre12">&lt;property name="professor" ref="professor" /&gt;</kbd> for the <kbd class="calibre12">subject</kbd> bean with the <kbd class="calibre12">@Autowired</kbd> annotation. Let's modify a <kbd class="calibre12">setter</kbd> method of the <kbd class="calibre12">Subject</kbd> class and Spring application (XML) context file, as follows:</p>
<pre class="calibre17">//Updated setter injection method<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>//Updated XML configuration<br class="title-page-name"/>&lt;bean id="professor" class="com.packet.spring.annotation.di.Professor"&gt;<br class="title-page-name"/>      &lt;property name="name" value="Nilang" /&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>&lt;bean id="subject" class="com.packet.spring.annotation.di.Subject"&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">We are expected to auto-inject the object of <kbd class="calibre12">Professor</kbd> into <kbd class="calibre12">subject</kbd>, since we used the <kbd class="calibre12">@Autowired</kbd> annotation. When you run this code, you will get output similar to the following:</p>
<pre class="calibre17">INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>Object of Subject is created</pre>
<p class="calibre2">Quick observation: only objects of <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Subject</kbd> beans are created, and no setter is called. In spite of using the <kbd class="calibre12">@Autowired</kbd> annotation, dependency is not injected automatically. This has happened because, without being processed, annotations do nothing at all. It's like electronic equipment without being plugged in. You can't do anything with it.</p>
<p class="calibre2"><span class="calibre11">By declaring configurations with annotations in the Java class, how does Spring know about it? This should be your first question when we talk about annotation-based DI. The answer is, we </span>need to let Spring know about the annotation we defined, so that Spring can use it to get this work done. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Activating annotation-based configuration</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">Annotation-based configuration is not turned on by default. You need to enable it by defining the <kbd class="calibre12">&lt;context:annotation-config/&gt;</kbd> element in application context (XML) files. </span>When Spring reads this element<span class="calibre11">,</span> it activates the actions for all annotations defined in beans in the same application context where this element is defined. In other words, Spring will activate the annotation on all the beans defined in the current application context where the <kbd class="calibre12">&lt;context:annotation-config /&gt;</kbd> element is defined. </p>
<p class="calibre2">Let's update the configuration and rerun the previous code. You will get output similar to the following:</p>
<pre class="calibre17">// Updated Configuration<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/>        http://www.springframework.org/schema/context<br class="title-page-name"/>        http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br class="title-page-name"/>    <br class="title-page-name"/>    &lt;context:annotation-config /&gt;<br class="title-page-name"/>    &lt;bean id="professor" class="com.packet.spring.annotation.di.Professor"&gt;<br class="title-page-name"/>      &lt;property name="name" value="Nilang" /&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>    <br class="title-page-name"/>    &lt;bean id="subject" class="com.packet.spring.annotation.di.Subject"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/beans&gt;<br class="title-page-name"/><br class="title-page-name"/>//Output<br class="title-page-name"/>...<br class="title-page-name"/>INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>Object of Subject is created<br class="title-page-name"/>setting the professor through setter method injection <br class="title-page-name"/>This subject is taught by Nilang</pre>
<div class="packt_infobox">To enable <kbd class="calibre37">&lt;context:annotation-config /&gt;</kbd> in Spring XML configuration files, you need to include a few schema definitions specific to context, such as <kbd class="calibre37">xmlns:context</kbd>, and add <kbd class="calibre37">context-specific xsd</kbd> into <kbd class="calibre37">schemaLocation</kbd>.</div>
<p class="calibre2">Now everything works as expected. Objects of the <kbd class="calibre12">professor</kbd> bean are injected into objects of the <kbd class="calibre12">subject</kbd> bean properly. This is what we want to achieve with annotation. But wait a minute. We just removed one element (<kbd class="calibre12">&lt;property&gt;</kbd>) and added the new one—<kbd class="calibre12">&lt;context:annotation-config /&gt;</kbd>. </p>
<p class="calibre2">Ideally, annotation-based configuration should replace XML-based configuration completely. In previous cases, we are still defining the <kbd class="calibre12">&lt;bean&gt;</kbd> definition in XML-based configuration. If you remove it, Spring will not create any bean, and will not perform any action for annotation you defined for those beans. This is because <kbd class="calibre12">&lt;context:annotation-config /&gt;</kbd> only works for the <kbd class="calibre12">&lt;bean&gt;</kbd>s that are defined in Spring's application context (XML) file. So, if there is no <kbd class="calibre12">&lt;bean&gt;</kbd> defined, there is no meaning of annotation, even though you defined it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining a Java class as &lt;bean&gt; with annotation</h1>
                
            
            <article>
                
<p class="calibre2">The solution to this &lt;indexentry content="annotation-based DI:Java class, defining as with annotation"&gt;problem is to define <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> in an application context (XML) file. When Spring reads this element, it will start scanning the beans from the Java package defined by its attribute, <kbd class="calibre12">base-package</kbd>. You can instruct Spring to treat the Java class as <kbd class="calibre12">&lt;bean&gt;</kbd> by declaring class-level annotation <kbd class="calibre12">@Component</kbd>. In short, defining annotation-based configuration is a two-step process, as follows:</p>
<ol class="calibre14">
<li value="1" class="calibre10"><strong class="calibre1">Scanning the package</strong>: This can be done by reading the <kbd class="calibre12">base-package</kbd> attribute of <kbd class="calibre12">&lt;context:component-scan&gt;</kbd>. Spring will start scanning for the classes in that Java package.</li>
<li value="2" class="calibre10"><strong class="calibre1">Defining beans</strong>: Out of Java classes in the said Java package, Spring will consider as <kbd class="calibre12">&lt;bean&gt;</kbd> only those which have class-level annotation—<kbd class="calibre12">@Component</kbd> is defined. Let's change our example to incorporate this configuration:</li>
</ol>
<pre class="calibre17">//Updated Spring application context (XML) file<br class="title-page-name"/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>        http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/>        http://www.springframework.org/schema/context<br class="title-page-name"/>        http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br class="title-page-name"/>    <br class="title-page-name"/>    &lt;context:annotation-config /&gt;<br class="title-page-name"/>    &lt;context:component-scan base-package="com.packet.spring.annotation.di"/&gt;<br class="title-page-name"/>&lt;/beans&gt;<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>//Updated Professor class<br class="title-page-name"/>@Component<br class="title-page-name"/>public class Professor {<br class="title-page-name"/>  @Value(value="Nilang")<br class="title-page-name"/>  private String name;<br class="title-page-name"/>  //Constructor<br class="title-page-name"/>  public Professor() {<br class="title-page-name"/>    System.out.println("Object of Professor is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return name;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setName(String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Updated Subject class<br class="title-page-name"/>@Component<br class="title-page-name"/>public class Subject {<br class="title-page-name"/>  private Professor professor;<br class="title-page-name"/>  public Subject() {<br class="title-page-name"/>    System.out.println("Object of Subject is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  //Setter injection method<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void taughtBy() {<br class="title-page-name"/>    if(professor !=null) {<br class="title-page-name"/>      System.out.println("This subject is taught by "+professor.getName());<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Spring will consider <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Subject</kbd> classes as a <kbd class="calibre12">&lt;bean&gt;</kbd> through <kbd class="calibre12">@Component</kbd> annotation, so there is no need to define them in an application context (XML) file. You can inject the value for primitive properties with the <kbd class="calibre12">@Value</kbd> annotation. In the preceding example, we have set the value of the <span class="calibre11"><kbd class="calibre12">name</kbd> property of the <kbd class="calibre12">Professor</kbd> bean with the <kbd class="calibre12">@Value</kbd> annotation directly at property level.  Alternatively, you can inject the primitive values to <kbd class="calibre12">property</kbd> at a setter method level, as per the following snippet:</span></p>
<pre class="calibre17">  @Autowired <br class="title-page-name"/>  public void setName(@Value("Komal") String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }</pre>
<p class="calibre2">You need to set the <kbd class="calibre12">@Autowired</kbd> annotation on the setter method and inject the value of that property with the <kbd class="calibre12">@Value</kbd> annotation. <span class="calibre11">When you run this code, you will get the desired output, similar to what we got with pure XML-based configuration.</span></p>
<p class="calibre2">The element <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> does all the things that <kbd class="calibre12">&lt;context:annotation-config /&gt;</kbd> can. If you keep both of them in application context (XML) files, there is no harm; but then <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> is just suffice, and you can omit <kbd class="calibre12">&lt;context:annotation-config /&gt;</kbd>.</p>
<p class="calibre2">You can pass multiple packages to <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> as comma separated string to its <kbd class="calibre12">base-package</kbd> attribute. What's more, you can define various filters (include and exclude) on <kbd class="calibre12">&lt;context:component-scan&gt;</kbd> to scan specific subpackages and eliminate others. </p>
<div class="packt_infobox">Configuration can be done through annotation or with XML, or by mixing both of them. The DI configured with XML is executed after annotation-based DI. So it's possible that XML-based configuration overrides the annotation-based configuration for a bean's property (setter) wiring.</div>
<p class="calibre2">So far, we have learned about <kbd class="calibre12">@Autowired</kbd>, <kbd class="calibre12">@Component</kbd>, and <kbd class="calibre12">@Value</kbd> annotations. We will see a few more annotations that are used frequently in DI as follows:</p>
<p class="calibre2"><strong class="calibre4">Annotation—</strong><kbd class="calibre12">@Required</kbd>: The  <kbd class="calibre12">@Required</kbd> annotation can be applied to a bean's setter method. It indicates that Spring must populate the value of a property from the setter method either through autowire or explicit setting of a property value. In other words, the bean property must be populated at configuration time. If this is not fulfilled, the container throws an exception.</p>
<p class="calibre2">As an alternative, you can use the <kbd class="calibre12">@Autowired</kbd> annotation with the attribute required—<kbd class="calibre12">@Autowired</kbd> (<kbd class="calibre12">required=false</kbd>). When you set it to <kbd class="calibre12">false</kbd>, Spring will ignore this property for autowire if the suitable bean is not available.</p>
<p class="calibre2"><strong class="calibre4">Annotation—</strong><kbd class="calibre12">@Qualifier</kbd><span class="calibre11">: By default, the <kbd class="calibre12">@Autowired</kbd> annotation works with the type of bean's class. </span>When there is more than one bean with the same type (class) configured, Spring will show an error when you try to autowire it with a property. In this case, you need to use the <kbd class="calibre12">@Qualifier</kbd> annotation. It will help to wire the specific bean out of available beans of the same type. You need to specify <kbd class="calibre12">@Qualifier</kbd> along with <kbd class="calibre12">@Autowired</kbd> to remove the confusion by declaring an exact bean. Let's understand this by looking at the following example:</p>
<pre class="calibre17">public class Professor {<br class="title-page-name"/>  private String name;<br class="title-page-name"/>  //Constructor<br class="title-page-name"/>  public Professor() {<br class="title-page-name"/>    System.out.println("Object of Professor is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return name;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setName(String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component<br class="title-page-name"/>public class Subject {<br class="title-page-name"/>  private Professor professor;<br class="title-page-name"/>  public Subject() {<br class="title-page-name"/>    System.out.println("Object of Subject is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  //Setter injection method<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  @Qualifier("professor1")<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void taughtBy() {<br class="title-page-name"/>    if(professor !=null) {<br class="title-page-name"/>      System.out.println("This subject is taught by "+professor.getName());<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Updated Application context (XML) file.<br class="title-page-name"/><br class="title-page-name"/>&lt;context:component-scan base-package="com.packet.spring.annotation.di"/&gt;<br class="title-page-name"/>&lt;bean id="professor1" class="com.packet.spring.annotation.di.Professor"&gt;<br class="title-page-name"/>      &lt;property name="name" value="Ramesh" /&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="professor2" class="com.packet.spring.annotation.di.Professor"&gt;<br class="title-page-name"/>      &lt;property name="name" value="Nilang" /&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">In the previous code, the <kbd class="calibre12">@Qualifier</kbd> annotation is added along with <kbd class="calibre12">@Autowired</kbd>, with the value <kbd class="calibre12">professor1</kbd> in the <kbd class="calibre12">Subject</kbd> class. This indicates to Spring to autowire the <kbd class="calibre12">professor</kbd> bean with <kbd class="calibre12">id = professor1</kbd>. In the Spring configuration file, we have defined two beans of the <kbd class="calibre12">Professor</kbd> type with different ID values. In absence of the <kbd class="calibre12">@Qualifier</kbd> annotation, Spring throws an error. The previous code produces output like the following:</p>
<pre class="calibre17">...<br class="title-page-name"/>org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions<br class="title-page-name"/>INFO: Loading XML bean definitions from class path resource [application-context.xml]<br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>Object of Subject is created<br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>setting the professor through setter method injection <br class="title-page-name"/>Object of Professor is created<br class="title-page-name"/>This subject is taught by Ramesh</pre>
<p class="calibre2">Now Spring will inject the object of a &lt;indexentry content="annotation-based DI:Java class, defining as with annotation"&gt;bean with similar ID as the value of the <kbd class="calibre12">@Qualifier</kbd> annotation. In previous cases, the object of bean with <kbd class="calibre12">id = professor1</kbd> is injected into <kbd class="calibre12">Subject</kbd>.</p>
<div class="packt_tip">You might be surprised that we have used XML-based configuration here. It's quite possible to define this with annotation in a Java class, but it's advisable to use XML configuration in case you need to define multiple beans of the same type with different ID.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Annotation with the factory method</h1>
                
            
            <article>
                
<p class="calibre2">We have seen how the <kbd class="calibre12">factory</kbd> method is created and configured to generate beans with XML-based configuration. Spring supports annotation for the <kbd class="calibre12">factory</kbd> method also. Let's take the same example, and understand how to write annotation for the <kbd class="calibre12">factory</kbd> method:</p>
<pre class="calibre17">public class Employee {<br class="title-page-name"/>  private String type;<br class="title-page-name"/>  public Employee(String type) {<br class="title-page-name"/>    this.type = type;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void showType() {<br class="title-page-name"/>    System.out.println("Type is :"+type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Developer extends Employee {<br class="title-page-name"/>  public Developer(String type) {<br class="title-page-name"/>    super(type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Manager extends Employee {<br class="title-page-name"/>  public Manager(String type) {<br class="title-page-name"/>    super(type);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component<br class="title-page-name"/>public class EmployeeService {<br class="title-page-name"/>  //Instance Factory method with annotation<br class="title-page-name"/>  @Bean("developerBean")<br class="title-page-name"/>  public Employee getEmployee(@Value("developer")String type) {<br class="title-page-name"/>    Employee employee = null;<br class="title-page-name"/>    if("developer".equalsIgnoreCase(type)) {<br class="title-page-name"/>      employee = new Developer("developer");<br class="title-page-name"/>    }else if("manager".equalsIgnoreCase(type)) {<br class="title-page-name"/>      employee = new Manager("manager");<br class="title-page-name"/>    }<br class="title-page-name"/>    System.out.println("Employee of type "+type+" is created");<br class="title-page-name"/>    return employee;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component<br class="title-page-name"/>public class SalaryService {<br class="title-page-name"/>  private Employee employee;<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setEmployee(@Qualifier("developerBean")Employee employee) {<br class="title-page-name"/>    this.employee = employee;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void showEmployeeType() {<br class="title-page-name"/>    if(this.employee !=null) {<br class="title-page-name"/>      this.employee.showType();<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class DIWithAnnotationFactoryCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/>    SalaryService salaryService = (SalaryService)springContext.getBean("salaryService");<br class="title-page-name"/>    salaryService.showEmployeeType();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre12">Employee</kbd> is a base class having <kbd class="calibre12">type</kbd> as property. <kbd class="calibre12">Developer</kbd> and <kbd class="calibre12">Manager</kbd> extend <kbd class="calibre12">Employee</kbd>, and set the <kbd class="calibre12">type</kbd> property in a respective constructor. <kbd class="calibre12">EmployeeService</kbd> and <kbd class="calibre12">SalaryService</kbd> are defined as component classes with the <kbd class="calibre12">@Component</kbd> annotation. Spring will treat both of them as <kbd class="calibre12">&lt;bean&gt;</kbd>. </p>
<p class="calibre2"><kbd class="calibre12">EmployeeService</kbd> works as a factory bean, which has a <kbd class="calibre12">getEmployee</kbd> method. This method has an <kbd class="calibre12">@Bean</kbd> annotation. The <kbd class="calibre12">@Bean</kbd> annotation indicates a <kbd class="calibre12">factory</kbd> method. In this method, we are injecting a primitive value: <kbd class="calibre12">developer</kbd> to <kbd class="calibre12">type</kbd> parameter, with the <kbd class="calibre12">@Value</kbd> annotation. This method <span class="calibre11">generates the object of either <kbd class="calibre12">Developer</kbd> or <kbd class="calibre12">Manager</kbd> based on the </span><kbd class="calibre12">type</kbd> parameter.</p>
<p class="calibre2">In the preceding code, we are supplying a <kbd class="calibre12">developerBean</kbd> value to the <kbd class="calibre12">@Bean</kbd> annotation. This instructs Spring to create a <kbd class="calibre12">&lt;bean&gt;</kbd> with <kbd class="calibre12">id =developerBean</kbd>, and a class as <kbd class="calibre12">Employee</kbd>—a return type from the <kbd class="calibre12">getEmployee</kbd> (factory) method. In short, the <kbd class="calibre12">factory</kbd> method in the previous code is equivalent to the following XML configuration:</p>
<pre class="calibre17">&lt;bean id="employeeService" class="com.packet.spring.annotation.factory.di.EmployeeService"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="developerBean" factory-method="getEmployee" factory-bean="employeeService"&gt;<br class="title-page-name"/>      &lt;constructor-arg value="developer"&gt;&lt;/constructor-arg&gt; <br class="title-page-name"/>&lt;/bean&gt;</pre>
<p class="calibre2">We have another component class: <kbd class="calibre12"> SalaryService </kbd>. It has a <kbd class="calibre12">setEmployee</kbd> method, taking the object of <kbd class="calibre12">Employee</kbd> as a parameter. We have given a qualifier as <kbd class="calibre12">developerBean</kbd> to the parameter of this method. Since this method is declared as autowired, Spring will inject the object of type <kbd class="calibre12">Employee</kbd> with <kbd class="calibre12">id=developerBean</kbd>, which is generated by the <kbd class="calibre12">factory</kbd> method in <kbd class="calibre12">EmployeeService</kbd>.  So, conclusively, the whole preceding Java code  is equivalent to the following XML configuration:</p>
<pre class="calibre17">&lt;bean id="employeeService" class="com.packet.spring.annotation.factory.di.EmployeeService"&gt;<br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/>&lt;bean id="developerBean" factory-method="getEmployee" factory-bean="employeeService"&gt;<br class="title-page-name"/>      &lt;constructor-arg value="developer"&gt;&lt;/constructor-arg&gt; <br class="title-page-name"/>&lt;/bean&gt;<br class="title-page-name"/><br class="title-page-name"/>&lt;bean id="salaryService" <br class="title-page-name"/>class="com.packet.spring.annotation.factory.di.SalaryService"&gt;<br class="title-page-name"/>      &lt;property name="employee" ref="developerBean"/&gt;<br class="title-page-name"/>&lt;/bean&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DI with Java configuration</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have seen how to define the configuration with XML and annotation. Spring also supports defining configuration completely in Java classes, and there is no more XML required. You need to provide Java classes that take the ownership of creating the beans. In short, it's a source of bean definition.</p>
<p class="calibre2">A class annotated by <kbd class="calibre12">@Configuration</kbd> would be considered as Java config for a Spring IoC container. This class should declare methods that actually <span class="calibre11">configure and </span>instantiate the objects of beans that would be managed by containers. All such methods should be annotated with <kbd class="calibre12">@Bean</kbd>. Spring will consider all such <kbd class="calibre12">@Bean</kbd> annotated methods as a source of bean. Such methods are kinds of <kbd class="calibre12">factory</kbd> methods. Let's understand this by looking at the following simple example:</p>
<pre class="calibre17">@Configuration<br class="title-page-name"/>public class JavaBaseSpringConfig {<br class="title-page-name"/>  @Bean(name="professor")<br class="title-page-name"/>  public Professor getProfessor() {<br class="title-page-name"/>    return new Professor();<br class="title-page-name"/>  }<br class="title-page-name"/>  @Bean(name="subjectBean")<br class="title-page-name"/>  public Subject getSubject() {<br class="title-page-name"/>    return new Subject();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this code, <kbd class="calibre12">JavaBaseSpringConfig</kbd> is a configuration class. The <kbd class="calibre12">name</kbd> attribute in the <kbd class="calibre12">@Bean</kbd> annotation is equivalent to the <kbd class="calibre12">id</kbd> attribute of the <kbd class="calibre12">&lt;bean&gt;</kbd> element. This configuration is equivalent to the following XML configuration:</p>
<pre class="calibre17">&lt;beans&gt;<br class="title-page-name"/>    &lt;bean id="professor" class="com.packet.spring.javaconfig.di.Professor"/&gt;<br class="title-page-name"/>    &lt;bean id="subjectBean" class="com.packet.spring.javaconfig.di.Subject"/&gt;<br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">Once you define all your beans in a configuration class, it can be loaded with application context by a container. Spring provides a separate application context called <kbd class="calibre12">AnnotationConfigApplicationContext</kbd> to load configuration classes and manage bean objects. It can be used as follows:</p>
<pre class="calibre17">public class DIWithJavaConfigCheck {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new AnnotationConfigApplicationContext(JavaBaseSpringConfig.class);<br class="title-page-name"/>    Professor professor = (Professor)springContext.getBean("professor");<br class="title-page-name"/>    Subject subject = (Subject)springContext.getBean("subjectBean");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">You need to pass a configuration class in the constructor of <kbd class="calibre12">AnnotationConfigApplicationContext</kbd>, and the rest of the process of getting beans is identical to other application contexts. Also, there is no change in the way beans are wired with Java config. For example, in the previous code, objects of type <kbd class="calibre12">Professor</kbd> can be injected into objects of <kbd class="calibre12">Subject</kbd>, as per the following snippet:</p>
<pre class="calibre17">public class Professor {<br class="title-page-name"/>  private String name;<br class="title-page-name"/>  //Constructor<br class="title-page-name"/>  public Professor() {<br class="title-page-name"/>    System.out.println("Object of Professor is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return this.name;<br class="title-page-name"/>  }<br class="title-page-name"/>  @Autowired <br class="title-page-name"/>  public void setName(@Value("Komal") String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class Subject {<br class="title-page-name"/>  private Professor professor;<br class="title-page-name"/>  public Subject() {<br class="title-page-name"/>    System.out.println("Object of Subject is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  //Setter injection method<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void taughtBy() {<br class="title-page-name"/>    if(professor !=null) {<br class="title-page-name"/>      System.out.println("This subject is taught by "+professor.getName());<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">You can notice in the preceding code that we haven't put a <kbd class="calibre12">@Component</kbd> annotation for the <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Subject</kbd> class. This is because the logic of instance creation is within the methods of the configuration class, so there is no need to ask Spring to scan the Java package explicitly. </p>
<p class="calibre2">Spring still provides support scanning of  specific Java package to create the bean, instead of creating it yourself with a new operator. For this, you need to apply the following changes:</p>
<pre class="calibre17">@Configuration<br class="title-page-name"/>@ComponentScan(basePackages="com.packet.spring.javaconfig.di")<br class="title-page-name"/>public class JavaBaseSpringConfig {<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("professor")<br class="title-page-name"/>public class Professor {<br class="title-page-name"/>  private String name;<br class="title-page-name"/>  //Constructor<br class="title-page-name"/>  public Professor() {<br class="title-page-name"/>    System.out.println("Object of Professor is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  public String getName() {<br class="title-page-name"/>    return this.name;<br class="title-page-name"/>  }<br class="title-page-name"/>  @Autowired <br class="title-page-name"/>  public void setName(@Value("Komal") String name) {<br class="title-page-name"/>    this.name = name;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("subjectBean")<br class="title-page-name"/>public class Subject {<br class="title-page-name"/>  private Professor professor;<br class="title-page-name"/>  public Subject() {<br class="title-page-name"/>    System.out.println("Object of Subject is created");<br class="title-page-name"/>  }<br class="title-page-name"/>  //Setter injection method<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setProfessor(Professor professor) {<br class="title-page-name"/>    System.out.println("setting the professor through setter method injection ");<br class="title-page-name"/>    this.professor = professor;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void taughtBy() {<br class="title-page-name"/>    if(professor !=null) {<br class="title-page-name"/>      System.out.println("This subject is taught by "+professor.getName());<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In the previous code snippet, we declared the <kbd class="calibre12">Professor</kbd> and <kbd class="calibre12">Subject</kbd> classes as components by declaring the <kbd class="calibre12">@Component</kbd> annotation. We also instructed the configuration class—<kbd class="calibre12">JavaBaseSpringConfig</kbd>, to scan the specific Java package with annotation <kbd class="calibre12">@ComponentScan</kbd>, and pass the Java package value in the <kbd class="calibre12">basePackage</kbd> attribute. In both of the previous cases, you will get identical output. This is equivalent to the following XML configuration:</p>
<pre class="calibre17">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br class="title-page-name"/>&lt;beans   <br class="title-page-name"/>      xsi:schemaLocation="http://www.springframework.org/schema/beans<br class="title-page-name"/>       http://www.springframework.org/schema/beans/spring-beans.xsd<br class="title-page-name"/>       http://www.springframework.org/schema/context<br class="title-page-name"/>       http://www.springframework.org/schema/context/spring-context.xsd"&gt;<br class="title-page-name"/><br class="title-page-name"/>    &lt;bean id="professor" class="com.packet.spring.javaconfig.di.Professor"&gt;<br class="title-page-name"/>        &lt;property name="name" value="komal" /&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>    &lt;bean id="subjectBean" class="com.packet.spring.javaconfig.di.Subject" autowire="byType"&gt;<br class="title-page-name"/>    &lt;/bean&gt;<br class="title-page-name"/>&lt;/beans&gt;</pre>
<p class="calibre2">In conclusion, the following diagram shows how a Spring IoC container manages the process of object creation and dependency management:</p>
<div class="mce-root"><img src="../images/00028.jpeg" class="calibre45"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we learned how you can implement DI with Spring—one of the most popular frameworks for developing enterprise applications today. We have seen how the Spring container plays a vital role for managing bean life cycle.</p>
<p class="calibre2">We also learned how to define configurations that are XML and annotation-based. We also looked at different types of DI in depth, such as setter-based injection and constructor-based injection.</p>
<p class="calibre2">If you want to write your custom logic while creating instances of beans, you can now use the <kbd class="calibre12">factory</kbd> method in Spring. We also learned how to bind beans automatically with various modes, such as autowire by name, type, and constructor.</p>
<p class="calibre2">With the help of Java config, you can build Spring applications with zero XML. We saw various techniques for using Java config in the last section.</p>
<p class="calibre2">We will continue our journey and learn how to achieve DI in Google Guice, another popular framework that provides containers to achieve loosely coupled systems. We will explore them in the next chapter.</p>
<p class="calibre2"> </p>


            </article>

            
        </section>
    </body></html>