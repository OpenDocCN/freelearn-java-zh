- en: Chapter 1. Building RESTful Web Services Using JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various ways to implement communication between heterogeneous applications.
    There are standards focusing on web services based on **SOAP**, **WSDL**, and
    WS* specifications; alongside these standards there is an emerging lightweight
    solution based on plain HTTP referred to as **Representational State Transfer**
    (**REST**).
  prefs: []
  type: TYPE_NORMAL
- en: REST is identified by the principles of addressable resources, constrained interfaces
    using HTTP verbs, representation, and statelessness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key principles of REST are:'
  prefs: []
  type: TYPE_NORMAL
- en: Associating IDs to resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using standard HTTP methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple formats of data sent by a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter starts with the basic concept of building **RESTful Web Services**
    using the **JAX-RS** 2.0 API and covers the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting POJOs to RESTful endpoints using JAX-RS 2.0 annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Produces`, `@Consumes` annotations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client API for JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample showing all verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom entity providers for **serializing** and **deserializing** user defined
    classes using JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the Bean Validation API for validation with JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The REST architectural style is based on request and response messages transferred
    between clients and servers without any of the participating node keeping track
    of the state of previous sessions..
  prefs: []
  type: TYPE_NORMAL
- en: REST uses nouns and verbs for readability. Resources are identified in requests.
    The representation of the resource that is sent to the client depends on the request
    and how the server sends the data.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A RESTful Web Service is a service whose interface and accessing mechanism are
    aligned with the REST principles . The URIs identify the resources. For example,
    a RESTful resource for a book can be identified as [http://foo.org/book](http://foo.org/book).
  prefs: []
  type: TYPE_NORMAL
- en: A resource for a book identified by ISBN could be [http://foo.org/book/isbn/1234459](http://foo.org/book/isbn/1234459).
    This shows a human-readable URI that is easy to understand and identify.
  prefs: []
  type: TYPE_NORMAL
- en: A client has enough metadata of a resource to modify or delete it as long as
    it is authorized to do so. To get a resource the client would send a HTTP `GET`
    request. To update the resource the client would send a `PUT` request. To delete
    a resource the client would send a `DELETE` request. To create a new resource,
    and for arbitrary processing, the client sends a HTTP `POST` request. The next
    section covers these verbs in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Verbs in REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the requests used in REST are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: The `GET` request retrieves a representation of a resource from server
    to client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: The `POST` request is used to create a resource on the server based
    on the representation that the client sends'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: The `PUT` request is used to update or create a reference to a resource
    on server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: The `DELETE` request can delete a resource on server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: The `HEAD` requests checks for a resource without retrieving it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will introduce the notion of safety and **idempotence**, two
    important terms associated with REST.
  prefs: []
  type: TYPE_NORMAL
- en: Safety and idempotence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to REST, a safe method, by definition, is a HTTP method that does
    not modify the state of the resource on the server. For example, invoking a `GET`
    or a `HEAD` method on the resource URL should never change the resource on the
    server. `PUT` is considered not safe since it usually creates a resource on the
    server. `DELETE` is also considered not safe since it will delete the resource
    on the server. `POST` is not safe since it will change the resource on the server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Idempotent** method is a method that can be called multiple times yet the
    outcome will not change.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` and `HEAD` are idempotent, which means that even though the same operation
    is done multiple times the result does not vary. `PUT` is idempotent; calling
    the `PUT` method multiple times will not change the result and the resource state
    is exactly the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE` is idempotent because once the resource is deleted it is gone, and
    calling the same operation multiple times will not change the outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `POST` is not idempotent and calling `POST` multiple times can
    have different outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idempotence and safety of the HTTP verbs are a convention, meaning that
    when someone is using your API they will assume that `GET`/`PUT`/`POST`/`DELETE`
    have the same idempotency characteristics that are previously described; and the
    implementation of the business logic behind each verb should support these characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The response sent by the server could be in XML, JSON, or any other MIME type
    as long as the server supports the requested format. In case the server cannot
    support the requested MIME type, it can return with a status code of 406 (not
    acceptable).
  prefs: []
  type: TYPE_NORMAL
- en: When we are developing with RESTful principles in mind, each message should
    have enough information to let the server understand the purpose of the message
    and how to process that message, to produce the response the message is meant
    for, and finally to ensure visibility and statelessness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summarizing, these are the components of RESTful Web Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base URI**: The base URI for the Web Service `http://foo.com/bar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Media type**: The media type supported by the Web Service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**: The HTTP methods such as `GET`, `PUT`, `POST`, and `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Java API for Representational State Transfer** (**JAX-RS**) specification
    defines a set of Java APIs for building web services conforming to the REST style.
  prefs: []
  type: TYPE_NORMAL
- en: This specification defines how to expose POJOs as web resources, using HTTP
    as the network protocol. Applications using these APIs can be deployed to an application
    server in a portable manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key features that are introduced in the JAX-RS 2.0 specification
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server side asynchronous support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bean Validation** support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the subsequent sections we will cover the following topics in relation to
    JAX-RS 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting POJOs to RESTful resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on JAX-RS annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client API for JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entities in JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom entity providers in JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Bean Validation API with JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting POJOs to RESTful resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A resource class is a POJO that uses the JAX-RS annotations. A resource class
    needs to have at least one method annotated with `@Path` or a request method.
    Resources are our so-called web services and incoming requests target these resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps to convert POJOs to RESTful endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a root resource as identified by a URI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the methods for the resource
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the MIME types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the Application subclass
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the subresources
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a root resource as identified by a URI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX-RS provides very rich client and server APIs that work on any Java EE application
    server. Using JAX-RS API, any POJO can be annotated to build the RESTful resources.
    Begin with a simple POJO `BookResource` and annotate it with the JAX-RS APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a root resource class, which is annotated with `@Path annotation`. The
    value `"books"` will indicate that the resource will be available at a location
    similar to the following URI `http://host:port/appname/books`.
  prefs: []
  type: TYPE_NORMAL
- en: Later on we add the methods to this resource so that, when a request with `GET`,
    `PUT`, and so on hits this resource, a particular method in the class is invoked
    to produce the response.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the methods for the resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a method to this resource, we annotate the method with `@GET`, `@PUT`,
    `@DELETE`, or `@HEAD`. In the following example, we chose to annotate using a
    `@GET annotation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `@GET` annotation specifies that the `getGreeting()` method handles the
    `HTTP GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the MIME types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specify the MIME type that can be handled by the resource, we should annotate
    the resource method with `@Produces` and `@Consumes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `@Produces` specifies that the media type this method will produce is `"text/plain"`.
    Support for other media types, and how to map from Java to a specific format and
    vice versa, is covered in detail in the entity provider's section. Thus, this
    is the initial introduction to having a first JAX-RS resource ready. The next
    section covers the details of the `Application` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Application subclass
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Application` class is a portable way to configure application-level details
    such as specifying the name, and registering various components of a JAX-RS application.
    This includes the different JAX-RS resources and the JAX-RS providers in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, application-wide properties can be set using a subclass of `Application`.
    The `Application` subclass should to be placed in either in `WEB-INF/classes`
    or `WEB-INF/lib` in a WAR file. Application class has the following methods that
    can be overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a subclass of Application for our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code we create a `HelloWorldApplication`, which is a subclass of `javax.ws.rs.core.Application`.
    With Servlet 3.0 there is no need of a `web.xml` file and the servlet container
    uses the value specified in the `@ApplicationPath` as the servlet mapping. The
    `getClasses()` method of the `Application` class is overridden to add `BooksResource.class`.
  prefs: []
  type: TYPE_NORMAL
- en: A basic JAX-RS resource is now ready to use. When the sample is deployed to
    an application server such as GlassFish, you can use curl to send a request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example on how to send a `curl -X GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in the terminal window should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello from book resource**'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*, will show how to use the Application class in a `web.xml`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the subresources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Resource classes can partially process some part of the request and provide
    another subresource to process the remaining part of the request.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a snippet of a root resource `Library` and another resource
    `Book`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Subresource locators are resource methods that have `@Path` annotation but no
    HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, `Library` is a root resource as it is annotated with
    `@Path`. The method `getBook()` is a subresource locator whose job is to provide
    an object that can process the request.
  prefs: []
  type: TYPE_NORMAL
- en: The `@PathParam` is an annotation that allows you to map URI path fragments
    in the method call. In this example, the `isbn` URI parameter is passed to provide
    information about the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client sends a request using the URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Library.getBook()` method will be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client sends a request using the URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Library.getBook()` method will be invoked first. A `Book` object is returned
    and then the `getAuthor()` method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: More on JAX-RS annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Produces` annotation is used to define the type of output the method in
    the resource produces. The `@Consumes` annotation is used to define the type of
    input, the method in the resource consumes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a method in a resource for a `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this snippet we have the `@POST` annotation that indicates this
    method accepts `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Produces(MediaType.APPLICATION_XML)` indicates that the `"application/xml"`
    media type is produced by the `addBook()` method of this resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Consumes(MediaType.APPLICATION_XML)` indicates that the `"application/xml"`
    media type is consumed by the `addBook()` method of this resource.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response.ok(book)` method builds an ok response of the type `MediaType.APPLICATION_XML_TYPE`
  prefs: []
  type: TYPE_NORMAL
- en: Other supported media types `@Produces` and `@Consumes` are `"text/xml"`, `"text/html"`,
    `"application/json"`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no media type specified in the `@Produces` or `@Consumes` annotations,
    support for any media type is assumed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a snippet of code that shows the `@DELETE` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `@PathParam` annotation allows you to map the URI path fragments in the
    method call. In this example, the `isbn` URI parameter is passed to provide information
    about the book.
  prefs: []
  type: TYPE_NORMAL
- en: The ISBN uniquely identifies the Book resource so that it can be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes important JAX-RS 2.0 annotations included in
    Java EE 7 and used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@Path` | To annotate a POJO with the resource path it represents. For example,
    `@Path("books")` or to annotate a subresource that is a method in the annotated
    class. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Produces` | To specify the output type that the resource produces, or in
    a narrower scope the type of output that a method in a resource produces. For
    example:`@Produces(MediaType.APPLICATION_JSON)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Consumes` | To specify the type of input that the resource consumes, or
    in a narrower scope the type of input that a method in a resource consumes. For
    example:`@Consumes (MediaType.APPLICATION_JSON)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@GET`, `@POST`, `@DELETE`, and so on | To map the HTTP methods to methods
    in the resource representing class. For example, `@GET` can be placed on `getBook`
    method. |'
  prefs: []
  type: TYPE_TB
- en: '| `@PathParam` | To specify the mapping between query parameter names and method.
    For example:`getBook(@PathParam("isbn") String isbn)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationPath` | Identifies the application path that serves as the base
    URI for all resource URIs provided by path. For example, `@ApplicationPath("library")`
    for the library application. |'
  prefs: []
  type: TYPE_TB
- en: '| `@Context` | Can be used to inject contextual objects such as `UriInfo`,
    which provides contextual request-specific information about the request URI.
    For example:`getBook(@Context UriInfo uriInfo,` |'
  prefs: []
  type: TYPE_TB
- en: '[Chapter 5](ch05.html "Chapter 5. RESTful Web Services by Example"), *RESTful
    Web Services by Example*, covers the different JAX-RS APIs in detail and ties
    them together with other Java EE APIs to build a real-world library application.'
  prefs: []
  type: TYPE_NORMAL
- en: The Client API for JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JAX-RS 2.0 provides a rich client API to access the web resources. Here is
    the code on how to use the client API for the `BooksResource` we built earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The default instance of the `javax.ws.rs.client.Client` object can be obtained
    using the `ClientBuilder.newClient()` API. The `BooksResource` can be identified
    by URI. The `WebTarget` object is used to build the URI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `target.request().get(String.class)` method builds an HTTP `GET` request
    and gets an object of type `String` in the response. More samples of the client
    API with other verbs are shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Entities in JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main part of an HTTP interaction consists of the request and response entities.
    Entities are also referred to as the payload or message body in some contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are sent via a request, usually an HTTP `POST` and `PUT` method is
    used, or they are returned in a response, this is relevant for all the HTTP methods.
    The `Content-Type` HTTP header is used to indicate the type of entity being sent.
    Common **content types** are `"text/plain"`, `"text/xml"`, `"text/html"`, and
    `"application/json"`.
  prefs: []
  type: TYPE_NORMAL
- en: Media types are used in the `Accept` header to indicate what type of resource
    representation the client wants to receive.
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet shows how to use the client API to create a `POST` request.
    This invocation takes an entity for a user-defined class `Book` and a `MediaType.APPLICATION_XML_TYPE`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the client code to invoke the `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `WebTarget#request()` method returns a `Response`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the client API code to invoke the `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next section will show how the entity providers that implement the JAX-RS
    API map to and from Java types request and response entities.
  prefs: []
  type: TYPE_NORMAL
- en: Custom entity providers in JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JAX-RS enables developers to add custom entity providers to the application.
    The custom entity providers can be used for dealing with user-defined classes
    in the requests as well as responses.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom entity provider provides a way to **deserialize** user-defined
    classes from the message bodies and **serialize** any media type to your user
    specific class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of entity providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBodyReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessageBodyWriter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `@Provider` annotation, application-specific provider classes can
    be discovered. Entity providers provide mapping between the representation and
    associated type. There is a sample included with the book that demonstrates the
    use of entity providers.
  prefs: []
  type: TYPE_NORMAL
- en: MessageBodyReader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An application can provide an implementation of the `MessageBodyReader` interface
    by implementing the `isReadable()` method and the `readFrom()` method to map the
    entity to the desired Java type.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows how the `MessageBodyReader` reads an `InputStream`
    object and converts it to a user-defined Java object.
  prefs: []
  type: TYPE_NORMAL
- en: '![MessageBodyReader](img/8125EN_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following code shows how to provide an implementation of `MessageBodyReader`
    and uses **Java Architecture for XML Binding** (**JAXB**) with JAX-RS. JAXB provides
    a fast and convenient way to bind XML schemas and Java representations, making
    it easy for Java developers to incorporate the XML data and processing functions
    in Java applications. As a part of this process, JAXB provides methods for **unmarshalling**
    (reading) XML instance documents into Java content trees, and then **marshalling**
    (writing) Java content trees back into XML instance documents.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a JAXB root element called `Book`. `Book` has properties such as name
    and ISBN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MessageBodyReader` implementation class can provide support to read from
    an `inputStream` object and convert to the `Book` object. The following table
    shows the methods that need to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of MessageBodyReader | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isReadable()` | To check if the `MessageBodyReader` class can support conversion
    from stream to Java type. |'
  prefs: []
  type: TYPE_TB
- en: '| `readFrom()` | To read a type from the `InputStream`. |'
  prefs: []
  type: TYPE_TB
- en: 'Here is the code for `SampleMessageBodyReader` class that is the implementation
    of the `MessageBodyReader` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `@Provider` annotation indicates that this is a provider and the implementing
    class can also use `@Produces` and `@Consumes` annotations to restrict the media
    types they support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of `isReadable()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `isReadable()` method returns `true` to indicate that this `SampleMessageBodyReader`
    class can process the `mediaType` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: This is an implementation of the `readFrom()` method of the `SampleMessageBodyReader`
    class. The `mediaType` parameter can be checked here and different actions can
    be taken based on the media type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `book` object, which is the method's return value, is then unmarshalled
    using JAXB **Unmarshaller** using the provided `inputStream` object as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: MessageBodyWriter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MessageBodyWriter` interface represents a contract for a provider that
    supports the conversion from a Java type to a stream.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows how `MessageBodyWriter` can take a user-defined class,
    `Book,` and marshal it to an `outputStream` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![MessageBodyWriter](img/8125EN_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following table shows the methods of `MessageBodyWriter` that must be implemented
    along with a short description of each of its method.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of MessageBodyWriter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isWritable()` | To check if the `MessageBodyWriter class` can support the
    conversion from the specified Java type. |'
  prefs: []
  type: TYPE_TB
- en: '| `getSize()` | To check the length of bytes if the size is known or -1. |'
  prefs: []
  type: TYPE_TB
- en: '| `writeTo()` | To write from a type to the stream. |'
  prefs: []
  type: TYPE_TB
- en: 'Here are the methods of the `MessageBodyWriter` interface that need to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `isWritable()`method of the `MessageBodyWriter` interface can be customized
    to check if this implementation of `MessageBodyWriter` supports the type or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `getSize()` method is called before the `writeTo()` method to ascertain
    the length of bytes in the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `writeTo()` method marshals the `Book` to the `Outputstream`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tips for debugging errors with** `MessageBodyReader` **and** `MessageBodyWriter`
    **:**'
  prefs: []
  type: TYPE_NORMAL
- en: Look for the `@Provider` annotation. `MessageBodyReader` implementation class
    and `MessageBodyWriter` implementation class need the `@Provider` annotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm if the implementation classes of `MessageBodyReader` and `MessageBodyWriter`
    interfaces are added in the `getClasses()` method of the Application subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the implementation of `MessageBodyReader.isReadable()` method returns
    `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the implementation of `MessageBodyWriter.isWritable()` method returns
    `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirm the `MessageBodyWriter.getSize()` method is `-1` if the size of response
    is unknown or set it to the right value if the size is known.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how the client looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `client.register()` method is used to register the `MessageBodyReaderWriter.class`
    and `BooksResource.class`.
  prefs: []
  type: TYPE_NORMAL
- en: The application class, `Book` is extracted from the response using `response.readEntity(Book.class)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Bean Validation API with JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation is the process of verifying that the given inputs are complying with
    the defined constraints. The Bean Validation specification defines the API to
    validate **JavaBeans**. This section shows how to validate the JAX-RS 2.0 resources
    using the Bean Validation API.
  prefs: []
  type: TYPE_NORMAL
- en: Validation can be used to ensure that fields in the JAX-RS resources follow
    certain constraints. For example, to check that a field is not `null` or if the
    ISBN follows a pattern. Using Bean Validation, a user can write custom validators
    and annotate the JAX-RS resources and their components using the custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: The sample included along with the book will show how to use Bean Validation
    with JAX-RS 2.0 resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code snippet showing how to enforce validation along with defining
    a constraint and adding a user-defined message to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `@ValidateOnExecution` annotation can be used to selectively enable and
    disable the validation. In this snippet, the `getBook()` method gets validated
    because the `@ValidateOnExecution` annotation enables the validation for the `ExecutableType.GETTER_METHODS`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: When the sample code is executed, if the book value is not null then, the book
    object is returned. If the book value is null, there is a validation error with
    a message shown on the screen as `"Book does not exist for the ISBN requested"`.
    This is the message that is provided with the `@NotNull` annotation shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling validation in the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting validation errors from the response is not enabled by default. The sample
    included in the book will demonstrate how to get the validation errors from the
    response. The user needs to set `BV_SEND_ERROR_IN_RESPONSE` property to Boolean
    value `true` using `Application` class by overriding the `getProperties()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the `getProperties()` method of the `Application` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `getProperties()` method returns the `Map<String,Object>` object with the
    String property `ServerProperties.BV_SEND_ERROR_IN_RESPONSE` set to the Boolean
    value `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Reading validation errors from the response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After the application class is configured to set the String property `ServerProperties.BV_SEND_ERROR_IN_RESPONSE`
    to the Boolean value `true`, the following code in the servlet class will read
    the validation errors from the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the code looks on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `response.readEntity()` method takes a list of `GenericType<ValidationError>`
    parameters. From the `List<ValidationError>` `errors`, returned by the `response.readEntity()`
    method, we can extract the validation error and get the validation message. On
    running the sample, the following message will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**"There was 1 error when validating the request**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Book does not exist for the ISBN requested"**'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with a brief introduction to REST and the key principles
    of RESTful Web Services development, followed by converting a POJO to a JAX-RS
    resource, a RESTful endpoint along with discussing different HTTP verbs and their
    use.
  prefs: []
  type: TYPE_NORMAL
- en: After the introduction, the chapter dives deeper into the JAX-RS API by introducing
    the client API to send requests to the resources developed using the JAX-RS APIs.
    We also covered customizing the entity providers to produce different output formats
    using `MessageBodyReader` and `MessageBodyWriters`. We learned how to validate
    JAX-RS 2.0 resources using Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the different polling techniques, compare
    and contrast them with Server-sent events (SSE) and **WebSockets**, followed by
    a closer look at how Java EE 7 provides support for SSE and WebSockets.
  prefs: []
  type: TYPE_NORMAL
