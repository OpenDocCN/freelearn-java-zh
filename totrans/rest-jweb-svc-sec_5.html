<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Digital Signatures and Encryption of Messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Digital Signatures and Encryption of Messages</h1></div></div></div><p>Since many systems interact with each other to achieve their business goals, we often feel the obligation to interact with services exposed by others. Also, when security needs play an important role, we must verify that the information we receive has been sent from whom we expected, and it has come without being altered. It is here where digital signatures will play an important role and help us meet this need.</p><p>Also, we may sometimes need to encrypt the message body to prevent it from being read if intercepted by unwanted persons. It is here where we can make use of Secure/Multipurpose Internet Mail Extensions, or the S/MIME standard, which is commonly used in the world of e-mail for <a class="indexterm" id="id221"/>public keys (<a class="ulink" href="http://en.wikipedia.org/wiki/Public_key">http://en.wikipedia.org/wiki/Public_key</a>), encryption <a class="indexterm" id="id222"/>(<a class="ulink" href="http://en.wikipedia.org/wiki/Encryption">http://en.wikipedia.org/wiki/Encryption</a>), and signing (<a class="ulink" href="http://en.wikipedia.org/wiki/Digital_signature">http://en.wikipedia.org/wiki/Digital_signature</a>)<a class="indexterm" id="id223"/> of MIME data<a class="indexterm" id="id224"/> (<a class="ulink" href="http://en.wikipedia.org/wiki/MIME">http://en.wikipedia.org/wiki/MIME</a>), and which also offers the ability to adapt the HTTP protocol and allows us to use it on RESTful web services.</p><p>In this chapter, we are going to learn about the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Signing messages</li><li class="listitem" style="list-style-type: disc">Verifying signatures</li><li class="listitem" style="list-style-type: disc">Encrypting message bodies with S/MIME</li></ul></div><div class="section" title="Digital signatures"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Digital signatures</h1></div></div></div><p>Digital signatures, nowadays, are a <a class="indexterm" id="id225"/>widely used mechanism. They are mainly used to sign digital documents and issue electronic invoices, among other things.</p><p>Among the benefits of using them are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They allow the receiver to <a class="indexterm" id="id226"/>obtain the identity of whoever has made the signature.</li><li class="listitem" style="list-style-type: disc">They provide the ability to verify that the information sent has not been altered since it has been signed by the issuer.</li></ul></div><p>In order to electronically sign the information that we will exchange through RESTful web services, we will use the authentication mechanism known as <span class="strong"><strong>DomainKeys Identified Mail</strong></span> (<span class="strong"><strong>DKIM</strong></span>), which<a class="indexterm" id="id227"/> allows us to decorate messages with headers using the rules dictated by the DOSETA specification. This authentication mechanism is mainly used for e-mail identity verification; however, it also works <a class="indexterm" id="id228"/>over other protocols such as HTTP, and it is because of this fact we can integrate it with RESTful web services. Thus, we will inject metadata into our messages with the purpose of signing, and these signatures can be verified by those who wish to consume.</p><p>At this time, we will build an example that shows how to sign a message, and then dissect each part of it to understand its operation.</p><p>If you want, you can download the source code using the following link on GitHub:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/signatures</a>
</p><p>Otherwise, we will explain it in the following pages. Let's start by creating a new project. Open the terminal and type the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn archetype:generate -DgroupId=com.packtpub -DartifactId=signatures -DarchetypeArtifactId=webapp-javaee6 -DarchetypeGroupId=org.codehaus.mojo.archetypes</strong></span>
</pre></div><p>When it asks you for the version, change the default value <code class="literal">1.0-SNAPSHOT</code> to <code class="literal">1.0</code>
</p><p>Now, we will generate the keys that allow us to encrypt messages and place them in the classpath of our application. For this, we will first import the project into Eclipse IDE and then create a folder within the project in which we place the keys that we want to generate. In Eclipse, right-click on the new project named <code class="literal">signatures</code> and select the option <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Source folder</strong></span>.</p><p>In the field <span class="strong"><strong>Folder name</strong></span>, we will enter <code class="literal">src/main/resources</code>, and then we press the <span class="strong"><strong>Finish</strong></span> button.</p><p>Now, let's go to this directory from the command line and execute the following instruction:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -genkeypair -alias demo._domainKey.packtpub.com -keyalg RSA -keysize 1024 -keystore demo.jks</strong></span>
</pre></div><p>Now, we should enter a password for both the KeyStore and the keys with which we will sign the message. When it asks you for a password, type <code class="literal">changeit</code>, which is the same password we have been using so<a class="indexterm" id="id229"/> far in our examples in this book. Then, we enter the requested information as shown in the following screenshot:</p><div class="mediaobject"><img alt="Digital signatures" src="graphics/0109OS_05_01.jpg"/></div><p>Now, we will implement some source code to sign a message. We first need to add the required dependencies to the <code class="literal">pom.xml</code> file.</p><p>First, add the JBoss repository from which we get the artifacts, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;jboss&lt;/id&gt;
    &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;</pre></div><p>Now, let's add all the dependencies we need to sign our message, as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-crypto&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</pre></div><p>With the purpose<a class="indexterm" id="id230"/> of avoiding duplicated classes in the classpath, we should delete the following dependency:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;javax&lt;/groupId&gt;
      &lt;artifactId&gt;javaee-web-api&lt;/artifactId&gt;
      &lt;version&gt;6.0&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;</pre></div><div class="section" title="Updating RESTEasy JAR files"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Updating RESTEasy JAR files</h2></div></div></div><p>As we are using the 3.0.6.Final Version to compile the project, it is necessary to update the existing versions in JBoss. So, we will go to the URL <a class="ulink" href="http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/">http://sourceforge.net/projects/resteasy/files/Resteasy%20JAX-RS/</a> and download the version we just described.</p><p>When we unzip the <code class="literal">.zip</code> file, we will find a<a class="indexterm" id="id231"/> file named <code class="literal">resteasy-jboss-modules-3.0.6.Final.zip</code>. Let's unzip this file too, and then paste all its content in our directory <code class="literal">JBOSS_HOME/modules</code>. Given RESTEasy modules have dependencies, we have to update them too. So, after we update the RESTEasy modules, we <a class="indexterm" id="id232"/>should update the module <code class="literal">org.apache.httpcomponents</code>. Let's go to the directory <code class="literal">JBOSS_HOME/modules/org/apache/httpcomponents</code> and update the following artifacts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">httpclient-4.1.2.jar</code> to <code class="literal">httpclient-4.2.1.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">httpcore-4.1.4.jar</code> to <code class="literal">httpcore-4.2.1.jar</code></li></ul></div><p>Also, we modify the <code class="literal">module.xml</code> file because the names of the JAR files are different, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!--
 ...
  --&gt;

&lt;module  name="org.apache.httpcomponents"&gt;
    &lt;properties&gt;
        &lt;property name="jboss.api" value="private"/&gt;
    &lt;/properties&gt;

    &lt;resources&gt;
<span class="strong"><strong>        &lt;resource-root path="httpclient-4.2.1.jar"/&gt;</strong></span>
<span class="strong"><strong>       &lt;resource-root path="httpcore-4.2.1.jar"/&gt;</strong></span>
        &lt;resource-root path="httpmime-4.1.2.jar"/&gt;
        &lt;!-- Insert resources here --&gt;
    &lt;/resources&gt;

    &lt;dependencies&gt;
        &lt;module name="javax.api"/&gt;
        &lt;module name="org.apache.commons.codec"/&gt;
        &lt;module name="org.apache.commons.logging"/&gt;
        &lt;module name="org.apache.james.mime4j"/&gt;
    &lt;/dependencies&gt;
&lt;/module&gt;</pre></div></div><div class="section" title="Applying digital signatures"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Applying digital signatures</h2></div></div></div><p>Now that we have everything we need to compile our project, we will create a very simple operation and apply a <a class="indexterm" id="id233"/>signature. In order to achieve this, let's create a class called <code class="literal">SignedService</code> in the source code package called <code class="literal">com.packtpub.resteasy.services</code>, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Applying digital signatures" src="graphics/0109OS_05_02.jpg"/></div><p>To sign a message, we take a key from the KeyStore and use it. We can identify the keys in a unique way through their<a class="indexterm" id="id234"/> alias and the domain they belong to. For example, for the key <code class="literal">demo._domainKey.packtpub.com</code>, the alias is <code class="literal">demo</code> and the domain it belongs to is the key <code class="literal">packtpub.com</code>. Given that we can find several keys in a KeyStore, RESTEasy offers the capability to select the one we want by using the annotation <code class="literal">@Signed</code>.</p><p>Let's add the method highlighted in the following code to the class and watch how the annotation works:</p><div class="informalexample"><pre class="programlisting">  @POST
  @Produces("text/plain")
<span class="strong"><strong>  @Signed(selector = "demo", domain = "packtpub.com")</strong></span>
  public String sign(String input) {
    System.out.println("Aplyng signature " + input);
    return "signed " + input;
  }</pre></div><p>The following figure shows us in a better way how the key is selected to sign the message:</p><div class="mediaobject"><img alt="Applying digital signatures" src="graphics/0109OS_05_03.jpg"/></div><p>Now, we will define the path under<a class="indexterm" id="id235"/> our signed resources will be available, so let's annotate the class as follows:</p><div class="informalexample"><pre class="programlisting">import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;

import org.jboss.resteasy.annotations.security.doseta.Signed;

<span class="strong"><strong>@Path("/signed")</strong></span>
public class SignedService {
...</pre></div><p>In order to make the application work properly, we will give it information so that it can apply the appropriate signatures.</p><p>First, in the folder <code class="literal">src/main/webapp</code>, we will create the <code class="literal">WEB-INF</code> folder with an empty <code class="literal">web.xml</code> file inside.</p><p>Let's start with the <code class="literal">web.xml</code> file, which should look like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;

  &lt;display-name&gt;signatures&lt;/display-name&gt;

&lt;/web-app&gt;</pre></div><p>Now, the first thing we will do is tell our application what resource we want to sign, which is the class that contains the method that we are signing. For this, let's configure the parameter <code class="literal">resteasy.resources</code> with the corresponding full class name, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
&lt;param-name&gt;resteasy.resources&lt;/param-name&gt;
&lt;param-value&gt;com.packtpub.resteasy.services.SignedResource&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Next, we will inform our application of the location of the key with<a class="indexterm" id="id236"/> which we apply the signature (the <code class="literal">.jks</code> file we created earlier). For this, we have two context parameters available, <code class="literal">resteasy.doseta.keystore.classpath</code> and <code class="literal">resteasy.keystore.filename</code>. Let's use the first parameter so that our file looks like the following:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
&lt;param-name&gt;resteasy.doseta.keystore.classpath&lt;/param-name&gt;
&lt;param-value&gt;demo.jks&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>As you remember, we were asked for a password for the KeyStore when creating the key. We will tell our application what this is using the parameter <code class="literal">resteasy.doseta.keystore.password</code>. Let's add the following content:</p><div class="informalexample"><pre class="programlisting">  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.doseta.keystore.password&lt;/param-name&gt;
    &lt;param-value&gt;changeit&lt;/param-value&gt;
  &lt;/context-param&gt;</pre></div><p>To create the KeyStore from which we will extract the key that will allow us to sign the message, we must add the following parameter:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;resteasy.context.objects&lt;/param-name&gt;
  &lt;param-value&gt;org.jboss.resteasy.security.doseta.KeyRepository : org.jboss.resteasy.security.doseta.ConfiguredDosetaKeyRepository&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>Finally, we should add the RESTEasy servlet, as follows:</p><div class="informalexample"><pre class="programlisting">  &lt;servlet&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</pre></div><p>Here, we show how the <code class="literal">web.xml</code> file should look<a class="indexterm" id="id237"/> once you have finished adding all the required information:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
&lt;web-app&gt;
  &lt;display-name&gt;signatures&lt;/display-name&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.resources&lt;/param-name&gt;
    &lt;param-value&gt;com.packtpub.resteasy.services.SignedService&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.doseta.keystore.classpath&lt;/param-name&gt;
    &lt;param-value&gt;demo.jks&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.doseta.keystore.password&lt;/param-name&gt;
    &lt;param-value&gt;changeit&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;resteasy.context.objects&lt;/param-name&gt;
    &lt;param-value&gt;org.jboss.resteasy.security.doseta.KeyRepository : org.jboss.resteasy.security.doseta.ConfiguredDosetaKeyRepository&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p>Now, let's generate the WAR file by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn install</strong></span>
</pre></div><p>After this, we will copy the generated artifact in to the JBoss deploy directory.</p></div><div class="section" title="Testing the functionality"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Testing the functionality</h2></div></div></div><p>Now, open SoapUI and<a class="indexterm" id="id238"/> test whether the web service is running as expected, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_04.jpg"/></div><p>As you can see in the response, we obtain the <code class="literal">DKIM-Signature</code> header used to sign the message. The full content of this header is as follows:</p><div class="informalexample"><pre class="programlisting">DKIM-Signature: d=packtpub.com;s=demo;v=1;a=rsa-sha256;c=simple/simple;bh=lc+ECoAqpQCB4ItWLUomBv34m3F9G0pkIBAI8Z/yWcQ=;b=AlJY6iiCtdCnHrJa+Of9aRgBXeIp7V7cEG7eyUp0CRbD9wjFodbQGRQjhfwDgd1WIBzVLIWelTdI85BlGl3ACNcMLBjPv2iBBjo+78e/9HcYs81YNlPRAAj6jzymA/+jkmpTVcthWaEEyoPJJBAI5FvP33zH7etfkFaGX+bwer0=</pre></div><p>From this whole string, what is important for us are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d=</code>: This is the domain, the value which is indicated at the time we implement the method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">a=</code>: This is the algorithm used by RESTEasy to sign the message. In this case, we use RSA because it is the only algorithm that is supported to date by the framework.</li></ul></div><p>The other parameters are not very important, and they are only necessary for a signed message.</p><p>Now, in order to validate the authenticity of the signature, we will create a class from which we will make the verification.</p><p>We will use JUnit; so, first add the<a class="indexterm" id="id239"/> corresponding dependency in the <code class="literal">pom.xml</code> file, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.8.2&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre></div><p>Now, let's create a new source folder named <code class="literal">scr/test/java</code> and a package named <code class="literal">com.packtpub.resteasy.services.test</code> inside it. Inside the package, let's create the class <code class="literal">SignedServiceTest</code> using the following content:</p><div class="informalexample"><pre class="programlisting">import javax.ws.rs.client.Entity; 
import javax.ws.rs.client.Invocation; 
import javax.ws.rs.client.WebTarget; 
import javax.ws.rs.core.Response;  
import junit.framework.Assert;  
import org.jboss.resteasy.client.jaxrs.ResteasyClient; 
import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder; 
import org.jboss.resteasy.security.doseta.DosetaKeyRepository; 
import org.jboss.resteasy.security.doseta.Verification; 
import org.jboss.resteasy.security.doseta.Verifier; 
import org.junit.Test;

public class SignedServiceTest {

  @Test
  public void testVerification() {
    // Keys repository
    DosetaKeyRepository repository = new DosetaKeyRepository();
    repository.setKeyStorePath("demo.jks");
    repository.setKeyStorePassword("changeit");
    repository.start();
    // Building the client
  ResteasyClient client = new ResteasyClientBuilder().build();
    Verifier verifier = new Verifier();
    Verification verification = verifier.addNew();
    verification.setRepository(repository);
    WebTarget target = client
             .target(
      "http://localhost:8080/signatures-1.0/signed");
    Invocation.Builder request = target.request();
    request.property(Verifier.class.getName(), verifier);
    // Invocation to RESTful web service
    Response response = request.post(Entity.text("Rene"));
    // Status 200 OK
    Assert.assertEquals(200, response.getStatus());
    System.out.println(response.readEntity(String.class));
    response.close();
    client.close();
  }
}</pre></div><p>If everything goes well, we will see a green <a class="indexterm" id="id240"/>bar as a result of our test, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_05.jpg"/></div></div><div class="section" title="Validating signatures with annotations"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Validating signatures with annotations</h2></div></div></div><p>A simpler way to<a class="indexterm" id="id241"/> validate whether a resource is signed is to use annotations. This solution can be used mainly when you have a flow of signatures that must be met.</p><p>For example, imagine that<a class="indexterm" id="id242"/> employees of the company Packt Publishing have a system through which they can apply to increase the RAM of their computers. To treat such requests as valid, they must be signed by the person making the request. We mean that we only need that the request be signed to be considered valid, as shown in the following figure:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_06.jpg"/></div><p>For this example, we will add two methods to our <code class="literal">SignedService</code> class; the first method will allow us to send the requests, as shown:</p><div class="informalexample"><pre class="programlisting">  @POST
  @Path("ram")
  @Signed(selector = "demo", domain = "packtpub.com")
  @Consumes("text/plain")
  public String requestRam(int numberOfGB) {
    return numberOfGB + "-GB";
  }</pre></div><p>To meet the business requirements, we <a class="indexterm" id="id243"/>will use the <code class="literal">@Verify</code> annotation<a class="indexterm" id="id244"/> in which we can add restrictions on signatures. For now, we only need to verify that the request is signed.</p><p>The following is the method<a class="indexterm" id="id245"/> that shows all the complicated logic used by the boss to approve or deny memory increases to employee PCs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Verify</strong></span>
@POST
@Path("verifier")
@Produces("text/plain")
public String processRequestRam (String input) {
  int numberOfGbRequested = Integer.valueOf(input.split("-")[0]);
  if (numberOfGbRequested &gt; 4) {
    return "deny";
  } else {
    return "accepted";
  }
}</pre></div><p>Now, let's deploy the application on JBoss and test it with SoapUI. As we have mentioned, the requests must be signed in order to<a class="indexterm" id="id246"/> be processed. So, first make a request to the method <code class="literal">processRequestRam</code> without a signature, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_07.jpg"/></div><p>What is essential for the application to be processed is that it comes from the company domain, in this case, <code class="literal">packtpub.com</code>. Later, the boss conducts a rigorous analysis of the application and issues a judgment to determine whether the <a class="indexterm" id="id247"/>application is approved or rejected.</p><p>For this example, we will remove the method that we created earlier and add two methods to our <code class="literal">SignedService</code> class; the first method will allow us to send the requests, as shown:</p><div class="informalexample"><pre class="programlisting">@POST
@Signed(selector = "demo", domain = "packtpub.com")
@Consumes("text/plain")
public Response requestRAM(int numberOfGB) {
  return Response.seeOther(
    URI.create("/signed/" + "GB:" + numberOfGB)).build();
}</pre></div><p>The output shows us the error very clearly. The request couldn't be processed because there is no <code class="literal">DKIM-Signature</code> header that contains the information to verify the signature. This means that the headers aren't there because they weren't signed earlier.</p><p>In order to get the request successfully processed, we will call a web service that signs the request. We will add the<a class="indexterm" id="id248"/> headers with<a class="indexterm" id="id249"/> the signature information and call the <code class="literal">processRequestRam</code> method again.</p><p>Let' start by calling the <code class="literal">requestRam</code> operation, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_08.jpg"/></div><p>As a result of this callback, we will obtain the following values:</p><div class="informalexample"><pre class="programlisting">DKIM-Signature: d=packtpub.com;s=demo;v=1;a=rsa-sha256;c=simple/simple;bh=uA6n2udZlWdx+ouwCEeeyM6Q48KH0EWa2MnfBwMP+vM=;b=T0drw9QWud7rs1w//5384hs8GCatJKzmljIhgiTrHWdVx/IhCVl915yycchN+hQ+ljUaS6bPtLYo/ZNspcv2LtAe/tKTPpng4RWlr52k0TqnV3XX2KvJ7kBOpEU2Rg6f6lBOJT5v+o0iV05ObagfzKDfQ9o09WpZjQKcBG+/xvE=

RESPONSE: 8 GB</pre></div><p>Let's keep moving! Now, we will use these values to make a request. From SoapUI, let's invoke the <code class="literal">processRequestRam</code> operation and focus on the bottom-left area of our request editor; there is an option that says <span class="strong"><strong>Header</strong></span>. Let's select this option and click on the <span class="strong"><strong>+</strong></span> symbol. Now, we have to enter the <code class="literal">DKIM-Signature</code> header and place the corresponding value. Also, don't forget to send the request parameter <code class="literal">8-GB</code> that was the response of the invocation of the <code class="literal">requestRam</code> operation, as highlighted in the following screenshot:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_09.jpg"/></div><p>As we can see, the request was successfully processed, but the boss denied the increase of memory. Now, we<a class="indexterm" id="id250"/> indicate that digital signatures allow us to validate that the information is not altered once it has been signed. Suppose malicious software intercepted the response, and<a class="indexterm" id="id251"/> instead of <code class="literal">8-GB</code>, it delivered the value <code class="literal">12-GB</code>. Let's make this request in SoapUI following the theory of digital signatures. This request should not be valid; however, we must check:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_10.jpg"/></div><p>The error message clearly indicates that the message body was altered, so the request is not processed and we<a class="indexterm" id="id252"/> get the <code class="literal">HTTP 401 Unauthorized</code> message. This corroborates the statement made before regarding the integrity of the signed messages.</p><p>RESTEasy allows us, however, to<a class="indexterm" id="id253"/> do more than just validate that a message has been signed. We can verify that the signer belongs to a specific domain. In our example, a firm would be considered valid only when it comes under the <code class="literal">packtpub.com</code> domain. To perform this type of control, we will make the following change:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Verify(identifierName = "d", identifierValue = "packtpub.com")</strong></span>
@POST
@Path("verifier")
@Produces("text/plain")
public String processRequestRam(String input) {
  int numberOfGbRequested = Integer.valueOf(input.split("-")[0]);
  if (numberOfGbRequested &gt; 4) {
    return "deny";
  } else {
    return "accepted";
  }
}</pre></div><p>Let's deploy the application in JBoss and execute the request again from SoapUI:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_11.jpg"/></div><p>Now, let's force a fault. We will assume that<a class="indexterm" id="id254"/> valid messages are only those that are signed from the domain <code class="literal">itpacktpub.com</code>. So, let's apply the <a class="indexterm" id="id255"/>following change:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Verify(identifierName = "d", identifierValue = "itpacktpub.com")</strong></span>
@POST
@Path("verifier")
@Produces("text/plain")
public String processRequestRam(String input) {
  int numberOfGbRequested = Integer.valueOf(input.split("-")[0]);
  if (numberOfGbRequested &gt; 4) {
    return "deny";
  } else {
    return "accepted";
  }
}</pre></div><p>Let's deploy the application in JBoss again, and execute the request from SoapUI:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_12.jpg"/></div><p>As we expected, the request failed this time. Obviously, this happened because the signatures could not be verified<a class="indexterm" id="id256"/> as the message was signed with the <code class="literal">packtpub.com</code> domain and not with the <code class="literal">itpacktpub.com</code> domain as we set in the operation <code class="literal">processRequestRam</code>.</p><p>Suddenly, you wonder why the value of the identified name is <code class="literal">d</code>. As we mentioned before, the letter <code class="literal">d</code> represents the<a class="indexterm" id="id257"/> domain. The RESTEasy documentation explains a little more about each of the parameters in the header. Here, we show you an example from the documentation about JBoss related to this topic:</p><p><span class="emphasis"><em>Here's what an example DKIM-Signature header might look like:</em></span></p><p><span class="emphasis"><em>DKIM-Signature: v=1;</em></span></p><p><span class="emphasis"><em>                a=rsa-sha256;</em></span></p><p><span class="emphasis"><em>                d=example.com;</em></span></p><p><span class="emphasis"><em>                s=burke;</em></span></p><p><span class="emphasis"><em>                c=simple/simple;</em></span></p><p><span class="emphasis"><em>                h=Content-Type;</em></span></p><p><span class="emphasis"><em>                x=0023423111111;</em></span></p><p><span class="emphasis"><em>                bh=2342322111;</em></span></p><p><span class="emphasis"><em>                b=M232234=</em></span></p><p><span class="emphasis"><em>As you can see, it is a set of name value pairs delimited by a ';'. While it's not THAT important to know the structure of the header, here's an explanation of each parameter:</em></span></p><p><span class="emphasis"><em>v: Protocol version. Always 1.</em></span></p><p><span class="emphasis"><em>a: Algorithm used to hash and sign the message. RSA signing and SHA256 hashing is the only supported algorithm at the moment by RESTEasy.</em></span></p><p><span class="emphasis"><em>d: Domain of the signer. This is used to identify the signer as well as discover the public key to use to verify the signature.</em></span></p><p><span class="emphasis"><em>s: Selector of the domain. Also used to identify the signer and discover the public key.</em></span></p><p><span class="emphasis"><em>c: Canonical algorithm. Only simple/simple is supported at the moment. Basically, this allows you to transform the message body before calculating the hash.</em></span></p><p><span class="emphasis"><em>h: Semi-colon delimited list of headers that are included in the signature calculation.</em></span></p><p><span class="emphasis"><em>x: When the signature expires. This is a numeric long value of the time in seconds since epoch. Allows signer to control when a signed message's signature expires.</em></span></p><p><span class="emphasis"><em>t: Timestamp of signature. Numeric long value of the time in seconds since epoch. Allows the verifier to control when a signature expires.</em></span></p><p><span class="emphasis"><em>bh: Base 64 encoded hash of the message body.</em></span></p><p><span class="emphasis"><em>b: Base 64 encoded signature.</em></span></p><p>Now that we have this<a class="indexterm" id="id258"/> information, it is clear to assume that if you want to check the signer, instead of using the letter <code class="literal">d</code>, we must use the<a class="indexterm" id="id259"/> letter <code class="literal">s</code>, and instead of <code class="literal">packtpub.com</code>, we will use <code class="literal">demo</code>. Once you apply these changes, our code should look like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Verify(identifierName = "s", identifierValue = "demo")</strong></span>
@POST
@Path("verifier")
@Produces("text/plain")
public String processRequestRam(String input) {
  int numberOfGbRequested = Integer.valueOf(input.split("-")[0]);
  if (numberOfGbRequested &gt; 4) {
    return "deny";
  } else {
    return "accepted";
  }
} </pre></div><p>In addition, if you want to verify the signer's name and domain, you must apply a slight change. This time, we will use the <code class="literal">@Verifications</code> annotation; this annotation receives an array of <code class="literal">@Verify</code> annotations <a class="indexterm" id="id260"/>as a parameter, which allows us to perform what we described earlier. In this case, we should add two controls using the <code class="literal">@Verify</code> annotation, and our code should look like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>@Verifications({ </strong></span>
@Verify(identifierName = "s", identifierValue = "demo"),
<span class="strong"><strong>@Verify(identifierName = "d", identifierValue = "packtpub.com") })</strong></span>
@POST
@Path("verifier")
@Produces("text/plain")
public String processRequestRam(String input) {
  int numberOfGbRequested = Integer.valueOf(input.split("-")[0]);
  if (numberOfGbRequested &gt; 4) {
    return "deny";
  } else {
    return "accepted";
  }
}</pre></div><p>Once we have applied the changes, we can<a class="indexterm" id="id261"/> perform a request using SoapUI. We should get a successful execution as the result, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Validating signatures with annotations" src="graphics/0109OS_05_13.jpg"/></div></div></div></div>
<div class="section" title="Message body encryption"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Message body encryption</h1></div></div></div><p>In the previous chapter, we saw how to encrypt a complete HTTP message using HTTPS. Now, we will explain how we can encrypt just the<a class="indexterm" id="id262"/> message body and the differences between each process. We start by constructing a simple example, and then, as we perform the respective tests of our implementation, we'll understand how it works.</p><p>In order not to spoil our previous project, we will build a new one. For this, we will execute the following commands in the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn archetype:generate -DgroupId=com.packtpub -DartifactId=encryption -DarchetypeArtifactId=webapp-javaee6 -DarchetypeGroupId=org.codehaus.mojo.archetypes</strong></span>
</pre></div><p>As seen earlier in this chapter, when you get asked for a version, change the default value of <code class="literal">1.0-SNAPSHOT</code> to <code class="literal">1.0</code>.</p><p>Of course, if you want, you can download<a class="indexterm" id="id263"/> all the source code from GitHub from the following URL:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter05/encryption</a>
</p><p>Now, let's import the project into Eclipse, delete the existing default dependence in the <code class="literal">pom.xml</code> file, and add dependencies on the artifacts <code class="literal">resteasy-jaxrs</code> and <code class="literal">resteasy-crypto</code>.</p><p>The <code class="literal">dependencies</code> section should look like the following:</p><div class="informalexample"><pre class="programlisting">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-crypto&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</pre></div><p>Now, let's create the class <code class="literal">EncryptedService</code> inside the package <code class="literal">com.packtpub</code>. In this class, we will create a very simple operation, as shown:</p><div class="informalexample"><pre class="programlisting">package com.packtpub;

import javax.ws.rs.GET;
import javax.ws.rs.Path;

@Path("/encrypted")
public class EncryptedService {

  @GET
  public String gretting() {
    return "Hello world";
  }
}</pre></div><p>To register the services of our application, let's create the class <code class="literal">EncryptedApplication</code>, as shown:</p><div class="informalexample"><pre class="programlisting">package com.packtpub;

import java.util.HashSet;
import java.util.Set;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/services")
public class EncryptedApplication extends Application {

  private Set&lt;Object&gt; resources = new HashSet&lt;Object&gt;();

  public EncryptedApplication() throws Exception {
    resources.add(new EncryptedService());
  }

  @Override
  public Set&lt;Object&gt; getSingletons() {
    return resources;
  }
}</pre></div><div class="section" title="Testing the functionality"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Testing the functionality</h2></div></div></div><p>After this, our application <a class="indexterm" id="id264"/>should be ready. So, let's execute a test<a class="indexterm" id="id265"/> from SoapUI to watch the traffic using Wireshark, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_14.jpg"/></div><p>Wireshark shows us the following:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_15.jpg"/></div><p>As we can see, the traffic<a class="indexterm" id="id266"/> analyzer shows how all the information is<a class="indexterm" id="id267"/> traveling straight and how easily it is interpreted. Now, let's enable HTTPS on JBoss to show how the whole message is encrypted.</p></div><div class="section" title="Enabling the server with HTTPS"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Enabling the server with HTTPS</h2></div></div></div><p>So, first we have to<a class="indexterm" id="id268"/> create a certificate KeyStore. We can achieve this by executing the following command on the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>keytool -genkey -alias tomcat -keyalg RSA</strong></span>
</pre></div><p>When it asks you for a password, you should use <code class="literal">changeit</code> as we have already used it in this book.</p><p>Now, we look<a class="indexterm" id="id269"/> at the <code class="literal">JBOSS_HOME/standalone/configuration/standalone.xml</code> file, at the line containing <code class="literal">&lt;connector name="http"</code>, and add the following:</p><div class="informalexample"><pre class="programlisting">&lt;connector name="https" protocol="HTTP/1.1" scheme="https" 
socket-binding="https" secure="true"&gt;
  &lt;ssl/&gt;
&lt;/connector&gt;</pre></div><p>Once you've made this change, we will restart the application server, deploy the application, and edit<a class="indexterm" id="id270"/> the request. This time, we'll use port 8443 and the HTTPS protocol. So, the URL should look like the following:</p><p>
<code class="literal">https://localhost:8443/encryption-1.0/services/encrypted</code>
</p><p>Let's execute the request<a class="indexterm" id="id271"/> using SoapUI; our traffic analyzer will now show us the following result:</p><div class="mediaobject"><img alt="Enabling the server with HTTPS" src="graphics/0109OS_05_16.jpg"/></div><p>As we expected, this time, the analyzer shows us very clearly that all the information has been encrypted.</p><p>Moving forward with our example, we will now disable HTTPS in JBoss. For this, we have to remove the connector we added before. Now, we will use S/MIME in order to encrypt only the message body of the response. First, let's check some concepts that will help us understand how it works.</p><p>S/MIME comes from Secure MIME. MIME stands for Multipurpose Internet Mail Extension, which helps us to not only send<a class="indexterm" id="id272"/> messages such as "Hello world", but also to send more interesting content such as videos, audio, and so on. MIME works with e-mail protocols such as SMTP and HTTP. This helps us to work with RESTful S/MIME web services. On the<a class="indexterm" id="id273"/> other hand, MIME offers us the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Message encryption</li><li class="listitem" style="list-style-type: disc">Validating the identity of the user who sends the message </li><li class="listitem" style="list-style-type: disc">The capability to verify<a class="indexterm" id="id274"/> the information integrity of the message</li></ul></div><p>Given that S/MIME works with certifications, this is where the information of the message sender is saved. When<a class="indexterm" id="id275"/> the receiver gets the message, they observe all the public part of the message. The message can then be deciphered using a key. Also, the receiver can access its content. If you want to proceed further with S/MIME, we recommend you visit the link <a class="ulink" href="http://datatracker.ietf.org/wg/smime/charter/">http://datatracker.ietf.org/wg/smime/charter/</a>.</p><p>Let's start by making some changes. First, we will create the source folder <code class="literal">src/main/resources</code> in the application; in this directory, we will place the resources necessary to encrypt the message.</p><p>Then, we generate a certificate using <code class="literal">openssl</code>, go to the directory we just created from the console, and run the following at the command line on a terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout demokey.pem -out democert.pem</strong></span>
</pre></div><p>Now, we have to enter the requested information as shown in the following screenshot:</p><div class="mediaobject"><img alt="Enabling the server with HTTPS" src="graphics/0109OS_05_17.jpg"/></div><p>This will generate two files: <code class="literal">demokey.pem</code>, which is a private key, and <code class="literal">democert.pem</code>, which is a certificate we<a class="indexterm" id="id276"/> will use to encrypt the message body. To<a class="indexterm" id="id277"/> represent a signed response, RESTEasy uses the <code class="literal">EnvelopedOutput</code> object. In the following figure, we show you how RESTEasy encrypts messages:</p><div class="mediaobject"><img alt="Enabling the server with HTTPS" src="graphics/0109OS_05_18.jpg"/></div><p>Therefore, we must replace the return type of the method <code class="literal">gretting()</code> in the <code class="literal">EncryptedService</code> class. Let's change the string to <code class="literal">EnvelopedOutput</code> and encrypt the message body using the<a class="indexterm" id="id278"/> certificate we generated before. Applying these changes, our method should look like the following:</p><div class="informalexample"><pre class="programlisting">@GET
public EnvelopedOutput gretting() throws Exception {
  InputStream certPem = Thread.currentThread()
                       .getContextClassLoader()
                       .getResourceAsStream("democert.pem");
  X509Certificate myX509Certificate = PemUtils.
      decodeCertificate(certPem)
  EnvelopedOutput output = new 
    EnvelopedOutput("Hello world", MediaType.TEXT_PLAIN);
  output.setCertificate(myX509Certificate);
  return output;
}</pre></div><p>Let's make a change<a class="indexterm" id="id279"/> in the <code class="literal">pom.xml</code> file. We will modify the <code class="literal">dependencies</code> section in the following way:</p><div class="informalexample"><pre class="programlisting">  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.8.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxb-provider&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-crypto&lt;/artifactId&gt;
      &lt;version&gt;3.0.6.Final&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</pre></div><p>Notice how we changed the scope of the <code class="literal">resteasy-jaxrs</code> and <code class="literal">resteasy-jaxb-provider</code> artifacts; this is necessary to avoid duplicate classes when we encrypt the message. Since these<a class="indexterm" id="id280"/> artifacts are modules within the application server, you need to indicate that we want to<a class="indexterm" id="id281"/> load them. For this, we will modify the <code class="literal">pom.xml</code> file in the plugin section of <code class="literal">maven-war-plugin</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
  &lt;configuration&gt;
    &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;
    &lt;archive&gt;
      &lt;manifestEntries&gt;
        &lt;Dependencies&gt;org.jboss.resteasy.resteasy-jaxb-provider export, org.jboss.resteasy.resteasy-jaxrs export&lt;/Dependencies&gt;
      &lt;/manifestEntries&gt;
    &lt;/archive&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</pre></div><p>Since JBoss Version 7 is a module-based application server, by default, only a few modules are activated when it starts. If you want to access other modules, it is necessary to indicate these dependencies explicitly. This can be done through the <code class="literal">MANIFEST.MF</code> file or by creating a file called <code class="literal">jboss-deployment-structure.xml</code>.</p><p>In this case, we will choose the first file by using <code class="literal">maven-war-</code>plugin to indicate the required dependencies.</p><div class="section" title="Testing the functionality"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec14"/>Testing the functionality</h3></div></div></div><p>Now, let's make the<a class="indexterm" id="id282"/> request again from SoapUI to the URL <code class="literal">http://localhost:8080/encryption-1.0/services/encrypted</code>.</p><p>This time, the response we will get is shown in the following screenshot:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_19.jpg"/></div><p>The following is <a class="indexterm" id="id283"/>what we will see from the traffic analyzer:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_20.jpg"/></div><p>As we can see, it shows<a class="indexterm" id="id284"/> us something very similar to the response from SoapUI. To decrypt the content, it is necessary that we have the private key and certificate. Through these two resources, we can obtain the object <code class="literal">EnvelopedInput</code> and get the message from it, as shown in the following figure:</p><div class="mediaobject"><img alt="Testing the functionality" src="graphics/0109OS_05_21.jpg"/></div><p>This will be demonstrated in the following code through a unit test. However, before going forward, we want to show that when encrypting messages with S/MIME, headers remain readable but the message body is fully encrypted. So, if we do not have the resources, the information is outdated and cannot be interpreted.</p><p>Now, we will<a class="indexterm" id="id285"/> write a class that allows us to read the message body. For this, we will create a new source folder called <code class="literal">src/main/test</code>.</p><p>Within this folder, let's create the class <code class="literal">com.packtpub.EncryptedServiceTest</code> with the following content:</p><div class="informalexample"><pre class="programlisting">package com.packtpub;

import java.security.PrivateKey;
import java.security.cert.X509Certificate;

import javax.ws.rs.client.Client;
import javax.ws.rs.client.WebTarget;

import junit.framework.Assert;

import org.jboss.resteasy.client.jaxrs.ResteasyClientBuilder;
import org.jboss.resteasy.security.PemUtils;
import org.jboss.resteasy.security.smime.EnvelopedInput;
import org.junit.Test;

public class EncryptedServiceTest {

  @Test
  public void testEncryptedGet() throws Exception {
    // LOADING THE CERTIFICATE
    X509Certificate myX509Certificate = PemUtils.decodeCertificate(
        Thread
        .currentThread().getContextClassLoader()
        .getResourceAsStream("democert.pem"));
    // LOADING THE KEY
    PrivateKey myPrivateKey = PemUtils.decodePrivateKey(Thread
        .currentThread().getContextClassLoader()
        .getResourceAsStream("demokey.pem"));
    // CREATING A CLIENT FOR THE WEB SERVICE
    Client client = new ResteasyClientBuilder().build();
    WebTarget target = client.target(
      "http://localhost:8080/encryption-1.0/services/encrypted"
    );
    // RETRIEVING THE RESULT OF METHOD EXECUTION
    EnvelopedInput&lt;?&gt; input = target.request().
            get(EnvelopedInput.class);
    Assert.assertEquals("Hello world",
        input.getEntity(String.class, 
        myPrivateKey, myX509Certificate));
    client.close();
  }

}</pre></div><p>Note how we need <a class="indexterm" id="id286"/>both the private key and the certificate to decrypt the message to obtain the entity formed from a string containing the message <code class="literal">Hello world</code>.</p><p>When we run this unit test, we should get a green bar if all goes well. This indicates that to decrypt the message, using the previous resources (private key and certificate) has obtained the expected message.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>In this chapter, we worked with digital signatures and learned how to use them in RESTful web services. These days, digital signatures are often used because they guarantee message integrity, and information cannot be compromised while it is traveling from the sender to the receptor. We already know that information can be modified in transit, but when you're verifying the signed information, the receiver can notice it and take the actions that he/she believes are appropriate. For example, they can send another request to avoid working with corrupt information. At the end of this chapter, we worked with message body encryption, and we saw the difference between using these encryptions and HTTPS. Finally, we saw how the receiver, using the key, figured out the message body to make use of the information according to their needs.</p></div></body></html>