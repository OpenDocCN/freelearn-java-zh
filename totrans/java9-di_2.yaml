- en: Dependency Injection in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we got acquainted with the Dependency Injection Principle,
    IOC with different scenarios, and different types of Dependency Injection by writing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the new features offered in Java 9\. Specifically,
    we will learn about modularity in Java 9, modularity framework, types of modules
    offered in Java 9, and we will see Dependency Injection using modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will mainly cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular Framework in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection using Java 9 Modular Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before learning what's new in Java 9, we need to know one of the important components
    of Java, which is **Java Development Kit** (**JDK**).
  prefs: []
  type: TYPE_NORMAL
- en: JDK is a collection of **Java Standard Edition** (**Java SE**), **Java Enterprise
    Edition** (**Java EE**), **Java Micro Edition** platforms (**Java ME**), and different
    tools such as javac, Java console, JAR, JShell, Jlink, and it provides all the
    libraries for developing, debugging, and monitoring for building Java-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 has come up with almost over 100 new features and enhancements in different
    categories of JDK, such as tools, security, deployment, performance tuning, API
    changes of core libraries, and javadoc.
  prefs: []
  type: TYPE_NORMAL
- en: Key features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some of the key features of Java 9 in brief, which will change
    Java software development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Platform Module System** (**JPMS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JShell (REPL)—The Java Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JLink—Module Linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-Release JAR Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream API enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack—Walking API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable collections with convenient factory methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support of HTTP 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java Platform Module System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of **Java Platform Module System** (**JPMS**) is key and a
    game changer feature of Java 9 and JPMS developed under the shed of project Jigsaw.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main objectives of project Jigsaw are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalable JDK: Until Java 8, engineering of JDK is solid and contains a number
    of components, which make it troublesome to maintain and develop. JDK 9 is partitioned
    into sets of independent modules, which permits custom runtime capability to incorporate
    only required modules in our application, which offers assistance to diminish
    runtime size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Robust encapsulation and security: Bundles from the module can be expressly
    exposed if required by other modules. On the other hand, another module has to
    explicitly define which particular bundles are required from modules. This way,
    modules can encapsulate particular bundles for security purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency: Modern module frameworks permit us to define unequivocal dependency
    between modules and all required subset modules dependency can be distinguished
    at compile time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern rebuild permits us to incorporate runtime images of modules, which gives
    superior performance of JDK. It moreover evacuates `tools.jar` and `rt.jar` from
    runtime images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To secure the internal structure of runtime images, an unused URI conspire is
    utilized for naming modules, resources, and classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss JPMS in detail in the *Modular Framework in Java 9* section.
  prefs: []
  type: TYPE_NORMAL
- en: JShell (REPL) – The Java Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier JDK, we did not have the luxury of running code using a command line
    interface. For learning new functions such as the matches function of regular
    expression API and many more, we had to write a necessary skeleton of Java, `public
    static void main(String[] args)`, and go through the compilation and execution
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced JShell, a command line tool. It uses the **Read-Eval-Print
    Loop** (**REPL**) principle to provide a command line interface to interact with
    the Java platform and provide an interactive way of running a program without
    writing necessary skeletons.
  prefs: []
  type: TYPE_NORMAL
- en: JShell came up with a parser that parses submitted code and identifies different
    types such as a variable, a declared method, loop, and many more, and put them
    all together in a dummy skeleton to make a complete Java program to pass it to
    the compiler. Based on the inputs compiler, it converts it into byte code. During
    this process, a file is not created, so it will all be saved in memory. At the
    end, the generated byte code is used by JVM to load and execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'JShell is located in the `bin` directory of shipped JDK 9\. Using a command
    interface, traverse to the `bin` directory and type command `JShell` to start
    the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00013.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s consider a program that we used to write in IDE. Here is a simple program
    to print a string message into uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can get quick output of the preceding string message by directly writing
    a statement in the JShell tool, declaring variables and `println` statements is
    not required. JShell provides various command features that make a developer's
    life easy when writing quick code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00014.gif)'
  prefs: []
  type: TYPE_IMG
- en: JLink – Module Linker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are talking about modular systems, then immediately one question comes,
    how dependencies  of modules will organize and what will be impact on final deployment?
  prefs: []
  type: TYPE_NORMAL
- en: The JLink tool is designed to provide optional phases between compile time and
    runtime, called link time, which links a set of modules and its transitive dependencies
    to create runtime images. JLink makes deployment simpler and also reduces the
    size of an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The invocation syntax of `jLink` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Multi-release JAR files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many third-party libraries, support for several Java versions with
    backward compatibility. Because of this, they don't use the latest API features
    introduced in new releases of JDK. Since Java 8, there is no facility to define
    condition-based platform dependencies for using new features.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 introduced a multi-release jar concept. It allows developers to create
    alternative versions of each class, which are only used when running on specific
    Java versions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the structure of a multi-release jar. It contain
    resources and classes along with the Meta-INF directory for metadata. This metadata
    file contains version-specific details to encode jar files to provide a compatible
    method for multiple versions of libraries that run on a target Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: To continue on with the preceding example, we can see that the **javaMutipleJar**
    library has three classes, **Class1.class**, **Class2.class**, and **Class3.class**,
    at root level build with Java 8\. If we deploy this jar in JDK, which does not
    support MARJAR, then only the root level classes will be visible and later platform
    classes will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, **Class1.class** and **Class2.class** want to use Java 9 features,
    so then only those classes will bundle with Java 9 compilation. When Java 10 comes
    and **Class1.class** wants to use Java 10 features, then, as mentioned in the
    diagram, because of MARJAR concepts, it will bundle with the Java 10 platform.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, multi-release jar concepts help third-party library and framework
    developers to easily separate the use of new APIs for specific JDK for supporting
    migration as well as continuing to support older versions.
  prefs: []
  type: TYPE_NORMAL
- en: Stream API enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stream is a pipeline that contains elements in sequential form to support aggregation
    operations on collections of data. Stream API is a major feature of Java 8, which
    provides sequential and parallel execution with filtering based on criteria, all
    this together is known as internal iteration of Stream.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 added four new methods to make the Stream API better for iterating operations.
    `dropWhile` and `takeWhile  `methods are default methods and `iterate` and `ofNullable` are
    static methods in the `java.util.stream` interface. Let's discuss the `takeWhile`
    method use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stream API Syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00016.gif)'
  prefs: []
  type: TYPE_IMG
- en: The `takeWhile()` method returns the longest prefix, which matches the predicate
    for the ordered stream. As from the preceding code, `takeWhile` returns the first
    three elements because of matching with the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: For unordered streams, the `takeWhile()` method returns a prefixed element until
    the predicate condition is true. It stops iteration if the predicate condition
    returns false and returns a list of elements that predicate evaluated until the
    condition fails for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Stack-walking API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To debug exceptions, we look at the root cause of exception by traversing the
    stack trace. Prior to Java 9, we all used `Thread.getStackTrace()` to get `StackTraceElement`
    objects in the form of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '**StackTraceElement**: Each element of `StackTraceElement` is a single `StackFrame`,
    which provides details about classname, method name, filename, and line number
    where the exception was generated. Except for the first `StackFrame`, all the
    other elements represent the method invocation call from the starting point of
    the application to the point where the exception generated. This is helpful when
    we want auditing of generated error logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 StackWalker API provides several features such as filtering, asserting,
    and skipping certain classes in the stack trace. We can get either a full stack
    trace or  short stack trace for a current thread at any point.
  prefs: []
  type: TYPE_NORMAL
- en: 'StackWalker provides various methods for capturing information about stacks,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**forEach**: For the current thread it returns each StackFrame stream to perform
    actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getInstance()**: This returns the current instance of StackWalker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**walk()**: This is used to open a sequential stream for each StackFrame for
    the current thread, where we can apply functions such as limit, skip, and filter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Immutable collections with convenient factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times we directly add or remove elements from a collection, which is returned
    from the `factory` method. This collection is immutable and adding items into
    these collection gives us an exception called `UnSupportedOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such situations, we create immutable collection objects by using the `collections.unmodifiableXXX()`
    method. These methods are also tedious, such as writing multiple statements for
    adding individual items and then adding into it immutable `List` or `Set` or `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Java 9 provides convenient immutable factory methods such as `List.of(), Set.of()
    and Map.of()` to solve the previously mentioned issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: HTTP/2.0 support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used to connect servers using `HttpURLConnection`, which works in a single
    request/response cycle, and this eventually increases web page loading time and
    latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, the difference between HTTP/1.1 of older JDK and HTTP/2 of JAVA 9
    is that data is framed when transporting between clients and servers. HTTP/2 uses
    the `HttpClient` API to push data by using the server push feature, with this
    it allows us to prioritize and send required data for loading the web page first.
    The following example shows HTTP interaction for the `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Modular Framework in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we discussed several Java 9 features in brief. Now,
    in this section, we will learn about the Modular Framework and how it is used
    in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: What is modularity?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move to Java Platform Module System, let's understand the meaning
    of modularity in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity is a design that divides systems into smaller parts called a module.
    Nowadays, modular kitchens are installed in homes. These types of kitchen include
    several units or modules such as wall cabinets, cupboards, sinks, and many more
    and all these different parts are built in factories. If at any time there is
    damage in any unit, then only that module needs to be replaced or repaired.
  prefs: []
  type: TYPE_NORMAL
- en: Another familiar modular system is electric outlets in walls, which allow you
    to plug in different types of electrical gadgets such as microwaves, mixer grinders,
    refrigerators, televisions, and they are all designed to work on defined tasks.
    These devices work in any outlet without caring whether it is in our home or a
    neighbor's home, they just do their task and function when they are plugged in.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of computer systems, modularity is a concept of combination and linking
    of multiple independent modules in a single system. It increases usability and
    removes duplication of code and also makes a system loosely coupled. Similar to
    the electric outlet concept, modules should do their task without caring where
    they are plugged into an application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Java Platform Module System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Platform Module System** (**JPMS**) is also known as JSR 376 and is
    implemented under project Jigsaw. We have to understand why we need module systems
    in Java and what the changes in current JDK are.'
  prefs: []
  type: TYPE_NORMAL
- en: The need for a Java modular system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run a small or big application, a runtime environment up to Java 8 is required
    because JDK is built to support monolithic design. All libraries are tightly coupled
    with each other and for deployment full JDK is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: We all want an application to be loosely coupled, highly
    united, readable, and understandable. So we are using classes and packages. Day
    by day Java is growing exponentially in terms of size and packages to provide
    better features, but dependencies between packages is compromised. So we need
    something new that is better than packages for maintaining our code base.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JAR Hell**: Before Java 9,  The JVM does not have thought that how JAR on
    the class path depends on another Jar. It essentially loads a bunch of JARs, but
    it does not validate their dependencies. The JVM breaks the execution at runtime
    when a JAR is missing. The JARs don''t characterize accessibility constraints
    such as open or private. The whole substance of all JARs on the class path is
    totally visible to all the other JARs from the class path. There is no way to
    declare that a few classes in a JAR are private. All classes and methods are open
    related to the class path. Sometimes, we have jar files that contain multiple
    versions of a single class. The Java ClassLoader loads only one version of this
    class, and it does not determined which one. This creates uncertainty about how
    our program is  going to work. This issue is known as **JAR Hell**. The Module
    Path concept presented in Java 9 tends to illuminate issues caused by the class
    path.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit Dependency**: We have all seen the `NoClassDefFoundError` error
    a few times. It comes when JVM is not able to discover a class on which code it
    is executing. Finding depending code and lost dependency is simple, but dependency
    that is not in classLoader is troublesome to recognize, since there are chances
    that the same class is stacked by numerous class loaders. The current JAR framework
    is not able to express which other JAR file is dependent, so that JVM understands
    and resolves dependency.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lack of strong encapsulation**: Java''s visibility modifier provides strong
    encapsulation between classes of the same packages. Current Java encapsulation
    works with ClassPath where every public class is visible to other classes because
    several critical JDK API classes are open for other classes.'
  prefs: []
  type: TYPE_NORMAL
- en: All preceding issues are fixed with Java 9 module concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Modular JDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JDK 9 folder structure has changed compared to Java 8; JDK 9 does not have
    JRE, it is separately installed into a distinct folder. In JDK 9, we can see a
    new folder called jmod, which contains all the Java platform modules. Java 9 on
    wards `rt.jar` and `tool.jar` is not available in JDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'All Java modules, `src` are available from the `..\jdk-9.0.1\lib\src` folder,
    and each module includes `module-info.java`. The following is a diagram that shows
    how JDK looks with all modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Every other module implicitly or explicitly depends on the `java.base` module.
    It follows a directed acyclic graph dependency, which means no circular dependency
    is allowed between modules.
  prefs: []
  type: TYPE_NORMAL
- en: All modules in JDK 9 are by default dependent on the base module, known as the `java.base` module.
    It includes the `java.lang` package.
  prefs: []
  type: TYPE_NORMAL
- en: We can list all modules of Java 9 using the  command `-- list-modules`. Each
    module name is followed by a version number with string `-@9`, to indicate that
    the module belongs to Java 9\. A JDK 9 specific module is prefix with keyword ***jdk*** such
    as                                                            `jdk.compiler` and
    JAVA SE specific modules start with the ***java*** *keyword*.
  prefs: []
  type: TYPE_NORMAL
- en: What is a module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discuss modular systems, immediately you might ask what is a module?
    A module is a collection of code, data, and resources with self-descriptive properties.
    It contains a set of packages and types such as classes, abstract classes, interfaces,
    and so on, and also, most importantly, every module contains a `module-info.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: A module can explicitly declare which package needs to export for other modules
    and what is required from other modules in order to compile and run. This will
    also help us to identify which module is missing when we get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modules are the main building block of JPMS. Modules are similar to JARs, but
    have additional characteristics, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module Name**: A unique name to identify globally; a name can be defined
    by using inverse-URL naming convention'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare dependencies for other modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaration of API that needs to export as packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Module Descriptor (module-info.java)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`module-info.java` is an important file in the modular system, and it contains
    modular metadata which describes the behavior module. It is a Java file, but it
    is not like a traditional Java file. It has its own syntax and it''s compiled
    into the `module-info.class` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the syntax that we have to follow when creating `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the `module-info.java` file, where each module
    contains a unique ID and optional module descriptor details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand different module descriptors, mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**requires <module>**: This descriptor specifies that a module depends on another
    module to run this module, this type of relationship is called a *module dependency*.
    At runtime, modules only see modules that are required, and this is called Readability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**requires transitive <module>**: This means to indicate a dependency on another
    module and, moreover, to guarantee that other modules perusing your module read
    that dependency—known as implied readability.  For example, module A reads module
    B and module B reads module C, then module B needs to declare requires transitive,
    otherwise module A will not compile unless they read module C explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**requires static <module>**: By using a static keyword, dependency will be
    validated at compile time and it will be optional at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exports <package-name>**: This descriptor is used to export own packages
    to other modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exports <package-name> to <module-name>**: By using such descriptor statements,
    we export packages to specific modules, not to all modules. It''s called qualified
    export.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**opens <package-name>**: Opens descriptor used to define, only public types
    of packages are accessible to code in other modules at runtime only using reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**opens <package-name> to <module-name>**: A qualified open. This opens only
    a specific module that can access public type packages at runtime only through
    reflection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uses <service-interface>**: A module directive defined service used for this
    module. It makes a module as a service consumer. Service implementation can be
    in the same module or on another module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**provide <service-interface> with <class1>,<class2>** :  Specifies that a
    module contains service implementation of an interface defined in a modules''s
    uses descriptor. This makes a module a service provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are important points that we need to understand when creating
    a module descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: A module-info can have only a module name; means exports or requires clause
    are not mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a module descriptor has only exports then it means it is only exporting declared
    packages to other modules and it is not dependent on any other module. We can
    call them independent modules. For example, the `java.base` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opposite to the previous point, module descriptors might contain export and
    requires clauses, which means the module is exporting packages to other modules
    and is also dependent on other modules for its own compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There might be zero or more export or requires clauses in the module descriptor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we create a project, JDK 8 adds a JDK jar into our project ClassPath. But
    when we create a Java 9 module project, then JDK modules are added into ModulePath.
  prefs: []
  type: TYPE_NORMAL
- en: Module types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different types of modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named application modules**: This is a simple module that we can all create.
    Any third-party libraries can be application modules.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform modules**: As we have seen, JDK 9 itself migrated to modular architecture.
    All the existing features will be provided as different modules, such as `java.sql`,
    `java. desktop`, `java.transaction`. These are called Platform Modules. All modules
    are implicitly dependent on the `java.base` module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic modules**:  A pre-Java 9 JAR, which is not migrated to modules,
    can be placed in a module path without module descriptors. These are called automated
    modules. This JAR implicitly exports all their packages for other modules and
    also reads other modules along with unnamed modules. Because there is no unique
    name for an automatic module, JDK generates depending on the JAR filename by removing
    the version number and extension. For example, the file `postgresql-42.1.4.jar` as
    a module will be `postgresql`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unnamed modules**: JDK 9 does not remove classpaths. So all the JARs and
    classes placed on the class path are called Unnamed Modules. These modules can
    read all the modules and export all the packages, as they do not have a name.
    This module cannot be read or required by named application modules.'
  prefs: []
  type: TYPE_NORMAL
- en: In JDK 9, we have two module paths and class paths. Now we might ask which JAR
    goes where? So, the answer is, a modular jar with an application module goes into
    `--module-path`,  and a modular jar with an unnamed module can be placed into
    `--class-path`. Similarly, a non-modular jar can be migrated into an automatic
    module and goes into `--module-path`. If a jar contains an unnamed module, then
    it resides in `--class-path`.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection using the Java 9 Modular Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last topic we will learn about is molecularity and basics of  Java 9 modules.
    Now, we will learn how to write modules and how Dependency Injection is handled
    in modules.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 has the concept of Service Loader, which is related to IoC and Dependency
    Injection. New module systems do not provide Dependency Injection, but the same
    can be achieved by Service Loader and SPI (Service Provider Interface) Pattern.
    We will now see how this will work with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Modules with Service Loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service is a bunch of interfaces and classes collectively named a library,
    which delivers a specific functionality. Simply, we can say API. There are multiple
    usages for a service and they are called service providers (say implementations)
    . The client utilizing this service will not have any contact with the implementations.
    This can be accomplished by utilizing the underneath concept.
  prefs: []
  type: TYPE_NORMAL
- en: Java has `ClassLoader`, which simply loads the classes and creates instances
    of classes on runtime. Compared to Java 9 modules, `java.util.ServiceLoader` is
    capable of finding and loading all the service providers at a runtime for a service
    interface. The `ServiceLoader` class permits decoupling between the API and client
    app. The service loader will instantiate all the service providers that are implementing
    the service and makes it accessible to the client to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of Notification Application containing API and a different
    implementation of API. We will create three modules, the first one with a service
    (API) module, the second one will be a provider (Implementation) module, and the
    last one will be a client module for the accessing service.
  prefs: []
  type: TYPE_NORMAL
- en: Service (API) module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The created API module with the name `com.packt.service.api`  contains a `NotificationService`
    interface to send notification and load service providers. To make this interface
    a service provider interface (SPI), we have to mention the `''use''` clause in
    `module-info.java`. Our module code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`module-info.java` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following  are the command line steps that need to be followed for the `com.packt.service.api`
    module jar. Assume that there will be an out directory in the `com.packt.service.api`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Service provider (Implementation) module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, create a service provider module `com.packt.service.impl` to implement
    `NotificationService` service API, and for that we should define a "*provides
    ... with*" clause in the `module-info.java` file. The ***provides*** keyword is
    used to mention the service interface name and the ***with*** keyword is used
    to mention which implementation we want to load. In the event that the module
    doesn’t have the provides statement in the module descriptor file, the service
    loader will not load that module. The syntax of the ''*provides...with''* statement
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To send an SMS message to a recipient we are creating two implementation classes, `SMSServiceImpl.java ` and
    `EmailServiceImpl`, by implementing  `NotificationService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The module descriptor for this provider module will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a jar file of the `com.packt.service.impl` module, we have to copy
    `notification-api.jar` of the service API module into the lib folder for compile
    time dependency resolution. The outcome of the following commands will be `sms-service.jar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Service Provider Rules:'
  prefs: []
  type: TYPE_NORMAL
- en: It always has a no-argument constructor. This constructor is used by the `ServiceLoader`
    class to instantiate the service provider using reflection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The provider must be a public concrete class. It should not be an abstract class
    or inner class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An occurrence of the implementation class must be consistent with the service
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, create a client application named `com.packt.client`, which lists all
    implementation of `NotificationService` by calling the `getInstances()` method.
    A client application only *requires* the `com.packt.service.api` module as dependency
    in `module-info.java`. But we have to copy `notification-api.jar` and `sms-service.jar`
    into the lib folder to resolve compile time dependency of the service API and
    service provider module. Our `ClientApplication.java` and `module-info.java` will
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For our client application, we have to only mention the *requires* clause for
    `com.packt.service.api` in the `module-info.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are commands that need to run in order to run our client application.
    In the output we will get a message from `SMSServiceImpl.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.gif)'
  prefs: []
  type: TYPE_IMG
- en: Writing modular code using a command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a tradition, let's create a simple module called `helloApp`, which will have
    a simple message and will be required by another module called `helloClient`.
    Here, we will use a command line interface to create and run the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `helloApp` module folder named `com.packt.helloapp` and a package
    folder named `com\packt\helloapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a `HelloApp.java` component class under the package name `com.packt.helloapp\com\packt\helloapp`
    and a `modue-info.java` file at root folder `com.packt.helloapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create another module called `helloClient`. Create a `helloClient`
    module with the folder name `com.packt.hello.client` and a package with the folder
    name `com\packt\hello\client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create another component class called `HelloClient.java` under the `com.packt.hello.client\com\packt\hello\client`
    package and create a `module-info.java` file at root folder `com.packt.hello.client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both modules are independent modules so are not dependent on each other. But
    if we want to use a method called `sayHelloJava()` in the `HelloClient` class,
    then we have to import the module, otherwise it will give a compile time error
    `package com.packt.helloapp is not visible`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining dependency between modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use `HelloApp`, we need to export the package `com.packt.helloapp` from
    the `helloApp`  module and include the `helloApp` module in the `helloClient`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, the first module descriptor, the `exports` keyword,
    indicates that packages are available to export to other modules. If a package
    is explicitly exported, then it is only accessible by other modules. If in a same
    module some packages are not exported, then it cannot be accessed by other modules.
  prefs: []
  type: TYPE_NORMAL
- en: The second module descriptor uses the `requires` keyword to indicate that the
    module is dependent on the `com.packt.helloapp` module,  and this is called Dependency
    Injection in Java 9 Module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `HelloClient` class will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating two modules, the following will be the final tree structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.gif)'
  prefs: []
  type: TYPE_IMG
- en: But wait, we only wrote the code and have not compiled and run it yet. Let's
    do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and running modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first compile the `HelloApp` module and then the `HelloClient` module.
    Before running the command, make sure that the Java 9 ClassPath is set. To compile
    module code, the following command needs to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: On successful compilation it will generate `HelloApp.class` and `module-info.class`
    into the output directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our `HelloApp` module is required by the `HelloClient` module, we should
    generate the `com.packt.helloapp` module jar to include it in the `HelloClient`
    module. To create a jar in the `mlib` folder, run the following jar command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, remove the output directory by running the following command and again
    make an output directory for the second module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to compile the `HelloClient` module, we need to provide a reference
    of `com.packt.hellpapp.jar`  and `javac` commands and provide a way to pass `module-path` to
    refer to other modules. Here we pass the `mlib` directory as a module path. Without
    `module-path`, compilation of the `com.packt.hello.client ` module is not possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the module with the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'At the end of the preceding example, we learned how to create a module and
    define Dependency Injection in Java modules. The following diagram shows how one
    module is dependent on another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, the journey ends for Dependency Injection in Java 9\. Let's summarize
    what we learned from this chapter. Firstly, we learned key features introduced
    in Java 9, such as Java Platform Module System, JShell, JLink tool, multi-release
    of JAR, Enhanced Stream API, Stack-Walking PI, Immutable collection methods, and
    HTTP 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, in Modular Frameworks in Java 9 section,  we learned the meaning of
    modularity and the need of modular design in Java applications. We also learned
    how JPMS changes the earlier JDK into Modular JDK in detail.
  prefs: []
  type: TYPE_NORMAL
- en: After that we learned about an important element of modular systems, which is
    modules. We saw how module structure is defined with the help of different module
    descriptors and module types.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, we learned how to write simple modules using commands to understand
    how Dependency Injection works in Java 9 between modules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss concepts of Dependency Injection in Spring
    Framework in detail.
  prefs: []
  type: TYPE_NORMAL
