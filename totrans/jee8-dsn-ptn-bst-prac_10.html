<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deployment Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will be looking at deployment patterns, why we use them, and how they impact the delivery of applications. <span class="calibre10">We will also cover the concepts of canary deployment, blue/green deployment, A/B deployment, and continuous deployment. After reading this chapter, we should be familiar with the concept of deployment patterns. The topics we will cover in this chapter are as follows:</span></p>
<ul class="calibre15">
<li class="calibre16">The concept of deployment patterns</li>
<li class="calibre16">The concept of canary deployment</li>
<li class="calibre16">The concept of blue/green deployment</li>
<li class="calibre16">The concept of A/B testing</li>
<li class="calibre16">The concept of continuous deployment</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of deployment patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">Applications constantly receive updates that function to create new features or correct any problems. These new features and updates need to be promoted to a production-level without causing any problems or delays to a service. Furthermore, it is sometimes necessary to deliver a new version of an application to a select group of users, such as those in certain countries or certain business areas. </span></p>
<p class="mce-root"><span class="calibre10">When we talk about <em class="calibre12">delivery</em> in this context, we are referring to releasing a new version of an application into the production environment. </span>A software project has various steps that need to be evaluated and considered in order to permit the delivery of good software.</p>
<p class="mce-root">These steps include following a good process to get the business role, a good process for testing the application, a good process for developing the code of the application, and a good process for delivering the project to production, which is the aim of the project. All software projects have one important common objective—to deliver good, high-quality software without causing any collateral effects. The deployment step is a very important step in particular, as this is when the software is delivered; the overall goal of the project will be achieved here, but if any errors occur, then all projects can be impaired. As a result of this step, deployment patterns <span class="calibre10">were created.</span></p>
<p class="mce-root">Deployment patterns (also known as <strong class="calibre8">deployment strategies</strong>) are a set of solutions for common deployment-related problems. These patterns make the deployment process safer and mitigate the chance of errors occurring in <span class="calibre10">new releases</span>. Some examples of deployment patterns include:</p>
<ul class="calibre15">
<li class="calibre101">
<ul class="calibre15">
<li class="calibre16">Canary deployment</li>
<li class="calibre16">Blue/green deployment</li>
<li class="calibre16">A/B testing</li>
</ul>
</li>
</ul>
<p class="mce-root">Continuous deployment is <span class="calibre10">also </span>a deployment pattern, but we did not include this in the list because it is the most comprehensive method, one that creates a pipeline and works at all steps of the delivery. <span class="calibre10">Furthermore, continuous deployment more accurately describes the solution of automating the development stages, and this </span>can be used with any of the deployment patterns listed previously. With this, the patterns we mentioned work in reduced scope and the continuous deployment pattern works on a large scope. In the following diagram, you can see how these two types of deployment patterns work, as well as the stages they follow:</p>
<div class="cdpaligncenter"><img src="Images/5771a09c-d28f-4246-85b1-1ff5570dd062.png" class="calibre102"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In some literature, the concept of continuous deployment is covered together with the concept of continuous delivery. This is because these two concepts are very similar, with only some small differences between them. The difference between these concepts will be shown in detail in the <em class="calibre12"><span class="calibre10">Explaining the concept of continuous deployment</span></em> section of this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of canary deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As previously mentioned, when we write a new version of an application, we need to deliver it without stopping or delaying the service in any way. An important step, therefore, is to deploy and test the new version first. If an error occurs, we will then need to rollback the deployments and maintain the old version of the application until any problems with the new version are solved. The canary deployment was created to so solve deployment-related problems such as this.</p>
<p class="mce-root">The canary deployment is a deployment pattern that allows us to deliver a new version of an application to the subset of a server. T<span class="calibre10">hen, t</span>he new version of the application can be tested, and, if an error <span class="calibre10">occurs,</span> then the delivery rolls back and keeps the old version, propagating a new version for the remaining servers. <span class="calibre10">In this pattern,</span> we can define some servers as canary servers.<span class="calibre10"> The deployment first occurs in the canary server, after which a test is done on the canary server. If satisfied, the new </span><span class="calibre10">version is propagated (or deployed) to</span><span class="calibre10"> the remaining servers. This pattern consists of the following four basic steps:</span></p>
<ol class="calibre21">
<li class="chapter">Defining the canary servers</li>
<li class="chapter">Deploying the application to canary servers</li>
<li class="chapter">Testing the application and verifying whether it satisfies our criteria</li>
<li class="chapter">Deploying the application to the remaining servers</li>
</ol>
<p class="mce-root">The following diagram shows a visual representation of these steps:</p>
<div class="cdpaligncenter"><img src="Images/9dfe427c-2e3e-4013-96d7-be57c20f6979.png" width="707" height="114" class="calibre103"/></div>
<p class="mce-root">To implement the canary deployment as a solution for delivering an application, you will first need to configure a proxy that redirects the requests to servers that are not canary servers. The following diagram demonstrates how canary deployment works:</p>
<div class="cdpaligncenter"><img src="Images/be3223dc-d22e-4d4f-8083-6349e31cc926.png" width="817" height="507" class="calibre104"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the canary servers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, some servers will be selected as a canary server, which is the server used to test a new version after deploying an application in the remaining servers. Here, we select which servers should be the canary servers. It is very important to ensure that all steps of canary deployment are completed without impacting the users who access the application. Some important questions to consider when creating definitions are as follows:</p>
<ul class="calibre15">
<li class="calibre16">Do we want to test the behavior of an application in multiple instances of a server?</li>
<li class="calibre16">How many servers can I use as canary servers without impacting user access?</li>
<li class="calibre16">How well does my application work with the new version and the old version of an application in the same environment?</li>
<li class="calibre16">What tests will be executed?</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">The amount of canary servers used is very important, so we recommend that the number of canary servers does not exceed 50% of the total servers in the production environment. Furthermore, when defining the number of canary servers, we need to decide what kind of scenarios we will be testing for. Whether we test <span class="calibre10">the application's ability to work well with multiple servers or not, we will still need at least two canary servers. Using two canary servers is often a good idea, as the number is rarely larger than 50% of the total servers in the production environment. In other words, the total number of servers in the production environment is usually bigger than four. If we imagine that the total of servers in a production environment is four when we use two servers as canary servers, then the other two servers will be used to access the old version of the application. Depending on the number of users with access, the application should not have any performance problems.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the application to canary servers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">When an application is deployed in a canary server, the canary server cannot be accessed by users and the proxy cannot redirect a request to these servers. At this moment, the production environment stays with two versions of the application—the old version and the new version. The application needs to prepare to work with two versions in the same environment. Note that users don't lose access to the application in this scenario, and the deployment of newer versions is done with transparent behavior and without impacting users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Testing the application and verifying whether it satisfies our criteria</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, the application is tested to verify whether or not our criteria are satisfied. This is done by evaluating certain processes, such as integrating with other applications, CPU, memory, disk usage, and database connection. These tests can be done through an automation test, an internal user, or through a few end users. If an error is found in this step, the deployment is aborted and rolled back and the canary servers receive the old version, which is then made available to end users.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the application to remaining servers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This step is only initialized<span class="calibre10"> </span><span class="calibre10">if an application has been approved and verified as satisfactory. When this step is started, the canary server becomes a server for the end user access; the other servers do not receive a new request here because the process of deployment will have been started. The proxy then redirects all end users' requests to servers with a new version (in other words, the canary servers) and the deployment of another server is started. Once deployment is complete, all servers are able to receive access to the end users.</span></p>
<p class="mce-root">With canary deployment, the end user should not be aware that deployment is occurring. Users will only be aware<span class="calibre10"> </span>if an interface is changed, or if some functionality is made available or unavailable to them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of blue/green deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Blue/green deployment is very similar to canary deployment in the sense that it deploys new versions of an application using the process of partition. The blue/green method deploys the application into a subset of servers in the production environment and then propagates the new version to the remaining servers. This deployment pattern differs from canary deployment with regard to its goals, because the blue/green deployment aims to reduce an application's downtime during deployment. With canary deployment, however, the goal is to reduce the occurrence of an error in the production environment associated with the new version. Furthermore, with canary deployment, the production environment can stay with both a new version and an old version and receive requests simultaneously, while in a blue/green deployment, only one version responds to requests.</p>
<p class="mce-root">The <strong class="calibre8">blue/green deployment</strong> is a deployment pattern that makes it possible to deploy a new version of an application <span class="calibre10">without making the application inactive to the end user</span>. With this pattern, the deployment is effected with a group of servers. If the deployment is completed successfully, then the remaining servers are deployed. </p>
<p class="mce-root">This pattern has the following three steps:</p>
<ol class="calibre21">
<li class="chapter">Defining a group of servers to receive the first deployment</li>
<li class="chapter">Deploying the application to a group of servers</li>
<li class="chapter">Deploying the application to the remaining server</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the group of servers to receive the first deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">On the blue/green deployment, defining the group of servers to receive the first deployment is very easy because no tests will run and nothing will be checked; the process of deployment simply needs to be completed successfully. A good practice is to divide the production environment into two groups of servers and select one group to receive the deployment first. Each group will <span class="calibre10">generally </span><span class="calibre10">have approximately 50% of </span><span class="calibre10">production </span><span class="calibre10">servers. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the application to a group of servers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, the requests are redirected to the server of the group in order for it to deploy, and the group to deploy receives the deployment of a new version of an application. All servers of the group to deploy will be dead in this time and will only respond to requests once <span class="calibre10">the process of deployment in the group has finished. The following diagram illustrates an example of this process:</span></p>
<div class="cdpaligncenter"><img src="Images/694a306f-f915-4d48-978d-78615fdda8b5.png" class="calibre105"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the application to the remaining server</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This step is started only if the deployment process was successfully completed with the group that was selected to receive the first deployment. When this step is started, the group of servers selected to receive the first deployment returns to the activity, and all requests sent by the end user are processed by servers of this group with a new version deployed. The deployment of the remaining servers is then initialized, and, until deployment is complete, the remaining servers <span class="calibre10">are dead. When deployment is finished, all servers will be able to receive and process requests, and all servers will stay with the new version of the application. This process is illustrated in the following diagram:</span></p>
<div class="cdpaligncenter"><img src="Images/80e628d2-3fb3-4d54-8513-65fbcb3eb404.png" class="calibre106"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of A/B testing</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We may sometimes update something in our application and want to check its impact on end users and their behavior. Generally, these kinds of updates relate to the usability or popularity of an application and are associated with UI changes. To allow us to check the impact of an update on an application, we need to create groups of end users, who will be thrown the new updates and asked to evaluate them. The deployment patterns we've already discussed don't solve this problem for us as they're unable to<span class="calibre10"> throw a new version of the application to a separate group of end users. Although they allow us to test the functionality of the application in a separated group, that group doesn't persist for very long.</span></p>
<p class="mce-root">A/B testing, however, is a deployment pattern that allows us to throw a new version of an application to a selected group of end users<span class="calibre10"> only. This makes</span><span class="calibre10"> it possible to evaluate the impact of a new version of an application on end users and therefore decide whether or not it will be thrown to all end users. This deployment pattern is commonly used by popular applications such as Facebook, LinkedIn, and Twitter, as these applications are most successful when their features are popular among users. This pattern can be implemented with application-level switches or with a proxy that redirects end users to a respective application. The following diagram illustrates an example of the A/B testing pattern:</span></p>
<div class="cdpaligncenter"><img src="Images/e53a2846-5f73-4cf0-8a8c-dd691a948fca.png" width="743" height="459" class="calibre107"/></div>
<p class="mce-root">This pattern requires the four following steps:</p>
<ol class="calibre21">
<li class="chapter">Defining a group of end users to receive the new version of the application</li>
<li class="chapter">Defining the servers to receive a new version</li>
<li class="chapter">Deploying the new version of an application to selected servers</li>
<li class="chapter">Evaluating the impact of the new version of the application</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining a group of end users</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, we select a group of end users to receive a new version of an application. To define this group, a number of things need to be evaluated. Some of these evaluations include:</p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">The new features existing in a new version</span></li>
<li class="calibre16">The localization of end users</li>
<li class="calibre16">Business roles</li>
</ul>
<p class="mce-root">The end users selected for A/B testing need to be defined and marked by the application in order to allow it to distinguish between end users with access to the new version and those without. This can be done using a cookie, filtering by IP address if the group is location-related, or by using another mechanism that grants an end user access <span class="calibre10">to </span><span class="calibre10">the new version.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Defining the servers to receive a new version</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, we define the group of servers that will receive the deployment of a new version. The selection and amount of servers to receive the deployment needs to be evaluated by the percentage of end users that will be able to access the new version. Depending on various scenarios, we should also evaluate the localization of users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Deploying the new version</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, we deploy the new version of an application to the selected group of servers. These servers will then become dead and deployment will start. In this step, it is advisable to use either the canary deployment or the blue/green deployment to minimize the chance of error. Once deployment is complete, we will grant access to the new version of the application to the selected group of end users.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Evaluating the impact of a new version</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this step, we evaluate the impact of the new version of an application. This step can be done using many different tools and techniques, the use of which depends on what our goals for the new features are, what the roles involved with these new features are, and any other questions that may arise according to business logic. This task <span class="calibre10">generally </span><span class="calibre10">consists of collecting data and analyzing it to verify the way end users behave with new features. After the evaluation is complete, we can then decide whether to throw the new version to the remaining end users or to remove them from the application.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the concept of continuous deployment</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The process of delivery release to users consists of important steps, and we can sometimes pass these steps with a manual process. The world is moving on apace, and so the delivery of a release needs to be swift as well. With this in mind, automating processes is a great solution for increasing the speed of release delivery; continuous deployment was therefore created as an evolution of continuous delivery, which itself is an evolution of continuous integration. </p>
<p class="mce-root">Continuous deployment is a deployment pattern that creates a pipeline where each step is executed through an automated process. All steps are then executed without human intervention. If a new release enters the pipeline, all steps will be executed automatically unless an error occurs. It is important to know that continuous deployment is not continuous delivery or continuous integration—although these deployment patterns have many similarities, they are all different. The main difference between them is the level of automation present; for example, continuous integration is more automated than continuous delivery, which, in turn, is more automated than continuous deployment. The following diagram illustrates the pipeline of both deployment patterns and the level of automation they have:</p>
<div class="cdpaligncenter"><img src="Images/57ae1445-e53b-4b6b-a454-00ec0083fb4b.png" class="calibre108"/></div>
<p class="mce-root">The main goal of continuous deployment is to minimize the time between the development of a release and its delivery in a production environment. It automates the steps of the developer so as to minimize the scope for human error and make the delivery safer. As discussed, continuous deployment can be used together with blue/green deployment, canary deployment, and A/B testing, and these patterns will work in both the <em class="calibre12">Deploy to production</em> and <em class="calibre12">Post deploy test</em> <span class="calibre10">steps.</span></p>
<p class="mce-root">To implement continuous deployment, it is necessary to have a good testing culture. This is because the quality of tests will define the quality of the releases, as well as the success of its implementation. Furthermore, the documentation needs to update any new releases <span class="calibre10">together, with all</span><span class="calibre10"> updates in the application reflected in the documentation. </span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we covered deployment patterns, including canary deployment, blue/green deployment, A/B testing, and continuous deployment. We also covered the reasons to use these deployment patterns and how to decide how they're best used.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">In the <em class="calibre12">Explaining the concept of deployment patterns</em> <span class="calibre10">section, </span><span class="calibre10">we looked at the principal concepts of deployment patterns and looked at their uses in a business environment. Similarly, in</span> the <em class="calibre12">Explaining the concept of canary deployment</em>, <span class="calibre10"><em class="calibre12">Explaining the concept of blue/green deployment</em>, <em class="calibre12">Explaining the concept of A/B testing,</em> and <em class="calibre12">Explaining the concept of continuous deployment</em> sections, </span>we explored what each of the patterns are and why we use them. Finally, in the<span class="calibre10"> <em class="calibre12">Explaining the concept of continuous deployment</em></span> section, <span class="calibre10">we covered the differences between continuous integration, continuous delivery, and continuous deployment.</span></p>
<p class="mce-root">In the next chapter, we will cover the concepts of operational patterns, performance and scalability patterns, and management and monitoring patterns.</p>


            </article>

            
        </section>
    </div>



  </body></html>