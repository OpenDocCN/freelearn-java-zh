- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Garbage Collectors and Dynamic CDS Archives
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集器和动态 CDS 归档
- en: This chapter includes 15 problems covering garbage collectors and **Application
    Class Data Sharing** (**AppCDS**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括 15 个关于垃圾收集器和**应用程序类数据共享（AppCDS**）的问题。
- en: By the end of this chapter, you’ll have a profound understanding of how a **garbage
    collector** (**GC**) works and how you can tune it for maximum performance. Moreover,
    you’ll have a good understanding of how AppCDS can boost your application startup.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将深刻理解垃圾收集器是如何工作的，以及如何对其进行调整以实现最佳性能。此外，你将很好地理解 AppCDS 如何提高你的应用程序启动速度。
- en: Problems
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Use the following problems to test your advanced programming prowess in garbage
    collectors and application class data sharing in Java. I strongly encourage you
    to give each problem a try before you turn to the solutions and download the example
    programs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下问题来测试你在 Java 中垃圾收集器和应用程序类数据共享方面的高级编程能力。我强烈建议你在查看解决方案并下载示例程序之前，尝试解决每个问题：
- en: '**Hooking the garbage collector goal**: Introduce Java garbage collectors quickly.
    Highlight the main objectives (advantages) and disadvantages of a garbage collector.'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**挂钩垃圾收集器目标**：快速介绍 Java 垃圾收集器。强调垃圾收集器的主要目标（优点）和缺点。'
- en: '**Handling the garbage collector stages**: List and briefly describe the most
    common stages of a garbage collector.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理垃圾收集器阶段**：列出并简要描述垃圾收集器最常见的阶段。'
- en: '**Covering some garbage collector terminology**: A garbage collector has specific
    terminology. Provide here the main terms used in conjunction with garbage collectors.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**涵盖一些垃圾收集器术语**：垃圾收集器有特定的术语。在此提供与垃圾收集器一起使用的主要术语。'
- en: '**Tracing the generational GC process**: Exemplify and explain a hypothetical
    scenario containing several consecutive runs of a generational garbage collector.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**追踪代垃圾收集过程**：举例说明并解释一个包含多个连续运行代垃圾收集器的假设场景。'
- en: '**Choosing the correct garbage collector**: List and explain the three main
    factors that should be considered for choosing the correct garbage collector.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择正确的垃圾收集器**：列出并解释在选择正确的垃圾收集器时应考虑的三个主要因素。'
- en: '**Categorizing garbage collectors**: Highlight the main categories of garbage
    collector across JDK’s evolution.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分类垃圾收集器**：强调 JDK 发展历程中垃圾收集器的主要类别。'
- en: '**Introducing G1**: Provide a brief introduction to the G1 GC, including its
    design principles.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 G1**：简要介绍 G1 GC，包括其设计原则。'
- en: '**Tackling G1 throughput improvements**: List the main improvements of G1 GC
    throughput across JDK versions.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解决 G1 吞吐量改进**：列出 G1 GC 在 JDK 各个版本中的主要改进。'
- en: '**Tackling G1 latency improvements**: List the main improvements of G1 GC latency
    across JDK versions.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解决 G1 延迟改进**：列出 G1 GC 在 JDK 各个版本中的主要改进。'
- en: '**Tackling G1 footprint improvements**: List the main improvements of the G1
    GC footprint across JDK versions.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解决 G1 脚本改进**：列出 G1 GC 在 JDK 各个版本中的主要改进。'
- en: '**Introducing ZGC**: Provide a brief introduction to the Z Garbage Collector.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍 ZGC**：简要介绍 Z 垃圾收集器。'
- en: '**Monitoring garbage collectors**: Explain and exemplify at least one tool
    for monitoring garbage collectors.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控垃圾收集器**：解释并举例说明至少一个用于监控垃圾收集器的工具。'
- en: '**Logging garbage collectors**: Provide the steps needed to log the garbage
    collector activity. Moreover, highlight some tools capable of analyzing and plotting
    the logged data.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**记录垃圾收集器**：提供记录垃圾收集器活动的步骤。此外，强调一些能够分析和绘制记录数据的工具。'
- en: '**Tuning garbage collectors**: Explain how to tune garbage collectors, including
    G1 and ZGC.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调整垃圾收集器**：解释如何调整垃圾收集器，包括 G1 和 ZGC。'
- en: '**Introducing Application Class Data Sharing (AppCDS, or Java’s Startup Booster)**:
    Give a quick and practical guide to using CDS and AppCDS in JDK 10/11, 13, and
    19.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**介绍应用程序类数据共享（AppCDS，或 Java 的启动加速器）**：提供使用 JDK 10/11、13 和 19 中的 CDS 和 AppCDS
    的快速实用指南。'
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter12).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分描述了前面问题的解决方案。请记住，通常没有解决特定问题的唯一正确方法。此外，请记住，这里所示的解释仅包括解决这些问题所需的最有趣和最重要的细节。下载示例解决方案以查看更多细节，并在[https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter12)上实验程序。
- en: 243\. Hooking the garbage collector goal
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 243. 钩子垃圾回收器目标
- en: Every programming language has to manage memory usage. Some programming languages
    delegate this task to programmers, while others leverage different mechanisms
    to partially control how memory is used. Java programmers can focus 100% on the
    functionalities of the application and let the *garbage collector* manage how
    memory is used.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都必须管理内存使用。一些编程语言将这项任务委托给程序员，而其他编程语言则利用不同的机制来部分控制内存的使用方式。Java程序员可以100%专注于应用程序的功能，让*垃圾回收器*管理内存的使用。
- en: 'The name *garbage collector* suggests an entity capable of finding and collecting
    garbage from memory. Actually, a garbage collector is a very complex process representing
    the climax of Java memory management that is capable of tracking every object
    from the heap and identifying and removing the ones that are not used/referenced
    by the application. The main advantages of a garbage collector include:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*垃圾回收器*这个名字暗示了一个能够从内存中找到并收集垃圾的实体。实际上，垃圾回收器是一个非常复杂的过程，代表了Java内存管理的巅峰，能够跟踪堆中的每个对象，并识别和删除那些未被应用程序使用/引用的对象。垃圾回收器的主要优势包括：'
- en: The Java programmer doesn’t need to manually handle the allocation/deallocation
    of memory.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java程序员不需要手动处理内存的分配/释放。
- en: The Java programmer doesn’t need to deal with *dangling* and *wild pointers*
    ([https://en.wikipedia.org/wiki/Dangling_pointer](https://en.wikipedia.org/wiki/Dangling_pointer)).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java程序员不需要处理*悬挂指针*和*野指针*([https://en.wikipedia.org/wiki/Dangling_pointer](https://en.wikipedia.org/wiki/Dangling_pointer))。
- en: In a wide range of scenarios, a garbage collector prevents *memory leaks* ([https://en.wikipedia.org/wiki/Memory_leak](https://en.wikipedia.org/wiki/Memory_leak)).
    However, this issue is not 100% covered.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在各种场景中，垃圾回收器可以防止*内存泄漏*([https://en.wikipedia.org/wiki/Memory_leak](https://en.wikipedia.org/wiki/Memory_leak))。然而，这个问题并没有得到100%的解决。
- en: 'While these advantages are major, there are a few disadvantages as well:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些优势是主要的，但也有一些缺点：
- en: A garbage collector itself is a resource that needs CPU power to work. We’re
    talking about CPU power that is in addition to the CPU power needed by the application.
    More garbage collector activity requires more CPU power.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收器本身是一个需要CPU功率来工作的资源。我们说的是除了应用程序需要的CPU功率之外的CPU功率。更多的垃圾回收器活动需要更多的CPU功率。
- en: The programmer cannot control the garbage collector scheduler. This may cause
    performance issues at peaks or when the application deals with intensive computations.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员无法控制垃圾回收器的调度器。这可能在高峰时段或当应用程序处理密集型计算时导致性能问题。
- en: Some garbage collectors cause long and unpredictable pauses of the application.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些垃圾回收器会导致应用程序出现长时间且不可预测的暂停。
- en: Learning and tuning the correct garbage collector can be really cumbersome.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和调整正确的垃圾回收器可能真的非常繁琐。
- en: In the next problems, we’ll go deeper into this topic.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的问题中，我们将更深入地探讨这个主题。
- en: 244\. Handling the garbage collector stages
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 244. 处理垃圾回收器阶段
- en: 'During its work, GC passes through different stages or steps. It can pass through
    one or more of the following stages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在其工作过程中，GC会经过不同的阶段或步骤。它可以经过以下一个或多个阶段：
- en: '*Mark* – In this stage, the GC identifies and marks (or paints) all pieces
    of memory (blocks) that are used (have references) and not used (have no references).
    The marked (painted) blocks are called *live objects*, while the rest are called
    *non-live objects*. *Imagine that you go to the pantry and identify all the fresh
    fruits and vegetables and separate them from the spoiled ones*.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mark* – 在这个阶段，垃圾回收器识别并标记（或涂鸦）所有被使用（有引用）和未被使用（没有引用）的内存（块）。被标记（涂鸦）的块被称为 *活动对象*，而其余的则被称为
    *非活动对象*。*想象一下，你走进储藏室，识别所有新鲜的水果和蔬菜，并将它们与变质的水果和蔬菜分开*。'
- en: '*Sweep* – In this stage, the GC removes all *non-live objects* from memory.
    *Next, you take all the spoiled fruits and vegetables out of the pantry and throw
    them away*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Sweep* – 在这个阶段，垃圾回收器（GC）从内存中移除所有 *非活动对象*。*接下来，你将所有变质的水果和蔬菜从储藏室中取出并扔掉*。'
- en: '*Compact* – In this stage, the GC attempts to group the *live objects* closer
    together – in other words, it arranges the live objects at the start of the heap
    in a continuous sequence of memory blocks. So, compacting involves *defragmentation*
    and *relocation* of the *live objects*. The goal of compaction is to obtain large
    memory blocks that are free and ready to serve other objects. *Next, we go to
    the pantry and stack all the fruits and vegetables in crates so that we get as
    much free space as possible. We will use this space for other fruits and vegetables
    that we are going to buy*.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Compact* – 在这个阶段，垃圾回收器试图将 *活动对象* 组得更近一些——换句话说，它将活动对象在堆的起始处排列成一系列连续的内存块。因此，压缩涉及
    *碎片整理* 和 *重定位* 活动对象。压缩的目的是获得大块空闲内存，以便为其他对象提供服务。*接下来，我们进入储藏室，将所有水果和蔬菜堆叠在箱子里，以便尽可能多地获得空闲空间。我们将使用这个空间来存放我们打算购买的其他水果和蔬菜*。'
- en: '*Copy* – This is another stage dedicated to organizing memory. It is an alternative
    to the *mark* stage. In this stage, the GC moves the *live objects* into a so-called
    *ToSpace*. The rest of the objects are considered *non-live* and remain in the
    so-called *FromSpace*.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Copy* – 这是另一个专门用于组织内存的阶段。它是 *标记* 阶段的替代方案。在这个阶段，垃圾回收器将 *活动对象* 移动到所谓的 *ToSpace*。其余的对象被认为是
    *非活动对象*，并保留在所谓的 *FromSpace* 中。'
- en: 'Typically, a GC follows one of these three scenarios:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，垃圾回收器遵循以下三种场景之一：
- en: Mark -> Sweep -> Compact
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mark -> Sweep -> Compact
- en: Copy
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copy
- en: Mark -> Compact
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mark -> Compact
- en: Next, let’s cover some GC terminology.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来了解一下垃圾回收器的一些术语。
- en: 245\. Covering some garbage collector terminology
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 245. 涵盖一些垃圾回收器术语
- en: Garbage collection has its own terminology that it is essential to know in order
    to better understand how it works. Some of these terms are presented here; we
    start with *epoch*, *single pass*, and *multiple passes*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收有其自己的术语，了解这些术语对于更好地理解其工作方式至关重要。这里介绍了一些这些术语；我们首先从 *epoch*、*单次遍历* 和 *多次遍历*
    开始。
- en: Epoch
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Epoch
- en: A GC works in cycles. A complete cycle of a GC is known as an *epoch*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器在周期中工作。垃圾回收器的一个完整周期被称为 *epoch*。
- en: Single and multiple passes
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单次遍历和多次遍历
- en: A GC can handle its internal steps in a single pass (*single-pass*) or multiple
    passes (*multi-pass*). In the case of *single-pass*, the GC groups multiple steps
    and handles them in a single run. On the other hand, in the case of *multi-pass*,
    the GC handles multiple steps in a sequence of several passes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器可以在单次遍历（*单次遍历*）或多次遍历（*多次遍历*）中处理其内部步骤。在 *单次遍历* 的情况下，垃圾回收器将多个步骤组合在一起，并在单次运行中处理它们。另一方面，在
    *多次遍历* 的情况下，垃圾回收器在多个遍历的序列中处理多个步骤。
- en: Serial and parallel
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行和并行
- en: A GC is considered *serial* if it uses a single thread. On the other hand, a
    GC is considered *parallel* if it uses multiple threads.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果垃圾回收器使用单个线程，则被认为是 *串行* 的。另一方面，如果垃圾回收器使用多个线程，则被认为是 *并行* 的。
- en: Stop-the-World (STW) and concurrent
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stop-the-World（STW）和并发
- en: A GC is of the type *Stop-the-World* (STW) if it has to stop (temporarily suspend)
    the application execution in order to carry out its cycle. On the other hand,
    a GC is *concurrent* if it is capable of running at the same time as the application
    without affecting its execution.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果垃圾回收器（GC）必须停止（暂时挂起）应用程序执行以执行其周期，则它属于 *Stop-the-World*（STW）类型。另一方面，如果垃圾回收器（GC）能够在不影响其执行的情况下与应用程序同时运行，则它被认为是
    *并发* 的。
- en: Live set
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动集合
- en: A GC *live set* represents all the *live objects* of the current application.
    If there is no memory leak (or other issues), then the *live set* should have
    a constant load factor and a relatively constant size. During application execution,
    objects are added/removed from the heap and from the *live set* respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: GC的活跃集代表当前应用程序中所有的活跃对象。如果没有内存泄漏（或其他问题），那么活跃集应该具有恒定的负载因子和相对恒定的大小。在应用程序执行期间，对象分别从堆和活跃集中添加/移除。
- en: Allocation rate
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配率
- en: Java allows us to set the size of the heap memory via the `–Xmx` options. This
    size should not exceed the memory available on your machine (server) and should
    be big enough to serve the *live set*. This can be achieved by taking into account
    the *allocation rate*, which is expressed as the amount of memory (for instance,
    MB) allocated per unit of time (for instance, seconds).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许我们通过`–Xmx`选项设置堆内存的大小。这个大小不应超过您的机器（服务器）上的内存，并且应该足够大，以服务于*活跃集*。这可以通过考虑*分配率*来实现，它表示单位时间内分配的内存量（例如，MB）。
- en: '**Important note**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: As a rule of thumb, try to set the heap size as 2.5 to 5 times the average size
    of the *live set*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，尽量将堆大小设置为平均活跃集大小的2.5到5倍。
- en: In other words, when many objects are created, there will be many cleanups as
    well. This means that the GC will run at a high frequency and will need a higher
    *allocation rate*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当创建许多对象时，也会有大量的清理工作。这意味着GC将以高频率运行，并且需要更高的*分配率*。
- en: NUMA
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NUMA
- en: NUMA is the acronym for non-uniform memory access. A processor has its own memory
    (called local memory) but it can also access the memory of other processors. Access
    to its local memory is faster than access to non-local memory. Basically, NUMA
    is a memory architecture that attempts to optimize access to local memory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NUMA是“非一致性内存访问”的缩写。处理器有自己的内存（称为本地内存），但它也可以访问其他处理器的内存。访问其本地内存的速度比访问非本地内存快。基本上，NUMA是一种尝试优化本地内存访问的内存架构。
- en: Region-based
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于区域
- en: A *region-based* GC divides the heap into smaller (eventually equal) regions/chunks
    of memory (for instance, G1 and ZGC are *region-based* GCs). Each such region
    can be allocated for different purposes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于区域*的GC将堆划分为更小的（最终相等）的区域/内存块（例如，G1和ZGC是*基于区域*的GC）。每个这样的区域可以用于不同的目的。'
- en: Generational garbage collection
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代际垃圾回收
- en: '*Generational garbage collection* is an algorithm that excels in handling short-living
    objects. A GC that implements this algorithm is called a *generational GC*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*代际垃圾回收*是一种在处理短生命周期对象方面表现优异的算法。实现此算法的GC称为*代际GC*。'
- en: 'This algorithm distinguishes between *young* and *old* objects and keeps them
    separate. The *young* objects are kept in an area called the *Young* generation
    or *Nursery* space, while the *old* objects are kept in an area called the *Old*
    generation or *Tenured* space. The following figure highlights the transitions
    of objects through the *Young* and *Old* generations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法区分*年轻*和*老*对象，并将它们分开。*年轻*对象被保存在一个称为*年轻代*或*保育区*的空间中，而*老*对象被保存在一个称为*老年代*或*持久代*的空间中。以下图显示了对象通过*年轻代*和*老年代*的转换：
- en: '![Figure 12.1.png](img/B19665_12_01.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.1.png](img/B19665_12_01.png)'
- en: 'Figure 12.1: The transitions of objects through Young and Old generations'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：对象通过年轻代和老年代的转换
- en: As you can see, the *Young* generation is divided into two regions/spaces, named
    the *Eden* region or *Eden* space and the *Survivor* region or *Survivor* space.
    Initially, the *Young* generation is empty.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，*年轻代*被分为两个区域/空间，分别命名为*Eden*区域或*Eden*空间和*幸存者*区域或*幸存者*空间。最初，*年轻代*是空的。
- en: 'Objects that are newly created are placed in the *Eden* space by default. However,
    there is an exception for extremely large objects, called *humongous objects*,
    that exceed 50% of the region’s size. These objects are placed directly into the
    *Old* generation area, which may cause performance issues due to the increased
    occurrence of *major*/*full* GC events. It is important to note that GCs can trigger
    different types of events:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新创建的对象会被放置在*Eden*空间中。然而，对于超过区域大小50%的极大对象，称为*巨无霸对象*，它们会被直接放入*老年代*区域，这可能会因为*主要*/*完全*GC事件的增加而导致性能问题。重要的是要注意，GC可以触发不同类型的事件：
- en: '*MinorGC* – This event occurs in the *Young* generation when the *Eden* space
    becomes full. Its purpose is to collect *non-live* objects and promote the remaining
    ones into the *Survivor* space. This event is the most commonly triggered by a
    GC.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MinorGC* – 当 *Eden* 空间满时，这个事件发生在 *Young* 代。其目的是收集 *非活动* 对象并将剩余的促进到 *Survivor*
    空间。这个事件是最常由 GC 触发的。 '
- en: '*MajorGC* – This event occurs in the *Old* generation and is responsible for
    collecting garbage from this area.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MajorGC* – 这个事件发生在 *Old* 代，负责从这个区域收集垃圾。'
- en: '*MixedGC* – This is a *MinorGC* event followed by reclaiming the *Old* generation.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MixedGC* – 这是一个紧随其后的 *MinorGC* 事件，随后回收 *Old* 代。'
- en: '*FullGC* – Clean up the *Young* and *Old* generations and perform compacting
    of the *Old* generation (we can programmatically force a *FullGC* via `System.gc()`
    or `Runtime.getRunTime().gc()`).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FullGC* – 清理 *Young* 和 *Old* 代，并对 *Old* 代进行压缩（我们可以通过 `System.gc()` 或 `Runtime.getRunTime().gc()`
    程序化地强制执行 *FullGC*）。'
- en: Next, let’s return to the topic of the *Young* generation. During the *epoch*
    (a GC complete cycle), the objects that survive (have not been garbage collected)
    are promoted into the *Survivor* space (the GC algorithm chooses between *Survivor
    space 0* (known as *S0* or *FromSpace*) or *1* (known as *S1* or *ToSpace*)).
    The objects that don’t fit into the *Survivor* space (if any) will be moved into
    the *Tenured* space – this is known as *premature promotion*. Usually, the GC
    handles the *Eden* space pretty quickly via the *MinorGC* events. Using local
    variables with short-living methods encourages the usage of *Eden* space and sustains
    the GC’s performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到 *Young* 代的主题。在 *epoch*（一个 GC 完成周期）期间，存活的（未被垃圾回收）对象会被提升到 *Survivor*
    空间（GC 算法在 *Survivor space 0*（称为 *S0* 或 *FromSpace*）和 *1*（称为 *S1* 或 *ToSpace*）之间进行选择）。那些不适合
    *Survivor* 空间的对象（如果有）将被移动到 *Tenured* 空间——这被称为 *premature promotion*。通常，GC 通过 *MinorGC*
    事件快速处理 *Eden* 空间。使用具有短生命周期方法的局部变量鼓励使用 *Eden* 空间并维持 GC 的性能。
- en: Objects that are considered old enough (they have survived during multiple epochs)
    are eventually promoted into the *Old* generation. This is an area typically (but
    not mandatorily) larger than the *Young* generation. Some GCs use a fixed delimitation
    between these areas (for instance, the **Concurrent Mark Sweep** (**CMS**) GC)
    while others use an elastic boundary between these areas (for instance, the G1
    GC). The *Old* generation area takes a relatively long time to be garbage collected
    and has a lower frequency than the *Young* generation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是足够老的（它们在多个时代中存活下来）对象最终会被提升到 *Old* 代。这个区域通常（但不一定是）比 *Young* 代大。一些 GC 使用这些区域之间的固定界限（例如，**Concurrent
    Mark Sweep** （**CMS**）GC），而其他 GC 使用这些区域之间的弹性界限（例如，G1 GC）。*Old* 代区域回收垃圾所需的时间相对较长，频率低于
    *Young* 代。
- en: As you can see in *Figure 12.1*, the heap also contains an area named the *Metadata*
    space. Before JDK 8, this area was named *PermGenSpace* or *Permanent* generation.
    This area is used to store classes and methods. This area is specially designed
    to grow beyond the heap size into the native memory (if the size of this area
    goes beyond the physical memory, the operating system will use virtual memory
    – but be aware that moving data between physical and virtual memory is a costly
    operation that will affect the application performance). Via *Metadata* space,
    JVM avoids out-of-memory errors. However, this area can be garbage collected in
    order to remove unused classes/methods. In this context, there are a few flags
    that can help us to tune it, but we will cover these flags in *Problem 256*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *Figure 12.1* 中可以看到的，堆中还包含一个名为 *Metadata* 的区域。在 JDK 8 之前，这个区域被称为 *PermGenSpace*
    或 *Permanent* 代。这个区域用于存储类和方法。这个区域是专门设计用来在堆大小之外增长到本地内存（如果这个区域的大小超过了物理内存，操作系统将使用虚拟内存——但请注意，在物理内存和虚拟内存之间移动数据是一个昂贵的操作，这将影响应用程序的性能）。通过
    *Metadata* 空间，JVM 避免了内存不足的错误。然而，这个区域可以被垃圾回收以删除未使用的类/方法。在这种情况下，有几个标志可以帮助我们调整它，但我们将这些标志放在
    *Problem 256* 中讨论。
- en: 246\. Tracing the generational GC process
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 246. 跟踪代 GC 过程
- en: 'In this problem, let’s start from an arbitrary initial state of a generational
    GC and follow a few hypothetical epochs (generally, all generational GC works
    more or less as you’ll see in this problem). We start with the following diagram:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，让我们从一个任意初始状态的代 GC 开始，并跟随几个假设的时代（通常，所有代 GC 的工作方式与你在这个问题中看到的方式大致相同）。我们从一个以下图表开始：
- en: '![Figure 12.2.png](img/B19665_12_02.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.2.png](img/B19665_12_02.png)'
- en: 'Figure 12.2: GC initial state'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：GC 初始状态
- en: 'At its initial state, the GC has an almost full *Eden* space (it stores objects
    1, 4, 5, 2, 6, and 3, and some free space – represented by those white gaps between
    objects) and empty *Survivor* and *Tenured* spaces. Moreover, object 7 should
    be added in the *Eden* space but there is not enough memory for it. When the *Eden*
    space cannot accommodate more objects, the GC triggers a *MinorGC* event. First,
    the *non-live objects* are identified. Here (as you can see in the following diagram),
    we have three objects (5, 2, and 3) that should be collected as garbage:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在其初始状态，GC 有一个几乎满载的 *Eden* 空间（它存储了对象 1、4、5、2、6 和 3，以及一些空闲空间——由对象之间的白色间隙表示），*Survivor*
    和 *Tenured* 空间为空。此外，对象 7 应该被添加到 *Eden* 空间中，但内存不足以容纳它。当 *Eden* 空间无法容纳更多对象时，GC 触发一个
    *MinorGC* 事件。首先，识别 *non-live objects*。这里（如图所示），我们有三个对象（5、2 和 3）应该被收集为垃圾：
- en: '![Figure 12.3.png](img/B19665_12_03.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.3.png](img/B19665_12_03.png)'
- en: 'Figure 12.3: Identify the non-live objects from the Eden space'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：识别 *Eden* 空间中的非活动对象
- en: 'These three objects are collected as garbage, so they are removed from the
    heap. Next, the *live objects* (1, 4, and 6) are moved into *Survivor space 0*.
    Finally, the new object (7) is added into the *Eden* space, as in the following
    figure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对象被收集为垃圾，因此它们被从堆中移除。接下来，*live objects*（1、4 和 6）被移动到 *Survivor space 0*。最后，新的对象（7）被添加到
    *Eden* 空间中，如图所示：
- en: '![Figure 12.4.png](img/B19665_12_04.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.4.png](img/B19665_12_04.png)'
- en: 'Figure 12.4: Removing objects from memory (5, 2, and 3), moving objects to
    Survivor space 0 (1, 4, and 6), and adding object 7 into the Eden space'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4：从内存中移除对象（5、2 和 3），将对象移动到 *Survivor space 0*（1、4 和 6），并将对象 7 添加到 *Eden*
    空间
- en: Here, an *epoch* (complete GC cycle) has ended.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个 *epoch*（完整的 GC 循环）已经结束。
- en: 'Later on, more objects are added into the *Eden* space until it is almost full
    again:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，更多的对象被添加到 *Eden* 空间中，直到它再次几乎满载：
- en: '![Figure 12.5.png](img/B19665_12_05.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.5.png](img/B19665_12_05.png)'
- en: 'Figure 12.5: The Eden space is almost full again'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5：*Eden* 空间再次几乎满载
- en: 'Adding the new object (12) requires a *Minor GC* event. Again, the *non-living
    objects* are identified as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的对象（12）需要触发一个 *Minor GC* 事件。再次，*non-living objects* 被识别如下：
- en: '![Figure 12.6.png](img/B19665_12_06.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.6.png](img/B19665_12_06.png)'
- en: 'Figure 12.6: There are non-live objects in the Eden and Survivor 0 spaces'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6：在 *Eden* 和 *Survivor 0* 空间中存在非活动对象
- en: 'There are four objects that should be collected as garbage. In the *Eden* space,
    there are three objects (11, 10, and 9), and in *Survivor space 0*, there is one
    object (4). All four of these objects are removed from the heap. The *live objects*
    from *Survivor space 0* (1 and 6) are moved to *Survivor space 1*. The *live objects*
    from the *Eden* space (7 and 8) are also moved into *Survivor space 1*. At any
    moment in time, one of the *Survivor* spaces is empty. Finally, the new object
    (12) is added to *Eden* space, as in the following figure:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个对象应该被收集为垃圾。在 *Eden* 空间中，有三个对象（11、10 和 9），在 *Survivor space 0* 中有一个对象（4）。这四个对象都被从堆中移除。*Survivor
    space 0* 中的 *live objects*（1 和 6）被移动到 *Survivor space 1*。*Eden* 空间中的 *live objects*（7
    和 8）也被移动到 *Survivor space 1*。在任何时刻，一个 *Survivor* 空间都是空的。最后，新的对象（12）被添加到 *Eden*
    空间中，如图所示：
- en: '![Figure 12.7.png](img/B19665_12_07.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.7.png](img/B19665_12_07.png)'
- en: 'Figure 12.7: At the end of another epoch'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：另一个时代的结束
- en: Here, another epoch has ended.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，另一个时代已经结束。
- en: 'Next, objects 13, 14, 15, and 16 are added to the *Eden* space, which is almost
    full again:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对象 13、14、15 和 16 被添加到 *Eden* 空间中，它再次几乎满载：
- en: '![Figure 12.8.png](img/B19665_12_08.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.8.png](img/B19665_12_08.png)'
- en: 'Figure 12.8: There is no memory available for object 17'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8：没有可用内存为对象 17 分配
- en: 'Being almost full, the *Eden* space cannot accommodate the new object, 17\.
    A new *Minor GC* event is triggered and objects 12, 15, 16, 13, 6, and 8 are identified
    as *non-live objects*:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 *Eden* 空间几乎满载，它无法容纳新的对象 17。一个新的 *Minor GC* 事件被触发，对象 12、15、16、13、6 和 8 被识别为
    *non-live objects*：
- en: '![Figure 12.9.png](img/B19665_12_09.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.9.png](img/B19665_12_09.png)'
- en: 'Figure 12.9: There are several non-live objects in different spaces'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9：在不同空间中有几个非活动对象
- en: 'These objects (12, 15, 16, 13, 6, and 8) are removed from the heap. Next, object
    14 is moved from the *Eden* space to *Survivor space 0*. Afterward, objects 1
    and 7 (from *Survivor space 1*) are moved into *Survivor space 0*. Finally, the
    new object 17 is moved into the *Eden* space, as in the following figure:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象（12、15、16、13、6和8）从堆中移除。接下来，对象14从**伊甸空间**移动到**幸存者空间0**。之后，对象1和7（来自**幸存者空间1**）被移动到**幸存者空间0**。最后，新对象17被移动到**伊甸空间**，如图所示：
- en: '![Figure 12.10.png](img/B19665_12_10.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.10.png](img/B19665_12_10.png)'
- en: 'Figure 12.10: The new object (17) is added to the Eden space'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：新对象（17）被添加到伊甸空间
- en: Here, another *epoch* has ended.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，另一个**时代**已经结束。
- en: 'We repeat the scenario and fill up the *Eden* space again. We stop when object
    22 should be added into the *Eden* space:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复这个场景，再次填满**伊甸空间**。当我们应该将对象22添加到**伊甸空间**时停止：
- en: '![Figure 12.11.png](img/B19665_12_11.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.11.png](img/B19665_12_11.png)'
- en: 'Figure 12.11: Trying to add in Eden space object 22'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：尝试在伊甸空间添加对象22
- en: 'As we already know, the GC marks all the *non-live objects* (here, 17, 21,
    18, and 7):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，GC标记了所有**非活动对象**（在这里，17、21、18和7）：
- en: '![Figure 12.12.png](img/B19665_12_12.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.12.png](img/B19665_12_12.png)'
- en: 'Figure 12.12: Marking the non-live objects'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：标记非活动对象
- en: 'This time, the GC promotes object 1 (when it is considered old enough) from
    the *Young* generation to the *Old* generation. Next, the objects from the *Eden*
    space (19 and 20) and the objects from *Survivor space 0* (14) are moved into
    *Survivor space 1*. The result is sketched in the next figure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，垃圾收集器（GC）将对象1（当它被认为足够老时）从**年轻**代提升到**老**代。接下来，来自**伊甸空间**（19和20）的对象和来自**幸存者空间0**（14）的对象被移动到**幸存者空间1**。结果如图所示：
- en: '![Figure 12.13.png](img/B19665_12_13.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.13.png](img/B19665_12_13.png)'
- en: 'Figure 12.13: We have the first object promoted to Old generation'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：我们第一个提升到老代的对象
- en: At the end of this *epoch*, we finally have an object (1) in *Tenured* space.
    Continuing to run *epoch* after *epoch* will eventually fill up the *Tenured*
    space, which will not be able to accommodate more objects. In other words, the
    *Minor GC* events (which are *stop-the-world* events) will reclaim the memory
    of the *Young* generation until the *Old* generation is full. When that happens,
    a *Mixed GC* or even *Full GC* event will be triggered (the *Full GC* is also
    an STW event and will handle the *Metadata* space as well).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个**时代**结束时，我们最终在**持久代**中有一个对象（1）。继续运行**时代**最终会填满**持久代**，这将无法容纳更多对象。换句话说，**小GC**事件（这些是**停止世界**事件）将回收**年轻代**的内存，直到**老代**填满。当这种情况发生时，将触发**混合GC**甚至**全GC**事件（**全GC**也是一个STW事件，并将处理**元数据**空间）。
- en: In a nutshell, this is how a GC works. Of course, there are many other internal/external
    factors that may influence the GC’s decisions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是GC的工作方式。当然，还有许多其他内部/外部因素可能会影响GC的决策。
- en: 247\. Choosing the correct garbage collector
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 247. 选择正确的垃圾收集器
- en: 'As you’ll see in the next problem, Java allows us to choose between several
    garbage collectors. There is no silver bullet, so choosing the correct garbage
    collector for your particular application is an important decision that should
    be made based on three factors: *throughput*, *latency*, and *footprint*.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一个问题中看到的，Java允许我们在几个垃圾收集器之间进行选择。没有银弹，因此为你的特定应用程序选择正确的垃圾收集器是一个重要的决定，应该基于三个因素：**吞吐量**、**延迟**和**占用空间**。
- en: '![Figure 12.14.png](img/B19665_12_14.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.14.png](img/B19665_12_14.png)'
- en: 'Figure 12.14: The factors that affect the choice of GC'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：影响GC选择的因素
- en: '*Throughput* represents the total time spent running the application code vs.
    running the GC. For instance, your application may run 97% of the total time,
    so you have a throughput of 97%. The remaining 3% is the time spent running the
    GC.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**吞吐量**表示运行应用程序代码所花费的总时间与运行GC所花费的时间之比。例如，你的应用程序可能运行了总时间的97%，因此你有97%的吞吐量。剩余的3%是运行GC所花费的时间。'
- en: '*Latency* measures how much the execution of the application is delayed by
    pauses caused by the GC. This is important because latency can affect the application’s
    responsiveness. These pauses may lead, at the interactivity level, to an unpleasant
    experience for the end users.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟**衡量了应用程序执行因GC导致的暂停而延迟的程度。这很重要，因为延迟会影响应用程序的响应性。这些暂停可能导致在交互层面给最终用户带来不愉快的体验。'
- en: '*Footprint* represents the extra memory needed by the GC to run its algorithms.
    This is the memory needed in addition to the memory used by the application itself.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存占用*表示GC运行其算法所需的额外内存。这是除了应用程序本身使用的内存之外的内存需求。'
- en: Choosing the proper GC based on these three factors is a very subjective decision.
    You may need a massive throughput while you can bear latencies, or you may not
    be able to afford latencies because you have high interactivity with the end users,
    or your scalability is in direct correlation with limited physical memory, so
    you are really interested in the footprint factor. As you’ll see in the next problem,
    each GC type has its own advantages and disadvantages in the context of these
    three factors.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这三个因素选择合适的GC是一个非常主观的决定。你可能需要巨大的吞吐量同时可以忍受延迟，或者你可能无法承受延迟，因为你与最终用户有高度交互，或者你的可伸缩性与有限的物理内存直接相关，因此你非常关注内存占用因素。正如你将在下一个问题中看到的那样，每种GC类型在这三个因素的情况下都有其自身的优缺点。
- en: 248\. Categorizing garbage collectors
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 248. 垃圾收集器的分类
- en: 'Garbage collectors have evolved exactly as Java itself has evolved. Today (JDK
    21), we distinguish between several GC types, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器的演变与Java本身的演变完全一致。今天（JDK 21），我们区分了几种GC类型，如下所示：
- en: Serial garbage collector
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行垃圾收集器
- en: Parallel garbage collector
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行垃圾收集器
- en: Garbage-First (G1) collector
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾-第一（G1）收集器
- en: Z Garbage Collector (ZGC)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z垃圾收集器（ZGC）
- en: Shenandoah Garbage Collector (not generational)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沙南多垃圾收集器（非代收集器）
- en: Concurrent Mark Sweep (CMS) collector (deprecated)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发标记清除（CMS）收集器（已弃用）
- en: Let’s tackle the main aspects of each GC type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决每种GC类型的主要方面。
- en: Serial garbage collector
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 串行垃圾收集器
- en: The serial garbage collector is an STW single-threaded generational collector.
    Before running its own algorithms, this GC freezes/pauses all the application
    threads. This means that this GC is not suitable for multi-threaded applications
    such as server-side components. However, being focused on a very small footprint
    (useful for small heaps), this collector is a good fit for single-threaded applications
    (and single-processor machines) that can easily accommodate and tolerate a significant
    latency (for instance, batch jobs or bulk processing).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 串行垃圾收集器是一个STW单线程代收集器。在运行自己的算法之前，这个GC会冻结/暂停所有应用程序线程。这意味着这个GC不适合多线程应用程序，如服务器端组件。然而，由于它专注于非常小的内存占用（对小型堆很有用），这个收集器非常适合单线程应用程序（以及单处理器机器），它们可以轻松地容纳和容忍显著的延迟（例如，批处理作业或批量处理）。
- en: Parallel garbage collector
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行垃圾收集器
- en: The parallel garbage collector is an STW multi-threaded generational collector.
    Before running its own algorithms, this GC freezes/pauses all the application
    threads, but it speeds up the garbage collection by using multiple threads. In
    other words, this GC can take advantage of multi-processor machines and can be
    a good fit for multi-threaded applications that use medium/large datasets. This
    GC is focused on throughput rather than latency and comes with pauses of 1 second
    or more. So, if you are in a multi-threaded context that can afford pauses of
    1 second or more, then this GC is the right choice.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 并行垃圾收集器是一个STW多线程代收集器。在运行自己的算法之前，这个GC会冻结/暂停所有应用程序线程，但它通过使用多个线程来加速垃圾收集。换句话说，这个GC可以利用多处理器机器，并且对于使用中等/大型数据集的多线程应用程序来说是一个很好的选择。这个GC关注吞吐量而不是延迟，并且伴随着1秒或更长的暂停。因此，如果你处于可以承受1秒或更长时间暂停的多线程环境中，那么这个GC是正确的选择。
- en: Garbage-First (G1) collector
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾-第一（G1）收集器
- en: The Garbage-First (G1) collector is an STW multi-threaded, region-based, generational
    collector focused on balanced performance. This GC was introduced in JDK 7 update
    4 as a default (since JDK 9) solution that sustains high throughput and low latency
    (a few hundred milliseconds). The price to pay for this performance is a more
    frequent rate of epochs. The GC will run more often, so be prepared to provide
    a CPU ready to accommodate more cycles than other GCs. This GC was designed for
    server-style applications that are executed on multi-processor machines with massive
    memory (large heap size). Also known as a *mostly concurrent* collector, G1 performs
    heavily next to the application using equally sized spaces/regions (from 1 to
    32 MB). So, if you can afford a large heap size and need low latency, then G1
    is the proper choice. We will talk in detail about G1 in subsequent problems.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾优先（G1）收集器是一个STW多线程、基于区域、分代收集器，专注于平衡性能。这个GC在JDK 7更新4中引入，作为默认（自JDK 9起）解决方案，以维持高吞吐量和低延迟（几秒）。为此性能付出的代价是更频繁的epochs。GC将更频繁地运行，因此请准备提供一台CPU，以便能够容纳比其他GC更多的周期。这个GC是为在多处理器机器上执行的服务器式应用程序设计的，这些机器具有大量内存（大堆大小）。也称为*主要并发*收集器，G1使用等大小的空间/区域（从1到32MB）在应用程序旁边进行大量操作。因此，如果您可以承受大堆大小并且需要低延迟，那么G1是正确的选择。我们将在后续问题中详细讨论G1。
- en: Z Garbage Collector (ZGC)
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Z垃圾回收器（ZGC）
- en: Z Garbage Collector (ZGC) was introduced for production starting with JDK 15
    as a low-latency GC that can handle large heap sizes (terabytes). Like G1, ZGC
    works concurrently but it guarantees to not stop the application threads for more
    than a few milliseconds (the documentation even states that ZGC can perform with
    sub-millisecond max pause times). We will cover it in detail in subsequent problems.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Z垃圾回收器（ZGC）从JDK 15开始用于生产，它是一种低延迟的GC，可以处理大堆大小（数TB）。像G1一样，ZGC是并发工作的，但它保证不会使应用程序线程停止超过几毫秒（文档甚至指出ZGC可以以亚毫秒的最大暂停时间运行）。我们将在后续问题中详细讨论它。
- en: Shenandoah Garbage Collector
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shenandoah垃圾回收器
- en: Shenandoah Garbage Collector was introduced in JDK 12 (and became more reliable
    in JDK 17) as a very low-latency, highly responsive GC (sub-millisecond pauses).
    It performs its job (including compaction) concurrently with the application.
    Shenandoah pauses are extremely short and independent of the heap size. Garbage
    collecting a 1 GB heap or a 300 GB heap should produce similar pauses.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Shenandoah垃圾回收器在JDK 12中引入（并在JDK 17中变得更加可靠）作为一个非常低延迟、高度响应的GC（亚毫秒暂停）。它与应用程序并发执行其工作（包括压缩）。Shenandoah暂停非常短，与堆大小无关。垃圾回收1GB的堆或300GB的堆应该产生类似的暂停。
- en: Concurrent Mark Sweep (CMS) collector (deprecated)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发标记清除（CMS）收集器（已废弃）
- en: CMS is a *mostly concurrent* collector deprecated by G1\. Since it is deprecated,
    I will not talk about it further.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: CMS是一个被G1废弃的*主要并发*收集器。由于它已被废弃，我将不再进一步讨论它。
- en: 249\. Introducing G1
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 249. 引入G1
- en: The G1 Garbage Collector is probably the most mature, maintained, and improved
    GC in Java. It was introduced in JDK 7 update 4, and from JDK 9, it became the
    default GC. This GC sustains high throughput and low latency (a few hundred milliseconds),
    being known for its balanced performance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: G1垃圾回收器可能是Java中最成熟、维护和改进的GC。它在JDK 7更新4中引入，从JDK 9开始成为默认GC。这个GC维持高吞吐量和低延迟（几秒），以其平衡的性能而闻名。
- en: Internally, G1 splits the heap into equally small chunks (max size of 32 MB),
    which are independent of each other and can be allocated dynamically to *Eden*,
    *Survivor*, or *Tenured* spaces. Each such chunk is called the G1 *heap region*.
    So, G1 is a region-based GC.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，G1将堆分割成大小相等的块（最大32MB），这些块相互独立，可以动态地分配给*Eden*、*Survivor*或*Tenured*空间。每个这样的块被称为G1的*堆区域*。因此，G1是一种基于区域的GC。
- en: '![Figure 12.15.png](img/B19665_12_15.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15.png](img/B19665_12_15.png)'
- en: 'Figure 12.15: G1 splits the memory heap into equal small chunks'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：G1将内存堆分割成相等的小块
- en: This architecture has a significant number of advantages. Probably, the most
    important one is represented by the fact that the *Old* generation can be cleaned
    up efficiently by cleaning it up in parts that sustain low latency.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构具有许多显著的优势。可能最重要的是，*Old*代可以通过清理低延迟的部分来有效地清理。
- en: For a heap size smaller than 4 GB, G1 will create regions of 1 MB. For heaps
    between 4 and 8 GB, G1 will create regions of 2 MB, and so on, up to 32 MB for
    a heap of 64 GB or larger. Basically, the JVM sets a number of regions that have
    a power of 2 and between 1 and 32 MB (typically, during the application start,
    the JVM sets up around 2,000+ regions).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小于4 GB的堆大小，G1将创建1 MB的区域。对于4到8 GB的堆，G1将创建2 MB的区域，以此类推，直到64 GB或更大的堆为32 MB。基本上，JVM设置了一定数量的区域，这些区域的数量是2的幂，且在1到32
    MB之间（通常，在应用启动期间，JVM设置大约2,000+个区域）。
- en: Design principles
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计原则
- en: 'G1 was designed on a set of principles, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: G1的设计基于以下原则：
- en: Balanced performance – Designed to balance throughput and low latency to sustain
    performance.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡性能 - 设计用于平衡吞吐量和低延迟，以维持性能。
- en: Generational – Dynamically split the heap into the *Young* and *Old* generations
    and focus on the *Young* generation, since in this region there is more garbage
    (most objects die in the *Young* generation region). The idea that most objects
    are short-lived is also known as the *generational hypothesis*.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代际 - 动态地将堆分为*Young*和*Old*代，并专注于*Young*代，因为在这个区域中垃圾更多（大多数对象在*Young*代区域死亡）。大多数对象生命周期短的观点也被称为*代际假设*。
- en: Incremental collecting of *Old* generation – G1 eventually moves objects from
    the *Young* to the *Old* generation and leaves them there to die slowly and collects
    them incrementally.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Old*代的增量收集 - G1最终将对象从*Young*代移动到*Old*代，并让它们在那里慢慢死亡，并逐步收集它们。'
- en: Mostly concurrent – G1 strives to perform heavy tasks next to the application
    (concurrently) with low and predictable pauses.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要并发 - G1努力在应用（并发）附近执行重任务，同时保持低且可预测的暂停。
- en: Thanks to these design principles, G1 has deprecated the CMS collector.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了这些设计原则，G1已经弃用了CMS收集器。
- en: 250\. Tackling G1 throughput improvements
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 250. 解决G1吞吐量提升问题
- en: G1 has made major progress from JDK 8 to JDK 20\. Some of these improvements
    have been reflected in throughput. Of course, this throughput improvement is dependent
    on a lot of factors (application, machine, tuning, and so on) but you may expect
    at least 10% higher throughput in JDK 18/20 than in JDK 8.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 8到JDK 20，G1取得了重大进展。其中一些改进已经体现在吞吐量上。当然，这种吞吐量提升取决于许多因素（应用、机器、调整等），但你可以预期在JDK
    18/20中至少比JDK 8有10%以上的吞吐量提升。
- en: In order to increase throughput, G1 has passed through several changes, as follows.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高吞吐量，G1已经经历了几次变化，如下所述。
- en: Delaying the start of the Old generation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟Old代的启动
- en: Starting with JDK 9, G1 is heavily focused on collecting garbage from the *Young*
    generation while delaying the start (initialization, resource allocation, and
    so on) of the *Old* generation to the last moment (it anticipates when the *Old*
    generation should be started).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 9开始，G1主要专注于从*Young*代收集垃圾，同时将*Old*代的启动（初始化、资源分配等）推迟到最后时刻（它预计何时应该启动*Old*代）。
- en: Focusing on easy pickings
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专注于易收集
- en: By easy pickings, we mean objects that are short-lived (for instance, temporary
    buffers), occupy a significant amount of heap, and can be collected easily at
    low cost with important benefits. Starting with JDK 9, G1 is highly focused on
    easy pickings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的“易收集”是指那些生命周期短（例如，临时缓冲区）、占用大量堆内存且可以以低成本轻松收集的对象，从而带来重要益处。从JDK 9开始，G1高度关注易收集的对象。
- en: Improving NUMA-aware memory allocation
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高NUMA感知内存分配
- en: NUMA stands for non-uniform memory access and it was described in *Problem 245*.
    G1 takes advantage of NUMA from JDK 14 and it is continuously improved. If NUMA
    is enabled, then JVM requires the OS to place G1 heap regions on NUMA nodes. At
    the end of this process, the whole heap should be located evenly across the NUMA
    nodes that are active.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: NUMA代表非均匀内存访问，这在*问题245*中有所描述。G1从JDK 14开始利用NUMA，并且持续改进。如果启用NUMA，那么JVM要求操作系统将G1堆区域放置在NUMA节点上。在此过程结束时，整个堆应均匀分布在所有活跃的NUMA节点上。
- en: '![Figure 12.16.png](img/B19665_12_16.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.16.png](img/B19665_12_16.png)'
- en: 'Figure 12.16: Heap memory without and with NUMA'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：带有和没有NUMA的堆内存
- en: 'The relationship between G1 heap regions and memory pages (operating system
    pages – [https://en.wikipedia.org/wiki/Page_(computer_memory)](https://en.wikipedia.org/wiki/Page_(computer_memory))
    falls into one of these two cases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: G1堆区域与内存页面（操作系统页面 - [https://en.wikipedia.org/wiki/Page_(computer_memory)](https://en.wikipedia.org/wiki/Page_(computer_memory)))之间的关系属于以下两种情况之一：
- en: If the size of a G1 heap region is greater than or equal to the size of a memory
    page, then a G1 heap region will consist of multiple memory pages (*Figure 12.17*,
    left-hand side).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个 G1 堆区域的尺寸大于或等于一个内存页的尺寸，那么一个 G1 堆区域将包含多个内存页（*图 12.17*，左侧）。
- en: If the size of a G1 heap region is smaller than or equal to the size of a memory
    page, then a memory page will consist of multiple G1 heap regions (*Figure 12.17*,
    right-hand side).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个 G1 堆区域的尺寸小于或等于一个内存页的尺寸，那么一个内存页将包含多个 G1 堆区域（*图 12.17*，右侧）。
- en: '![Figure 12.17.png](img/B19665_12_17.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17.png](img/B19665_12_17.png)'
- en: 'Figure 12.17: G1 heap region and memory page relationship'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17：G1 堆区域与内存页的关系
- en: Without NUMA, the G1 GC allocates memory to threads from a single common memory
    allocator. With NUMA, there is a memory allocator per NUMA node, and memory is
    allocated to threads based on these NUMA nodes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有NUMA时，G1 GC 从单个公共内存分配器为线程分配内存。有 NUMA 时，每个 NUMA 节点都有一个内存分配器，内存分配是基于这些 NUMA
    节点的。
- en: Improving NUMA allocation awareness is a continuous goal of G1.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提高NUMA分配意识是G1的持续目标。
- en: Parallelized full-heap collections
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化全堆收集
- en: Among other not-so-common optimizations, we have the parallelization of full-heap
    collection. This was added in JDK 10 as a solution to make full-heap collections
    as fast as possible.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他不太常见的优化中，我们有全堆收集的并行化。这一改进是在 JDK 10 中添加的，作为使全堆收集尽可能快的一种解决方案。
- en: Other improvements
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他改进
- en: Tons of small improvements have been added to JVM itself, and their effects
    are reflected in GC performance as well. This means that by simply updating to
    the latest JDK, our GC will perform better. You’ll notice an improvement of at
    least 10% between JDK 8 and JDK 20.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 本身已经添加了大量的微小改进，这些改进在 GC 性能上也有所体现。这意味着通过简单地更新到最新的 JDK，我们的 GC 将会表现得更好。您会发现
    JDK 8 和 JDK 20 之间至少有 10% 的性能提升。
- en: 251\. Tackling G1 latency improvements
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 251. 解决 G1 延迟改进
- en: G1 GC latency has also recorded some improvements from JDK 8 to JDK 20 (which
    are obviously reflected in G1 GC throughput as well).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 8 到 JDK 20，G1 GC 延迟也记录了一些改进（这显然也反映在 G1 GC 吞吐量上）。
- en: In order to decrease latency, G1 has passed through several changes, as follows.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少延迟，G1 已经经历了几次变化，如下所述。
- en: Merge parallel phases into a larger one
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并并行阶段为一个更大的阶段
- en: Starting with JDK 8, many aspects of G1 have been parallelized. In other words,
    at any moment in time, we may have in execution multiple parallel phases. Starting
    with JDK 9, these parallel phases can be merged into a single larger one. In practice,
    this means less synchronization and less time spent creating/destroying threads.
    As a result, this improvement speeds up the parallelization processing, leading
    to less latency.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 8 开始，G1 的许多方面都进行了并行化。换句话说，在任何时刻，我们可能都在执行多个并行阶段。从 JDK 9 开始，这些并行阶段可以被合并成一个更大的阶段。实际上，这意味着减少了同步，减少了创建/销毁线程的时间。因此，这一改进加快了并行化处理，减少了延迟。
- en: Reduction of metadata
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少元数据
- en: Reduction of metadata was added in JDK 11\. Practically, G1 attempts to manage
    less metadata by reducing its amount as much as possible. Less data to manage
    means better latency. Of course, this means a smaller footprint as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 减少元数据是在 JDK 11 中添加的。实际上，G1 尽可能地减少元数据量，以管理更少的元数据。管理的数据越少，延迟就越好。当然，这也意味着更小的内存占用。
- en: Better work balancing
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的工作平衡
- en: Work balancing was improved starting with JDK 11\. In a nutshell, this means
    that threads that have finished their current work can steal work from other threads.
    In practice, this means that the tasks are done faster since all threads are working
    (on their own work or on stolen work) and none of them are just hanging on. So,
    smarter algorithms have been developed to orchestrate and keep threads busy in
    order to finish the tasks faster and decrease latency. However, reducing the overhead
    of stealing work is still a subject of improvement.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 11 开始，工作平衡得到了改进。简而言之，这意味着完成当前工作的线程可以从其他线程那里窃取工作。实际上，这意味着任务完成得更快，因为所有线程都在工作（在自己的工作或窃取的工作上），没有线程只是挂起。因此，开发了更智能的算法来协调和保持线程忙碌，以更快地完成任务并减少延迟。然而，减少窃取工作的开销仍然是改进的主题。
- en: Better parallelization
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的并行化
- en: Better parallelization is available starting with JDK 14\. In practice, G1 removes
    all duplicates from potential areas with references. Afterward, it applies parallelization
    instead of brute force.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 14 开始，提供了更好的并行化。实际上，G1 从潜在的引用区域中移除了所有重复项。之后，它应用并行化而不是蛮力。
- en: Better reference scanning
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的引用扫描
- en: In order to sustain better parallelization, JDK 15 has also improved the reference
    scanning in the collected areas. JDK 14 knows how to remove duplicates and parallelize
    the data processing, while JDK 15 knows how to scan references more optimally.
    Their effects are combined into decreasing latency.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地实现并行化，JDK 15 也改进了收集区域中的引用扫描。JDK 14 知道如何去除重复项并并行化数据处理，而 JDK 15 知道如何更优化地扫描引用。它们的效果结合在一起，降低了延迟。
- en: Other improvements
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他改进
- en: A lot of time has been spent improving so-called uncommon situations. For instance,
    special attention has been focused on *evacuation failures* (the attempt of moving
    the *live objects* between two memory areas and compacting them is known as *evacuation
    fashion*, and when moving objects around leads to out-of-memory issues, then we
    have an *evacuation failure*). This corner case has been seriously improved in
    order to handle such scenarios faster than before (before JDK 17).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在改进所谓的非常见情况上花费了很多时间。例如，特别关注了*迁移失败*（在两个内存区域之间移动*活动对象*并压缩它们的尝试被称为*迁移方式*，当移动对象导致内存不足问题时，我们就有了一个*迁移失败*）。为了比以前更快地处理此类场景，这个边缘情况得到了严重改进（在
    JDK 17 之前）。
- en: 252\. Tackling G1 footprint improvements
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 252. 解决 G1 占用空间改进
- en: Between JDK 8 and JDK 20, the G1 footprint has been improved by focusing on
    efficient metadata and freeing the memory as quickly as possible.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 8 和 JDK 20 之间，G1 的占用空间通过关注高效的元数据和尽可能快地释放内存得到了改进。
- en: In order to optimize its footprint, G1 has passed through several changes, as
    follows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化其占用空间，G1 已经经历了多次变化，如下所述。
- en: Maintain only the needed metadata
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅保留所需的元数据
- en: In order to maintain only the needed metadata, JDK 11 is capable of concurrently
    (re)creating the needed data and freeing it as fast as possible. In JDK 17, the
    focus on the needed metadata has been reiterated and only the absolutely required
    data is kept around. Moreover, JDK 18 comes up with a denser representation of
    data. All these improvements are reflected in a smaller footprint.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅保留所需的元数据，JDK 11 能够并发（重新）创建所需的数据，并尽可能快地释放它。在 JDK 17 中，对所需元数据的关注得到了重申，并且只保留绝对需要的数据。此外，JDK
    18 提出了数据更密集的表示形式。所有这些改进都反映在更小的占用空间中。
- en: Release memory
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 释放内存
- en: Starting with JDK 17, the G1 GC is capable of concurrently releasing memory
    (giving it back to the OS). This means that memory can be optimally reused and
    is available to serve other tasks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 17 开始，G1 垃圾收集器能够并发释放内存（将其归还给操作系统）。这意味着内存可以被最优地重用，并可用于服务其他任务。
- en: 253\. Introducing ZGC
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 253. 引入 ZGC
- en: Z Garbage Collector (ZGC) was introduced for the first time (as an experimental
    feature) in JDK 11\. It was promoted to the production stage (production ready)
    in JDK 15 under JEP 377\. It continues to be improved as we speak – in JDK 21,
    ZGC sustains application performance by maintaining separate generations for young
    and old objects. Basically, this minimizes allocation stalls and heap memory overhead.
    Moreover, JDK 21 (JEP 439) has promoted ZGC’s status from Targeted to Completed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Z 垃圾收集器（ZGC）首次（作为一个实验性功能）在 JDK 11 中引入。它在 JDK 15 中被提升到生产阶段（生产就绪），根据 JEP 377。它仍在不断改进——在
    JDK 21 中，ZGC 通过维护年轻和旧对象的不同代来维持应用程序性能。基本上，这最小化了分配停滞和堆内存开销。此外，JDK 21（JEP 439）将 ZGC
    的状态从目标提升到完成。
- en: ZGC is concurrent (works at the same time as the application based on low-level
    concurrency primitives such as *load barriers* and *colored pointers*), tracing
    (traversing the object graph to identify *live* and *non-live* objects), and compacting
    (fight against fragmentation). It is also NUMA-aware and region-based.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是并发的（基于低级并发原语，如*加载屏障*和*彩色指针*），跟踪（遍历对象图以识别*活动*和*非活动*对象），以及压缩（对抗碎片）。它也是 NUMA
    意识的，基于区域的。
- en: ZGC was specially designed as a low-latency, highly scalable GC capable of handling
    from small (a few megabytes; the documentation states 8 MB) to massive heaps (terabytes;
    the documentation states 16 TB) with pauses (pulse times) of a maximum of a few
    milliseconds (the documentation states sub-millisecond max pause times).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC 是专门设计为低延迟、高度可扩展的垃圾收集器，能够处理从小型（几兆字节；文档中提到 8 MB）到大型（兆字节；文档中提到 16 TB）的堆，最大暂停时间（脉冲时间）仅为几毫秒（文档中提到亚毫秒最大暂停时间）。
- en: '![Figure 12.18.png](img/B19665_12_18.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.18.png](img/B19665_12_18.png)'
- en: 'Figure 12.18: ZGC is focused on low latency'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18：ZGC 专注于低延迟
- en: It is very important to say that pauses don’t increase with the heap size (pulse
    times are O(1), so they execute in constant time).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要说明，暂停时间不会随着堆大小的增加而增加（脉冲时间复杂度为O(1)，因此它们在恒定时间内执行）。
- en: The shortcoming (trade-off) of ZGC relies on throughput. In other words, ZGC
    throughput is slightly reduced (a few percent, for instance from 0% to 10% in
    some cases) in comparison with G1 throughput.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC的缺点（权衡）在于吞吐量。换句话说，与G1吞吐量相比，ZGC的吞吐量略有降低（例如，在某些情况下从0%降低到10%）。
- en: Starting with JDK 16, ZGC takes advantage of a concurrent thread stack, and
    starting with JDK 18, it supports string de-duplication. These are just two of
    the major improvements next to many other improvements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从JDK 16开始，ZGC利用了并发线程堆栈，从JDK 18开始，它支持字符串去重。这些只是众多改进中的两个主要改进。
- en: ZGC is auto-tuned. In other words, as you’ll see in *Problem 256*, ZGC has just
    a few options that we can tune while most of the tuning is automatic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC是自动调优的。换句话说，正如你将在*问题256*中看到的那样，ZGC只有少数几个我们可以调整的选项，而大部分调整是自动的。
- en: ZGC is concurrent
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC是并发的
- en: 'G1 and ZGC are both concurrent, but they don’t follow the same path. ZGC strives
    to collect as much garbage as possible in a concurrent fashion. For this, ZGC
    relies on three main lightweight (very short, sub-millisecond) pauses and three
    concurrent phases, as in the following figure:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: G1和ZGC都是并发的，但它们并不遵循相同的路径。ZGC力求以并发的方式收集尽可能多的垃圾。为此，ZGC依赖于三个主要轻量级（非常短，亚毫秒级）暂停和三个并发阶段，如下面的图所示：
- en: '![Figure 12.19.png](img/B19665_12_19.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19.png](img/B19665_12_19.png)'
- en: 'Figure 12.19: ZGC concurrency'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：ZGC并发
- en: 'Each of the three phases is signaled by a synchronization point (pause):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都由一个同步点（暂停）来表示：
- en: '*Pause Mark Start –* This pause signals that the *Concurrent Mark* phase follows.
    During this synchronization point, ZGC prepares the current state for executing
    the *Concurrent Mark* phase. This is a lightweight pause that performs some settings
    on *colored pointers* and resets a few flags and counters. Next, the *Concurrent
    Mark* phase runs concurrently and marks the objects from the heap.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暂停标记开始 –* 这个暂停信号表示将跟随*并发标记*阶段。在这个同步点，ZGC为执行*并发标记*阶段准备当前状态。这是一个轻量级暂停，对*彩色指针*进行一些设置，并重置一些标志和计数器。接下来，*并发标记*阶段并发运行并标记堆中的对象。'
- en: '*Pause Mark End –* This pause signals the end of the *Concurrent Mark* phase.
    It also pauses before executing the *Concurrent Prepare for Relocation* phase.
    This phase is responsible for locating all the *live* objects from sparsely populated
    regions and marks them as candidates to be moved/evacuated to other regions. Moreover,
    during this phase, ZGC deallocates regions that don’t contain *live* objects.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暂停标记结束 –* 这个暂停信号表示*并发标记*阶段的结束。它也在执行*并发准备重定位*阶段之前暂停。这个阶段负责定位所有来自稀疏填充区域的*活动*对象，并将它们标记为可以移动/迁移到其他区域的候选者。此外，在这个阶段，ZGC解除分配不包含*活动*对象的区域。'
- en: '*Pause Relocate Start* – This pause signals that the *Concurrent Relocate*
    phase follows. During this phase, the objects marked as evacuation candidates
    in the previous phase are effectively moved (copied) from the current region to
    the new region. Their references are also restored, being deallocated from the
    current region and reallocated to the new region.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*暂停重定位开始* – 这个暂停信号表示将跟随*并发重定位*阶段。在这个阶段，前一个阶段标记为迁移候选者的对象实际上被（复制）从当前区域移动到新区域。它们的引用也被恢复，从当前区域解除分配并重新分配到新区域。'
- en: ZGC and colored pointers
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC和彩色指针
- en: ZGC runs next to the application and manipulates (moves around) the objects
    used by that application. This may lead to unexpected errors (for instance, the
    application may attempt to use out-of-date references) that cause the application
    to act weirdly or even crash. In order to prevent such scenarios, ZGC relies on
    two low-level concurrency primitives known as *colored pointer* and *load barriers*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC在应用程序旁边运行并操作（移动）该应用程序使用的对象。这可能导致意外的错误（例如，应用程序可能尝试使用过时的引用），从而导致应用程序行为异常甚至崩溃。为了防止这种情况，ZGC依赖于两种称为*彩色指针*和*加载屏障*的低级并发原语。
- en: A *colored pointer* is a 64-bit pointer. This pointer is used by ZGC with a
    44-bit object address capable of handling up to 16 terabytes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*彩色指针*是一个64位指针。这个指针由ZGC使用一个44位对象地址，能够处理高达16 terabytes。'
- en: '![Figure 12.20.png](img/B19665_12_20.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20.png](img/B19665_12_20.png)'
- en: 'Figure 12.20: Colored pointer'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：彩色指针
- en: 'A *colored pointer* reserves 20 bits for storing metadata about this pointer.
    The most important metadata is:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*彩色指针*为存储此指针的元数据保留了20位。最重要的元数据是：'
- en: '*Finalizable* – 1 bit that indicates if an object is reachable (*live* object)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Finalizable* – 1位表示对象是否可达（*活动*对象）'
- en: '*Remapped* – 1 bit that indicates if an object doesn’t point into a relocation
    set'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*重映射* – 1位表示对象是否不指向重定位集'
- en: '*Marked0*/*Marked1* – 2 bits that indicate if an object is or is not marked'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Marked0*/*Marked1* – 2位表示对象是否被标记'
- en: As well as colored pointers, ZGC needs load barriers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了彩色指针外，ZGC还需要负载屏障。
- en: ZGC and load barriers
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC和负载屏障
- en: '*Load barriers* are portions of code injected by the compiler to handle *colored
    pointers*. While the application is not aware of *colored pointers*, ZGC needs
    to interpret and work with them, and this is exactly the job of *load barriers*.
    For instance, let’s assume that we have, in the application, the following snippet
    of code (I’ve intentionally added the line numbers manually):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载屏障*是编译器注入的代码片段，用于处理*彩色指针*。虽然应用程序不知道*彩色指针*，但ZGC需要解释和与它们一起工作，这正是*负载屏障*的工作。例如，假设我们在应用程序中有以下代码片段（我故意手动添加了行号）：'
- en: '[PRE0]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The compiler analyzes the code to decide where to inject a *load barrier*.
    The conclusion is that the only place where a *load barrier* should be injected
    is between lines 1 and 2 because that is the only place where an object is loaded
    from the heap. In line 2, there is no need for a *load barrier* since there is
    a copy of the memory reference. In line 3, there is also no need for a *load barrier*
    since there is a method reference. Finally, in line 4, there is no need for a
    *load barrier* since there is no object reference. So, ZGC sees this code as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器分析代码以决定在哪里注入一个*负载屏障*。结论是，唯一应该在行1和行2之间注入*负载屏障*的地方，因为那里是唯一从堆中加载对象的地方。在行2中，不需要*负载屏障*，因为有一个内存引用的副本。在行3中，也不需要*负载屏障*，因为有一个方法引用。最后，在行4中，也不需要*负载屏障*，因为没有对象引用。所以，ZGC看到这段代码如下：
- en: '[PRE1]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The purpose of the *load barrier* is to ensure that the pointers are valid (shown
    by having a good color). If a bad color is encountered, then the *load barrier*
    tries to heal it (update the pointer, relocate the object reference, and so on).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载屏障*的目的是确保指针是有效的（通过良好的颜色显示）。如果遇到坏颜色，则*负载屏障*会尝试修复它（更新指针，重新定位对象引用等）。'
- en: ZGC is region-based
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZGC是区域基于的
- en: 'ZGC is a *region-based* GC, so it divides the heap into smaller regions/chunks
    that are allocated to the *Young* or *Old* generation, as in the following figure:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ZGC是一种基于区域的垃圾回收器，因此它将堆划分为更小的区域/块，这些区域/块分配给*年轻*或*老*代，如下面的图所示：
- en: '![Figure 12.21.png](img/B19665_12_21.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 12.21.png](img/B19665_12_21.png)'
- en: 'Figure 12.21: ZGC heap regions'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：ZGC堆区域
- en: 'Exactly like G1, ZGC is a *region-based* GC. Nevertheless, ZGC is more powerful
    than G1 and has the capability to dynamically increase/decrease the number of
    active regions during runtime. Moreover, ZGC can rely on regions of three sizes,
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与G1完全一样，ZGC是一种基于区域的垃圾回收器。然而，ZGC比G1更强大，并且能够在运行时动态地增加/减少活动区域的数量。此外，ZGC可以依赖于三种大小的区域，如下所示：
- en: Small region – These regions are 2 MB.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小区域 – 这些区域大小为2 MB。
- en: Medium region – These regions can be from 4 MB to 32 MB. They are dynamically
    sized.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中等区域 – 这些区域可以从4 MB到32 MB不等。它们是动态大小的。
- en: Large region – These are regions reserved for *humongous* objects. These are
    tightly fitted regions that can be smaller or larger than a medium region.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大区域 – 这些区域是为*巨大*对象预留的。这些区域是紧密匹配的，可能比中等区域小或大。
- en: So, at a glance, ZGC is a concurrent GC with constant pause times (sub-millisecond),
    working in parallel mode, and capable of fighting against fragmentation via compacting.
    Moreover, it is region-based, NUMA-aware, capable of auto-tuning, and relies on
    *colored pointers* and *load barriers*.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乍一看，ZGC是一种具有恒定暂停时间（亚毫秒级）的并发垃圾回收器，以并行模式工作，并且能够通过压缩来对抗碎片化。此外，它是基于区域的，NUMA感知的，能够自动调整，并依赖于*彩色指针*和*负载屏障*。
- en: 254\. Monitoring garbage collectors
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 254. 监控垃圾回收器
- en: Monitoring the activity and evolution in the timeline of your GC is a major
    aspect in order to identify potential performance issues. For instance, you may
    be interested in monitoring pause times, identifying the frequency and types of
    GC events, what spaces are filled up by the triggered GC events, and so on. The
    main goal is to collect as much information as possible that can be helpful in
    troubleshooting performance issues related to heap memory and GC evolution.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 GC 在时间线中的活动和演变是识别潜在性能问题的关键。例如，您可能对监控暂停时间、识别 GC 事件的频率和类型、被触发的 GC 事件填充的空间等感兴趣。主要目标是收集尽可能多的信息，这些信息有助于解决与堆内存和
    GC 进化相关的性能问题。
- en: 'Any modern IDE provides profilers that contain (among other related things)
    information and real-time graphs about the GC *epochs*/cycles. For instance, the
    following figure is from the NetBeans IDE, which displays the GC evolution (heap
    status) as an item of the toolbar (by simply clicking on that area, you can force
    the GC to perform garbage collection):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代 IDE 都提供包含（包括其他相关事物）GC *epochs*/cycles 的信息和实时图表的剖析器。例如，以下图来自 NetBeans IDE，它将
    GC 进化（堆状态）显示为工具栏的一项（只需单击该区域，就可以强制 GC 执行垃圾回收）：
- en: '![Figure 12.22.png](img/B19665_12_22.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.22.png](img/B19665_12_22.png)'
- en: 'Figure 12.22: NetBeans display GC evolution on the toolbar'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22：NetBeans 在工具栏上显示 GC 进化
- en: 'Of course, a more detailed view is available via the NetBeans profiler:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，通过 NetBeans 剖析器可以获得更详细的信息：
- en: '![Figure 12.23.png](img/B19665_12_23.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23.png](img/B19665_12_23.png)'
- en: 'Figure 12.23: NetBeans profiler for GC'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23：NetBeans 的 GC 分析器
- en: Among other tools that can be used to monitor your GC are the *jstat* command-line
    utility (`jstat -gc $JAVA_PID`) and *JConsole* (Java Monitoring and Management
    Console).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用于监控您的 GC 的其他工具中，还有 *jstat* 命令行实用程序（`jstat -gc $JAVA_PID`）和 *JConsole*（Java
    监控和管理控制台）。
- en: 'The following figure is a screenshot from *JConsole*:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是来自 *JConsole* 的截图：
- en: '![Figure 12.24.png](img/B19665_12_24.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.24.png](img/B19665_12_24.png)'
- en: 'Figure 12.24: Monitoring the GC via JConsole'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24：通过 JConsole 监控 GC
- en: You may also be interested in **visualgc** (**Visual Garbage Collection Monitoring
    Tool**) from Oracle, **JDK VisualGC** (IntelliJ IDE plugin), and **Memory Analyzer**
    (**MAT**) from Eclipse.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还对 Oracle 的 **visualgc**（**可视化垃圾回收监控工具**）、**JDK VisualGC**（IntelliJ IDE 插件）和
    Eclipse 的 **Memory Analyzer**（**MAT**）感兴趣。
- en: 255\. Logging garbage collectors
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 255. 记录垃圾收集器
- en: Analyzing the GC logs is another approach that can be useful for finding memory
    issues. Since GC logs don’t add a significant overhead, they can be enabled in
    production for debugging purposes. Really, GC logs have an insignificant overhead,
    so you should definitely use them!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 GC 日志是另一种有用的方法，可以帮助找到内存问题。由于 GC 日志不会增加显著的开销，因此可以在生产环境中启用它们进行调试。实际上，GC 日志的开销微乎其微，因此您绝对应该使用它们！
- en: 'Let’s consider some simple Java code that adds and removes from `List<String>`.
    Adding and removing the code requires a full GC via `System.gc()`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些简单的 Java 代码，该代码向 `List<String>` 添加和删除元素。添加和删除代码需要通过 `System.gc()` 执行完整
    GC：
- en: '[PRE2]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we want to run this simple application and log the GC activity.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要运行这个简单的应用程序并记录 GC 活动。
- en: 'Before JDK 9, we can obtain a quick and verbose log of GC via the `-verbose:gc`
    option:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDK 9 之前，我们可以通过 `-verbose:gc` 选项获取 GC 的快速和详细日志：
- en: '[PRE3]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A possible output will look as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的输出如下所示：
- en: '[PRE4]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is the simplest GC log. For more details, we can add the `-XX:+PrintGCDetails`
    option:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的 GC 日志。要获取更多详细信息，我们可以添加 `-XX:+PrintGCDetails` 选项：
- en: '[PRE5]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Moreover, we can attach a few options for obtaining information about tenuring
    distribution (`-XX:+PrintTenuringDistribution`), garbage collector time stamps
    (`-XX:+PrintGCTimeStamps`), the class histogram (`-XX:+PrintClassHistogram`),
    and the application stopped time (`-XX:+PrintGCApplicationStoppedTime`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以附加一些选项来获取关于十岁分布（`-XX:+PrintTenuringDistribution`）、垃圾收集器时间戳（`-XX:+PrintGCTimeStamps`）、类直方图（`-XX:+PrintClassHistogram`）和应用停止时间（`-XX:+PrintGCApplicationStoppedTime`）的信息。
- en: 'In this context, GC logs are available on the console (stdout) using the info
    level. You can easily redirect the GC logs to a file via the `-Xloggc` option:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，GC 日志在控制台（stdout）上可用，使用 info 级别。您可以通过 `-Xloggc` 选项轻松地将 GC 日志重定向到文件：
- en: '[PRE6]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Actually, `-Xloggc` is deprecated and you should use it only if you are using
    a JDK earlier than version 9\. Starting with JDK 9 (JEP 158 – [https://openjdk.org/jeps/158](https://openjdk.org/jeps/158)),
    we have a *unified logging system* for all JVM components.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`-Xloggc` 已被弃用，并且您只有在使用版本低于9的JDK时才应使用它。从JDK 9（JEP 158 – [https://openjdk.org/jeps/158](https://openjdk.org/jeps/158)）开始，我们有一个针对所有JVM组件的
    *统一日志系统*。
- en: 'So, starting with JDK 9, we have a unified logging system via the `–Xlog` option.
    The equivalent of `-XX:+PrintGCDetails -verbose:gc` is `-Xlog:gc*`. If we want
    to redirect GC logs to a file using the debug level, then we can do it as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从JDK 9开始，我们通过 `–Xlog` 选项拥有一个统一的日志系统。`-XX:+PrintGCDetails -verbose:gc` 的等效选项是
    `-Xlog:gc*`。如果我们想以调试级别将GC日志重定向到文件，则可以这样做：
- en: '[PRE7]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `gclog.txt` will be saved in the application root folder. If you remove
    the `*` character, then you’ll get a less verbose GC log.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`gclog.txt` 将保存在应用程序根目录中。如果您删除了 `*` 字符，那么您将得到一个不那么冗长的垃圾收集器日志。'
- en: Logging only NUMA logs is available via `-Xlog:numa*={log level}`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `-Xlog:numa*={log level}` 可用仅记录NUMA日志。
- en: Having the GC log is half of the problem. The other half consists of interpreting
    this log. As you can see, this is not that easy. Fortunately, you don’t have to
    bother reading the log files because we have tools capable of parsing, analyzing,
    and providing detailed reports from GC logs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有垃圾收集器日志只是问题的一半。另一半包括解释这个日志。如您所见，这并不容易。幸运的是，您不必费心阅读日志文件，因为我们有能够解析、分析和从垃圾收集器日志中提供详细报告的工具。
- en: One of these tools is Universal GC Log Analyzer ([https://gceasy.io/](https://gceasy.io/)).
    Using the free version, we can upload our `gclog.txt` file and get a detailed
    report. For instance, in the following figure, we can see how memory was allocated
    for our application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具之一是通用垃圾收集器日志分析器（[https://gceasy.io/](https://gceasy.io/)）。使用免费版本，我们可以上传我们的
    `gclog.txt` 文件并获得详细报告。例如，在下面的图中，我们可以看到为我们的应用程序分配了多少内存。
- en: '![Figure 12.25.png](img/B19665_12_25.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25.png](img/B19665_12_25.png)'
- en: 'Figure 12.25: A screenshot from Universal GC Log Analyzer (GCEasy) report'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：来自通用垃圾收集器日志分析器（GCEasy）报告的截图
- en: This figure is just a very small part of the report. Try it yourself to see
    the full report. Other similar tools that you may like to try are GCViewer, GCPlot,
    IBM Garbage Collection and Memory Visualizer, garbagecat, SolarWinds Loggly, Sematext
    Logs, **Java Flight Recorder** (**JFR**), jvm-gc-logs-analyzer, and so on.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此图只是报告的一小部分。自己尝试一下，看看完整的报告。您可能还想尝试的其他类似工具包括 GCViewer、GCPlot、IBM垃圾收集器和内存可视化器、garbagecat、SolarWinds
    Loggly、Sematext Logs、**Java飞行记录器**（**JFR**）、jvm-gc-logs-analyzer 等。
- en: 256\. Tuning garbage collectors
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 256. 调整垃圾收集器
- en: Garbage collectors are complex machinery whose performances are highly related
    to their settings (startup parameters) in the context of the current JVM, current
    application, and hardware. Since the GC consumes and shares resources (memory,
    CPU time, and so on) with our application, it is essential to tune it to work
    as efficiently as possible. If the GC is not efficient, then we may face significant
    pause times that will negatively impact the application run.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器是一种复杂的机械，其性能与当前JVM、当前应用程序和硬件环境中的设置（启动参数）高度相关。由于垃圾收集器会消耗和共享资源（内存、CPU时间等）与我们的应用程序，因此将其调整到尽可能高效地工作至关重要。如果垃圾收集器效率不高，那么我们可能会面临显著的暂停时间，这将负面地影响应用程序的运行。
- en: In this problem, we will cover the main tuning options available for the serial
    GC, parallel GC, G1 GC, and ZGC.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将介绍串行GC、并行GC、G1 GC和ZGC可用的主要调整选项。
- en: How to tune
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何调整
- en: Before attempting to tune the GC, ensure that it is really causing trouble.
    By inspecting and correlating the charts and logs, you can identify such troubles
    and decide where you should act (what parameters should be tuned). Check out the
    usage of the heap memory and how objects fill up the *Eden*, *Survivor*, and *Tenured*
    spaces.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试调整垃圾收集器之前，请确保它确实引起了问题。通过检查和关联图表和日志，您可以识别这些问题并决定您应该采取行动的地方（应该调整哪些参数）。检查堆内存的使用情况以及对象如何填充
    *Eden*、*Survivor* 和 *Tenured* 空间。
- en: 'Typically, a healthy GC produces a heap usage graph known as *shark teeth*,
    as in the following figure:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个健康的垃圾收集器会产生一个称为 *shark teeth* 的堆使用图，如下面的图所示：
- en: '![Figure 12.26.png](img/B19665_12_26.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图12.26.png](img/B19665_12_26.png)'
- en: 'Figure 12.26: Healthy heap usage'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：健康的堆使用
- en: Moreover, check out the 90^(th) and 99^(th) percentiles along with the average
    GC time. This information can give you a hint about whether more memory is needed
    or if it is cleared properly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查90^(th)和99^(th)百分位数以及平均GC时间。这些信息可以给你一个提示，了解是否需要更多的内存或者是否已经正确清理。
- en: Once you identify the GC troubles, try to tackle them one by one. Don’t rush
    to change several parameters at once because it will be hard to manage and analyze
    their combined effect. Try to modify one of them and experiment to see what’s
    happening and what the results are. If you see some benefits, then go for the
    next one and experiment again. Observe if the combined effect has been improved
    or not. Otherwise, maybe it is better to restore this one to its default value
    before going for the next one.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了GC问题，尝试逐一解决它们。不要急于同时更改多个参数，因为这很难管理和分析它们的综合效果。尝试修改其中一个，并实验看看发生了什么以及结果如何。如果你看到一些好处，那么就进行下一个实验，并再次实验。观察综合效果是否有所改善。否则，也许在尝试下一个之前，最好将这个参数恢复到其默认值。
- en: Tuning the serial garbage collector
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整串行垃圾回收器
- en: The serial garbage collector can be enabled via `-XX:+UseSerialGC`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`-XX:+UseSerialGC`启用串行垃圾回收器。
- en: Since this is a single-threaded GC, there is not much to tune. However, you
    may adjust the heap size via `–Xmx` and `–Xms` (for instance, a heap size of 3
    GB can be set via `–Xmx3g` and `–Xms3g`) and the *Young* generation size via the
    `–Xmn` option. Nevertheless, these options work with all types of GC for setting
    the heap size.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个单线程GC，没有太多可以调整的。然而，你可以通过`-Xmx`和`-Xms`调整堆大小（例如，可以通过`-Xmx3g`和`-Xms3g`设置3GB的堆大小）以及通过`-Xmn`选项调整*Young*代的大小。不过，这些选项与所有类型的GC一起工作，用于设置堆大小。
- en: Tunning the parallel garbage collector
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整并行垃圾回收器
- en: The parallel garbage collector can be enabled via `-XX:+UseParallelGC`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`-XX:+UseParallelGC`启用并行垃圾回收器。
- en: This GC is multi-threaded and we can control the number of threads used for
    cleaning tasks via the `-XX:ParallelGCThreads` option (for instance, setting six
    threads can be done with `-XX:ParallelGCThreads=6`).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个垃圾回收器是多线程的，我们可以通过`-XX:ParallelGCThreads`选项来控制用于清理任务的线程数量（例如，设置六个线程可以通过`-XX:ParallelGCThreads=6`来完成）。
- en: Keep in mind that a higher number of threads results in a higher fragmentation
    of the heap reserved for the *Tenured* space. Each thread that participates in
    a *Minor* GC event will reserve some space in the *Tenured* space for its promotions
    goals. This will lead to serious fragmentation of the *Tenured* space. Fixing
    this issue requires reducing the number of threads and increasing the size of
    the *Old* generation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，线程数量越多，为*Tenured*空间保留的堆的碎片化程度就越高。每个参与*Minor* GC事件的线程都会在*Tenured*空间中为其晋升目标保留一些空间。这将导致*Tenured*空间的严重碎片化。解决这个问题需要减少线程数量并增加*Old*代的大小。
- en: The maximum pause time can be controlled via the `-XX:MaxGCPauseMillis` option
    (for instance, `-XX:MaxGCPauseMillis=150`, which will ensure maximum pause times
    of 150 milliseconds between two consecutive runs/events of GC). However, be aware
    that bigger pause times will allow more garbage to hit the heap. This means that
    the next run of the GC will be more expensive. On the other hand, a small pause
    time will instruct the GC to run more frequently, and this may cause the application
    to spend too much time on garbage collection.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最大暂停时间可以通过`-XX:MaxGCPauseMillis`选项来控制（例如，`-XX:MaxGCPauseMillis=150`，这将确保在两次连续的GC运行/事件之间最大暂停时间为150毫秒）。然而，请注意，更大的暂停时间将允许更多的垃圾进入堆。这意味着GC的下一次运行将更加昂贵。另一方面，较小的暂停时间将指示GC更频繁地运行，这可能会导致应用程序在垃圾回收上花费太多时间。
- en: Next, the maximum throughput that we want to achieve can be set via the `-XX:GCTimeRatio`
    option. This option is evaluated as the ratio between the time spent inside vs.
    outside the GC. It is a percentage computed as 1/(1 + n). In other words, `-XX:GCTimeRatio`
    specifies the amount of time dedicated to garbage collection in a 1/(1+n) ratio.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要达到的最大吞吐量可以通过`-XX:GCTimeRatio`选项来设置。此选项是GC内部与外部花费时间的比率。这是一个计算为1/(1+n)的百分比。换句话说，`-XX:GCTimeRatio`指定了在1/(1+n)比率中分配给垃圾回收的时间量。
- en: For instance, if we set this option as `-XX:GCTimeRatio=14`, then we target
    a goal of 1/15\. This means that 6% of the total time should be spent in garbage
    collection (by default, this option is set to 99, or 1% of time is spent on garbage
    collection).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们设置此选项为 `-XX:GCTimeRatio=14`，那么我们的目标是 1/15。这意味着总时间的 6% 应该用于垃圾收集（默认情况下，此选项设置为
    99，即 1% 的时间用于垃圾收集）。
- en: If you get an `OutOfMemoryError`, then most probably, this is caused by too
    much time spent on garbage collection. For instance, if more than 98% of the time
    is spent recovering less than 2% of the heap, then you’ll see such an error. In
    other words, GC has spent a lot of time cleaning a small part of the heap. This
    may indicate memory leaks or a heap that is too small. Nevertheless, if you can
    live with this error, then you can suppress it via the `-XX:-UseGCOverheadLimit`
    option.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到 `OutOfMemoryError`，那么这很可能是由于垃圾收集花费了太多时间造成的。例如，如果超过 98% 的时间用于恢复不到 2% 的堆，那么您将看到这样的错误。换句话说，GC
    花了很长时间清理堆的小部分。这可能表明存在内存泄漏或堆太小。尽管如此，如果您可以容忍这个错误，那么您可以通过 `-XX:-UseGCOverheadLimit`
    选项来抑制它。
- en: We can also control the size of the *Young*/*Old* generation. You can control
    the growth of the *Young* generation via `-XX:YoungGenerationSizeIncrement`, and
    the growth of the *Old* generation via `-XX:TenuredGenerationSizeIncrement`. The
    values of these options are percentages (by default, the growth percentage is
    20% and the shrinking percentage is 5%). Moreover, you can control the shrinking
    percentage by simply setting the `-XX:AdaptiveSizeDecrementScaleFactor` option.
    The shrinking of the *Young* generation is automatically computed via `-XX:YoungGenerationSizeIncrement`/`-XX:AdaptiveSizeDecrementScaleFactor`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以控制 *Young*/*Old* 代的大小。您可以通过 `-XX:YoungGenerationSizeIncrement` 控制年轻代的增长，通过
    `-XX:TenuredGenerationSizeIncrement` 控制老年代的成长。这些选项的值是百分比（默认情况下，增长百分比为 20%，缩减百分比为
    5%）。此外，您可以通过简单地设置 `-XX:AdaptiveSizeDecrementScaleFactor` 选项来控制缩减百分比。*Young* 代的缩减会自动通过
    `-XX:YoungGenerationSizeIncrement`/`-XX:AdaptiveSizeDecrementScaleFactor` 计算。
- en: Tuning the G1 garbage collector
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整 G1 垃圾收集器
- en: The G1 garbage collector can be enabled via `-XX:+UseG1GC`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `-XX:+UseG1GC` 启用 G1 垃圾收集器。
- en: By default, G1 takes care of the *Young* generation. Basically, it cleans the
    *Young* generation and promotes the reachable objects to the *Old* generation
    until it hits a threshold of 45%. This default value can be altered via `-XX:InitiatingHeapOccupancyPercent`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，G1 负责管理 *Young* 代。基本上，它会清理 *Young* 代并将可达对象提升到 *Old* 代，直到达到 45% 的阈值。此默认值可以通过
    `-XX:InitiatingHeapOccupancyPercent` 进行更改。
- en: When tuning the G1 collector, we can target throughput, latency, or footprint.
    When tuning for latency, we have to focus on low pause times. This can be achieved
    by setting the `–Xmx` and `–Xms` options at the same value (to avoid heap resizing).
    Moreover, we can rely on the `-XX:+AlwaysPreTouch` and `-XX:+UseLargePages` flag
    options to load the (large) memory pages at the start of the application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当调整 G1 收集器时，我们可以针对吞吐量、延迟或占用空间进行优化。当针对延迟进行优化时，我们必须关注低暂停时间。这可以通过将 `–Xmx` 和 `–Xms`
    选项设置为相同的值（以避免堆大小调整）来实现。此外，我们可以依靠 `-XX:+AlwaysPreTouch` 和 `-XX:+UseLargePages`
    标志选项在应用程序启动时加载（大）内存页面。
- en: If latency is affected by the *Young* generation size, then it is a good idea
    to decrease its size via `-XX:G1NewSizePercent` and `-XX:G1MaxNewSizePercent`.
    On the other hand, if the *Mixed* GC events affect latency, then we should focus
    on spreading the *Tenured* space across more collections via the `-XX:G1MixedGCCountTarget`
    flag option. In addition, we may want to focus on `-XX:G1HeapWastePercent` (stop
    earlier the *Tenured* space cleanup) and `-XX:G1MixedGCLiveThresholdPercent` (the
    *Tenured* space becomes part of a mixed collection only when this threshold is
    exceeded (defaults to 65)). You may also be interested in `-XX:G1RSetUpdatingPauseTimePercent`,
    `-XX:-ReduceInitialCardMarks`, and `-XX:G1RSetRegionEntries` (for details, see
    the G1 documentation).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟受到 *Young* 代大小的影响，那么通过 `-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent`
    减小其大小是一个好主意。另一方面，如果 *Mixed* GC 事件影响延迟，那么我们应该通过 `-XX:G1MixedGCCountTarget` 标志选项在更多收集中分配
    *Tenured* 空间。此外，我们可能还想关注 `-XX:G1HeapWastePercent`（提前停止 *Tenured* 空间清理）和 `-XX:G1MixedGCLiveThresholdPercent`（只有当此阈值超过时，*Tenured*
    空间才成为混合收集的一部分，默认为 65）。您可能还对 `-XX:G1RSetUpdatingPauseTimePercent`、`-XX:-ReduceInitialCardMarks`
    和 `-XX:G1RSetRegionEntries`（有关详细信息，请参阅 G1 文档）感兴趣。
- en: When tuning for throughput (applications that manipulate a lot of data need
    a GC capable of cleaning as much garbage as possible), we have to focus on the
    `-XX:MaxGCPauseMillis` option. When this option has a low effect, then you should
    focus on `-XX:G1NewSizePercent` and `-XX:G1MaxNewSizePercent`. Basically, G1 strives
    to bound the *Young* generation size between the values of `-XX:G1NewSizePercent`
    (default is 5) and `-XX:G1MaxNewSizePercent` (default is 60). By juggling these
    three options, we can relax the GC and give it more time and space to process
    a lot of garbage. In addition, throughput can be sustained via the `-XX:G1RSetUpdatingPauseTimePercent`
    option.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当调整吞吐量（处理大量数据的应用程序需要能够清理尽可能多的垃圾的 GC）时，我们必须关注 `-XX:MaxGCPauseMillis` 选项。当此选项效果较低时，我们应该关注
    `-XX:G1NewSizePercent` 和 `-XX:G1MaxNewSizePercent`。基本上，G1 力求将 *Young* 代的大小限制在
    `-XX:G1NewSizePercent`（默认为 5）和 `-XX:G1MaxNewSizePercent`（默认为 60）的值之间。通过调整这三个选项，我们可以放宽
    GC，给它更多的时间和空间来处理大量垃圾。此外，吞吐量可以通过 `-XX:G1RSetUpdatingPauseTimePercent` 选项来维持。
- en: By increasing the value of this option, we decrease the time spent in concurrent
    parts while performing more work when pausing the application’s threads. In addition,
    as in the case of tuning for latency, we may want to avoid heap resizing (set
    `–Xmx` and `–Xms` at the same value) and turn on the `-XX:+AlwaysPreTouch` and
    `-XX:+UseLargePages` flag options.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加此选项的值，我们可以在暂停应用程序线程时进行更多工作，同时减少在并发部分花费的时间。此外，与调整延迟的情况一样，我们可能想要避免堆大小调整（将
    `–Xmx` 和 `–Xms` 设置为相同的值）并开启 `-XX:+AlwaysPreTouch` 和 `-XX:+UseLargePages` 标志选项。
- en: Tuning for footprint may be influenced by setting the `-XX:GCTimeRatio`. This
    defaults to 12 (8%) but we can increase it to force the GC to spend more time
    in garbage collection. As a result, more heap memory will be free, but this is
    not a general rule. It is recommended to experiment and see how it really works.
    Moreover, since JDK 8 (update 20), we can set up the `-XX:+UseStringDeduplication`
    flag option. Practically, if this option is enabled, then G1 locates duplicate
    strings and holds a single reference to one string while cleaning up the duplicates.
    This should result in a more efficient and optimal usage of the heap memory. You
    also may want to consult the documentation for `-XX:+PrintStringDeduplicationStatistics`
    and `-XX:StringDeduplicationAgeThreshold=n`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 调整内存占用大小可能会受到设置 `-XX:GCTimeRatio` 的影响。默认值为 12（8%），但我们可以将其增加以迫使垃圾回收（GC）花费更多时间在垃圾回收上。结果，将有更多的堆内存被释放，但这并不是一个普遍的规则。建议进行实验以了解其真实效果。此外，自
    JDK 8（更新 20）以来，我们可以设置 `-XX:+UseStringDeduplication` 标志选项。实际上，如果启用此选项，那么 G1 在清理重复字符串时会定位重复的字符串，并保留对其中一个字符串的单个引用。这应该会导致堆内存的更高效和优化使用。您还可能希望查阅
    `-XX:+PrintStringDeduplicationStatistics` 和 `-XX:StringDeduplicationAgeThreshold=n`
    的文档。
- en: As you already know, G1 splits the heap into small regions up to 32 MB. In practice,
    this may lead to performance degradation, especially for large objects on very
    large heaps. But, starting with JDK 18, the maximum region size was set up to
    512 MB. Whenever you need, you can control the maximum region size via the `-XX:G1HeapRegionSize`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，G1 将堆分成最多 32 MB 的小区域。在实践中，这可能会导致性能下降，尤其是在非常大的堆上处理大对象时。但是，从 JDK 18 开始，最大区域大小被设置为
    512 MB。您需要时，可以通过 `-XX:G1HeapRegionSize` 控制最大区域大小。
- en: Tuning Z Garbage Collector
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整 Z 垃圾回收器
- en: Z Garbage Collector can be enabled via `-XX:+UseZGC` (before JDK 15, you may
    also need `-XX:+UnlockExperimentalVMOptions`).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Z 垃圾回收器可以通过 `-XX:+UseZGC` 启用（在 JDK 15 之前，您可能还需要 `-XX:+UnlockExperimentalVMOptions`）。
- en: One of the most important settings of this GC is `–Xmx` to set up the maximum
    heap size. Next to this one, we have `-XX:ConcGCThreads=n`, where `n` is the number
    of threads used by ZGC. However, ZGC is fully capable of dynamically determining
    the optimal value for this option, so think twice before modifying it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 GC 最重要的设置之一是 `–Xmx`，用于设置最大堆大小。接下来是 `-XX:ConcGCThreads=n`，其中 `n` 是 ZGC 使用的线程数。然而，ZGC
    完全能够动态确定此选项的最佳值，因此在修改之前请三思。
- en: Tuning Metaspace (Metadata space)
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整元空间（元数据空间）
- en: 'If your focus is on tuning Metaspace, then you’ll be interested in the following
    options:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的重点是调整元空间，那么您会对以下选项感兴趣：
- en: '`-XX:MetaspaceSize` – Set the initial size of Metaspace'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MetaspaceSize` – 设置元空间的初始大小'
- en: '`-XX:MaxMetaspaceSize` – Set the maximum size of Metaspace'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxMetaspaceSize` – 设置元空间的最大大小'
- en: '`-XX:MinMetaspaceFreeRatio` – Set the class metadata capacity that should be
    free after running the GC (this is the minimum value as a percentage)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MinMetaspaceFreeRatio` – 设置 GC 运行后应空闲的类元数据容量（这是作为百分比的最低值）'
- en: '`-XX:MaxMetaspaceFreeRatio` – Set the class metadata capacity that should be
    free after running the GC (this is the maximum value as a percentage)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxMetaspaceFreeRatio` – 设置 GC 运行后应空闲的类元数据容量（这是作为百分比的最高值）'
- en: Controlling the size and behavior of the Metaspace can also be part of tuning
    your GC. Again, experimenting and comparing the results is the main rule of thumb
    that can lead you to a successful and optimal GC.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 控制元空间的大小和行为也可以是调整 GC 的一部分。再次强调，实验和比较结果是你通往成功和最佳 GC 的主要规则。
- en: 257\. Introducing Application Class Data Sharing (AppCDS, or Java’s Startup
    Booster)
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 257. 介绍应用程序类数据共享（AppCDS，或 Java 的启动加速器）
- en: 'Launching a Java application is a multi-step process. Before executing the
    bytecode of a class, the JVM has to perform at least the following steps for a
    given class name:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Java 应用程序是一个多步骤的过程。在执行类的字节码之前，JVM 必须为给定的类名执行至少以下步骤：
- en: Look up the class on disk (JVM has to scan the disk and find the given class
    name).
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在磁盘上查找类（JVM 必须扫描磁盘并找到给定的类名）。
- en: Load the class (JVM opens the file and loads its content).
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载类（JVM 打开文件并加载其内容）。
- en: Check the bytecode (JVM verifies the integrity of the content).
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查字节码（JVM 验证内容的一致性）。
- en: Pull the bytecode internally (JVM transfers the code into an internal data structure).
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部拉取字节码（JVM 将代码传输到内部数据结构）。
- en: Obviously, these steps are not cost-free. Loading hundreds/thousands of classes
    will have a significant overhead on launching time and memory footprint. Typically,
    an application’s JAR remains unchanged for a long time, but JVM performs the previous
    steps and obtains the same result every time we launch the application.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些步骤并非没有成本。加载数百/数千个类将在启动时间和内存占用上产生显著开销。通常，应用程序的 JAR 文件在很长时间内保持不变，但 JVM 执行前面的步骤，并在每次启动应用程序时获得相同的结果。
- en: Improving/accelerating the startup performance and even reducing the memory
    footprint are the main goals of Application Class Data Sharing (AppCDS). In a
    nutshell, AppCDS was initially popularized in JDK 10 (2018), and it was simplified
    in JDK 13 and JDK 19\. The idea of AppCDS is to perform the previous steps once
    and dump the result into an archive. This archive can be reused for subsequent
    launches and even shared across multiple JVM instances running on the same host.
    The bigger the application is, the bigger the startup benefits are.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 提高或加速启动性能，甚至减少内存占用，是应用程序类数据共享（AppCDS）的主要目标。简而言之，AppCDS 最初在 JDK 10（2018）中流行起来，并在
    JDK 13 和 JDK 19 中简化。AppCDS 的想法是只执行前面的步骤一次，并将结果存入存档。这个存档可以用于后续的启动，甚至可以在同一主机上运行的多个
    JVM 实例之间共享。应用程序越大，启动时的好处就越大。
- en: 'Putting these ideas into practice requires the following three steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些想法付诸实践需要以下三个步骤：
- en: Create the list of classes that should be shared between the application instances.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应在应用程序实例之间共享的类列表。
- en: Archive this list of classes in an archive suitable for memory mapping.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个类列表存档到适合内存映射的存档中。
- en: Give the resulting archive to every application startup (every application instance).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的存档提供给每个应用程序启动（每个应用程序实例）。
- en: 'Depending on the JDK used, you may have to manually follow these steps or only
    a part of them. The AppCDS algorithm is constantly improved, so its use depends
    on your JDK, as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的 JDK，你可能需要手动遵循这些步骤或其中的一部分。AppCDS 算法不断改进，因此其使用取决于你的 JDK，如下所示：
- en: In JDK 10/11, you have to follow the previous three steps. However, if you want
    to share only the JDK classes (not the application classes), then you can skip
    step 1\. JDK has already prepared the list of classes that should be shared in
    `$JAVA_HOME\lib\classlist` (there are around 1,200 classes).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JDK 10/11 中，你必须遵循前面的三个步骤。然而，如果你想只共享 JDK 类（而不是应用程序类），那么你可以跳过步骤 1。JDK 已经在 `$JAVA_HOME\lib\classlist`
    中准备了应共享的类列表（大约有 1,200 个类）。
- en: In JDK 12+, you can skip steps 1 and 2 because an archive of JDK classes is
    already available. However, if you want to share the application classes as well,
    then you need to follow all three steps.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JDK 12+ 中，你可以跳过步骤 1 和 2，因为 JDK 类的存档已经可用。然而，如果你想共享应用程序类，那么你需要遵循所有三个步骤。
- en: In JDK 13+, we can take advantage of dynamic CDS archives. Practically, JVM
    collects the classes to be added into the archive at application runtime. Steps
    1 and 2 are merged automatically.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JDK 19+, we can take advantage of the autogenerated shared archive. The CDS
    archive is built and used in a single command.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tackling a JDK class data archive
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tackling a JDK class data archive means that we will create a reusable archive
    containing only JDK classes, not the classes of our application.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: JDK 10/JDK 11
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JDK 10/11, we can use the already existent `$JAVA_HOME/lib/classlist`. This
    is a file that contains the list of JDK classes, and you can easily inspect it
    with a text editor. Having the class list, we can create the proper CDS archive
    via the `–Xshare:dump` option, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The resulting archive will be stored in `$JAVA_HOME\bin\server\classes.jsa`
    (this is the default location and you may need to run this command as an administrator
    to avoid a permission denied restriction).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can use this archive via `–Xshare:on`, as follows (if you run under
    JDK 11, then `--enable-preview` is also needed, but I’ll skip it here):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use the unified logging system to track CDS work via `–Xlog`, as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the output, we can see that a shared object is marked with a significant
    message, as follows (objects that are not shared don’t contain the “*shared objects
    file*” text):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, JVM scans for archives in the default location. But, if we move
    the archive to another location (for instance, in the application root folder),
    then we have to indicate this location via `-XX:SharedArchiveFile`, as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Actually, the default value of `–Xshare` is `auto`. This means that if an archive
    is found, then it is used automatically. So, if you omit `–Xshare:on`, then JVM
    relies on `–Xshare:auto`, which has the same effect. If you want to shut down
    CDS support, then use `–Xshare:off`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: JDK 12+
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JDK 12+ comes with an already prepared archive for JDK classes, so there is
    no need to create one (no need to use `–Xshare:dump`). JVM will use it automatically
    thanks to `–Xshare:auto` or via the explicit `–Xshare:on`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, if you have a different location than the default one (`$JAVA_HOME\bin\server\classes.jsa`),
    then use `-XX:SharedArchiveFile`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Tackling application class data archive
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the JDK classes, we may want to share our application classes as well.
    This can be done in several steps depending on the JDK.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Before JDK 13
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before JDK 13, we need to create the list of classes that we want to share.
    We can do it manually or via the `-XX:DumpLoadedClassList` option, as follows
    (I’ll skip it here, but you’ll need `--enable-preview` as well):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The generated `classes.lst` contains all classes (classes used by the JDK +
    your application classes) that will be shared. Next, we can obtain the archive,
    as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Consider the following important note.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Notice that CDS (AppCDS) can archive classes from JAR files only. Don’t use
    classpaths with wildcards or exploded paths such as `target/classes`. Replace
    `app.jar` with your JAR.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CDS（AppCDS）只能从 JAR 文件存档类。不要使用带有通配符或展开路径的类路径，例如 `target/classes`。将 `app.jar`
    替换为您的 JAR 文件。
- en: The archive (`appcds.jsa`) is stored in the application root folder, not in
    `$JAVA_HOME`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 存档 (`appcds.jsa`) 存储在应用程序根目录中，而不是在 `$JAVA_HOME` 中。
- en: 'Finally, we can share the archive and get some logs, as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以分享存档并获取一些日志，如下所示：
- en: '[PRE16]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Done!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: JDK 13+
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDK 13+
- en: 'Starting with JDK 13, we can take advantage of *dynamic application class-data
    sharing*. In other words, we can obtain the archive when JVM exits via the `-XX:ArchiveClassesAtExit`
    option, as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 13 开始，我们可以利用 *动态应用程序类数据共享*。换句话说，我们可以通过 `-XX:ArchiveClassesAtExit` 选项在
    JVM 退出时获取存档，如下所示：
- en: '[PRE17]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Replace `app.jar` with your JAR. Use the generated archive as usual via `-Xshare:on`
    and `-XX:SharedArchiveFile`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `app.jar` 替换为您的 JAR 文件。通过 `-Xshare:on` 和 `-XX:SharedArchiveFile` 选项像往常一样使用生成的存档。
- en: JDK 19+
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JDK 19+
- en: 'Starting with JDK 19, we can rely on autogenerated archives. This is possible
    in a single command, as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JDK 19 开始，我们可以依赖自动生成的存档。这可以通过单个命令实现，如下所示：
- en: '[PRE18]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time, JVM checks if an archive exists at the path given via `-XX:SharedArchiveFile`.
    If such an archive exists, then JVM loads and uses it; otherwise, at exit, JVM
    will generate an archive at that location. Moreover, JVM checks the JDK version
    used for creating the archive. If the current JDK version (the JVM JDK version)
    and the archive JDK are not the same, then JVM will overwrite the existing archive.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，JVM 会检查通过 `-XX:SharedArchiveFile` 选项提供的路径上是否存在存档。如果存在这样的存档，则 JVM 会加载并使用它；否则，在退出时，JVM
    将在该位置生成一个存档。此外，JVM 会检查创建存档所使用的 JDK 版本。如果当前 JDK 版本（JVM JDK 版本）和存档 JDK 版本不同，则 JVM
    将覆盖现有的存档。
- en: 'You may also be interested in the following article: [https://spring.io/blog/2023/12/04/cds-with-spring-framework-6-1](https://spring.io/blog/2023/12/04/cds-with-spring-framework-6-1).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还对以下文章感兴趣：[https://spring.io/blog/2023/12/04/cds-with-spring-framework-6-1](https://spring.io/blog/2023/12/04/cds-with-spring-framework-6-1)。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered 15 problems with garbage collectors and AppCDS. Even if
    these problems have been mostly theoretical, they still represent major topics
    that can boost your application performance at runtime (in the GC case) and startup
    (in the AppCDS case).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 15 个与垃圾收集器和 AppCDS 相关的问题。即使这些问题大多是理论性的，它们仍然代表了可以提升您应用程序在运行时（在 GC 的情况下）和启动时（在
    AppCDS 的情况下）性能的主要主题。
- en: Join our community on Discord
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ)'
- en: '![](img/QR_Code1139613064111216156.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1139613064111216156.png)'
