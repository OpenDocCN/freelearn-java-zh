- en: Advanced Application Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some advanced features of Quarkus that will
    help you design and code cutting-edge Quarkus applications. The topics we will
    learn about will cover different areas of Quarkus API, ranging from advanced configuration
    options to controlling the life cycle of a Quarkus application and firing time-based
    events using the Quarkus scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to leverage the following advanced
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced MicroProfile configuration options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the life cycle events of your services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling periodic tasks in your services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Using advanced configuration options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already learned, Quarkus relies on the MicroProfile Config specification
    to inject configuration properties into our application. So far, we have used
    the default configuration file (named `application.properties`) to provide initial
    values for the application's initial settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap with a basic example of how to inject a property, including a
    default value for the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are injecting an application property into the `fileName`
    variable. Note that property names should be carefully planned since Quarkus ships
    with an extensive set of system properties that can be used to manage its environment.
    Luckily, you don''t need to have your documentation at hand to check for all the
    available system properties. As a matter of fact, you can use Maven''s `generate-config`
    command to list all the built-in system properties, based on the extensions that
    you have currently installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a file named `application.properties.example` under
    the `src/main/resources` folder. If you open this file, you will see that it contains
    a commented list of all the available configuration options, which are located
    under the `quarkus` namespace. Here is a brief excerpt of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, you can choose a different filename for `generate-command` by
    adding the `-Dfile=<filename>` option.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will learn about some advanced configuration drills
    using the examples located in the `Chapter08/advanced-config` folder of this book's
    GitHub repository as references. We recommend importing the project into your
    IDE before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple configuration sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `application.properties` file is not the only option when it comes to setting
    application properties. As per MicroProfile''s Config specification, you can also
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java system properties**: Java system properties can be read/written programmatically
    by means of the `System.getProperty()` and `System.setProperty()` APIs. As an
    alternative, you can set a property on the command line with the `-D` option,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Environment variables**: This requires setting an environment variable for
    the property, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the matching environment variable name has been set
    to uppercase and the dot has been replaced with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, in the current version of Quarkus, it is required that the
    variable is also defined in `application.properties` so that it can be overridden
    by the environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is also possible to collect our configuration from an external source
    by adding a new configuration source to our application. The next section will
    show us how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring custom configuration sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the examples we've created so far, we have assumed that the application
    configuration is picked up from the `src/main/resources/application.properties`
    file, which is the default for Quarkus applications. Nevertheless, since Quarkus
    fully supports the **MicroProfile Config** specification, it is entirely possible
    to load the configuration from another source, which could be an external filesystem,
    a database, or anything that can be loaded by a Java application!
  prefs: []
  type: TYPE_NORMAL
- en: In order to do that, you have to implement the `org.eclipse.microprofile.config.spi.ConfigSource`
    interface, which exposes a set of methods for loading properties (`getProperties`),
    retrieving the properties' names (`getPropertyNames`), and retrieving the corresponding
    value (`getValue`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As proof of concept, take a look at the following implementation, which is
    available in the `Chapter08/advanced-config` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code itself is pretty simple if you are familiar with the `java.io` API.
    The `FileConfigSource` class attempts to load an external configuration from the
    `/tmp/config.properties` path of your filesystem. It is worth mentioning that
    an `ORDINAL` variable has been set to specify the order for this `ConfigSource`
    class in case some properties are loaded from multiple sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for a `ConfigSource` is set to `100`, and sources with the
    highest ordinal value have priority in case the property is defined across multiple
    sources. Here is the ranking of the available configuration sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Config source** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `application.properties` | `100` |'
  prefs: []
  type: TYPE_TB
- en: '| Environment variables | `300` |'
  prefs: []
  type: TYPE_TB
- en: '| System properties | `400` |'
  prefs: []
  type: TYPE_TB
- en: Since we have set the `ORDINAL` variable to `900` in our example, it will prevail
    over the other configuration sources, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the custom `ConfigSource` is available in the project, we need to register
    for this class. For this purpose, we have added a file named `org.eclipse.microprofile.config.spi.ConfigSource`
    under the `resources/META-INF/services` folder of the project. Here''s a tree
    view of the project, under the `resources` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this file, we have specified the fully qualified name of `ConfigSource`.
    In our case, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, as soon as the application is started, the custom `ConfigSource` will be
    loaded and its properties will prevail over other potential duplicates of the
    same attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `AdvancedConfigTest` class of your project, you will find one assertion,
    which verifies that one property has been loaded from the external `FileConfigSource`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: More details about the `AdvancedConfigTest` class will be discussed later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using converters in your configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To discuss configuration converters, let''s take this simple configuration
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it''s perfectly fine to inject the preceding properties into our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the MicroProfile Config API provides a type-safe conversion
    for values that are not just plain strings.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that we can provide a default value for a property, which will be
    used if the property hasn't been defined in our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens by providing converters in the configuration model. Out of the
    box, some converters are already provided by the MicroProfile Config API by default.
    Here''s a list of the built-in converters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean` and `java.lang.Boolean`. The following values are converted into
    Booleans (case-insensitive): `true`, `YES`, `Y`, `1`, and `ON`. Any other value
    will be `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte` and `java.lang.Byte`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short` and `java.lang.Short`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` and `java.lang.Integer`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long` and `java.lang.Long`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` and `java.lang.Float`. A dot `.` is used to separate the fractional
    digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double` and `java.lang.Double`. A dot `.` is used to separate the fractional
    digits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char` and `java.lang.Character`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Class`. This is based on the result of `Class.forName`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Array, list, and set are also supported. In order to inject one of these Collections
    into a class variable, you can use the comma (`,`) char as a delimiter and `\`
    as the escape character. For example, take the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will inject the preceding configuration into a `java.util.List`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In much the same way, you can use built-in converters to generate an `Array`
    from a list of values. Take a look at the following configuration example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding configuration can be injected into an array of strings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Even classes can be injected as part of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, the class will be searched by the class loader and created using
    the `Class.forName` construct. We can put it in our code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s worth mentioning that you can inject the whole `Config` object
    and retrieve the single properties each time you need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's explore some more advanced strategies for creating type converters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the list of built-in converters is not enough, you can still create custom
    converters by implementing the generic interface, that is, `org.eclipse.microprofile.config.spi.Converter`.
    The `Type` parameter of the interface is the target type the string is converted
    into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is for the target `Type` parameter, which derives from a
    plain Java string that we have included in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to register your converter in a file named `resources/META-INF/services/org.eclipse.microprofile.config.spi.Converter`.
    Include the fully qualified class name of the custom implementation. For example,
    in our case, we have added the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s learn how to use our custom converter in practice. To do that,
    we will add the following line to the `application.properties` file, which uses
    the pattern coded in the constructor of the `CustomConfigValue` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the custom converter can be injected into our code as a class attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although the preceding example does nothing fancy, it shows us how we can create
    a customized property based on class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing advanced configuration options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the `Chapter08/advanced-config/src/test` folder of this chapter, you
    will find a test class named `AdvancedConfigTest`, which will verify the key concepts
    that we've learned about so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run all of these tests successfully, copy the `customconfig.properties`
    file into the `/tmp` folder of your drive, otherwise one of the assertions contained
    in the `AdvancedConfigTest` class will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, simply run the `install` goal, which will trigger the test''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You should see that all the tests contained in `AdvancedConfigTest` pass.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just learned how to create complex configurations using built-in converters
    and, for the most demanding, custom converters. What about if we need to switch
    between different configurations, for example, when moving from a development
    environment to a production one? Here, you can duplicate your configuration. However,
    the proliferation of configuration files is not always welcome in IT projects.
    Let's learn how to deal with this concern using **configuration profiles**.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, configuration profiles allow us to specify namespaces for our
    profiles in our configuration so that we can bind each property to a specific
    profile in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, Quarkus ships with the following configuration profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev`: This is triggered when running in development mode (that is, `quarkus:dev`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This is triggered when running tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`prod`**: This is picked up when we''re not running in development or test
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the preceding profiles, you can define your own custom profiles, which
    will be activated according to the rules we specified in the *Activating profiles*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following syntax to bind a configuration parameter to a specific
    profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To see a practical example of this, we will go through the source code in the
    `Chapter08/profiles` folder of this book's GitHub repository. We recommend importing
    the project into your IDE before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by checking its `application.properties` configuration file, which
    defines multiple profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, we have specified three different JDBC URLs
    for our data source connection. Each one is bound to a different profile. We have
    also set a specific connection pool setting for the production profile in order
    to grant a larger number of database connections. In the next section, we will
    learn how to activate every single profile.
  prefs: []
  type: TYPE_NORMAL
- en: Activating profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s learn how to activate a specific profile by taking the `prod` profile
    in the preceding configuration as an example. First of all, we need to start a
    PostgreSQL instance named `postgresProd` and bind it to port `7432`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to provide profile information during the `package` phase, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the application, it will pick up the profile you specified in
    the `package` phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, it is also possible to specify the profile using the `QUARKUS_PROFILE`
    environment variable, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s worth mentioning that the same strategy can be used to define
    non standard profiles. For example, let''s say we want to add a **staging** profile
    for applications that need to be checked before production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can apply the same strategy we've used for other profiles, that is,
    we can either specify the profile at application startup using the Java system
    property (`quarkus-profile`) or add the necessary information to the `QUARKUS_PROFILE`
    environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic profile selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To simplify development and testing, the `dev` and `test` profiles can be automatically
    triggered by the Maven plugin. So, for example, if you are executing Quarkus in
    development mode, the `dev` profile will be used eventually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In much the same way, the `test` profile will be activated when tests are executed,
    for example, during the `install` life cycle phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test` profile will be activated when you execute the Maven `test` goal.
    Additionally, it''s worth knowing that you can set a different profile for your
    tests through `maven-surfire-plugin`, within its system properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we walked through application profiles. In the next section,
    we'll learn how to control the life cycle of our Quarkus applications.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the application life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Controlling the application life cycle is a common requirement for your services
    to be able to bootstrap some external resources or verify the status of your components.
    One simple strategy, borrowed from the Java Enterprise API, is to include the
    **Undertow** extension (or any upper layer, such as rest services) so that you
    can leverage `ServletContextListener`, which is notified when a web application
    is created or destroyed. Here is a minimal implementation of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Although it is perfectly fine to reuse this strategy in a Quarkus web application,
    it is recommended to use this approach for any kind of Quarkus service. This can
    be done by observing the `io.quarkus.runtime.StartupEvent` and `io.quarkus.runtime.ShutdownEvent`
    events. Additionally, in CDI applications, you can observe an event with the `@Initialized(ApplicationScoped.class)`
    qualifier, which is fired when the application context is initialized. This can
    be particularly useful for bootstrapping resources such as databases, which are
    required before the configuration is read by Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: To see a practical example of this, check the source code that's available in
    the `Chapter08/lifecycle` folder of this book's GitHub repository. As usual, it's
    advised to import the project into your IDE before you move on. The purpose of
    this example is to show you how to replace the PostgreSQL database, in our customer
    service, with the H2 database ([https://www.h2database.com/](https://www.h2database.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the configuration, the life cycle project doesn''t contain the
    PostgreSQL JDBC dependency anymore. To replace this, the following one has been
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To test our customer service, we have included two H2 database configuration
    profiles: one that''s bound to the `dev` profile and one that''s bound to the
    `test` profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To bind the H2 database before the application context is started, we can use
    the following `DBLifeCycleBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is able to intercept the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context startup**: This is captured through the `observeContextInit` method.
    The database is bootstrapped in this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application startup**: This is captured through the `onStart` method. We
    are simply performing some logs when this event is fired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application shutdown**: This is captured through the `onStop` method. We
    are shutting down the database in this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you can start Quarkus in the `dev` profile as usual with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is started, we will be notified that the H2 database has
    been started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will receive one more notification on application startup, where we
    can include some extra tasks to be completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we stop the application, the resource will be dismissed, as shown
    in the following console logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Before shutting down the database, you can enjoy running your customer service
    example with a tiny in-memory database layer.
  prefs: []
  type: TYPE_NORMAL
- en: Activating a database test resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a bonus tip, we will show you how to activate the H2 database during the
    test life cycle. This can be done by adding a class, annotated as `@QuarkusTestResource`,
    to your test classes while passing the `H2DatabaseTestResource` class as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`H2DatabaseTestResource` basically performs the same actions that `DBLifeCycleBean`
    does, before our tests are fired. Note that the following dependency has been
    added into the project to run the preceding test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can safely run tests against the `test` profile with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, before our tests are executed, the following log will confirm that
    the H2 database has been started on one of our available IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Bootstrapping external resources is indeed a common use case for life cycle
    managers. Another frequent use case consists of scheduling events at the application
    startup phase. In the next section, we will discuss how to fire events using Quarkus'
    scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: Firing events with the Quarkus scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus includes an extension called **scheduler**, which can be used to schedule
    tasks for single or repeated execution. We can use the cron format to specify
    the number of times the scheduler fires the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the following example is located in the `Chapter08/scheduler`
    folder of this book''s GitHub repository. If you check the `pom.xml` file, you
    will notice that the following extension has been added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our sample project generates a random token (for the sake of simplicity, a
    random string is used) every 30 seconds. The class that''s in charge of generating
    random tokens is the following `TokenGenerator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can have our token injected into the built-in REST endpoint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the application as usual with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that, every 30 seconds, the following message is printed in
    the console logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by requesting the `/token` URL, the randomly generated string will be
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Using the cron scheduler format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides using time expressions (**s=seconds**, **m=minutes**, **h=hours**,
    **d=days**), you can opt for the more compact expression of the cron scheduler.
    Therefore, if you wanted to fire the event every second, then you could use the
    following cron expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the cron main page for more information about the cron format: [http://man7.org/linux/man-pages/man5/crontab.5.html](http://man7.org/linux/man-pages/man5/crontab.5.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Firing one-time events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to execute one-time events, then you can inject the `io.quarkus.scheduler.Scheduler`
    class into your code directly and use the `startTimer` method, which will fire
    the execution of an action in a separate thread. This can be seen in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this brief excerpt, we can see how a single event, which will be executed
    in the `oneTimeAction()` method, can fire a one-time action after `300` milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented some advanced techniques that we can use to manage
    our configuration using converters and configuration profiles. We have also demonstrated
    how different configuration sources can be injected and prioritized over the standard
    configuration file. In the second part of this chapter, we had a look at how to
    capture the application life cycle's events and how to schedule the execution
    of future tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To make our applications even more scalable, in the next chapter, we will discuss
    how to build reactive applications, which are event-driven and non-blocking. Hold
    on tight!
  prefs: []
  type: TYPE_NORMAL
