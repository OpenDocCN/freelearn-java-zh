<html><head></head><body>
		<div id="_idContainer057">
			<h1 id="_idParaDest-122"><em class="italic">Chapter 5<a id="_idTextAnchor121"/></em>: Strings, Input/Output,and Files</h1>
			<p>In this chapter, you will be presented with the <strong class="source-inline">String</strong> class methods in more detail. We will also discuss popular string utilities from standard libraries and the Apache Commons project. An overview of Java input/output streams and the related classes of the <strong class="source-inline">java.io</strong> packages will follow, along with some classes of the <strong class="source-inline">org.apache.commons.io</strong> package. The file-managing classes and their methods are described in a dedicated section. After completing this chapter, you will be able to write code that processes strings and files, using standard Java API and Apache Commons utilities.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>String processing</li>
				<li>I/O streams</li>
				<li>File management</li>
				<li>Apache Commons’ <strong class="source-inline">FileUtils</strong> and <strong class="source-inline">IOUtils</strong> utilities </li>
			</ul>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, in this book. The files with the code examples for this chapter are available in the GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the <a href="https://examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams">examples/src/main/java/com/packt/learnjava/ch05_stringsIoStreams</a> folder. </p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>String processing</h1>
			<p>In mainstream <a id="_idIndexMarker524"/>programming, <strong class="source-inline">String</strong> probably is the most popular class. In <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, we learned about this class, its literals, and its specific feature called <strong class="bold">string immutability</strong>. In<a id="_idIndexMarker525"/> this section, we will explain how a string can be processed using the <strong class="source-inline">String</strong> class methods and utility classes from the standard library, and the <strong class="source-inline">StringUtils</strong> class from the <strong class="source-inline">org.apache.commons.lang3</strong> package in particular.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Methods of the String class </h2>
			<p>The <strong class="source-inline">String</strong> class has<a id="_idIndexMarker526"/> more than 70 methods that enable analyzing, modifying, and comparing strings, and converting numeric literals into the corresponding string literals. To see all the methods of the <strong class="source-inline">String</strong> class, please refer to the Java API online at <a href="https://docs.oracle.com/en/java/javase">https://docs.oracle.com/en/java/javase</a>.</p>
			<h3>String analysis</h3>
			<p>The <strong class="source-inline">length()</strong> method <a id="_idIndexMarker527"/>returns<a id="_idIndexMarker528"/> the number of characters in the string, as shown in the following code:</p>
			<pre class="source-code">String s7 = "42";</pre>
			<pre class="source-code">System.out.println(s7.length());    //prints: 2</pre>
			<pre class="source-code">System.out.println("0 0".length()); //prints: 3</pre>
			<p>The<a id="_idIndexMarker529"/> following <strong class="source-inline">isEmpty()</strong> method returns <strong class="source-inline">true</strong> when the length of the string (count of characters) is <strong class="source-inline">0</strong>: </p>
			<pre class="source-code">System.out.println("".isEmpty());   //prints: true</pre>
			<pre class="source-code">System.out.println(" ".isEmpty());  //prints: false</pre>
			<p>The <strong class="source-inline">indexOf()</strong> and <strong class="source-inline">lastIndexOf()</strong> methods <a id="_idIndexMarker530"/>return the position of <a id="_idIndexMarker531"/>the specified substring in the string shown in this code snippet:</p>
			<pre class="source-code">String s6 = "abc42t%";</pre>
			<pre class="source-code">System.out.println(s6.indexOf(s7));            //prints: 3</pre>
			<pre class="source-code">System.out.println(s6.indexOf("a"));           //prints: 0</pre>
			<pre class="source-code">System.out.println(s6.indexOf("xyz"));         //prints: -1</pre>
			<pre class="source-code">System.out.println("ababa".lastIndexOf("ba")); //prints: 3</pre>
			<p>As you can see, the first character in the string has a position (index) of <strong class="source-inline">0</strong>, and the absence of the specified substring results in the index <strong class="source-inline">-1</strong>.</p>
			<p>The <strong class="source-inline">matches()</strong> method applies<a id="_idIndexMarker532"/> the regular expression (passed as an argument) to the string as follows: </p>
			<pre class="source-code">System.out.println("abc".matches("[a-z]+"));   //prints: true</pre>
			<pre class="source-code">System.out.println("ab1".matches("[a-z]+"));   //prints: false</pre>
			<p>Regular <a id="_idIndexMarker533"/>expressions are outside the scope of this book. You can learn<a id="_idIndexMarker534"/> about them at <a href="https://www.regular-expressions.info">https://www.regular-expressions.info</a>. In the preceding example, the <strong class="source-inline">[a-z]+</strong> expression matches one or more letters only.</p>
			<h3>String comparison</h3>
			<p>In <a href="B18388_03_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Java Fundamentals</em>, we <a id="_idIndexMarker535"/>talked about<a id="_idIndexMarker536"/> the <strong class="source-inline">equals()</strong> method that returns <strong class="source-inline">true</strong> only when two <strong class="source-inline">String</strong> objects or literals are spelled exactly the same way. The following code snippet demonstrates how it works:</p>
			<pre class="source-code">String s1 = "abc";</pre>
			<pre class="source-code">String s2 = "abc";</pre>
			<pre class="source-code">String s3 = "acb";</pre>
			<pre class="source-code">System.out.println(s1.equals(s2));     //prints: true</pre>
			<pre class="source-code">System.out.println(s1.equals(s3));     //prints: false</pre>
			<pre class="source-code">System.out.println("abc".equals(s2));  //prints: true</pre>
			<pre class="source-code">System.out.println("abc".equals(s3));  //prints: false</pre>
			<p>Another <strong class="source-inline">String</strong> class, the <strong class="source-inline">equalsIgnoreCase()</strong> method, does a similar job but ignores the difference in the characters’ case, as follows:</p>
			<pre class="source-code">String s4 = "aBc";</pre>
			<pre class="source-code">String s5 = "Abc";</pre>
			<pre class="source-code">System.out.println(s4.equals(s5));           //prints: false</pre>
			<pre class="source-code">System.out.println(s4.equalsIgnoreCase(s5)); //prints: true</pre>
			<p>The <strong class="source-inline">contentEquals()</strong> method acts similar to the <strong class="source-inline">equals()</strong> method, as shown here:</p>
			<pre class="source-code">String s1 = "abc";</pre>
			<pre class="source-code">String s2 = "abc";</pre>
			<pre class="source-code">System.out.println(s1.contentEquals(s2));    //prints: true</pre>
			<pre class="source-code">System.out.println("abc".contentEquals(s2)); //prints: true </pre>
			<p>The<a id="_idIndexMarker537"/> difference<a id="_idIndexMarker538"/> is that the <strong class="source-inline">equals()</strong> method checks whether both values are represented by the <strong class="source-inline">String</strong> class, while <strong class="source-inline">contentEquals()</strong> compares only the characters (content) of the character sequence. The character sequence can be represented by <strong class="source-inline">String</strong>, <strong class="source-inline">StringBuilder</strong>, <strong class="source-inline">StringBuffer</strong>, <strong class="source-inline">CharBuffer</strong>, or any other class that implements a <strong class="source-inline">CharSequence</strong> interface. Nevertheless, the <strong class="source-inline">contentEquals()</strong> method will return <strong class="source-inline">true</strong> if both sequences contain the same characters, while the <strong class="source-inline">equals()</strong> method will return <strong class="source-inline">false</strong> if one of the sequences is not created by the <strong class="source-inline">String</strong> class.</p>
			<p>The <strong class="source-inline">contains()</strong> method returns <strong class="source-inline">true</strong> if the <strong class="source-inline">string</strong> contains a certain substring, as follows:</p>
			<pre class="source-code">String s6 = "abc42t%";</pre>
			<pre class="source-code">String s7 = "42";</pre>
			<pre class="source-code">String s8 = "xyz";</pre>
			<pre class="source-code">System.out.println(s6.contains(s7));    //prints: true</pre>
			<pre class="source-code">System.out.println(s6.contains(s8));    //prints: false</pre>
			<p>The <strong class="source-inline">startsWith()</strong> and <strong class="source-inline">endsWith()</strong> methods perform a similar check but only at the start of the string or the end of the string value, as shown in the following code:</p>
			<pre class="source-code">String s6 = "abc42t%";</pre>
			<pre class="source-code">String s7 = "42";</pre>
			<pre class="source-code">System.out.println(s6.startsWith(s7));      //prints: false</pre>
			<pre class="source-code">System.out.println(s6.startsWith("ab"));    //prints: true</pre>
			<pre class="source-code">System.out.println(s6.startsWith("42", 3)); //prints: true</pre>
			<pre class="source-code">System.out.println(s6.endsWith(s7));        //prints: false</pre>
			<pre class="source-code">System.out.println(s6.endsWith("t%"));      //prints: true</pre>
			<p>The <strong class="source-inline">compareTo()</strong> and <strong class="source-inline">compareToIgnoreCase()</strong> methods compare strings lexicographically – based on the Unicode value of each character in the strings. They return the<a id="_idIndexMarker539"/> value <strong class="source-inline">0</strong> if the strings are equal, a negative integer value if the first string is<a id="_idIndexMarker540"/> lexicographically less (has a smaller Unicode value) than the second string, and a positive integer value if the first string is lexicographically greater than the second string (has a bigger Unicode value), as shown here:</p>
			<pre class="source-code">String s4 = "aBc";</pre>
			<pre class="source-code">String s5 = "Abc";</pre>
			<pre class="source-code">System.out.println(s4.compareTo(s5));             //prints: 32</pre>
			<pre class="source-code">System.out.println(s4.compareToIgnoreCase(s5));   //prints: 0</pre>
			<pre class="source-code">System.out.println(s4.codePointAt(0));            //prints: 97</pre>
			<pre class="source-code">System.out.println(s5.codePointAt(0));            //prints: 65</pre>
			<p>From this code snippet, you can see that the <strong class="source-inline">compareTo()</strong> and <strong class="source-inline">compareToIgnoreCase()</strong> methods are based on the code points of the characters that compose the strings. The reason the <strong class="source-inline">s4</strong> string is bigger than the <strong class="source-inline">s5</strong> string by <strong class="source-inline">32</strong> is because the code point of the <strong class="source-inline">a</strong> character (<strong class="source-inline">97</strong>) is bigger than the code point of the <strong class="source-inline">A</strong> character (<strong class="source-inline">65</strong>) by <strong class="source-inline">32</strong>. </p>
			<p>The given example also shows that the <strong class="source-inline">codePointAt()</strong> method returns the code point of the<a id="_idIndexMarker541"/> character located in the string at the specified position. The code points were described<a id="_idIndexMarker542"/> in the <em class="italic">Integral types</em> section of <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>.</p>
			<h3>String transformation</h3>
			<p>The <strong class="source-inline">substring()</strong> method<a id="_idIndexMarker543"/> returns the substring, starting <a id="_idIndexMarker544"/>with the specified position (index), as follows:</p>
			<pre class="source-code">System.out.println("42".substring(0));   //prints: 42</pre>
			<pre class="source-code">System.out.println("42".substring(1));   //prints: 2</pre>
			<pre class="source-code">System.out.println("42".substring(2));   //prints:</pre>
			<pre class="source-code">System.out.println("42".substring(3)); </pre>
			<pre class="source-code">                                //error: index out of range: -1</pre>
			<pre class="source-code">String s6 = "abc42t%";</pre>
			<pre class="source-code">System.out.println(s6.substring(3));     //prints: 42t%</pre>
			<pre class="source-code">System.out.println(s6.substring(3, 5));  //prints: 42</pre>
			<p>The <strong class="source-inline">format()</strong> method <a id="_idIndexMarker545"/>uses the passed-in first argument as a template and inserts the other arguments in the corresponding position of the template sequentially. The following code example prints the sentence <strong class="source-inline">Hey, Nick! Give me 2 apples, please!</strong> three times:</p>
			<pre class="source-code">String t = "Hey, %s! Give me %d apples, please!";</pre>
			<pre class="source-code">System.out.println(String.format(t, "Nick", 2));</pre>
			<pre class="source-code">String t1 = String.format(t, "Nick", 2);</pre>
			<pre class="source-code">System.out.println(t1);</pre>
			<pre class="source-code">System.out.println(String.format("Hey, </pre>
			<pre class="source-code">                  %s! Give me %d apples, please!", "Nick", 2));</pre>
			<p>The <strong class="source-inline">%s</strong> and <strong class="source-inline">%d</strong> symbols are called <strong class="bold">format specifiers</strong>. There are many specifiers and various flags that allow a programmer to fine-control the result. You can read about them in the API of the <strong class="source-inline">java.util.Formatter</strong> class.</p>
			<p>The <strong class="source-inline">concat()</strong> method <a id="_idIndexMarker546"/>works the same way as the <a id="_idIndexMarker547"/>arithmetic operator (<strong class="source-inline">+</strong>), as shown here:</p>
			<pre class="source-code">String s7 = "42";</pre>
			<pre class="source-code">String s8 = "xyz";</pre>
			<pre class="source-code">String newStr1 = s7.concat(s8);</pre>
			<pre class="source-code">System.out.println(newStr1);    //prints: 42xyz</pre>
			<pre class="source-code">String newStr2 = s7 + s8;</pre>
			<pre class="source-code">System.out.println(newStr2);    //prints: 42xyz</pre>
			<p>The<a id="_idIndexMarker548"/> following <strong class="source-inline">join()</strong> method acts similarly but allows the addition of a delimiter:</p>
			<pre class="source-code">String newStr1 = String.join(",", "abc", "xyz");</pre>
			<pre class="source-code">System.out.println(newStr1);        //prints: abc,xyz</pre>
			<pre class="source-code">List&lt;String&gt; list = List.of("abc","xyz");</pre>
			<pre class="source-code">String newStr2 = String.join(",", list);</pre>
			<pre class="source-code">System.out.println(newStr2);        //prints: abc,xyz</pre>
			<p>The following group of the <strong class="source-inline">replace()</strong>, <strong class="source-inline">replaceFirst()</strong>, and <strong class="source-inline">replaceAll()</strong> methods<a id="_idIndexMarker549"/> replace certain characters in the string with the provided ones:</p>
			<pre class="source-code">System.out.println("abcbc".replace("bc","42"));</pre>
			<pre class="source-code">                                                //prints: a4242</pre>
			<pre class="source-code">System.out.println("abcbc".replaceFirst("bc", "42"));</pre>
			<pre class="source-code">                                                //prints: a42bc</pre>
			<pre class="source-code">System.out.println("ab11bcd".replaceAll("[a-z]+", "42"));</pre>
			<pre class="source-code">                                               //prints: 421142</pre>
			<p>The first line of the preceding code replaces all the instances of <strong class="source-inline">"bc"</strong> with <strong class="source-inline">"42"</strong>. The second replaces only the first instance of <strong class="source-inline">"bc"</strong> with <strong class="source-inline">"42"</strong>, and the last one replaces all the substrings<a id="_idIndexMarker550"/> that match the provided regular expression with <strong class="source-inline">"42"</strong>.</p>
			<p>The <strong class="source-inline">toLowerCase()</strong> and <strong class="source-inline">toUpperCase()</strong> methods <a id="_idIndexMarker551"/>change the case of the whole<a id="_idIndexMarker552"/> string, as shown here:</p>
			<pre class="source-code">System.out.println("aBc".toLowerCase());   //prints: abc</pre>
			<pre class="source-code">System.out.println("aBc".toUpperCase());   //prints: ABC</pre>
			<p>The <strong class="source-inline">split()</strong> method breaks<a id="_idIndexMarker553"/> the string into substrings, using the provided character as the delimiter, as follows:</p>
			<pre class="source-code">String[] arr = "abcbc".split("b");</pre>
			<pre class="source-code">System.out.println(arr[0]);   //prints: a</pre>
			<pre class="source-code">System.out.println(arr[1]);   //prints: c</pre>
			<pre class="source-code">System.out.println(arr[2]);   //prints: c</pre>
			<p>There are several <strong class="source-inline">valueOf()</strong> methods that transform the values of a primitive type to a <strong class="source-inline">String</strong> type, such <a id="_idIndexMarker554"/>as the following:</p>
			<pre class="source-code">float f = 23.42f;</pre>
			<pre class="source-code">String sf = String.valueOf(f);</pre>
			<pre class="source-code">System.out.println(sf);         //prints: 23.42</pre>
			<p>There are<a id="_idIndexMarker555"/> also the <strong class="source-inline">()</strong> and <strong class="source-inline">getChars()</strong> methods that transform a string to an array of a corresponding type, while the <strong class="source-inline">chars()</strong> method <a id="_idIndexMarker556"/>creates an <strong class="source-inline">IntStream</strong> of characters (their code <a id="_idIndexMarker557"/>points). We will talk about streams in <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>.</p>
			<h3>Methods added with Java 11</h3>
			<p>Java 11 introduced<a id="_idIndexMarker558"/> several new methods in <a id="_idIndexMarker559"/>the <strong class="source-inline">String</strong> class.</p>
			<p>The <strong class="source-inline">repeat()</strong> method allows you to create a new <strong class="source-inline">String</strong> value based on multiple concatenations of the same string, as shown in the following code:</p>
			<pre class="source-code">System.out.println("ab".repeat(3)); //prints: ababab</pre>
			<pre class="source-code">System.out.println("ab".repeat(1)); //prints: ab</pre>
			<pre class="source-code">System.out.println("ab".repeat(0)); //prints:</pre>
			<p>The <strong class="source-inline">isBlank()</strong> method returns <strong class="source-inline">true</strong> if the string has a length of <strong class="source-inline">0</strong> or consists of white spaces only, such as the following:</p>
			<pre class="source-code">System.out.println("".isBlank());     //prints: true</pre>
			<pre class="source-code">System.out.println("   ".isBlank());  //prints: true</pre>
			<pre class="source-code">System.out.println(" a ".isBlank());  //prints: false</pre>
			<p>The <strong class="source-inline">stripLeading()</strong> method removes leading white spaces from the string, the <strong class="source-inline">stripTrailing()</strong> method removes trailing white spaces, and the <strong class="source-inline">strip()</strong> method removes both, as shown here:</p>
			<pre class="source-code">String sp = "   abc   ";</pre>
			<pre class="source-code">System.out.println("'" + sp + "'");                 </pre>
			<pre class="source-code">                                          //prints: '   abc   '</pre>
			<pre class="source-code">System.out.println("'" + sp.stripLeading() + "'");  </pre>
			<pre class="source-code">                                             //prints: 'abc   '</pre>
			<pre class="source-code">System.out.println("'" + sp.stripTrailing() + "'"); </pre>
			<pre class="source-code">                                              //prints: '  abc'</pre>
			<pre class="source-code">System.out.println("'" + sp.strip() + "'");</pre>
			<pre class="source-code">                                                //prints: 'abc'</pre>
			<p>And finally, the <strong class="source-inline">lines()</strong> method breaks the string by line terminators and returns a <strong class="source-inline">Stream&lt;String&gt;</strong> of resulting lines. A line terminator is an escape sequence line feed (<strong class="source-inline">\n</strong>) (<strong class="source-inline">\u000a</strong>), a carriage return (<strong class="source-inline">\r</strong>) (<strong class="source-inline">\u000d</strong>), or a carriage return followed immediately by a line feed (<strong class="source-inline">\r\n</strong>) (<strong class="source-inline">\u000d\u000a</strong>), such as the following:</p>
			<pre class="source-code">String line = "Line 1\nLine 2\rLine 3\r\nLine 4";</pre>
			<pre class="source-code">line.lines().forEach(System.out::println); </pre>
			<p>The output of the preceding code is as follows:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18388_Figure_5.1.jpg" alt=""/>
				</div>
			</div>
			<p>We will <a id="_idIndexMarker560"/>talk<a id="_idIndexMarker561"/> about streams in <a href="B18388_14_ePub.xhtml#_idTextAnchor296"><em class="italic">Chapter 14</em></a>, <em class="italic">Java Standard Streams</em>.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/>String utilities</h2>
			<p>In addition <a id="_idIndexMarker562"/>to the <strong class="source-inline">String</strong> class, there are many other classes that have methods that process the <strong class="source-inline">String</strong> values. Among the most useful is the <strong class="source-inline">StringUtils</strong> class of the <strong class="source-inline">org.apache.commons.lang3</strong> package from a project <a id="_idIndexMarker563"/>called an <strong class="bold">Apache Commons</strong>, maintained by an open source community of<a id="_idIndexMarker564"/> programmers called the <strong class="bold">Apache Software Foundation</strong>. We will talk more about this project and its libraries in <a href="B18388_07_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 7</em></a>, <em class="italic">Java Standard and External Libraries</em>. To use it in your project, add the following dependency in the <strong class="source-inline">pom.xml</strong> file:</p>
			<pre class="source-code">&lt;dependency&gt;</pre>
			<pre class="source-code">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</pre>
			<pre class="source-code">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</pre>
			<pre class="source-code">    &lt;version&gt;3.8.1&lt;/version&gt;</pre>
			<pre class="source-code">&lt;/dependency&gt;</pre>
			<p>The <strong class="source-inline">StringUtils</strong> class is the favorite of many programmers. It complements methods of the <strong class="source-inline">String</strong> class by providing the following null-safe operations (when a method is implemented in such a way – by checking the values for null, for example – that it does not throw <strong class="source-inline">NullPointerException</strong>):</p>
			<ul>
				<li><strong class="source-inline">isBlank(CharSequence cs)</strong>: Returns <strong class="source-inline">true</strong> if the input value is white space, empty (<strong class="source-inline">""</strong>), or <strong class="source-inline">null</strong></li>
				<li><strong class="source-inline">isNotBlank(CharSequence cs)</strong>: Returns <strong class="source-inline">false</strong> when the preceding method returns <strong class="source-inline">true</strong></li>
				<li><strong class="source-inline">isEmpty(CharSequence cs)</strong>: Returns <strong class="source-inline">true</strong> if the input value is empty (<strong class="source-inline">""</strong>) or <strong class="source-inline">null</strong></li>
				<li><strong class="source-inline">isNotEmpty(CharSequence cs)</strong>: Returns <strong class="source-inline">false</strong> when the preceding method returns <strong class="source-inline">true</strong></li>
				<li><strong class="source-inline">trim(String str)</strong>: Removes leading and trailing white space from the input value <a id="_idIndexMarker565"/>and processes <strong class="source-inline">null</strong>, empty (<strong class="source-inline">""</strong>), and white space, as follows:<p class="source-code">System.out.println("'" + StringUtils.trim(" x ")+"'");</p><p class="source-code">                                            //prints: 'x'</p><p class="source-code">System.out.println(StringUtils.trim(null));</p><p class="source-code">                                           //prints: null</p><p class="source-code">System.out.println("'" + StringUtils.trim("") + "'");</p><p class="source-code">                                             //prints: ''</p><p class="source-code">System.out.println("'" + StringUtils.trim("   ")+"'"); </p><p class="source-code">                                             //prints: ''</p></li>
				<li><strong class="source-inline">trimToNull(String str)</strong>: Removes leading and trailing white space from the input value and processes <strong class="source-inline">null</strong>, empty (<strong class="source-inline">""</strong>), and white space, as follows:<p class="source-code">System.out.println("'"+StringUtils.trimToNull(" x ")+"'");  </p><p class="source-code">                                           // prints: 'x'</p><p class="source-code">System.out.println(StringUtils.trimToNull(null));</p><p class="source-code">                                           //prints: null</p><p class="source-code">System.out.println(StringUtils.trimToNull(""));</p><p class="source-code">                                           //prints: null</p><p class="source-code">System.out.println(StringUtils.trimToNull("   "));</p><p class="source-code">                                           //prints: null</p></li>
				<li><strong class="source-inline">trimToEmpty(String str)</strong>: Removes leading and trailing white space from the <a id="_idIndexMarker566"/>input value and processes <strong class="source-inline">null</strong>, empty (<strong class="source-inline">""</strong>), and white space, as follows:<p class="source-code">System.out.println("'" + </p><p class="source-code">          StringUtils.trimToEmpty(" x ") + "'");   // 'x'</p><p class="source-code">System.out.println("'" + </p><p class="source-code">          StringUtils.trimToEmpty(null) + "'");    // ''</p><p class="source-code">System.out.println("'" + </p><p class="source-code">          StringUtils.trimToEmpty("") + "'");      // ''</p><p class="source-code">System.out.println("'" + </p><p class="source-code">          StringUtils.trimToEmpty("   ") + "'");   // ''</p></li>
				<li><strong class="source-inline">strip(String str)</strong>, <strong class="source-inline">stripToNull(String str)</strong>, and <strong class="source-inline">stripToEmpty(String str)</strong>: Produces the same result as the preceding <strong class="source-inline">trim(String str)</strong>, <strong class="source-inline">trimToNull(String str)</strong>, and <strong class="source-inline">trimToEmpty(String str)</strong> methods but uses a more extensive definition of white space (based on <strong class="source-inline">Character.isWhitespace(int codepoint)</strong>) and thus removes the same characters as the <strong class="source-inline">trim(String str)</strong>, <strong class="source-inline">trimToNull(String str)</strong>, and <strong class="source-inline">trimToEmpty(String str)</strong> methods do, and more</li>
				<li><strong class="source-inline">strip(String str, String stripChars)</strong>, <strong class="source-inline">stripAccents(String input)</strong>, <strong class="source-inline">stripAll(String... strs)</strong>, <strong class="source-inline">stripAll(String[] strs, String stripChars)</strong>, <strong class="source-inline">stripEnd(String str, String stripChars)</strong>, and <strong class="source-inline">stripStart(String str, String stripChars)</strong>: Removes particular characters from particular parts of <strong class="source-inline">String</strong> or <strong class="source-inline">String[]</strong> array elements</li>
				<li><strong class="source-inline">startsWith(CharSequence str, CharSequence prefix)</strong>, <strong class="source-inline">startsWithAny(CharSequence string, CharSequence... searchStrings)</strong>, <strong class="source-inline">startsWithIgnoreCase(CharSequence str, CharSequence prefix)</strong>, and similar <strong class="source-inline">endsWith*()</strong> methods: Checks whether a <strong class="source-inline">String</strong> value<a id="_idIndexMarker567"/> starts (or ends) with a certain prefix (or suffix)</li>
				<li><strong class="source-inline">indexOf</strong>, <strong class="source-inline">lastIndexOf</strong>, <strong class="source-inline">contains</strong>: Checks an index in a null-safe manner</li>
				<li><strong class="source-inline">indexOfAny</strong>, <strong class="source-inline">lastIndexOfAny</strong>, <strong class="source-inline">indexOfAnyBut</strong>, <strong class="source-inline">lastIndexOfAnyBut</strong>: Returns an index </li>
				<li><strong class="source-inline">containsOnly</strong>, <strong class="source-inline">containsNone</strong>, and <strong class="source-inline">containsAny</strong>: Checks whether the value contains certain characters or not</li>
				<li><strong class="source-inline">substring</strong>, <strong class="source-inline">left</strong>, <strong class="source-inline">right</strong>, and <strong class="source-inline">mid</strong>: Returns a substring in a null-safe manner</li>
				<li><strong class="source-inline">substringBefore</strong>, <strong class="source-inline">substringAfter</strong>, <strong class="source-inline">substringBetween</strong>: Returns a substring from a relative position</li>
				<li><strong class="source-inline">split</strong> or <strong class="source-inline">join</strong>: Splits or joins a value (respectively)</li>
				<li><strong class="source-inline">remove</strong> and <strong class="source-inline">delete</strong>: Eliminates a substring</li>
				<li><strong class="source-inline">replace</strong> and <strong class="source-inline">overlay</strong>: Replaces a value</li>
				<li><strong class="source-inline">chomp</strong> and <strong class="source-inline">chop</strong>: Removes the end</li>
				<li><strong class="source-inline">appendIfMissing</strong>: Adds a value if not present</li>
				<li><strong class="source-inline">prependIfMissing</strong>: Prepends a prefix to the start of the <strong class="source-inline">String</strong> value if not present</li>
				<li><strong class="source-inline">leftPad</strong>, <strong class="source-inline">rightPad</strong>, <strong class="source-inline">center</strong>, and <strong class="source-inline">repeat</strong>: Adds padding</li>
				<li><strong class="source-inline">upperCase</strong>, <strong class="source-inline">lowerCase</strong>, <strong class="source-inline">swapCase</strong>, <strong class="source-inline">capitalize</strong>, and <strong class="source-inline">uncapitalize</strong>: Changes the case</li>
				<li><strong class="source-inline">countMatches</strong>: Returns <a id="_idIndexMarker568"/>the number of the substring occurrences</li>
				<li><strong class="source-inline">isWhitespace</strong>, <strong class="source-inline">isAsciiPrintable</strong>, <strong class="source-inline">isNumeric</strong>, <strong class="source-inline">isNumericSpace</strong>, <strong class="source-inline">isAlpha</strong>, <strong class="source-inline">isAlphaNumeric</strong>, <strong class="source-inline">isAlphaSpace</strong>, and <strong class="source-inline">isAlphaNumericSpace</strong>: Checks the presence of a certain type of characters</li>
				<li><strong class="source-inline">isAllLowerCase</strong> and <strong class="source-inline">isAllUpperCase</strong>: Checks the case</li>
				<li><strong class="source-inline">defaultString</strong>, <strong class="source-inline">defaultIfBlank</strong>, and <strong class="source-inline">defaultIfEmpty</strong>: Returns a default value if <strong class="source-inline">null</strong></li>
				<li><strong class="source-inline">rotate</strong>: Rotates characters using a circular shift </li>
				<li><strong class="source-inline">reverse</strong> and <strong class="source-inline">reverseDelimited</strong>: Reverses characters or delimited groups of characters </li>
				<li><strong class="source-inline">abbreviate</strong> and <strong class="source-inline">abbreviateMiddle</strong>: Abbreviates a value using an ellipsis or another value</li>
				<li><strong class="source-inline">difference</strong>: Returns the differences in values</li>
				<li><strong class="source-inline">getLevenshteinDistance</strong>: Returns the number of changes needed to transform one value into another</li>
			</ul>
			<p>As you can see, the <strong class="source-inline">StringUtils</strong> class has a very rich (we have not listed everything) set of methods for string analysis, comparison, and transformation that complements the <a id="_idIndexMarker569"/>methods of the <strong class="source-inline">String</strong> class.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>I/O streams</h1>
			<p>Any software<a id="_idIndexMarker570"/> system has to receive and produce some kind of data that can be organized as a set of isolated input/output or as a stream of data. A stream can be limited or endless. A program can read from a stream (which is <a id="_idIndexMarker571"/>called an <strong class="bold">input stream</strong>) or write to a stream (which is <a id="_idIndexMarker572"/>called an <strong class="bold">output stream</strong>). The Java I/O stream is either byte-based or character-based, meaning that its data is interpreted either as raw bytes or as characters.</p>
			<p>The <strong class="source-inline">java.io</strong> package contains classes that support many, but not all, possible data sources. It is built for the most part around input from and to files, network streams, and internal memory buffers. It does not contain many classes necessary for network communication. They belong to <strong class="source-inline">java.net</strong>, <strong class="source-inline">javax.net</strong>, and other packages of a Java networking API. Only after the networking source or destination is established (a network socket, for example) can a program read and write data using the <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> classes of the <strong class="source-inline">java.io</strong> package. </p>
			<p>The classes of the <strong class="source-inline">java.nio</strong> package have pretty much the same functionality as the classes of <strong class="source-inline">java.io</strong> packages. But, in addition, they can work in <em class="italic">non-blocking</em> mode, which can substantially increase performance in certain situations. We will talk about non-blocking processing in <a href="B18388_15_ePub.xhtml#_idTextAnchor315"><em class="italic">Chapter 15</em></a>, <em class="italic">Reactive Programming</em>.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Stream data</h2>
			<p>Input<a id="_idIndexMarker573"/> data has to be binary – expressed in 0s and 1s – at the very least because that is the format a computer can read. Data can be read or written one byte at a time or an array of several bytes at a time. These bytes can remain binary or can be interpreted as characters.</p>
			<p>In the first case, they can be read as bytes or byte arrays by the descendants of the <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> classes, such as (omitting the package name if the class belongs to the <strong class="source-inline">java.io</strong> package) <strong class="source-inline">ByteArrayInputStream</strong>, <strong class="source-inline">ByteArrayOutputStream</strong>, <strong class="source-inline">FileInputStream</strong>, <strong class="source-inline">FileOutputStream</strong>, <strong class="source-inline">ObjectInputStream</strong>, <strong class="source-inline">ObjectOutputStream</strong>, <strong class="source-inline">javax.sound.sampled.AudioInputStream</strong>, and <strong class="source-inline">org.omg.CORBA.portable.OutputStream</strong>; which one you use depends on the source or destination of the data. The <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> classes themselves are abstract and cannot be instantiated.</p>
			<p>In the second case, data that can be interpreted as characters is called <strong class="bold">text data</strong>, and there are character-oriented reading and writing classes based on <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong>, which are abstract classes too. Examples of their sub-classes are <strong class="source-inline">CharArrayReader</strong> and <strong class="source-inline">CharArrayWriter</strong>, <strong class="source-inline">InputStreamReader</strong> and <strong class="source-inline">OutputStreamWriter</strong>, <strong class="source-inline">PipedReader</strong> and <strong class="source-inline">PipedWriter</strong>, and <strong class="source-inline">StringReader</strong> and <strong class="source-inline">StringWriter</strong>.</p>
			<p>You may have noticed that we listed the classes in pairs. But not every input class has a matching output specialization – for example, there are the <strong class="source-inline">PrintStream</strong> and <strong class="source-inline">PrintWriter</strong> classes that support output to a printing device, but there is no corresponding input partner, not by name at least. However, there is a <strong class="source-inline">java.util.Scanner</strong> class that parses input text in a known format. </p>
			<p>There is also a set of buffer-equipped classes that help to improve performance by reading or writing a bigger chunk of data at a time, especially in cases when access to a source or<a id="_idIndexMarker574"/> destination takes a long time.</p>
			<p>In the rest of this section, we will review classes of the <strong class="source-inline">java.io</strong> package and some popular related classes from other packages.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>The InputStream class and its subclasses</h2>
			<p>In the<a id="_idIndexMarker575"/> Java<a id="_idIndexMarker576"/> Class Library, the <strong class="source-inline">InputStream</strong> abstract<a id="_idIndexMarker577"/> class has the following direct implementations: <strong class="source-inline">ByteArrayInputStream</strong>, <strong class="source-inline">FileInputStream</strong>, <strong class="source-inline">ObjectInputStream</strong>, <strong class="source-inline">PipedInputStream</strong>, <strong class="source-inline">SequenceInputStream</strong>, <strong class="source-inline">FilterInputStream</strong>, and <strong class="source-inline">javax.sound.sampled.AudioInputStream</strong>. </p>
			<p>All of them can be used as they are or override the following methods of the <strong class="source-inline">InputStream</strong> class:</p>
			<ul>
				<li><strong class="source-inline">int available()</strong>: Returns the number of bytes available for reading</li>
				<li><strong class="source-inline">void close()</strong>: Closes the stream and releases the resources</li>
				<li><strong class="source-inline">void mark(int readlimit)</strong>: Marks a position in the stream and defines how many bytes can be read</li>
				<li><strong class="source-inline">boolean markSupported()</strong>: Returns <strong class="source-inline">true</strong> if the marking is supported</li>
				<li><strong class="source-inline">static InputStream nullInputStream()</strong>: Creates an empty stream</li>
				<li><strong class="source-inline">abstract int read()</strong>: Reads<a id="_idIndexMarker578"/> the next byte in<a id="_idIndexMarker579"/> the stream</li>
				<li><strong class="source-inline">int read(byte[] b)</strong>: Reads data from the stream into the <strong class="source-inline">b</strong> buffer</li>
				<li><strong class="source-inline">int read(byte[] b, int off, int len)</strong>: Reads <strong class="source-inline">len</strong> or fewer bytes from the stream into the <strong class="source-inline">b</strong> buffer</li>
				<li><strong class="source-inline">byte[] readAllBytes()</strong>: Reads all the remaining bytes from the stream</li>
				<li><strong class="source-inline">int readNBytes(byte[] b, int off, int len)</strong>: Reads <strong class="source-inline">len</strong> or fewer bytes into the <strong class="source-inline">b</strong> buffer at the <strong class="source-inline">off</strong> offset</li>
				<li><strong class="source-inline">byte[] readNBytes(int len)</strong>: Reads <strong class="source-inline">len</strong> or fewer bytes into the <strong class="source-inline">b</strong> buffer</li>
				<li><strong class="source-inline">void reset()</strong>: Resets the reading location to the position where the <strong class="source-inline">mark()</strong> method was last called</li>
				<li><strong class="source-inline">long skip(long n)</strong>: Skips <strong class="source-inline">n</strong> or fewer bytes of the stream; returns the actual number of bytes skipped</li>
				<li><strong class="source-inline">long transferTo(OutputStream out)</strong>: Reads from the input stream and writes to the provided output stream byte by byte; returns the actual number of bytes transferred</li>
			</ul>
			<p><strong class="source-inline">abstract int read()</strong> is the only method that has to be implemented, but most of the descendants<a id="_idIndexMarker580"/> of this class override many of the other methods<a id="_idIndexMarker581"/> too.</p>
			<h3>ByteArrayInputStream</h3>
			<p>The <strong class="source-inline">ByteArrayInputStream</strong> class <a id="_idIndexMarker582"/>allows<a id="_idIndexMarker583"/> reading a byte array as an input stream. It has the following two constructors that create an object of the class and define the buffer used to read the input stream of bytes: </p>
			<ul>
				<li><strong class="source-inline">ByteArrayInputStream(byte[] buffer)</strong></li>
				<li><strong class="source-inline">ByteArrayInputStream(byte[] buffer, int offset, int length)</strong></li>
			</ul>
			<p>The second of the constructors allows you to set, in addition to the buffer, the offset and the length of the buffer too. Let’s look at an example and see how this class can be used. We will assume there is a source of the <strong class="source-inline">byte[]</strong> array with data:</p>
			<pre class="source-code">byte[] bytesSource(){</pre>
			<pre class="source-code">    return new byte[]{42, 43, 44};</pre>
			<pre class="source-code">}</pre>
			<p>Then, we can write the following:</p>
			<pre class="source-code">byte[] buffer = bytesSource();</pre>
			<pre class="source-code">try(ByteArrayInputStream bais = new ByteArrayInputStream(buffer)){</pre>
			<pre class="source-code">    int data = bais.read();</pre>
			<pre class="source-code">    while(data != -1) {</pre>
			<pre class="source-code">        System.out.print(data + " ");   //prints: 42 43 44</pre>
			<pre class="source-code">        data = bais.read();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">bytesSource()</strong> method produces the array of bytes that fills the buffer that is passed into the constructor of the <strong class="source-inline">ByteArrayInputStream</strong> class as a parameter. The resulting stream is then read byte by byte using the <strong class="source-inline">read()</strong> method until the end of the stream is reached (and the <strong class="source-inline">read()</strong> method returns <strong class="source-inline">-1</strong>). Each new byte is printed out (without a line feed and with white space after it, so all the read bytes are displayed in one line separated by the white space). </p>
			<p>The preceding<a id="_idIndexMarker584"/> code is usually <a id="_idIndexMarker585"/>expressed in a more compact form, as follows:</p>
			<pre class="source-code">byte[] buffer = bytesSource();</pre>
			<pre class="source-code">try(ByteArrayInputStream bais = new ByteArrayInputStream(buffer)){</pre>
			<pre class="source-code">    int data;</pre>
			<pre class="source-code">    while ((data = bais.read()) != -1) {</pre>
			<pre class="source-code">        System.out.print(data + " ");   //prints: 42 43 44</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>Instead of just printing the bytes, they can be processed in any other manner necessary, including interpreting them as characters, such as the following:</p>
			<pre class="source-code">byte[] buffer = bytesSource();</pre>
			<pre class="source-code">try(ByteArrayInputStream bais = </pre>
			<pre class="source-code">                             new ByteArrayInputStream(buffer)){</pre>
			<pre class="source-code">  int data;</pre>
			<pre class="source-code">  while ((data = bais.read()) != -1) {</pre>
			<pre class="source-code">      System.out.print(((char)data) + " ");   //prints: * + ,</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>But, in such a case, it is better to use one of the <strong class="source-inline">Reader</strong> classes that are specialized for character <a id="_idIndexMarker586"/>processing. We will talk<a id="_idIndexMarker587"/> about them in the <em class="italic">Reader and writer classes and their subclasses</em> section.</p>
			<h3>FileInputStream</h3>
			<p>The <strong class="source-inline">FileInputStream</strong> class <a id="_idIndexMarker588"/>gets data <a id="_idIndexMarker589"/>from a file in a filesystem – the raw bytes of an image, for example. It has the following three constructors:</p>
			<ul>
				<li><strong class="source-inline">FileInputStream(File file)</strong></li>
				<li><strong class="source-inline">FileInputStream(String name)</strong></li>
				<li><strong class="source-inline">FileInputStream(FileDescriptor fdObj)</strong></li>
			</ul>
			<p>Each constructor opens the file specified as the parameter. The first constructor accepts the <strong class="source-inline">File</strong> object; the second, the path to the file in the filesystem; and the third, the file descriptor object that represents an existing connection to an actual file in the filesystem. Let’s look at the following example:</p>
			<pre class="source-code">String file =  classLoader.getResource("hello.txt").getFile();</pre>
			<pre class="source-code">try(FileInputStream fis = new FileInputStream(file)){</pre>
			<pre class="source-code">    int data;</pre>
			<pre class="source-code">    while ((data = fis.read()) != -1) {</pre>
			<pre class="source-code">        System.out.print(((char)data) + " ");   </pre>
			<pre class="source-code">                                          //prints: H e l l o !</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>In the <strong class="source-inline">src/main/resources</strong> folder, we have created the <strong class="source-inline">hello.txt</strong> file that has only one line in it – <strong class="source-inline">Hello!</strong>. The output of the preceding example looks as follows:</p>
			<p class="figure-caption"><img src="image/B18388_Figure_5.2.png" alt="Graphical user interface&#10;&#10;Description automatically generated"/></p>
			<p>After reading bytes from the <strong class="source-inline">hello.txt</strong> file, we decided, for demo purposes, to cast each <strong class="source-inline">byte</strong> to <strong class="source-inline">char</strong> so that you can see that the code does read from the specified file, but the <strong class="source-inline">FileReader</strong> class is a better choice for text file processing (we will discuss it shortly). Without the cast, the result would be the following:</p>
			<pre class="source-code">System.out.print((data) + " ");   </pre>
			<pre class="source-code">                                //prints: 72 101 108 108 111 33</pre>
			<p>By the way, because the <strong class="source-inline">src/main/resources</strong> folder is placed by the IDE (using Maven) on the classpath, a file placed in it can also be accessed via a class loader that creates a <a id="_idIndexMarker590"/>stream using its<a id="_idIndexMarker591"/> own <strong class="source-inline">InputStream</strong> implementation:</p>
			<pre class="source-code">try(InputStream is = InputOutputStream.class.getResourceAsStream("/hello.txt")){</pre>
			<pre class="source-code">    int data;</pre>
			<pre class="source-code">    while ((data = is.read()) != -1) {</pre>
			<pre class="source-code">        System.out.print((data) + " ");   </pre>
			<pre class="source-code">             //prints: 72 101 108 108 111 33</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">InputOutputStream</strong> class in the preceding example is not a class from some library. It is just the main class we used to run the example. The <strong class="source-inline">InputOutputStream.class.getResourceAsStream()</strong> construct allows you to use the same classloader that has loaded the <strong class="source-inline">InputOutputStream</strong> class for the purpose<a id="_idIndexMarker592"/> of finding a file on the classpath <a id="_idIndexMarker593"/>and creating a stream that contains its content. In the <em class="italic">File management</em> section, we will present other ways of reading a file too.</p>
			<h3>ObjectInputStream</h3>
			<p>The set of <a id="_idIndexMarker594"/>methods of the <strong class="source-inline">ObjectInputStream</strong> class<a id="_idIndexMarker595"/> is much bigger than the set of methods of any other <strong class="source-inline">InputStream</strong> implementation. The reason for that is that it is built around reading the values of the object fields that can be of various types. In order for <strong class="source-inline">ObjectInputStream</strong> to be able to construct an object from the input stream of data, the object has to be <em class="italic">deserializable</em>, which means it has to be <em class="italic">serializable</em> in the first place – that is, to be convertible into a byte stream. Usually, it is done for the purpose of transporting objects over a network. At the destination, the serialized objects are deserialized, and the values of the original objects are restored.</p>
			<p>Primitive types and most Java classes, including the <strong class="source-inline">String</strong> class and primitive type wrappers, are serializable. If a class has fields of custom types, they have to be made serializable by implementing <strong class="source-inline">java.io.Serizalizable</strong>. How to do that is outside the scope of this book. For now, we are going to use only the serializable types. Let’s look at this class:</p>
			<pre class="source-code">class SomeClass implements Serializable {</pre>
			<pre class="source-code">    private int field1 = 42;</pre>
			<pre class="source-code">    private String field2 = "abc";</pre>
			<pre class="source-code">}</pre>
			<p>We have to tell the compiler that it is serializable. Otherwise, the compilation will fail. It is done in order to make sure that, before stating that the class is serializable, the programmer either reviewed all the fields and made sure they are serializable or has implemented the methods necessary for the serialization. </p>
			<p>Before we can create an input stream and use <strong class="source-inline">ObjectInputStream</strong> for deserialization, we need to serialize the object first. That is why we first use <strong class="source-inline">ObjectOutputStream</strong> and <strong class="source-inline">FileOutputStream</strong> to serialize an object and write it into the <strong class="source-inline">someClass.bin</strong> file. We will talk more about them in the <em class="italic">The OutputStream class and its subclasses</em> section. Then, we read from the file using <strong class="source-inline">FileInputStream</strong> and deserialize the file content using <strong class="source-inline">ObjectInputStream</strong>:</p>
			<pre class="source-code">String fileName = "someClass.bin";</pre>
			<pre class="source-code">try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName));</pre>
			<pre class="source-code">     ObjectInputStream ois = new ObjectInputStream(new </pre>
			<pre class="source-code">                             FileInputStream(fileName))){</pre>
			<pre class="source-code">    SomeClass obj = new SomeClass();</pre>
			<pre class="source-code">    oos.writeObject(obj);</pre>
			<pre class="source-code">    SomeClass objRead = (SomeClass) ois.readObject();</pre>
			<pre class="source-code">    System.out.println(objRead.field1);  //prints: 42</pre>
			<pre class="source-code">    System.out.println(objRead.field2);  //prints: abc</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>Note that the<a id="_idIndexMarker596"/> file has to be created first before the preceding code is run. We will show how it can <a id="_idIndexMarker597"/>be done in the <em class="italic">Creating files and directories</em> section. And, as a reminder, we have used the <strong class="source-inline">try-with-resources</strong> statement because <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> both implement the <strong class="source-inline">Closeable</strong> interface. </p>
			<h3>PipedInputStream</h3>
			<p>A piped input <a id="_idIndexMarker598"/>stream has a very particular<a id="_idIndexMarker599"/> specialization; it is used as one of the mechanisms of communication between threads. One thread reads from a <strong class="source-inline">PipedInputStream</strong> object and passes data to another thread that writes data to a <strong class="source-inline">PipedOutputStream</strong> object. Here is an example:</p>
			<pre class="source-code">PipedInputStream pis = new PipedInputStream();</pre>
			<pre class="source-code">PipedOutputStream pos = new PipedOutputStream(pis);</pre>
			<p>Alternatively, data can be moved in the opposite direction when one thread reads from a <strong class="source-inline">PipedOutputStream</strong> object and another thread writes to a <strong class="source-inline">PipedInputStream</strong> object as follows:</p>
			<pre class="source-code">PipedOutputStream pos = new PipedOutputStream();</pre>
			<pre class="source-code">PipedInputStream pis = new PipedInputStream(pos);</pre>
			<p>Those who work in this area are familiar with the message, <strong class="source-inline">Broken pipe</strong>, which means that the supplying data pipe stream has stopped working.</p>
			<p>The piped<a id="_idIndexMarker600"/> streams can also be created without any connection and connected later, as shown here:</p>
			<pre class="source-code">PipedInputStream pis = new PipedInputStream();</pre>
			<pre class="source-code">PipedOutputStream pos = new PipedOutputStream();</pre>
			<pre class="source-code">pos.connect(pis); </pre>
			<p>As an example, here are two classes that are going to be executed by different threads – first, the <strong class="source-inline">PipedOutputWorker</strong> class, as follows:</p>
			<pre class="source-code">class PipedOutputWorker implements Runnable{</pre>
			<pre class="source-code">    private PipedOutputStream pos;</pre>
			<pre class="source-code">    public PipedOutputWorker(PipedOutputStream pos) {</pre>
			<pre class="source-code">        this.pos = pos;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void run() {</pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">            for(int i = 1; i &lt; 4; i++){</pre>
			<pre class="source-code">                pos.write(i);</pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            pos.close();</pre>
			<pre class="source-code">        } catch (Exception ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">PipedOutputWorker</strong> class has the <strong class="source-inline">run()</strong> method (because it implements a <strong class="source-inline">Runnable</strong> interface) that<a id="_idIndexMarker601"/> writes into the <a id="_idIndexMarker602"/>stream the three numbers <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">3</strong>, and then closes. Now, let’s look at the <strong class="source-inline">PipedInputWorker</strong> class, as shown here: </p>
			<pre class="source-code">class PipedInputWorker implements Runnable{</pre>
			<pre class="source-code">    private PipedInputStream pis;</pre>
			<pre class="source-code">    public PipedInputWorker(PipedInputStream pis) {</pre>
			<pre class="source-code">        this.pis = pis;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void run() {</pre>
			<pre class="source-code">        try {</pre>
			<pre class="source-code">            int i;</pre>
			<pre class="source-code">            while((i = pis.read()) &gt; -1){</pre>
			<pre class="source-code">                System.out.print(i + " ");  </pre>
			<pre class="source-code">            }</pre>
			<pre class="source-code">            pis.close();</pre>
			<pre class="source-code">        } catch (Exception ex) {</pre>
			<pre class="source-code">            ex.printStackTrace();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>It also has a <strong class="source-inline">run()</strong> method (because it implements a <strong class="source-inline">Runnable</strong> interface) that reads from the stream and prints out each byte until the stream ends (indicated by <strong class="source-inline">-1</strong>). Now, let’s connect these <a id="_idIndexMarker603"/>pipes and <a id="_idIndexMarker604"/>execute a <strong class="source-inline">run()</strong> method of these classes:</p>
			<pre class="source-code">PipedOutputStream pos = new PipedOutputStream();</pre>
			<pre class="source-code">PipedInputStream pis = new PipedInputStream();</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    pos.connect(pis);</pre>
			<pre class="source-code">    new Thread(new PipedOutputWorker(pos)).start();</pre>
			<pre class="source-code">    new Thread(new PipedInputWorker(pis)).start(); </pre>
			<pre class="source-code">                                                //prints: 1 2 3</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the objects of the workers were passed into the constructor of the <strong class="source-inline">Thread</strong> class. The <strong class="source-inline">start()</strong> method of the <strong class="source-inline">Thread</strong> object executes the <strong class="source-inline">run()</strong> method of the passed in <strong class="source-inline">Runnable</strong>. And we see the results as expected –<strong class="source-inline">PipedInputWorker</strong> prints all the bytes written to the piped stream by <strong class="source-inline">PipedOutputWorker</strong>. We will go into more detail about threads in <a href="B18388_08_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 8</em></a>, <em class="italic">Multithreading and Concurrent Processing</em>.</p>
			<h3>SequenceInputStream</h3>
			<p>The <strong class="source-inline">SequenceInputStream</strong> class<a id="_idIndexMarker605"/> concatenates<a id="_idIndexMarker606"/> input streams passed into one of the following constructors as parameters:</p>
			<ul>
				<li><strong class="source-inline">SequenceInputStream(InputStream s1, InputStream s2)</strong></li>
				<li><strong class="source-inline">SequenceInputStream(Enumeration&lt;InputStream&gt; e)</strong></li>
			</ul>
			<p><strong class="bold">Enumeration</strong> is a<a id="_idIndexMarker607"/> collection <a id="_idIndexMarker608"/>of objects of the type indicated in the angle brackets, called <strong class="bold">generics</strong>, meaning <em class="italic">of type T</em>. The <strong class="source-inline">SequenceInputStream</strong> class reads from the first input string until it ends, whereupon it reads from the second one, and so on, until the end of the last of the streams. As an example, let’s create a <strong class="source-inline">howAreYou.txt</strong> file (with the text, <strong class="source-inline">How are you?</strong>) in the <strong class="source-inline">resources</strong> folder next to the <strong class="source-inline">hello.txt</strong> file. The <strong class="source-inline">SequenceInputStream</strong> class can then be used as follows:</p>
			<pre class="source-code">String file1 = classLoader.getResource("hello.txt").getFile();</pre>
			<pre class="source-code">String file2 = classLoader.getResource("howAreYou.txt").getFile();</pre>
			<pre class="source-code">try(FileInputStream fis1 = </pre>
			<pre class="source-code">                    new FileInputStream(file1);</pre>
			<pre class="source-code">    FileInputStream fis2 = </pre>
			<pre class="source-code">                    new FileInputStream(file2);</pre>
			<pre class="source-code">    SequenceInputStream sis=</pre>
			<pre class="source-code">            new SequenceInputStream(fis1, fis2)){</pre>
			<pre class="source-code">    int i;</pre>
			<pre class="source-code">    while((i = sis.read()) &gt; -1){</pre>
			<pre class="source-code">        System.out.print((char)i);       </pre>
			<pre class="source-code">                                   //prints: Hello!How are you?</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, when an enumeration of input streams is passed in, each of the streams is read (and <a id="_idIndexMarker609"/>printed<a id="_idIndexMarker610"/> in our case) until the end.</p>
			<h3>FilterInputStream</h3>
			<p>The <strong class="source-inline">FilterInputStream</strong> class<a id="_idIndexMarker611"/> is a <a id="_idIndexMarker612"/>wrapper around the <strong class="source-inline">InputStream</strong> object passed as a parameter in the constructor. Here is the constructor and the two <strong class="source-inline">read()</strong> methods of the <strong class="source-inline">FilterInputStream</strong> class:</p>
			<pre class="source-code">protected volatile InputStream in;</pre>
			<pre class="source-code">protected FilterInputStream(InputStream in) { this.in = in; }</pre>
			<pre class="source-code">public int read() throws IOException { return in.read(); }</pre>
			<pre class="source-code">public int read(byte b[]) throws IOException { </pre>
			<pre class="source-code">    return read(b, 0, b.length);</pre>
			<pre class="source-code">}</pre>
			<p>All the other methods of the <strong class="source-inline">InputStream</strong> class are overridden similarly; the function is delegated to the object assigned to the <strong class="source-inline">in</strong> property.</p>
			<p>As you can see, the constructor is protected, which means that only the child has access to it. Such a design hides from the client the actual source of the stream and forces the programmer to use one of the <strong class="source-inline">FilterInputStream</strong> class extensions: <strong class="source-inline">BufferedInputStream</strong>, <strong class="source-inline">CheckedInputStream</strong>, <strong class="source-inline">DataInputStream</strong>, <strong class="source-inline">PushbackInputStream</strong>, <strong class="source-inline">javax.crypto.CipherInputStream</strong>, <strong class="source-inline">java.util.zip.DeflaterInputStream</strong>, <strong class="source-inline">java.util.zip.InflaterInputStream</strong>, <strong class="source-inline">java.security.DigestInputStream</strong>, or <strong class="source-inline">javax.swing.ProgressMonitorInputStream</strong>. Alternatively, you can create a custom extension. But, before creating your own extension, look at the listed classes and see if one of them fits your needs. Here is an example of using a <strong class="source-inline">BufferedInputStream</strong> class:</p>
			<pre class="source-code">String file = classLoader.getResource("hello.txt").getFile();</pre>
			<pre class="source-code">try(FileInputStream  fis = new FileInputStream(file);</pre>
			<pre class="source-code">    FilterInputStream filter = new BufferedInputStream(fis)){</pre>
			<pre class="source-code">    int i;</pre>
			<pre class="source-code">    while((i = filter.read()) &gt; -1){</pre>
			<pre class="source-code">        System.out.print((char)i);     //prints: Hello!</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">BufferedInputStream</strong> class uses the buffer to improve performance. When the bytes from the stream are skipped or read, the internal buffer is automatically refilled with as many bytes as necessary at the time, from the contained input stream.</p>
			<p>The <strong class="source-inline">CheckedInputStream</strong> class adds a checksum of the data being read that allows the verification of the integrity of the input data using the <strong class="source-inline">getChecksum()</strong> method.</p>
			<p>The <strong class="source-inline">DataInputStream</strong> class reads and interprets input data as primitive Java data types in a machine-independent way.</p>
			<p>The <strong class="source-inline">PushbackInputStream</strong> class<a id="_idIndexMarker613"/> adds <a id="_idIndexMarker614"/>the ability to push back the read data using the <strong class="source-inline">unread()</strong> method. It is useful in situations when the code has the logic of analyzing the just-read data and deciding to unread it, so it can be reread at the next step.</p>
			<p>The <strong class="source-inline">javax.crypto.CipherInputStream</strong> class adds <strong class="source-inline">Cipher</strong> to the <strong class="source-inline">read()</strong> methods. If <strong class="source-inline">Cipher</strong> is initialized for decryption, <strong class="source-inline">javax.crypto.CipherInputStream</strong> will attempt to decrypt the data before returning.</p>
			<p>The <strong class="source-inline">java.util.zip.DeflaterInputStream</strong> class compresses data in the deflate compression format.</p>
			<p>The <strong class="source-inline">java.util.zip.InflaterInputStream</strong> class uncompresses data in the deflate compression format.</p>
			<p>The <strong class="source-inline">java.security.DigestInputStream</strong> class updates the associated message digest using the bits going through the stream. The <strong class="source-inline">on (boolean on)</strong> method turns the <strong class="source-inline">digest</strong> function on or off. The calculated digest can be retrieved using the <strong class="source-inline">getMessageDigest()</strong> method.</p>
			<p>The <strong class="source-inline">javax.swing.ProgressMonitorInputStream</strong> class provides a monitor of the progress <a id="_idIndexMarker615"/>of reading from <strong class="source-inline">InputStream</strong>. The<a id="_idIndexMarker616"/> monitor object can be accessed using the <strong class="source-inline">getProgressMonitor()</strong> method.</p>
			<h3>javax.sound.sampled.AudioInputStream</h3>
			<p>The <strong class="source-inline">AudioInputStream</strong> class <a id="_idIndexMarker617"/>represents<a id="_idIndexMarker618"/> an input stream with a specified audio format and length. It has the following two constructors:</p>
			<ul>
				<li><strong class="source-inline">AudioInputStream (InputStream stream, AudioFormat format, long length)</strong>: Accepts the stream of audio data, the requested format, and the length in sample frames</li>
				<li><strong class="source-inline">AudioInputStream (TargetDataLine line)</strong>: Accepts the target data line indicated</li>
			</ul>
			<p>The <strong class="source-inline">javax.sound.sampled.AudioFormat</strong> class describes audio-format properties such as channels, encoding, frame rate, and similar. The <strong class="source-inline">javax.sound.sampled.TargetDataLine</strong> class has the <strong class="source-inline">open()</strong> method that opens the line with the specified format and the <strong class="source-inline">read()</strong> method that reads audio data from the data line’s input buffer.</p>
			<p>There is also the <strong class="source-inline">javax.sound.sampled.AudioSystem</strong> class, and its methods handle <strong class="source-inline">AudioInputStream</strong> objects. They can be used for reading from an audio file, a stream, or a URL, and they write to an audio file. They also can be used to convert an audio stream to another audio format.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>The OutputStream class and its subclasses</h2>
			<p>The <strong class="source-inline">OutputStream</strong> class is <a id="_idIndexMarker619"/>a peer of the <strong class="source-inline">InputStream</strong> class<a id="_idIndexMarker620"/> that <a id="_idIndexMarker621"/>writes data instead of reading. It is an abstract class that has the following direct implementations<a id="_idIndexMarker622"/> in the <strong class="bold">Java Class Library</strong> (<strong class="bold">JCL</strong>): <strong class="source-inline">ByteArrayOutputStream</strong>, <strong class="source-inline">FilterOutputStream</strong>, <strong class="source-inline">ObjectOutputStream</strong>, <strong class="source-inline">PipedOutputStream</strong>, and <strong class="source-inline">FileOutputStream</strong>. </p>
			<p>The <strong class="source-inline">FileOutputStream</strong> class has the following direct extensions: <strong class="source-inline">BufferedOutputStream</strong>, <strong class="source-inline">CheckedOutputStream</strong>, <strong class="source-inline">DataOutputStream</strong>, <strong class="source-inline">PrintStream</strong>, <strong class="source-inline">javax.crypto.CipherOutputStream</strong>, <strong class="source-inline">java.util.zip.DeflaterOutputStream</strong>, <strong class="source-inline">java.security.DigestOutputStream</strong>, and <strong class="source-inline">java.util.zip.InflaterOutputStream</strong>.</p>
			<p>All of them can be used as they are or override the following methods of the <strong class="source-inline">OutputStream</strong> class:</p>
			<ul>
				<li><strong class="source-inline">void close()</strong>: Closes the stream and releases the resources</li>
				<li><strong class="source-inline">void flush()</strong>: Forces the remaining bytes to be written out</li>
				<li><strong class="source-inline">static OutputStream nullOutputStream()</strong>: Creates a new <strong class="source-inline">OutputStream</strong> that writes nothing</li>
				<li><strong class="source-inline">void write(byte[] b)</strong>: Writes the provided byte array to the output stream</li>
				<li><strong class="source-inline">void write(byte[] b, int off, int len)</strong>: Writes <strong class="source-inline">len</strong> bytes of the provided byte array, starting at the <strong class="source-inline">off</strong> offset, to the output stream</li>
				<li><strong class="source-inline">abstract void write(int b)</strong>: Writes the provided byte to the output stream</li>
			</ul>
			<p>The only method that has to be implemented is <strong class="source-inline">abstract void write(int b)</strong>, but most of the descendants of the <strong class="source-inline">OutputStream</strong> class override many of the other methods too. </p>
			<p>After learning about the input streams in the <em class="italic">The InputStream class and its subclasses</em> section, all of the <strong class="source-inline">OutputStream</strong> implementations, except the <strong class="source-inline">PrintStream</strong> class, should<a id="_idIndexMarker623"/> be intuitively familiar to you. So, we will <a id="_idIndexMarker624"/>discuss here only the <strong class="source-inline">PrintStream</strong> class.</p>
			<h3>PrintStream </h3>
			<p>The <strong class="source-inline">PrintStream</strong> class <a id="_idIndexMarker625"/>adds to another output<a id="_idIndexMarker626"/> stream the ability to print data as characters. We have actually used it already many times. The <strong class="source-inline">System</strong> class has an object of the <strong class="source-inline">PrintStream</strong> class set as a <strong class="source-inline">System.out</strong> public static property. This means that every time we print something using <strong class="source-inline">System.out</strong>, we are using the <strong class="source-inline">PrintStream</strong> class:</p>
			<pre class="source-code">System.out.println("Printing a line");</pre>
			<p>Let’s look at another example of the <strong class="source-inline">PrintStream</strong> class usage: </p>
			<pre class="source-code">String fileName = "output.txt";</pre>
			<pre class="source-code">try(FileOutputStream  fos = new FileOutputStream(fileName);</pre>
			<pre class="source-code">    PrintStream ps = new PrintStream(fos)){</pre>
			<pre class="source-code">    ps.println("Hi there!");</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">PrintStream</strong> class takes the <strong class="source-inline">FileOutputStream</strong> object and prints the characters generated by it. In this case, it prints out all the bytes that <strong class="source-inline">FileOutputStream</strong> writes to the file. By the way, there is no need to create the destination file explicitly. If absent, it will be created automatically inside the <strong class="source-inline">FileOutputStream</strong> constructor. If we open the file after the preceding code is run, we will see one line in it – <strong class="source-inline">"Hi there!"</strong>. </p>
			<p>Alternatively, the same result can be achieved using another <strong class="source-inline">PrintStream</strong> constructor that takes the <strong class="source-inline">File</strong> object, as follows:</p>
			<pre class="source-code">String fileName = "output.txt";</pre>
			<pre class="source-code">File file = new File(fileName);</pre>
			<pre class="source-code">try(PrintStream ps = new PrintStream(file)){</pre>
			<pre class="source-code">    ps.println("Hi there!");</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>An even simpler solution can be created using the third variation of the <strong class="source-inline">PrintStream</strong> constructor that takes the filename as a parameter:</p>
			<pre class="source-code">String fileName = "output.txt";</pre>
			<pre class="source-code">try(PrintStream ps = new PrintStream(fileName)){</pre>
			<pre class="source-code">    ps.println("Hi there!");</pre>
			<pre class="source-code">} catch (Exception ex) {</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>The <a id="_idIndexMarker627"/>previous <a id="_idIndexMarker628"/>two examples are possible because the <strong class="source-inline">PrintStream</strong> constructor uses the <strong class="source-inline">FileOutputStream</strong> class behind the scenes, exactly as we did it in the first example of the <strong class="source-inline">PrintStream</strong> class usage. So, the <strong class="source-inline">PrintStream</strong> class has several constructors just for convenience, but all of them essentially have the same functionality:</p>
			<ul>
				<li><strong class="source-inline">PrintStream(File file)</strong></li>
				<li><strong class="source-inline">PrintStream(File file, String csn)</strong></li>
				<li><strong class="source-inline">PrintStream(File file, Charset charset)</strong></li>
				<li><strong class="source-inline">PrintStream(String fileName)</strong></li>
				<li><strong class="source-inline">PrintStream(String fileName, String csn)</strong></li>
				<li><strong class="source-inline">PrintStream(String fileName, Charset charset)</strong></li>
				<li><strong class="source-inline">PrintStream(OutputStream out)</strong></li>
				<li><strong class="source-inline">PrintStream(OutputStream out, boolean autoFlush)</strong></li>
				<li><strong class="source-inline">PrintStream(OutputStream out, boolean autoFlush, String encoding)</strong></li>
				<li><strong class="source-inline">PrintStream(OutputStream out, boolean autoFlush, Charset charset)</strong></li>
			</ul>
			<p>Some of the constructors also take a <strong class="source-inline">Charset</strong> instance or just its name (<strong class="source-inline">String csn</strong>), which allows you to apply a different mapping between sequences of 16-bit Unicode code units and sequences of bytes. You can see all available charsets by just printing them out, as shown here:</p>
			<pre class="source-code">for (String chs : Charset.availableCharsets().keySet()) {</pre>
			<pre class="source-code">    System.out.println(chs);</pre>
			<pre class="source-code">}</pre>
			<p>Other constructors take <strong class="source-inline">boolean autoFlush</strong> as a parameter. This parameter indicates (when <strong class="source-inline">true</strong>) that the output buffer should be flushed automatically when an array is <a id="_idIndexMarker629"/>written<a id="_idIndexMarker630"/> or the symbol end-of-line is encountered.</p>
			<p>Once an object of <strong class="source-inline">PrintStream</strong> is created, it provides a variety of methods, as listed here:</p>
			<ul>
				<li><strong class="source-inline">void print(T value)</strong>: Prints the value of any <strong class="source-inline">T</strong> primitive type passed in without moving to another line</li>
				<li><strong class="source-inline">void print(Object obj)</strong>: Calls the <strong class="source-inline">toString()</strong> method on the passed in object and prints the result without moving to another line; does not generate <strong class="source-inline">NullPointerException</strong> in case the passed-in object is <strong class="source-inline">null</strong> and prints <strong class="source-inline">null</strong> instead</li>
				<li><strong class="source-inline">void println(T value)</strong>: Prints the value of any <strong class="source-inline">T</strong> primitive type passed in and moves to another line</li>
				<li><strong class="source-inline">void println(Object obj)</strong>: Calls the <strong class="source-inline">toString()</strong> method on the passed-in object, prints the result, and moves to another line; does not generate <strong class="source-inline">NullPointerException</strong> in case the passed-in object is <strong class="source-inline">null</strong> and prints <strong class="source-inline">null</strong> instead</li>
				<li><strong class="source-inline">void println()</strong>: Just moves to another line</li>
				<li><strong class="source-inline">PrintStream printf(String format, Object... values)</strong>: Substitutes the placeholders in the provided <strong class="source-inline">format</strong> string with the provided <strong class="source-inline">values</strong> and writes the result into the stream</li>
				<li><strong class="source-inline">PrintStream printf(Locale l, String format, Object... args)</strong>: The same as the preceding method but applies localization using the provided <strong class="source-inline">Local</strong> object; if the provided <strong class="source-inline">Local</strong> object is <strong class="source-inline">null</strong>, no localization is applied, and <a id="_idIndexMarker631"/>this<a id="_idIndexMarker632"/> method behaves exactly like the preceding one</li>
				<li><strong class="source-inline">PrintStream format(String format, Object... args)</strong> and <strong class="source-inline">PrintStream format(Locale l, String format, Object... args)</strong>: Behaves the same way as <strong class="source-inline">PrintStream printf(String format, Object... values)</strong> and <strong class="source-inline">PrintStream printf(Locale l, String format, Object... args)</strong> (already described in the list), such as the following:<p class="source-code">System.out.printf("Hi, %s!%n", "dear reader"); </p><p class="source-code">                               //prints: Hi, dear reader!</p><p class="source-code">System.out.format("Hi, %s!%n", "dear reader"); </p><p class="source-code">                               //prints: Hi, dear reader!</p></li>
			</ul>
			<p>In the preceding example, (<strong class="source-inline">%</strong>) indicates a formatting rule. The following symbol (<strong class="source-inline">s</strong>) indicates a <strong class="source-inline">String</strong> value. Other possible symbols in this position can be (<strong class="source-inline">d</strong>) (decimal), (<strong class="source-inline">f</strong>) (floating-point), and so on. The symbol (<strong class="source-inline">n</strong>) indicates a new line (the same as the (<strong class="source-inline">\n</strong>) escape character). There are many formatting rules. All of them are described in the documentation for the <strong class="source-inline">java.util.Formatter</strong> class.</p>
			<ul>
				<li><strong class="source-inline">PrintStream append(char c)</strong>, <strong class="source-inline">PrintStream append(CharSequence c)</strong>, and <strong class="source-inline">PrintStream append(CharSequence c, int start, int end)</strong>: Appends the provided character to the stream, such as the following:<p class="source-code">System.out.printf("Hi %s", "there").append("!\n");  </p><p class="source-code">                                      //prints: Hi there!</p><p class="source-code">System.out.printf("Hi ")</p><p class="source-code">               .append("one there!\n two", 4, 11);  </p><p class="source-code">                                      //prints: Hi there!</p></li>
			</ul>
			<p>With this, we <a id="_idIndexMarker633"/>conclude the discussion <a id="_idIndexMarker634"/>of the <strong class="source-inline">OutputStream</strong> subclass and now turn our attention to another class hierarchy – the <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong> classes and their subclasses from the JCL.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>The Reader and Writer classes and their subclasses</h2>
			<p>As we<a id="_idIndexMarker635"/> mentioned <a id="_idIndexMarker636"/>several<a id="_idIndexMarker637"/> times <a id="_idIndexMarker638"/>already, the <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong> classes are very similar in their function to the <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> classes but specialize in processing texts. They interpret stream bytes as characters and have their own independent <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> class hierarchy. It is possible to process stream bytes as characters without <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong> or any of their subclasses. We have seen such examples in the preceding sections describing the <strong class="source-inline">InputStream</strong> and <strong class="source-inline">OutputStream</strong> classes. However, using the <strong class="source-inline">Reader</strong> and <strong class="source-inline">Writer</strong> classes <a id="_idIndexMarker639"/>makes text processing <a id="_idIndexMarker640"/>simpler and code easier to read.</p>
			<h3>Reader and its subclasses</h3>
			<p>The <strong class="source-inline">Reader</strong> class is an <a id="_idIndexMarker641"/>abstract class that reads streams as characters. It is an analog to <strong class="source-inline">InputStream</strong> and has the following methods:</p>
			<ul>
				<li><strong class="source-inline">abstract void close()</strong>: Closes the stream and other used resources</li>
				<li><strong class="source-inline">void mark(int readAheadLimit)</strong>: Marks the current position in the stream</li>
				<li><strong class="source-inline">boolean markSupported()</strong>: Returns <strong class="source-inline">true</strong> if the stream supports the <strong class="source-inline">mark()</strong> operation</li>
				<li><strong class="source-inline">static Reader nullReader()</strong>: Creates an empty <strong class="source-inline">Reader</strong> that reads no characters</li>
				<li><strong class="source-inline">int read()</strong>: Reads one character</li>
				<li><strong class="source-inline">int read(char[] buf)</strong>: Reads characters into the provided <strong class="source-inline">buf</strong> array and returns the count of the read characters </li>
				<li><strong class="source-inline">abstract int read(char[] buf, int off, int len)</strong>: Reads the <strong class="source-inline">len</strong> characters into an array starting from the <strong class="source-inline">off</strong> index</li>
				<li><strong class="source-inline">int read(CharBuffer target)</strong>: Attempts to read characters into the provided <strong class="source-inline">target</strong> buffer</li>
				<li><strong class="source-inline">boolean ready()</strong>: Returns <strong class="source-inline">true</strong> when the stream is ready to be read</li>
				<li><strong class="source-inline">void reset()</strong>: Resets the mark; however, not all streams support this operation, with some supporting it but not supporting a mark being set in the first place</li>
				<li><strong class="source-inline">long skip(long n)</strong>: Attempts to skip the <strong class="source-inline">n</strong> characters; returns the count of skipped characters</li>
				<li><strong class="source-inline">long transferTo(Writer out)</strong>: Reads all characters from this reader and writes the characters to the provided <strong class="source-inline">Writer</strong> object </li>
			</ul>
			<p>As you can see, the only methods that need to be implemented are the two abstract <strong class="source-inline">read()</strong> and <strong class="source-inline">close()</strong> methods. Nevertheless, many children of this class override other methods too, sometimes for better performance or different functionality. The <strong class="source-inline">Reader</strong> subclasses in the JCL are <strong class="source-inline">CharArrayReader</strong>, <strong class="source-inline">InputStreamReader</strong>, <strong class="source-inline">PipedReader</strong>, <strong class="source-inline">StringReader</strong>, <strong class="source-inline">BufferedReader</strong>, and <strong class="source-inline">FilterReader</strong>. The <strong class="source-inline">BufferedReader</strong> class has a <strong class="source-inline">LineNumberReader</strong> subclass, and <a id="_idIndexMarker642"/>the <strong class="source-inline">FilterReader</strong> class has a <strong class="source-inline">PushbackReader</strong> subclass.</p>
			<h3>Writer and its subclasses</h3>
			<p>The abstract <strong class="source-inline">Writer</strong> class writes<a id="_idIndexMarker643"/> to character streams. It is an analog to <strong class="source-inline">OutputStream</strong> and has the following methods:</p>
			<ul>
				<li><strong class="source-inline">Writer append(char c)</strong>: Appends the provided character to the stream</li>
				<li><strong class="source-inline">Writer append(CharSequence c)</strong>: Appends the provided character sequence to the stream</li>
				<li><strong class="source-inline">Writer append(CharSequence c, int start, int end)</strong>: Appends a subsequence of the provided character sequence to the stream</li>
				<li><strong class="source-inline">abstract void close()</strong>: Flushes and closes the stream and related system resources</li>
				<li><strong class="source-inline">abstract void flush()</strong>: Flushes the stream</li>
				<li><strong class="source-inline">static Writer nullWriter()</strong>: Creates a new <strong class="source-inline">Writer</strong> object that discards all characters</li>
				<li><strong class="source-inline">void write(char[] c)</strong>: Writes an array of <strong class="source-inline">c</strong> characters</li>
				<li><strong class="source-inline">abstract void write(char[] c, int off, int len)</strong>: Writes the <strong class="source-inline">len</strong> elements of an array of <strong class="source-inline">c</strong> characters, starting from the <strong class="source-inline">off</strong> index</li>
				<li><strong class="source-inline">void write(int c)</strong>: Writes one character</li>
				<li><strong class="source-inline">void write(String str)</strong>: Writes the provided string</li>
				<li><strong class="source-inline">void write(String str, int off, int len)</strong>: Writes a substring of the <strong class="source-inline">len</strong> length from the provided <strong class="source-inline">str</strong> string, starting from the <strong class="source-inline">off</strong> index</li>
			</ul>
			<p>As you can see, the three abstract methods, <strong class="source-inline">write(char[], int, int)</strong>, <strong class="source-inline">flush()</strong>, and <strong class="source-inline">close()</strong>, must be implemented by the children of this class. They also typically override other methods too.</p>
			<p>The <strong class="source-inline">Writer</strong> subclasses<a id="_idIndexMarker644"/> in the JCL are <strong class="source-inline">CharArrayWriter</strong>, <strong class="source-inline">OutputStreamWriter</strong>, <strong class="source-inline">PipedWriter</strong>, <strong class="source-inline">StringWriter</strong>, <strong class="source-inline">BufferedWriter</strong>, <strong class="source-inline">FilterWriter</strong>, and <strong class="source-inline">PrintWriter</strong>. The <strong class="source-inline">OutputStreamWriter</strong> class has a <strong class="source-inline">FileWriter</strong> subclass.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Other classes of the java.io package</h2>
			<p>Other classes<a id="_idIndexMarker645"/> of <a id="_idIndexMarker646"/>the <strong class="source-inline">java.io</strong> package include the following: </p>
			<ul>
				<li><strong class="source-inline">Console</strong>: Allows interaction with the character-based console device, associated with the current Java Virtual Machine instance</li>
				<li><strong class="source-inline">StreamTokenizer</strong>: Takes an input stream and parses it into <strong class="source-inline">tokens</strong></li>
				<li><strong class="source-inline">ObjectStreamClass</strong>: The serialization’s descriptor for classes</li>
				<li><strong class="source-inline">ObjectStreamField</strong>: A description of a serializable field from a serializable class</li>
				<li><strong class="source-inline">RandomAccessFile</strong>: Allows random access for reading from and writing to a file, but its discussion is outside the scope of this book</li>
				<li><strong class="source-inline">File</strong>: Allows creating and managing files and directories; described in the <em class="italic">File management</em> section</li>
			</ul>
			<h3>Console</h3>
			<p>There are <a id="_idIndexMarker647"/>several<a id="_idIndexMarker648"/> ways to create and run a <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) instance<a id="_idIndexMarker649"/> that executes an application. If the JVM is started from a command line, a console window is automatically opened. It allows you to type on the display from the keyboard; however, the JVM can be started by a background process too. In such a case, a console is not created.</p>
			<p>To check programmatically whether a console exists, you can invoke the <strong class="source-inline">System.console()</strong> static method. If no console device is available, then an invocation of that method will return <strong class="source-inline">null</strong>. Otherwise, it will return an object of the <strong class="source-inline">Console</strong> class that allows interaction with the console device and the application user.</p>
			<p>Let’s<a id="_idIndexMarker650"/> create<a id="_idIndexMarker651"/> the following <strong class="source-inline">ConsoleDemo</strong> class:</p>
			<pre class="source-code">package com.packt.learnjava.ch05_stringsIoStreams;</pre>
			<pre class="source-code">import java.io.Console;</pre>
			<pre class="source-code">public class ConsoleDemo {</pre>
			<pre class="source-code">    public static void main(String... args)  {</pre>
			<pre class="source-code">        Console console = System.console();</pre>
			<pre class="source-code">        System.out.println(console);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If we run it from the IDE, as we usually do, the result will be as follows:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B18388_Figure_5.3.jpg" alt=""/>
				</div>
			</div>
			<p>That is because the JVM was not launched from the command line. In order to do it, let’s compile our application and create a <strong class="source-inline">.jar</strong> file by executing the <strong class="source-inline">mvn clean package</strong> Maven command in the root directory of the project. (We assume that you have Maven installed on your computer.) It will delete the <strong class="source-inline">target</strong> folder, then recreate it, compile all the <strong class="source-inline">.java</strong> files to the corresponding <strong class="source-inline">.class</strong> files in the <strong class="source-inline">target</strong> folder, and then archive them in a <strong class="source-inline">.jar</strong> file, <strong class="source-inline">learnjava-1.0-SNAPSHOT.jar</strong>.</p>
			<p>Now, we can launch the <strong class="source-inline">ConsoleDemo</strong> application from the same project root directory using the following command: </p>
			<p class="source-code">java -cp ./target/examples-1.0-SNAPSHOT.jar  </p>
			<p class="source-code">          com.packt.learnjava.ch05_stringsIoStreams.ConsoleDemo</p>
			<p>The preceding <strong class="source-inline">–cp</strong> command option depicts a classpath, so in our case, we tell the JVM to look for the classes in the <strong class="source-inline">.jar</strong> file in the folder target. The command is shown in two lines because the page width cannot accommodate it. But if you want to run it, make sure you do it as one line. The result will be as follows:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B18388_Figure_5.4.jpg" alt=""/>
				</div>
			</div>
			<p>This tells us that we have the <strong class="source-inline">Console</strong> class object now. Let’s see what we can do with it. The class has the following methods:</p>
			<ul>
				<li><strong class="source-inline">String readLine()</strong>: Waits until the user hits the <em class="italic">Enter</em> key and reads the line of text from the console</li>
				<li><strong class="source-inline">String readLine(String format, Object... args)</strong>: Displays a prompt (the<a id="_idIndexMarker652"/> message produced after the provided format had the placeholders substituted <a id="_idIndexMarker653"/>with the provided arguments), waits until the user hits the <em class="italic">Enter</em> key, and reads the line of text from the console; if no arguments (<strong class="source-inline">args</strong>) are provided, it displays the format as the prompt</li>
				<li><strong class="source-inline">char[] readPassword()</strong>: Performs the same function as the <strong class="source-inline">readLine()</strong> function but without echoing the typed characters</li>
				<li><strong class="source-inline">char[] readPassword(String format, Object... args)</strong>: Performs the same function as <strong class="source-inline">readLine(String format, Object... args)</strong> but without echoing the typed characters</li>
			</ul>
			<p>To run each of the following code sections individually, you need to comment out the <strong class="source-inline">console1()</strong> call in the <strong class="source-inline">main</strong> method and uncomment <strong class="source-inline">console2()</strong> or <strong class="source-inline">console3()</strong>, recompile using <strong class="source-inline">mvn package</strong>, and then rerun the <strong class="source-inline">java</strong> command shown previously.</p>
			<p>Let’s demonstrate the preceding methods with the following example (the <strong class="source-inline">console2()</strong> method):</p>
			<pre class="source-code">Console console = System.console();</pre>
			<pre class="source-code">System.out.print("Enter something 1: "); </pre>
			<pre class="source-code">String line = console.readLine();</pre>
			<pre class="source-code">System.out.println("Entered 1: " + line);</pre>
			<pre class="source-code">line = console.readLine("Enter something 2: ");</pre>
			<pre class="source-code">System.out.println("Entered 2: " + line);</pre>
			<pre class="source-code">line = console.readLine("Enter some%s", "thing 3: ");</pre>
			<pre class="source-code">System.out.println("Entered 3: " + line);</pre>
			<pre class="source-code">System.out.print("Enter password: ");</pre>
			<pre class="source-code">char[] password = console.readPassword();</pre>
			<pre class="source-code">System.out.println("Entered 4: " + new String(password));</pre>
			<pre class="source-code">password = console.readPassword("Enter password 5: ");</pre>
			<pre class="source-code">System.out.println("Entered 5: " + new String(password));</pre>
			<pre class="source-code">password = console.readPassword("Enter pass%s", "word 6: ");</pre>
			<pre class="source-code">System.out.println("Entered 6: " + new String(password));</pre>
			<p>The<a id="_idIndexMarker654"/> result <a id="_idIndexMarker655"/>of the preceding example is as follows:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B18388_Figure_5.6.jpg" alt=""/>
				</div>
			</div>
			<p>Some IDEs cannot run these examples and throw <strong class="source-inline">NullPointerException</strong>. If that is the case, run the console-related examples from the command line, as described previously. Don’t forget to run the <strong class="source-inline">maven package</strong> command every time you change code.</p>
			<p>Another group of <strong class="source-inline">Console</strong> class methods can be used in conjunction with the previously demonstrated methods:</p>
			<ul>
				<li><strong class="source-inline">Console format(String format, Object... args)</strong>: Substitutes the placeholders in the provided <strong class="source-inline">format</strong> string with the provided <strong class="source-inline">args</strong> values and displays the result</li>
				<li><strong class="source-inline">Console printf(String format, Object... args)</strong>: Behaves the same way as the <strong class="source-inline">format()</strong> method</li>
			</ul>
			<p>As an<a id="_idIndexMarker656"/> example, look <a id="_idIndexMarker657"/>at the following line:</p>
			<pre class="source-code">String line = console.format("Enter some%s", "thing:").readLine();</pre>
			<p>It produces the same result as this line:</p>
			<pre class="source-code">String line = console.readLine("Enter some%s", "thing:");</pre>
			<p>And finally, the last three methods of the <strong class="source-inline">Console</strong> class are as follows:</p>
			<ul>
				<li><strong class="source-inline">PrintWriter writer()</strong>: Creates a <strong class="source-inline">PrintWriter</strong> object associated with this console that can be used for producing an output stream of characters</li>
				<li><strong class="source-inline">Reader reader()</strong>: Creates a <strong class="source-inline">Reader</strong> object associated with this console that can be used for reading the input as a stream of characters</li>
				<li><strong class="source-inline">void flush()</strong>: Flushes the console and forces any buffered output to be written immediately</li>
			</ul>
			<p>Here is an example of their usage (the <strong class="source-inline">console3()</strong> method):</p>
			<pre class="source-code">try (Reader reader = console.reader()){</pre>
			<pre class="source-code">    char[] chars = new char[10];</pre>
			<pre class="source-code">    System.out.print("Enter something: ");</pre>
			<pre class="source-code">    reader.read(chars);</pre>
			<pre class="source-code">    System.out.print("Entered: " + new String(chars));</pre>
			<pre class="source-code">} catch (IOException e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">PrintWriter out = console.writer();</pre>
			<pre class="source-code">out.println("Hello!");</pre>
			<pre class="source-code">console.flush();</pre>
			<p>The result of the preceding code looks as follows:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B18388_Figure_5.7.jpg" alt=""/>
				</div>
			</div>
			<p><strong class="source-inline">Reader</strong> and <strong class="source-inline">PrintWriter</strong> can also <a id="_idIndexMarker658"/>be used to create <a id="_idIndexMarker659"/>other <strong class="source-inline">Input</strong> and <strong class="source-inline">Output</strong> streams that we have been talking about in this section.</p>
			<h3>StreamTokenizer</h3>
			<p>The <strong class="source-inline">StreamTokenizer</strong> class parses<a id="_idIndexMarker660"/> the input<a id="_idIndexMarker661"/> stream and produces tokens. Its <strong class="source-inline">StreamTokenizer(Reader r)</strong> constructor accepts a <strong class="source-inline">Reader</strong> object that is the source of the tokens. Every time the <strong class="source-inline">int nextToken()</strong> method is called on the <strong class="source-inline">StreamTokenizer</strong> object, the following happens:</p>
			<ol>
				<li>The next token is parsed.</li>
				<li>The <strong class="source-inline">StreamTokenizer</strong> instance field, <strong class="source-inline">ttype</strong>, is populated by the value that indicates the token type:<ul><li>The <strong class="source-inline">ttype</strong> value can be one of the following integer constants: <strong class="source-inline">TT_WORD</strong>, <strong class="source-inline">TT_NUMBER</strong>, <strong class="source-inline">TT_EOL</strong> (end-of-line), or <strong class="source-inline">TT_EOF</strong> (end-of-stream).</li><li>If the <strong class="source-inline">ttype</strong> value is <strong class="source-inline">TT_WORD</strong>, the <strong class="source-inline">StreamTokenizer</strong> instance, the <strong class="source-inline">sval</strong> field, is populated by the <strong class="source-inline">String</strong> value of the token.</li><li>If the <strong class="source-inline">ttype</strong> value is <strong class="source-inline">TT_NUMBER</strong>, the <strong class="source-inline">StreamTokenizer</strong> instance field, <strong class="source-inline">nval</strong>, is populated by the <strong class="source-inline">double</strong> value of the token.</li></ul></li>
				<li>The <strong class="source-inline">lineno()</strong> method of the <strong class="source-inline">StreamTokenizer</strong> instance returns the current line number.</li>
			</ol>
			<p>Let’s look<a id="_idIndexMarker662"/> at an example before talking about<a id="_idIndexMarker663"/> other methods of the <strong class="source-inline">StreamTokenizer</strong> class. Let’s assume that, in the project <strong class="source-inline">resources</strong> folder, there is a <strong class="source-inline">tokens.txt</strong> file that contains the following four lines of text:</p>
			<pre class="source-code">There</pre>
			<pre class="source-code">happened</pre>
			<pre class="source-code">42</pre>
			<pre class="source-code">events.</pre>
			<p>The following code will read the file and tokenize its content (the <strong class="source-inline">streamTokenizer()</strong> method of the <strong class="source-inline">InputOutputStream</strong> class):</p>
			<pre class="source-code">String file =  classLoader.</pre>
			<pre class="source-code">                           getResource("tokens.txt").getFile();</pre>
			<pre class="source-code">try(FileReader fr = new FileReader(file);</pre>
			<pre class="source-code">   BufferedReader br = new BufferedReader(fr)){</pre>
			<pre class="source-code">  StreamTokenizer st = new StreamTokenizer(br);</pre>
			<pre class="source-code">  st.eolIsSignificant(true);</pre>
			<pre class="source-code">  st.commentChar('e');</pre>
			<pre class="source-code">  System.out.println("Line " + st.lineno() + ":");</pre>
			<pre class="source-code">  int i;</pre>
			<pre class="source-code">  while ((i = st.nextToken()) != StreamTokenizer.TT_EOF) {</pre>
			<pre class="source-code">    switch (i) {</pre>
			<pre class="source-code">       case StreamTokenizer.TT_EOL:</pre>
			<pre class="source-code">            System.out.println("\nLine " + st.lineno() + ":");</pre>
			<pre class="source-code">            break;</pre>
			<pre class="source-code">       case StreamTokenizer.TT_WORD:</pre>
			<pre class="source-code">            System.out.println("TT_WORD =&gt; " + st.sval);</pre>
			<pre class="source-code">            break;</pre>
			<pre class="source-code">       case StreamTokenizer.TT_NUMBER:</pre>
			<pre class="source-code">            System.out.println("TT_NUMBER =&gt; " + st.nval);</pre>
			<pre class="source-code">            break;</pre>
			<pre class="source-code">       default:</pre>
			<pre class="source-code">            System.out.println("Unexpected =&gt; " + st.ttype);</pre>
			<pre class="source-code">       }</pre>
			<pre class="source-code">  }         </pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>If we<a id="_idIndexMarker664"/> run<a id="_idIndexMarker665"/> this code, the result will be the following:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B18388_Figure_5.8.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p>We have used the <strong class="source-inline">BufferedReader</strong> class, which is a good practice for higher efficiency, but in our case, we can easily avoid it, like this:</p>
			<pre class="source-code"> FileReader fr = new FileReader(filePath);</pre>
			<pre class="source-code"> StreamTokenizer st = new StreamTokenizer(fr);</pre>
			<p>The result would not change. We also used the following three methods that we have not<a id="_idIndexMarker666"/> described <a id="_idIndexMarker667"/>yet:</p>
			<ul>
				<li><strong class="source-inline">void eolIsSignificant(boolean flag)</strong>: Indicates whether the end-of-line should be treated as a token</li>
				<li><strong class="source-inline">void commentChar(int ch)</strong>: Indicates which character starts a comment, so the rest of the line is ignored</li>
				<li><strong class="source-inline">int lineno()</strong>: Returns the current line number</li>
			</ul>
			<p>The following methods can be invoked using the <strong class="source-inline">StreamTokenizer</strong> object:</p>
			<ul>
				<li><strong class="source-inline">void lowerCaseMode(boolean fl)</strong>: Indicates whether a word token should be lowercase</li>
				<li><strong class="source-inline">void ordinaryChar(int ch)</strong>, <strong class="source-inline">void ordinaryChars(int low, int hi)</strong>: Indicate a specific character or the range of characters that have to be treated as <em class="italic">ordinary</em> (not as a comment character, word component, string delimiter, white space, or number character)</li>
				<li><strong class="source-inline">void parseNumbers()</strong>: Indicates that a word token that has the format of a double-precision floating-point number has to be interpreted as a number, rather than a word</li>
				<li><strong class="source-inline">void pushBack()</strong>: Forces the <strong class="source-inline">nextToken()</strong> method to return the current value of the <strong class="source-inline">ttype</strong> field</li>
				<li><strong class="source-inline">void quoteChar(int ch)</strong>: Indicates that the provided character has to be interpreted as the beginning and the end of the string value that has to be taken as-is (as a quote)</li>
				<li><strong class="source-inline">void resetSyntax()</strong>: Resets this tokenizer’s syntax table so that all characters are <em class="italic">ordinary</em></li>
				<li><strong class="source-inline">void slashSlashComments(boolean flag)</strong>: Indicates that C++-style comments have to be recognized</li>
				<li><strong class="source-inline">void slashStarComments(boolean flag)</strong>: Indicates that C-style comments<a id="_idIndexMarker668"/> have<a id="_idIndexMarker669"/> to be recognized</li>
				<li><strong class="source-inline">String toString()</strong>: Returns the string representation of the token and the line number</li>
				<li><strong class="source-inline">void whitespaceChars(int low, int hi)</strong>: Indicates the range of characters that have to be interpreted as white space</li>
				<li><strong class="source-inline">void wordChars(int low, int hi)</strong>: Indicates the range of characters that have to be interpreted as a word</li>
			</ul>
			<p>As you can see, using the wealth of the preceding methods allows you to fine-tune the text interpretation.</p>
			<h3>ObjectStreamClass and ObjectStreamField</h3>
			<p>The <strong class="source-inline">ObjectStreamClass</strong> and <strong class="source-inline">ObjectStreamField</strong> classes <a id="_idIndexMarker670"/>provide <a id="_idIndexMarker671"/>access to<a id="_idIndexMarker672"/> the serialized<a id="_idIndexMarker673"/> data of a class loaded in the JVM. The <strong class="source-inline">ObjectStreamClass</strong> object can be found/created using one of the following lookup methods:</p>
			<ul>
				<li><strong class="source-inline">static ObjectStreamClass lookup(Class cl)</strong>: Finds the descriptor of a serializable class</li>
				<li><strong class="source-inline">static ObjectStreamClass lookupAny(Class cl)</strong>: Finds the descriptor for any class, whether serializable or not</li>
			</ul>
			<p>After <strong class="source-inline">ObjectStreamClass</strong> is found and the class is serializable (implementing the <strong class="source-inline">Serializable</strong> interface), it can be used to access the <strong class="source-inline">ObjectStreamField</strong> objects, each containing information about one serialized field. If the class is not serializable, there is no <strong class="source-inline">ObjectStreamField</strong> object associated with any of the fields.</p>
			<p>Let’s look <a id="_idIndexMarker674"/>at <a id="_idIndexMarker675"/>an<a id="_idIndexMarker676"/> example. Here is the method <a id="_idIndexMarker677"/>that displays information obtained from the <strong class="source-inline">ObjectStreamClass</strong> and <strong class="source-inline">ObjectStreamField</strong> objects:</p>
			<pre class="source-code">void printInfo(ObjectStreamClass osc) {</pre>
			<pre class="source-code">    System.out.println(osc.forClass());</pre>
			<pre class="source-code">    System.out.println("Class name: " + osc.getName());</pre>
			<pre class="source-code">    System.out.println("SerialVersionUID: " +</pre>
			<pre class="source-code">                                   osc.getSerialVersionUID());</pre>
			<pre class="source-code">    ObjectStreamField[] fields = osc.getFields();</pre>
			<pre class="source-code">    System.out.println("Serialized fields:");</pre>
			<pre class="source-code">    for (ObjectStreamField osf : fields) {</pre>
			<pre class="source-code">        System.out.println(osf.getName() + ": ");</pre>
			<pre class="source-code">        System.out.println("\t" + osf.getType());</pre>
			<pre class="source-code">        System.out.println("\t" + osf.getTypeCode());</pre>
			<pre class="source-code">        System.out.println("\t" + osf.getTypeString());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>To demonstrate how it works, we will create a serializable <strong class="source-inline">Person1</strong> class:</p>
			<pre class="source-code">package com.packt.learnjava.ch05_stringsIoStreams;</pre>
			<pre class="source-code">import java.io.Serializable;</pre>
			<pre class="source-code">public class Person1 implements Serializable {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person1(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We did not add methods because only the object state is serializable, not the methods. Now, let’s <a id="_idIndexMarker678"/>run<a id="_idIndexMarker679"/> the<a id="_idIndexMarker680"/> following <a id="_idIndexMarker681"/>code:</p>
			<pre class="source-code">ObjectStreamClass osc1 = </pre>
			<pre class="source-code">        ObjectStreamClass.lookup(Person1.class);</pre>
			<pre class="source-code">printInfo(osc1);</pre>
			<p>The result will be as follows:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B18388_Figure_5.9.jpg" alt=""/>
				</div>
			</div>
			<p>As you can see, there is information about the class name and all field names and types. There are also two other methods that can be called using the <strong class="source-inline">ObjectStreamField</strong> object: </p>
			<ul>
				<li><strong class="source-inline">boolean isPrimitive()</strong>: Returns <strong class="source-inline">true</strong> if this field has a primitive type</li>
				<li><strong class="source-inline">boolean isUnshared()</strong>: Returns <strong class="source-inline">true</strong> if this field is unshared (private or accessible only from the same package)</li>
			</ul>
			<p>Now, let’s create a non-serializable <strong class="source-inline">Person2</strong> class:</p>
			<pre class="source-code">package com.packt.learnjava.ch05_stringsIoStreams;</pre>
			<pre class="source-code">public class Person2 {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person2(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This <a id="_idIndexMarker682"/>time, we <a id="_idIndexMarker683"/>will <a id="_idIndexMarker684"/>run the code <a id="_idIndexMarker685"/>that only looks up the class, as follows:</p>
			<pre class="source-code">ObjectStreamClass osc2 = </pre>
			<pre class="source-code">             ObjectStreamClass.lookup(Person2.class);</pre>
			<pre class="source-code">System.out.println("osc2: " + osc2);    //prints: null</pre>
			<p>As expected, the non-serializable object was not found using the <strong class="source-inline">lookup()</strong> method. In order to find a non-serializable object, we need to use the <strong class="source-inline">lookupAny()</strong> method:</p>
			<pre class="source-code">ObjectStreamClass osc3 = </pre>
			<pre class="source-code">           ObjectStreamClass.lookupAny(Person2.class);</pre>
			<pre class="source-code">printInfo(osc3);</pre>
			<p>If we run the preceding example, the result will be as follows:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B18388_Figure_5.10.jpg" alt=""/>
				</div>
			</div>
			<p>From a non-serializable<a id="_idIndexMarker686"/> object, we were able to extract information about the class <a id="_idIndexMarker687"/>but not<a id="_idIndexMarker688"/> about<a id="_idIndexMarker689"/> the fields.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>The java.util.Scanner class</h2>
			<p>The <strong class="source-inline">java.util.Scanner</strong> class is<a id="_idIndexMarker690"/> typically used to<a id="_idIndexMarker691"/> read input from a keyboard but can also read text from any object that implements the <strong class="source-inline">Readable</strong> interface (this interface only has the <strong class="source-inline">int read(CharBuffer buffer)</strong> method). It breaks the input value by a delimiter (white space is a default delimiter) into tokens that are processed using different methods.</p>
			<p>For example, we can read an input from <strong class="source-inline">System.in</strong> – a standard input stream, which typically represents keyboard input:</p>
			<pre class="source-code">Scanner sc = new Scanner(System.in);</pre>
			<pre class="source-code">System.out.print("Enter something: ");</pre>
			<pre class="source-code">while(sc.hasNext()){</pre>
			<pre class="source-code">    String line = sc.nextLine();</pre>
			<pre class="source-code">    if("end".equals(line)){</pre>
			<pre class="source-code">        System.exit(0);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    System.out.println(line);</pre>
			<pre class="source-code">}</pre>
			<p>It accepts many lines (each line ends after the <em class="italic">Enter</em> key is pressed) until the line <strong class="source-inline">end</strong> is entered, as follows:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B18388_Figure_5.11.jpg" alt=""/>
				</div>
			</div>
			<p>Alternatively, <strong class="source-inline">Scanner</strong> can read lines from a file:</p>
			<pre class="source-code">String file =  classLoader.getResource("tokens.txt").getFile();</pre>
			<pre class="source-code">try(Scanner sc = new Scanner(new File(file))){</pre>
			<pre class="source-code">    while(sc.hasNextLine()){</pre>
			<pre class="source-code">        System.out.println(sc.nextLine());</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception ex){</pre>
			<pre class="source-code">    ex.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, we have used the <strong class="source-inline">tokens.txt</strong> file again. The results are as follows:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B18388_Figure_5.12.jpg" alt=""/>
				</div>
			</div>
			<p>To <a id="_idIndexMarker692"/>demonstrate <strong class="source-inline">Scanner</strong> breaking the input by a <a id="_idIndexMarker693"/>delimiter, let’s run the following code:</p>
			<pre class="source-code">String input = "One two three";</pre>
			<pre class="source-code">Scanner sc = new Scanner(input);</pre>
			<pre class="source-code">while(sc.hasNext()){</pre>
			<pre class="source-code">    System.out.println(sc.next());</pre>
			<pre class="source-code">}</pre>
			<p>The result is as follows:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B18388_Figure_5.13.jpg" alt=""/>
				</div>
			</div>
			<p>To use another delimiter, it can be set as follows:</p>
			<pre class="source-code">String input = "One,two,three";</pre>
			<pre class="source-code">Scanner sc = new Scanner(input).useDelimiter(",");</pre>
			<pre class="source-code">while(sc.hasNext()){</pre>
			<pre class="source-code">    System.out.println(sc.next());</pre>
			<pre class="source-code">}</pre>
			<p>The result remains the same:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B18388_Figure_5.14.jpg" alt=""/>
				</div>
			</div>
			<p>It is also possible to use a regular expression for extracting the tokens, but that topic is outside the scope of this book.</p>
			<p>The <strong class="source-inline">Scanner</strong> class has many other methods that make its usage applicable to a variety of sources and required results. The <strong class="source-inline">findInLine()</strong>, <strong class="source-inline">findWithinHorizon()</strong>, <strong class="source-inline">skip()</strong>, and <strong class="source-inline">findAll()</strong> methods <a id="_idIndexMarker694"/>do not use the delimiter; they just try to match the provided pattern. For<a id="_idIndexMarker695"/> more information, refer to the Scanner documentation (<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html</a>).</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>File management</h1>
			<p>We have<a id="_idIndexMarker696"/> already used some methods for finding, creating, reading, and writing files using the JCL classes. We had to do it in order to support a demo code of input/output streams. In this section, we are going to talk about file management using the JCL in more detail.</p>
			<p>The <strong class="source-inline">File</strong> class from the <strong class="source-inline">java.io</strong> package represents the underlying filesystem. An object of the <strong class="source-inline">File</strong> class can be created with one of the following constructors:</p>
			<ul>
				<li><strong class="source-inline">File(String pathname)</strong>: Creates a new <strong class="source-inline">File</strong> instance based on the provided pathname</li>
				<li><strong class="source-inline">File(String parent, String child)</strong>: Creates a new <strong class="source-inline">File</strong> instance based on the provided parent pathname and a child pathname</li>
				<li><strong class="source-inline">File(File parent, String child)</strong>: Creates a new <strong class="source-inline">File</strong> instance based on the provided parent <strong class="source-inline">File</strong> object and a child pathname</li>
				<li><strong class="source-inline">File(URI uri)</strong>: Creates a new <strong class="source-inline">File</strong> instance based on the provided <strong class="source-inline">URI</strong> object that represents the pathname</li>
			</ul>
			<p>We will now see <a id="_idIndexMarker697"/>some examples of the constructors’ usage while talking about creating and deleting files.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>Creating and deleting files and directories</h2>
			<p>To create a<a id="_idIndexMarker698"/> file or<a id="_idIndexMarker699"/> directory in the filesystem, you need first to construct a new <strong class="source-inline">File</strong> object using one of the constructors listed in the <em class="italic">File management</em> section. For example, assuming that the filename is <strong class="source-inline">FileName.txt</strong>, the <strong class="source-inline">File</strong> object can be created as <strong class="source-inline">new File("FileName.txt")</strong>. If the file has to be created inside a directory, then either a path has to be added in front of the filename (when it is passed into the constructor) or one of the other three constructors has to be used, such as the following (see the <strong class="source-inline">createFile2()</strong> method in the <strong class="source-inline">Files</strong> class):</p>
			<pre class="source-code">String path = "demo1" + File.separator + </pre>
			<pre class="source-code">                            "demo2" + File.separator;</pre>
			<pre class="source-code">String fileName = "FileName.txt";</pre>
			<pre class="source-code">File f = new File(path + fileName);</pre>
			<p>Note the usage of <strong class="source-inline">File.separator</strong> instead of the slash symbols, (<strong class="source-inline">/</strong>) or (<strong class="source-inline">\</strong>). That is because <strong class="source-inline">File.separator</strong> returns the platform-specific slash symbol. Here is an example of another <strong class="source-inline">File</strong> constructor usage:</p>
			<pre class="source-code">String path = "demo1" + File.separator + </pre>
			<pre class="source-code">                            "demo2" + File.separator;</pre>
			<pre class="source-code">String fileName = "FileName.txt";</pre>
			<pre class="source-code">File f = new File(path, fileName);</pre>
			<p>Yet another constructor can be used as follows:</p>
			<pre class="source-code">String path = "demo1" + File.separator + </pre>
			<pre class="source-code">                            "demo2" + File.separator;</pre>
			<pre class="source-code">String fileName = "FileName.txt";</pre>
			<pre class="source-code">File f = new File(new File(path), fileName);</pre>
			<p>However, if <a id="_idIndexMarker700"/>you<a id="_idIndexMarker701"/> prefer or have to use a <strong class="bold">Universal Resource Identifier</strong> (<strong class="bold">URI</strong>), you <a id="_idIndexMarker702"/>can construct a <strong class="source-inline">File</strong> object like this: </p>
			<pre class="source-code">String path = "demo1" + File.separator + </pre>
			<pre class="source-code">                            "demo2" + File.separator;</pre>
			<pre class="source-code">String fileName = "FileName.txt";</pre>
			<pre class="source-code">URI uri = new File(path + fileName).toURI();</pre>
			<pre class="source-code">File f = new File(uri);</pre>
			<p>Then, one of the following methods has to be invoked on the newly created <strong class="source-inline">File</strong> object:</p>
			<ul>
				<li><strong class="source-inline">boolean createNewFile()</strong>: If a file with this name does not yet exist, creates a new file and returns <strong class="source-inline">true</strong>; otherwise, returns <strong class="source-inline">false</strong></li>
				<li><strong class="source-inline">static File createTempFile(String prefix, String suffix)</strong>: Creates a file in the temporary-file directory</li>
				<li><strong class="source-inline">static File createTempFile(String prefix, String suffix, File directory)</strong>: Creates the directory; the provided prefix and suffix are used to generate the directory name</li>
			</ul>
			<p>If the file you would like to create has to be placed inside a directory that does not exist yet, one of the following methods has to be used first, invoked on the <strong class="source-inline">File</strong> object that represents the filesystem path to the file:</p>
			<ul>
				<li><strong class="source-inline">boolean mkdir()</strong>: Creates the directory with the provided name</li>
				<li><strong class="source-inline">boolean mkdirs()</strong>: Creates the directory with the provided name, including any necessary but nonexistent parent directories</li>
			</ul>
			<p>Before we<a id="_idIndexMarker703"/> look at a code example, we <a id="_idIndexMarker704"/>need to explain how the <strong class="source-inline">delete()</strong> method works:</p>
			<ul>
				<li><strong class="source-inline">boolean delete()</strong>: Deletes the file or empty directory, which means you can delete the file but not all of the directories, as follows:<p class="source-code">String path = "demo1" + File.separator + </p><p class="source-code">                            "demo2" + File.separator;</p><p class="source-code">String fileName = "FileName.txt";</p><p class="source-code">File f = new File(path + fileName);</p><p class="source-code">f.delete();</p></li>
			</ul>
			<p>Let’s look at how to overcome this limitation in the following example:</p>
			<pre class="source-code">String path = "demo1" + File.separator + </pre>
			<pre class="source-code">                            "demo2" + File.separator;</pre>
			<pre class="source-code">String fileName = "FileName.txt";</pre>
			<pre class="source-code">File f = new File(path + fileName);</pre>
			<pre class="source-code">try {</pre>
			<pre class="source-code">    new File(path).mkdirs();</pre>
			<pre class="source-code">    f.createNewFile();</pre>
			<pre class="source-code">    f.delete();</pre>
			<pre class="source-code">    path = StringUtils</pre>
			<pre class="source-code">            .substringBeforeLast(path, File.separator);</pre>
			<pre class="source-code">    while (new File(path).delete()) {</pre>
			<pre class="source-code">        path = StringUtils</pre>
			<pre class="source-code">             .substringBeforeLast(path, File.separator);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">} catch (Exception e) {</pre>
			<pre class="source-code">    e.printStackTrace();</pre>
			<pre class="source-code">}</pre>
			<p>This example creates and deletes a file and all related directories. Notice our usage of the <strong class="source-inline">org.apache.commons.lang3.StringUtils</strong> class, which we discussed in the <em class="italic">String utilities</em> section. It allowed us to remove from the path the just-deleted directory and to<a id="_idIndexMarker705"/> continue doing it until all the nested<a id="_idIndexMarker706"/> directories are deleted, and the top-level directory is deleted last. </p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Listing files and directories</h2>
			<p>The following <a id="_idIndexMarker707"/>methods can be used for listing directories and the files in them:</p>
			<ul>
				<li><strong class="source-inline">String[] list()</strong>: Returns the names of the files and directories in the directory</li>
				<li><strong class="source-inline">File[] listFiles()</strong>: Returns the <strong class="source-inline">File</strong> objects that represent the files and directories in the directory</li>
				<li><strong class="source-inline">static File[] listRoots()</strong>: Lists the available filesystem roots</li>
			</ul>
			<p>In order to demonstrate the preceding methods, let’s assume we have created the directories and two files in them, as follows:</p>
			<pre class="source-code">String path1 = "demo1" + File.separator;</pre>
			<pre class="source-code">String path2 = "demo2" + File.separator;</pre>
			<pre class="source-code">String path = path1 + path2;</pre>
			<pre class="source-code">File f1 = new File(path + "file1.txt");</pre>
			<pre class="source-code">File f2 = new File(path + "file2.txt");</pre>
			<pre class="source-code">File dir1 = new File(path1);</pre>
			<pre class="source-code">File dir = new File(path);</pre>
			<pre class="source-code">dir.mkdirs();</pre>
			<pre class="source-code">f1.createNewFile();</pre>
			<pre class="source-code">f2.createNewFile();</pre>
			<p>After that, we<a id="_idIndexMarker708"/> should be able to run the following code:</p>
			<pre class="source-code">System.out.print("\ndir1.list(): ");</pre>
			<pre class="source-code">for(String d: dir1.list()){</pre>
			<pre class="source-code">    System.out.print(d + " ");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.print("\ndir1.listFiles(): ");</pre>
			<pre class="source-code">for(File f: dir1.listFiles()){</pre>
			<pre class="source-code">    System.out.print(f + " ");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.print("\ndir.list(): ");</pre>
			<pre class="source-code">for(String d: dir.list()){</pre>
			<pre class="source-code">    System.out.print(d + " ");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.print("\ndir.listFiles(): ");</pre>
			<pre class="source-code">for(File f: dir.listFiles()){</pre>
			<pre class="source-code">    System.out.print(f + " ");</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">System.out.print("\nFile.listRoots(): ");</pre>
			<pre class="source-code">for(File f: File.listRoots()){</pre>
			<pre class="source-code">    System.out.print(f + " ");</pre>
			<pre class="source-code">}</pre>
			<p>The result should be as follows:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B18388_Figure_5.15.jpg" alt=""/>
				</div>
			</div>
			<p>The demonstrated <a id="_idIndexMarker709"/>methods can be enhanced by adding the following filters to them so that they will list only the files and directories that match the filter:</p>
			<ul>
				<li><strong class="source-inline">String[] list(FilenameFilter filter)</strong></li>
				<li><strong class="source-inline">File[] listFiles(FileFilter filter)</strong></li>
				<li><strong class="source-inline">File[] listFiles(FilenameFilter filter)</strong></li>
			</ul>
			<p>However, a discussion of the file filters is outside the scope of this book.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Apache Commons’ FileUtils and IOUtils utilities </h1>
			<p>A popular<a id="_idIndexMarker710"/> companion of JCL is the Apache<a id="_idIndexMarker711"/> Commons project (<a href="https://commons.apache.org">https://commons.apache.org</a>), which <a id="_idIndexMarker712"/>provides many libraries that complement the JCL functionality. The classes of the <strong class="source-inline">org.apache.commons.io</strong> package are contained in the following root package and sub-packages:</p>
			<ul>
				<li>The <strong class="source-inline">org.apache.commons.io</strong> root package contains utility classes with static methods for common tasks, such as the popular <strong class="source-inline">FileUtils</strong> and <strong class="source-inline">IOUtils</strong> classes, described in the <em class="italic">FileUtils class</em> and <em class="italic">Class IOUtils class</em> sections respectively.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.input</strong> package contains classes that support input based on the <strong class="source-inline">InputStream</strong> and <strong class="source-inline">Reader</strong> implementations, such as <strong class="source-inline">XmlStreamReader</strong> or <strong class="source-inline">ReversedLinesFileReader</strong>.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.output</strong> package contains classes that support output based on the <strong class="source-inline">OutputStream</strong> and <strong class="source-inline">Writer</strong> implementations, such as <strong class="source-inline">XmlStreamWriter</strong> or <strong class="source-inline">StringBuilderWriter</strong>.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.filefilter</strong> package contains classes that serve as file filters, such as <strong class="source-inline">DirectoryFileFilter</strong> or <strong class="source-inline">RegexFileFilter</strong>.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.comparator</strong> package contains various implementations of <strong class="source-inline">java.util.Comparator</strong> for files such as <strong class="source-inline">NameFileComparator</strong>.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.serialization</strong> package provides a framework for controlling the deserialization of classes.</li>
				<li>The <strong class="source-inline">org.apache.commons.io.monitor</strong> package allows monitoring filesystems, checking for a directory, and file creating, updating, or deleting. You can launch the <strong class="source-inline">FileAlterationMonitor</strong> object as a thread and create an object of <strong class="source-inline">FileAlterationObserver</strong> that performs a check of the changes in <a id="_idIndexMarker713"/>the <a id="_idIndexMarker714"/>filesystem at a specified interval.</li>
			</ul>
			<p>Refer to the Apache Commons project documentation (<a href="https://commons.apache.org/">https://commons.apache.org/</a>) for more details.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>The FileUtils class</h2>
			<p>The popular <strong class="source-inline">org.apache.commons.io.FileUtils</strong> class allows you to do all possible operations<a id="_idIndexMarker715"/> with files, as follows:</p>
			<ul>
				<li>Writing to a file</li>
				<li>Reading from a file</li>
				<li>Making a directory, including parent directories</li>
				<li>Copying files and directories</li>
				<li>Deleting files and directories</li>
				<li>Converting to and from a URL</li>
				<li>Listing files and directories by filter and extension</li>
				<li>Comparing file content</li>
				<li>Getting a file last-changed date</li>
				<li>Calculating a checksum</li>
			</ul>
			<p>If you plan to manage files and directories programmatically, it is imperative that you study the <a id="_idIndexMarker716"/>documentation of this class on the Apache Commons project website (<a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html">https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/FileUtils.html</a>).</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>The IOUtils class</h2>
			<p><strong class="source-inline">org.apache.commons.io.IOUtils</strong> is another very useful utility class that provides <a id="_idIndexMarker717"/>the following general I/O stream manipulation methods:</p>
			<ul>
				<li>The <strong class="source-inline">closeQuietly</strong> methods that close a stream, ignoring nulls and exceptions</li>
				<li>The <strong class="source-inline">toXxx/read</strong> methods that read data from a stream</li>
				<li>The <strong class="source-inline">write</strong> methods that write data to a stream</li>
				<li>The <strong class="source-inline">copy</strong> methods that copy all the data from one stream to another</li>
				<li>The <strong class="source-inline">contentEquals</strong> methods that compare the content of two streams</li>
			</ul>
			<p>All the methods in this class that read a stream are buffered internally, so there is no need to use the <strong class="source-inline">BufferedInputStream</strong> or <strong class="source-inline">BufferedReader</strong> class. The <strong class="source-inline">copy</strong> methods all use <strong class="source-inline">copyLarge</strong> methods behind the scenes that substantially increase their performance and efficiency.</p>
			<p>This class is indispensable for managing the I/O streams. See more details about this class and its<a id="_idIndexMarker718"/> methods on<a id="_idIndexMarker719"/> the Apache Commons project website (<a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html">https://commons.apache.org/proper/commons-io/javadocs/api-2.7/org/apache/commons/io/IOUtils.html</a>).</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Summary</h1>
			<p>In this chapter, we have discussed the <strong class="source-inline">String</strong> class methods that allow analyzing, comparing, and transforming strings. We have also discussed popular string utilities from the JCL and the Apache Commons project. Two big sections of this chapter were dedicated to the input/output streams and the supporting classes in the JCL and the Apache Commons project. The file-managing classes and their methods were also discussed and demonstrated in specific code examples. Now, you should be able to write code that processes strings and files, using standard Java API and Apache Commons utilities.</p>
			<p>In the next chapter, we will present the Java Collections framework and its three main interfaces, <strong class="source-inline">List</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>, including discussion and demonstration of generics. We will also discuss utility classes for managing arrays, objects, and <strong class="source-inline">time</strong>/<strong class="source-inline">date</strong> values.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>Quiz</h1>
			<ol>
				<li value="1">What does the following code print?<p class="source-code">String str = "&amp;8a!L";</p><p class="source-code">System.out.println(str.indexOf("a!L"));</p><ol><li><strong class="source-inline">3</strong></li><li><strong class="source-inline">2</strong></li><li><strong class="source-inline">1</strong></li><li><strong class="source-inline">0</strong></li></ol></li>
				<li>What does the following code print?<p class="source-code">String s1 = "x12";</p><p class="source-code">String s2 = new String("x12");</p><p class="source-code">System.out.println(s1.equals(s2)); </p><ol><li><strong class="source-inline">Error</strong></li><li><strong class="source-inline">Exception</strong></li><li><strong class="source-inline">true</strong></li><li><strong class="source-inline">false</strong></li></ol></li>
				<li>What does the following code print?<p class="source-code">System.out.println("%wx6".substring(2));</p><ol><li><strong class="source-inline">wx</strong></li><li><strong class="source-inline">x6</strong></li><li><strong class="source-inline">%w</strong></li><li><strong class="source-inline">Exception</strong></li></ol></li>
				<li>What does the following code print?<p class="source-code">System.out.println("ab"+"42".repeat(2));</p><ol><li><strong class="source-inline">ab4242</strong></li><li><strong class="source-inline">ab42ab42</strong></li><li><strong class="source-inline">ab422</strong></li><li><strong class="source-inline">Error</strong></li></ol></li>
				<li>What does the following code print?<p class="source-code">String s = "  ";</p><p class="source-code">System.out.println(s.isBlank()+" "+s.isEmpty());</p><ol><li><strong class="source-inline">false false</strong></li><li><strong class="source-inline">false true</strong></li><li><strong class="source-inline">true true</strong></li><li><strong class="source-inline">true false</strong></li></ol></li>
				<li>Select all correct statements:<ol><li>A stream can represent a data source.</li><li>An input stream can write to a file.</li><li>A stream can represent a data destination.</li><li>An output stream can display data on a screen.</li></ol></li>
				<li>Select all correct statements about the classes of the <strong class="source-inline">java.io</strong> package:<ol><li>Reader extends <strong class="source-inline">InputStream</strong>.</li><li>Reader extends <strong class="source-inline">OutputStream</strong>.</li><li>Reader extends <strong class="source-inline">java.lang.Object</strong>.</li><li>Reader extends <strong class="source-inline">java.lang.Input</strong>.</li></ol></li>
				<li>Select all correct statements about the classes of the <strong class="source-inline">java.io</strong> package:<ol><li>Writer extends <strong class="source-inline">FilterOutputStream</strong>.</li><li>Writer extends <strong class="source-inline">OutputStream</strong>.</li><li>Writer extends <strong class="source-inline">java.lang.Output</strong>.</li><li>Writer extends <strong class="source-inline">java.lang.Object</strong>.</li></ol></li>
				<li>Select all correct statements about the classes of the <strong class="source-inline">java.io</strong> package:<ol><li><strong class="source-inline">PrintStream</strong> extends <strong class="source-inline">FilterOutputStream</strong>.</li><li><strong class="source-inline">PrintStream</strong> extends <strong class="source-inline">OutputStream</strong>.</li><li><strong class="source-inline">PrintStream</strong> extends <strong class="source-inline">java.lang.Object</strong>.</li><li><strong class="source-inline">PrintStream</strong> extends <strong class="source-inline">java.lang.Output</strong>.</li></ol></li>
				<li>What does the following code do?<p class="source-code">String path = "demo1" + File.separator + "demo2" + File.separator;</p><p class="source-code">String fileName = "FileName.txt";</p><p class="source-code">File f = new File(path, fileName);</p><p class="source-code">try {</p><p class="source-code">    new File(path).mkdir();</p><p class="source-code">    f.createNewFile();</p><p class="source-code">} catch (Exception e) {</p><p class="source-code">    e.printStackTrace();</p><p class="source-code">} </p><ol><li>Creates two directories and a file in the <strong class="source-inline">demo2</strong> directory</li><li>Creates one directory and a file in it</li><li>Does not create any directory</li><li>Exception</li></ol></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer058">
			</div>
		</div>
	</body></html>