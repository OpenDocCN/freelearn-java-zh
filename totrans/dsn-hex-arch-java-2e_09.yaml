- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applying Dependency Inversion with Java Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to develop each hexagon as a Java module.
    By doing that, we started to enforce the scope and responsibilities of each hexagon
    in the architecture. However, we did not go too far in exploiting the Java module’s
    features, such as encapsulation and dependency inversion, and how these features
    can enhance the overall structure of a hexagonal system by making it more robust
    and loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the role that’s played by the **Java Platform Module System**
    (**JPMS**) in developing a hexagonal system, we need to understand what problems
    the JPMS aims to solve. Once we know what we can do with the JPMS in terms of
    encapsulation and dependency inversion, we can apply these techniques in conjunction
    with the hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will learn how to combine the JPMS with the hexagonal
    architecture to create a well-encapsulated system with clearly defined boundaries
    that are reinforced by the system’s modular structure and dependency inversion
    techniques. We’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the JPMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverting dependencies on a hexagonal application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Java platform’s `ServiceLoader` class to retrieve JPMS provider implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to use services, consumers,
    and providers from the JPMS to apply dependency inversion and encapsulation principles
    for a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are both available for the Linux, macOS, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the JPMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before `classpath` parameter. The `classpath` parameter is where we put dependencies
    in the form of **JAR files**. However, the problem is that there is no way to
    determine which JAR file a particular dependency came from. If you have two classes
    with the same name, in the same package, and present in two different JAR files,
    one of the JAR files would be loaded first, causing one JAR file to be shadowed
    by the other.
  prefs: []
  type: TYPE_NORMAL
- en: '`classpath` parameter, but only one of the JAR files is loaded, shadowing the
    rest. This JAR dependency entanglement issue is also known as `classpath` parameter
    is when we see unexpected `ClassNotFoundException` exceptions at system runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS cannot completely prevent JAR hell issues related to dependency version
    mismatches and shadowing. Still, the modular approach helps us have a better view
    of the dependencies that are needed by a system. This broader dependency perspective
    is helpful to prevent and diagnose such dependency issues.
  prefs: []
  type: TYPE_NORMAL
- en: Before the JPMS, there was no way to control access to public types from different
    JAR files. The default behavior of a **Java Virtual Machine** (**JVM**) is to
    always make these public types available between other JAR files, which often
    leads to collisions involving classes with the same name and package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JPMS introduced the `module` path and a strict encapsulation policy that
    restricts, by default, access to all public types between different modules. No
    longer can all public types be accessed from other dependencies. With the JPMS,
    `module` has to state which packages that contain public types are available to
    other modules. We did that by using the `exports` directive on the `domain` hexagon
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to access the `domain` hexagon module, we used the `requires` directive
    in the `application` hexagon module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This modularization mechanism assembles code in a new Java construct called
    `module`. As we saw previously, `module` may have to determine which package it
    intends to export and which other modules it requires. In this arrangement, we
    have more control over the things our application exposes and consumes.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re targeting development on cloud-based environments and care for performance
    and cost, the `module` system’s nature allows you to construct a customized Java
    runtime (known in the past as **JRE**) containing just the modules required to
    run the application. With a smaller Java runtime, both the application startup
    time and memory usage will decrease. Let’s say we’re talking about hundreds –
    even thousands – of Kubernetes pods running Java in the cloud. With a smaller
    Java runtime, we can achieve a considerable economy regarding computational resource
    consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more acquainted with the JPMS’s motivations and benefits, let’s
    go back to developing our topology and inventory system. We will learn how to
    use more advanced JPMS features to enhance encapsulation and adherence to dependency
    inversion principles.
  prefs: []
  type: TYPE_NORMAL
- en: Inverting dependencies on a hexagonal application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**), as introduced by Robert C.
    Martin, states that high-level components should not depend on low-level components.
    Instead, both of them should depend on abstractions. At first glance, for some,
    it may not be so obvious to understand such a concept. *After all, what do the
    high- and low-level components mean?* *And what kind of abstractions are we* *talking
    about?*
  prefs: []
  type: TYPE_NORMAL
- en: A high-level component has a set of operations orchestrated to enable a major
    system behavior. A high-level component may rely on low-level components to provide
    a major system behavior. A low-level component, in turn, utilizes a specialized
    behavior that supports the goals of a high-level component. We call a piece of
    client code that acts as the high-level component because it depends on and consumes
    the functionalities provided by the low-level component.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level component can be either a concrete or abstract element, while
    the low-level component should be concrete because it always provides implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider some client code as a high-level component that calls methods
    on a serving code. The serving code, in turn, can be regarded as a low-level component.
    This low-level component contains the implementation details. In procedural programming
    designs, it’s common to see high-level components depending directly on the implementation
    details provided by low-level components. Martin says that this direct dependency
    on implementation details is bad because it makes the system rigid. For example,
    if we change these implementation details on the low-level components, such changes
    can cause immediate problems for the high-level components that depend directly
    on them. That’s where this rigidity comes from: we cannot change one part of the
    code without causing side effects in other parts.'
  prefs: []
  type: TYPE_NORMAL
- en: To invert the dependency, we need to make the high-level component depend on
    the same abstraction that the low-level component is derived from. In object-oriented
    designs, we can achieve this feat by using abstract classes or interfaces. The
    low-level component implements an abstraction, whereas the high-level component
    refers to that abstraction instead of the low-level implementation. So, this is
    what we have to do to invert the dependencies properly.
  prefs: []
  type: TYPE_NORMAL
- en: The JPMS introduced a mechanism to help us avoid this dependency on implementation
    details. This mechanism is based on consumers, services, and providers. In addition
    to these three JPMS elements, there is one more, already known in previous Java
    versions, called `ServiceLoader`, which enables the system to find and retrieve
    implementations of a given abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: We call a consumer with a module that declares the need to consume a service
    provided by a provider module through the `uses` directive. This `uses` directive
    states the name of an interface or abstract class that represents the service
    we intend to use. The service, in turn, is the object that implements the interface
    or extends the abstract class that’s informed in the `uses` directive. The provider
    is a module that declares the service interface and its implementations with the
    providers and directives, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can use the JPMS to apply this DIP to our hexagonal system,
    topology, and inventory. We’ll also see a representation for inverting dependencies
    using input adapters, use cases, and input ports.
  prefs: []
  type: TYPE_NORMAL
- en: Providing services with use cases and input ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When developing the topology and inventory system, we designed use cases as
    interfaces and input ports as implementations for these interfaces. We can consider
    use cases and input ports as hexagonal architecture components that match the
    JPMS definition for a service. The Application hexagon module can be regarded
    as the module that provides the service. *And what about the consumer?* The Framework
    hexagon module is the direct consumer of the Application hexagon module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on that reasoning, we’ll re-implement both the Application and Framework
    hexagon modules so that the input adapters from the Framework hexagon will no
    longer need to depend on the input port implementations from the Application hexagon.
    Instead, the input adapters will only depend on the use case interface types,
    rather than the input ports’ concrete types. In such a context, we can regard
    input adapters as high-level components and input ports as low-level components.
    Input adapters refer to use case interfaces. Input ports implement these use cases.
    The following diagram illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Dependency inversion with an input adapter, use case, and input
    port](img/B19777_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Dependency inversion with an input adapter, use case, and input
    port
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates how we can approach dependency inversion in
    the hexagonal architecture. This example considers the dependency inversion between
    the Framework and Application hexagons, but we can do the same thing with the
    Domain hexagon as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider how `RouterManagementGenericAdapter` is currently accessing
    the implementation details instead of the abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By calling `new RouterManagementInputPort(RouterManagementH2Adapter.getInstance())`,
    we are making the input adapter depend on the implementation details of both the
    `RouterManagementInputPort` input port and the output adapter expressed by `RouterManagementH2Adapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an input port class eligible to be used as a provider class in the
    JPMS, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must add a no-arguments constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must declare the `setOutputPort` method in the use case interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we must implement the `setOutputPort` method in the input port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can update the Application hexagon’s `module` descriptor to define
    the services that we’ll provide by using the use case interfaces and their input
    port’s implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring the dependency that the `application` module has on the
    Domain hexagon and `lombok` modules. Then, we use `exports` to enable access to
    the input ports, output ports, and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must declare the services we want to provide. We can accomplish this
    service declaration by providing a use case interface and the input port that
    implements it. Let’s declare the service provider for router management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `RouterManagementUseCase` is being provided by `RouterManagementInputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must define the service provider for switch management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `SwitchManagementUseCase` is being provided by `SwitchManagementInputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we must declare the service provider for network management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have `NetworkManagementUseCase` being provided by `NetworkManagementInputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn how to access these input ports through JPMS services in input
    adapters, let’s learn how we can invert dependencies when working with output
    ports and output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Providing services with output ports and output adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Framework hexagon, we have output ports as interfaces and output adapters
    as their implementations. Input ports depend on output ports. In that sense, input
    ports can be regarded as high-level components because they depend on the abstractions
    provided by output ports. Output adapters act as low-level components that provide
    implementations for output port abstractions. The following diagram shows an illustration
    of this dependency inversion arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Dependency inversion with an input port, output port, and output
    adapter](img/B19777_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Dependency inversion with an input port, output port, and output
    adapter
  prefs: []
  type: TYPE_NORMAL
- en: Note that both the input port and the output adapter point to the same output
    port abstraction. This means that we can use the JPMS to apply the dependency
    inversion principle with these architecture components.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one requirement we have to meet to use output adapters as
    implementation providers. This requirement requires every provider class to have
    a public constructor with no parameters, which is not the case for the output
    adapters we implemented in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We implemented the `RouterManagementH2Adapter` constructor as `private` to
    enforce a singleton pattern. To show how to use this output adapter as a JPMS
    service provider, we need to disable the singleton pattern by changing the constructor’s
    access modifier from `private` to `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update the framework hexagon’s `module` (the `info.java` file)
    to define the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start by using the `requires` directive to declare the module dependencies
    on the Domain and Application hexagon modules. Then, we use the `exports` directive
    to enable access to all public types in the `dev.davivieira.topologyinventory.framework.adapters.output.h2.data`
    package. We use the `opens` directive to allow runtime reflective access to the
    output adapters. We need this reflective access because of the database library
    dependencies that these output adapters have.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `provides` and `with` directives to inform the output port
    interfaces, `RouterManagementOutputPort` and `SwitchManagementOutputPort`, along
    with their respective output adapter implementations, `RouterManagementH2Adapter`
    and `SwitchManagementH2Adapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve completed the configuration that’s required to enable dependency
    inversion between the output ports and adapters, let’s learn how to configure
    input adapters to access dependencies through their abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Making the input adapters dependent on abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in consuming the services we have exposed with the `provides`
    and `with` directives is to update the `module` descriptor of the consumer’s `framework`
    hexagon module by utilizing the `uses` directive. We’ll execute the following
    steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by updating the module descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first three `uses` directives point to the services provided by the Application
    hexagon module. The last two `uses` directives refer to the services we exposed
    in the Framework hexagon module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the `module` descriptors adequately configured to allow the
    system to depend on interfaces instead of implementations, we need to refactor
    the input adapters so that they only rely on use case interfaces from the Application
    hexagon module and output the port interfaces from the Framework hexagon module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we must configure the `RouterManagementGenericAdapter` adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `RouterManagementGenericAdapter` no longer depends on `RouterManagementInputPort`
    and `RouterManagementH2Adapter`, as it did previously. There is only one dependency
    on the `RouterManagementUseCase` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the `SwitchManagementGenericAdapter` input adapter, this is how we should
    configure the dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SwitchManagementGenericAdapter` input adapter depends on both the `RouterManagementUseCase`
    and `SwitchManagementUseCase` use case interfaces to perform its activities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To conclude, we have to adjust the `NetworkManagementGenericAdapter` adapter
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NetworkManagementGenericAdapter` input adapter follows the same pattern
    we used in the previous input adapters and requires use case references in the
    input adapter’s constructor. Here, we’re making use of the `SwitchManagementUseCase`
    and `NetworkManagementUseCase` use case interfaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this section, we touched on a crucial JPMS feature: service providers. By
    using them, we can bind input port implementations to the use case interfaces.
    That’s how we arrange the code. So, the input adapters can rely on use case abstractions
    to trigger operations on the Application hexagon.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to use `ServiceLoader` to retrieve service implementations
    based on the JPMS providers we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Java platform’s ServiceLoader class to retrieve JPMS provider implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have configured the `module` descriptor of the Application and Framework
    hexagon modules. We have refactored the input adapters so that they only depend
    on the abstractions provided by use case interfaces. *But how can we retrieve
    the concrete instances that implement those use case interfaces?* That’s exactly
    what the `ServiceLoader` class does.
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceLoader` is not a new class made solely to support JPMS features. Instead,
    `ServiceLoader` has been present in Java since version `module` descriptor to
    find implementations for a given service provider interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how we can use `ServiceLoader`, let’s update the `FrameworkTestData`
    test class by creating a method called `loadPortsAndUseCases`. This method uses
    `ServiceLoader` to retrieve the objects we need to instantiate the input adapters.
    We need to create the `loadPortsAndUseCases` method because we’ll call it to initialize
    the input adapters through `ServiceLoader`. Before creating the `loadPortsAndUseCases`
    method, we need to declare the input adapter variables that we’ll use to assign
    the objects that are instantiated with the aid of `ServiceLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The variables we’ve declared here are used to store references for the input
    adapters we’ll create using the input ports and output adapters objects that we
    obtained from the `ServiceLoader` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by initializing `RouterManagementGenericAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing RouterManagementGenericAdapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start the `loadPortsAndUseCases` method’s implementation by using a
    `ServiceLoader` instance to retrieve the objects that are necessary for instantiating
    `RouterManagementGenericAdapter`. We’ll perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `loadPortsAndUseCases` method’s initial implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `load` method from `ServiceLoader` receives a `RouterManagementUseCase.class`
    file as a parameter. This method can find all the implementations for the `RouterManagementUseCase`
    interface. Since `RouterManagementInputPort` is the only implementation that’s
    available for the use case interface, we can call `loaderUseCaseRouter.findFirst().get()`
    to get that implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Aside from a proper implementation for the `RouterManagementUseCase` interface,
    we also need to provide an implementation for the `RouterManagementOutputPort`
    interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code shows how to retrieve a `RouterManagementOutputPort` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call on `loaderOutputRouter.findFirst().get()` retrieves a `RouterManagementH2Adapter`
    object, which is the only available implementation for the `RouterManagementOutputPort`
    interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the `RouterManagementInputPort` and `RouterManagementH2Adapter` objects
    loaded from `ServiceLoader`, we have the required objects to create an input adapter.
    But first, we need to set up the output port for the use case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how we can set a `RouterManagementOutputPort` object in `RouterManagementUseCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling `routerManagementUseCase.setOutputPort(routerManagementOutputPort)`,
    we are setting `RouterManagementOutputPort` in `RouterManagementUseCase`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can create a new `RouterManagementGenericAdapter` adapter by passing
    `RouterManagementUseCase`, which we have just created, to its constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s move on and learn how to initialize `SwitchManagementGenericAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing SwitchManagementGenericAdapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Still inside the `loadPortsAndUseCases` method, we need to use `ServiceLoader`
    to find an available implementation for `SwitchManagementUseCase`. We’ll perform
    the following steps for the same reason:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are retrieving a `SwitchManagementUseCase` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By calling `ServiceLoader.load(SwitchManagementUseCase.class)`, we are retrieving
    a `ServiceLoader` object containing all the available implementations for `SwitchManagementUseCase`.
    In our case, the only available implementation is the `SwitchManagementInputPort`
    input port. To load such an implementation, we must call `loaderUseCaseSwitch.findFirst().get()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also need an implementation for the `SwitchManagementOutputPort` output port.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code shows how we can get a `SwitchManagementOutputPort` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Output adapters implement output ports. So, to get an output port implementation,
    we should call `ServiceLoader.load(SwitchManagementOutputPort.class)` to load
    the `SwitchManagementH2Adapter` implementation and then call `loaderOutputSwitch.findFirst().get()`
    to retrieve that implementation object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can use the output port object to set it in the use case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can initiate the input adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To instantiate `SwitchManagementGenericAdapter`, we need to pass references
    for both the `RouterManagementUseCase` and `SwitchManagementUseCase` use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s move on and learn how to initialize `NetworkManagementGenericAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing NetworkManagementGenericAdapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For `NetworkManagementGenericAdapter`, we only need to load an implementation
    for `NetworkManagementUseCase`. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we should use `ServiceLoader` to get a `NetworkManagementUseCase`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must reuse `RouterManagementOutputPort`, which we loaded previously,
    to set `NetworkManagementUseCase`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can initiate `NetworkManagementGenericAdapter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To initiate a new `NetworkManagementGenericAdapter` adapter, we must pass references
    for the `SwitchManagementUseCase` and `NetworkManagementUseCase` use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This section taught us how to retrieve interface implementations using `ServiceLoader`
    in conjunction with JPMS service providers. With this technique, we can structure
    code that only relies on abstractions rather than implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking into the motivations and benefits behind
    the JPMS. We discovered that one of the problems the JPMS solves is that of JAR
    hell, where it’s difficult to control the dependencies that an application should
    expose and use. The JPMS addresses this problem by closing access to every public
    type in a module, requiring the developer to explicitly state which packages containing
    public types should be visible to other modules. Also, the developer should state
    the modules that a given module depends on in the `module` descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed the DIP and recognized the use cases, input ports, input
    adapters, and output adapters as components that we can apply to the DIP. Then,
    we used JPMS features such as consumers, services, and providers to refactor the
    topology and inventory system to enable dependency inversion in conjunction with
    hexagonal architecture components.
  prefs: []
  type: TYPE_NORMAL
- en: By employing the DIP, we created a more supple design, an important characteristic
    when it comes to building change-tolerant systems. We learned that the JPMS is
    a Java technology that we can use to implement DIP. Such technology also enables
    us to provide robust encapsulation by isolating related code into modules. This
    capability is paramount if we wish to establish and enforce boundaries between
    the Domain, Application, and Framework hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start our journey into the cloud-native world by
    learning about the Quarkus Framework and how to use it to prepare and optimize
    a hexagonal system to run in a cloud-native environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which JAR dependency problem does the JPMS aim to solve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which JPMS directive should we use to enable access to a package containing
    public types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To declare a dependency on a module, which JPMS directive should we use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When applying dependency inversion on the hexagonal architecture, which components
    can be regarded as high-level, abstraction, and low-level?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: The JAR hell problem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exports directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The requires directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input adapters, use cases, and input ports, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Dependency Inversion Principle*, by Robert C. Martin, C++ Report, 1996.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Becoming Cloud-Native'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will integrate the Quarkus framework into a hexagonal application,
    making it truly modern cloud-native software that's ready to be deployed in cloud
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to add Quarkus to our existing topology and inventory system.
    Then, we'll explore some of the exciting Quarkus features, such as CDI beans,
    RESTEasy Reactive, and Hibernate Reactive. After combining Quarkus and hexagonal
    architecture, we'll learn how to dockerize and create Kubernetes objects to deploy
    our hexagonal application to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19777_10.xhtml#_idTextAnchor213), *Adding Quarkus to a Modularized
    Hexagonal Application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19777_11.xhtml#_idTextAnchor228), *Leveraging CDI Beans to
    Manage Ports and Use Cases*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19777_12.xhtml#_idTextAnchor244), *Using RESTEasy Reactive
    to Implement Input Adapters*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data with Output
    Adapters and Hibernate Reactive*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19777_14.xhtml#_idTextAnchor286), *Setting Up Dockerfile and
    Kubernetes Objects for Cloud Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
