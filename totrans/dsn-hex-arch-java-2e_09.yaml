- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Applying Dependency Inversion with Java Modules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 模块应用依赖反转
- en: In the previous chapters, we learned how to develop each hexagon as a Java module.
    By doing that, we started to enforce the scope and responsibilities of each hexagon
    in the architecture. However, we did not go too far in exploiting the Java module’s
    features, such as encapsulation and dependency inversion, and how these features
    can enhance the overall structure of a hexagonal system by making it more robust
    and loosely coupled.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何将每个六边形作为 Java 模块来开发。通过这样做，我们开始强制实施架构中每个六边形的范围和职责。然而，我们没有深入挖掘
    Java 模块的功能，例如封装和依赖反转，以及这些功能如何通过使系统更加健壮和松散耦合来增强六角系统的整体结构。
- en: To understand the role that’s played by the **Java Platform Module System**
    (**JPMS**) in developing a hexagonal system, we need to understand what problems
    the JPMS aims to solve. Once we know what we can do with the JPMS in terms of
    encapsulation and dependency inversion, we can apply these techniques in conjunction
    with the hexagonal architecture.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 **Java 平台模块系统**（**JPMS**）在开发六角系统中所扮演的角色，我们需要了解 JPMS 旨在解决哪些问题。一旦我们知道在封装和依赖反转方面可以使用
    JPMS 做些什么，我们就可以将这些技术与六角架构结合使用。
- en: 'So, in this chapter, we will learn how to combine the JPMS with the hexagonal
    architecture to create a well-encapsulated system with clearly defined boundaries
    that are reinforced by the system’s modular structure and dependency inversion
    techniques. We’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习如何将 JPMS 与六角架构结合使用，以创建一个封装良好、边界清晰、由系统的模块结构和依赖反转技术加强的系统。我们将涵盖以下主题：
- en: Introducing the JPMS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 JPMS
- en: Inverting dependencies on a hexagonal application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在六角应用程序中反转依赖
- en: Using the Java platform’s `ServiceLoader` class to retrieve JPMS provider implementations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Java 平台的 `ServiceLoader` 类来检索 JPMS 提供者实现
- en: By the end of this chapter, you will have learned how to use services, consumers,
    and providers from the JPMS to apply dependency inversion and encapsulation principles
    for a hexagonal system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何使用 JPMS 中的服务、消费者和提供者来应用依赖反转和封装原则，以实现六角系统。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are both available for the Linux, macOS, and Windows operating systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，您需要在您的计算机上安装最新的 **Java SE 开发工具包** 和 **Maven 3.8**。它们都适用于 Linux、macOS
    和 Windows 操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码文件，链接为 [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter09)。
- en: Introducing the JPMS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JPMS
- en: Before `classpath` parameter. The `classpath` parameter is where we put dependencies
    in the form of **JAR files**. However, the problem is that there is no way to
    determine which JAR file a particular dependency came from. If you have two classes
    with the same name, in the same package, and present in two different JAR files,
    one of the JAR files would be loaded first, causing one JAR file to be shadowed
    by the other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `classpath` 参数之前。`classpath` 参数是我们放置以 **JAR 文件** 形式存在的依赖项的地方。然而，问题是无法确定特定依赖项来自哪个
    JAR 文件。如果您有两个具有相同名称的类，它们位于同一个包中，并且存在于两个不同的 JAR 文件中，那么其中一个 JAR 文件会首先被加载，导致一个 JAR
    文件被另一个 JAR 文件覆盖。
- en: '`classpath` parameter, but only one of the JAR files is loaded, shadowing the
    rest. This JAR dependency entanglement issue is also known as `classpath` parameter
    is when we see unexpected `ClassNotFoundException` exceptions at system runtime.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`classpath` 参数，但只加载了一个 JAR 文件，覆盖了其余的文件。这种 JAR 依赖项纠缠问题也被称为 `classpath` 参数，当我们看到系统运行时意外的
    `ClassNotFoundException` 异常时。'
- en: The JPMS cannot completely prevent JAR hell issues related to dependency version
    mismatches and shadowing. Still, the modular approach helps us have a better view
    of the dependencies that are needed by a system. This broader dependency perspective
    is helpful to prevent and diagnose such dependency issues.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS无法完全防止与依赖版本不匹配和阴影相关的JAR地狱问题。尽管如此，模块化方法帮助我们更好地了解系统所需的依赖。这种更广泛的依赖视角有助于防止和诊断此类依赖问题。
- en: Before the JPMS, there was no way to control access to public types from different
    JAR files. The default behavior of a **Java Virtual Machine** (**JVM**) is to
    always make these public types available between other JAR files, which often
    leads to collisions involving classes with the same name and package.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在JPMS之前，没有方法可以控制从不同的JAR文件中访问公共类型。**Java虚拟机**（**JVM**）的默认行为是始终在其他JAR文件之间使这些公共类型可用，这通常会导致涉及具有相同名称和包的类的冲突。
- en: 'The JPMS introduced the `module` path and a strict encapsulation policy that
    restricts, by default, access to all public types between different modules. No
    longer can all public types be accessed from other dependencies. With the JPMS,
    `module` has to state which packages that contain public types are available to
    other modules. We did that by using the `exports` directive on the `domain` hexagon
    module:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS引入了`module`路径和严格的封装策略，默认情况下，该策略限制了不同模块之间对所有公共类型的访问。不再可以从其他依赖中访问所有公共类型。使用JPMS时，`module`必须声明包含公共类型的哪些包可供其他模块使用。我们通过在`domain`六边形模块上使用`exports`指令来实现这一点：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to access the `domain` hexagon module, we used the `requires` directive
    in the `application` hexagon module:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了访问`domain`六边形模块，我们在`application`六边形模块中使用了`requires`指令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This modularization mechanism assembles code in a new Java construct called
    `module`. As we saw previously, `module` may have to determine which package it
    intends to export and which other modules it requires. In this arrangement, we
    have more control over the things our application exposes and consumes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化机制通过一个新的Java结构`module`来组装代码。正如我们之前所看到的，`module`可能需要确定它打算导出哪个包以及它需要哪些其他模块。在这种安排中，我们对自己的应用程序暴露和消费的内容有更多的控制。
- en: If you’re targeting development on cloud-based environments and care for performance
    and cost, the `module` system’s nature allows you to construct a customized Java
    runtime (known in the past as **JRE**) containing just the modules required to
    run the application. With a smaller Java runtime, both the application startup
    time and memory usage will decrease. Let’s say we’re talking about hundreds –
    even thousands – of Kubernetes pods running Java in the cloud. With a smaller
    Java runtime, we can achieve a considerable economy regarding computational resource
    consumption.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你针对基于云的环境进行开发，并关心性能和成本，`module`系统的本质允许你构建一个定制的Java运行时（过去被称为**JRE**），其中只包含运行应用程序所需的模块。使用较小的Java运行时，应用程序的启动时间和内存使用量都会降低。假设我们谈论的是在云中运行的数百甚至数千个Java
    Kubernetes pod。使用较小的Java运行时，我们可以在计算资源消耗方面实现相当可观的经济效益。
- en: Now that we are more acquainted with the JPMS’s motivations and benefits, let’s
    go back to developing our topology and inventory system. We will learn how to
    use more advanced JPMS features to enhance encapsulation and adherence to dependency
    inversion principles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对JPMS的动机和好处有了更多的了解，让我们回到开发我们的拓扑和库存系统。我们将学习如何使用更高级的JPMS功能来增强封装和遵循依赖反转原则。
- en: Inverting dependencies on a hexagonal application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在六边形应用程序中反转依赖
- en: The **dependency inversion principle** (**DIP**), as introduced by Robert C.
    Martin, states that high-level components should not depend on low-level components.
    Instead, both of them should depend on abstractions. At first glance, for some,
    it may not be so obvious to understand such a concept. *After all, what do the
    high- and low-level components mean?* *And what kind of abstractions are we* *talking
    about?*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由罗伯特·C·马丁提出的**依赖反转原则**（**DIP**）表明，高级组件不应依赖于低级组件。相反，它们都应该依赖于抽象。乍一看，对于一些人来说，理解这样的概念可能并不明显。*毕竟，高级和低级组件是什么意思？*
    *我们所说的抽象是什么类型的？*
- en: A high-level component has a set of operations orchestrated to enable a major
    system behavior. A high-level component may rely on low-level components to provide
    a major system behavior. A low-level component, in turn, utilizes a specialized
    behavior that supports the goals of a high-level component. We call a piece of
    client code that acts as the high-level component because it depends on and consumes
    the functionalities provided by the low-level component.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高级组件有一组操作，这些操作被编排起来以实现主要系统行为。高级组件可能依赖于低级组件来提供主要系统行为。反过来，低级组件利用一种专门的行为来支持高级组件的目标。我们称一段充当高级组件的客户端代码，因为它依赖于并消费低级组件提供的功能。
- en: The high-level component can be either a concrete or abstract element, while
    the low-level component should be concrete because it always provides implementation
    details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 高级组件可以是具体或抽象的元素，而低级组件应该是具体的，因为它总是提供实现细节。
- en: 'Let’s consider some client code as a high-level component that calls methods
    on a serving code. The serving code, in turn, can be regarded as a low-level component.
    This low-level component contains the implementation details. In procedural programming
    designs, it’s common to see high-level components depending directly on the implementation
    details provided by low-level components. Martin says that this direct dependency
    on implementation details is bad because it makes the system rigid. For example,
    if we change these implementation details on the low-level components, such changes
    can cause immediate problems for the high-level components that depend directly
    on them. That’s where this rigidity comes from: we cannot change one part of the
    code without causing side effects in other parts.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些客户端代码作为一个高级组件，它调用服务端代码上的方法。反过来，服务端代码可以被视为一个低级组件。这个低级组件包含了实现细节。在过程式编程设计中，常见高级组件直接依赖于低级组件提供的实现细节。马丁说，这种对实现细节的直接依赖是糟糕的，因为它使得系统变得僵化。例如，如果我们更改低级组件的实现细节，这些更改可能会立即对直接依赖于它们的低级组件造成问题。这就是这种僵化的来源：我们不能改变代码的一部分而不在其他部分引起副作用。
- en: To invert the dependency, we need to make the high-level component depend on
    the same abstraction that the low-level component is derived from. In object-oriented
    designs, we can achieve this feat by using abstract classes or interfaces. The
    low-level component implements an abstraction, whereas the high-level component
    refers to that abstraction instead of the low-level implementation. So, this is
    what we have to do to invert the dependencies properly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转依赖关系，我们需要让高级组件依赖于低级组件所派生的相同抽象。在面向对象设计中，我们可以通过使用抽象类或接口来实现这一功能。低级组件实现了一个抽象，而高级组件则引用这个抽象而不是低级实现。因此，这就是我们正确反转依赖关系所必须做的。
- en: The JPMS introduced a mechanism to help us avoid this dependency on implementation
    details. This mechanism is based on consumers, services, and providers. In addition
    to these three JPMS elements, there is one more, already known in previous Java
    versions, called `ServiceLoader`, which enables the system to find and retrieve
    implementations of a given abstraction.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JPMS引入了一种机制来帮助我们避免对实现细节的依赖。这个机制基于消费者、服务和提供者。除了这三个JPMS元素之外，还有一个在之前的Java版本中就已经知道的元素，称为`ServiceLoader`，它使系统能够找到并检索给定抽象的实现。
- en: We call a consumer with a module that declares the need to consume a service
    provided by a provider module through the `uses` directive. This `uses` directive
    states the name of an interface or abstract class that represents the service
    we intend to use. The service, in turn, is the object that implements the interface
    or extends the abstract class that’s informed in the `uses` directive. The provider
    is a module that declares the service interface and its implementations with the
    providers and directives, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个通过`uses`指令声明需要使用提供者模块提供服务的消费者模块称为消费者。这个`uses`指令声明了一个接口或抽象类，它代表我们打算使用的服务。反过来，服务是实现了接口或扩展了`uses`指令中提到的抽象类的对象。提供者是一个模块，它通过提供者和指令分别声明服务接口及其实现。
- en: Let’s see how we can use the JPMS to apply this DIP to our hexagonal system,
    topology, and inventory. We’ll also see a representation for inverting dependencies
    using input adapters, use cases, and input ports.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用JPMS将这种DIP应用到我们的六边形系统、拓扑和库存中。我们还将看到使用输入适配器、用例和输入端口来反转依赖关系的表示。
- en: Providing services with use cases and input ports
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用用例和输入端口提供服务
- en: When developing the topology and inventory system, we designed use cases as
    interfaces and input ports as implementations for these interfaces. We can consider
    use cases and input ports as hexagonal architecture components that match the
    JPMS definition for a service. The Application hexagon module can be regarded
    as the module that provides the service. *And what about the consumer?* The Framework
    hexagon module is the direct consumer of the Application hexagon module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发拓扑和库存系统时，我们将用例设计为接口，将输入端口设计为这些接口的实现。我们可以将用例和输入端口视为与 JPMS 对服务定义相匹配的六边形架构组件。应用程序六边形模块可以被视为提供服务的模块。*那么消费者呢？*
    框架六边形模块是应用程序六边形模块的直接消费者。
- en: 'Based on that reasoning, we’ll re-implement both the Application and Framework
    hexagon modules so that the input adapters from the Framework hexagon will no
    longer need to depend on the input port implementations from the Application hexagon.
    Instead, the input adapters will only depend on the use case interface types,
    rather than the input ports’ concrete types. In such a context, we can regard
    input adapters as high-level components and input ports as low-level components.
    Input adapters refer to use case interfaces. Input ports implement these use cases.
    The following diagram illustrates this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个推理，我们将重新实现应用程序和框架六边形模块，以便框架六边形的输入适配器不再需要依赖于应用程序六边形的输入端口实现。相反，输入适配器将只依赖于用例接口类型，而不是输入端口的具体类型。在这种情况下，我们可以将输入适配器视为高级组件，将输入端口视为低级组件。输入适配器指的是用例接口。输入端口实现这些用例。以下图示说明了这一点：
- en: '![Figure 9.1 – Dependency inversion with an input adapter, use case, and input
    port](img/B19777_09_01.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 使用输入适配器、用例和输入端口的依赖反转](img/B19777_09_01.jpg)'
- en: Figure 9.1 – Dependency inversion with an input adapter, use case, and input
    port
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 使用输入适配器、用例和输入端口的依赖反转
- en: The preceding diagram illustrates how we can approach dependency inversion in
    the hexagonal architecture. This example considers the dependency inversion between
    the Framework and Application hexagons, but we can do the same thing with the
    Domain hexagon as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示说明了我们如何在六边形架构中实现依赖反转。此示例考虑了框架和应用六边形的依赖反转，但我们可以用领域六边形做同样的事情。
- en: 'Let’s consider how `RouterManagementGenericAdapter` is currently accessing
    the implementation details instead of the abstraction:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下 `RouterManagementGenericAdapter` 当前是如何访问实现细节而不是抽象的：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By calling `new RouterManagementInputPort(RouterManagementH2Adapter.getInstance())`,
    we are making the input adapter depend on the implementation details of both the
    `RouterManagementInputPort` input port and the output adapter expressed by `RouterManagementH2Adapter`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `new RouterManagementInputPort(RouterManagementH2Adapter.getInstance())`，我们使输入适配器依赖于
    `RouterManagementInputPort` 输入端口和由 `RouterManagementH2Adapter` 表达的输出适配器的实现细节。
- en: 'To make an input port class eligible to be used as a provider class in the
    JPMS, we need to do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使输入端口类有资格作为 JPMS 中的提供者类使用，我们需要做以下事情：
- en: 'First, we must add a no-arguments constructor:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须添加一个无参数构造函数：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we must declare the `setOutputPort` method in the use case interface:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在用例接口中声明 `setOutputPort` 方法：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, we must implement the `setOutputPort` method in the input port:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在输入端口中实现 `setOutputPort` 方法：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can update the Application hexagon’s `module` descriptor to define
    the services that we’ll provide by using the use case interfaces and their input
    port’s implementations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新应用程序六边形的 `module` 描述符来定义我们将通过使用用例接口及其输入端口的实现来提供的服务：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start by declaring the dependency that the `application` module has on the
    Domain hexagon and `lombok` modules. Then, we use `exports` to enable access to
    the input ports, output ports, and use cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明 `application` 模块对领域六边形和 `lombok` 模块的依赖。然后，我们使用 `exports` 来启用对输入端口、输出端口和用例的访问。
- en: 'Next, we must declare the services we want to provide. We can accomplish this
    service declaration by providing a use case interface and the input port that
    implements it. Let’s declare the service provider for router management:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须声明我们想要提供的服务。我们可以通过提供用例接口及其实现它的输入端口来完成此服务声明。让我们声明路由管理的服务提供者：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, `RouterManagementUseCase` is being provided by `RouterManagementInputPort`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`RouterManagementUseCase` 是由 `RouterManagementInputPort` 提供的。
- en: 'Next, we must define the service provider for switch management:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义用于交换管理的服务提供商：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, `SwitchManagementUseCase` is being provided by `SwitchManagementInputPort`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`SwitchManagementUseCase`是由`SwitchManagementInputPort`提供的。
- en: 'Finally, we must declare the service provider for network management:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须声明网络管理的服务提供商：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have `NetworkManagementUseCase` being provided by `NetworkManagementInputPort`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`NetworkManagementUseCase`是由`NetworkManagementInputPort`提供的。
- en: Before we learn how to access these input ports through JPMS services in input
    adapters, let’s learn how we can invert dependencies when working with output
    ports and output adapters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何通过JPMS服务在输入适配器中访问这些输入端口之前，让我们学习如何在处理输出端口和输出适配器时反转依赖关系。
- en: Providing services with output ports and output adapters
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输出端口和输出适配器提供服务
- en: 'In the Framework hexagon, we have output ports as interfaces and output adapters
    as their implementations. Input ports depend on output ports. In that sense, input
    ports can be regarded as high-level components because they depend on the abstractions
    provided by output ports. Output adapters act as low-level components that provide
    implementations for output port abstractions. The following diagram shows an illustration
    of this dependency inversion arrangement:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架六边形中，我们将输出端口作为接口，将输出适配器作为它们的实现。输入端口依赖于输出端口。从这个意义上讲，输入端口可以被视为高级组件，因为它们依赖于输出端口提供的抽象。输出适配器作为低级组件，为输出端口抽象提供实现。以下图表展示了这种依赖反转安排的示意图：
- en: '![Figure 9.2 – Dependency inversion with an input port, output port, and output
    adapter](img/B19777_09_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 使用输入端口、输出端口和输出适配器的依赖反转](img/B19777_09_02.jpg)'
- en: Figure 9.2 – Dependency inversion with an input port, output port, and output
    adapter
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 使用输入端口、输出端口和输出适配器的依赖反转
- en: Note that both the input port and the output adapter point to the same output
    port abstraction. This means that we can use the JPMS to apply the dependency
    inversion principle with these architecture components.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入端口和输出适配器都指向相同的输出端口抽象。这意味着我们可以使用JPMS将这些架构组件应用于依赖反转原则。
- en: 'However, there is one requirement we have to meet to use output adapters as
    implementation providers. This requirement requires every provider class to have
    a public constructor with no parameters, which is not the case for the output
    adapters we implemented in the previous chapters:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使用输出适配器作为实现提供商，我们必须满足一个要求。这个要求需要每个提供者类都有一个不带参数的公共构造函数，而我们在前几章中实现的输出适配器并不符合这一要求：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We implemented the `RouterManagementH2Adapter` constructor as `private` to
    enforce a singleton pattern. To show how to use this output adapter as a JPMS
    service provider, we need to disable the singleton pattern by changing the constructor’s
    access modifier from `private` to `public`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`RouterManagementH2Adapter`构造函数实现为`private`，以强制使用单例模式。为了展示如何将此输出适配器作为JPMS服务提供商使用，我们需要通过将构造函数的访问修饰符从`private`更改为`public`来禁用单例模式：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we can update the framework hexagon’s `module` (the `info.java` file)
    to define the services:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新框架六边形的`module`（即`info.java`文件），以定义服务：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start by using the `requires` directive to declare the module dependencies
    on the Domain and Application hexagon modules. Then, we use the `exports` directive
    to enable access to all public types in the `dev.davivieira.topologyinventory.framework.adapters.output.h2.data`
    package. We use the `opens` directive to allow runtime reflective access to the
    output adapters. We need this reflective access because of the database library
    dependencies that these output adapters have.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`requires`指令声明对域和应用六边形模块的模块依赖。然后，我们使用`exports`指令启用对`dev.davivieira.topologyinventory.framework.adapters.output.h2.data`包中所有公共类型的访问。我们使用`opens`指令允许对输出适配器进行运行时反射访问。我们需要这种反射访问，因为这些输出适配器有数据库库依赖项。
- en: Finally, we use the `provides` and `with` directives to inform the output port
    interfaces, `RouterManagementOutputPort` and `SwitchManagementOutputPort`, along
    with their respective output adapter implementations, `RouterManagementH2Adapter`
    and `SwitchManagementH2Adapter`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`provides`和`with`指令来告知输出端口接口，包括`RouterManagementOutputPort`和`SwitchManagementOutputPort`，以及它们各自的输出适配器实现，即`RouterManagementH2Adapter`和`SwitchManagementH2Adapter`。
- en: Now that we’ve completed the configuration that’s required to enable dependency
    inversion between the output ports and adapters, let’s learn how to configure
    input adapters to access dependencies through their abstractions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了配置，以启用输出端口和适配器之间的依赖反转，让我们学习如何配置输入适配器通过它们的抽象访问依赖项。
- en: Making the input adapters dependent on abstractions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使输入适配器依赖于抽象
- en: 'The first step in consuming the services we have exposed with the `provides`
    and `with` directives is to update the `module` descriptor of the consumer’s `framework`
    hexagon module by utilizing the `uses` directive. We’ll execute the following
    steps to do so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 消费我们使用 `provides` 和 `with` 指令公开的服务的第一步是更新消费者 `framework` 六边形模块的 `module` 描述符，利用
    `uses` 指令。我们将执行以下步骤来完成此操作：
- en: 'Let’s start by updating the module descriptor:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先更新模块描述符：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first three `uses` directives point to the services provided by the Application
    hexagon module. The last two `uses` directives refer to the services we exposed
    in the Framework hexagon module.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前三个 `uses` 指令指向应用程序六边形模块提供的服务。最后两个 `uses` 指令指的是我们在框架六边形模块中公开的服务。
- en: Now that we have the `module` descriptors adequately configured to allow the
    system to depend on interfaces instead of implementations, we need to refactor
    the input adapters so that they only rely on use case interfaces from the Application
    hexagon module and output the port interfaces from the Framework hexagon module.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经适当地配置了 `module` 描述符，允许系统依赖于接口而不是实现，我们需要重构输入适配器，以便它们只依赖于应用程序六边形模块的使用情况接口，并输出框架六边形模块的端口接口。
- en: 'First, we must configure the `RouterManagementGenericAdapter` adapter:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须配置 `RouterManagementGenericAdapter` 适配器：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that `RouterManagementGenericAdapter` no longer depends on `RouterManagementInputPort`
    and `RouterManagementH2Adapter`, as it did previously. There is only one dependency
    on the `RouterManagementUseCase` interface.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`RouterManagementGenericAdapter` 现在不再依赖于 `RouterManagementInputPort` 和 `RouterManagementH2Adapter`，就像之前那样。只有一个依赖项在
    `RouterManagementUseCase` 接口上。
- en: 'For the `SwitchManagementGenericAdapter` input adapter, this is how we should
    configure the dependency:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `SwitchManagementGenericAdapter` 输入适配器，这是我们应该配置依赖项的方式：
- en: '[PRE15]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SwitchManagementGenericAdapter` input adapter depends on both the `RouterManagementUseCase`
    and `SwitchManagementUseCase` use case interfaces to perform its activities.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SwitchManagementGenericAdapter` 输入适配器依赖于 `RouterManagementUseCase` 和 `SwitchManagementUseCase`
    使用情况接口以执行其活动。'
- en: 'To conclude, we have to adjust the `NetworkManagementGenericAdapter` adapter
    class:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须调整 `NetworkManagementGenericAdapter` 适配器类：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `NetworkManagementGenericAdapter` input adapter follows the same pattern
    we used in the previous input adapters and requires use case references in the
    input adapter’s constructor. Here, we’re making use of the `SwitchManagementUseCase`
    and `NetworkManagementUseCase` use case interfaces.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NetworkManagementGenericAdapter` 输入适配器遵循我们在之前输入适配器中使用的相同模式，并在输入适配器的构造函数中需要使用情况引用。在这里，我们正在使用
    `SwitchManagementUseCase` 和 `NetworkManagementUseCase` 使用情况接口。'
- en: 'In this section, we touched on a crucial JPMS feature: service providers. By
    using them, we can bind input port implementations to the use case interfaces.
    That’s how we arrange the code. So, the input adapters can rely on use case abstractions
    to trigger operations on the Application hexagon.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提到了一个关键的 JPMS 功能：服务提供者。通过使用它们，我们可以将输入端口实现绑定到使用情况接口。这就是我们组织代码的方式。因此，输入适配器可以依赖于使用情况抽象来触发应用程序六边形上的操作。
- en: Now, let’s learn how to use `ServiceLoader` to retrieve service implementations
    based on the JPMS providers we have defined.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用 `ServiceLoader` 根据我们定义的 JPMS 提供者检索服务实现。
- en: Using the Java platform’s ServiceLoader class to retrieve JPMS provider implementations
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 平台的 ServiceLoader 类检索 JPMS 提供者实现
- en: So far, we have configured the `module` descriptor of the Application and Framework
    hexagon modules. We have refactored the input adapters so that they only depend
    on the abstractions provided by use case interfaces. *But how can we retrieve
    the concrete instances that implement those use case interfaces?* That’s exactly
    what the `ServiceLoader` class does.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置了应用程序和框架六边形模块的 `module` 描述符。我们已经重构了输入适配器，以便它们只依赖于使用情况接口提供的抽象。*但是，我们如何检索实现这些使用情况接口的具体实例呢？*
    这正是 `ServiceLoader` 类所做的事情。
- en: '`ServiceLoader` is not a new class made solely to support JPMS features. Instead,
    `ServiceLoader` has been present in Java since version `module` descriptor to
    find implementations for a given service provider interface.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceLoader`不是一个仅为了支持JPMS特性而创建的新类。相反，`ServiceLoader`自Java版本`module`描述符以来就存在于Java中，用于查找给定服务提供者接口的实现。'
- en: 'To illustrate how we can use `ServiceLoader`, let’s update the `FrameworkTestData`
    test class by creating a method called `loadPortsAndUseCases`. This method uses
    `ServiceLoader` to retrieve the objects we need to instantiate the input adapters.
    We need to create the `loadPortsAndUseCases` method because we’ll call it to initialize
    the input adapters through `ServiceLoader`. Before creating the `loadPortsAndUseCases`
    method, we need to declare the input adapter variables that we’ll use to assign
    the objects that are instantiated with the aid of `ServiceLoader`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用`ServiceLoader`，让我们通过创建一个名为`loadPortsAndUseCases`的方法来更新`FrameworkTestData`测试类。此方法使用`ServiceLoader`检索我们需要实例化输入适配器的对象。我们需要创建`loadPortsAndUseCases`方法，因为我们将在初始化输入适配器时通过`ServiceLoader`调用它。在创建`loadPortsAndUseCases`方法之前，我们需要声明我们将使用以分配由`ServiceLoader`辅助实例化的对象的输入适配器变量：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The variables we’ve declared here are used to store references for the input
    adapters we’ll create using the input ports and output adapters objects that we
    obtained from the `ServiceLoader` class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里声明的变量用于存储我们将使用从`ServiceLoader`类获得的输入端口和输出适配器对象创建的输入适配器的引用。
- en: Let’s start by initializing `RouterManagementGenericAdapter`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先初始化`RouterManagementGenericAdapter`。
- en: Initializing RouterManagementGenericAdapter
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化`RouterManagementGenericAdapter`
- en: 'We will start the `loadPortsAndUseCases` method’s implementation by using a
    `ServiceLoader` instance to retrieve the objects that are necessary for instantiating
    `RouterManagementGenericAdapter`. We’ll perform the following steps to do this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ServiceLoader`实例检索创建`RouterManagementGenericAdapter`所需的必要对象来开始`loadPortsAndUseCases`方法的实现。我们将执行以下步骤来完成此操作：
- en: 'The following code shows the `loadPortsAndUseCases` method’s initial implementation:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了`loadPortsAndUseCases`方法的初始实现：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `load` method from `ServiceLoader` receives a `RouterManagementUseCase.class`
    file as a parameter. This method can find all the implementations for the `RouterManagementUseCase`
    interface. Since `RouterManagementInputPort` is the only implementation that’s
    available for the use case interface, we can call `loaderUseCaseRouter.findFirst().get()`
    to get that implementation.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ServiceLoader`的`load`方法接收一个`RouterManagementUseCase.class`文件作为参数。此方法可以找到`RouterManagementUseCase`接口的所有实现。由于`RouterManagementInputPort`是唯一可用于用例接口的实现，我们可以调用`loaderUseCaseRouter.findFirst().get()`来获取该实现。'
- en: Aside from a proper implementation for the `RouterManagementUseCase` interface,
    we also need to provide an implementation for the `RouterManagementOutputPort`
    interface.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了为`RouterManagementUseCase`接口提供适当的实现外，我们还需要为`RouterManagementOutputPort`接口提供实现。
- en: 'The following code shows how to retrieve a `RouterManagementOutputPort` object:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了如何检索`RouterManagementOutputPort`对象：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The call on `loaderOutputRouter.findFirst().get()` retrieves a `RouterManagementH2Adapter`
    object, which is the only available implementation for the `RouterManagementOutputPort`
    interface.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对`loaderOutputRouter.findFirst().get()`的调用检索了一个`RouterManagementH2Adapter`对象，这是唯一可用于`RouterManagementOutputPort`接口的实现。
- en: With the `RouterManagementInputPort` and `RouterManagementH2Adapter` objects
    loaded from `ServiceLoader`, we have the required objects to create an input adapter.
    But first, we need to set up the output port for the use case.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过从`ServiceLoader`加载`RouterManagementInputPort`和`RouterManagementH2Adapter`对象，我们拥有了创建输入适配器所需的必要对象。但在创建输入适配器之前，我们需要设置用例的输出端口。
- en: 'This is how we can set a `RouterManagementOutputPort` object in `RouterManagementUseCase`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们在`RouterManagementUseCase`中设置`RouterManagementOutputPort`对象的方法：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By calling `routerManagementUseCase.setOutputPort(routerManagementOutputPort)`,
    we are setting `RouterManagementOutputPort` in `RouterManagementUseCase`.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用`routerManagementUseCase.setOutputPort(routerManagementOutputPort)`，我们在`RouterManagementUseCase`中设置了`RouterManagementOutputPort`。
- en: 'Now, we can create a new `RouterManagementGenericAdapter` adapter by passing
    `RouterManagementUseCase`, which we have just created, to its constructor:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将我们刚刚创建的`RouterManagementUseCase`传递给其构造函数来创建一个新的`RouterManagementGenericAdapter`适配器：
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let’s move on and learn how to initialize `SwitchManagementGenericAdapter`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何初始化`SwitchManagementGenericAdapter`。
- en: Initializing SwitchManagementGenericAdapter
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化`SwitchManagementGenericAdapter`
- en: 'Still inside the `loadPortsAndUseCases` method, we need to use `ServiceLoader`
    to find an available implementation for `SwitchManagementUseCase`. We’ll perform
    the following steps for the same reason:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在 `loadPortsAndUseCases` 方法内部，我们需要使用 `ServiceLoader` 来找到 `SwitchManagementUseCase`
    的可用实现。我们将执行以下步骤出于相同的原因：
- en: 'In the following code, we are retrieving a `SwitchManagementUseCase` implementation:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们正在检索一个 `SwitchManagementUseCase` 实现：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By calling `ServiceLoader.load(SwitchManagementUseCase.class)`, we are retrieving
    a `ServiceLoader` object containing all the available implementations for `SwitchManagementUseCase`.
    In our case, the only available implementation is the `SwitchManagementInputPort`
    input port. To load such an implementation, we must call `loaderUseCaseSwitch.findFirst().get()`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用 `ServiceLoader.load(SwitchManagementUseCase.class)`，我们正在检索一个包含所有可用 `SwitchManagementUseCase`
    实现的 `ServiceLoader` 对象。在我们的情况下，唯一的可用实现是 `SwitchManagementInputPort` 输入端口。要加载此类实现，我们必须调用
    `loaderUseCaseSwitch.findFirst().get()`。
- en: We also need an implementation for the `SwitchManagementOutputPort` output port.
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要 `SwitchManagementOutputPort` 输出端口的实现。
- en: 'The following code shows how we can get a `SwitchManagementOutputPort` implementation:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何获取 `SwitchManagementOutputPort` 实现：
- en: '[PRE23]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Output adapters implement output ports. So, to get an output port implementation,
    we should call `ServiceLoader.load(SwitchManagementOutputPort.class)` to load
    the `SwitchManagementH2Adapter` implementation and then call `loaderOutputSwitch.findFirst().get()`
    to retrieve that implementation object.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出适配器实现了输出端口。因此，要获取输出端口实现，我们应该调用 `ServiceLoader.load(SwitchManagementOutputPort.class)`
    来加载 `SwitchManagementH2Adapter` 实现，然后调用 `loaderOutputSwitch.findFirst().get()`
    来检索该实现对象。
- en: 'Now, we can use the output port object to set it in the use case:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用输出端口对象将其设置在用例中：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can initiate the input adapter:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以启动输入适配器：
- en: '[PRE25]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To instantiate `SwitchManagementGenericAdapter`, we need to pass references
    for both the `RouterManagementUseCase` and `SwitchManagementUseCase` use cases.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要实例化 `SwitchManagementGenericAdapter`，我们需要传递 `RouterManagementUseCase` 和 `SwitchManagementUseCase`
    用例的引用。
- en: Now, let’s move on and learn how to initialize `NetworkManagementGenericAdapter`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何初始化 `NetworkManagementGenericAdapter`。
- en: Initializing NetworkManagementGenericAdapter
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 NetworkManagementGenericAdapter
- en: 'For `NetworkManagementGenericAdapter`, we only need to load an implementation
    for `NetworkManagementUseCase`. Follow these steps to do so:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `NetworkManagementGenericAdapter`，我们只需要加载 `NetworkManagementUseCase` 的实现。按照以下步骤操作：
- en: 'The following code shows how we should use `ServiceLoader` to get a `NetworkManagementUseCase`
    object:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了我们应该如何使用 `ServiceLoader` 来获取 `NetworkManagementUseCase` 对象：
- en: '[PRE26]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we must reuse `RouterManagementOutputPort`, which we loaded previously,
    to set `NetworkManagementUseCase`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须重用之前加载的 `RouterManagementOutputPort`，以设置 `NetworkManagementUseCase`：
- en: '[PRE27]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we can initiate `NetworkManagementGenericAdapter`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以启动 `NetworkManagementGenericAdapter`：
- en: '[PRE28]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To initiate a new `NetworkManagementGenericAdapter` adapter, we must pass references
    for the `SwitchManagementUseCase` and `NetworkManagementUseCase` use cases.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要启动一个新的 `NetworkManagementGenericAdapter` 适配器，我们必须传递 `SwitchManagementUseCase`
    和 `NetworkManagementUseCase` 用例的引用。
- en: This section taught us how to retrieve interface implementations using `ServiceLoader`
    in conjunction with JPMS service providers. With this technique, we can structure
    code that only relies on abstractions rather than implementations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节教我们如何使用 `ServiceLoader` 与 JPMS 服务提供者结合来检索接口实现。使用这种技术，我们可以构建只依赖于抽象而不是实现的代码。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by looking into the motivations and benefits behind
    the JPMS. We discovered that one of the problems the JPMS solves is that of JAR
    hell, where it’s difficult to control the dependencies that an application should
    expose and use. The JPMS addresses this problem by closing access to every public
    type in a module, requiring the developer to explicitly state which packages containing
    public types should be visible to other modules. Also, the developer should state
    the modules that a given module depends on in the `module` descriptor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先探讨了 JPMS 的动机和好处。我们发现 JPMS 解决的一个问题是 JAR 地狱，在那里很难控制应用程序应该暴露和使用的依赖项。JPMS
    通过关闭对模块中每个公共类型的访问来解决这个问题，要求开发者明确声明哪些包含公共类型的包应该对其他模块可见。此外，开发者应在 `module` 描述符中声明给定模块所依赖的模块。
- en: Next, we discussed the DIP and recognized the use cases, input ports, input
    adapters, and output adapters as components that we can apply to the DIP. Then,
    we used JPMS features such as consumers, services, and providers to refactor the
    topology and inventory system to enable dependency inversion in conjunction with
    hexagonal architecture components.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了DIP，并认识到使用案例、输入端口、输入适配器和输出适配器作为我们可以应用于DIP的组件。然后，我们使用JPMS功能，如消费者、服务和提供者，重构拓扑和库存系统，以实现与六边形架构组件结合的依赖倒置。
- en: By employing the DIP, we created a more supple design, an important characteristic
    when it comes to building change-tolerant systems. We learned that the JPMS is
    a Java technology that we can use to implement DIP. Such technology also enables
    us to provide robust encapsulation by isolating related code into modules. This
    capability is paramount if we wish to establish and enforce boundaries between
    the Domain, Application, and Framework hexagons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用DIP，我们创建了一个更灵活的设计，这在构建容错系统时是一个重要特性。我们了解到JPMS是一种Java技术，我们可以用它来实现DIP。这种技术还使我们能够通过将相关代码隔离到模块中来提供强大的封装。如果我们希望建立和执行领域、应用和框架六边形的边界，这种能力至关重要。
- en: In the next chapter, we’ll start our journey into the cloud-native world by
    learning about the Quarkus Framework and how to use it to prepare and optimize
    a hexagonal system to run in a cloud-native environment.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始我们的云原生之旅，通过学习Quarkus框架以及如何使用它来准备和优化六边形系统以在云原生环境中运行。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: Which JAR dependency problem does the JPMS aim to solve?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JPMS旨在解决哪种JAR依赖问题？
- en: Which JPMS directive should we use to enable access to a package containing
    public types?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用哪个JPMS指令来启用对包含公共类型的包的访问？
- en: To declare a dependency on a module, which JPMS directive should we use?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要声明对模块的依赖，我们应该使用哪个JPMS指令？
- en: When applying dependency inversion on the hexagonal architecture, which components
    can be regarded as high-level, abstraction, and low-level?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用依赖倒置原则于六边形架构时，哪些组件可以被视为高级、抽象和低级？
- en: Answers
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章问题的答案：
- en: The JAR hell problem.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JAR地狱问题。
- en: The exports directive.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: exports指令。
- en: The requires directive.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: requires指令。
- en: Input adapters, use cases, and input ports, respectively.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入适配器、用例和输入端口，分别。
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Dependency Inversion Principle*, by Robert C. Martin, C++ Report, 1996.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖倒置原则*，由Robert C. Martin撰写，C++ Report，1996年。'
- en: 'Part 3: Becoming Cloud-Native'
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：成为云原生
- en: In this part, you will integrate the Quarkus framework into a hexagonal application,
    making it truly modern cloud-native software that's ready to be deployed in cloud
    environments.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，你将集成Quarkus框架到六边形应用程序中，使其真正成为现代云原生软件，准备好在云环境中部署。
- en: We'll learn how to add Quarkus to our existing topology and inventory system.
    Then, we'll explore some of the exciting Quarkus features, such as CDI beans,
    RESTEasy Reactive, and Hibernate Reactive. After combining Quarkus and hexagonal
    architecture, we'll learn how to dockerize and create Kubernetes objects to deploy
    our hexagonal application to a Kubernetes cluster.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何将Quarkus添加到我们现有的拓扑和库存系统中。然后，我们将探索一些令人兴奋的Quarkus特性，如CDI Bean、RESTEasy
    Reactive和Hibernate Reactive。结合Quarkus和六边形架构后，我们将学习如何docker化并创建Kubernetes对象，以便将我们的六边形应用程序部署到Kubernetes集群。
- en: 'This part has the following chapters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B19777_10.xhtml#_idTextAnchor213), *Adding Quarkus to a Modularized
    Hexagonal Application*'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19777_10.xhtml#_idTextAnchor213)，*将Quarkus添加到模块化的六边形应用程序中*'
- en: '[*Chapter 11*](B19777_11.xhtml#_idTextAnchor228), *Leveraging CDI Beans to
    Manage Ports and Use Cases*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19777_11.xhtml#_idTextAnchor228)，*利用CDI Bean管理端口和用例*'
- en: '[*Chapter 12*](B19777_12.xhtml#_idTextAnchor244), *Using RESTEasy Reactive
    to Implement Input Adapters*'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19777_12.xhtml#_idTextAnchor244)，*使用RESTEasy Reactive实现输入适配器*'
- en: '[*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data with Output
    Adapters and Hibernate Reactive*'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19777_13.xhtml#_idTextAnchor263)，*使用输出适配器和Hibernate Reactive持久化数据*'
- en: '[*Chapter 14*](B19777_14.xhtml#_idTextAnchor286), *Setting Up Dockerfile and
    Kubernetes Objects for Cloud Deployment*'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19777_14.xhtml#_idTextAnchor286)，*设置Dockerfile和Kubernetes对象以进行云部署*'
