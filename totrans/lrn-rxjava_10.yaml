- en: Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While unit testing is not a silver bullet to ensure that your code works properly,
    it is a good practice to strive for. This is especially true if your logic is
    highly deterministic and modular enough to isolate.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with RxJava at first glance may not seem straightforward. After all,
    RxJava declares behaviors rather than states. So how do we test whether behaviors
    are working correctly, especially when most testing frameworks expect a stateful
    result? Fortunately, RxJava comes with several tools to aid testing, and you can
    use these tools with your favorite testing frameworks. There are many testing
    tools available on the market that can work with RxJava, but in this chapter,
    we will use JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also cover a few tips to effectively debug RxJava programs. One of
    the downsides of RxJava is that when bugs occur, traditional approaches to debugging
    are not always effective, particularly because the stack traces are not always
    helpful and breakpoints do not apply easily. But there is a benefit RxJava offers
    in debugging: with the right approach, you can walk through your entire reactive
    chain and find the operator that causes things to go wrong. The problem becomes
    very linear and a matter of isolating the bad link. This can simplify the debugging
    process significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has a number of testing features to cover, so we will start with
    simpler naive approaches to cover basic blocking operators. Then, we will escalate
    to the more robust tools, such as `TestObserver`, `TestSubscriber`, and `TestScheduler`,
    which you will likely use in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blockingSubscribe()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestObserver` and `TestSubscriber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestScheduler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava debugging strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be using JUnit as our testing framework. Add the following
    dependency to your Maven or Gradle project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the configuration for Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the configuration for Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To save yourself hassle, organize your code project to conform to the Maven
    Standard Directory layout. You might want to place your test classes in a `/src/test/java/`
    folder so Maven and Gradle will automatically recognize it as the test code folder.
    You also should put your production code in a `/src/main/java/` folder in your
    project. You can read more about the Maven Standard Directory layout at [https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html).
  prefs: []
  type: TYPE_NORMAL
- en: Blocking subscribers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember how sometimes we have to stop the main thread from racing past an
    `Observable` or `Flowable` that operates on a different thread and keep it from
    exiting the application before it has a chance to fire? We often prevented this
    using `Thread.sleep()`, especially when we used `Observable.interval()`, `subscribeOn()`,
    or `observeOn()`. The following code shows how we did this typically and kept
    an `Observable.interval()` application alive for five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to unit testing, the unit test usually has to complete before
    it starts the next one. This can become quite messy when we have an `Observable`
    or `Flowable` operation that happens on a different thread. When a `test` method
    declares an asynchronous `Observable` or `Flowable` chain operation, we need to
    block and wait for that operation to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create a test to ensure that five emissions are emitted from `Observable.interval()`,
    and we increment `AtomicInteger` before validating that it was incremented five
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use the `@Test` annotation to tell `JUnit` that this is a test method. You
    can run it in Intellij IDEA by clicking on its green triangular *play* button
    in the gutter or by running the test task in Gradle or Maven.
  prefs: []
  type: TYPE_NORMAL
- en: There is a problem, though. When you run this test, the assertion fails. `Observable.interval()`
    is running on a computation thread and the main thread rushes past it. The main
    thread performs `assertTrue()` before the five emissions are fired and therefore
    finds `hitCount` to be `0` rather than `5`. We need to stop the main thread until
    `subscribe()` finishes and calls `onComplete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we do not have to get creative using synchronizers and other native
    Java concurrency tools. Instead, we can use `blockingSubscribe()`, which will
    block the declaring main thread until `onComplete()` (or `onError()`) is called.
    Once those five emissions are gathered, the main thread can proceed and perform
    the assertion successfully, as demonstrated here. The test should then pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we will see in this chapter, there are better ways to test other than `blockingSubscribe()`.
    But `blockingSubscribe()` is a quick and effective way to stop the declaring thread
    and wait for the `Observable` or `Flowable` to finish before proceeding, even
    if it is on a different thread. Just make sure that the source terminates at some
    point, or the test will never finish.
  prefs: []
  type: TYPE_NORMAL
- en: Be judicious in how you use `blockingSubscribe()` outside the context of testing
    and using it in production. There are definitely times it is a legitimate solution
    to interface with a non-reactive API. For example, it can be valid to use it in
    production to keep an application alive indefinitely and is an effective alternative
    to using `Thread.sleep()`. Just be careful to ensure the asynchronous benefits
    of RxJava are not undermined.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In RxJava, there is a set of operators we have not covered yet called **blocking
    operators**. These operators serve as an immediate proxy between the reactive
    world and the stateful one, blocking and waiting for results to be emitted, but
    returned in a non-reactive way. Even if the reactive operations are working on
    different threads, blocking operators will stop the declaring thread and make
    it wait for the results in a synchronized manner, much like `blockingSubscribe()`.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking operators are especially helpful in making the results of an `Observable`
    or `Flowable` easily available for evaluation. However, you will want to avoid
    using them in production because they encourage anti-patterns and undermine the
    benefits of reactive programming. For testing, you will still want to prefer `TestObserver`
    and `TestSubscriber`, which we will cover later. But here are the blocking operators
    if you ever have a need for them.
  prefs: []
  type: TYPE_NORMAL
- en: blockingFirst()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `blockingFirst()` operator will stop the calling thread and make it wait
    for the first value to be emitted and returned (even if the chain is operating
    on a different thread with `observeOn()` and `subscribeOn()`). Say we want to
    test an `Observable` chain that filters a sequence of string emissions for only
    ones that have a length of four. If we want to assert that the first emission
    to make it through this operation is `Beta`, we can test for it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, our unit test is called `testFirst()`, and it will assert that the first
    string emitted with a length of four is `Beta`. Note that instead of using `subscribe()`
    or `blockingSubscribe()` to receive the emissions, we use `blockingFirst()`, which
    will return the first emission in a non-reactive way. In other words, it returns
    a straight-up string and not an `Observable` emitting string.
  prefs: []
  type: TYPE_NORMAL
- en: This will block the declaring thread until the value is returned and assigned
    to `firstWithLengthFour`. We then use that saved value to assert that it is, in
    fact, `Beta`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at `blockingFirst()`, you may be tempted to use it in production code
    to save a result statefully and refer to it later. Try not to do that! While there
    are certain cases where you might be able to justify it (such as saving emissions
    into a `HashMap` for expensive computations and lookups), blocking operators can
    easily be abused. If you need to persist values, try to use `replay()` and other
    reactive caching strategies so that you can easily change its behaviors and concurrency
    policies down the road. Blocking will often make your code less flexible and undermine
    the benefits of Rx.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `blockingFirst()` operator will throw an error and fail the test
    if no emissions come through. However, you can provide a default value as an overload
    to `blockingFirst()` so it always has a value to fall back on.
  prefs: []
  type: TYPE_NORMAL
- en: A similar blocking operator to `blockingFirst()` is `blockingSingle()`, which
    expects only a single item to be emitted, but throws an error if there are more.
  prefs: []
  type: TYPE_NORMAL
- en: blockingGet()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Maybe` and `Single` do not have `blockingFirst()` since there can only be
    one element at most. Logically, for a `Single` and `Maybe`, it is not exactly
    the *first* element, but rather the *only* element, so the equivalent operator
    is `blockingGet()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assert that all items of length four include only `Beta` and `Zeta`,
    and we collect them with `toList()`, which yields a `Single<List<String>>`. We
    can use `blockingGet()` to wait for this list and assert that it is equal to our
    desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: blockingLast()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is `blockingFirst()`, it only makes sense to have `blockingLast()`.
    This will block and return the last value to be emitted from an `Observable` or
    `Flowable` operation. Of course, it will not return anything until `onComplete()`
    is called, so this is something you will want to avoid using with infinite sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we assert that the last four-character string emitted from our operation
    is `Zeta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like `blockingFirst()`, `blockingLast()` will throw an error if no emissions
    occur, but you can specify an overload for a default value.
  prefs: []
  type: TYPE_NORMAL
- en: blockingIterable()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most interesting blocking operators is `blockingIterable()`. Rather
    than returning a single emission like our previous examples, it will provide the
    emissions as they become available through `iterable<T>`. The `Iterator<T>` provided
    by the `Iterable<T>` will keep blocking the iterating thread until the next emission
    is available, and the iteration will end when `onComplete()` is called. Here,
    we iterate through each returned string value to ensure that its length is actually
    `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `blockingIterable()` will queue up unconsumed values until the `Iterator`
    is able to process them. This can be problematic without backpressure as you may
    run into `OutOfMemoryException` errors.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike C#, note that Java's for-each construct will not handle cancellation,
    breaking, or disposal. You can work around this by iterating the `Iterator` from
    the iterable inside `try-finally`. In the `finally` block, cast the `Iterator`
    to a `disposable` so you can call its `dispose()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `blockingIterable()` can be helpful in quickly turning an `Observable` or
    `Flowable` into pull-driven functional sequence types such as a Java 8 Stream
    or Kotlin sequence, which can be built-off iterables. However, for Java 8 streams,
    you are likely better-off using David Karnok's RxJava2Jdk8Interop library ([https://github.com/akarnokd/RxJava2Jdk8Interop](https://github.com/akarnokd/RxJava2Jdk8Interop)),
    so that termination is handled more safely.
  prefs: []
  type: TYPE_NORMAL
- en: blockingForEach()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more fluent way in which we can execute a blocking for each task is to use
    the `blockingForEach()` operator instead of `blockingIterable()`. This will block
    the declaring thread and wait for each emission to be processed before allowing
    the thread to continue. We can streamline our earlier example, where we iterated
    each emitted string and ensured that its length was five and specify the assertion
    as a lambda in the `forEach()` operator instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A variant of `blockingForEach()` is `blockingForEachWhile()`, which accepts
    a predicate that gracefully terminates the sequence if the predicate evaluates
    to false against an emission. This can be desirable if all emissions are not going
    to be consumed and you want to gracefully terminate.
  prefs: []
  type: TYPE_NORMAL
- en: blockingNext()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `blockingNext()` will return an iterable and block each iterator''s `next()`
    request until the next value is provided. Emissions that occur after the last
    fulfilled `next()` request and before the current `next()` are ignored. Here,
    we have a source that emits every microsecond (1/1000th of a millisecond). Note
    that the iterable returned from `blockingNext()` ignored previous values it missed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: blockingLatest()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The iterable from `blockingLatest()`, on the other hand, does not wait for
    the next value, but requests the last emitted value. Any values before that which
    were not captured are forgotten. It will not reconsume the latest value if the
    iterator''s `next()` consumed it previously and will block until the next one
    comes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: blockingMostRecent()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `blockingMostRecent()` is similar to `blockingLatest()`, but it will re-consume
    the latest value repeatedly for every `next()` call from the iterator even if
    it was consumed already. It also requires a `defaultValue` argument so it has
    something to return if no value is emitted yet. Here, we use `blockingMostRecent()`
    against an `Observable` emitting every 10 milliseconds. The default value is `-1`,
    and it consumes each value repeatedly until the next value is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we finish covering blocking operators, it should be emphasized again that
    they can be an effective way to do simple assertions and provide means to block
    for results so they can be consumed easily by a testing framework. However, you
    will want to avoid using blocking operators for production as much as possible.
    Try not to give into the sirens of convenience, as you will find that they can
    quickly undermine the flexibility and benefits of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Using TestObserver and TestSubscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered `blockingSubscribe()` and several blocking operators in this chapter
    so far. While you can use these blocking tools to do simple assertions, there
    is a much more comprehensive way to test reactive code than simply blocking for
    one or more values. After all, we should do more than test `onNext()` calls. We
    also have `onComplete()` and `onError()` events to account for! It also would
    be great to streamline testing other RxJava events, such as subscription, disposal,
    and cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: So let's introduce the `TestObserver` and `TestSubscriber`, your two best friends
    in testing your RxJava applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestObserver` and `TestSubscriber` are a treasure trove of convenient methods
    to aid testing, many of which assert that certain events have occurred or specific
    values were received. There are also blocking methods, such as `awaitTerminalEvent()`,
    which will stop the calling thread until the reactive operation terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: '`TestObserver` is used for `Observable`, `Single`, `Maybe`, and `Completable`
    sources, while `TestSubscriber` is used for Flowable sources. Here is a unit test
    showcasing several `TestObserver` methods, which also exist on `TestSubscriber`
    if you are working with Flowables. These methods perform tasks such as asserting
    that certain events have (or have not) occurred, awaiting terminations or asserting
    that certain values were received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is just a handful of many testing methods available, and they will make
    your unit tests in a much more comprehensive and streamlined manner. Most of the
    `TestObserver` methods return `TestObserver` so you can actually chain these assertions
    fluently (and this also applies to `TestSubscriber`).
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the `awaitTerminalEvent()` operator can accept a timeout argument
    that will throw an error if the source does not complete before that time.
  prefs: []
  type: TYPE_NORMAL
- en: Spend some time going through all these testing methods so you are aware of
    the different assertions you make. Prefer `TestObserver` and `TestSubscriber`
    over blocking operators as much as possible. This way, you can spend less time
    maintaining your tests and ensure that you cover the full spectrum of events in
    the life cycle of an `Observable` or `Flowable` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`TestObserver` implements `Observer`, `MaybeObserver`, `SingleObserver`, and
    `CompetableObserver` to support all these reactive types. If you live test a long-running
    asynchronous source, you might want to use `awaitCount()` to wait for a minimum
    number of emissions to assert with and not wait for the `onComplete()` call.'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating time with the TestScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous examples, did you notice that testing a time-driven `Observable`
    or `Flowable` requires that time to elapse before the test completes? In the last
    exercise, we took five emissions from an `Observable.interval()` emitting every
    1 second, so that test took 5 seconds to complete. If we have a lot of unit tests
    that deal with time-driven sources, it can take a long time for testing to complete.
    Would it not be nice if we could simulate time elapses rather than experiencing
    them?
  prefs: []
  type: TYPE_NORMAL
- en: The `TestScheduler` does exactly this. It is a Scheduler implementation that
    allows us to *fast-forward* by a specific amount of elapsed time, and we can do
    any assertions after each f*ast-forward* to see what events have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create a test against `Observable.interval()` that emits every minute and
    ultimately asserts that 90 emissions have occurred after 90 minutes. Rather than
    having to wait the entire 90 minutes in real time, we use `TestObserver` to artificially
    elapse these 90 minutes. This allows the test to run instantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Cool, right? It is almost like time travel! We put `Observable.interval()` on
    our `TestScheduler`. This way, `TestScheduler` controls how the `Observable` interprets
    time and pushes emissions. We fast-forward 30 seconds using `advanceTimeBy()` and
    then assert that no emissions have happened yet. We then use `advanceTimeTo()`
    to jump 70 seconds after subscription occurred and assert that one emission did
    happen. Finally, we advance 90 minutes after subscription, and we assert that
    90 emissions did, in fact, occur.
  prefs: []
  type: TYPE_NORMAL
- en: This all ran instantly rather than taking 90 minutes, showing that it is indeed
    possible to test time-driven `Observable`/`Flowable` operations without having
    to actually elapse that time. Carefully note that `advanceTimeBy()` will fast-forward
    the specified time interval relative to the *current* time, whereas `advanceTimeTo()`
    will jump to the exact time elapsed since the subscription has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, use `TestScheduler` when you need to virtually represent time elapsing,
    but note that it is not a thread-safe Scheduler and should not be used with actual
    concurrency. A common pitfall is complicated flows that use many operators and
    Schedulers are not easily configurable to use `TestScheduler`. In this case, you
    can use `RxJavaPlugins.setComputationScheduler()` and similar methods that override
    the standard Schedulers and inject `TestScheduler` in its place.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other methods to note in `TestScheduler`. The `now()` will return
    how much time has virtually elapsed in the unit you specify. The `triggerActions()`
    method will kick-off any actions that are scheduled to be triggered, but have
    not virtually been elapsed yet.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging RxJava code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RxJava is not easy to debug at first glance, primarily due to the lack of debug
    tooling and the large stack traces it can produce. There are efforts in creating
    effective debugging tools for RxJava, most notably the Frodo library for Android
    ([https://github.com/android10/frodo](https://github.com/android10/frodo)). We
    will not cover any debugging tools for RxJava as nothing has been standardized
    quite yet, but we will learn about an effective approach that you can take to
    debug reactive code.
  prefs: []
  type: TYPE_NORMAL
- en: A common theme in debugging RxJava operations is finding the bad link or the
    operator in the `Observable`/`Flowable` chain that is causing the problem. Whether
    an error is being emitted, `onComplete()` is never being called, or an `Observable`
    is unexpectedly empty, you often have to start at the beginning of the chain at
    the source and then validate each step downstream until you find the one not working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, we have an `Observable` pushing five strings containing numbers and alphabetic
    words separated by slashes "`/`". We want to break these up on the slashes "`/`",
    filter only for the alphabetic words, and capture them in `TestObserver`. However,
    run this operation and you will see that this test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So what in the world went wrong? How do we debug this failing test? Well, remember
    that RxJava operations are a pipeline. The correct emissions are supposed to flow
    through and make it to the `Observer`. But no emissions were received instead.
    Let's get our plumber gear on and find out where the clog in the pipeline is.
    We will start at the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Place `doOnNext()` immediately after the source and before `concatMap()`, and
    print each emission. This gives us visibility into what is coming out of the source
    `Observable`. As shown here, we should see all the emissions from the source print,
    which shows that no emissions are being omitted and the source upstream is working
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s move downstream and look at `concatMap()` next. Maybe that is omitting
    emissions, so let''s check. Move `doOnNext()` after `concatMap()` and print each
    emission to see whether all of them are coming through, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so `concatMap()` is working fine and all the emissions are going through.
    So nothing is wrong with the splitting operation inside `concatMap()`. Let''s
    move on downstream and put `doOnNext()` after `filter()`. As shown, print each
    emission to see whether the ones we want come out of the `filter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! No emissions were printed after `filter()`, which means nothing flowed
    through it. The `filter()` is the operator causing the problem. We intended to
    filter out the numeric strings and only emit the alphabetic words. But for some
    reason, all emissions were filtered out. If you know anything about regular expressions,
    note that we are only qualifying strings that are entirely uppercase. We actually
    need to qualify lowercase letters too, so here is the correction we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, it is fixed! Our unit test passed finally, and here it is in its entirety.
    Now that the problem is solved and we are finished debugging, we can remove `doOnNext()`
    and any print calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In summary, when you have an `Observable` or `Flowable` operation that is emitting
    an error, the wrong items, or no items at all, start at the source and work your
    way downstream until you find the operator causing the problem. You can also put
    `TestObserver` at each step to get a more comprehensive report of what happened
    in that operation, but using operators such as `doOnNext()`, `doOnError()`, `doOnComplete()`,
    `doOnSubscribe()`, and so on are quick and easy ways to get an insight into what
    is happening in that part of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be optimal that you have to modify code with `doXXX()` operators
    to debug it. If you are using Intellij IDEA, you can try to use breakpoints within
    lambdas, although I have only had mixed success with this approach. You can also
    research RxJava debugging libraries to get detailed logs without modifying your
    code. Hopefully, as RxJava continues to gain traction, more useful debugging tools
    will pop up and become standardized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to test and debug RxJava code. When you create
    an application or an API that is built on RxJava, you may want to build unit tests
    around it in order to ensure that sanity checks are always enforced. You can use
    blocking operators to help perform assertions, but `TestObserver` and `TestSubscriber`
    will give you a much more comprehensive and streamlined testing experience. You
    can also use `TestScheduler` to simulate time elapses so that time-based Observables
    can be tested instantly. Finally, we covered a debugging strategy in RxJava, which
    often involves finding the *broken operator*, starting at the source, and moving
    downstream until it is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter closes our journey covering the RxJava library, so congratulations
    if you got here! You now have a solid foundation of building reactive Java applications.
    In the final two chapters, we will cover RxJava in two specific domains: Android
    and Kotlin.'
  prefs: []
  type: TYPE_NORMAL
