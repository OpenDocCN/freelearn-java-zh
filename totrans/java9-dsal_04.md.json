["```java\npublic int sum_upto(int n){\n  int sum=0;\n  for(int i=0;i<=n;i++){\n    sum+=i;\n  }\n  return sum;\n}\n```", "```java\npublic int sum_upto_functional(int n){\n  return n==0?0:n+sum_upto_functional(n-1);\n}\n```", "```java\npublic long choose(long n, long r){\n  if(n<r){\n    return 0;\n  }else if(r==0){\n    return 1;\n  }else if(n==r){\n    return 1;\n  }else{\n    return choose(n-1,r) + choose(n-1,r-1);\n  }\n}\n```", "```java\n@FunctionalInterface\npublic interface SampleFunctionalInterface {\n  int modify(int x);\n}\n```", "```java\npublic interface AnotherFunctionalInterface{\n  public void doSomething(int x);\n  public String toString();\n}\n```", "```java\n@FunctionalInterface\npublic interface FunctionalInterfaceWithDefaultMethod {\n    int modify(int x);\n    default int modifyTwice(int x){return modify(modify(x));}\n}\n```", "```java\nSampleFunctionalInterface sfi = (x)->x+1;\nint y = sfi.modify(1);\n```", "```java\nThread t = new Thread(()->{for(int i=0;i<500;i++) System.out.println(i);});\n```", "```java\npublic class LinkedList<E> {\n  private E head;\n  private LinkedList<E> tail;\n\n  private LinkedList(){\n\n}\n\n  private LinkedList(E head, LinkedList<E> tail){\n    this.head = head;\n    this.tail = tail;\n  }\n\n  public E head(){\n    return head;\n  }\n  public LinkedList<E> tail(){\n    return tail;\n  }\n```", "```java\n  public LinkedList<E> add(E value){\n    return new LinkedList<E>(value,this);\n  }\n}\n```", "```java\npublic static final class EmptyList<E> extends LinkedList<E>{\n  @Override\n  public E head() {\n    throw new NoValueException(\"head() invoked on empty list\"); \n  }\n\n  @Override\n  public LinkedList<E> tail() { \n    throw new NoValueException(\"tail() invoked on empty list\"); \n  }\n}\n\npublic static <E> LinkedList<E> emptyList(){\n  return new EmptyList<>();\n}\n```", "```java\nLinkedList<Integer> linkedList = LinkedList.<Integer>emptyList()\n.add(5).add(3).add(0);\nwhile(!(linkedList instanceof LinkedList.EmptyList)){\n  System.out.println(linkedList.head());\n  linkedList = linkedList.tail();\n}\n```", "```java\n@FunctionalInterface\npublic interface OneArgumentStatement<E> {\n  void doSomething(E argument);\n}\n```", "```java\npublic class LinkedList<E> {\n…\n\n  public static class EmptyList<E> extends LinkedList<E>{\n  …\n\n  @Override\n  public void forEach(OneArgumentStatement<E> processor) {}\n  }\n\n  …\n\n  public void forEach(OneArgumentStatement<E> processor){\n    processor.doSomething(head());\n    tail().forEach(processor);\n  }\n}\n```", "```java\nlinkedList.forEach((x) -> {System.out.println(x);});\n```", "```java\nlinkedList.forEach(System.out::println);\n```", "```java\nLinkedList<Integer> tranformedList = linkedList.map((x)->x*2);\n```", "```java\npublic class LinkedList<E> {\n…\n  public static class EmptyList<E> extends LinkedList<E>{\n  …\n\n  @Override\n  public <R> LinkedList<R> map(OneArgumentExpression<E, R> transformer) {\n\n  return LinkedList.emptyList();\n  }\n}\n…\n\n  public <R> LinkedList<R> map(OneArgumentExpression<E,R> transformer){\n    return new LinkedList<>(transformer.compute(head()),\n    tail.map(transformer));\n  }\n}\n```", "```java\nLinkedList<Integer> tranformedList = linkedList.map((x)->x*2);\ntranformedList.forEach(System.out::println);\n```", "```java\nLinkedList<String> tranformedListString\n = linkedList.map((x)->\"x*2 = \"+(x*2));\ntranformedListString.forEach(System.out::println);\n```", "```java\n@FunctionalInterface\npublic interface TwoArgumentExpression<A,B,R> {\n  R compute(A lhs, B rhs);\n}\n```", "```java\npublic class LinkedList<E> {\n  …\n  …\n\n  public static class EmptyList<E> extends LinkedList<E>{\n\n    …\n\n    @Override\n    public <R> R foldLeft(R initialValue, TwoArgumentExpression<R, E, R> computer) {\n      return initialValue; \n    }\n  }\n\n  …\n\n  public <R> R foldLeft(R initialValue, TwoArgumentExpression<R,E,R> computer){\n    R newInitialValue = computer.compute(initialValue, head());\n    return tail().foldLeft(newInitialValue, computer);\n  }\n}\n```", "```java\nint sum = linkedList.foldLeft(0,(a,b)->a+b);\nSystem.out.println(sum);\n```", "```java\nLinkedList<Integer> reversedList = linkedList.foldLeft(LinkedList.emptyList(),(l,b)->l.add(b) );\nreversedList.forEach(System.out::println);\n```", "```java\npublic class LinkedList<E> {\n  …\n\n  public static class EmptyList<E> extends LinkedList<E>{\n    …\n\n    @Override\n    public <R> R foldRight(TwoArgumentExpression<E, R, R> computer, R initialValue) {\n      return initialValue;\n    }\n  }\n\n  …\n\n  public <R> R foldRight(TwoArgumentExpression<E,R,R> computer, R initialValue){\n    R computedValue = tail().foldRight(computer, initialValue);\n    return computer.compute(head(), computedValue);\n  }\n}\n```", "```java\nint sum2 = linkedList.foldRight((a,b)->a+b, 0);\nSystem.out.println(sum2);\n```", "```java\nLinkedList<Integer> sameList = linkedList.foldRight((b,l)->l.add(b), LinkedList.emptyList());\nsameList.forEach(System.out::println);\n```", "```java\nprivate static LinkedList<Integer> ofRange(int start, int end, LinkedList<Integer> tailList){\n  if(start>=end){\n    return tailList;\n  }else{\n    return ofRange(start+1, end, tailList).add(start);\n  }\n}\n```", "```java\npublic static LinkedList<Integer> ofRange(int start, int end){\n  return ofRange(start,end, LinkedList.emptyList());\n}\n```", "```java\nLinkedList<Integer> rangeList = LinkedList.ofRange(1,100);\nrangeList.forEach(System.out::println);\n```", "```java\npublic class LinkedList<E> {\n\n  …\n\n    public static class EmptyList<E> extends LinkedList<E>{\n\n    …\n\n    @Override\n    public LinkedList<E> filter(OneArgumentExpression<E, Boolean> selector) {\n      return this;\n    }\n  }\n\n  …\n\n  public LinkedList<E> filter(OneArgumentExpression<E, Boolean> selector){\n    if(selector.compute(head())){\n      return new LinkedList<E>(head(), tail().filter(selector));\n    }else{\n      return tail().filter(selector);\n    }\n  }\n}\n```", "```java\nLinkedList<Integer> evenList = LinkedList.ofRange(1,100).filter((a)->a%2==0);\nevenList.forEach(System.out::println);\n```", "```java\nint sumOfRange = LinkedList.ofRange(1,101).foldLeft(0, (a,b)->a+b);\nSystem.out.println(sumOfRange);\n```", "```java\npublic static BigInteger factorial(int x){\n  return LinkedList.ofRange(1,x+1)\n  .map((a)->BigInteger.valueOf(a))\n  .foldLeft(BigInteger.valueOf(1),(a,b)->a.multiply(b));\n}\n```", "```java\nSystem.out.println(factorial(100));\n```", "```java\npublic static String repeatString(final String seed, int count){\n  return LinkedList.ofRange(1,count+1)\n  .map((a)->seed)\n  .foldLeft(\"\",(a,b)->a+b);\n}\n```", "```java\npublic static String repeatString2(final String seed, int count){\n  return LinkedList.ofRange(1,count+1)\n  .foldLeft(\"\",(a,b)->a+seed);\n}\n```", "```java\npublic LinkedList<E> append(LinkedList<E> rhs){\n  return this.foldRight((x,l)->l.add(x),rhs);\n}\n```", "```java\nLinkedList<Integer> linkedList = \nLinkedList.<Integer>emptyList().add(5).add(3).add(0);\nLinkedList<Integer> linkedList2 =\n LinkedList.<Integer>emptyList().add(6).add(8).add(9);\nlinkedList.append(linkedList2).forEach(System.out::print);\n```", "```java\nLinkedList<Integer> funnyList \n=LinkedList.ofRange(1,10)\n.flatMap((x)->LinkedList.ofRange(0,x));\n```", "```java\nfunnyList.forEach(System.out::print);\n```", "```java\npublic class LinkedList<E> {\n\n  public static class EmptyList<E> extends LinkedList<E>{\n\n    …\n\n    @Override\n    public <R> LinkedList<R> flatMap(OneArgumentExpression<E, LinkedList<R>> transformer) {\n      return LinkedList.emptyList();\n    }\n  }\n\n  …\n\n  public <R> LinkedList<R> flatMap(OneArgumentExpression<E, LinkedList<R>> transformer){\n    return transformer.compute(head())\n    append(tail().flatMap(transformer));\n  }\n}\n```", "```java\npublic abstract class Option<E> {\n  public abstract E get();\n  public abstract <R> Option<R> map(OneArgumentExpression<E,R> transformer);\n  public abstract <R> Option<R> flatMap(OneArgumentExpression<E,Option<R>> transformer);\n  public abstract void forEach(OneArgumentStatement<E> statement);\n\n  …\n}\n```", "```java\npublic static <X> Option<X>  optionOf(X value){\n  if(value == null){\n    return new None<>();\n  }else{\n    return new Some<>(value);\n  }\n}\n```", "```java\npublic static class None<E> extends Option<E>{\n\n  @Override\n  public <R> Option<R> flatMap(OneArgumentExpression<E, Option<R>> transformer) {\n    return new None<>();\n  }\n\n  @Override\n  public E get() {\n    throw new NoValueException(\"get() invoked on None\");\n  }\n\n  @Override\n  public <R> Option<R> map(OneArgumentExpression<E, R> transformer) {\n    return new None<>();\n  }\n\n  @Override\n  public void forEach(OneArgumentStatement<E> statement) {\n  }\n}\n```", "```java\npublic static class Some<E> extends Option<E>{\n  E value;\n  public Some(E value){\n    this.value = value;\n  }\n  public E get(){\n    return value;\n  }\n  …\n}\n```", "```java\npublic static class Some<E> extends Option<E>{\n  …\n\n  public <R> Option<R> map(OneArgumentExpression<E,R> transformer){\n    return Option.optionOf(transformer.compute(value));\n  }\n  public <R> Option<R> flatMap(OneArgumentExpression<E,Option<R>> transformer){\n    return transformer.compute(value);\n  }\n  public void forEach(OneArgumentStatement<E> statement){\n    statement.doSomething(value);\n  }\n}\n```", "```java\npublic class Country {\n  private String name;\n  private String countryCode;\n\n  public Country(String countryCode, String name) {\n    this.countryCode = countryCode;\n    this.name = name;\n  }\n\n  public String getCountryCode() {\n    return countryCode;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\npublic class City {\n  private String name;\n  private Country country;\n\n  public City(Country country, String name) {\n    this.country = country;\n    this.name = name;\n  }\n\n  public Country getCountry() {\n    return country;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n}\npublic class Address {\n  private String street;\n  private City city;\n\n  public Address(City city, String street) {\n    this.city = city;\n    this.street = street;\n  }\n\n  public City getCity() {\n    return city;\n  }\n\n  public String getStreet() {\n    return street;\n  }\n}\npublic class Person {\n  private String name;\n  private Address address;\n\n  public Person(Address address, String name) {\n    this.address = address;\n    this.name = name;\n  }\n\n  public Address getAddress() {\n    return address;\n  }\n\n  public String getName() {\n    return name;\n  }\n}\n```", "```java\nif(person!=null\n && person.getAddress()!=null\n && person.getAddress().getCity()!=null\n && person.getAddress().getCity().getCountry()!=null){\n  System.out.println(person.getAddress().getCity().getCountry());\n}\n```", "```java\nString countryName = Option.optionOf(person)\n.map(Person::getAddress)\n.map(Address::getCity)\n.map(City::getCountry)\n.map(Country::getName).get();\n```", "```java\npublic class Option<E> {\n  public static class None<E> extends Option<E>{\n\n  …\n\n    @Override\n    public void forEach(OneArgumentStatement<E> statement) {\n    }\n  }\n\n…\n\n  public void forEach(OneArgumentStatement<E> statement){\n    statement.doSomething(value);\n  }\n}\n```", "```java\nOption.optionOf(person)\n.map(Person::getAddress)\n.map(Address::getCity)\n.map(City::getCountry)\n.map(Country::getName)\n.forEach(System.out::println);\n```", "```java\npublic class Person {\n  private String name;\n  private Address address;\n\n  public Person(Address address, String name) {\n    this.address = address;\n    this.name = name;\n  }\n\n  public Option<Address> getAddress() {\n    return Option.optionOf(address);\n  }\n\n  public Option<String> getName() {\n    return Option.optionOf(name);\n  }\n}\n```", "```java\nOption.optionOf(person)\n.flatMap(Person::getAddress)\n.flatMap(Address::getCity)\n.flatMap(City::getCountry)\n.flatMap(Country::getName)\n.forEach(System.out::println);\n```", "```java\npublic abstract class Try<E> {\n  public abstract <R> Try<R> map(\nOneArgumentExpressionWithException<E, R> expression);\n\n  public abstract <R> Try<R> flatMap(\nOneArgumentExpression<E, Try<R>> expression);\n\n  public abstract E get();\n\n  public abstract void forEach(\nOneArgumentStatement<E> statement);\n\n  public abstract Try<E> processException(\nOneArgumentStatement<Exception> statement);\n  …\n  public static <E> Try<E> of(\nNoArgumentExpressionWithException<E> expression) {\n    try {\n      return new Success<>(expression.evaluate());\n    } catch (Exception ex) {\n      return new Failure<>(ex);\n    }\n  }\n  …\n}\n```", "```java\n@FunctionalInterface\npublic interface NoArgumentExpressionWithException<R> {\n  R evaluate() throws Exception;\n}\n\n@FunctionalInterface\npublic interface OneArgumentExpressionWithException<A,R> {\n  R compute(A a) throws Exception;\n}\n```", "```java\nprotected static class Success<E> extends Try<E> {\n  protected E value;\n\n  public Success(E value) {\n    this.value = value;\n  }\n```", "```java\n  @Override\n  public <R> Try<R> flatMap(\n    OneArgumentExpression<E, Try<R>> expression) {\n      return expression.compute(value);\n  }\n```", "```java\n  @Override\n  public <R> Try<R> map(\n    OneArgumentExpressionWithException<E, R> expression) {\n    try {\n      return new Success<>(\n        expression.compute(value));\n    } catch (Exception ex) {\n      return new Failure<>(ex); \n    }\n  }\n```", "```java\n  @Override\n  public E get() {\n    return value;\n  }\n```", "```java\n  @Override \n  public void forEach(\n    OneArgumentStatement<E> statement) {\n      statement.doSomething(value);\n  }\n```", "```java\n  @Override\n  public Try<E> processException(\n    OneArgumentStatement<Exception> statement) {\n      return this;\n  }\n}\n```", "```java\nprotected static class Failure<E> extends Try<E> {\n  protected Exception exception;\n\n  public Failure(Exception exception) {\n    this.exception = exception;\n  }\n```", "```java\n  @Override\n  public <R> Try<R> flatMap(\n    OneArgumentExpression<E, Try<R>> expression) {\n      return new Failure<>(exception);\n  }\n\n  @Override\n  public <R> Try<R> map(\n    OneArgumentExpressionWithException<E, R> expression) {\n      return new Failure<>(exception);\n  }\n```", "```java\n  @Override\n  public E get() {\n    throw new NoValueException(\"get method invoked on Failure\");\n  }\n```", "```java\n  @Override\n  public void forEach(\n    OneArgumentStatement<E> statement) {\n    …\n  }\n```", "```java\n  @Override\n  public Try<E> processException(\n    OneArgumentStatement<Exception> statement) {\n      statement.doSomething(exception);\n      return this;\n  }\n}\n```", "```java\nTry.of(() -> new FileInputStream(\"demo\"))\n.map((in)->new InputStreamReader(in))\n.map((in)->new BufferedReader(in))\n.map((in)->in.readLine())\n.processException(System.err::println)\n.forEach(System.out::println);\n```", "```java\nchoose(n,r) = choose(n-1,r) + choose(n-1, r-1)\n```", "```java\n T(n,r) = T(n-1,r) + T(n-1,r-1) + C\n=>T(n,r) -  T(n-1,r) = T(n-1,r-1) + C\n```", "```java\nT(n,r) -  T(n-1,r) = T(n-1,r-1) + C\nT(n-1,r) -  T(n-2,r) = T(n-2,r-1) + C\nT(n-2,r) -  T(n-3,r) = T(n-3,r-1) + C\n…\nT(r+1,r) -  T(r,r) = T(r,r-1) + C\n```", "```java\nT(n,r) = O((n-r)r) = O(nr)\n```"]