<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;jBPM in Production"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. jBPM in Production</h1></div></div></div><p>In the previous chapters, we sailed through the various functional aspects of jBPM and also saw how we can extend and customize jBPM for adding more features. Now, it is production time, and there is a change in the perspective of how the application is viewed by its stakeholders.</p><p>The important question now is not the functional characteristics, but the nonfunctional ones. People think about the stability and resilience of the application and not the flexibility that it gives. People think of how fast and cost-efficiently the application can be scaled so as to provision for more users and how less critical is the latency of a service.</p><p>The mettle of the application is put under fire. jBPM is ready-to-use production software, and in this chapter, we will discuss various facilities available in jBPM to make it fit into the requirements of production software. The chapter is structured on the basis of the major qualities of a system that has to be taken care of in production.</p><p>We will discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to scale</li><li class="listitem" style="list-style-type: disc">How to make applications secure</li><li class="listitem" style="list-style-type: disc">How to meet availability requirements</li><li class="listitem" style="list-style-type: disc">How to incorporate new changes to the system</li><li class="listitem" style="list-style-type: disc">How the system handles errors in runtime</li></ul></div><div class="section" title="Scalability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Scalability</h1></div></div></div><p>Scalability can be described<a id="id925" class="indexterm"/> as the capacity of a system to handle growing volumes of service provisioning in a controlled and cost-efficient manner. In case of a <a id="id926" class="indexterm"/>BPM system, there are two major use cases where the requirement of scaling can arise.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Scaling the modeling facility, that is, the workbench</li><li class="listitem" style="list-style-type: disc">Scaling the process runtime, with which the end customers of the application interact</li></ul></div><p>Scaling an application typically involves two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertical scaling</strong></span>: This is<a id="id927" class="indexterm"/> achieved by adding resources to the server that is providing the service</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Horizontal scaling</strong></span>: This is achieved<a id="id928" class="indexterm"/> by adding multiple servers to provision the same service</li></ul></div><p>Vertical scaling involves less complexity of implementation as it asks for improving the hardware (usually) and configuring the application to use these resources. However, vertical scaling is often limited by the constraints put by cost and technology in building the resources. In the context of jBPM, the resources that can be added are the memory, processor cores, and secondary storage mechanisms. jBPM doesn't provide out-of-the-box functionality to explicitly cater for these resource improvements, but there would be improvements in throughput and performance by taking advantage of the underlying platforms used by the jBPM, such as the application server on which jBPM is deployed and JVM on which the application server resides.</p><p>Within the scope of this book, it is obvious that horizontal scaling would need a better method, and the following sections purely concentrate on horizontally scaling of the jBPM functionality.</p><div class="section" title="Scaling the business process modeling facility"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec139"/>Scaling the business process modeling facility</h2></div></div></div><p>Scaling the<a id="id929" class="indexterm"/> modeling tool points to increasing the<a id="id930" class="indexterm"/> number of users that can perform modeling simultaneously. Users can choose either web tooling or Eclipse tooling for modeling purposes, and there can be scenarios where the modeling users create a single application or multiple applications.</p><p>Given the previous factors and constraints, the most obvious way to increase the throughput of the modeling workbench service is to increase the number of units that provision the service. So, we add servers and jump to face the quintessential problems of clustering. Each server has a separate asset repository, and if the users collaborate to create the same application, we need to keep the assets in the repository sync always.</p><p>The out-of-the-box facility<a id="id931" class="indexterm"/> that jBPM provides as the asset repository is the Git-backed <a id="id932" class="indexterm"/>
<span class="strong"><strong>Virtual File System</strong></span> (<span class="strong"><strong>VFS</strong></span>), and in order to keep the file system in sync, jBPM suggests the use of Apache Helix, a cluster management framework.</p><p>The following diagram visualizes the deployment architecture in this scenario:</p><div class="mediaobject"><img src="graphics/9578OS_09_01.jpg" alt="Scaling the business process modeling facility"/></div><p>Apache Helix acts as a cluster management solution, which registers all servers to the cluster and enables the synchronization of the repositories.</p><p>Helix internally uses Apache ZooKeeper to manage the state of the system and manage the notifications between the nodes.</p><p>The details of configuring VFS clustering are explicitly provided in the jBPM user guide; please refer to it for configuration details.</p><p>Apache Helix <a id="id933" class="indexterm"/>provides a set of functionalities that enable <a id="id934" class="indexterm"/>us to develop a fault-tolerant, scalable distributed system. For more details, see <a class="ulink" href="http://helix.apache.org/Architecture.html">http://helix.apache.org/Architecture.html</a>.</p></div><div class="section" title="Scaling the process runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec140"/>Scaling the process runtime</h2></div></div></div><p>When we talk about scaling any software application, it involves increasing the capacity of the system to<a id="id935" class="indexterm"/> serve an increasing number of user interactions. In BPM-based applications, along with the increase in user interactions, the<a id="id936" class="indexterm"/> complexity and content of the business processes factor in for an increase in the capacity of the system.</p><div class="section" title="Factors and considerations"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec111"/>Factors and considerations</h3></div></div></div><p>The following section <a id="id937" class="indexterm"/>highlights the factors involved in finalizing the deployment architecture of the system and discusses the consideration <a id="id938" class="indexterm"/>made in the jBPM architecture to meet these increasing requirements.</p><div class="section" title="Number of processes/process instances"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec29"/>Number of processes/process instances</h4></div></div></div><p>Yes, this is an obvious factor: the number of process definitions that are part of the application and the<a id="id939" class="indexterm"/> number of process instances created from these process definitions use the system capacity. The process definitions are stored in the asset repository, and we have already discussed this in the <span class="emphasis"><em>Scaling the business process modeling facility</em></span> section, but the increase in process definitions directs to an increase in the number of process instances that have to be managed by the system. The reverse is also possible, that is, a relatively small number of process definitions but a large number of process instances.</p><p>Process instances carry the runtime state of the process execution and by default in memory. However, this is not an option in a real-world scenario where the availability of the runtime state is critical, and so, jBPM provides mechanisms to persist the process instances into a database. In the context of our discussion, we have to note that with an increase in the number of process instances, we have to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Increase the capacity of the database</li><li class="listitem" style="list-style-type: disc">Increase the capacity of the memory</li></ul></div><p>The following diagram shows the schematic deployment architecture where there are multiple jBPM runtime instances having replicated VFS repositories for asset storage and a centralized database<a id="id940" class="indexterm"/> storing the runtime information:</p><div class="mediaobject"><img src="graphics/9578OS_09_02.jpg" alt="Number of processes/process instances"/></div></div><div class="section" title="The number of user interactions"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec30"/>The number of user interactions</h4></div></div></div><p>User interactions with the process runtime are for the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interactions<a id="id941" class="indexterm"/> with the process engine for starting a process (creation of a process instance) or signaling an event to an already started process instance</li><li class="listitem" style="list-style-type: disc">Interaction with the task service for handling the life cycle methods for human tasks</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/>Note</h3><p>One other possibility is the interactions to domain-specific asynchronous workitems, which needs its own capacity planning.</p></div></div><p>Interactions with the process engine are performed through a dedicated KieSession API and come with a specific constraint; that is, interactions with a process instance can only be performed through the Kie session in which the process instance was created. Each interaction needs the instance of the Kie session where it was created, and jBPM provides multiple strategies<a id="id942" class="indexterm"/> for handling the scaling up of process interactions. jBPM allows you to choose the strategy while creating the runtime manager, which is in turn used to access the runtime engine and create sessions for interaction.</p></div><div class="section" title="Flavors of runtime manager"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec31"/>Flavors of runtime manager</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singleton strategy</strong></span>:<p>By choosing this <a id="id943" class="indexterm"/>strategy, we choose to maintain a single instance of the runtime<a id="id944" class="indexterm"/> instance and a single instance of Kie Session for all interactions. This is the easiest strategy and is most favorable for low and medium loads.</p><p>The singleton strategy can be programmatically chosen as follows:</p><div class="informalexample"><pre class="programlisting">RuntimeManagerFactory.Factory.get().newSingletonRuntimeManager(runtimeEnvironment);</pre></div><p>Further, if you are using jBPM console (KIE Workbench), you can configure the <code class="literal">&lt;runtime-strategy&gt;</code> deployment descriptor tag as <code class="literal">SINGLETON</code>. A sample deployment descriptor is shown as follows:</p><div class="informalexample"><pre class="programlisting">&lt;deployment-descriptor xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd" &gt;
  &lt;persistence-unit&gt;org.jbpm.domain&lt;/persistence-unit&gt;
  &lt;audit-persistence-unit&gt;org.jbpm.domain&lt;/audit-persistence-unit&gt;
  &lt;audit-mode&gt;JPA&lt;/audit-mode&gt;
  &lt;persistence-mode&gt;JPA&lt;/persistence-mode&gt;
  &lt;runtime-strategy&gt;SINGLETON&lt;/runtime-strategy&gt;
  &lt;marshalling-strategies/&gt;
  &lt;event-listeners/&gt;
  &lt;task-event-listeners/&gt;
  &lt;globals/&gt;
  &lt;work-item-handlers/&gt;
  &lt;environment-entries/&gt;
  &lt;configurations/&gt;
  &lt;required-roles/&gt;
&lt;/deployment-descriptor&gt;</pre></div><p>
<code class="literal">SINGLETON</code> is the default strategy in the jBPM console.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note64"/>Note</h3><p>We can <a id="id945" class="indexterm"/>override the default deployment descriptor by using a Java option during the start of the server as follows: <code class="literal">Dorg.kie.deployment.desc.location=file:/application/configuration/deployment-descriptor.xml</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Per request strategy</strong></span>:<p>A new<a id="id946" class="indexterm"/> instance of runtime manager is provided, and the session is created and maintained for the request scope.</p><p>This strategy<a id="id947" class="indexterm"/> is stateless and ideal for horizontally scaling the jBPM process runtime instances, but the functionality in the process is limited to stateless facts, with no user interactions allowed other than the start process.</p><p>We can choose the per request strategy programmatically during the creation of runtime by the following code:</p><div class="informalexample"><pre class="programlisting">RuntimeManagerFactory.Factory.get().newPerRequestRuntimeManager(runtimeEnvironment);</pre></div><p>Further, for jBPM console, the deployment descriptor can be customized as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;deployment-descriptor xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd" &gt;
  &lt;runtime-strategy&gt;PER_REQUEST&lt;/runtime-strategy&gt;
&lt;/deployment-descriptor&gt;</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Per process instance strategy</strong></span>:<p>It is the most advanced strategy taking into consideration the tradeoff between the scalability of the system and the overhead it put. As the name indicates, ksession sticks to the process instance and lives as long as the process instance is alive. It does not have the scalability constraints in the <a id="id948" class="indexterm"/>singleton strategy, and although it has a high overhead, it doesn't have the overhead limitations and is not scalable as the per request strategy. Thus, the per process instance strategy is placed in<a id="id949" class="indexterm"/> the middle of the above two and is used in most of the cases where jBPM is used.</p><p>We can choose the per process instance strategy programmatically during the creation of runtime by the following line of code:</p><div class="informalexample"><pre class="programlisting">RuntimeManagerFactory.Factory.get().newPerProcessInstanceRuntimeManager(runtimeEnvironment);</pre></div><p>Further, for the jBPM console, the deployment descriptor is customized as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;deployment-descriptor xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd" &gt;
  &lt;runtime-strategy&gt;PER_PROCESS_INSTANCE&lt;/runtime-strategy&gt;
&lt;/deployment-descriptor&gt;</pre></div></li></ul></div></div><div class="section" title="Task service"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec32"/>Task service</h4></div></div></div><p>Task service is the dedicated component for managing human task services. The interactions with<a id="id950" class="indexterm"/> an application can be performed through the human tasks. jBPM provides a default implementation for the human task service, which is based on the WS-Human Task specification. The task service clients are light and go hand-in-hand with strategies that we have chosen for the runtime manager, and all the clients share the same database; therefore, scaling up of human tasks is in sync with the strategy chosen for the runtime manager and with the increase in the capacity <a id="id951" class="indexterm"/>of the database storage.</p></div><div class="section" title="Number of timer events"><div class="titlepage"><div><div><h4 class="title"><a id="ch09lvl4sec33"/>Number of timer events</h4></div></div></div><p>The functionality of timer events is achieved using the scheduler service. Multiple implementations of the scheduler service are provided by jBPM. The Quartz scheduler-based implementation is a fit in for a production environment. The Quartz scheduler supports the clustering mode, which provides both high availability and scalability, which works by maintaining the<a id="id952" class="indexterm"/> data or state of the schedules (or jobs) that it handles in a shared database between nodes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>Quartz is an<a id="id953" class="indexterm"/> open source job scheduling library that can be integrated within a Java application. Quartz can be used to create scheduled tasks and provide support for JTA transactions and clustering. For more details, see <a class="ulink" href="http://quartz-scheduler.org/">http://quartz-scheduler.org/</a>.</p></div></div><p>The Quartz scheduler can be enabled by providing the absolute path of the <code class="literal">quartz</code> definition file against the <code class="literal">org.quartz.properties </code>system property.</p><p>A sample <code class="literal">quartz</code> definition file is given as follows that is configured for use along with a PostgreSQL database.</p><div class="informalexample"><pre class="programlisting">#============================================================================
# Configure Main Scheduler Properties
#============================================================================

org.quartz.scheduler.instanceName = jBPMClusteredScheduler
org.quartz.scheduler.instanceId = AUTO

#============================================================================
# Configure ThreadPool
#============================================================================

org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================

org.quartz.jobStore.misfireThreshold = 60000

org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreCMT
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate
org.quartz.jobStore.useProperties=false
org.quartz.jobStore.dataSource=managedDS
org.quartz.jobStore.nonManagedTXDataSource=notManagedDS
org.quartz.jobStore.tablePrefix=QRTZ_
org.quartz.jobStore.isClustered=true
org.quartz.jobStore.clusterCheckinInterval = 20000
#============================================================================
# Configure Datasources
#============================================================================
org.quartz.dataSource.managedDS.jndiURL=jboss/datasources/psjbpmDS
org.quartz.dataSource.notManagedDS.jndiURL=jboss/datasources/quartzNotManagedDS</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>When <a id="id954" class="indexterm"/>using the Quartz scheduler, as a prerequisite, we would have to create the database schemas that are used by Quartz to persist its job data. The database scripts provided with the Quartz distribution (jBPM uses Quartz 1.8.5. DB scripts) are usually located under <code class="literal">QUARTZ_HOME/docs/dbTables</code>.</p></div></div><p>The scheduler service can be configured programmatically by configuring <code class="literal">GlobalSchedulerService</code> in the runtime environment:</p><div class="informalexample"><pre class="programlisting">RuntimeEnvironmentBuilder.Factory.get()
  .newDefaultBuilder().entityManagerFactory(emf)
  .knowledgeBase(kbase).schedulerService(globalSchedulerService);</pre></div><p>Here, the <code class="literal">globalSchedulerService</code> object is an implementation of <code class="literal">org.jbpm.process.core.timer.GlobalSchedulerService</code> and the Quartz implementation<a id="id955" class="indexterm"/> is <code class="literal">org.jbpm.process.core.timer.impl.QuartzSchedulerService</code>.</p></div></div></div></div></div>
<div class="section" title="Availability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Availability</h1></div></div></div><p>The availability of an<a id="id956" class="indexterm"/> application or system can be viewed as the total amount of time that it provides its services against the total time it is expected to do so. System availability is <a id="id957" class="indexterm"/>affected by multiple factors ranging from failure of the system due to hardware/software failures and the known downtime for maintenance and upgrades.</p><p>High availability is achieved in applications by having failover mechanisms using which the system can get back to its service provisioning state after a failure. A more optimized system would consider backup mechanisms, which it can immediately switch on to in a failure scenario, thus improving the availability. Scheduled maintenance can be done using a rolling upgrade to ensure high availability. The solutions are usually depicted in the form of deployment architecture, vary according to the software solution, and consider the trade-offs in non-functional requirements.</p><p>The following figure depicts the sample deployment architecture that can be applied to the jBPM workbench and runtime, which can cater to high-availability and high-throughput scenarios. The architecture considers a failover mechanism by having a persistent, distributed storage for all data and a load balancer with a passive backup to ensure the switching of nodes upon a partial failure (node failure). jBPM doesn't provide all the components needed in this deployment architecture but has to get third-party software and integrated. We discuss the applicability of these components in the subsequent sections.</p><div class="mediaobject"><img src="graphics/9578OS_09_03.jpg" alt="Availability"/></div><div class="section" title="Applicability to workbench"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec141"/>Applicability to workbench</h2></div></div></div><p>Thinking about the availability of the workspace, we need to consider the following two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Availability of the web-based user interface for modeling</li><li class="listitem" style="list-style-type: disc">Availability of the stores where the assets are created during the modeling</li></ul></div><p>The service<a id="id958" class="indexterm"/> providing the web-based user interface is hosted on an application server, and the availability means availability provisions provided by the application server. Usually, the provisions are in the form of load balancer-based failover mechanisms, where the load balancer switches the traffic to another node when the node providing the service fails, and the failover mechanism ensures that the node will be back live within a certain timespan to provide the full potential throughput.</p><p>Assets are<a id="id959" class="indexterm"/> stored in a virtual file system, and by default, it is a Git-based repository. As we have discussed in the <span class="emphasis"><em>Scaling the business process modeling facility</em></span> section, the Git-based repository can be clustered and the assets synchronized. So, even if one node fails, the latest assets will be restored from the other nodes.</p></div><div class="section" title="Applicability to continuous improvements in processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec142"/>Applicability to continuous improvements in processes</h2></div></div></div><p>From the perspective of the applications developed using the modeling facility, there can be continuous improvements in the application processes. The new version of a process can be deployed to<a id="id960" class="indexterm"/> the jBPM runtime in two ways.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new version of the process can be deployed as a new process definition, and the old one can be retired by removing it from the knowledge repository so that no new instance of this process version is deployed. However, this approach absolutely doesn't handle the existing process instances. Either they should be allowed to continue with the earlier versions or they should be aborted and reprocessed. The decisions on choosing the approach should be handled case-by-case on the basis of the business scenario that these process definitions are handling.</li><li class="listitem" style="list-style-type: disc">Using the process migration facility provided by jBPM. However, the facility is limited to process changes that are non-conflicting.</li></ul></div><p>Thus, process upgrades are not a very smooth process and require careful handling. Further, to achieve availability, either the upgrades have to be done during low-traffic periods or we have to do a rolling upgrade.</p></div><div class="section" title="Applicability to the process runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec143"/>Applicability to the process runtime</h2></div></div></div><p>Availability of the process runtime<a id="id961" class="indexterm"/> involves the availability of services to interact with process instances such as process instance life cycles and user<a id="id962" class="indexterm"/> interactions. Similar to what we discussed about the workbench facility, there are two things we need to consider:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Availability of the process instance interactions</li><li class="listitem" style="list-style-type: disc">Availability of the process instance data</li></ul></div><p>For the availability of the process instance interactions, we need to have a load balancing mechanism that can switch over the traffic of one node to another upon a failure. Further, we need to be able to<a id="id963" class="indexterm"/> persist the process instance data in a nonvolatile storage for a failover. As <a id="id964" class="indexterm"/>discussed in the <span class="emphasis"><em>Scaling the process runtime</em></span> section, jBPM supports the persistence of runtime information in relational databases.</p><p>Most of the popular relational databases have inbuilt support for availability using clustered storage. This can be utilized to make sure that the persisted process instance data can be made highly available.</p></div></div>
<div class="section" title="Security"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Security</h1></div></div></div><p>Security or<a id="id965" class="indexterm"/> application security in this context refers to protecting the services and data provided by jBPM from unauthorized access (authentication) and at the same time ensuring that the users can access the set of services and data authorized for them (authorization).</p><p>Another important perspective<a id="id966" class="indexterm"/> that we have to consider in a BPM system is providing non-repudiation for all the user interactions. jBPM supports this by providing an audit logging facility for all runtime data changes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>Non-repudiation assures that a user cannot deny performing an action or operation in the system.</p></div></div><div class="section" title="Securing the access of application assets"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec144"/>Securing the access of application assets</h2></div></div></div><p>jBPM, usually deployed in an<a id="id967" class="indexterm"/> application server, uses a JEE-compatible standard, that is, <span class="strong"><strong>Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong>JAAS</strong></span>), for <a id="id968" class="indexterm"/>providing application security. The application server provides this service and a mechanism to register the users.</p><p>The default asset repository used to keep the application assets is the Git repository. Further, a Git repository ensures that a change to a repository handled by it (be it an addition of a file or a change of the file) is only allowed for an authorized person.</p><p>Authentication is done for the users logging in through the workbench, and for making changes to the repository through Eclipse, the users have to use SSH.</p><p>The workbench user management supports the following roles:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Admin</strong></span>: The role that<a id="id969" class="indexterm"/> has full access rights. The user who plays the<a id="id970" class="indexterm"/> role of admin manages the BPMS.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Analyst</strong></span>: The role that can do<a id="id971" class="indexterm"/> the modeling and is associated with a business analyst for creating processes, rules, entities, forms, and so on.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Developer</strong></span>: The role that carries the baton of the process artifacts from the business analyst and develops<a id="id972" class="indexterm"/> fully executable code with back-end services and handlers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Business user</strong></span>: The role that <a id="id973" class="indexterm"/>performs operation management by using task management features. The person assigned to this role is the end user of the application, who avails the functionality provided by the application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View only user</strong></span>: The role that can <a id="id974" class="indexterm"/>view the statistics of processes and their performance and is the primary user of the statistics dashboard.</li></ul></div><p>Taking the example of jBPM<a id="id975" class="indexterm"/> installed in the JBoss application server (now renamed to WildFly), it provides utilities such as <code class="literal">add-user</code> to add the users and assign their roles.</p></div><div class="section" title="Securing the process runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec145"/>Securing the process runtime</h2></div></div></div><p>The following subsections details the provisions for securing the process runtime, that is, securing the operation management specific operations.</p><div class="section" title="Access security specific to human tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec112"/>Access security specific to human tasks</h3></div></div></div><p>The workbench<a id="id976" class="indexterm"/> allows only authorized people to access the process runtime capabilities as discussed in the previous section. Apart from the process management<a id="id977" class="indexterm"/> access, inside each process definition, each human task is assigned to a user or a role (group).</p><p>In an environment using the whole jBPM suite of software, including the process modeler, we can drive this by adding more roles or groups to the system by using the application server capabilities. In an embedded mode, jBPM provides an extension point for implementing an application-specific access security mechanism.</p><p>This extension can be done by implementing the <code class="literal">org.kie.api.task.UserGroupCallback</code> interface and embedding the application-specific logic for validating the authorization of the users to perform tasks. The specific method that we need to implement for attaining this integration is as follows:</p><div class="informalexample"><pre class="programlisting">boolean existsUser(String userId)</pre></div><p>This interface method is used for determining whether the user attached to a task is valid. For integrating with our application, we can implement this method by using the logic or service used<a id="id978" class="indexterm"/> for authentication.</p><div class="informalexample"><pre class="programlisting">boolean existsGroup(String groupId)</pre></div><p>This interface method is used for resolving whether the group or role attached to a task is valid.</p><div class="informalexample"><pre class="programlisting">List&lt;String&gt; getGroupsForUser(String userId,List&lt;String&gt; groupIds, List&lt;String&gt; allExistingGroupIds)</pre></div><p>This is used for resolving the groups (or roles) that are valid for a user.</p><p>The <code class="literal">userGroupCallback</code> interface implementation can be attached to the process runtime by using the <code class="literal">HumanTaskService</code> factory. The code snippet for doing this is as follows:</p><div class="informalexample"><pre class="programlisting">UserGroupCallBack userGroupCallBack= new CustomUserGroupCallback();
TaskService taskService = HumanTaskServiceFactory.newTaskServiceConfigurator().entityManagerFactory(emf).userGroupCallback(userGroupCallBack).getTaskService();</pre></div><p>The advantage of this mechanism is that we are not constrained to the user management functionality provided by jBPM but can develop our own. Further, jBPM provides a set of pre-build <code class="literal">userGroupCallBack</code> functions that can be used in production:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">org.jbpm.services.task.identity.LDAPUserGroupCallbackImpl</code>, as the name indicates, can be used for configuring it with your LDAP service.</li><li class="listitem" style="list-style-type: disc"><code class="literal">org.jbpm.services.task.identity.JAASUserGroupCallbackImpl</code>, as the name indicates, can be used for configuring it with your JAAS standard-specific user authentication mechanisms widely used in application server environments. jBPM provides adapters for Oracle WebLogic, IBM WebSphere, and JBoss application servers.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note68"/>Note</h3><p>LDAP (which stands for Lightweight Directory Access Protocol) is an open standard, widely used in small and medium organizations to share user information between services and systems.</p></div></div></div><div class="section" title="Audit logging"><div class="titlepage"><div><div><h3 class="title"><a id="ch09lvl3sec113"/>Audit logging</h3></div></div></div><p>In business domains using a BPM, the process defines the business itself. Using these processes, multiple <a id="id979" class="indexterm"/>systems and people in the organization interact with one another. In any organization, disputes regarding actions done by people or systems that drive these processes are common. From the perspective of application security, these scenarios are solved using non-repudiation mechanisms, which assure that no user or system can deny these actions. Audit<a id="id980" class="indexterm"/> logging is one of the widely used non-repudiation mechanisms, in which every action performed on the system is stored and is later used for resolving a dispute or analyzing the root cause of the dispute. Another advantage is that we can use this data to analyze and find out the performance and quality indicators of the business processes.</p><p>An audit log helps us to retrieve information about what happened to a process instance, when it happened, and who triggered it.</p><p>jBPM provides a generic audit logging mechanism that comprehensively covers the life cycle of a business process. The audit log is stored as three data models:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process instance log</strong></span>: Stores the data <a id="id981" class="indexterm"/>corresponding to interactions with the process instance life cycle, for example, starting of a process instance, stopping of a process instance, or aborting a process instance. Using the attributes of the instance log, we can trace back the process definition, process version, process instance, user identity, and so on, which are associated with a life cycle change.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Node instance log</strong></span>: Stores the<a id="id982" class="indexterm"/> data corresponding to the life cycle of a node in the process. A node refers usually to an activity in the business process. The attributes of this data help us to trace back to the process definition, process version, process instance, user identity, time, and workitem on which this incident occurred.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Variable instance log</strong></span>: Stores the data corresponding to the changes in process variables in a process instance.</li></ul></div><p>The following<a id="id983" class="indexterm"/> table lists the data available in the audit log data model:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th colspan="3" style="text-align: center" valign="bottom">
<p>Process instance log</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Field</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Type</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Identity of the log table</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Duration</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Lifetime <a id="id984" class="indexterm"/>of the process instance when the incident occurred</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>End date</p>
</td><td style="text-align: left" valign="top">
<p>DATETIME</p>
</td><td style="text-align: left" valign="top">
<p>Represents the time when the process instance ended, applicable only if the process instance is stopped or aborted</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>External ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>An external ID provided for the identification of a process instance from the domain data</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>User identity</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identity of the user who initiated the process instance.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Outcome</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Outcome of the process information, primarily used to store information such as error code, in case the process stops due to an error event</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Parent process instance ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>The identifier of the parent process instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier <a id="id985" class="indexterm"/>of the process definition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process instance ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Unique identifier of the process instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process name</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Name of the process definition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process version</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Version of the process definition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Start date</p>
</td><td style="text-align: left" valign="top">
<p>DATETIME</p>
</td><td style="text-align: left" valign="top">
<p>Date on which the process instance was started</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Status</p>
</td><td style="text-align: left" valign="top">
<p>INT(11)</p>
</td><td style="text-align: left" valign="top">
<div class="mediaobject"><img src="graphics/B02011_09_Table.jpg" alt="Audit logging"/></div>
<p>The preceding table provides the possible values of this field and what they mean</p>
</td></tr><tr><td colspan="3" style="text-align: center" valign="top">
<p>
<span class="strong"><strong>Node instance log</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Field</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Type</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Unique identifier</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Connection</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier <a id="id986" class="indexterm"/>of the sequence flow that led to this node instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Log date</p>
</td><td style="text-align: left" valign="top">
<p>DATETIME</p>
</td><td style="text-align: left" valign="top">
<p>Date at<a id="id987" class="indexterm"/> which the node was triggered</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>External ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>External identifier associated with the process instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Node instance ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier of the node instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Node name</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Name of the node from the process definition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Node type</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>The type of node or activity, for example, service task</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier of the process definition that this node is a part of</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process Instance ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier of the process instance that this node is a part of</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Type</p>
</td><td style="text-align: left" valign="top">
<p>INT(11)</p>
</td><td style="text-align: left" valign="top">
<p>Indicates whether the log was updated on entry or exit</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Workitem ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier of the workitem that this node refers to</p>
</td></tr><tr><td colspan="3" style="text-align: center" valign="top">
<p>
<span class="strong"><strong>Variable instance log</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Field</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Type</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Description</strong></span>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Unique identifier</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Log date</p>
</td><td style="text-align: left" valign="top">
<p>DATETIME</p>
</td><td style="text-align: left" valign="top">
<p>Time at which the change in this variable occurred</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>External ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>External identifier associated with the process instance</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Old value</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Previous<a id="id988" class="indexterm"/> value of the variable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Process ID of the definition</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Process instance ID</p>
</td><td style="text-align: left" valign="top">
<p>BIGINT(20)</p>
</td><td style="text-align: left" valign="top">
<p>Process instance identifier</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Value</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Current value of the variable</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Variable ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Identifier, variable name</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Variable instance ID</p>
</td><td style="text-align: left" valign="top">
<p>VARCHAR(255)</p>
</td><td style="text-align: left" valign="top">
<p>Additional information when a variable is defined on the composite node level to distinguish between top-level and embedded-level variables</p>
</td></tr></tbody></table></div><p>Apart from its use for security, this log information can be analyzed to find out various performance indicators of the process and the organization. The dashboard builder can be used to build reports from these logs.</p></div></div></div>
<div class="section" title="Maintainability"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Maintainability</h1></div></div></div><p>The maintainability of a system<a id="id989" class="indexterm"/> can be considered to be a measure to determine how easily the repair<a id="id990" class="indexterm"/> actions can be performed. When we say repair, we need to discuss the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The ease of fixing issues in a deployed system (if any)</li><li class="listitem" style="list-style-type: disc">Improvements in the system to match the changing business needs</li><li class="listitem" style="list-style-type: disc">Coping with infrastructure changes in the deployment environment</li></ul></div><p>In the system of our consideration, a BPM, changes in business logic are more frequent. So, one of the main factors from a maintainability perspective is the ease of improving the process executable. This is one area that jBPM excels in; as we have already discussed in earlier chapters, jBPM provides a full-fledged modeling, simulation, and deployment tooling environment. The actors, from this perspective, business analysts and developers, can use the tooling to model, simulate, test, and deploy the process changes.</p><p>Another aspect is the infrastructure or the environment in which jBPM is deployed and maintained in production. jBPM supports multiple deployment architectures as discussed in <a class="link" href="ch08.html" title="Chapter 8. Integrating jBPM with Enterprise Architecture">Chapter 8</a>, <span class="emphasis"><em>Integrating jBPM with Enterprise Architecture</em></span>, and by default, it focuses on deployment in a JEE environment, where it is deployed inside a JEE application container, with persistent data storage in a conventional relational database.</p><p>The architecture of the system is based on the following standards:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modeling based on BPMN</li><li class="listitem" style="list-style-type: disc">Simulation based on BPsim</li><li class="listitem" style="list-style-type: disc">Human tasks based on WS-HT</li><li class="listitem" style="list-style-type: disc">Persistence based on JPA</li><li class="listitem" style="list-style-type: disc">Transaction management based on JTA</li></ul></div><p>The advantage is that jBPM easily fits into our current production environment, and as the environment evolves, so does jBPM with its development community playing an active role in enterprise middleware architecture. Compliance to the standards and modularity of the<a id="id991" class="indexterm"/> system ensures that our client doesn't fall into a vendor lock-in scenario, with parts of the system being easily replaceable.</p><p>In the previous chapters, we have already explained the "how" of the functionalities discussed in this section.</p></div>
<div class="section" title="Fault tolerance"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Fault tolerance</h1></div></div></div><p>Fault tolerance indicates<a id="id992" class="indexterm"/> the ability to operate in a predictive manner, when one or more failures happen in the system. In Java-based applications, these faults are<a id="id993" class="indexterm"/> managed using exception handling mechanisms. jBPM is no exception; it uses the exception handling approach to be fault-tolerant.</p><div class="section" title="Exception handling in process definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec146"/>Exception handling in process definitions</h2></div></div></div><p>We can<a id="id994" class="indexterm"/> specify the occurrence and the handling mechanisms that happen in a business process using BPMN elements, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Error events can be used to specify the occurrence of an unexpected situation. Compared to Java programming, this is similar to throwing an error.</li><li class="listitem" style="list-style-type: disc">Compensation can be used to specify what to do when an error has occurred; this is similar to the catch operation construct in a Java program.</li></ul></div><p>The advantage of <a id="id995" class="indexterm"/>using exception handling at a process level is that the exception scenarios are visible in the process, thus making the monitoring and analysis of these scenarios easier, thereby contributing to continuous improvements of the process.</p></div><div class="section" title="Exception handling for domain-specific processes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec147"/>Exception handling for domain-specific processes</h2></div></div></div><p>When we define new custom workitem handlers that form custom, business-specific activities in a process, we can specify mechanisms to handle exception scenarios. jBPM by default provides the<a id="id996" class="indexterm"/> following decorators for handling an exception scenario in an activity:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SignallingTaskHandlerDecorator</code>: This decorator catches an exception during the life cycle methods of an activity and signals the process instance using a configurable event. These events can be caught in the process definition, and subsequent actions can be taken. This decorator can be specified while registering the workitem handler to a session.<p>For example:</p><div class="informalexample"><pre class="programlisting">String eventType = "Mail-Service-failed";
SignallingTaskHandlerDecorator signallingTaskWrapper = new SignallingTaskHandlerDecorator
(MailServiceHandler.class, eventType); signallingTaskWrapper.setWorkItemExceptionParameterName
(ExceptionService.exceptionParameterName);
ksession.getWorkItemManager().registerWorkItemHandler
("Mail Task", signallingTaskWrapper);</pre></div><p>In this example, we register a handler for sending mails by using <code class="literal">MailServiceHandler.class</code>, and during exception scenarios, the <code class="literal">"Mail-Service-Failed"</code> event is signaled to the process instance.</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">LoggingTaskHandlerDcorator</code>: This decorator catches the exceptions during the life cycle methods of the activity of the logging mechanism. This feature can be used in less critical areas where a process exception can just be a warning in the log.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Summary</h1></div></div></div><p>In this chapter, we discussed the non-functional characteristics of jBPM that are critical in building a production-ready application based on BPM. Further, we discussed sample deployment architectures that are possible with jBPM to meet various requirements and configurations, and customization available to include certain characteristics in the jBPM system.</p></div></body></html>