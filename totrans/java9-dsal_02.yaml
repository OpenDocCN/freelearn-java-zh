- en: Chapter 2. Cogs and Pulleys – Building Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed algorithms in the previous chapter, but the title of the book
    also includes the term "data structure." So what is a data structure? A data structure
    is an organization of data in memory that is generally optimized so it can be
    used by a particular algorithm. We have seen that an algorithm is a list of steps
    that leads to a desired outcome. In the case of a program, there is always some
    input and output. Both input and output contain data and hence must be organized
    in some way or another. Therefore, the input and output of an algorithm are data
    structures. In fact, all the intermediate states that an algorithm has to go through
    must also be stored in some form of a data structure. Data structures don''t have
    any use without algorithms to manipulate them, and algorithms cannot work without
    data structures. It''s because this is how they get input and emit output or store
    their intermediate states. There are a lot of ways in which data can be organized.
    Simpler data structures are also different types of variables. For example, `int`
    is a data structure that stores one 4-byte integer value. We can even have classes
    that store a set of specific types of values. However, we also need to think about
    how to store a collection of a large number of the same type of values. In this
    book, we will spend the rest of the time discussing a collection of values of
    the same type because how we store a collection determines which algorithm can
    work on them. Some of the most common ways of storing a collection of values have
    their own names; we will discuss them in this chapter. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the basic building blocks that we will use to build more complex data
    structures. Even if we don't use them directly, we will use their concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a Java programmer, you must have worked with arrays. Arrays are the
    basic storage mechanisms available for a sequence of data. The best thing about
    arrays is that the elements of an array are collocated sequentially and can be
    accessed completely and randomly with single instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traversal of an array element by an element is very simple. Since any element
    can be accessed randomly, you just keep incrementing an index and keep accessing
    the element at this index. The following code shows both traversal and random
    access in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Insertion of elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the elements in an array are stored in contiguous memory. This makes it
    possible to access any element in a constant amount of time. A program simply
    needs to compute the offset that corresponds to an index, and it reads the information
    directly. But this means they are also limited and have a fixed size. If you want
    to insert a new element into an array, you will need to create a new array with
    one more element and copy the entire data from the original data along with the
    new value. To avoid all this complexity, we will start with moving an existing
    element to a new position. What we are looking to do is to take an element out,
    shift all the elements up to the target position to make space in this position,
    and insert the value we extracted in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion of elements in an array](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: Insertion of an existing array element into a new location'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure explains what we mean by this operation. The thin black
    arrows show the movement of the element that is being reinserted, and the thick
    white arrow shows the shift of the elements of the array. In each case, the bottom
    figure shows the array after the reinsertion is done. Notice that the shifting
    is done either to the left or right, depending on what the start and end index
    are. Let''s put this in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What would be the running time complexity of the preceding algorithm? For all
    our cases, we will only consider the worst case. When does an algorithm perform
    worst? To understand this, let''s see what the most frequent operation in an algorithm
    is. It is of course the shift that happens in the loop. The number of shifts become
    maximum when `startIndex` is at the beginning of the array and `targetIndex` at
    the end or vice versa. This is when all but one element has to be shifted one
    by one. The running time in this case must be some constant times the number of
    elements of the array plus some other constant to account for the non-repeating
    operations. So it is *T(n) = K(n-1)+C* for some constants *K* and *C*, where *n*
    is the number of elements in the array and *T(n)* is the running time of the algorithm.
    This can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = K(n-1)+C = Kn + (C-K)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps explain the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: As per rule 1 of the definition of **big O**, *T(n) = O(Kn + (C-K))*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per rule 3, *T(n) = O(Kn)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We know *|-(C-K)| < |Kn + (C-K)|* is true for sufficiently large *n*. Therefore,
    as per rule 3, since *T(n) = O(Kn + (C-K))*, it means *T(n) = O(Kn + (C-K) + (-(C-K)))*,
    that is, *T(n) = O(Kn)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And, finally, as per rule 2, *T(n) = O(n)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now since the array is the major input in the algorithm, the size of the input
    is represented by *n*. So we will say, the running time of the algorithm is *O(n)*,
    where *n* is the size of the input.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion of a new element and the process of appending it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we move on to the process of insertion of a new element. Since arrays are
    fixed in size, insertion requires us to create a new array and copy all the earlier
    elements into it. The following figure explains the idea of an insertion made
    in a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion of a new element and the process of appending it](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Insertion of a new element into an array'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you copy all the elements before the targeted position as they are in
    the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the new value must be put in the correct position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the end, copy the rest of the elements in the array by shifting their position
    by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have the code ready, appending it would mean just inserting it at the
    end, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What is the running time complexity of the preceding algorithm? Well, no matter
    what we do, we must copy all the elements of the original array to the new array,
    and this is the operation in the loop. So the running time is *T(n) = Kn + C*
    for some constants *K* and *C*, and *n* is the size of the array, which is the
    size of the input. I leave it to you to verify the steps in order to figure out
    this: *T(n) = O(n)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays are great for storing data. We have also seen that any element of an
    array can be read in *O(1)* time. But arrays are fixed in size. Changing the size
    of an array means creating a new array and copying all the elements to the original
    array. The simplest recourse to the resizing problem is to store each element
    in a different object and then hold a reference in each element to the next element.
    This way, the process of adding a new element will just involve creating the element
    and attaching it at the end of the last element of the original linked list. In
    another variation, the new element can be added to the beginning of the existing
    linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linked list](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: An example of a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3* shows an example of a linked list. The arrows represent a reference.
    Each element is stored in a **wrapper object** that also holds a reference to
    the next element wrapper. There are two additional references to the first and
    last elements, which are required for any operation to start. The last reference
    is optional, but it improves the performance of appending to the end vastly, as
    we shall see.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the discussion, let''s create a linked list node in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create a `Node` class inside the `LinkedList` class, which will act
    as a wrapper for the elements and also hold the reference to the next node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must have references for the first and last elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a method called `getNewNode()` that creates a new empty
    node. We will need this if we want to use a different class for a node in any
    of the subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the unfinished class `LinkedList` will not be able to store any
    element; let's see how to do this, though. Notice that we have implemented the
    `Iterable` interface. This will allow us to loop through all the elements in an
    advanced for loop.
  prefs: []
  type: TYPE_NORMAL
- en: Appending at the end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Appending at the end is achieved by simply creating a link from the last element
    of the original linked list to the new element that is being appended and then
    reassigning the reference to the last element. The second step is required because
    the new element is the new last element. This is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending at the end](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Appending at the end of a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a small difference when you append an element to a linked list that
    is empty to start with. At this point, the first and last references are null,
    and this case must be handled separately. The following figure explains this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending at the end](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Appending to an empty linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will achieve this by using the following simple code as is. We return the
    node that has just been added. This is helpful to any class that is extending
    this class. We will do the same in all cases, and we will see the use of this
    while discussing doubly linked lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We try to update the reference of the current last node only if the list is
    not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must update the last reference as the new element is not going to
    be the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the list is empty, the new element must also be the first new element
    and we must update the first reference accordingly, as shown in the preceding
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we also keep track of the current length of the list. This is not
    essential, but if we do this, we do not have to traverse the entire list just
    to count how many elements are in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, of course, there is this important question: what is the time complexity
    of appending to a linked list? Well, if we do it the way we have done it before—that
    is, by having a special reference to the last element—we don''t need any loop,
    as we can see in the code. If the program does not have any loops, all operations
    would be one-time operations, hence everything is completed in constant time.
    You can verify that a constant function has this complexity: *O(1)*. Compare this
    with what was appended at the end of an array. It required the creation of a new
    array and also had *O(n)* complexity, where *n* was the size of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: Insertion at the beginning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inserting an element at the beginning of a list is very similar to appending
    it at the end. The only difference is that you need to update the first reference
    instead of the last reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Insertion at an arbitrary position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Insertion at an arbitrary position can be achieved in the same way we perform
    an insertion in the first element, except that we update the reference of the
    previous element instead of the first reference. There is, however, a catch; we
    need to find the position where we need to insert the element. There is no way
    to find it other than to start at the beginning and walk all the way to the correct
    position while counting each node we step on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion at an arbitrary position](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Insertion of an arbitrary element into a linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement the idea as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we take care of the special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, we walk all the way to the desired position while counting
    the nodes, or in this case, counting the index in the opposite direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we update the references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What is the complexity of this algorithm? There is a loop that must run as many
    times as the index. This algorithm seems to have a running time that is dependent
    on the value of the input and not just its size. In this case, we are only interested
    in the worst case. What is the worst case then? It is when we need to step on
    all the elements of the list, that is, when we have to insert the element at the
    end of the list, except for the last element. In this case, we must step on *n-1*
    elements to get there and do some constant work. The number of steps would then
    be *T(n) = C(n-1)+K* for some constants *C* and *K*. So, *T(n) = O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Looking up an arbitrary element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding the value of an arbitrary element has two different cases. For the first
    and last element, it is simple. Since we have direct references to the first and
    last element, we just have to traverse that reference and read the value inside
    it. I leave this for you to see how it could be done.
  prefs: []
  type: TYPE_NORMAL
- en: However, how do you read an arbitrary element? Since we only have forward references,
    we must start from the beginning and walk all the way, traversing references while
    counting steps until we reach the element we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We start from the first element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When the index is `0`, we would have finally reached the desired position,
    so we return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are not there yet, we must step onto the next element and keep counting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here too, we have a loop inside that has to run an index a number of times.
    The worst case is when you just need to remove one element but it is not the last
    one; the last one can be found directly. It is easy to see that just like you
    insert into an arbitrary position, this algorithm also has running time complexity
    of *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking up an arbitrary element](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Removing an element in the beginning'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an element in the beginning means simply updating the reference to
    the first element with that of the next element. Note that we do not update the
    reference in the element that has just been removed because the element, along
    with the reference, would be garbage-collected anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign the reference to the next element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no more elements left, we must also update the last reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Removing an arbitrary element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing an arbitrary element is very similar to removing an element from the
    beginning, except that you update the reference held by the previous element instead
    of the special reference named first. The following figure shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing an arbitrary element](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Removing an arbitrary element'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that only the link in the linked list is to be reassigned to the next
    element. The following code does what is shown in the preceding figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, removing the first element is a special case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, find out the element just before the one that needs to be removed because
    this element would need its reference updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the last reference if the last element is the one that is being removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the reference held by the previous element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is very easy to see that the running time worst case complexity of this algorithm
    is *O(n)*—which is similar to finding an arbitrary element—because this is what
    needs to be done before removing it. The operation of the actual removal process
    itself requires only a constant number of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we are working in Java, we prefer to implement the `Iterable` interface.
    It lets us loop through the list in a simplified for loop syntax. For this purpose,
    we first have to create an iterator that will let us fetch the elements one by
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is self-explanatory. Every time it is invoked, we move to the next
    element and return the current element''s value. Now we implement the `iterator`
    method of the `Iterable` interface to make our list an iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables us to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes that the variable `linkedList` was `LinkedList<Integer>`.
    Any list that extends this class will also get this property automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Did you notice that there is no quick way to remove the element from the end
    of a linked list? This is because even if there is a quick way to find the last
    element, there is no quick way to find the element before it whose reference needs
    to be updated. We must walk all the way from the beginning to find the previous
    element. Well then, why not just have another reference to store the location
    of the last but one element? This is because after you remove the element, how
    would you update the reference otherwise? There would be no reference to the element
    right before that. What it looks like is that to achieve this, we have to store
    the reference of all the previous elements up to the beginning. The best way to
    do this would be to store the reference of the previous element in each of the
    elements or nodes along with the reference to the next element. Such a linked
    list is called a **doubly linked list** since the elements are linked both ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Doubly linked list](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement a doubly linked list by extending our original linked list
    because a lot of the operations would be similar. We can create the barebones
    class in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new `Node` class extending the original one and adding a reference
    for the previous node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to override the `getNode()` method to use this node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Insertion at the beginning or at the end
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Insertion at the beginning is very similar to that of a singly linked list,
    except that we must now update the next node''s reference for its previous node.
    The node being inserted does not have a previous node in this case, so nothing
    needs to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Pictorially, it can be visualized as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion at the beginning or at the end](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Insertion at the beginning of a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'Appending at the end is very similar and is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the original list were empty, the original last reference would be null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The complexity of the insertion is the same as that of a singly linked list.
    In fact, all the operations on a doubly linked list have the same running time
    complexity as that of a singly linked list, except the process of removing the
    last element. We will thus refrain from stating it again until we discuss the
    removal of the last element. You should verify that the complexity stays the same
    as with a singly linked list in all other cases.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion at an arbitrary location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with everything else, this operation is very similar to the process of making
    an insertion at an arbitrary location of a singly linked list, except that you
    need to update the references for the previous node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Insertion at an arbitrary location](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11: Insertion at an arbitrary location of a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the first and last element, our overridden methods are invoked
    anyway. Therefore, there is no need to consider them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This part needs a little bit of explaining. In *Figure 11*, the node being
    inserted is **13**. Its previous node should be **4**, which was originally the
    previous node of the next node **3**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prev` reference of the next node **3** must now hold the newly inserted
    node **13**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Removing the first element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removing the first element is almost the same as that for a singly linked list.
    The only additional step is to set the `prev` reference of the next node to `null`.
    The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows what happens. Also, note that finding an element
    does not really need an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the first element](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12: Removal of the first element from a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: There can be an optimization to traverse backward from the last element to the
    first in case the index we are looking for is closer toward the end; however,
    it does not change the asymptotic complexity of the find operation. So we leave
    it at this stage. If interested, you would be able to easily figure out how to
    do this optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an arbitrary element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like other operations, removal is very similar to removal of elements
    in the case of a singly linked list, except that we need to update the `prev`
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing an arbitrary element](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13: Removal of an arbitrary element from a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will help us achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a special case that needs extra attention. A doubly linked list really
    shines while removing the last element. We will discuss the `removeLast()` method
    in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is fairly easy to figure out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Removal of the last element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is where a doubly linked list really shines. This is the reason we got
    started with a doubly linked list. And it''s not even a lot of code. Check this
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Just use the fact that we have access to the previous node''s reference and
    we can update the last reference very easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list is not empty after removal, set the next reference of the new last
    element to null. If the new list is empty instead, update the first element as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to update the length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We don't need a new figure to understand the update of the references as they
    are really similar to the removal process of the first element. The only difference
    from the singly linked list is that in the case of a singly linked list, we need
    to walk all the way to the end of the list to find the previous element of the
    list. However, in the case of a doubly linked list, we can update it in one step
    because we always have access to the previous node's reference. This drastically
    reduces the running time from *O(n)* in the case of a singly linked list to *O(1)*
    in the case of a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Circular linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circular linked list is an ordinary linked list, except that the last element
    holds the reference to the first element as its next element. This, of course,
    justifies its name. It would be useful when, for example, you are holding a list
    of players in a list and they play in turn in a round robin fashion. The implementation
    is simplified if you use a circular linked list and just keep rotating as the
    players complete their turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Circular linked list](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14: A circular linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of a circular linked list is the same as that of a simple
    linked list; no more fields or methods are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the same as the insertion for a simple linked list, except that you
    assign the last references next to the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, it is not hard to guess how it would be to append at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Insertion at any other index, of course, remains the same as that for a simple
    linked list; no more changes are required. This means the complexity of the insertion
    stays the same as with that for a simple linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Removal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Removal also only changes when you remove the first or the last element. In
    any case, just updating the last element''s next reference solves the purpose.
    The only place where we need to change this is when we remove the first element.
    This is because the same operation we used for a simple linked list does not update
    the previous element''s next reference, which we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Nothing else needs to be done in removal.
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we are doing here is just bringing the next element of the first element
    to the first position. This is exactly what the name "rotation" would imply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Rotation](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15: Rotation of a circular linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Doing the same with a simple linked list would require no more than assigning
    one more reference. You should be able to figure out how to do this with a simple
    linked list. But this operation looks more natural for a circular linked list,
    as conceptually, there is no first element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real power of a circular linked list is the iterator, which never ends.
    If the list is non-empty, the iterator will have `hasNext()`, which always returns
    true. This means you can simply keep calling the `next()` method on the iterator
    and keep processing the elements in a round robin fashion. The following code
    should make it clear what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you try to use the enhanced for loop with a circular linked list,
    you will run into an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered a few basic data structures and the algorithms for manipulating
    them. In addition to this, we also found out their running time complexities.
    To summarize this, an array provides you with the fastest random access there
    is with this time complexity: *O(1)*. But arrays cannot change size; the only
    modification they allow is to change the value of an element. A linked list allows
    fast append at the end and insertion at the beginning at *O(1)* time. However,
    *O(1)* removal is only available for removing the first element. This is resolved
    by a doubly linked list that also allows *O(1)* removal from the end. A circular
    linked list holds a reference to the first element in the next reference of the
    last element. This makes the list a circular structure that allows one to loop
    indefinitely.'
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will discuss the abstraction of data structures
    called abstract data types. We will use the data structures we have seen in this
    chapter to implement the abstract data types, which in turn will be used in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
