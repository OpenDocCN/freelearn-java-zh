- en: Chapter 2. Cogs and Pulleys – Building Blocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.齿轮和滑轮 - 构建块
- en: 'We discussed algorithms in the previous chapter, but the title of the book
    also includes the term "data structure." So what is a data structure? A data structure
    is an organization of data in memory that is generally optimized so it can be
    used by a particular algorithm. We have seen that an algorithm is a list of steps
    that leads to a desired outcome. In the case of a program, there is always some
    input and output. Both input and output contain data and hence must be organized
    in some way or another. Therefore, the input and output of an algorithm are data
    structures. In fact, all the intermediate states that an algorithm has to go through
    must also be stored in some form of a data structure. Data structures don''t have
    any use without algorithms to manipulate them, and algorithms cannot work without
    data structures. It''s because this is how they get input and emit output or store
    their intermediate states. There are a lot of ways in which data can be organized.
    Simpler data structures are also different types of variables. For example, `int`
    is a data structure that stores one 4-byte integer value. We can even have classes
    that store a set of specific types of values. However, we also need to think about
    how to store a collection of a large number of the same type of values. In this
    book, we will spend the rest of the time discussing a collection of values of
    the same type because how we store a collection determines which algorithm can
    work on them. Some of the most common ways of storing a collection of values have
    their own names; we will discuss them in this chapter. They are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章讨论了算法，但本书的标题也包括了“数据结构”这个术语。那么什么是数据结构呢？数据结构是数据在内存中的组织形式，通常是经过优化的，以便特定算法可以使用。我们已经看到，算法是一系列导致期望结果的步骤。在程序的情况下，总有一些输入和输出。输入和输出都包含数据，因此必须以某种方式组织。因此，算法的输入和输出都是数据结构。实际上，算法必须经过的所有中间状态也必须以某种形式存储在数据结构中。没有算法来操作它们，数据结构就没有任何用途，没有数据结构，算法也无法工作。这是因为它们就是这样获取输入、发出输出或存储它们的中间状态的。数据可以组织的有很多种方式。简单的数据结构也是不同类型的变量。例如，`int`
    是一个存储一个 4 字节整数值的数据结构。我们甚至可以有存储一组特定类型值的类。然而，我们还需要考虑如何存储大量相同类型值的集合。在这本书中，我们将用剩下的时间讨论同一类型值的集合，因为存储集合的方式决定了哪些算法可以对其工作。一些存储值集合的最常见方式有自己的名称；我们将在本章中讨论它们。它们如下：
- en: Arrays
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Linked lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Doubly linked lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向链表
- en: Circular linked lists
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环链表
- en: These are the basic building blocks that we will use to build more complex data
    structures. Even if we don't use them directly, we will use their concepts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将用来构建更复杂的数据结构的基本构建块。即使我们不直接使用它们，我们也会使用它们的概念。
- en: Arrays
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: If you are a Java programmer, you must have worked with arrays. Arrays are the
    basic storage mechanisms available for a sequence of data. The best thing about
    arrays is that the elements of an array are collocated sequentially and can be
    accessed completely and randomly with single instructions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Java 程序员，你一定使用过数组。数组是为一系列数据提供的最基本存储机制。数组最好的地方是数组的元素是顺序存储的，并且可以通过单条指令完全随机地访问。
- en: 'The traversal of an array element by an element is very simple. Since any element
    can be accessed randomly, you just keep incrementing an index and keep accessing
    the element at this index. The following code shows both traversal and random
    access in an array:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过元素逐个遍历数组元素非常简单。由于任何元素都可以随机访问，你只需不断递增索引并保持访问此索引处的元素。以下代码展示了数组的遍历和随机访问：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Insertion of elements in an array
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组中元素的插入
- en: All the elements in an array are stored in contiguous memory. This makes it
    possible to access any element in a constant amount of time. A program simply
    needs to compute the offset that corresponds to an index, and it reads the information
    directly. But this means they are also limited and have a fixed size. If you want
    to insert a new element into an array, you will need to create a new array with
    one more element and copy the entire data from the original data along with the
    new value. To avoid all this complexity, we will start with moving an existing
    element to a new position. What we are looking to do is to take an element out,
    shift all the elements up to the target position to make space in this position,
    and insert the value we extracted in the same place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的所有元素都存储在连续的内存中。这使得可以在常数时间内访问任何元素。程序只需计算与索引相对应的偏移量，然后直接读取信息。但这意味着它们也是有限的，并且具有固定的大小。如果你想在数组中插入一个新元素，你需要创建一个包含一个更多元素的新数组，并将整个原始数据以及新值一起复制。为了避免所有这些复杂性，我们将从将现有元素移动到新位置开始。我们想要做的是取出一个元素，将所有元素向上移动到目标位置以腾出空间，并将提取的值插入到相同的位置。
- en: '![Insertion of elements in an array](img/00003.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![数组中元素的插入](img/00003.jpeg)'
- en: 'Figure 1: Insertion of an existing array element into a new location'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：将现有数组元素插入新位置
- en: 'The preceding figure explains what we mean by this operation. The thin black
    arrows show the movement of the element that is being reinserted, and the thick
    white arrow shows the shift of the elements of the array. In each case, the bottom
    figure shows the array after the reinsertion is done. Notice that the shifting
    is done either to the left or right, depending on what the start and end index
    are. Let''s put this in code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图解释了我们所说的这种操作。细黑箭头显示了正在重新插入的元素的运动，粗白箭头显示了数组元素的变化。在每个情况下，底部图显示了重新插入完成后的数组。请注意，移动要么向左要么向右，这取决于起始索引和结束索引。让我们用代码来实现这一点：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What would be the running time complexity of the preceding algorithm? For all
    our cases, we will only consider the worst case. When does an algorithm perform
    worst? To understand this, let''s see what the most frequent operation in an algorithm
    is. It is of course the shift that happens in the loop. The number of shifts become
    maximum when `startIndex` is at the beginning of the array and `targetIndex` at
    the end or vice versa. This is when all but one element has to be shifted one
    by one. The running time in this case must be some constant times the number of
    elements of the array plus some other constant to account for the non-repeating
    operations. So it is *T(n) = K(n-1)+C* for some constants *K* and *C*, where *n*
    is the number of elements in the array and *T(n)* is the running time of the algorithm.
    This can be expressed as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前述算法的运行时间复杂度是什么？对于所有我们的情况，我们只考虑最坏的情况。算法何时表现最差？为了理解这一点，让我们看看算法中最频繁的操作是什么。当然是在循环中发生的移动。当`startIndex`位于数组的开始而`targetIndex`位于末尾或相反时，移动次数达到最大。在这种情况下，必须逐个移动除一个元素之外的所有元素。在这种情况下，运行时间必须是数组元素数量的一些常数倍加上一些其他常数，以考虑非重复操作。因此，它是*T(n)
    = K(n-1)+C*，其中*K*和*C*是常数，*n*是数组中的元素数量，*T(n)*是算法的运行时间。这可以表示如下：
- en: '*T(n) = K(n-1)+C = Kn + (C-K)*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*T(n) = K(n-1)+C = Kn + (C-K)*'
- en: 'The following steps explain the expression:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤解释了表达式的含义：
- en: As per rule 1 of the definition of **big O**, *T(n) = O(Kn + (C-K))*.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据大O定义的规则1，*T(n) = O(Kn + (C-K))*。
- en: As per rule 3, *T(n) = O(Kn)*.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据定义的规则3，*T(n) = O(Kn)*。
- en: We know *|-(C-K)| < |Kn + (C-K)|* is true for sufficiently large *n*. Therefore,
    as per rule 3, since *T(n) = O(Kn + (C-K))*, it means *T(n) = O(Kn + (C-K) + (-(C-K)))*,
    that is, *T(n) = O(Kn)*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道对于足够大的*n*，*|-(C-K)| < |Kn + (C-K)|*是正确的。因此，根据规则3，由于*T(n) = O(Kn + (C-K))*，这意味着*T(n)
    = O(Kn + (C-K) + (-(C-K)))*，即*T(n) = O(Kn)*。
- en: And, finally, as per rule 2, *T(n) = O(n)*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，根据规则2，*T(n) = O(n)*。
- en: Now since the array is the major input in the algorithm, the size of the input
    is represented by *n*. So we will say, the running time of the algorithm is *O(n)*,
    where *n* is the size of the input.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于数组是算法的主要输入，输入的大小用*n*表示。所以我们将说，算法的运行时间是*O(n)*，其中*n*是输入的大小。
- en: Insertion of a new element and the process of appending it
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入新元素及其附加过程
- en: 'Now we move on to the process of insertion of a new element. Since arrays are
    fixed in size, insertion requires us to create a new array and copy all the earlier
    elements into it. The following figure explains the idea of an insertion made
    in a new array:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续到插入新元素的过程。由于数组的大小是固定的，插入操作需要我们创建一个新的数组并将所有之前的元素复制到其中。以下图解展示了在新的数组中进行插入的概念：
- en: '![Insertion of a new element and the process of appending it](img/00004.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![插入新元素及其附加过程](img/00004.jpeg)'
- en: 'Figure 2: Insertion of a new element into an array'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：将新元素插入到数组中
- en: 'The following code does exactly that:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码正是这样做的：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'First, you copy all the elements before the targeted position as they are in
    the original array:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你只需像在原始数组中一样复制目标位置之前的所有元素：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the new value must be put in the correct position:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，新值必须放置在正确的位置：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the end, copy the rest of the elements in the array by shifting their position
    by one:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将它们的位移动一位来复制数组中的其余元素：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we have the code ready, appending it would mean just inserting it at the
    end, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码准备好后，附加操作就意味着只需将其插入到末尾，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What is the running time complexity of the preceding algorithm? Well, no matter
    what we do, we must copy all the elements of the original array to the new array,
    and this is the operation in the loop. So the running time is *T(n) = Kn + C*
    for some constants *K* and *C*, and *n* is the size of the array, which is the
    size of the input. I leave it to you to verify the steps in order to figure out
    this: *T(n) = O(n)*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前述算法的运行时间复杂度是多少？好吧，无论我们做什么，我们都必须将原始数组中的所有元素复制到新数组中，这是循环中的操作。因此，运行时间是 *T(n) =
    Kn + C*，其中 *K* 和 *C* 是一些常数，而 *n* 是数组的大小，也就是输入的大小。我将这个验证步骤留给你，以便找出这个：*T(n) = O(n)*。
- en: Linked list
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: 'Arrays are great for storing data. We have also seen that any element of an
    array can be read in *O(1)* time. But arrays are fixed in size. Changing the size
    of an array means creating a new array and copying all the elements to the original
    array. The simplest recourse to the resizing problem is to store each element
    in a different object and then hold a reference in each element to the next element.
    This way, the process of adding a new element will just involve creating the element
    and attaching it at the end of the last element of the original linked list. In
    another variation, the new element can be added to the beginning of the existing
    linked list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 数组非常适合存储数据。我们也看到，数组的任何元素都可以在 *O(1)* 时间内读取。但是数组的大小是固定的。改变数组的大小意味着创建一个新的数组并将所有元素复制到原始数组中。对于调整大小问题的最简单解决办法是将每个元素存储在不同的对象中，然后在每个元素中持有对下一个元素的引用。这样，添加新元素的过程只需创建该元素并将其附加到原始链表的最后一个元素上。在另一种变体中，新元素可以被添加到现有链表的开始位置：
- en: '![Linked list](img/00005.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![链表](img/00005.jpeg)'
- en: 'Figure 3: An example of a linked list'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：链表的示例
- en: '*Figure 3* shows an example of a linked list. The arrows represent a reference.
    Each element is stored in a **wrapper object** that also holds a reference to
    the next element wrapper. There are two additional references to the first and
    last elements, which are required for any operation to start. The last reference
    is optional, but it improves the performance of appending to the end vastly, as
    we shall see.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3* 展示了一个链表的示例。箭头代表引用。每个元素都存储在一个**包装对象**中，该对象还持有对下一个元素包装器的引用。还有两个额外的引用指向第一个和最后一个元素，这对于任何操作开始都是必需的。最后一个引用是可选的，但它极大地提高了向末尾附加的性能，正如我们将看到的。'
- en: 'To begin the discussion, let''s create a linked list node in the following
    way:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始讨论，让我们以下面的方式创建一个链表节点：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, we create a `Node` class inside the `LinkedList` class, which will act
    as a wrapper for the elements and also hold the reference to the next node:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`LinkedList`类内部创建一个`Node`类，它将作为元素的包装器，并持有对下一个节点的引用：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we must have references for the first and last elements:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须为第一个和最后一个元素设置引用：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we create a method called `getNewNode()` that creates a new empty
    node. We will need this if we want to use a different class for a node in any
    of the subclasses:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个名为`getNewNode()`的方法，该方法创建一个新的空节点。如果我们想在任何子类中使用不同的节点类，我们将需要这个方法：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, the unfinished class `LinkedList` will not be able to store any
    element; let's see how to do this, though. Notice that we have implemented the
    `Iterable` interface. This will allow us to loop through all the elements in an
    advanced for loop.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，未完成的类 `LinkedList` 将无法存储任何元素；不过，让我们看看如何实现这一点。请注意，我们已经实现了 `Iterable` 接口。这将允许我们通过高级
    for 循环遍历所有元素。
- en: Appending at the end
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在末尾追加
- en: 'Appending at the end is achieved by simply creating a link from the last element
    of the original linked list to the new element that is being appended and then
    reassigning the reference to the last element. The second step is required because
    the new element is the new last element. This is shown in the following figure:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾追加是通过简单地从原始链表的最后一个元素创建一个指向正在追加的新元素的链接，然后重新分配最后一个元素的引用来实现的。第二步是必需的，因为新元素是新的最后一个元素。这将在以下图中展示：
- en: '![Appending at the end](img/00006.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![在末尾追加](img/00006.jpeg)'
- en: 'Figure 4: Appending at the end of a linked list'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4：在链表末尾追加
- en: 'There is a small difference when you append an element to a linked list that
    is empty to start with. At this point, the first and last references are null,
    and this case must be handled separately. The following figure explains this case:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向一开始就是空的链表追加元素时，会有一个小的区别。在这种情况下，第一个和最后一个引用都是 null，这种情况必须单独处理。以下图解释了这种情况：
- en: '![Appending at the end](img/00007.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![在末尾追加](img/00007.jpeg)'
- en: 'Figure 5: Appending to an empty linked list'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：向空链表追加
- en: 'We will achieve this by using the following simple code as is. We return the
    node that has just been added. This is helpful to any class that is extending
    this class. We will do the same in all cases, and we will see the use of this
    while discussing doubly linked lists:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下简单代码实现这一点。我们返回刚刚添加的节点。这对任何扩展此类的类都很有帮助。我们将在所有情况下都这样做，我们将在讨论双链表时看到这一点：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We try to update the reference of the current last node only if the list is
    not empty:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只尝试更新当前最后一个节点的引用，如果列表不为空：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we must update the last reference as the new element is not going to
    be the last element:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须更新最后一个引用，因为新元素不会是最后一个元素：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, if the list is empty, the new element must also be the first new element
    and we must update the first reference accordingly, as shown in the preceding
    figure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果列表为空，新元素也必须是第一个新元素，我们必须相应地更新第一个引用，如图所示：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that we also keep track of the current length of the list. This is not
    essential, but if we do this, we do not have to traverse the entire list just
    to count how many elements are in the list.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还跟踪列表的当前长度。这并不是必需的，但如果这样做，我们就不必遍历整个列表来计算列表中有多少元素。
- en: 'Now, of course, there is this important question: what is the time complexity
    of appending to a linked list? Well, if we do it the way we have done it before—that
    is, by having a special reference to the last element—we don''t need any loop,
    as we can see in the code. If the program does not have any loops, all operations
    would be one-time operations, hence everything is completed in constant time.
    You can verify that a constant function has this complexity: *O(1)*. Compare this
    with what was appended at the end of an array. It required the creation of a new
    array and also had *O(n)* complexity, where *n* was the size of the array.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，有一个重要的问题：向链表追加元素的时间复杂度是多少？好吧，如果我们像之前那样做——也就是说，通过有一个指向最后一个元素的特别引用——我们不需要任何循环，就像我们在代码中看到的那样。如果程序没有任何循环，所有操作都是一次性操作，因此所有操作都在常数时间内完成。你可以验证一个常数函数具有这种复杂度：*O(1)*。将此与在数组末尾追加的内容进行比较。它需要创建一个新的数组，并且具有
    *O(n)* 的复杂度，其中 *n* 是数组的大小。
- en: Insertion at the beginning
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在起始位置插入
- en: 'Inserting an element at the beginning of a list is very similar to appending
    it at the end. The only difference is that you need to update the first reference
    instead of the last reference:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的起始位置插入元素与在末尾追加它非常相似。唯一的区别是您需要更新第一个引用而不是最后一个引用：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Insertion at an arbitrary position
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在任意位置插入
- en: Insertion at an arbitrary position can be achieved in the same way we perform
    an insertion in the first element, except that we update the reference of the
    previous element instead of the first reference. There is, however, a catch; we
    need to find the position where we need to insert the element. There is no way
    to find it other than to start at the beginning and walk all the way to the correct
    position while counting each node we step on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意位置插入可以通过与我们在第一个元素中执行插入相同的方式进行，只是我们需要更新前一个元素的引用而不是第一个引用。然而，有一个问题；我们需要找到插入元素的位置。除了从开始处开始并一直走到正确的位置同时计数我们经过的每个节点外，没有其他方法可以找到它。
- en: '![Insertion at an arbitrary position](img/00008.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![在任意位置插入](img/00008.jpeg)'
- en: 'Figure 6: Insertion of an arbitrary element into a linked list'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：在链表中插入任意元素
- en: 'We can implement the idea as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如下实现这个想法：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'First, we take care of the special cases:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们处理特殊情况：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As mentioned earlier, we walk all the way to the desired position while counting
    the nodes, or in this case, counting the index in the opposite direction:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在计数节点的同时走到期望的位置，或者在这种情况下，在相反方向上计数索引：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we update the references:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新引用：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What is the complexity of this algorithm? There is a loop that must run as many
    times as the index. This algorithm seems to have a running time that is dependent
    on the value of the input and not just its size. In this case, we are only interested
    in the worst case. What is the worst case then? It is when we need to step on
    all the elements of the list, that is, when we have to insert the element at the
    end of the list, except for the last element. In this case, we must step on *n-1*
    elements to get there and do some constant work. The number of steps would then
    be *T(n) = C(n-1)+K* for some constants *C* and *K*. So, *T(n) = O(n)*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的复杂度是多少？有一个循环必须运行与索引相同的次数。这个算法似乎运行时间依赖于输入的值，而不仅仅是其大小。在这种情况下，我们只对最坏情况感兴趣。那么最坏情况是什么？它是指我们需要走过列表中的所有元素，也就是说，当我们必须将元素插入列表的末尾时，除了最后一个元素。在这种情况下，我们必须走过*n-1*个元素才能到达那里并做一些常数工作。因此，步数将是*T(n)
    = C(n-1)+K*，其中*C*和*K*是某些常数。所以，*T(n) = O(n)*。
- en: Looking up an arbitrary element
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找任意元素
- en: Finding the value of an arbitrary element has two different cases. For the first
    and last element, it is simple. Since we have direct references to the first and
    last element, we just have to traverse that reference and read the value inside
    it. I leave this for you to see how it could be done.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查找任意元素的值有两种不同的情况。对于第一个和最后一个元素，这很简单。由于我们直接引用了第一个和最后一个元素，我们只需遍历那个引用并读取其中的值。我将这个留给你去观察它是如何实现的。
- en: However, how do you read an arbitrary element? Since we only have forward references,
    we must start from the beginning and walk all the way, traversing references while
    counting steps until we reach the element we want.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如何读取任意元素？由于我们只有前向引用，我们必须从开始处开始并一直走到，在遍历引用的同时计数步数，直到我们到达我们想要的元素。
- en: 'Let''s see how we can do this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We start from the first element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从第一个元素开始：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the index is `0`, we would have finally reached the desired position,
    so we return:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引为`0`时，我们最终到达了期望的位置，因此我们返回：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we are not there yet, we must step onto the next element and keep counting:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有到达那里，我们必须移动到下一个元素并继续计数：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here too, we have a loop inside that has to run an index a number of times.
    The worst case is when you just need to remove one element but it is not the last
    one; the last one can be found directly. It is easy to see that just like you
    insert into an arbitrary position, this algorithm also has running time complexity
    of *O(n)*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们也有一个循环，它需要运行多次。最坏的情况是你只需要删除一个元素，但它不是最后一个；最后一个可以直接找到。很容易看出，就像你在任意位置插入一样，这个算法的运行时间复杂度也是*O(n)*。
- en: '![Looking up an arbitrary element](img/00009.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![查找任意元素](img/00009.jpeg)'
- en: 'Figure 7: Removing an element in the beginning'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：删除开始位置的元素
- en: 'Removing an element in the beginning means simply updating the reference to
    the first element with that of the next element. Note that we do not update the
    reference in the element that has just been removed because the element, along
    with the reference, would be garbage-collected anyway:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始位置删除元素意味着简单地更新第一个元素的引用为下一个元素的引用。请注意，我们不会更新刚刚删除的元素的引用，因为该元素以及引用无论如何都会被垃圾回收：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assign the reference to the next element:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将引用分配给下一个元素：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If there are no more elements left, we must also update the last reference:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的元素，我们还必须更新最后一个引用：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Removing an arbitrary element
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除任意元素
- en: 'Removing an arbitrary element is very similar to removing an element from the
    beginning, except that you update the reference held by the previous element instead
    of the special reference named first. The following figure shows this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 移除任意元素与从开始移除元素非常相似，只是你更新前一个元素持有的引用，而不是名为first的特殊引用。以下图示展示了这一点：
- en: '![Removing an arbitrary element](img/00010.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![移除任意元素](img/00010.jpeg)'
- en: 'Figure 8: Removing an arbitrary element'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：移除任意元素
- en: 'Notice that only the link in the linked list is to be reassigned to the next
    element. The following code does what is shown in the preceding figure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有链表中的链接需要重新分配给下一个元素。以下代码执行了前面图示中的操作：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Of course, removing the first element is a special case:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，移除第一个元素是一个特殊情况：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, find out the element just before the one that needs to be removed because
    this element would need its reference updated:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找出需要移除的元素之前的元素，因为这个元素需要更新其引用：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update the last reference if the last element is the one that is being removed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个元素是被移除的元素，则更新最后一个引用：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the reference held by the previous element:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更新前一个元素持有的引用：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is very easy to see that the running time worst case complexity of this algorithm
    is *O(n)*—which is similar to finding an arbitrary element—because this is what
    needs to be done before removing it. The operation of the actual removal process
    itself requires only a constant number of steps.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，该算法的最坏情况时间复杂度是*O(n)*——这与查找任意元素相似——因为这是在移除之前需要做的事情。实际移除过程本身只需要常数步数。
- en: Iteration
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: 'Since we are working in Java, we prefer to implement the `Iterable` interface.
    It lets us loop through the list in a simplified for loop syntax. For this purpose,
    we first have to create an iterator that will let us fetch the elements one by
    one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在Java中工作，我们更喜欢实现`Iterable`接口。它让我们能够以简化的for循环语法遍历列表。为此，我们首先必须创建一个迭代器，它将允许我们逐个获取元素：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code is self-explanatory. Every time it is invoked, we move to the next
    element and return the current element''s value. Now we implement the `iterator`
    method of the `Iterable` interface to make our list an iterable:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是自我解释的。每次调用它时，我们都移动到下一个元素并返回当前元素的值。现在我们实现`Iterable`接口的`iterator`方法，使我们的列表成为一个可迭代的：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This enables us to use the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用以下代码：
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code assumes that the variable `linkedList` was `LinkedList<Integer>`.
    Any list that extends this class will also get this property automatically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设变量`linkedList`是`LinkedList<Integer>`。任何扩展此类的列表也将自动获得此属性。
- en: Doubly linked list
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'Did you notice that there is no quick way to remove the element from the end
    of a linked list? This is because even if there is a quick way to find the last
    element, there is no quick way to find the element before it whose reference needs
    to be updated. We must walk all the way from the beginning to find the previous
    element. Well then, why not just have another reference to store the location
    of the last but one element? This is because after you remove the element, how
    would you update the reference otherwise? There would be no reference to the element
    right before that. What it looks like is that to achieve this, we have to store
    the reference of all the previous elements up to the beginning. The best way to
    do this would be to store the reference of the previous element in each of the
    elements or nodes along with the reference to the next element. Such a linked
    list is called a **doubly linked list** since the elements are linked both ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到没有快速的方法从链表的末尾移除元素？这是因为即使有快速的方法找到最后一个元素，也没有快速的方法找到它之前需要更新引用的元素。我们必须从头开始遍历以找到前一个元素。那么，为什么不保留另一个引用来存储倒数第二个元素的位置呢？这是因为在你移除元素之后，你将如何更新引用呢？将没有指向那个元素的引用。看起来为了实现这一点，我们必须存储从开始到前一个元素的所有元素的引用。最好的方法是在每个元素或节点中存储前一个元素的引用以及指向下一个元素的引用。这样的链表被称为**双向链表**，因为元素是双向链接的：
- en: '![Doubly linked list](img/00011.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![双向链表](img/00011.jpeg)'
- en: 'Figure 9: Doubly linked list'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：双向链表
- en: 'We will implement a doubly linked list by extending our original linked list
    because a lot of the operations would be similar. We can create the barebones
    class in the following manner:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过扩展我们的原始链表来实现双向链表，因为许多操作都是相似的。我们可以以下面的方式创建基本类：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a new `Node` class extending the original one and adding a reference
    for the previous node:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `Node` 类，它扩展了原始类并添加了对前一个节点的引用：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Of course, we need to override the `getNode()` method to use this node:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要重写 `getNode()` 方法来使用此节点：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Insertion at the beginning or at the end
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开头或结尾进行插入
- en: 'Insertion at the beginning is very similar to that of a singly linked list,
    except that we must now update the next node''s reference for its previous node.
    The node being inserted does not have a previous node in this case, so nothing
    needs to be done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头进行插入与单链表的插入非常相似，除了我们现在必须更新下一个节点的引用以指向其前一个节点。在这种情况下，被插入的节点没有前一个节点，因此不需要做任何事情：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Pictorially, it can be visualized as shown in the following figure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图像上，它可以如下所示可视化：
- en: '![Insertion at the beginning or at the end](img/00012.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![在开头或结尾插入](img/00012.jpeg)'
- en: 'Figure 10: Insertion at the beginning of a doubly linked list'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：双向链表的开头插入
- en: 'Appending at the end is very similar and is given as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在末尾的插入非常相似，如下所示：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the original list were empty, the original last reference would be null:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果原始列表为空，原始的最后一个引用将是 `null`：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The complexity of the insertion is the same as that of a singly linked list.
    In fact, all the operations on a doubly linked list have the same running time
    complexity as that of a singly linked list, except the process of removing the
    last element. We will thus refrain from stating it again until we discuss the
    removal of the last element. You should verify that the complexity stays the same
    as with a singly linked list in all other cases.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的复杂性与单链表相同。实际上，双向链表上的所有操作都具有与单链表相同的运行时间复杂度，除了移除最后一个元素的过程。因此，我们将在此讨论移除最后一个元素之前不再重复这一点。你应该验证在其他所有情况下，复杂度与单链表相同。
- en: Insertion at an arbitrary location
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在任意位置插入
- en: As with everything else, this operation is very similar to the process of making
    an insertion at an arbitrary location of a singly linked list, except that you
    need to update the references for the previous node.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他所有操作一样，这个操作与在单链表的任意位置进行插入的过程非常相似，除了你需要更新前一个节点的引用。
- en: '![Insertion at an arbitrary location](img/00013.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![在任意位置插入](img/00013.jpeg)'
- en: 'Figure 11: Insertion at an arbitrary location of a doubly linked list'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：双向链表的任意位置插入
- en: 'The following code does this for us:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为我们完成了这项工作：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the case of the first and last element, our overridden methods are invoked
    anyway. Therefore, there is no need to consider them again:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个和最后一个元素的情况下，我们的重写方法仍然会被调用。因此，没有必要再次考虑它们：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This part needs a little bit of explaining. In *Figure 11*, the node being
    inserted is **13**. Its previous node should be **4**, which was originally the
    previous node of the next node **3**:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分需要稍作解释。在 *图11* 中，被插入的节点是 **13**。其前一个节点应该是 **4**，它原本是下一个节点 **3** 的前一个节点：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `prev` reference of the next node **3** must now hold the newly inserted
    node **13**:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个节点 **3** 的 `prev` 引用现在必须持有新插入的节点 **13**：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Removing the first element
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除第一个元素
- en: 'Removing the first element is almost the same as that for a singly linked list.
    The only additional step is to set the `prev` reference of the next node to `null`.
    The following code does this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 移除第一个元素几乎与单链表相同。唯一的额外步骤是将下一个节点的 `prev` 引用设置为 `null`。以下代码执行此操作：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following figure shows what happens. Also, note that finding an element
    does not really need an update:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了发生的情况。此外，请注意，查找元素实际上并不需要更新：
- en: '![Removing the first element](img/00014.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![移除第一个元素](img/00014.jpeg)'
- en: 'Figure 12: Removal of the first element from a doubly linked list'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图12：从双向链表中移除第一个元素
- en: There can be an optimization to traverse backward from the last element to the
    first in case the index we are looking for is closer toward the end; however,
    it does not change the asymptotic complexity of the find operation. So we leave
    it at this stage. If interested, you would be able to easily figure out how to
    do this optimization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们寻找的索引更接近链表末尾，可以有一个优化来从最后一个元素遍历到第一个元素；然而，这并不会改变查找操作的渐进复杂度。所以我们就保持在这个阶段。如果你感兴趣，可以很容易地找出如何进行这种优化。
- en: Removing an arbitrary element
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除任意元素
- en: 'Just like other operations, removal is very similar to removal of elements
    in the case of a singly linked list, except that we need to update the `prev`
    reference:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他操作一样，移除操作在单链表中的元素移除情况下非常相似，只是我们需要更新`prev`引用：
- en: '![Removing an arbitrary element](img/00015.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![移除任意元素](img/00015.jpeg)'
- en: 'Figure 13: Removal of an arbitrary element from a doubly linked list'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：从双链表中移除任意元素
- en: 'The following code will help us achieve this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助我们实现这一点：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is a special case that needs extra attention. A doubly linked list really
    shines while removing the last element. We will discuss the `removeLast()` method
    in the next section:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要额外注意的特殊情况。双链表在移除最后一个元素时表现得尤为出色。我们将在下一节讨论`removeLast()`方法：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The rest of the code is fairly easy to figure out:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码相对容易理解：
- en: '[PRE48]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Removal of the last element
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除最后一个元素
- en: 'This is where a doubly linked list really shines. This is the reason we got
    started with a doubly linked list. And it''s not even a lot of code. Check this
    out:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是双链表真正发光的地方。这也是我们一开始选择使用双链表的原因。而且代码量并不多。看看这个：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Just use the fact that we have access to the previous node''s reference and
    we can update the last reference very easily:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只需利用我们可以访问前一个节点的引用，并且可以很容易地更新最后一个引用的事实：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the list is not empty after removal, set the next reference of the new last
    element to null. If the new list is empty instead, update the first element as
    well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果移除后列表不为空，将新最后一个元素的下一个引用设置为null。如果新列表为空，则更新第一个元素：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Don''t forget to update the length:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新长度：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We don't need a new figure to understand the update of the references as they
    are really similar to the removal process of the first element. The only difference
    from the singly linked list is that in the case of a singly linked list, we need
    to walk all the way to the end of the list to find the previous element of the
    list. However, in the case of a doubly linked list, we can update it in one step
    because we always have access to the previous node's reference. This drastically
    reduces the running time from *O(n)* in the case of a singly linked list to *O(1)*
    in the case of a doubly linked list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要新的图来理解引用的更新，因为它们实际上与移除第一个元素的过程非常相似。唯一的区别在于，在单链表中，我们需要走到链表的末尾才能找到列表的前一个元素。然而，在双链表中，我们可以一步更新它，因为我们始终可以访问前一个节点的引用。这极大地减少了运行时间，从单链表中的*O(n)*降低到双链表中的*O(1)*。
- en: Circular linked list
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'A circular linked list is an ordinary linked list, except that the last element
    holds the reference to the first element as its next element. This, of course,
    justifies its name. It would be useful when, for example, you are holding a list
    of players in a list and they play in turn in a round robin fashion. The implementation
    is simplified if you use a circular linked list and just keep rotating as the
    players complete their turn:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是一个普通的链表，除了最后一个元素持有对第一个元素的引用作为其下一个元素。这当然也解释了它的名字。例如，当你持有一个玩家列表，他们轮流进行循环赛时，这会很有用。如果你使用循环链表，并且随着玩家完成他们的回合而不断旋转，实现会变得更加简单：
- en: '![Circular linked list](img/00016.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![循环链表](img/00016.jpeg)'
- en: 'Figure 14: A circular linked list'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图14：循环链表
- en: 'The basic structure of a circular linked list is the same as that of a simple
    linked list; no more fields or methods are required:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表的基本结构与简单链表相同；不需要更多的字段或方法：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Insertion
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入
- en: 'This is the same as the insertion for a simple linked list, except that you
    assign the last references next to the first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这与简单链表的插入操作相同，只是你需要将最后一个引用的下一个元素赋值为第一个：
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'From this, it is not hard to guess how it would be to append at the end:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个，不难猜出在末尾添加元素的方式：
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Insertion at any other index, of course, remains the same as that for a simple
    linked list; no more changes are required. This means the complexity of the insertion
    stays the same as with that for a simple linked list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他索引处插入，当然，与简单链表的插入相同；不需要更多更改。这意味着插入的复杂性与简单链表相同。
- en: Removal
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: 'Removal also only changes when you remove the first or the last element. In
    any case, just updating the last element''s next reference solves the purpose.
    The only place where we need to change this is when we remove the first element.
    This is because the same operation we used for a simple linked list does not update
    the previous element''s next reference, which we need to do:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作也只有在删除第一个或最后一个元素时才会改变。在任何情况下，只需更新最后一个元素的下一个引用即可解决问题。唯一需要更改这个引用的地方是在删除第一个元素时。这是因为我们用于简单链表的相同操作不会更新前一个元素的下一个引用，而这正是我们需要做的：
- en: '[PRE56]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Nothing else needs to be done in removal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除操作中，不需要做其他任何事情。
- en: Rotation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转
- en: 'What we are doing here is just bringing the next element of the first element
    to the first position. This is exactly what the name "rotation" would imply:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将第一个元素的下一个元素移动到第一个位置。这正是“旋转”这个名字所暗示的：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Rotation](img/00017.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![旋转](img/00017.jpeg)'
- en: 'Figure 15: Rotation of a circular linked list'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图15：循环链表的旋转
- en: Doing the same with a simple linked list would require no more than assigning
    one more reference. You should be able to figure out how to do this with a simple
    linked list. But this operation looks more natural for a circular linked list,
    as conceptually, there is no first element.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单链表中执行相同的操作只需要分配一个额外的引用。你应该能够弄清楚如何在简单链表中做到这一点。但这个操作对于循环链表来说看起来更自然，因为从概念上讲，没有第一个元素。
- en: 'The real power of a circular linked list is the iterator, which never ends.
    If the list is non-empty, the iterator will have `hasNext()`, which always returns
    true. This means you can simply keep calling the `next()` method on the iterator
    and keep processing the elements in a round robin fashion. The following code
    should make it clear what I mean:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表真正的力量在于迭代器，它永远不会结束。如果列表非空，迭代器将具有`hasNext()`方法，它总是返回true。这意味着你可以简单地不断调用迭代器的`next()`方法，并按轮询方式持续处理元素。以下代码应该能清楚地说明我的意思：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that if you try to use the enhanced for loop with a circular linked list,
    you will run into an infinite loop.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你尝试使用增强型for循环与循环链表一起使用，你将遇到无限循环。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We covered a few basic data structures and the algorithms for manipulating
    them. In addition to this, we also found out their running time complexities.
    To summarize this, an array provides you with the fastest random access there
    is with this time complexity: *O(1)*. But arrays cannot change size; the only
    modification they allow is to change the value of an element. A linked list allows
    fast append at the end and insertion at the beginning at *O(1)* time. However,
    *O(1)* removal is only available for removing the first element. This is resolved
    by a doubly linked list that also allows *O(1)* removal from the end. A circular
    linked list holds a reference to the first element in the next reference of the
    last element. This makes the list a circular structure that allows one to loop
    indefinitely.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些基本数据结构和操作它们的算法。除此之外，我们还发现了它们的运行时间复杂度。为了总结这一点，数组提供了最快的随机访问，其时间复杂度为*O(1)*。但是数组不能改变大小；它们唯一允许的修改是更改元素的值。链表允许以*O(1)*时间在末尾快速追加和在开头插入。然而，*O(1)*的删除操作仅适用于删除第一个元素。这通过一个双向链表得到解决，它也允许从末尾以*O(1)*删除。循环链表在最后一个元素的下一个引用中保存对第一个元素的引用。这使得列表成为一个循环结构，允许无限循环。
- en: In the upcoming chapters, we will discuss the abstraction of data structures
    called abstract data types. We will use the data structures we have seen in this
    chapter to implement the abstract data types, which in turn will be used in later
    chapters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论数据结构抽象称为抽象数据类型。我们将使用本章中看到的数据结构来实现抽象数据类型，这些抽象数据类型随后将在后面的章节中使用。
