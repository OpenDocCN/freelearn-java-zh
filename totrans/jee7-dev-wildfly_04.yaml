- en: Chapter 4. Learning Context and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that [Chapter 3](part0023_split_000.html#page "Chapter 3. Introducing
    Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, was challenging since we had
    to cover lots of ground, including Java Enterprise enhancements and a Maven-specific
    configuration. In this chapter, we'll discuss **Contexts and Dependency Injection**
    (**CDI**), which was added to the Java EE specification in Java EE 6 (starting
    from JSR 299). It provides several benefits to Java EE developers that were missing,
    such as allowing any JavaBean to be used as a JSF managed bean, including stateless
    and stateful session beans. You can find more information on CDI and the newest
    version of the specification itself (JSR 346) at [http://www.cdi-spec.org/](http://www.cdi-spec.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What Contexts and Dependency Injection is and how it relates to EJB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to rewrite our ticket-booking example to use the CDI and JavaServer Faces
    technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run the project using Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter assumes familiarity with **JavaServer Faces** (**JSF**), which
    will be used to provide a graphical interface for our applications. If you are
    looking for a start up guide for JSF, there are several excellent resources available
    online, including the relevant sections in the official Java EE 7 tutorial at
    [http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX](http://docs.oracle.com/javaee/7/tutorial/doc/jsf-develop.htm#BNATX).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Contexts and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CDI for the Java EE platform introduces a standard set of component management
    services to the Java EE platform. As a component of Java EE 7, CDI is in many
    ways a standardization of concepts that have been brewing in Spring for a long
    time, such as dependency injection and interceptors. In fact, CDI and Spring 3
    share many similar features. There are also other dependency injection frameworks
    available for developers that are more lightweight and easier to use in a Java
    SE environment. **Google Guice** ([https://github.com/google/guice](https://github.com/google/guice))
    is a notable example. Providing full-blown support for the CDI container in a
    standalone Java SE application and separation from the application server are
    one of the goals of the upcoming CDI 2.0 specification. This will allow developers
    to use a common programming model on both client and server sides.
  prefs: []
  type: TYPE_NORMAL
- en: CDI lets you decouple concerns by what it refers to as loose coupling and strong
    typing. In doing so, it provides an almost liberating escape from the banalities
    of everyday Java programming, allowing injections of its objects and controlling
    their lifetimes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why is CDI required for Java EE?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you have been programming with Java EE 5, you might argue that it already
    features resources injection of resources. However, this kind of injection can
    be used only for resources known to the container (for example, `@EJB`, `@PersistenceContext`,
    `@PersistenceUnit`, and `@Resource`). CDI, on the other hand, provides a general-purpose
    dependency injection scheme, which can be used for any component.
  prefs: []
  type: TYPE_NORMAL
- en: The CDI elementary unit is still the bean. Compared to EJBs, CDI features a
    different, more flexible kind of bean, which would often be a good place to put
    your business logic in. One of the most important differences between the two
    approaches is that CDI Beans are **contextual**; that is, they live in a well-defined
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, the injected EJB proxy (let's just assume that it is a POJO class annotated
    with a `@Stateless` annotation) just points to a pool of stateless instances (or
    a single bean instance for stateful beans). There is no automatic association
    between the HTTP request or HTTP session and a given EJB instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite is true for CDI Beans, which live in well-defined scopes. For
    example, the following CDI Bean lives in `RequestScoped`; that is, it will be
    destroyed at the end of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding CDI Bean can be safely injected into our former servlet; at the
    end of an HTTP session or HTTP request, all the instances associated with this
    scope are automatically destroyed, and thus, garbage collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Named beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the earlier section, we came across the `@Named` annotation. Named beans
    allow us to easily inject our beans into other classes that depend on them and
    refer to them from JSF pages via the **Unified Expression Language** (**UEL**).
    Recall the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This class, decorated with the `@Named` annotation, can then be referenced
    from a JSF page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the name of the bean will be the class name with its first letter
    switched to lowercase; thus, the `Customer` bean can be referred to as `customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use a different naming policy for your bean, you could use the
    `@Named` annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This way, we will be able to reference our CDI Beans using the identified `customNamed`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of two `@RequestScoped` and `@Named` annotations, we can just use the
    `@Model` annotation that aggregates them.
  prefs: []
  type: TYPE_NORMAL
- en: CDI scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CDI Beans come with a set of predefined scopes and annotations, and each CDI
    Bean has a distinct life cycle determined by the scope it belongs to. The following
    table describes the built-in CDI scopes and annotations required to set these
    scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Scope | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@RequestScoped` | The `@RequestScoped` beans are shared during the length
    of a single request. This could be an HTTP request, a remote EJB invocation, a
    web services invocation, or message delivered to a Message Driven Bean (MDB).
    These beans are destroyed at the end of the request. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ConversationScoped` | The `@ConversationScoped` beans are shared across
    multiple requests in the same HTTP session but only if there is an active conversation
    maintained. Conversations are supported for JSF requests through the `javax.enterprise.context.Conversation`
    bean. |'
  prefs: []
  type: TYPE_TB
- en: '| `@SessionScoped` | The `@SessionScoped` beans are shared between all the
    requests that occur in the same HTTP session and destroyed when the session is
    destroyed. |'
  prefs: []
  type: TYPE_TB
- en: '| `@ApplicationScoped` | An `@ApplicationScoped` bean will live for as long
    as the application is running and be destroyed when the application is shut down.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@Dependent` | The `@Dependent` beans are never shared between injection
    points. Any injection of a dependent bean is a new instance whose life cycle is
    bound to the life cycle of the object it is being injected into. |'
  prefs: []
  type: TYPE_TB
- en: 'Other parts of Java EE can extend the list of available scopes. In Java EE
    7 (in the Java Transaction API specification), a new scope has been introduced:
    `@TransactionScoped`. It bounds the life cycle of a bean with the current transaction.
    It is of course possible to introduce your own custom scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter example, we will use the `RequestScoped` and `SessionScoped`
    beans to drive our simple ticket-booking system. In the next chapter, we will
    further enhance our example using `ConversationScoped` beans, which are a peculiar
    scope of CDI Beans. Providing a detailed explanation of all the named beans scopes
    is beyond the scope of this book. However, you can quench your thirst for knowledge
    by having a look at CDI Reference Implementation (JBoss Weld) docs at [http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html](http://docs.jboss.org/weld/reference/latest/en-US/html/scopescontexts.html).
  prefs: []
  type: TYPE_NORMAL
- en: WildFly CDI implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weld is the CDI Reference Implementation that originated as part of the Seam
    3 project ([http://www.seamframework.org/](http://www.seamframework.org/)). Weld
    provides a complete CDI implementation, which can be a part of a Java EE 7 container
    such as WildFly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in order to run CDI-based applications on WildFly, you don''t need
    to download any extra libraries as Weld is part of the server modules, and it
    is included in all server configurations as stated by the following extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Having your module installed, however, does not mean that you can blindly use
    it in your applications. The general rule is that on WildFly, every application
    module is isolated from other modules; this means, by default, it does not have
    visibility on the AS modules, nor do the AS modules have visibility on the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be accurate, we could state that all WildFly modules fall into the following
    three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modules that are implicitly added to your applications**: This category includes
    the most common APIs such as `javax.activation`, `javax.annotation`, `javax.security`,
    `javax.transaction`, `javax.jms`, and `javax.xml`. Using these modules does not
    require any extra effort as WildFly will add them for you if you are referencing
    them in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules that are added on conditions**: This category includes `javax.ejb`,
    `org.jboss.resteasy` and `org.hibernate`, `org.jboss.as.web`, and finally `org.jboss.as.weld`.
    All these modules will be added on the condition that you supply its core annotations
    (such as `@Stateless` for EJB) or its core configuration files, for example, `web.xml`
    for a web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules that need to be explicitly enabled by the application deployer**:
    This includes all other modules, such as your custom modules, that you can add
    to the application server. The simplest way to allow you to have visibility to
    these modules is adding an explicit dependency to your `META-INF/MANIFEST.MF`
    file. For example, if you want to trigger the **log4j** dependency, you have to
    code your manifest file as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is also a custom descriptor file available, which is used by WildFly to
    resolve dependencies – `jboss-deployment-structure.xml`. It allows the developer
    to configure the required dependencies in a fine-grained matter. The file is placed
    in the top-level deployment file, in the `META-INF` directory (or `WEB-INF` for
    a web archive). A sample content of the XML file (along with the XSD schema) is
    available at [https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly](https://docs.jboss.org/author/display/WFLY8/Class+Loading+in+WildFly).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you have followed our checklist carefully, you will be aware that in
    order to let Weld libraries kick in and automatically discover your CDI beans,
    you should add its core configuration file, which is `beans.xml`. This file can
    be placed in your application at the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `WEB-INF` folder if you are developing a web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In your `META-INF` folder if you are deploying a JAR archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `beans.xml` file is based on the following schema reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, it is perfectly legal to place an empty `beans.xml` file in the correct
    location; if you do so, CDI will be enabled in your application. If you, however,
    do not place a `beans.xml` file, then only an annotated subset of classes will
    be considered as beans. In such a case, the container will create beans only for
    classes that are annotated with CDI-related annotations and ignore the rest. Most
    of the times, this is not the behavior we expect, and it differs from the default
    mode in Java EE 6 (when the `beans.xml` file was required).
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the `bean-discovery-mode` attribute is set to `all`
    in our `beans.xml` file. This allows us to configure the CDI discovery mode we
    discussed in the previous paragraph. It states that every legible class in our
    archive will be treated as a managed bean. You can place a `@Vetoed` annotation
    on a class to filter it out from the bean discovery process. It is also possible
    to set the discovery mode to `annotated` so that you can place a scope annotation
    for every class that you would like to use as a bean. This is the default value
    of the newest CDI version (also when there is no `beans.xml`), so be sure to set
    it on for all our samples.
  prefs: []
  type: TYPE_NORMAL
- en: Rethinking your ticketing system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have learned the basics of CDI, we will start re-engineering the ticket-booking
    system using CDI Beans wherever necessary. We will turn it into a leaner application
    by dropping a few items such as remote interfaces or asynchronous methods, which
    are not needed in this example. By doing this, you will be able to focus just
    on the components that are actually used in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new Maven project, just as we did in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: From the **File** menu, go to **New** | **Maven Project**; follow the wizard
    as we did previously (remember to check the **Create a simple project** option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, enter `com.packtpub.wflydevelopment.chapter4` as **Group
    Id**, `ticket-agency-cdi` as **Artifact Id**, and set packaging to **war**:![Rethinking
    your ticketing system](img/00040.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Finish**. The Maven plugin for Eclipse will generate a project structure
    for you that you know from the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The only difference is that besides the standard `java` (for Java classes) and
    `resources` (for configuration files) folders, a new directory named `webapp`
    that will host the web application views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the required dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to compile and run the project, our Maven''s `pom.xml` file will require
    the following set of dependencies known from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also require two plugins from the previous chapter (note that we changed
    the extension of the filename from `jar` to `war`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In case you have any problems with the `POM` configuration file, be sure that
    you check the source code attached to this book and the material from the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your project is properly configured, we can start modeling our beans.
    The first bean we will upgrade is `TheatreBooker`, which will drive the user session,
    accessing the ticket list from our `TheatreBox` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the bean has been tagged as `Named [1]`, which means that it
    can be directly referenced in our JSF pages. The bean is `SessionScoped [2]` since
    it stores the amount of money available to the customer during its session.
  prefs: []
  type: TYPE_NORMAL
- en: We would also like to inject `logger [3]` and `FacesContextFacexContexts [5]`
    instead of manually defining it. To do this, we will need to register a bean that
    produces loggers, which are parameterized with the name of the class. We will
    cover this process of producing beans in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice that we can safely inject EJBs into our CDI Beans using the
    `Inject [4]` annotation. Also, the reverse is perfectly legal, that is, injecting
    CDI Beans into EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to our earlier project, here we don't raise Java exceptions when the
    customer is not able to afford a ticket. Since the application is web based, we
    simply display a warning message to the client using `JSF Faces Messages [6]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other bean that we still use in our application is `TheatreInfo`, which
    has been moved to the `controller` package as it will actually provide the application
    with the list of available seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, have a look at the `@Model` annotation `[1]`, which is an alias (we
    call this kind of annotations **stereotypes**) for two commonly used annotations:
    `@Named` and `@RequestScoped`. Therefore, this bean will be named into our JSF
    page and will carry a request scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, pay attention to the `getSeats` method. This method returns a list of
    seats, exposing it as a `producer` method `[2]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `producer` method allows you to have control over the production of the
    dependency objects. As a Java factory pattern, they can be used as a source of
    objects whose implementation may vary at runtime or if the object requires some
    custom initialization that is not to be performed in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: It can be used to provide any kind of concrete class implementation; however,
    it is especially useful to inject Java EE resources into your application.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using a `@Producer` annotation for the `getSeats` method is
    that its objects can be exposed directly via JSF's **Expression Language** (**EL**),
    as we will see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, another feature of CDI that was unleashed in this example is the **observer**.
    An observer, as the name suggests, can be used to observe events. An observer
    method is notified whenever an object is created, removed, or updated. In our
    example, it allows the list of seats to be refreshed whenever they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be precise, in our example, we are using a conditional observer that is denoted
    by the expression `notifyObserver = Reception.IF_EXISTS`. This means that in practice,
    the `observer` method is only called if an instance of the component already exists.
    If not specified, the default option (`ALWAYS`) will be that the observer method
    is always called. (If an instance doesn't exist, it will be created.)
  prefs: []
  type: TYPE_NORMAL
- en: In the newest CDI version, it is possible to get additional information about
    the fired event in the observer by adding an `EventMetadata` parameter to the
    observer's method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever a change in our list of seats occurs, we will use the `javax.enterprise.event.Event`
    object to notify the observer about the changes. This will be done in our singleton
    bean, which gets injected with the seat''s event `[1]`, and notifies the observer
    by firing the event when a seat is booked `[2]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we mentioned that a preconfigured logger should be injected to a bean
    if it requests it. We will create a simple logger producer that will use the information
    about the injection point (the bean that requests a logger) to configure an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also allowed the injection of `FacesContext` instead of using the standard
    `FacesContext.getCurrentInstance()` static method. This context is used, for example,
    to display the stated error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last class we will include in our project is the `Seat` bean, known from
    the previous chapter, which will be used as our model without any change (remember
    to include it in your project with a proper package).
  prefs: []
  type: TYPE_NORMAL
- en: Building the view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have coded the server side of our example, creating the front end will
    be quite easy, as we have made all our resources available through CDI Beans.
  prefs: []
  type: TYPE_NORMAL
- en: One notable difference between some of the earlier editions of this book is
    that **Facelets** are now the preferred view technology for JSF. Earlier versions
    of JSF used **JavaServer Pages** (**JSP**) as their default view technology. As
    JSP technology predates JSF, using JSP with JSF sometimes felt unnatural or created
    problems. For example, the life cycle of JSPs is different from the life cycle
    of JSF.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compared to the simpler request-response paradigm on which the JSP life cycle
    is based, the JSF life cycle is much more complex since the core of JSF is the
    MVC pattern, which has several implications. User actions in JSF-generated views
    take place in a client that does not have a permanent connection to the server.
    The delivery of user actions or page events is delayed until a new connection
    is established. The JSF life cycle must handle this delay between event and event
    processing. Also, the JSF life cycle must ensure that the view is correct before
    rendering it, and also that the JSF system includes a phase to validate inputs
    and another to update the model only after all the inputs pass validation.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time Facelets are used to build JavaServer Faces views using HTML-style
    templates and component trees. Templating is a useful feature available with Facelets
    that allows you to create a page that will act as the template for the other pages
    in an application (something like Struts Tiles). The idea is to obtain portions
    of reusable code without repeating the same code on different pages.
  prefs: []
  type: TYPE_NORMAL
- en: So here's the main application structure that contains a template page named
    `default.xhtml` that is referenced by views in the template attribute of the page's
    composition element. The template contains two main HTML `div` elements that will
    be used to contain the main application panel (`content`) and a footer div (`footer`),
    which will barely output the application title.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add the template at first, add a new JSF page to the `WEB-INF/templates`
    folder of your application and name it `default.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the main page view, which will be embedded into your template.
    For this purpose, add a JSF page named `index.xhtml` to the `webapp` folder of
    your Maven project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `ui:composition` element is a templating tag that wraps content to be included
    in another Facelet. Specifically, it will be included in the `default.xhtml[1]`
    template.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of the view is done in three steps. First, we will display the
    customer's money `[2]`, which is bound to the session variable called `money`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how we directly reference CDI Beans (for example, `TheatreBooker`) from
    JSF expressions, just as we used to do with JSF Managed Beans.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing on the checklist is printing all JSF messages `[3]` that are
    meant to be produced by the application via the `messages` element.
  prefs: []
  type: TYPE_NORMAL
- en: The main task of this view is to produce a view of all tickets and let the users
    purchase them. This is achieved by means of a `dataTable` object `[3]`that can
    be used to produce a tabular list of objects, which are generally stored as `java.util.List`
    in your beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the value attribute of the `dataTable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we don''t directly reference a CDI Bean, but we reference an
    object that has been produced by a CDI Bean. To be precise, it has been produced
    by `TheatreInfo` that, as we have seen, has a `@Produces` and `@Named` annotation
    on our list of seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This `dataTable` object will be displayed only if it contains some data in it
    (as dictated by the `not empty seats` EL expression). In one of the `dataTable`
    columns, we have added `commandButton [4]` that will be used to book the seat
    displayed on that row. Notice one of the JSF 2 goodies here, as we call the `bookSeat`
    method of `TheatreBooker` passing an argument as one parameter, which is the `seatId`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2 facet suggestions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By enabling JSF 2 facets on your project configuration, you can enjoy some additional
    benefits while designing your views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling JSF 2 project facets takes half a minute. Right-click on your project
    and navigate to **Properties** | **Project Facets**. Then, select the **JSF 2.2
    Project facets** checkbox and click on the **OK** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF 2 facet suggestions](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the JSF facet is enabled, Eclipse will notify you that the JSF library
    configuration is missing; just disable the JSF library configuration that is a
    part of Maven's duty.
  prefs: []
  type: TYPE_NORMAL
- en: Once JSF 2 facets are configured, if you press *Ctrl* + Space bar before referencing
    a field or method, a suggestion pop-up window will let you choose the method or
    attribute of the Bean you want to reference.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready to run the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OK, now your application is almost ready. We just need to configure a JSF mapping
    in a `web.xml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will then run the `FacesServlet` servlet for all the pages at `/faces/*
    url`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as stated previously, in order to activate our `war` file as an explicit
    bean archive, we need to add an empty `beans.xml` file to the `WEB-INF` folder
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you follow the same naming convention used in this chapter, you will
    end up with the following project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready to run the application](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, you must be familiar with building and deploying your Maven
    applications using Eclipse or a shell. Assuming that you are managing your application
    from a shell, start by building up the project using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, publish it using the WildFly Maven plugin, as we did in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the WildFly server is started, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If the WildFly server is not started, you can execute the following command
    and then the WildFly Maven plugin will automatically start an instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The application will be available at `http://localhost:8080/ticket-agency-cdi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to do this with a unique command, you can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After so much work, you will be pleased to have your application running on
    your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready to run the application](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Right now, you will be able to book tickets up to the budget ($ 100) defined
    in your `SessionScoped` bean. So enjoy this first taste of JSF and CDI.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in this chapter, we only scratched the surface of JSF features. There
    is also a new higher-level approach introduced in JSF 2.2 that can be used for
    flow-based scenarios such as a shopping cart. The new feature is called **FacesFlow**
    and comes with a `@FlowScoped` annotation. However, we will now focus on adding
    some other features to our current application.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the scheduler into our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to now, we have not included the scheduler, which was in charge of simulating
    other customer-requesting tickets, into our application. This was not an oversight;
    as a matter of fact, introducing an external system in a web application poses
    some challenges. For example, what if the scheduler updates some data used by
    the application? How will the user know it?
  prefs: []
  type: TYPE_NORMAL
- en: There are several strategies to address this requirement; however, they all
    boil down to using some intelligence in your client application. For example,
    if you are familiar with web scripting languages, you can use the popular jQuery
    API to poll the server for some updates. The newest version of JSF 2.2 comes with
    great support for HTML5 and JavaScript frameworks, thanks to the custom data attributes
    and pass-through elements. These are simple mechanisms that allow the JSF's render
    kit to render parts of the page without any further changes so that custom tags
    may be interpreted by the browser (or a JavaScript framework).
  prefs: []
  type: TYPE_NORMAL
- en: Since not all Java EE developers might be skilled in JavaScript, we would rather
    show a simple and effective way to fulfill our requirement using **RichFaces**
    libraries ([http://www.jboss.org/richfaces](http://www.jboss.org/richfaces)),
    which provide advanced Ajax support along with a rich set of ready-to-use components.
  prefs: []
  type: TYPE_NORMAL
- en: Installing RichFaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Installing RichFaces requires a set of core libraries that are generally available
    at the RichFaces download page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you need to provide a set of third-party dependencies that are
    used by the RichFaces API. Never mind, that''s what Maven is for! Start by adding
    the latest **Bill of Materials** (**BOM**) for the `RichFaces` API in the upper
    dependency-management section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it''s just a matter of adding the rich UI libraries and the core API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Making your application rich
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we have installed RichFaces libraries, we will just need to reference
    them on each XHTML page in your project. Here''s the new `index.xhtml` page using
    the RichFaces namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have highlighted the core enhancements added to this page. At first, as we
    said, we need to reference the RichFaces libraries at the top of the XHTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added a rich Ajax component, **a4j:poll**, which does a simple but
    an effective job of polling the server for updates, allowing the re-rendering
    of our components—`grid` (which contains the main datatable), `poller` (to check
    whether it should still be running), and `bookedCounter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, this component references a CDI bean named `Poller`, which acts
    just as an on/off flag for our poller. We expect to turn off polling as soon as
    all the seats are sold out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our seller service stays nearly the same as in the previous chapter (the only
    difference is the `logger` injection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add a booking record, which will be bounded with the current
    view using the view scope. Its role will be to count the number of bookings done
    by the user in the current view (a single browser tab is considered a single view):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can experiment with the booked counter by trying to book tickets via two
    separate tabs in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we placed two annotations on the bean: `@Named`
    and `@ViewScoped`. If you would like to define multiple beans with a specific
    set of CDI annotations, it would be a good idea to create your own custom annotation
    that already contains the desired ones. This kind of construction is called a
    stereotype. It is possible to incorporate the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A default scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, interceptor bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a `@Named` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, an `@Alternative` annotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a stereotype, you need to add the wanted annotations along with the
    `@Stereotype` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can define the `BookinRecord` bean as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `@Model` stereotype is available in CDI by default. It defines a request
    scoped named bean, and you can use it on your beans right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With all the libraries in place, you can now test run your new rich application.
    As you can see, every 30 seconds a ticket is sold out and buttons are turned,
    in real time, into **Not available**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the application](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating interceptors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is one more CDI feature worth mentioning here, the interceptors. Sometimes,
    applications contain logic and cross-cutting multiple layers; the most simple
    example is logging. Under the Java EE platform, it can be achieved using interceptors.
    First, we need to create a new annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This annotation defines an interceptor binding. It can be used to specify methods
    that you would like to intercept. The bindings can be used on types as well; in
    that case, every method call on that type is intercepted. The most important part
    of this definition is the `@InterceptorBinding [1]` annotation. Be sure to add
    it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have to create the interceptor definition itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We start by stating that our class is `@Interceptor` and it will be using the
    interceptor binding that we've defined earlier (`@Logged [1]`). Next, we create
    a method log that will be executed around every method execution (`@AroundInvoke
    [2]`) on annotated classes. Inside of it, we will call the `context.proceed()`
    method that will basically forward the call to the original receiver. Note that
    the interceptor can decide (based on some security logic, for instance) whether
    the call should be dropped. It could even analyze or change the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to enable it in the `beans.xml` file by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s move on to just the annotated classes or methods that you want
    to log using the `@Logged` annotation. For instance, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'All calls to the `TheatreBooker` public methods will now be logged in to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the case of multiple interceptors, the order in which they are executed is
    determined by the `@Interceptor.Priority` annotation. Interceptors with lowest
    priorities will be called first. Be sure to check the constants defined in the
    `Priority` annotation. Your own interceptor's priorities should be between the
    `APPLICATION` and `LIBRARY_AFTER` scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also other interesting CDI mechanisms that we will not cover in this
    book, but are definitely worth exploring: decorators and alternatives. Decorators
    are basically strongly typed interceptors that are focused on the business logic
    of your application. Alternatives can be used to provide alternative implementations
    for specific beans.'
  prefs: []
  type: TYPE_NORMAL
- en: Are EJBs and JSF Managed Beans obsolete?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the end of this chapter, we would like to give our honest opinion about a
    common question posed by developers, that is, how EJB, JSF Managed Beans, and
    CDI interact and where the boundary between them lies. Are there redundancies
    between them? It is indeed a bit confusing since there are now multiple component
    models available in Java EE.
  prefs: []
  type: TYPE_NORMAL
- en: JSF Managed Beans have been, for a long time, the actual glue between the application
    view and the business methods. Since Release 2.0 of JSF, you can declare JSF Managed
    Beans via an annotation, and the scopes are expanded with a **view scope** and
    the ability to create custom scopes. However, there is very little still going
    on for JSF Managed Beans. Most of its features can be replaced by CDI Beans that
    are much more flexible and allow you to have a better integration with other Java
    EE components. Even the view scope, in the newest version of JSF, has been implemented
    as a CDI custom scope (`javax.faces.view.ViewScoped`), which replaces the old
    `javax.faces.bean.ViewScoped` (notice the name of the package; it's a common mistake
    to mix them up).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, EJBs, even though they use a less flexible injection mechanism,
    still maintain some unique features such as schedulable timers, asynchronous operations,
    and pooling that are essential for throttling and assuring that the application
    provides a good quality of service. Beginning from Java EE 7, EJBs no longer are
    the only components that have a transactional nature. The new `@Transactional`
    annotation allows you to use declarative transactions in CDI beans by simply placing
    it on selected methods.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, it's likely that EJBs are not disappearing from our code, rather
    it is likely (and desirable too) that they will continue to be used for some of
    their unique features. For the remaining part though, its functionality will be
    exposed via CDI instead of EJBs' own annotations such as `@Stateless` and `@EJB`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an introduction to CDI. We covered how JSF pages
    can access CDI-named beans as if they were JSF Managed Beans. We also covered
    how CDI makes it easy to inject dependencies into our code via the `@Inject` annotation.
    Additionally, we explained how we can add another library of the JBoss ecosystem
    (RichFaces) uncovering just one aspect of its potentiality.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we have worked with in-memory data, so it's time to introduce storage
    for our CDI applications using the Java Persistence API, which is the theme of
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
