<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;JSF 2.2 &#x2013; HTML5 and Upload"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. JSF 2.2 – HTML5 and Upload</h1></div></div></div><p>This chapter can be read in two parts. The first part will present the JSF 2.2 support for HTML5, while the second part discusses the new <span class="strong"><strong>upload</strong></span> component of JSF 2.2. Apparently, these two parts are not related, but as you will see, the upload component of JSF 2.2 can be spiced up with HTML5 features and the new pass-through attributes can be very helpful to extend the upload component of JSF 2.2 with HTML5 upload component facilities.</p><div class="section" title="Working with HTML5 and JSF 2.2"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Working with HTML5 and JSF 2.2</h1></div></div></div><p>Everybody involved <a id="id1088" class="indexterm"/>in web application development is enthusiastic to explore and use HTML5, which comes with a suite of new components and features, such as <code class="literal">&lt;audio&gt;</code>, <code class="literal">&lt;video&gt;</code>, <code class="literal">&lt;keygen&gt;</code>, and so on. Starting with version 2.2, JSF developers can interact with HTML5 using the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pass-through attributes</li><li class="listitem" style="list-style-type: disc">Pass-through elements (HTML-friendly markup)</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note149"/>Note</h3><p>Although pass-through elements and pass-through attributes are inspired by HTML5, they are JSF elements that might be used with other HTML versions as well.</p></div></div><p>These mechanisms are the alternative to writing custom render kits. This is a great solution, because HTML5 is in the developing stage, which means that writing and adapting render kits to constant HTML5 changes can be a real challenge.</p><p>If you want to use HTML5 with JSF 2.0, then you need to write custom render kits for supporting the new components and attributes.</p><div class="section" title="Pass-through attributes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Pass-through attributes</h2></div></div></div><p>Starting<a id="id1089" class="indexterm"/> with JSF 2.2, we have attributes that are processed by JSF components on the server side and <span class="strong"><strong>pass-through attributes</strong></span> that <a id="id1090" class="indexterm"/>are processed at runtime on the client side.</p><p>A handy HTML5 element that can be used for exemplifying pass-through attributes is the <code class="literal">&lt;input&gt;</code> element. Among the new supported features, we have new values for <code class="literal">type</code> attribute (such as, <code class="literal">email</code>, <code class="literal">tel</code>, <code class="literal">color</code>, and <code class="literal">reset</code>) and the new attribute, <code class="literal">placeholder</code> (a text used as a hint in empty fields).</p><p>In pure HTML5, such an element can be as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;input placeholder="Enter player e-mail" type="email"&gt;</pre></div><p>The same thing can be obtained with pass-through attributes in five different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Place the pass-through attributes in the new namespace <code class="literal">http://xmlns.jcp.org/jsf/passthrough</code> (any JSF developer is familiar with namespaces and prefixed elements. There is no trick to use this namespace or prefixed attributes). Let's see how to obtain the preceding HTML5 element using JSF pass-through attributes, as follows:<div class="informalexample"><pre class="programlisting">&lt;html 
      
<span class="strong"><strong>      </strong></span>
      &gt;
    
 ...
 &lt;h:body&gt;
  &lt;h:inputText value="#{playersBean.email}" 
               f5:type="email" f5:placeholder="Enter player e-mail"/&gt;            
...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note150"/>Note</h3><p>When this book was written, there was still a debate about which is the proper prefix for this namespace. Initially, <code class="literal">p</code> was chosen, but this is recognized as the prefix of PrimeFaces; therefore, another prefix had to be used. So, when you read this book, feel free to replace <code class="literal">f5</code> (used here) with the one that wins this debate and becomes more popular.</p></div></div></li><li class="listitem" style="list-style-type: disc">Use <code class="literal">&lt;f:passThroughAttribute&gt;</code> nested in <code class="literal">&lt;h:inputText&gt;</code>, as follows:<div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{playersBean.email}"&gt;
 &lt;f:passThroughAttribute name="placeholder" 
                         value="Enter player e-mail" /&gt;
 &lt;f:passThroughAttribute name="type" value="email" /&gt;
&lt;/h:inputText&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Pass-through attributes might come from a managed bean also. Place them in a <code class="literal">Map&lt;String, String&gt;</code>, where the map key is the attribute name and the map value is the attribute value, as follows:<div class="informalexample"><pre class="programlisting">private Map&lt;String, String&gt; attrs = new HashMap&lt;&gt;();
...
attrs.put("type", "email");
attrs.put("placeholder", "Enter player e-mail");</pre></div><p>Further, use <code class="literal">&lt;f:passThroughAttributes&gt;</code> tag, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{playersBean.email}"&gt;
 &lt;f:passThroughAttributes value="#{playersBean.attrs}" /&gt;
&lt;/h:inputText&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Using Expression Language 3 (part of Java EE 7), multiple attributes can also be directly defined, as follows (practically, you define a <code class="literal">Map&lt;String, String&gt; </code>via EL 3):<div class="informalexample"><pre class="programlisting">&lt;h:inputText value="#{playersBean.email}"&gt;
 &lt;f:passThroughAttributes value='#{{"placeholder":"Enter player e-mail", "type":"email"}}' /&gt;
&lt;/h:inputText&gt;</pre></div><p>The complete example is available in the code bundle of this chapter and is named <code class="literal">ch8_1</code>.</p></li><li class="listitem" style="list-style-type: disc">Pass-through attributes <a id="id1091" class="indexterm"/>can be added programmatically. For example, you can generate an HTML5 input element and add it into a form, as follows:<div class="informalexample"><pre class="programlisting">&lt;h:body&gt;        
 &lt;h:form id="playerForm"&gt;
 ...
 &lt;/h:form&gt;
&lt;/h:body&gt;
...
FacesContext facesContext = FacesContext.getCurrentInstance();
UIComponent formComponent = facesContext.getViewRoot().
                                  findComponent("playerForm");
        
HtmlInputText playerInputText = new HtmlInputText();
Map passThroughAttrs = playerInputText.getPassThroughAttributes();
passThroughAttrs.put("placeholder", "Enter player email");
passThroughAttrs.put("type", "email");        

formComponent.getChildren().add(playerInputText);
...</pre></div><p>The complete example is available on the code bundle of this chapter and is named <code class="literal">ch8_1_2</code>.</p></li></ul></div></div><div class="section" title="Pass-through elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Pass-through elements</h2></div></div></div><p>JSF developers<a id="id1092" class="indexterm"/> hide HTML code behind JSF components. For web designers, the JSF code may look pretty strange, but the generated HTML is more familiar. In order to alter the generated HTML, web designers have to modify the JSF code, which can be difficult for them. But JSF 2.2 comes with friendly markup for HTML5, known as<a id="id1093" class="indexterm"/> <span class="strong"><strong>pass-through elements</strong></span>. Using this feature, web designers can write pure HTML code and JSF developers can come over and link the HTML elements to the server side by adding/replacing the necessary attributes. JSF recognizes such attributes if they are in the <a class="ulink" href="http://xmlns.jcp.org/jsf">http://xmlns.jcp.org/jsf</a> namespace. For example, we can write a JSF page without any JSF tag, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      &gt;

 &lt;head jsf:id="head"&gt;
  &lt;title&gt;&lt;/title&gt;
 &lt;/head&gt;

 &lt;body jsf:id="body"&gt;
  &lt;form jsf:id="form"&gt;
   Name:&lt;input type="text" jsf:value="#{playersBean.playerName}"/&gt;
   Surname:&lt;input type="text" jsf:value="#{playersBean.playerSurname}"/&gt;
   &lt;button jsf:action="#{playersBean.playerAction()}"&gt;Show&lt;/button&gt;
  &lt;/form&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note151"/>Note</h3><p>JSF scans the HTML elements for attributes in the namespace <a class="ulink" href="http://xmlns.jcp.org/jsf">http://xmlns.jcp.org/jsf</a>. For such elements, JSF will determine the element type and will add the corresponding JSF component instead (<code class="literal">&lt;h:head&gt;</code> for <code class="literal">&lt;head&gt;</code> and <code class="literal">&lt;h:inputText&gt;</code> for <code class="literal">&lt;input&gt;</code>). JSF will add the components in the component tree, which will be rendered as HTML code to the client. This JSF component will be linked to the particular element and will receive the attributes as "normal" attributes or as pass-through attributes, depending on their origins. The correspondence between JSF components and HTML elements is available at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html">http://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagDecorator.html</a>. For HTML elements that don't have a direct correspondent (for example <code class="literal">&lt;div&gt;</code> and <code class="literal">&lt;span&gt;</code>), JSF will create a special component, component-family, such as <code class="literal">javax.faces.Panel</code>, and render-type <code class="literal">javax.faces.passthrough.Element</code> as detailed at <a class="ulink" href="http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html">http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/jsf/element.html</a>.</p></div></div><p>The complete<a id="id1094" class="indexterm"/> example <a id="id1095" class="indexterm"/>is available in the code bundle of this chapter and is named <code class="literal">ch8_1_3</code>.</p><p>Since JSF replaces the HTML elements with JSF components, we can use these components at full capacity, meaning that we can use them as in JSF. For example, we can use validators, converters, and <code class="literal">&lt;f:param&gt;</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      
      &gt;

 &lt;head jsf:id="head"&gt;
  &lt;title&gt;&lt;/title&gt;
 &lt;/head&gt;
 &lt;body jsf:id="body"&gt;
  &lt;form jsf:id="form"&gt;
   Name:
   &lt;input type="text" jsf:value="#{playersBean.playerName}"&gt;                               
    &lt;f:validator validatorId="playerValidator"/&gt;
   &lt;/input&gt;    
   &lt;!-- or, like this --&gt;
  &lt;input type="text" jsf:value="#{playersBean.playerName}" 
                     jsf:validator="playerValidator"/&gt;
   Surname:
   &lt;input type="text" jsf:value="#{playersBean.playerSurname}"&gt;      
    &lt;f:validator validatorId="playerValidator"/&gt;
   &lt;/input&gt;
   &lt;!-- or, like this --&gt;
   &lt;input type="text" jsf:value="#{playersBean.playerSurname}"       
                      jsf:validator="playerValidator"/&gt;
   &lt;button jsf:action="#{playersBean.playerAction()}"&gt;Show
    &lt;f:param id="playerNumber" name="playerNumberParam" value="2014"/&gt;                 
   &lt;/button&gt;
  &lt;/form&gt;
 &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The complete example is available in the code bundle of this chapter and is named <code class="literal">ch8_1_4</code>.</p></div><div class="section" title="JSF 2.2 – HTML5 and Bean Validation 1.1 (Java EE 7)"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec86"/>JSF 2.2 – HTML5 and Bean Validation 1.1 (Java EE 7)</h2></div></div></div><p>The <a id="id1096" class="indexterm"/>Bean Validation 1.1 (see <a class="ulink" href="http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm">http://docs.oracle.com/javaee/7/tutorial/doc/partbeanvalidation.htm</a>) can be the perfect choice for validating user inputs in a JSF 2.2/HTML5 application. For example, we can validate the submitted name and surname in <code class="literal">PlayersBean</code>, as follows—we don't accept null values, empty values, or values shorter than three characters:</p><div class="informalexample"><pre class="programlisting">@Named
@RequestScoped
public class PlayersBean {

    private static final Logger logger = Logger.getLogger(PlayersBean.class.getName());
    
    @NotNull(message = "null/empty values not allowed in player name")
    @Size(min = 3,message = "Give at least 3 characters for player name")
    private String playerName;
    @NotNull(message = "null/empty values not allowed in player surname")
    @Size(min = 3,message = "Give at least 3 characters for player surname")
    private String playerSurname;
    ...</pre></div><p>JSF can interpret empty string submitted values as <code class="literal">null</code> if you set the following context parameter in <code class="literal">web.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;context-param&gt;
 &lt;param-name&gt;
  javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL
 &lt;/param-name&gt;
 &lt;param-value&gt;true&lt;/param-value&gt;
&lt;/context-param&gt;</pre></div><p>So in this case, there is no need to use the <code class="literal">&lt;f:validator&gt;</code> or <code class="literal">validator</code> attribute. Check out the complete application named <code class="literal">ch8_2</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note152"/>Note</h3><p>OmniFaces provides an HTML5 render kit that extends support for HTML5 specific attributes. You may want to check it out at <a class="ulink" href="http://showcase.omnifaces.org/">http://showcase.omnifaces.org/</a>.</p></div></div></div></div></div>
<div class="section" title="JSF 2.2 upload feature"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>JSF 2.2 upload feature</h1></div></div></div><p>JSF developers <a id="id1097" class="indexterm"/>have waited a long time for a built-in upload component. Until JSF 2.2, the workarounds consisted of using JSF extensions, such as PrimeFaces, RichFaces, and third-party libraries such as Apache Commons FileUpload.</p><p>JSF 2.2 comes with an input component dedicated for upload tasks (that renders an HTML <code class="literal">input</code> element of type <code class="literal">file</code>). This component is represented by the <code class="literal">&lt;h:inputFile&gt;</code> tag<a id="id1098" class="indexterm"/> and it can be used as any other JSF component. The entire list of supported attributes is available at <a class="ulink" href="http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html">http://docs.oracle.com/javaee/7/javaserverfaces/2.2/vdldocs/facelets/h/inputFile.html</a>, but the most important ones are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">value</code>: This represents the file to be uploaded as a <code class="literal">javax.servlet.http.Part</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">required</code>: This is a Boolean value. If it is <code class="literal">true</code>, the user must provide a value to submit.</li><li class="listitem" style="list-style-type: disc"><code class="literal">validator</code>: This indicates a validator for this component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">converter</code>: This indicates a converter for this component.</li><li class="listitem" style="list-style-type: disc"><code class="literal">valueChangeListener</code>: This indicates a method that will be called when the component's value is changed.</li></ul></div><p>The <code class="literal">&lt;h:inputFile&gt;</code> component<a id="id1099" class="indexterm"/> is based on Servlet 3.0, which is part of Java EE since version 6. Servlet 3.0 provides an upload mechanism based on the <code class="literal">javax.servlet.http.Part</code> interface and the <code class="literal">@MultipartConfig</code> annotation. A simple Servlet 3.0 for upload files looks like the following code—keep in mind this servlet because we will use it in the last section of this chapter:</p><div class="informalexample"><pre class="programlisting">@WebServlet(name = "UploadServlet", urlPatterns = {"/UploadServlet"})
@MultipartConfig(location="/folder", fileSizeThreshold=1024*1024, 
                 maxFileSize=1024*1024*3, maxRequestSize=1024*1024*3*3)
public class UploadServlet extends HttpServlet {

 @Override
 protected void doPost(HttpServletRequest request, 
                       HttpServletResponse response)
  throws ServletException, IOException {

  for (Part part : request.getParts()) {
       String filename = "";
       for (String s: part.getHeader("content-disposition").split(";")) {
            if (s.trim().startsWith("filename")) {
                filename = s.split("=")[1].replaceAll("\"", "");
            }
       }
       part.write(filename);
  }
 }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note153"/>Note</h3><p>If you take a quick look over the JSF 2.2 <code class="literal">FacesServlet</code> source code, you will notice that it was annotated with <code class="literal">@MultipartConfig</code> especially for handling multipart data.</p></div></div><p>If you are not familiar with uploading files using Servlet 3.0, then you can try the tutorial at <a class="ulink" href="http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html">http://docs.oracle.com/javaee/6/tutorial/doc/glrbb.html</a>.</p><p>On the client side, you can use a <code class="literal">&lt;form&gt;</code> tag and an HTML5 input of type <code class="literal">file</code>:</p><div class="informalexample"><pre class="programlisting">&lt;form action="UploadServlet" enctype="multipart/form-data" method="POST"&gt;
  &lt;input type="file" name="file"&gt;
  &lt;input type="Submit" value="Upload File"&gt;
&lt;/form&gt;</pre></div><p>Basically, JSF 2.2 upload component is just a wrapper of this example.</p><div class="section" title="A simple JSF 2.2 upload example"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec87"/>A simple JSF 2.2 upload example</h2></div></div></div><p>In this section, we <a id="id1100" class="indexterm"/>will cover the fundamental steps of a JSF 2.2 upload application. Even if this is a simple example, you will see that further examples are based on this one. So in order to use the <code class="literal">&lt;h:inputFile&gt;</code> component, you need to focus on the client side and on the server side:</p><p>On the client side, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, the <code class="literal">&lt;h:form&gt;</code> encoding must be set to multipart/form-data, which will help the browser to build the <code class="literal">POST</code> request accordingly, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;h:form id="uploadFormId" enctype="multipart/form-data"&gt;</pre></div></li><li class="listitem">Second, the <code class="literal">&lt;h:inputFile&gt;</code> must be configured to respect your needs, Here, we provide a simple case, as follows:<div class="informalexample"><pre class="programlisting">&lt;h:inputFile id="fileToUpload" required="true" 
              requiredMessage="No file selected ..." 
              value="#{uploadBean.file}"/&gt;   </pre></div></li><li class="listitem">Further, you need a button (or a link) to start the upload process, as follows:<div class="informalexample"><pre class="programlisting">&lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"/&gt;</pre></div></li></ol></div><p>Optionally, you<a id="id1101" class="indexterm"/> can add some tags for handling upload messages, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:messages globalOnly="true" showDetail="false" 
            showSummary="true" style="color:red"/&gt;
&lt;h:form id="uploadFormId" enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload" required="true" 
              requiredMessage="No file selected ..." 
              value="#{uploadBean.file}"/&gt;                       
 &lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"/&gt;             
 &lt;h:message showDetail="false" showSummary="true" 
            for="fileToUpload" style="color:red"/&gt;
&lt;/h:form&gt;</pre></div><p>On the server side, we need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Usually, the <code class="literal">value</code> attribute of <code class="literal">&lt;h:inputFile&gt;</code> contains an EL expression of type <code class="literal">#{</code><span class="emphasis"><em>upload_bean.part_object</em></span><code class="literal">}</code>. If you replace <span class="emphasis"><em>upload_bean</em></span> with <code class="literal">uploadBean</code> and <span class="emphasis"><em>part_object</em></span> with <code class="literal">file</code>, you will obtain <code class="literal">#{uploadBean.file}</code>. The <code class="literal">file</code> object is used to store the uploaded data as an instance of <code class="literal">javax.servlet.http.Part</code> in the <code class="literal">UploadBean</code> bean. All you have to do is to define the <code class="literal">file </code>property in the same manner as any other property, as shown in the following code:<div class="informalexample"><pre class="programlisting">import javax.servlet.http.Part;
...
private Part file;
...
public Part getFile() {
 return file;
}

public void setFile(Part file) {
 this.file = file;
}
...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note154"/>Note</h3><p>The uploaded data can be read through the <code class="literal">getInputStream</code> method of <code class="literal">Part</code>.</p></div></div></li><li class="listitem">When the button labeled <span class="strong"><strong>Upload</strong></span> is clicked, the <code class="literal">upload</code> method is called. When this method is called, the <code class="literal">file</code> object is already populated with the uploaded bytes; therefore, you can obtain the data as a stream (use the <code class="literal">getInputStream</code> method) and process it accordingly. For example, you can use the <code class="literal">Scanner</code> API to extract the data into a <code class="literal">String</code>, as follows:<div class="informalexample"><pre class="programlisting">public void upload() {
 try {
     if (file != null) {
         Scanner scanner = new Scanner(file.getInputStream(), 
                                   "UTF-8").useDelimiter("\\A");
         fileInString = scanner.hasNext() ? scanner.next() : "";

         FacesContext.getCurrentInstance().addMessage(null, 
                 new FacesMessage("Upload successfully ended!"));
         }
     } catch (IOException | NoSuchElementException e) {
       FacesContext.getCurrentInstance().addMessage(null, 
                     new FacesMessage("Upload failed!"));
 }
}</pre></div></li></ol></div><p>The complete <a id="id1102" class="indexterm"/>application is available in the code bundle of this chapter and is named <code class="literal">ch8_3</code>. In this case, the uploaded data is converted into string and displayed in a log; therefore, try to upload readable information, such as plain text files.</p></div><div class="section" title="Using multiple &lt;h:inputFile&gt; elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Using multiple &lt;h:inputFile&gt; elements</h2></div></div></div><p>If you ask <a id="id1103" class="indexterm"/>yourself whether you can <a id="id1104" class="indexterm"/>use more than one <code class="literal">&lt;h:inputFile&gt;</code> element in a <code class="literal">&lt;h:form&gt;</code> form, the answer is yes. Specify an ID for each <code class="literal">&lt;h:inputFile&gt;</code> element and associate it with a unique <code class="literal">Part</code> instance. In order to use two <code class="literal">&lt;h:inputFile&gt;</code> elements, the <code class="literal">&lt;h:form&gt;</code> form will change to the following code—you can easily extrapolate this example for three, four, or more <code class="literal">&lt;h:inputFile&gt;</code> elements:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="uploadFormId" enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload_1" required="true" 
              requiredMessage="No file selected ..." 
              value="#{uploadBean.file1}"/&gt;           
 &lt;h:inputFile id="fileToUpload_2" required="true" 
              requiredMessage="No file selected ..." 
              value="#{uploadBean.file2}"/&gt;
 ...           
 &lt;h:message showDetail="false" showSummary="true" 
            for="fileToUpload_1" style="color:red"/&gt;
 &lt;h:message showDetail="false" showSummary="true" 
            for="fileToUpload_2" style="color:red"/&gt;
 ...
 &lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"/&gt;
&lt;/h:form&gt;</pre></div><p>Now, on the <a id="id1105" class="indexterm"/>server side, you need two <code class="literal">Part</code> instances, defined as follows:</p><div class="informalexample"><pre class="programlisting">...
private Part file1;
private Part file2;
...
//getter and setter for both, file1 and file2
...</pre></div><p>In the <code class="literal">upload</code> method, you need to process both <code class="literal">Part</code> instances:</p><div class="informalexample"><pre class="programlisting">...
if (file1 != null) {
    Scanner scanner1 = new Scanner(file1.getInputStream(), 
                       "UTF-8").useDelimiter("\\A");
    fileInString1 = scanner1.hasNext() ? scanner1.next() : "";
    FacesContext.getCurrentInstance().addMessage(null, new 
          FacesMessage("Upload successfully ended for file 1!"));
}

if (file2 != null) {
    Scanner scanner2 = new Scanner(file2.getInputStream(), 
                       "UTF-8").useDelimiter("\\A");
    fileInString2 = scanner2.hasNext() ? scanner2.next() : "";
    FacesContext.getCurrentInstance().addMessage(null, new 
          FacesMessage("Upload successfully ended for file 2!"));
}
...</pre></div><p>Done! The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_4</code>.</p></div><div class="section" title="Extracting info about a file to be uploaded"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec89"/>Extracting info about a file to be uploaded</h2></div></div></div><p>Filename, size, and <a id="id1106" class="indexterm"/>content type are the most common types of information needed when uploading a file. In JSF, this information is available on both the client side and the server side. Let's consider the following <code class="literal">&lt;h:inputFile&gt;</code> element:</p><div class="informalexample"><pre class="programlisting">&lt;h:form id="formUploadId" enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload" value="#{uploadBean.file}"  
              required="true" requiredMessage="No file selected ..."&gt;                                      
 ...
 &lt;/h:inputFile&gt;
&lt;/h:form&gt;</pre></div><p>Now you will see how to extract the information about the file selected for upload.</p><p>On the client side, we need to perform either of the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extracting the filename, size (in bytes), and the content type on the client side can be accomplished in a JavaScript function, as follows:<div class="informalexample"><pre class="programlisting">var file = document.getElementById('formUploadId:fileToUpload').files[0];
...
alert(file.name);
alert(file.size);
alert(file.type);</pre></div></li><li class="listitem" style="list-style-type: disc">Another approach is to use EL in a JSF page, as follows (of course, this works after the file is uploaded):<div class="informalexample"><pre class="programlisting">// the id of the component, formUploadId:fileToUpload
#{uploadBean.file.name}

// the uploaded file name
#{uploadBean.file.submittedFileName}

// the uploaded file size
#{uploadBean.file.size}

// the uploaded file content type
#{uploadBean.file.contentType}</pre></div></li></ul></div><p>On the server side, we need to perform either of the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extracting the filename, size (in bytes), and the content type on server side can be accomplished through several methods of the <code class="literal">Part</code> interface, as follows:<div class="informalexample"><pre class="programlisting">...
private Part file;
...
System.out.println("File component id: " + file.getName());
System.out.println("Content type: " + file.getContentType());
System.out.println("Submitted file name:" + file.getSubmittedFileName());            
System.out.println("File size: " + file.getSize());
...</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note155"/>Note</h3><p>If the string returned by this method represents the entire path instead of the filename, then you have to isolate the filename as a substring of this string.</p></div></div></li><li class="listitem" style="list-style-type: disc">The filename <a id="id1107" class="indexterm"/>can be obtained from the <code class="literal">content-disposition</code> header as well using the following code:<div class="informalexample"><pre class="programlisting">private String getFileNameFromContentDisposition(Part file) {

 for (String content:file.getHeader("content-disposition").split(";")) {
      if (content.trim().startsWith("filename")) {
          return content.substring(content.indexOf('=') + 
                                     1).trim().replace("\"", "");
      }
 }

 return null;
}</pre></div><p>An example of the <code class="literal">content-disposition</code> header can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_08_01.jpg" alt="Extracting info about a file to be uploaded"/></div></li></ul></div><p>This is very easy to understand if you inspect the <code class="literal">POST</code> request (you can do this with Firebug or any other specialized tool). In the preceding screenshot, you can see the relevant chunk of request that is depicted in the <code class="literal">getFileNameFromContentDisposition</code> method.</p><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_5</code>.</p></div><div class="section" title="Writing uploaded data to a disk"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec90"/>Writing uploaded data to a disk</h2></div></div></div><p>In the <a id="id1108" class="indexterm"/>previous examples, the uploaded data was converted to <code class="literal">String</code> and displayed on a console. Normally, when you upload a file, you want to save its content on a disk in a specific location (let's say, the <code class="literal">D:\files</code> folder). For this, you can use <code class="literal">FileOutputStream</code>, as follows:</p><div class="informalexample"><pre class="programlisting">   try (InputStream inputStream = file.getInputStream(); 
        FileOutputStream outputStream = new FileOutputStream("D:" +
        File.separator + "files" + File.separator + getSubmittedFileName())) {

     int bytesRead = 0;
     final byte[] chunck = new byte[1024];
     while ((bytesRead = inputStream.read(chunck)) != -1) {
             outputStream.write(chunck, 0, bytesRead);
     }

     FacesContext.getCurrentInstance().addMessage(null, new 
             FacesMessage("Upload successfully ended!"));
     } catch (IOException e) {
              FacesContext.getCurrentInstance().addMessage(null, new 
                                     FacesMessage("Upload failed!"));
     }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note156"/>Note</h3><p>If you want buffered I/O, then add <code class="literal">BufferedInputStream</code> and <code class="literal">BufferedOutputStream</code> into your code.</p></div></div><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_6</code>. If you prefer to obtain the filename from the <code class="literal">content-disposition</code> header, you better check the application <code class="literal">ch8_7</code>.</p><p>Another approach consists of using the <code class="literal">Part.write</code> method. In this case, you have to indicate the location where the file should be saved through the <code class="literal">&lt;multipart-config&gt;</code> tag (<a class="ulink" href="http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm">http://docs.oracle.com/javaee/7/tutorial/doc/servlets011.htm</a>). Moreover, you can set the maximum file size, request size, and the file size threshold; these configurations should be added in <code class="literal">web.xml</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;servlet&gt;
 &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
 &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
 &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
 &lt;multipart-config&gt;
  &lt;location&gt;D:\files&lt;/location&gt;
  &lt;max-file-size&gt;1310720&lt;/max-file-size&gt;
  &lt;max-request-size&gt;20971520&lt;/max-request-size&gt;
  &lt;file-size-threshold&gt;50000&lt;/file-size-threshold&gt;
 &lt;/multipart-config&gt;
&lt;/servlet&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note157"/>Note</h3><p>If you don't specify a location, the default one will be used. The default location is "".</p></div></div><p>The uploaded file <a id="id1109" class="indexterm"/>will be saved in the indicated location under the name passed to the <code class="literal">Part.write</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">try {
    file.write(file.getSubmittedFileName());
    FacesContext.getCurrentInstance().addMessage(null, new 
                  FacesMessage("Upload successfully ended!"));
    } catch (IOException e) {
      FacesContext.getCurrentInstance().addMessage(null, new 
                  FacesMessage("Upload failed!"));
    }</pre></div><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_8</code>.</p></div><div class="section" title="Upload validator"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec91"/>Upload validator</h2></div></div></div><p>In most cases, you <a id="id1110" class="indexterm"/>need to restrict the user upload based on certain constraints. Commonly, you will limit the filename length, file size, and file content type. For example, you may want to reject the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Files that have names bigger than 25 characters</li><li class="listitem" style="list-style-type: disc">Files that are not PNG or JPG images</li><li class="listitem" style="list-style-type: disc">Files that are bigger than 1 MB in size</li></ul></div><p>For this, you can write a JSF validator, as follows:</p><div class="informalexample"><pre class="programlisting">@FacesValidator
public class UploadValidator implements Validator {

 private static final Logger logger = 
         Logger.getLogger(UploadValidator.class.getName());

 @Override
 public void validate(FacesContext context, UIComponent component, 
                             Object value) throws ValidatorException {

  Part file = (Part) value;

  //VALIDATE FILE NAME LENGTH
  String name = file.getSubmittedFileName();
  logger.log(Level.INFO, "VALIDATING FILE NAME: {0}", name);
  if (name.length() == 0) {
      FacesMessage message = new FacesMessage("Upload Error: Cannot 
                                        determine the file name !");
      throw new ValidatorException(message);
  } else if (name.length() &gt; 25) {
    FacesMessage message = new FacesMessage("Upload Error: 
                                        The file name is to long !");
    throw new ValidatorException(message);
  }

  //VALIDATE FILE CONTENT TYPE
  if ((!"image/png".equals(file.getContentType())) &amp;&amp; 
                      (!"image/jpeg".equals(file.getContentType()))) {
       FacesMessage message = new FacesMessage("Upload Error: Only images can be uploaded (PNGs and JPGs) !");
       throw new ValidatorException(message);
  }

  //VALIDATE FILE SIZE (not bigger than 1 MB)
  if (file.getSize() &gt; 1048576) {
      FacesMessage message = new FacesMessage("Upload Error: Cannot 
                                 upload files larger than 1 MB !");
      throw new ValidatorException(message);
  }
 }
}</pre></div><p>Next, add the validator to the <code class="literal">&lt;h:inputFile&gt;</code> element, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:inputFile id="fileToUpload" required="true" 
             requiredMessage="No file selected ..." 
             value="#{uploadBean.file}"&gt;           
 &lt;f:validator validatorId="uploadValidator" /&gt;
&lt;/h:inputFile&gt;</pre></div><p>Now, only the files<a id="id1111" class="indexterm"/> that meet our constraints will be uploaded. For each rejected file, you will see an info message that will signal if the filename or its size is too big, or whether the file is a PNG or JPG image.</p><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_9</code>.</p></div><div class="section" title="Ajaxify the upload"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec92"/>Ajaxify the upload</h2></div></div></div><p>A JSF upload <a id="id1112" class="indexterm"/>can take advantages of the AJAX mechanism by combining the <code class="literal">&lt;h:inputFile&gt;</code> tag with <code class="literal">&lt;f:ajax&gt;</code> or the <code class="literal">&lt;h:commandButton&gt;</code> tag (upload initialization) with <code class="literal">&lt;f:ajax&gt;</code>. In the first case, a common ajaxified upload will look like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:form enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload" value="#{uploadBean.file}" 
              required="true" requiredMessage="No file selected ..."&gt;
  &lt;!-- &lt;f:ajax listener="#{uploadBean.upload()}"
               render="@all"/&gt; use @all in JSF 2.2.0 --&gt; 
  &lt;f:ajax listener="#{uploadBean.upload()}" 
               render="fileToUpload"/&gt; &lt;!-- works in JSF 2.2.5 --&gt;
 &lt;/h:inputFile&gt;           
 &lt;h:message showDetail="false" showSummary="true" 
            for="fileToUpload" style="color:red"/&gt;
&lt;/h:form&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note158"/>Note</h3><p>The render attribute should contain the IDs of components to re-render after upload. In JSF 2.2.0, you need to use <code class="literal">@all</code> instead of IDs because there is a bug associated that was fixed in the later versions. For example, in JSF 2.2.5 everything works as expected.</p></div></div><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_10</code>.</p><p>In the second case, place <code class="literal">&lt;f:ajax&gt;</code> in <code class="literal">&lt;h:commandButton&gt;</code>, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:form enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload" value="#{uploadBean.file}" 
              required="true" requiredMessage="No file selected ..."/&gt;                          
 &lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"&gt;
  &lt;!-- &lt;f:ajax execute="fileToUpload"
              render="@all"/&gt; use @all in JSF 2.2.0 --&gt; 
  &lt;f:ajax execute="fileToUpload" 
              render="fileToUpload"/&gt; &lt;!-- works in JSF 2.2.5 --&gt;
 &lt;/h:commandButton&gt;
 &lt;h:message showDetail="false" showSummary="true" 
            for="fileToUpload" style="color:red"/&gt;
&lt;/h:form&gt;</pre></div><p>The complete application<a id="id1113" class="indexterm"/> is available in the code bundle of this chapter and is named <code class="literal">ch8_11</code>.</p></div><div class="section" title="Uploading images with preview"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec93"/>Uploading images with preview</h2></div></div></div><p>A nice feature of<a id="id1114" class="indexterm"/> the upload components is that they allow us to preview images before they are uploaded. In the following screenshot, you can see what we will develop next:</p><div class="mediaobject"><img src="graphics/6466EN_08_02.jpg" alt="Uploading images with preview"/></div><p>So when the user browses an image, you need to proceed with a behind the scene auto AJAX upload, which should cause the user to see the image preview immediately after he/she chooses the image from the local machine. The <code class="literal">POST</code> request generated by AJAX will populate the server-side <code class="literal">Part</code> object (let's call it <code class="literal">file</code>). When AJAX completes, you need to re-render a component capable of displaying an<a id="id1115" class="indexterm"/> image, such as <code class="literal">&lt;h:graphicImage&gt;</code>. This component will call a servlet using a <code class="literal">GET</code> request. The managed bean responsible with upload should be session scoped; therefore, the servlet will be able to extract the bean instance from the session and use the <code class="literal">file</code> object representing the image. Now, the servlet can pass the image bytes directly to the response output stream, or create a thumbnail of the image and send a small number of bytes. Further, when the user clicks the button that initializes the upload, you need to write the file object on the disk.</p><p>This is the main <a id="id1116" class="indexterm"/>idea. Next, you will implement it and spice it up with some validation capabilities, a cancel button, and some image information displayed next to the preview.</p><p>In order to achieve this, you need to perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Write an auto upload based on AJAX, as follows:<div class="informalexample"><pre class="programlisting">&lt;h:form enctype="multipart/form-data"&gt;                    
 &lt;h:inputFile id="uploadFileId" value="#{uploadBean.file}" 
          required="true" requiredMessage="No file selected ..."&gt;
  &lt;f:ajax render=":previewImgId :imgNameId :uploadMessagesId" 
          listener="#{uploadBean.validateFile()}"/&gt;        
 &lt;/h:inputFile&gt;                                       
&lt;/h:form&gt;</pre></div></li><li class="listitem">AJAX will call the <a id="id1117" class="indexterm"/><code class="literal">validateFile</code> method. This server-side method is capable of validating the filename, length, size, and the content type. The <code class="literal">validateFile</code> method is defined as follows:<div class="informalexample"><pre class="programlisting">...
private Part file;
...
public void validateFile() {

 //VALIDATE FILE NAME LENGTH
 String name = file.getSubmittedFileName();
 if (name.length() == 0) {
     resetFile();
     
     FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Upload  
        Error: Cannot determine the file name !"));
 } else if (name.length() &gt; 25) {
   resetFile();
   FacesContext.getCurrentInstance().addMessage(null, new 
   FacesMessage("Upload Error: The file name is to long !"));
 } else //VALIDATE FILE CONTENT TYPE
 if ((!"image/png".equals(file.getContentType())) &amp;&amp; 
       (!"image/jpeg".equals(file.getContentType()))) {
      resetFile();
      FacesContext.getCurrentInstance().addMessage(null, new 
      FacesMessage("Upload Error: Only images can be uploaded
           (PNGs and JPGs) !"));
 } else //VALIDATE FILE SIZE (not bigger than 1 MB)        
 if (file.getSize() &gt; 1048576) {
     resetFile();
     FacesContext.getCurrentInstance().addMessage(null, new 
     FacesMessage("Upload Error: Cannot upload files larger than 1 MB !"));
 }
}</pre></div></li><li class="listitem">If the constraints <a id="id1118" class="indexterm"/>are violated, then the <code class="literal">resetFile</code> method<a id="id1119" class="indexterm"/> is called. This is a simple method that resets the file object to its initial state. Moreover, it calls the <code class="literal">delete</code> method, which deletes the underlying storage for the file item (including temporary files on the disk).The <code class="literal">resetFile</code> method is defined as follows:<div class="informalexample"><pre class="programlisting">public void resetFile() {
 try {
     if (file != null) {
         file.delete();
     }
 } catch (IOException ex) {
   Logger.getLogger(UploadBean.class.getName()).
                         log(Level.SEVERE, null, ex);
 }
 file = null;
}</pre></div></li><li class="listitem">When the AJAX request is complete, it will re-render the components with IDs: <code class="literal">previewImgId</code>, <code class="literal">imgNameId</code>, and <code class="literal">uploadMessagesId</code>. The following code reveals the components having the <code class="literal">previewImgId</code> and <code class="literal">imgNameId</code> IDs—here the <code class="literal">uploadMessagesId</code> ID corresponds to a <code class="literal">&lt;h:messages&gt;</code> component:<div class="informalexample"><pre class="programlisting">...
&lt;h:panelGrid columns="2"&gt;
 &lt;h:graphicImage id="previewImgId" 
                 value="/PreviewServlet/#{header['Content-Length']}" 
                 width="#{uploadBean.file.size gt 0 ? 100 : 0}" 
                 height="#{uploadBean.file.size gt 0 ? 100 : 0}"/&gt;
 &lt;h:outputText id="imgNameId" value="#{uploadBean.file.submittedFileName} 
  #{empty uploadBean.file.submittedFileName ? '' : ','} 
  #{uploadBean.file.size} #{uploadBean.file.size gt 0 ? 'bytes' : ''}"/&gt;
&lt;/h:panelGrid&gt;
...</pre></div></li><li class="listitem">The value of <code class="literal">&lt;h:graphicImage&gt;</code> accesses <code class="literal">PreviewServlet</code>. This servlet can <a id="id1120" class="indexterm"/>serve the<a id="id1121" class="indexterm"/> image for preview through the response output stream. In order to avoid the caching mechanism, you need to provide a URL with a random part (the request content length can be a convenient choice). This technique will load the correct image every time, instead of loading the same image for all requests. The relevant part of the servlet is as follows:<div class="informalexample"><pre class="programlisting">protected void processRequest(HttpServletRequest request, 
                               HttpServletResponse response)
 throws ServletException, IOException {

 //decorate with buffers if you need to
 OutputStream out = response.getOutputStream();

 response.setHeader("Expires", "Sat, 6 May 1995 12:00:00 GMT");
 response.setHeader("Cache-Control","no-store,no-cache,must-revalidate");
 response.addHeader("Cache-Control", "post-check=0, pre-check=0");
 response.setHeader("Pragma", "no-cache");

 int nRead;
 try {
     HttpSession session = request.getSession(false);
     if (session.getAttribute("uploadBean") != null) {
         UploadBean uploadBean = (UploadBean) 
                    session.getAttribute("uploadBean");
         if (uploadBean.getFile() != null) {
             try (InputStream inStream = 
                          uploadBean.getFile().getInputStream()) {
                  byte[] data = new byte[1024];
                  while ((nRead =inStream.
                          read(data, 0, data.length)) != -1) {
                          out.write(data, 0, nRead);
                  }
             }
         }
    }
 } finally {
   out.close();
 }
}</pre></div></li><li class="listitem">The preceding <a id="id1122" class="indexterm"/>code will send all bytes of the uploaded image to the response output stream. A common technique consists of scaling down the image to obtain a thumbnail that contains a smaller number of bytes. In Java, scaling an image can be accomplished in many ways, but a quick approach can be seen in the following code:<div class="informalexample"><pre class="programlisting">protected void processRequest(HttpServletRequest request, 
                               HttpServletResponse response)
 throws ServletException, IOException {

 OutputStream out = response.getOutputStream();

 response.setHeader("Expires", "Sat, 6 May 1995 12:00:00 GMT");
 response.setHeader("Cache-Control","no-store,no-cache,must-revalidate");
 response.addHeader("Cache-Control", "post-check=0, pre-check=0");
 response.setHeader("Pragma", "no-cache");
       
 try {
     HttpSession session = request.getSession(false);
     if (session.getAttribute("uploadBean") != null) {
         UploadBean uploadBean = (UploadBean) 
                              session.getAttribute("uploadBean");
         if (uploadBean.getFile() != null) {
             BufferedImage image = ImageIO.read(uploadBean.getFile().getInputStream());
             BufferedImage resizedImage = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);
             Graphics2D g = resizedImage.createGraphics();
             g.drawImage(image, 0, 0, 100, 100, null);
             g.dispose();
             ImageIO.write(resizedImage, "png", out);
         }
     }
 } finally {
   out.close();
 }
}</pre></div></li><li class="listitem">Further, you add <a id="id1123" class="indexterm"/>two buttons: one button labeled <span class="strong"><strong>Upload</strong></span> and another one labeled <span class="strong"><strong>Cancel</strong></span>. The first one will initialize the upload, and the second one will cancel the upload, as shown in the following code:<div class="informalexample"><pre class="programlisting">&lt;h:form&gt;
 &lt;h:commandButton value="Upload Image" 
                  action="#{uploadBean.saveFileToDisk()}"/&gt;
 &lt;h:commandButton value="Cancel" action="#{uploadBean.resetFile()}"/&gt; 
&lt;/h:form&gt;</pre></div></li><li class="listitem">When the button labeled <span class="strong"><strong>Upload</strong></span> is clicked, the <a id="id1124" class="indexterm"/><code class="literal">saveFileToDisk</code> method will save the uploaded data to the disk, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void saveFileToDisk() {

 if (file != null) {
     //decorate with buffers if you need too
     try (InputStream inputStream = file.getInputStream(); 
          FileOutputStream outputStream = new FileOutputStream("D:" + File.separator + "files" + File.separator + getSubmittedFileName())) {

          int bytesRead;
          final byte[] chunck = new byte[1024];
          while ((bytesRead = inputStream.read(chunck)) != -1) {
                  outputStream.write(chunck, 0, bytesRead);
          }

          resetFile();

          FacesContext.getCurrentInstance().addMessage(null, new 
                      FacesMessage("Upload successfully ended!"));
     } catch (IOException e) {
              FacesContext.getCurrentInstance().addMessage(null, new FacesMessage("Upload failed!"));
     }
  }
 }</pre></div></li></ol></div><p>Done! The complete application, without thumbnail, is available in the code bundle of this chapter and is named <code class="literal">ch8_13</code>. The complete application, with thumbnail, is named <code class="literal">ch8_12</code>.</p><p>The validation process<a id="id1125" class="indexterm"/> can be eliminated from the server side and can be accomplished on the client side also. Such an example can be found in the code bundle of this chapter and is named <code class="literal">ch8_14</code>. The JavaScript code is pretty straightforward, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
function validateFile() {
 // &lt;![CDATA[
 document.getElementById('formSaveId:uploadHiddenId').value = false;
 document.getElementById('validationId').innerHTML = "";
                
 var file= document.getElementById('formUploadId:fileToUpload').files[0];               

 document.getElementById('fileNameId').innerHTML = 
                         "&lt;b&gt;File Name:&lt;/b&gt; " + file.name;
 if (file.size &gt; 1048576)
     fileSize = (Math.round(file.size * 100 / 
                         (1048576)) / 100).toString() + 'MB';
 else
     fileSize = (Math.round(file.size * 100 
                         / 1024) / 100).toString() + 'KB';
 
 document.getElementById('fileSizeId').innerHTML = 
                         "&lt;b&gt;File Size:&lt;/b&gt; " + fileSize;
 document.getElementById('fileContentTypeId').innerHTML = 
                         "&lt;b&gt;File Type:&lt;/b&gt; " + file.type;

 //VALIDATE FILE NAME LENGTH     
 if (file.name.length === 0) {
     clearUploadField();
     document.getElementById('validationId').innerHTML = 
      "&lt;ul&gt;&lt;li&gt;Upload Error: Cannot determine the file name !&lt;/li&gt;&lt;/ul&gt;";
     return false;
 }

 if (file.name.length &gt; 25) {
     clearUploadField();
     document.getElementById('validationId').innerHTML = 
          "&lt;ul&gt;&lt;li&gt;Upload Error: The file name is to long !&lt;/li&gt;&lt;/ul&gt;";
     return false;
 }

 //VALIDATE FILE CONTENT TYPE
  if (file.type !== "image/png" &amp;&amp; file.type !== "image/jpeg") {
     clearUploadField();
     document.getElementById('validationId').innerHTML = 
         "&lt;ul&gt;&lt;li&gt;Upload Error: Only images can be uploaded 
                                  (PNGs and JPGs) !&lt;/li&gt;&lt;/ul&gt;";
     return false;
 }
 

 //VALIDATE FILE SIZE (not bigger than 1 MB)   
 if (file.size &gt; 1048576) {
     clearUploadField();
     document.getElementById('validationId').innerHTML = 
       "&lt;ul&gt;&lt;li&gt;Upload Error: Cannot upload files 
                              larger than 1 MB !&lt;/li&gt;&lt;/ul&gt;";
     return false;
 }
                 
 document.getElementById('formSaveId:uploadHiddenId').value = true;
 return true;
 //]]&gt;
}

function clearUploadField() {               

 document.getElementById('previewImgId').removeAttribute("src");
 document.getElementById('imgNameId').innerHTML = "";
 document.getElementById('uploadMessagesId').innerHTML = "";
 var original = document.getElementById("formUploadId:fileToUpload");
 var replacement = document.createElement("input");

 replacement.type = "file";
 replacement.id = original.id;
 replacement.name = original.name;
 replacement.className = original.className;
 replacement.style.cssText = original.style.cssText;
 replacement.onchange = original.onchange;
 // ... more attributes

 original.parentNode.replaceChild(replacement, original);
}

&lt;/script&gt;</pre></div></div><div class="section" title="Uploading multiple files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec94"/>Uploading multiple files</h2></div></div></div><p>By default, JSF 2.2 does<a id="id1126" class="indexterm"/> not provide support for uploading multiple files, but with some adjustments, we can easily achieve this goal. In order to have multiple file uploads, you need to focus on two aspects, which are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making multiple file selections possible</li><li class="listitem" style="list-style-type: disc">Uploading all the selected files</li></ul></div><p>Regarding the first task, the multiple selection can be activated using an HTML5 input file attribute (<code class="literal">multiple</code>) and the JSF 2.2 pass-through attribute feature. When this attribute is present and its value is set to <code class="literal">multiple</code>, the file chooser can select multiple files. So, this task requires some minimal adjustments:</p><div class="informalexample"><pre class="programlisting">&lt;html 
      
      &gt;
...
&lt;h:form id="uploadFormId" enctype="multipart/form-data"&gt;
 &lt;h:inputFile id="fileToUpload" required="true" <span class="strong"><strong>f5:multiple="multiple" </strong></span>
     requiredMessage="No file selected ..." value="#{uploadBean.file}"/&gt;           
 &lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"/&gt;
&lt;/h:form&gt;</pre></div><p>The second task is a little bit tricky, because when multiple files are selected, JSF will overwrite the previous <code class="literal">Part</code> instance with each file in the uploaded set. This is normal, since you use an object of type <code class="literal">Part</code>, but you need a collection of <code class="literal">Part</code> instances. Fixing this issue requires us to focus on the renderer of the file component. This renderer is named <code class="literal">FileRenderer</code> (an extension of <code class="literal">TextRenderer</code>), and the <code class="literal">decode</code> method implementation is the key for our issue (the bold code is very important for us), as shown in the <a id="id1127" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">@Override
public void decode(FacesContext context, UIComponent component) {
 
 rendererParamsNotNull(context, component);
 
 if (!shouldDecode(component)) {
     return;
 }

 String clientId = decodeBehaviors(context, component);
 
 if (clientId == null) {
     clientId = component.getClientId(context);
 }
 
 assert(clientId != null);
 ExternalContext externalContext = context.getExternalContext();
 Map&lt;String, String&gt; requestMap = 
                     externalContext.getRequestParameterMap();
         
 if (requestMap.containsKey(clientId)) {
     setSubmittedValue(component, requestMap.get(clientId));
 }
 
 HttpServletRequest request = (HttpServletRequest) 
                               externalContext.getRequest();
 try {
<span class="strong"><strong>     Collection&lt;Part&gt; parts = request.getParts();</strong></span>
<span class="strong"><strong>     for (Part cur : parts) {</strong></span>
<span class="strong"><strong>          if (clientId.equals(cur.getName())) {</strong></span>
<span class="strong"><strong>              component.setTransient(true);</strong></span>
<span class="strong"><strong>              setSubmittedValue(component, cur);</strong></span>
<span class="strong"><strong>          }</strong></span>
<span class="strong"><strong>     }</strong></span>
 } catch (IOException ioe) {
          throw new FacesException(ioe);
 } catch (ServletException se) {
          throw new FacesException(se);
 }
}</pre></div><p>The highlighted code causes the override <code class="literal">Part</code> issue, but you can easily modify it to submit a list of <code class="literal">Part</code> instances instead of one <code class="literal">Part</code>, as follows:</p><div class="informalexample"><pre class="programlisting">try {
    Collection&lt;Part&gt; parts = request.getParts();
    List&lt;Part&gt; multiple = new ArrayList&lt;&gt;();
    for (Part cur : parts) {
         if (clientId.equals(cur.getName())) {
             component.setTransient(true);
             multiple.add(cur);
         }
    }
    this.setSubmittedValue(component, multiple);
} catch (IOException | ServletException ioe) {
  throw new FacesException(ioe);
}</pre></div><p>Of course, in order <a id="id1128" class="indexterm"/>to modify this code, you need to create a custom file renderer and configure it properly in <code class="literal">faces-config.xml</code>.</p><p>Afterwards, you can define a list of <code class="literal">Part</code> instances in your bean using the following code:</p><div class="informalexample"><pre class="programlisting">...
private List&lt;Part&gt; files;

public List&lt;Part&gt; getFile() {
 return files;
}

public void setFile(List&lt;Part&gt; files) {
 this.files = files;
}
...</pre></div><p>Each entry in the list is a file; therefore, you can write them on the disk by iterating the list using the following code:</p><div class="informalexample"><pre class="programlisting">...
for (Part file : files) {
 try (InputStream inputStream = file.getInputStream(); FileOutputStream 
      outputStream = new FileOutputStream("D:" + File.separator + "files" + File.separator + getSubmittedFileName())) {

      int bytesRead = 0;
      final byte[] chunck = new byte[1024];
      while ((bytesRead = inputStream.read(chunck)) != -1) {
              outputStream.write(chunck, 0, bytesRead);
      }

      FacesContext.getCurrentInstance().addMessage(null, new 
       FacesMessage("Upload successfully ended: " +  
        file.getSubmittedFileName()));
 } catch (IOException e) {
          FacesContext.getCurrentInstance().addMessage(null, new   
                                  FacesMessage("Upload failed !"));
 }
}
...</pre></div><p>The complete application is <a id="id1129" class="indexterm"/>available in the code bundle of this chapter and is named <code class="literal">ch8_15</code>.</p></div><div class="section" title="Upload and the indeterminate progress bar"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec95"/>Upload and the indeterminate progress bar</h2></div></div></div><p>When users <a id="id1130" class="indexterm"/>upload small files, the process happens pretty fast; however, when large files are involved, it may take several seconds, or even minutes, to end. In this case, it is a good practice to implement a progress bar that indicates the upload status. The simplest progress bar is known as an indeterminate progress bar, because it shows that the process is running, but it doesn't provide information for estimating the time left or the amount of processed bytes.</p><p>In order to <a id="id1131" class="indexterm"/>implement a progress bar, you need to develop an AJAX-based upload. The JSF AJAX mechanism allows us to determine when the AJAX request begins and when it completes. This can be achieved on the client side; therefore, an indeterminate progress bar can be easily implemented using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
 function progressBar(data) {
  if (data.status === "begin") {
      document.getElementById("uploadMsgId").innerHTML="";
      document.getElementById("progressBarId").
                setAttribute("src", "./resources/progress_bar.gif");
  }

  if (data.status === "complete") {              
      document.getElementById("progressBarId").removeAttribute("src");
  }
 }
&lt;/script&gt;
...
&lt;h:body&gt;       
 &lt;h:messages id="uploadMsgId" globalOnly="true" showDetail="false" 
                             showSummary="true" style="color:red"/&gt;
 &lt;h:form id="uploadFormId" enctype="multipart/form-data"&gt;
  &lt;h:inputFile id="fileToUpload" required="true"
      requiredMessage="No file selected ..." value="#{uploadBean.file}"/&gt;           
  &lt;h:message showDetail="false" showSummary="true" 
      for="fileToUpload" style="color:red"/&gt;
  &lt;h:commandButton value="Upload" action="#{uploadBean.upload()}"&gt;             
   &lt;f:ajax execute="fileToUpload" onevent="progressBar" 
                         render=":uploadMsgId @form"/&gt;
  &lt;/h:commandButton&gt;    
 &lt;/h:form&gt;
 &lt;div&gt;            
  &lt;img id="progressBarId" width="250px;" height="23"/&gt;
 &lt;/div&gt;
&lt;/h:body&gt;</pre></div><p>A possible<a id="id1132" class="indexterm"/> output is as follows:</p><div class="mediaobject"><img src="graphics/6466EN_08_03.jpg" alt="Upload and the indeterminate progress bar"/></div><p>The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_16</code>.</p></div><div class="section" title="Upload and the determinate progress bar"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec96"/>Upload and the determinate progress bar</h2></div></div></div><p>A <a id="id1133" class="indexterm"/>determinate progress bar is much more complicated. Usually, such a progress bar is based on a listener capable to monitor the transferred bytes (if you have worked with Apache Commons' <code class="literal">FileUpload</code>, you must<a id="id1134" class="indexterm"/> have had the chance to implement such a listener). In JSF 2.2, <code class="literal">FacesServlet</code> was annotated with <code class="literal">@MultipartConfig</code> for dealing multipart data (upload files), but there is no progress listener interface for it. Moreover, <code class="literal">FacesServlet</code> is declared <code class="literal">final</code>; therefore, we cannot extend it.</p><p>Well, the possible approaches are pretty limited by these aspects. In order to implement a server-side progress bar, we need to implement the upload component in a separate class (servlet) and provide a listener. Alternatively, on the client side, we need a custom <code class="literal">POST</code> request that tricks <code class="literal">FacesServlet</code> that the request is formatted by <code class="literal">jsf.js</code>.</p><p>In this section, you <a id="id1135" class="indexterm"/>will see a workaround based on HTML5 XMLHttpRequest Level 2 (can upload/download streams as <code class="literal">Blob</code>, <code class="literal">File</code>, and <code class="literal">FormData</code>), HTML5 progress events (for upload it returns total transferred bytes and uploaded bytes), HTML5 progress bar, and a custom Servlet 3.0. If you are not familiar with these HTML5 features, then you have to check out some dedicated documentation.</p><p>After you get familiar with these HTML5 features, it will be very easy to understand the following client-side code. First we have the following JavaScript code:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript"&gt;
 function fileSelected() {
  hideProgressBar();
  updateProgress(0);
  document.getElementById("uploadStatus").innerHTML = "";
  var file = document.getElementById('fileToUploadForm:
                                         fileToUpload').files[0];
  if (file) {
      var fileSize = 0;
      if (file.size &gt; 1048576)
          fileSize = (Math.round(file.size * 100 / (1048576)) / 
                                             100).toString() + 'MB';
      else
          fileSize = (Math.round(file.size * 100 / 1024) / 
                                             100).toString() + 'KB';

      document.getElementById('fileName').innerHTML = 'Name: ' + 
                                                          file.name;
      document.getElementById('fileSize').innerHTML = 'Size: ' + 
                                                           fileSize;
      document.getElementById('fileType').innerHTML = 'Type: ' + 
                                                          file.type;
  }
 }

 function uploadFile() {
  showProgressBar();
  var fd = new FormData();
  fd.append("fileToUpload", document.getElementById('fileToUploadForm:
                                            fileToUpload').files[0]);

  var xhr = new XMLHttpRequest();
  xhr.upload.addEventListener("progress", uploadProgress, false);
  xhr.addEventListener("load", uploadComplete, false);
  xhr.addEventListener("error", uploadFailed, false);
  xhr.addEventListener("abort", uploadCanceled, false);
  xhr.open("POST", "UploadServlet");
  xhr.send(fd);
 }

 function uploadProgress(evt) {
  if (evt.lengthComputable) {
      var percentComplete = Math.round(evt.loaded * 100 / evt.total);
                    updateProgress(percentComplete);
  }
 }

 function uploadComplete(evt) {
  document.getElementById("uploadStatus").innerHTML = "Upload 
                    successfully completed!";
 }

 function uploadFailed(evt) {
  hideProgressBar();
  document.getElementById("uploadStatus").innerHTML = "The upload cannot be complete!";
 }

 function uploadCanceled(evt) {
  hideProgressBar();
  document.getElementById("uploadStatus").innerHTML = "The upload was 
                    canceled!";
 }

 var updateProgress = function(value) {
     var pBar = document.getElementById("progressBar");
     document.getElementById("progressNumber").innerHTML=value+"%";
     pBar.value = value;
 }

 function hideProgressBar() {
  document.getElementById("progressBar").style.visibility = "hidden";
  document.getElementById("progressNumber").style.visibility = "hidden";
 }

 function showProgressBar() {
  document.getElementById("progressBar").style.visibility = "visible";
  document.getElementById("progressNumber").style.visibility = "visible";
 }
&lt;/script&gt;</pre></div><p>Further, we <a id="id1136" class="indexterm"/>have<a id="id1137" class="indexterm"/> the upload component that uses the preceding JavaScript code:</p><div class="informalexample"><pre class="programlisting">&lt;h:body&gt;
 &lt;hr/&gt;
 &lt;div id="fileName"&gt;&lt;/div&gt;
 &lt;div id="fileSize"&gt;&lt;/div&gt;
 &lt;div id="fileType"&gt;&lt;/div&gt;
 &lt;hr/&gt;
 &lt;h:form id="fileToUploadForm" enctype="multipart/form-data"&gt;
  &lt;h:inputFile id="fileToUpload" onchange="fileSelected();"/&gt; 
  &lt;h:commandButton type="button" onclick="uploadFile()" value="Upload" /&gt;
 &lt;/h:form&gt;          
 &lt;hr/&gt; 
 &lt;div id="uploadStatus"&gt;&lt;/div&gt;
  &lt;table&gt;
   &lt;tr&gt;
    &lt;td&gt;
     &lt;progress id="progressBar" style="visibility: hidden;" 
                                   value="0" max="100"&gt;&lt;/progress&gt; 
    &lt;/td&gt;                   
    &lt;td&gt;                    
     &lt;div id="progressNumber" style="visibility: hidden;"&gt;0 %&lt;/div&gt;
    &lt;/td&gt;
   &lt;/tr&gt;   
 &lt;/table&gt;
 &lt;hr/&gt;
&lt;/h:body&gt;</pre></div><p>A possible output can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/6466EN_08_04.jpg" alt="Upload and the determinate progress bar"/></div><p>The servlet behind<a id="id1138" class="indexterm"/> this solution is<a id="id1139" class="indexterm"/> <code class="literal">UploadServlet</code> that <a id="id1140" class="indexterm"/>was presented earlier. The complete application is available in the code bundle of this chapter and is named <code class="literal">ch8_17</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note159"/>Note</h3><p>For multiple file uploads and progress bars, you can extend this example, or choose a built-in solution, such as PrimeFaces Upload, RichFaces Upload, or jQuery Upload Plugin.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Summary</h1></div></div></div><p>In this chapter, you saw how to exploit HTML5 through JSF 2.2 using the pass-through attribute and the pass-through elements techniques. Moreover, in the second part of this chapter, you saw how to work with the new JSF 2.2 upload component (simple upload, multiple file uploads, upload images with preview, and indeterminate/determinate progress bars for upload).</p><p>See you in the next chapter, where we will go further with a great feature of JSF 2.2, that is, stateless views.</p></div></body></html>