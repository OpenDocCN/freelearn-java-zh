- en: Message Routing
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, all message interaction in this book has been unidirectional, flowing
    from message publishers to consumers. What if a consumer wants to alert a publisher
    that processing is complete and send a reply, or a taxi driver wants to acknowledge
    a taxi booking request?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers steps 5 to 10 in the taxi application system architecture,
    where a taxi driver responds to the customer and confirms a booking request. The
    taxi publishes its current location to a queue. The customer's application connects
    to the broker through WebSockets and subscribes to location updates, delivered
    directly from the taxi.
  prefs: []
  type: TYPE_NORMAL
- en: The **Remote Procedure Call** (**RPC**) request-response concept will be introduced,
    along with how to route a response back to the consumer. Since **Advanced Message
    Queuing Protocol** (**AMQP**) 0-9-1 , brokers provide four exchange types. This
    chapter also shows how to implement the last one, headers exchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending responses to the publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reply-to queues and RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data analysis service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Sending responses to the publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is true that all of our interactions with RabbitMQ so far have been one way
    and asynchronous. It is also true that clients interacting with a service usually
    expect to receive a response. Reversing the publisher and consumer roles in the
    response phase requires the client to act as a publisher and the service as a
    consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different queues are used for requests and responses, as demonstrated in [Chapter
    *2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*,
    and illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df52094d-f1e9-4f0a-a789-08d0dc4c2553.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.1: A request-response interaction performed with message queues'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, *Fig 5.2*, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When a taxi driver confirms a booking request, a message is sent to the message
    broker with information about the driver (5).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application service receives the message (6), stores the information in
    the database (7), and confirms the booking with the mobile application, which
    is ultimately shown to the customer (8).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the taxi needs to continuously share its current location with
    the customer. This is accomplished by sending the car's latitude and longitude
    to a location queue every minute (9). The customer side of the app uses a WebSocket
    connection over RabbitMQ to subscribe to the current location queue (10).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete Car**''s (**CC**''s) architecture is shown in the following diagram,
    as a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af043c33-805f-4566-9920-8d1dc2fc470d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.2: CC''s main application architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how WebSockets is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets in RabbitMQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ is a multi-protocol message broker. This section explores the **Single
    Text-Oriented Message Protocol** (**STOMP**) and how to use it with RabbitMQ to
    build interactive web applications. The Web STOMP RabbitMQ plugin makes it possible
    to use STOMP over the internet, by using WebSockets to send real-time data between
    a client—such as a web browser—and a broker via a web server. The plugin allows
    for highly interactive user experiences with data stored or processed on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Start by enabling the Web STOMP plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Web STOMP plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the RabbitMQ management plugin, RabbitMQ does not embed the Web STOMP
    plugin by default but offers it as an option. The appropriate RabbitMQ plugin
    must be enabled as well as installed, and a **virtual host** (**vhost**) has to
    be created with the appropriate permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following Debian package script to install the Web STOMP plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For security purposes, create at least one user, with limited permissions,
    on a publicly exposed vhost. Run the following code to create the new vhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add user permissions for the `cc-dev` user and the `cc-dev-ws` vhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The new vhost is now created and is accessible to the `cc-dev` user. Some basic
    security options should be configured before setting up a new queue for the taxis
    to publish their current locations.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Web STOMP with SSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web STOMP uses the internet, which, in CC's application, leaves information
    vulnerable to snooping unless properly secured. Since most clients send the broker
    **Uniform Resource Locator** (**URL**), username, and password information, an
    additional level of security is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, it is possible to tell RabbitMQ to use **Secure Sockets Layer** (**SSL**)
    through the configuration file. For security, the CC team will add the following
    lines to the configuration to set up a certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the settings to take effect, the broker must be restarted and the default
    username and password changed. The scripts contain the broker URL, which could
    give unwanted easy access to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and publishing GPS data to the queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, the CC team will create a queue where the taxi sends the current location,
    this time by using `rabbitmqadmin` and running the following commands to create
    a queue called `taxi_information`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an exchange called `taxi_exchange`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the command-line tools do not allow the action to bind queues to exchanges,
    use the RabbitMQ management interface to bind the `taxi_information` queue to
    the `taxi_exchange` exchange using the `taxi_information` routing key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CC team will log in, head to the Queues section, and add this information
    to the Bindings section, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87070943-e468-4e28-994b-8ccbc3c86988.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.3: Add binding to the queue via RabbitMQ management'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a queue established, the taxi application can communicate with the broker.
    The code for this is not provided since it would be almost the same code as in
    [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*.
    Instead, the following diagram shows how a message can be published via the management
    console, which is usually used for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6edb8a77-9336-496d-985d-ad30f26448bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.4: Send GPS coordinates to RabbitMQ'
  prefs: []
  type: TYPE_NORMAL
- en: The consumer can now subscribe to **Global Positioning System** (**GPS**) data
    from the `taxi_information` queue.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to GPS and driver information via WebSockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The customer can use the mobile clients to receive location data through WebSockets,
    as shown in *Fig 5.2*.
  prefs: []
  type: TYPE_NORMAL
- en: The customer mobile application uses JavaScript and HTML, made possible with
    tools such as React Native or Angular NativeScript, which are two cross-platform
    frameworks that continue to gain traction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CC team imports the StompJs library ([stomp.umd.min.js](https://stomp-js.github.io/guide/stompjs/using-stompjs-v5.html))
    into the application using a content delivery network, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, CC includes some code, in order to receive updates from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the `stompClient` variable is declared and configured. The broker
    URL should start with `ws://` or `wss://`. The `reconnectDelay` variable in the
    example is set to `200` ms, which means that a retry will happen 200 ms after
    a disconnect, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the instance is created and connected to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The CC team will create a callback to handle incoming messages and subscribe
    directly to the `taxi_information` queue. The username, password, and broker URL
    must be changed.
  prefs: []
  type: TYPE_NORMAL
- en: The broker URL must include the Web STOMP port, defaulting to `15674`.
  prefs: []
  type: TYPE_NORMAL
- en: Happy times! The customer will now know approximately where the taxi is located,
    both before and during the ride.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another option to receive a reply from the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Reply-to queues and RPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CC application can now communicate in a good way between the publisher and
    the consumer, but what if a function has to run on a remote computer and wait
    for the result? Hardcoding an exchange and routing key in the service to publish
    responses isn't possible as it would be too inflexible. The solution is to have
    the request message carry the coordinates of the location where the response should
    be sent, a pattern commonly known as RPC.
  prefs: []
  type: TYPE_NORMAL
- en: The application service calls a specific function residing on the taxi application,
    and the taxi sends the result to the end user. The request message carries the
    name of the queue where the response should be sent. The AMQP protocol supports
    this mechanism out of the box. The client can store the queue name of the location
    where the response must be sent.
  prefs: []
  type: TYPE_NORMAL
- en: When RabbitMQ delivers a message to the consumer, it will change the `reply-to`
    property. The server can reply to the message from the publisher by sending a
    message to the default exchange with the routing key of the `reply-to` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any type of queue can be used for the `reply-to` mechanism, but in practice,
    the following two approaches are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a short-lived queue for each request-response interaction**. This
    approach uses an exclusive, auto-deleted, nondurable, server-side named queue
    created by the client with the following benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No other consumer can get messages from it since it is exclusive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be auto-deleted; once the reply has been consumed, there is no longer
    a use for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for it to be durable; request-response interactions are not meant to
    be long-lived.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server generates a unique name, which relieves the client from having to
    figure out a unique naming scheme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a permanent reply-to queue specific to the client**. This approach uses
    a nonexclusive, non-automatically deleted, nondurable, client-side named queue
    with the following benefits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for it to be durable, for the same reason explained previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for it to be exclusive—a different consumer will be used for each request-response
    interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difficulty in using a permanent queue is in correlating responses with requests.
    This is done through the `CorrelationId` message property, carried from the request
    message to the response message. This property allows the client to identify the
    correct request to process.
  prefs: []
  type: TYPE_NORMAL
- en: A permanent queue is more efficient than using short-lived queues with each
    request since creation and deletion are expensive operations.
  prefs: []
  type: TYPE_NORMAL
- en: RabbitMQ client libraries offer primitives that simplify responses correlated
    with requests.
  prefs: []
  type: TYPE_NORMAL
- en: That completes the information on routing back options to response queues through `reply-to`.
    To continue, the CC team will discover the fourth type of exchange offered by
    RabbitMQ by connecting a data analysis service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a data analysis service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CC wants to be able to analyze incoming data. This system analyses requests
    for taxis in different areas, discovers important patterns, and finds peak request
    times. The project manager assigned the team to build a system capable of running
    several versions of the same service in parallel, allowing the graceful evolution
    of the service during updates.
  prefs: []
  type: TYPE_NORMAL
- en: A member of the team stated that it is possible to use a topic exchange and
    structure the routing key as `{service_name}{version}`. Their idea works within
    the current system; however, RabbitMQ offers a more elegant solution to this problem
    through the headers exchange.
  prefs: []
  type: TYPE_NORMAL
- en: The headers exchange allows the routing of messages based on their headers,
    which are custom key-value pairs stored in the message properties. The custom
    key-value pairs guide messages to the correct queue or queues. With this approach,
    the message and its routing information are all self-contained, remain consistent,
    and are therefore easier to inspect as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'This addition works flawlessly within CC''s architecture, merely requiring
    the team to bind the queues to a headers exchange and send messages with the appropriate
    headers. Start by opening a command-line shell and executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new headers exchange called `taxi_headers_exchange`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The CC team will set up a queue to receive information from the taxis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new queue called `taxi_information_with_headers`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the new queue to the `taxi_header_exchange` headers exchange in the management
    console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4461780b-78c2-47b2-9f8f-ba96b9bdd10c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.5: Bind a queue to an exchange in the management console'
  prefs: []
  type: TYPE_NORMAL
- en: By setting x-match to all, this means that RabbitMQ will route messages sent
    to taxi_header_exchange to the taxi_information_with_headers queue only when system
    = taxi and version = 0.1b. Otherwise, the system drops the message. Header values
    to match on may be of the String, Number, Boolean, or List types. Routing keys
    aren't required since the key-value pairs serve as the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The x-match parameter specifies whether all headers must match or just one.
    The property can have two different values—any or all, described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: all is the default value, which means that all header pairs (key, value) must
    match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any means at least one of the header pairs must match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the data analysis service is written in Python, we will switch away
    from Ruby for the moment. Luckily, connecting and publishing messages in Python
    is very much the same as it is in Ruby, so there is no big learning curve to get
    through.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the RabbitMQ recommended library for Python is `pika` ([https://pypi.
    org/project/pika/](https://pypi.org/project/pika/)). Information can be sent to
    the new queue as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start to import the client library `pika` and `json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Set credentials to connect to RabbitMQ:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Assert that the connection is established, and try to open a channel on the
    connection. Set the header version value to `0.1b` and the system value to `taxi`.
    A message is published to the `taxi_header_exchange` with the given GPS positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because `x-match=all`, both header values must be embedded in the message properties.
    The exchange ensures that the system and version match the values specified in
    the management console before routing the message to the `taxi_information_with_headers`
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As CC's users and customers become more familiar with the system, they begin
    to ask for more functionality. The CC application is now able to connect to the
    broker through WebSockets and subscribes to location updates delivered directly
    from the taxi. Location messages are flowing and CC's app is working great and
    offering more complex features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter further demonstrated how to use RPC in RabbitMQ via reply-to queues.
    The header exchange was introduced to build a system capable of running several
    versions of the same service in parallel, allowing graceful evolution during updates.
    Another exciting addition to the CC system took place in this chapter, which was
    the ability to incorporate data analysis into the system to discover important
    user patterns and other insights. Header exchanges were thereby explained.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter covers the all-important production realities that CC must
    understand going forward. Important topics such as federation features and clustering,
    along with health checks and alerts, are coming up.
  prefs: []
  type: TYPE_NORMAL
