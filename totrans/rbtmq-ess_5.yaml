- en: Message Routing
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, all message interaction in this book has been unidirectional, flowing
    from message publishers to consumers. What if a consumer wants to alert a publisher
    that processing is complete and send a reply, or a taxi driver wants to acknowledge
    a taxi booking request?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers steps 5 to 10 in the taxi application system architecture,
    where a taxi driver responds to the customer and confirms a booking request. The
    taxi publishes its current location to a queue. The customer's application connects
    to the broker through WebSockets and subscribes to location updates, delivered
    directly from the taxi.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The **Remote Procedure Call** (**RPC**) request-response concept will be introduced,
    along with how to route a response back to the consumer. Since **Advanced Message
    Queuing Protocol** (**AMQP**) 0-9-1 , brokers provide four exchange types. This
    chapter also shows how to implement the last one, headers exchange.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Sending responses to the publisher
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reply-to queues and RPC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a data analysis service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files of this chapter can be found on GitHub at [https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/RabbitMQ-Essentials-Second-Edition/tree/master/Chapter05).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Sending responses to the publisher
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is true that all of our interactions with RabbitMQ so far have been one way
    and asynchronous. It is also true that clients interacting with a service usually
    expect to receive a response. Reversing the publisher and consumer roles in the
    response phase requires the client to act as a publisher and the service as a
    consumer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Different queues are used for requests and responses, as demonstrated in [Chapter
    *2*](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*,
    and illustrated in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df52094d-f1e9-4f0a-a789-08d0dc4c2553.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.1: A request-response interaction performed with message queues'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, *Fig 5.2*, we can see the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: When a taxi driver confirms a booking request, a message is sent to the message
    broker with information about the driver (5).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application service receives the message (6), stores the information in
    the database (7), and confirms the booking with the mobile application, which
    is ultimately shown to the customer (8).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the taxi needs to continuously share its current location with
    the customer. This is accomplished by sending the car's latitude and longitude
    to a location queue every minute (9). The customer side of the app uses a WebSocket
    connection over RabbitMQ to subscribe to the current location queue (10).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complete Car**''s (**CC**''s) architecture is shown in the following diagram,
    as a reminder:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af043c33-805f-4566-9920-8d1dc2fc470d.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.2: CC''s main application architecture'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how WebSockets is implemented.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets in RabbitMQ
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RabbitMQ is a multi-protocol message broker. This section explores the **Single
    Text-Oriented Message Protocol** (**STOMP**) and how to use it with RabbitMQ to
    build interactive web applications. The Web STOMP RabbitMQ plugin makes it possible
    to use STOMP over the internet, by using WebSockets to send real-time data between
    a client—such as a web browser—and a broker via a web server. The plugin allows
    for highly interactive user experiences with data stored or processed on a server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Start by enabling the Web STOMP plugin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Web STOMP plugin
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the RabbitMQ management plugin, RabbitMQ does not embed the Web STOMP
    plugin by default but offers it as an option. The appropriate RabbitMQ plugin
    must be enabled as well as installed, and a **virtual host** (**vhost**) has to
    be created with the appropriate permissions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following Debian package script to install the Web STOMP plugin:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For security purposes, create at least one user, with limited permissions,
    on a publicly exposed vhost. Run the following code to create the new vhost:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, add user permissions for the `cc-dev` user and the `cc-dev-ws` vhost:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The new vhost is now created and is accessible to the `cc-dev` user. Some basic
    security options should be configured before setting up a new queue for the taxis
    to publish their current locations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Securing Web STOMP with SSL
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Web STOMP uses the internet, which, in CC's application, leaves information
    vulnerable to snooping unless properly secured. Since most clients send the broker
    **Uniform Resource Locator** (**URL**), username, and password information, an
    additional level of security is necessary.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, it is possible to tell RabbitMQ to use **Secure Sockets Layer** (**SSL**)
    through the configuration file. For security, the CC team will add the following
    lines to the configuration to set up a certificate:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the settings to take effect, the broker must be restarted and the default
    username and password changed. The scripts contain the broker URL, which could
    give unwanted easy access to the server.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Creating and publishing GPS data to the queue
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, the CC team will create a queue where the taxi sends the current location,
    this time by using `rabbitmqadmin` and running the following commands to create
    a queue called `taxi_information`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add an exchange called `taxi_exchange`, like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the command-line tools do not allow the action to bind queues to exchanges,
    use the RabbitMQ management interface to bind the `taxi_information` queue to
    the `taxi_exchange` exchange using the `taxi_information` routing key.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'The CC team will log in, head to the Queues section, and add this information
    to the Bindings section, as shown in the following diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87070943-e468-4e28-994b-8ccbc3c86988.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.3: Add binding to the queue via RabbitMQ management'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'With a queue established, the taxi application can communicate with the broker.
    The code for this is not provided since it would be almost the same code as in
    [Chapter 2](377ec533-342d-4a08-9011-7176de197886.xhtml), *Creating a Taxi Application*.
    Instead, the following diagram shows how a message can be published via the management
    console, which is usually used for testing purposes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6edb8a77-9336-496d-985d-ad30f26448bf.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.4: Send GPS coordinates to RabbitMQ'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The consumer can now subscribe to **Global Positioning System** (**GPS**) data
    from the `taxi_information` queue.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to GPS and driver information via WebSockets
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The customer can use the mobile clients to receive location data through WebSockets,
    as shown in *Fig 5.2*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: The customer mobile application uses JavaScript and HTML, made possible with
    tools such as React Native or Angular NativeScript, which are two cross-platform
    frameworks that continue to gain traction.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The CC team imports the StompJs library ([stomp.umd.min.js](https://stomp-js.github.io/guide/stompjs/using-stompjs-v5.html))
    into the application using a content delivery network, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, CC includes some code, in order to receive updates from the queue.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the `stompClient` variable is declared and configured. The broker
    URL should start with `ws://` or `wss://`. The `reconnectDelay` variable in the
    example is set to `200` ms, which means that a retry will happen 200 ms after
    a disconnect, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, the instance is created and connected to, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The CC team will create a callback to handle incoming messages and subscribe
    directly to the `taxi_information` queue. The username, password, and broker URL
    must be changed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The broker URL must include the Web STOMP port, defaulting to `15674`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Happy times! The customer will now know approximately where the taxi is located,
    both before and during the ride.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at another option to receive a reply from the consumer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Reply-to queues and RPC
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CC application can now communicate in a good way between the publisher and
    the consumer, but what if a function has to run on a remote computer and wait
    for the result? Hardcoding an exchange and routing key in the service to publish
    responses isn't possible as it would be too inflexible. The solution is to have
    the request message carry the coordinates of the location where the response should
    be sent, a pattern commonly known as RPC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The application service calls a specific function residing on the taxi application,
    and the taxi sends the result to the end user. The request message carries the
    name of the queue where the response should be sent. The AMQP protocol supports
    this mechanism out of the box. The client can store the queue name of the location
    where the response must be sent.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: When RabbitMQ delivers a message to the consumer, it will change the `reply-to`
    property. The server can reply to the message from the publisher by sending a
    message to the default exchange with the routing key of the `reply-to` property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当RabbitMQ将消息传递给消费者时，它将更改`reply-to`属性。服务器可以通过向默认交换发送带有`reply-to`属性路由键的消息来从发布者回复消息。
- en: 'Any type of queue can be used for the `reply-to` mechanism, but in practice,
    the following two approaches are used:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`reply-to`机制，可以使用任何类型的队列，但在实践中，以下两种方法被使用：
- en: '**Create a short-lived queue for each request-response interaction**. This
    approach uses an exclusive, auto-deleted, nondurable, server-side named queue
    created by the client with the following benefits:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为每个请求-响应交互创建一个短暂队列**。这种方法使用客户端创建的专用、自动删除、非持久的、服务器端命名的队列，具有以下优点：'
- en: No other consumer can get messages from it since it is exclusive.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是专用的，没有其他消费者可以从中获取消息。
- en: It can be auto-deleted; once the reply has been consumed, there is no longer
    a use for it.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以自动删除；一旦回复被消费，就不再需要它。
- en: No need for it to be durable; request-response interactions are not meant to
    be long-lived.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要它是持久的；请求-响应交互并不打算长期存在。
- en: The server generates a unique name, which relieves the client from having to
    figure out a unique naming scheme.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器生成一个唯一的名称，从而减轻了客户端需要想出唯一命名方案的负担。
- en: '**Use a permanent reply-to queue specific to the client**. This approach uses
    a nonexclusive, non-automatically deleted, nondurable, client-side named queue
    with the following benefits:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用针对客户端的特定永久`reply-to`队列**。这种方法使用非专用、非自动删除、非持久的客户端端命名的队列，具有以下优点：'
- en: No need for it to be durable, for the same reason explained previously.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样不需要它是持久的，原因如前所述。
- en: No need for it to be exclusive—a different consumer will be used for each request-response
    interaction.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要它是专用的——每个请求-响应交互将使用不同的消费者。
- en: The difficulty in using a permanent queue is in correlating responses with requests.
    This is done through the `CorrelationId` message property, carried from the request
    message to the response message. This property allows the client to identify the
    correct request to process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用永久队列的困难在于关联响应与请求。这是通过`CorrelationId`消息属性完成的，该属性从请求消息携带到响应消息。该属性允许客户端识别要处理的正确请求。
- en: A permanent queue is more efficient than using short-lived queues with each
    request since creation and deletion are expensive operations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 永久队列比使用每个请求的短暂队列更有效，因为创建和删除是昂贵的操作。
- en: RabbitMQ client libraries offer primitives that simplify responses correlated
    with requests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ客户端库提供了简化与请求关联的响应的原始操作。
- en: That completes the information on routing back options to response queues through `reply-to`.
    To continue, the CC team will discover the fourth type of exchange offered by
    RabbitMQ by connecting a data analysis service.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了通过`reply-to`将路由回选项信息到响应队列的信息。为了继续，CC团队将通过连接数据分析服务来发现RabbitMQ提供的第四种交换类型。
- en: Creating a data analysis service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据分析服务
- en: CC wants to be able to analyze incoming data. This system analyses requests
    for taxis in different areas, discovers important patterns, and finds peak request
    times. The project manager assigned the team to build a system capable of running
    several versions of the same service in parallel, allowing the graceful evolution
    of the service during updates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CC希望能够分析传入的数据。该系统分析不同地区的出租车请求，发现重要模式，并找出高峰请求时间。项目经理指派团队构建一个能够并行运行同一服务的多个版本的系统，以便在更新期间优雅地演进服务。
- en: A member of the team stated that it is possible to use a topic exchange and
    structure the routing key as `{service_name}{version}`. Their idea works within
    the current system; however, RabbitMQ offers a more elegant solution to this problem
    through the headers exchange.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 团队成员表示，可以使用主题交换并将路由键结构化为`{service_name}{version}`。他们的想法在当前系统中是可行的；然而，RabbitMQ通过头部交换提供了对这个问题的更优雅的解决方案。
- en: The headers exchange allows the routing of messages based on their headers,
    which are custom key-value pairs stored in the message properties. The custom
    key-value pairs guide messages to the correct queue or queues. With this approach,
    the message and its routing information are all self-contained, remain consistent,
    and are therefore easier to inspect as a whole.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'This addition works flawlessly within CC''s architecture, merely requiring
    the team to bind the queues to a headers exchange and send messages with the appropriate
    headers. Start by opening a command-line shell and executing the following commands:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new headers exchange called `taxi_headers_exchange`, as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The CC team will set up a queue to receive information from the taxis.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new queue called `taxi_information_with_headers`, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Bind the new queue to the `taxi_header_exchange` headers exchange in the management
    console, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4461780b-78c2-47b2-9f8f-ba96b9bdd10c.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'Fig 5.5: Bind a queue to an exchange in the management console'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: By setting x-match to all, this means that RabbitMQ will route messages sent
    to taxi_header_exchange to the taxi_information_with_headers queue only when system
    = taxi and version = 0.1b. Otherwise, the system drops the message. Header values
    to match on may be of the String, Number, Boolean, or List types. Routing keys
    aren't required since the key-value pairs serve as the key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The x-match parameter specifies whether all headers must match or just one.
    The property can have two different values—any or all, described as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: all is the default value, which means that all header pairs (key, value) must
    match.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any means at least one of the header pairs must match.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the data analysis service is written in Python, we will switch away
    from Ruby for the moment. Luckily, connecting and publishing messages in Python
    is very much the same as it is in Ruby, so there is no big learning curve to get
    through.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the RabbitMQ recommended library for Python is `pika` ([https://pypi.
    org/project/pika/](https://pypi.org/project/pika/)). Information can be sent to
    the new queue as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Start to import the client library `pika` and `json`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Set credentials to connect to RabbitMQ:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Assert that the connection is established, and try to open a channel on the
    connection. Set the header version value to `0.1b` and the system value to `taxi`.
    A message is published to the `taxi_header_exchange` with the given GPS positions:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because `x-match=all`, both header values must be embedded in the message properties.
    The exchange ensures that the system and version match the values specified in
    the management console before routing the message to the `taxi_information_with_headers`
    queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As CC's users and customers become more familiar with the system, they begin
    to ask for more functionality. The CC application is now able to connect to the
    broker through WebSockets and subscribes to location updates delivered directly
    from the taxi. Location messages are flowing and CC's app is working great and
    offering more complex features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着CC的用户和客户对系统越来越熟悉，他们开始要求更多的功能。现在CC应用程序能够通过WebSockets连接到代理，并订阅直接从出租车发送的位置更新。位置信息正在流动，CC的应用程序运行良好，并提供了更复杂的功能。
- en: This chapter further demonstrated how to use RPC in RabbitMQ via reply-to queues.
    The header exchange was introduced to build a system capable of running several
    versions of the same service in parallel, allowing graceful evolution during updates.
    Another exciting addition to the CC system took place in this chapter, which was
    the ability to incorporate data analysis into the system to discover important
    user patterns and other insights. Header exchanges were thereby explained.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进一步演示了如何通过回复队列在RabbitMQ中使用RPC。引入了头部交换，以构建能够并行运行同一服务多个版本的系统，允许在更新期间优雅地演进。CC系统在这一章中还有一项令人兴奋的添加，那就是将数据分析集成到系统中，以发现重要的用户模式和其它洞察。因此，头部交换得到了解释。
- en: The next chapter covers the all-important production realities that CC must
    understand going forward. Important topics such as federation features and clustering,
    along with health checks and alerts, are coming up.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了CC必须了解的前瞻性生产现实。重要的话题，如联盟功能和集群，以及健康检查和警报，即将出现。
