- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging CDI Beans to Manage Ports and Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus provides its own dependency injection solution called **Quarkus DI**.
    It stems from the **Contexts and Dependency Injection** (**CDI**) for **Java 2.0**
    specification. We employ CDI to delegate the responsibility of providing object
    instances to an external dependency and managing their life cycle across an application.
    Several dependency injection solutions on the market take such responsibility.
    Quarkus DI is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: The value of using a dependency injection mechanism is that we no longer need
    to worry about how and when to provide an object instance. A dependency injection
    solution enables us to automatically create and provide objects as dependencies
    in classes that depend on those objects, generally using annotation attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of hexagonal architecture, the Framework and Application hexagons
    are good candidates to leverage the benefits a CDI solution can provide. Instead
    of using constructors that inject dependencies using concrete classes, we can
    use the CDI discovery mechanisms to automatically look up interface implementations
    and provide them to the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn how to enhance the provisioning of ports and use
    cases by turning them into beans. We’ll explore bean scopes and their life cycles
    and understand how and when to use the available bean scopes. Once we know about
    the CDI fundamentals, we’ll learn how to apply them to a hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Quarkus DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming ports, use cases, and adapters into CDI beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing use cases with Quarkus and Cucumber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to integrate Quarkus DI into a hexagonal
    application by transforming use cases and ports into managed beans that can be
    injected across the hexagonal system. You’ll also know how to test use cases by
    using Quarkus in conjunction with Cucumber.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Quarkus DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quarkus DI** is the dependency injection solution provided by the Quarkus
    framework. This solution, also called **ArC**, is based on the CDI for the **Java
    2.0 specification**. Quarkus DI does not completely implement such a specification.
    Instead, it provides some customized and changed implementations that are more
    inclined toward the Quarkus project’s goals. However, these changes are more visible
    when you go deeper into what the Quarkus DI provides. For those working only with
    the basics and most recurrent features described in the CDI for Java 2.0 specification,
    the Quarkus DI experience is similar to other CDI implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage we get by using Quarkus DI or any dependency injection solution
    is that we can focus more on the business aspects of the software we’re developing,
    rather than on the plumbing activities related to the provisioning and life cycle
    control of the objects that the application needs to provide its features. To
    enable such an advantage, Quarkus DI deals with so-called beans.
  prefs: []
  type: TYPE_NORMAL
- en: Working with beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Beans** are special kinds of objects we can use to inject dependencies or
    that act as dependencies themselves to be injected into other beans. This injection
    activity takes place in a container-managed environment. This environment is nothing
    more than the runtime environment in which the application runs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Beans have a context that influences when and how their instance objects are
    created. The following are the main contexts that are supported by Quarkus DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationScoped`: A bean marked with such a context is available to the
    entire application. Only one bean instance is created and shared across all system
    areas that inject this bean. Another important aspect is that `ApplicationScoped`
    beans are lazily loaded. This means that the bean instance is created only when
    a bean’s method is called for the first time. Take a look at this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `MyBean` class is available not only to the `Consumer` class but also to
    other classes that inject the bean. The bean instance will be created only once
    when `myBean.getName()` is called for the first time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Singleton`: Similar to `ApplicationScoped` beans, for `Singleton` beans, only
    one bean object is created and shared across the system. The only difference,
    though, is that `Singleton` beans are eagerly loaded. This means that once the
    system is started, the `Singleton` bean instance is started as well. Here is the
    code that exemplifies this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `EagerBean` object will be created during the system’s initialization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`RequestScoped`: We usually mark a bean as `RequestScope` when we want to make
    that bean available only for as long as the request associated with that bean
    lives. The following is an example of how we can use `RequestScope`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time a request arrives at `/request`, a new `RequestData` bean object
    will be created and destroyed once the request has finished.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Dependent`: Beans marked as `Dependent` have their scope restricted to places
    where they are used. So, `Dependent` beans are not shared across other beans in
    the system. Also, their life cycle is the same as the one defined in the bean
    injecting them. For example, if you inject a `Dependent`-annotated bean into a
    `RequestScoped` bean, the former bean uses the latter’s scope:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DependentBean` class will become `ApplicationScoped` when injected into
    `ConsumerApplication` and `RequestScoped` into `ConsumerRequest`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SessionScoped`: We use this scope to share the bean context between all the
    requests of the same HTTP session. We need the `quarkus-undertow` extension to
    enable `SessionScoped` on Quarkus:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, a `SessionBean` instance will be created after the
    first request is sent to `/sessionData`. This same instance will be available
    for other requests coming from the same session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To summarize, Quarkus offers the following bean scopes: `ApplicationScoped`,
    `RequestScoped`, `Singleton`, `Dependent`, and `SessionScoped`. For stateless
    applications, most of the time, you may only need `ApplicationScoped` and `RequestScoped`.
    By understanding how these scopes work, we can select them according to our system
    needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the advantages of Quarkus DI and the basics of how it
    works, let’s learn how to employ dependency injection techniques with the ports
    and use cases from the hexagonal architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming ports, use cases, and adapters into CDI beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing the Application hexagon for the topology and inventory system,
    we defined the use cases as interfaces and input ports as their implementations.
    We also defined output ports as interfaces and output adapters as their implementations
    in the Framework hexagon. In this section, we’ll refactor components from both
    the Application and Framework hexagons to enable the usage of dependency injection
    with Quarkus DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to working with Quarkus DI is to add the following Maven dependency
    to the project’s root `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the RESTEasy libraries, this `quarkus-resteasy` library also
    provides the required libraries to work with Quarkus DI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start our refactoring efforts with the classes and interfaces related
    to router management.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CDI for router management objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When developing the topology and inventory system, we defined a set of ports,
    use cases, and adapters to manage router-related operations. We’ll walk through
    the required changes to enable dependency injection in such operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by transforming the `RouterManagementH2Adapter` output adapter into
    a managed bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We turn this class into a managed bean by putting the `@ApplicationScoped` annotation
    on top of the `RouterManagementH2Adapter` class. Note the `EntityManager` attribute
    – we can use dependency injection on that attribute as well. We’ll do that in
    [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data with Output
    Adapters and Hibernate Reactive*, but we won’t touch on it for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before changing the `RouterManagementUseCase` interface and its implementation,
    `RouterManagementInputPort`, let’s analyze some aspects of the current implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We defined the `setOutputPort` method to receive and set an instance type of
    `RouterManagementOutputPort`, which is fulfilled by a `RouterManagementH2Adapter`
    output adapter. As we’ll no longer need to explicitly provide this output adapter
    object (because Quarkus DI will inject it), we can remove the `setOutputPort`
    method from the `RouterManagementUseCase` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code demonstrates how `RouterManagementInputPort` is implemented
    without Quarkus DI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To provide an object of the `RouterManagementOutputPort` type, we need to use
    the previously mentioned `setOutputPort` method. After implementing Quarkus DI,
    this will no longer be necessary, as we’ll see in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is what `RouterManagementOutputPort` should look like after implementing
    Quarkus DI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we add `ApplicationScoped` on top of `RouterManagementInputPort` to enable
    it to be injected into other system parts. Then, by using the `@Inject` annotation,
    we inject `RouterManagementOutputPort`. We don’t need to refer to the output adapter’s
    implementation. Quarkus DI will find a proper implementation for this output port
    interface, which happens to be the `RouterManagementH2Adapter` output adapter
    that we turned into a managed bean earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we must update the `RouterManagementGenericAdapter` input adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of initializing `RouterManagementUseCase` using a constructor, we must
    provide the dependency through the `@Inject` annotation. At runtime, Quarkus DI
    will create and assign a `RouterManagementInputPort` object to that use case reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That’s it for the changes we must make to the classes and interfaces related
    to router management. Now, let’s learn what we need to change regarding the classes
    and interfaces for switch management.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CDI for switch management objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll follow a similar path to the one we followed when we
    refactored the ports, use cases, and adapters related to router management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by transforming the `SwitchManagementH2Adapter` output adapter into
    a managed bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SwitchManagementH2Adapter` adapter also makes use of `EntityManager`. We
    won’t modify how the `EntityManager` object is provided, but in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263),
    *Persisting Data with Output Adapters and Hibernate Reactive*, we will change
    it to use dependency injection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We changed the definition of the `SwitchManagementUseCase` interface in [*Chapter
    9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion with Java
    Modules*, and defined the `setOutputPort` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As Quarkus DI will provide a proper `SwitchManagementOutputPort` instance, we’ll
    no longer need this `setOutputPort` method, so we can remove it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code shows how `SwitchManagementInputPort` is implemented without
    dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the `setOutputPort` method to initialize a `SwitchManagementOutputPort`
    object. When using dependency injection techniques, there is no need to explicitly
    instantiate or initialize objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is what `SwitchManagementInputPort` should look like after implementing
    dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the `@ApplicationScoped` annotation to convert `SwitchManagementInputPort`
    into a managed bean and the `@Inject` annotation to make Quarkus DI discover a
    managed bean object that implements the `SwitchManagementOutputPort` interface,
    which happens to be the `SwitchManagementH2Adapter` output adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We still need to adjust the `SwitchManagementGenericAdapter` input adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are injecting dependencies for both the `SwitchManagementUseCase`
    and `RouterManagementUseCase` objects. Before using annotations, these dependencies
    were provided in this way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The improvement we get is that we no longer need to rely on the constructor
    to initialize the `SwitchManagementGenericAdapter` dependencies. Quarkus DI will
    automatically provide the required instances for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next section is about the operations related to network management. Let’s
    learn how we should change them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CDI for network management classes and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have fewer things to change for the network part because we did not create
    a specific output port and adapter for the network-related operations. So, the
    implementation changes will only take place on the use cases, input ports, and
    input adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by looking at the `NetworkManagementUseCase` use case interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we did in the other use cases, we also defined the `setOutputPort` method
    to allow the initialization of `RouterManagementOutputPort`. After implementing
    Quarkus DI, this method will no longer be needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how `NetworkManagementInputPort` is implemented without Quarkus DI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NetworkManagementInputPort` input port only relies on `RouterManagementOutputPort`,
    which, without dependency injection, is initialized by the `setOutputPort` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is what `NetworkManagementInputPort` looks like after implementing Quarkus
    DI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `setOutputPort` method has been removed. Quarkus DI is now
    providing an implementation for `RouterManagementOutputPort` through the `@Inject`
    annotation. The `@ApplicationScoped` annotation converts `NetworkManagementInputPort`
    into a managed bean.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we have to change the `NetworkManagementGenericAdapter` input adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `NetworkManagementGenericAdapter` input adapter relies on the `SwitchManagementUseCase`
    and `NetworkManagementUseCase` use cases to trigger network-related operations
    on the system. As we did in the previous implementations, here, we are using `@Inject`
    to provide the dependencies at runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code shows how these dependencies were provided before Quarkus
    DI:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After implementing the injection mechanism, we can safely remove this `NetworkManagementGenericAdapter`
    constructor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have finished making all the necessary changes to convert the input ports,
    use cases, and adapters into components that can be used for dependency injection.
    These changes showed us how to integrate the Quarkus CDI mechanisms into our hexagonal
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to adapt the hexagonal system to mock and use managed beans
    during tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing use cases with Quarkus and Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While implementing the Application hexagon in [*Chapter 7*](B19777_07.xhtml#_idTextAnchor152),
    *Building the Application Hexagon*, we used Cucumber to aid us in shaping and
    testing our use cases. By leveraging the behavior-driven design techniques provided
    by Cucumber, we could express use cases in a declarative way. Now, we need to
    integrate Cucumber so that it works with Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to add the Quarkus testing dependencies to the `pom.xml`
    file from the Application hexagon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quarkus-cucumber` dependency provides the integration we need to run tests
    with Quarkus. We also need the `quarkus-junit5` dependency, which enables us to
    use the `@``QuarkusTest` annotation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we must add the necessary Cucumber dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the `cucumber-java`, `cucumber-junit`, and `cucumber-picocontainer` dependencies,
    we can enable the Cucumber engine on the system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s see how Cucumber is configured without Quarkus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@RunWith(Cucumber.class)` annotation is used to activate the Cucumber
    engine. When using Quarkus, this is how `ApplicationTest` should be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `@QuarkusTest` annotations activate the Quarkus testing engine. By extending
    the `CucumberQuarkusTest` class, we also enable the Cucumber testing engine.
  prefs: []
  type: TYPE_NORMAL
- en: There are no tests on the `ApplicationTest` class because this is just a bootstrap
    class. Remember that Cucumber tests were implemented in separate classes. Before
    changing these classes, we need to mock the managed beans that are required to
    provide instances for `RouterManagementOutputPort` and `SwitchManagementOutputPort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a mocked bean object for `RouterManagementOutputPort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is a dummy mocked bean that we created to prevent Quarkus from throwing
    `UnsatisfiedResolutionException`. By using the `@Mock` annotation, Quarkus will
    instantiate the `RouterManagementOutputPortMock` class and serve it as a bean
    to be injected during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way, we will mock `SwitchManagementOutputPort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For `SwitchManagementOutputPort`, we created `SwitchManagementOutputPortMock`
    to provide a dummy managed bean so that Quarkus can use it for injection during
    the tests. Without mocks, we’d need real instances from the `RouterManagementH2Adapter`
    and `SwitchManagementH2Adapter` output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Although we don’t refer directly to output interfaces and output port adapters
    during tests, Quarkus still tries to perform bean discovery on them. That’s why
    we need to provide the mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can refactor the tests to use the dependency injection provided by
    Quarkus DI. Let’s learn how to do that on the `RouterAdd` test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using Quarkus DI, this is how we got the implementation for `RouterManagementUseCase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code can be removed once the `@Inject` annotation has been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We can follow the same approach of adding the `@Inject` annotation and removing
    the constructor call to instantiate input port objects when refactoring other
    test classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output you’ll get after running Quarkus tests integrated with Cucumber
    will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the installed feature’s output entry, Quarkus mentions `CDI` and
    `Cucumber` as extensions that are being used.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to configure Quarkus to work together with Cucumber
    properly. This configuration was required to configure Quarkus mocks and refactor
    test classes to inject input port objects instead of creating them with constructor
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had the opportunity to learn how Quarkus provides dependency
    injection through Quarkus DI. We started by reviewing some of the concepts defined
    by the CDI for **Java 2.0** specification, the specification that Quarkus DI is
    derived from. Then, we proceeded to implement these concepts in our hexagonal
    application. We defined the managed beans and injected them while refactoring
    use cases, ports, and adapters. Finally, we learned how to integrate Quarkus with
    Cucumber to get the best of both worlds while testing our hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing Quarkus dependency injection mechanisms into a hexagonal system,
    we are also turning it into a more robust and modern system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll turn our attention to adapters. Quarkus provides
    powerful capabilities for creating reactive REST endpoints and we’ll learn how
    to integrate them with hexagonal system adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quarkus DI is based on which Java specification?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `ApplicationScoped` and `Singleton` scopes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the annotation we should use to provide dependencies through Quarkus
    DI instead of using calling constructors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enable Quarkus testing capabilities, which annotation should we use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s based on the CDI for **Java** **2.0** specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using `ApplicationScope`, the objects are lazily loaded. With `Singleton`,
    the objects are eagerly loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@``Inject` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `@``QuarkusTest` annotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
