- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Leveraging CDI Beans to Manage Ports and Use Cases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用CDI Bean管理端口和用例
- en: Quarkus provides its own dependency injection solution called **Quarkus DI**.
    It stems from the **Contexts and Dependency Injection** (**CDI**) for **Java 2.0**
    specification. We employ CDI to delegate the responsibility of providing object
    instances to an external dependency and managing their life cycle across an application.
    Several dependency injection solutions on the market take such responsibility.
    Quarkus DI is one of them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus提供自己的依赖注入解决方案，称为**Quarkus DI**。它源自**Java 2.0**规范的**上下文和依赖注入**（**CDI**）。我们使用CDI将提供对象实例的责任委托给外部依赖，并在整个应用程序中管理其生命周期。市场上存在几个依赖注入解决方案承担这样的责任。Quarkus
    DI就是其中之一。
- en: The value of using a dependency injection mechanism is that we no longer need
    to worry about how and when to provide an object instance. A dependency injection
    solution enables us to automatically create and provide objects as dependencies
    in classes that depend on those objects, generally using annotation attributes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入机制的价值在于，我们不再需要担心如何以及何时提供对象实例。依赖注入解决方案使我们能够自动创建并提供对象作为依赖项，通常使用注解属性。
- en: In the context of hexagonal architecture, the Framework and Application hexagons
    are good candidates to leverage the benefits a CDI solution can provide. Instead
    of using constructors that inject dependencies using concrete classes, we can
    use the CDI discovery mechanisms to automatically look up interface implementations
    and provide them to the application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构的上下文中，框架和应用六边形是利用CDI解决方案提供的好处的好候选者。我们不必使用使用具体类注入依赖项的构造函数，而是可以使用CDI发现机制自动查找接口实现并将它们提供给应用程序。
- en: In this chapter, we’ll learn how to enhance the provisioning of ports and use
    cases by turning them into beans. We’ll explore bean scopes and their life cycles
    and understand how and when to use the available bean scopes. Once we know about
    the CDI fundamentals, we’ll learn how to apply them to a hexagonal system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过将端口和用例转换为Bean来增强端口和用例的供应。我们将探索Bean作用域及其生命周期，并了解何时以及如何使用可用的Bean作用域。一旦我们了解了CDI基础知识，我们将学习如何将其应用于六边形系统。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Learning about Quarkus DI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Quarkus DI
- en: Transforming ports, use cases, and adapters into CDI beans
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将端口、用例和适配器转换为CDI Bean
- en: Testing use cases with Quarkus and Cucumber
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Quarkus和Cucumber测试用例
- en: By the end of this chapter, you’ll know how to integrate Quarkus DI into a hexagonal
    application by transforming use cases and ports into managed beans that can be
    injected across the hexagonal system. You’ll also know how to test use cases by
    using Quarkus in conjunction with Cucumber.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何通过将用例和端口转换为可以在六边形系统中注入的托管Bean，将Quarkus DI集成到六边形应用中。你还将知道如何结合Cucumber使用Quarkus来测试用例。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you will need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for Linux, Mac, and Windows operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，你需要在你的计算机上安装最新的**Java SE开发工具包**和**Maven 3.8**。它们适用于Linux、Mac和Windows操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter11)。
- en: Learning about Quarkus DI
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Quarkus DI
- en: '**Quarkus DI** is the dependency injection solution provided by the Quarkus
    framework. This solution, also called **ArC**, is based on the CDI for the **Java
    2.0 specification**. Quarkus DI does not completely implement such a specification.
    Instead, it provides some customized and changed implementations that are more
    inclined toward the Quarkus project’s goals. However, these changes are more visible
    when you go deeper into what the Quarkus DI provides. For those working only with
    the basics and most recurrent features described in the CDI for Java 2.0 specification,
    the Quarkus DI experience is similar to other CDI implementations.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quarkus DI**是Quarkus框架提供的依赖注入解决方案。这个解决方案也称为**ArC**，基于**Java 2.0规范**的CDI。Quarkus
    DI并没有完全实现这样的规范。相反，它提供了一些定制和修改后的实现，这些实现更倾向于Quarkus项目的目标。然而，这些更改在你深入了解Quarkus DI提供的内容时更为明显。对于那些只使用Java
    2.0规范中CDI描述的基本和最常见功能的人来说，Quarkus DI的体验与其他CDI实现相似。'
- en: The advantage we get by using Quarkus DI or any dependency injection solution
    is that we can focus more on the business aspects of the software we’re developing,
    rather than on the plumbing activities related to the provisioning and life cycle
    control of the objects that the application needs to provide its features. To
    enable such an advantage, Quarkus DI deals with so-called beans.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Quarkus DI或任何依赖注入解决方案的优势是我们可以更多地关注我们正在开发的软件的业务方面，而不是与提供应用程序功能所需的对象的供应和生命周期控制相关的管道活动。为了实现这种优势，Quarkus
    DI处理所谓的豆。
- en: Working with beans
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与豆类一起工作
- en: '**Beans** are special kinds of objects we can use to inject dependencies or
    that act as dependencies themselves to be injected into other beans. This injection
    activity takes place in a container-managed environment. This environment is nothing
    more than the runtime environment in which the application runs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**豆类**是我们可以用作注入依赖项或作为依赖项本身被注入到其他豆类中的特殊对象。这种注入活动发生在容器管理的环境中。这个环境不过是应用程序运行的运行时环境。'
- en: 'Beans have a context that influences when and how their instance objects are
    created. The following are the main contexts that are supported by Quarkus DI:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 豆类有一个上下文，它影响其实例对象何时以及如何创建。以下是由Quarkus DI支持的上下文的主要类型：
- en: '`ApplicationScoped`: A bean marked with such a context is available to the
    entire application. Only one bean instance is created and shared across all system
    areas that inject this bean. Another important aspect is that `ApplicationScoped`
    beans are lazily loaded. This means that the bean instance is created only when
    a bean’s method is called for the first time. Take a look at this example:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationScoped`：带有此类上下文的豆在整个应用程序中可用。仅创建一个豆实例，并在所有注入此豆的系统区域中共享。另一个重要方面是`ApplicationScoped`豆是延迟加载的。这意味着只有在第一次调用豆的方法时才会创建豆实例。看看这个例子：'
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `MyBean` class is available not only to the `Consumer` class but also to
    other classes that inject the bean. The bean instance will be created only once
    when `myBean.getName()` is called for the first time.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`MyBean`类不仅对`Consumer`类可用，也对其他注入豆的类可用。只有在第一次调用`myBean.getName()`时，才会创建豆实例。'
- en: '`Singleton`: Similar to `ApplicationScoped` beans, for `Singleton` beans, only
    one bean object is created and shared across the system. The only difference,
    though, is that `Singleton` beans are eagerly loaded. This means that once the
    system is started, the `Singleton` bean instance is started as well. Here is the
    code that exemplifies this:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Singleton`：与`ApplicationScoped`豆类似，对于`Singleton`豆，也只有一个豆对象被创建并在整个系统中共享。唯一的区别是`Singleton`豆是预先加载的。这意味着一旦系统启动，`Singleton`豆实例也会启动。以下是一个示例代码：'
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `EagerBean` object will be created during the system’s initialization.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EagerBean`对象将在系统初始化期间创建。'
- en: '`RequestScoped`: We usually mark a bean as `RequestScope` when we want to make
    that bean available only for as long as the request associated with that bean
    lives. The following is an example of how we can use `RequestScope`:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestScoped`：当我们只想让豆在与其关联的请求存在的时间内可用时，我们通常将豆标记为`RequestScope`。以下是我们如何使用`RequestScope`的示例：'
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every time a request arrives at `/request`, a new `RequestData` bean object
    will be created and destroyed once the request has finished.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当请求到达`/request`时，都会创建一个新的`RequestData`豆对象，一旦请求完成，该对象就会被销毁。
- en: '`Dependent`: Beans marked as `Dependent` have their scope restricted to places
    where they are used. So, `Dependent` beans are not shared across other beans in
    the system. Also, their life cycle is the same as the one defined in the bean
    injecting them. For example, if you inject a `Dependent`-annotated bean into a
    `RequestScoped` bean, the former bean uses the latter’s scope:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`依赖性`: 标记为 `依赖性` 的豆豆（Beans）其作用域被限制在它们被使用的地方。因此，`依赖性` 豆豆不会在系统中的其他豆豆之间共享。此外，它们的生命周期与注入它们的豆豆中定义的生命周期相同。例如，如果你将一个
    `依赖性` 注解的豆豆注入到一个 `RequestScoped` 豆豆中，前一个豆豆将使用后者的作用域：'
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `DependentBean` class will become `ApplicationScoped` when injected into
    `ConsumerApplication` and `RequestScoped` into `ConsumerRequest`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当将 `DependentBean` 类注入到 `ConsumerApplication` 时，它将成为 `ApplicationScoped`，注入到
    `ConsumerRequest` 时将变为 `RequestScoped`。
- en: '`SessionScoped`: We use this scope to share the bean context between all the
    requests of the same HTTP session. We need the `quarkus-undertow` extension to
    enable `SessionScoped` on Quarkus:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionScoped`: 我们使用这个作用域在同一个 HTTP 会话的所有请求之间共享豆豆上下文。我们需要 `quarkus-undertow`
    扩展来在 Quarkus 上启用 `SessionScoped`：'
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, a `SessionBean` instance will be created after the
    first request is sent to `/sessionData`. This same instance will be available
    for other requests coming from the same session.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的示例中，在向 `/sessionData` 发送第一个请求之后，将创建一个 `SessionBean` 实例。这个相同的实例将可用于来自同一会话的其他请求。
- en: 'To summarize, Quarkus offers the following bean scopes: `ApplicationScoped`,
    `RequestScoped`, `Singleton`, `Dependent`, and `SessionScoped`. For stateless
    applications, most of the time, you may only need `ApplicationScoped` and `RequestScoped`.
    By understanding how these scopes work, we can select them according to our system
    needs.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Quarkus 提供以下豆豆作用域：`ApplicationScoped`、`RequestScoped`、`Singleton`、`Dependent`
    和 `SessionScoped`。对于无状态应用程序，大多数情况下，你可能只需要 `ApplicationScoped` 和 `RequestScoped`。通过了解这些作用域的工作方式，我们可以根据系统需求进行选择。
- en: Now that we know about the advantages of Quarkus DI and the basics of how it
    works, let’s learn how to employ dependency injection techniques with the ports
    and use cases from the hexagonal architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Quarkus DI 的优势以及其基本工作原理，让我们学习如何使用六角架构中的端口和用例来应用依赖注入技术。
- en: Transforming ports, use cases, and adapters into CDI beans
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将端口、用例和适配器转换为 CDI 豆豆
- en: When designing the Application hexagon for the topology and inventory system,
    we defined the use cases as interfaces and input ports as their implementations.
    We also defined output ports as interfaces and output adapters as their implementations
    in the Framework hexagon. In this section, we’ll refactor components from both
    the Application and Framework hexagons to enable the usage of dependency injection
    with Quarkus DI.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在为拓扑和库存系统设计应用程序六边形时，我们将用例定义为接口，并将输入端口定义为它们的实现。我们还在框架六边形中定义了输出端口，并将输出适配器定义为它们的实现。在本节中，我们将重构来自应用程序和框架六边形的组件，以启用与
    Quarkus DI 一起使用依赖注入。
- en: 'The first step to working with Quarkus DI is to add the following Maven dependency
    to the project’s root `pom.xml`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Quarkus DI 一起工作的第一步是在项目的根 `pom.xml` 中添加以下 Maven 依赖项：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In addition to the RESTEasy libraries, this `quarkus-resteasy` library also
    provides the required libraries to work with Quarkus DI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 RESTEasy 库之外，这个 `quarkus-resteasy` 库还提供了与 Quarkus DI 一起工作的所需库。
- en: Let’s start our refactoring efforts with the classes and interfaces related
    to router management.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从与路由管理相关的类和接口开始我们的重构工作。
- en: Implementing CDI for router management objects
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现路由管理对象中的 CDI
- en: 'When developing the topology and inventory system, we defined a set of ports,
    use cases, and adapters to manage router-related operations. We’ll walk through
    the required changes to enable dependency injection in such operations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发拓扑和库存系统时，我们定义了一系列端口、用例和适配器来管理路由相关的操作。我们将逐步介绍所需的更改以启用此类操作中的依赖注入：
- en: 'We start by transforming the `RouterManagementH2Adapter` output adapter into
    a managed bean:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将 `RouterManagementH2Adapter` 输出适配器转换为托管豆豆：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We turn this class into a managed bean by putting the `@ApplicationScoped` annotation
    on top of the `RouterManagementH2Adapter` class. Note the `EntityManager` attribute
    – we can use dependency injection on that attribute as well. We’ll do that in
    [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data with Output
    Adapters and Hibernate Reactive*, but we won’t touch on it for now.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过在`RouterManagementH2Adapter`类上放置`@ApplicationScoped`注解，将这个类转换为一个托管Bean。注意`EntityManager`属性——我们也可以在这个属性上使用依赖注入。我们将在[*第13章*](B19777_13.xhtml#_idTextAnchor263)中这样做，*使用输出适配器和Hibernate
    Reactive持久化数据*，但现在我们不会涉及这一点。
- en: 'Before changing the `RouterManagementUseCase` interface and its implementation,
    `RouterManagementInputPort`, let’s analyze some aspects of the current implementation:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改`RouterManagementUseCase`接口及其实现`RouterManagementInputPort`之前，让我们分析一下当前实现的一些方面：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We defined the `setOutputPort` method to receive and set an instance type of
    `RouterManagementOutputPort`, which is fulfilled by a `RouterManagementH2Adapter`
    output adapter. As we’ll no longer need to explicitly provide this output adapter
    object (because Quarkus DI will inject it), we can remove the `setOutputPort`
    method from the `RouterManagementUseCase` interface.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们定义了`setOutputPort`方法来接收和设置一个`RouterManagementOutputPort`类型的实例，这由一个`RouterManagementH2Adapter`输出适配器来满足。由于我们不再需要显式提供这个输出适配器对象（因为Quarkus
    DI将注入它），我们可以从`RouterManagementUseCase`接口中删除`setOutputPort`方法。
- en: 'The following code demonstrates how `RouterManagementInputPort` is implemented
    without Quarkus DI:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码演示了在没有Quarkus DI的情况下如何实现`RouterManagementInputPort`：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To provide an object of the `RouterManagementOutputPort` type, we need to use
    the previously mentioned `setOutputPort` method. After implementing Quarkus DI,
    this will no longer be necessary, as we’ll see in the next step.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要提供一个`RouterManagementOutputPort`类型的对象，我们需要使用之前提到的`setOutputPort`方法。在实现Quarkus
    DI之后，这将不再必要，正如我们将在下一步看到的那样。
- en: 'This is what `RouterManagementOutputPort` should look like after implementing
    Quarkus DI:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是实现Quarkus DI后`RouterManagementOutputPort`应该看起来像什么：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we add `ApplicationScoped` on top of `RouterManagementInputPort` to enable
    it to be injected into other system parts. Then, by using the `@Inject` annotation,
    we inject `RouterManagementOutputPort`. We don’t need to refer to the output adapter’s
    implementation. Quarkus DI will find a proper implementation for this output port
    interface, which happens to be the `RouterManagementH2Adapter` output adapter
    that we turned into a managed bean earlier.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们在`RouterManagementInputPort`上添加`ApplicationScoped`以使其能够注入到其他系统部分。然后，通过使用`@Inject`注解，我们注入`RouterManagementOutputPort`。我们不需要引用输出适配器的实现。Quarkus
    DI将找到适当的实现来满足这个输出端口接口，这恰好是我们之前转换成托管Bean的`RouterManagementH2Adapter`输出适配器。
- en: 'Finally, we must update the `RouterManagementGenericAdapter` input adapter:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须更新`RouterManagementGenericAdapter`输入适配器：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of initializing `RouterManagementUseCase` using a constructor, we must
    provide the dependency through the `@Inject` annotation. At runtime, Quarkus DI
    will create and assign a `RouterManagementInputPort` object to that use case reference.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不能使用构造函数来初始化`RouterManagementUseCase`，而必须通过`@Inject`注解提供依赖。在运行时，Quarkus DI将为该用例引用创建并分配一个`RouterManagementInputPort`对象。
- en: That’s it for the changes we must make to the classes and interfaces related
    to router management. Now, let’s learn what we need to change regarding the classes
    and interfaces for switch management.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与路由管理相关的类和接口，我们必须做的更改就这些了。现在，让我们学习关于开关管理类和接口我们需要更改的内容。
- en: Implementing CDI for switch management objects
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现开关管理对象的CDI
- en: 'In this section, we’ll follow a similar path to the one we followed when we
    refactored the ports, use cases, and adapters related to router management:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遵循与我们在重构与路由管理相关的端口、用例和适配器时相同的路径：
- en: 'We start by transforming the `SwitchManagementH2Adapter` output adapter into
    a managed bean:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将`SwitchManagementH2Adapter`输出适配器转换为一个托管Bean：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `SwitchManagementH2Adapter` adapter also makes use of `EntityManager`. We
    won’t modify how the `EntityManager` object is provided, but in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263),
    *Persisting Data with Output Adapters and Hibernate Reactive*, we will change
    it to use dependency injection.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SwitchManagementH2Adapter`适配器也使用了`EntityManager`。我们不会修改`EntityManager`对象提供的方式，但在[*第13章*](B19777_13.xhtml#_idTextAnchor263)中，*使用输出适配器和Hibernate
    Reactive持久化数据*，我们将将其改为使用依赖注入。'
- en: 'We changed the definition of the `SwitchManagementUseCase` interface in [*Chapter
    9*](B19777_09.xhtml#_idTextAnchor192), *Applying Dependency Inversion with Java
    Modules*, and defined the `setOutputPort` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在[*第9章*](B19777_09.xhtml#_idTextAnchor192)中更改了`SwitchManagementUseCase`接口的定义，*使用Java模块应用依赖倒置*，并定义了`setOutputPort`方法：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As Quarkus DI will provide a proper `SwitchManagementOutputPort` instance, we’ll
    no longer need this `setOutputPort` method, so we can remove it.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于Quarkus DI将提供适当的`SwitchManagementOutputPort`实例，我们不再需要这个`setOutputPort`方法，因此我们可以将其删除。
- en: 'The following code shows how `SwitchManagementInputPort` is implemented without
    dependency injection:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了在没有依赖注入的情况下如何实现`SwitchManagementInputPort`：
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We call the `setOutputPort` method to initialize a `SwitchManagementOutputPort`
    object. When using dependency injection techniques, there is no need to explicitly
    instantiate or initialize objects.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们调用`setOutputPort`方法来初始化一个`SwitchManagementOutputPort`对象。在使用依赖注入技术时，不需要显式实例化或初始化对象。
- en: 'The following is what `SwitchManagementInputPort` should look like after implementing
    dependency injection:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现依赖注入后，`SwitchManagementInputPort`应该看起来是这样的：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use the `@ApplicationScoped` annotation to convert `SwitchManagementInputPort`
    into a managed bean and the `@Inject` annotation to make Quarkus DI discover a
    managed bean object that implements the `SwitchManagementOutputPort` interface,
    which happens to be the `SwitchManagementH2Adapter` output adapter.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`@ApplicationScoped`注解将`SwitchManagementInputPort`转换为托管Bean，并使用`@Inject`注解让Quarkus
    DI发现实现`SwitchManagementOutputPort`接口的托管Bean对象，恰好是`SwitchManagementH2Adapter`输出适配器。
- en: 'We still need to adjust the `SwitchManagementGenericAdapter` input adapter:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然需要调整`SwitchManagementGenericAdapter`输入适配器：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are injecting dependencies for both the `SwitchManagementUseCase`
    and `RouterManagementUseCase` objects. Before using annotations, these dependencies
    were provided in this way:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在为`SwitchManagementUseCase`和`RouterManagementUseCase`对象注入依赖项。在使用注解之前，这些依赖项以这种方式提供：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The improvement we get is that we no longer need to rely on the constructor
    to initialize the `SwitchManagementGenericAdapter` dependencies. Quarkus DI will
    automatically provide the required instances for us.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们获得的好处是，我们不再需要依赖于构造函数来初始化`SwitchManagementGenericAdapter`依赖项。Quarkus DI将自动为我们提供所需的实例。
- en: The next section is about the operations related to network management. Let’s
    learn how we should change them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节是关于网络管理操作的内容。让我们学习我们应该如何更改它们。
- en: Implementing CDI for network management classes and interfaces
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现网络管理类和接口的CDI
- en: 'We have fewer things to change for the network part because we did not create
    a specific output port and adapter for the network-related operations. So, the
    implementation changes will only take place on the use cases, input ports, and
    input adapters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络部分，我们不需要做太多更改，因为我们没有为网络相关操作创建特定的输出端口和适配器。因此，实现更改将仅发生在用例、输入端口和输入适配器上：
- en: 'Let’s start by looking at the `NetworkManagementUseCase` use case interface:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先看看`NetworkManagementUseCase`用例接口：
- en: '[PRE17]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we did in the other use cases, we also defined the `setOutputPort` method
    to allow the initialization of `RouterManagementOutputPort`. After implementing
    Quarkus DI, this method will no longer be needed.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们在其他用例中所做的那样，我们也定义了`setOutputPort`方法以允许初始化`RouterManagementOutputPort`。在实现Quarkus
    DI之后，此方法将不再需要。
- en: 'This is how `NetworkManagementInputPort` is implemented without Quarkus DI:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是实现没有Quarkus DI的`NetworkManagementInputPort`的方式：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `NetworkManagementInputPort` input port only relies on `RouterManagementOutputPort`,
    which, without dependency injection, is initialized by the `setOutputPort` method.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NetworkManagementInputPort`输入端口仅依赖于`RouterManagementOutputPort`，在没有依赖注入的情况下，它通过`setOutputPort`方法进行初始化。'
- en: 'This is what `NetworkManagementInputPort` looks like after implementing Quarkus
    DI:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是实现Quarkus DI后`NetworkManagementInputPort`的样子：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, the `setOutputPort` method has been removed. Quarkus DI is now
    providing an implementation for `RouterManagementOutputPort` through the `@Inject`
    annotation. The `@ApplicationScoped` annotation converts `NetworkManagementInputPort`
    into a managed bean.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，`setOutputPort`方法已被删除。现在，Quarkus DI通过`@Inject`注解提供`RouterManagementOutputPort`的实现。`@ApplicationScoped`注解将`NetworkManagementInputPort`转换为托管Bean。
- en: 'Finally, we have to change the `NetworkManagementGenericAdapter` input adapter:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须更改`NetworkManagementGenericAdapter`输入适配器：
- en: '[PRE20]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `NetworkManagementGenericAdapter` input adapter relies on the `SwitchManagementUseCase`
    and `NetworkManagementUseCase` use cases to trigger network-related operations
    on the system. As we did in the previous implementations, here, we are using `@Inject`
    to provide the dependencies at runtime.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NetworkManagementGenericAdapter`输入适配器依赖于`SwitchManagementUseCase`和`NetworkManagementUseCase`用例，在系统中触发与网络相关的操作。正如我们在之前的实现中所做的那样，这里我们使用`@Inject`在运行时提供依赖项。'
- en: 'The following code shows how these dependencies were provided before Quarkus
    DI:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码展示了在Quarkus DI之前这些依赖是如何提供的：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After implementing the injection mechanism, we can safely remove this `NetworkManagementGenericAdapter`
    constructor.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在实现注入机制之后，我们可以安全地移除这个`NetworkManagementGenericAdapter`构造函数。
- en: We have finished making all the necessary changes to convert the input ports,
    use cases, and adapters into components that can be used for dependency injection.
    These changes showed us how to integrate the Quarkus CDI mechanisms into our hexagonal
    application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有必要的更改，将输入端口、用例和适配器转换为可用于依赖注入的组件。这些更改展示了如何将Quarkus CDI机制集成到我们的六边形应用程序中。
- en: Now, let’s learn how to adapt the hexagonal system to mock and use managed beans
    during tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将六边形系统适应以在测试期间模拟和使用托管Bean。
- en: Testing use cases with Quarkus and Cucumber
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Quarkus和Cucumber测试用例
- en: 'While implementing the Application hexagon in [*Chapter 7*](B19777_07.xhtml#_idTextAnchor152),
    *Building the Application Hexagon*, we used Cucumber to aid us in shaping and
    testing our use cases. By leveraging the behavior-driven design techniques provided
    by Cucumber, we could express use cases in a declarative way. Now, we need to
    integrate Cucumber so that it works with Quarkus:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现应用程序六边形的过程中[*第7章*](B19777_07.xhtml#_idTextAnchor152)，*构建应用程序六边形*，我们使用了Cucumber来帮助我们塑造和测试我们的用例。通过利用Cucumber提供的行为驱动设计技术，我们能够以声明性方式表达用例。现在，我们需要集成Cucumber，使其与Quarkus协同工作：
- en: 'The first step is to add the Quarkus testing dependencies to the `pom.xml`
    file from the Application hexagon:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是将Quarkus测试依赖项添加到应用程序六边形的`pom.xml`文件中：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `quarkus-cucumber` dependency provides the integration we need to run tests
    with Quarkus. We also need the `quarkus-junit5` dependency, which enables us to
    use the `@``QuarkusTest` annotation.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus-cucumber`依赖提供了我们运行Quarkus测试所需的集成。我们还需要`quarkus-junit5`依赖，它使我们能够使用`@QuarkusTest`注解。'
- en: 'Next, we must add the necessary Cucumber dependencies:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加必要的Cucumber依赖项：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the `cucumber-java`, `cucumber-junit`, and `cucumber-picocontainer` dependencies,
    we can enable the Cucumber engine on the system.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加`cucumber-java`、`cucumber-junit`和`cucumber-picocontainer`依赖项，我们可以在系统中启用Cucumber引擎。
- en: 'Let’s see how Cucumber is configured without Quarkus:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在没有Quarkus的情况下如何配置Cucumber：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `@RunWith(Cucumber.class)` annotation is used to activate the Cucumber
    engine. When using Quarkus, this is how `ApplicationTest` should be implemented:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@RunWith(Cucumber.class)`注解来激活Cucumber引擎。当使用Quarkus时，这是实现`ApplicationTest`的方式：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `@QuarkusTest` annotations activate the Quarkus testing engine. By extending
    the `CucumberQuarkusTest` class, we also enable the Cucumber testing engine.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`@QuarkusTest`注解激活了Quarkus测试引擎。通过扩展`CucumberQuarkusTest`类，我们也启用了Cucumber测试引擎。'
- en: There are no tests on the `ApplicationTest` class because this is just a bootstrap
    class. Remember that Cucumber tests were implemented in separate classes. Before
    changing these classes, we need to mock the managed beans that are required to
    provide instances for `RouterManagementOutputPort` and `SwitchManagementOutputPort`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationTest`类上没有测试，因为这个只是一个启动类。记住，Cucumber测试是在单独的类中实现的。在更改这些类之前，我们需要模拟所需的托管Bean，以提供`RouterManagementOutputPort`和`SwitchManagementOutputPort`的实例。
- en: 'Let’s create a mocked bean object for `RouterManagementOutputPort`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`RouterManagementOutputPort`创建一个模拟Bean对象：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is a dummy mocked bean that we created to prevent Quarkus from throwing
    `UnsatisfiedResolutionException`. By using the `@Mock` annotation, Quarkus will
    instantiate the `RouterManagementOutputPortMock` class and serve it as a bean
    to be injected during the tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们创建的虚拟模拟Bean，用于防止Quarkus抛出`UnsatisfiedResolutionException`。通过使用`@Mock`注解，Quarkus将实例化`RouterManagementOutputPortMock`类，并在测试期间将其作为Bean注入。
- en: 'In the same way, we will mock `SwitchManagementOutputPort`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们将模拟`SwitchManagementOutputPort`：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For `SwitchManagementOutputPort`, we created `SwitchManagementOutputPortMock`
    to provide a dummy managed bean so that Quarkus can use it for injection during
    the tests. Without mocks, we’d need real instances from the `RouterManagementH2Adapter`
    and `SwitchManagementH2Adapter` output adapters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `SwitchManagementOutputPort`，我们创建了 `SwitchManagementOutputPortMock` 以提供一个虚拟的托管
    Bean，这样 Quarkus 就可以在测试期间使用它进行注入。如果没有模拟，我们需要从 `RouterManagementH2Adapter` 和 `SwitchManagementH2Adapter`
    输出适配器获取真实实例。
- en: Although we don’t refer directly to output interfaces and output port adapters
    during tests, Quarkus still tries to perform bean discovery on them. That’s why
    we need to provide the mocks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在测试期间没有直接引用输出接口和输出端口适配器，但 Quarkus 仍然试图在它们上执行 Bean 发现。这就是为什么我们需要提供模拟的原因。
- en: 'Now, we can refactor the tests to use the dependency injection provided by
    Quarkus DI. Let’s learn how to do that on the `RouterAdd` test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重构测试以使用 Quarkus DI 提供的依赖注入。让我们在 `RouterAdd` 测试中学习如何做到这一点：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before using Quarkus DI, this is how we got the implementation for `RouterManagementUseCase`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Quarkus DI 之前，这是我们对 `RouterManagementUseCase` 的实现方式：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code can be removed once the `@Inject` annotation has been implemented.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了 `@Inject` 注解，就可以删除前面的代码。
- en: We can follow the same approach of adding the `@Inject` annotation and removing
    the constructor call to instantiate input port objects when refactoring other
    test classes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在重构其他测试类时遵循相同的做法，添加 `@Inject` 注解并删除构造函数调用以实例化输入端口对象。
- en: 'The output you’ll get after running Quarkus tests integrated with Cucumber
    will be similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行与 Cucumber 集成的 Quarkus 测试后，你将得到以下类似的结果：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that in the installed feature’s output entry, Quarkus mentions `CDI` and
    `Cucumber` as extensions that are being used.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在已安装功能的输出条目中，Quarkus 提到了 `CDI` 和 `Cucumber` 作为正在使用的扩展。
- en: In this section, we learned how to configure Quarkus to work together with Cucumber
    properly. This configuration was required to configure Quarkus mocks and refactor
    test classes to inject input port objects instead of creating them with constructor
    calls.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何配置 Quarkus 正确地与 Cucumber 一起工作。此配置是为了配置 Quarkus 模拟并重构测试类，以注入输入端口对象而不是通过构造函数调用创建它们。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had the opportunity to learn how Quarkus provides dependency
    injection through Quarkus DI. We started by reviewing some of the concepts defined
    by the CDI for **Java 2.0** specification, the specification that Quarkus DI is
    derived from. Then, we proceeded to implement these concepts in our hexagonal
    application. We defined the managed beans and injected them while refactoring
    use cases, ports, and adapters. Finally, we learned how to integrate Quarkus with
    Cucumber to get the best of both worlds while testing our hexagonal application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有机会学习 Quarkus 如何通过 Quarkus DI 提供依赖注入。我们首先回顾了 CDI 为 **Java 2.0** 规范定义的一些概念，该规范是
    Quarkus DI 所依据的。然后，我们继续在我们的六边形应用程序中实现这些概念。我们在重构用例、端口和适配器时定义了托管 Bean 并注入了它们。最后，我们学习了如何将
    Quarkus 与 Cucumber 集成，以便在测试我们的六边形应用程序时获得两者的最佳效果。
- en: By implementing Quarkus dependency injection mechanisms into a hexagonal system,
    we are also turning it into a more robust and modern system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Quarkus 依赖注入机制集成到六边形系统中，我们也将它转变为一个更健壮和现代的系统。
- en: In the next chapter, we’ll turn our attention to adapters. Quarkus provides
    powerful capabilities for creating reactive REST endpoints and we’ll learn how
    to integrate them with hexagonal system adapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注适配器。Quarkus 提供了创建反应式 REST 端点的强大功能，我们将学习如何将它们与六边形系统适配器集成。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Quarkus DI is based on which Java specification?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus DI 基于哪个 Java 规范？
- en: What is the difference between the `ApplicationScoped` and `Singleton` scopes?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ApplicationScoped` 和 `Singleton` 范围之间的区别是什么？'
- en: What is the annotation we should use to provide dependencies through Quarkus
    DI instead of using calling constructors?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用哪种注解来通过 Quarkus DI 提供依赖关系，而不是使用调用构造函数？
- en: To enable Quarkus testing capabilities, which annotation should we use?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 Quarkus 测试功能，我们应该使用哪个注解？
- en: Answers
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: It’s based on the CDI for **Java** **2.0** specification.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它基于 **Java** **2.0** 规范的 CDI。
- en: When using `ApplicationScope`, the objects are lazily loaded. With `Singleton`,
    the objects are eagerly loaded.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `ApplicationScope` 时，对象是延迟加载的。使用 `Singleton` 时，对象是预先加载的。
- en: The `@``Inject` annotation.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Inject` 注解。'
- en: The `@``QuarkusTest` annotation.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@QuarkusTest` 注解。'
