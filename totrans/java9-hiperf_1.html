<html><head></head><body><div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Chapter 1. Learning Java 9 Underlying Performance Improvements"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title"><a id="ch01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Chapter 1. Learning Java 9 Underlying Performance Improvements</h1></div></div></div><p class="calibre11">Just when you think you have a handle on lambdas and all the performance-related features of Java 8, along comes Java 9. What follows are several of the capabilities that made it into Java 9 that you can use to help improve the performance of your applications. These go beyond byte-level changes like for string storage or garbage collection changes, which you have little control over. Also, ignore implementation changes like those for faster object locking, since you don't have to do anything differently and you automatically get these improvements. Instead, there are new library features and completely new command-line tools that will help you create apps quickly.</p><p class="calibre11">In this lesson, we will cover the following topics:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">Modular development and its impact on performance</li><li class="listitem">Various string-related performance improvements, including compact string and indify string concatenation</li><li class="listitem">Advancement in concurrency</li><li class="listitem">Various underlying compiler improvements, such as tiered attribution and <span class="emphasis"><strong class="calibre13">Ahead-of-Time</strong></span> (<span class="emphasis"><strong class="calibre13">AOT</strong></span>) compilation</li><li class="listitem">Security manager improvements</li><li class="listitem">Enhancements in graphics rasterizers</li></ul></div><div class="calibre2" title="Introducing the New Features of Java 9"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Introducing the New Features of Java 9</h1></div></div></div><p class="calibre11">In this lesson, we will explore many under the cover improvements to performance that you automatically get by just running your application in the new environment. Internally, string changes also drastically reduce memory footprint requirements for times when you don't need full-scale Unicode support in your character strings. If most of your strings can be encoded either as ISO-8859-1 or Latin-1 (1 byte per character), they'll be stored much more efficiently in Java 9. So, let's dive deep into the core libraries and learn the underlying performance improvements.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Modular Development and Its Impact"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec06" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Modular Development and Its Impact</h1></div></div></div><p class="calibre11">In software engineering, modularity is an important concept. From the point of view of performance as well as maintainability, it is important to create autonomous units called <span class="emphasis"><strong class="calibre13">modules</strong></span>. These modules can be tied together to make a complete system. The modules provides encapsulation where the implementation is hidden from other modules. Each module can expose distinct APIs that can act as connectors so that other modules can communicate with it. This type of design is useful as it promotes loose coupling, helps focus on singular functionality to make it cohesive, and enables testing it in isolation. It also reduces system complexity and optimizes application development process. Improving performance of each module helps improving overall application performance. Hence, modular development is a very important concept.</p><p class="calibre11">I know you may be thinking, wait a minute, isn't Java already modular? Isn't the object-oriented nature of Java already providing modular operation? Well, object-oriented certainly imposes uniqueness along with data encapsulation. It only recommends loose coupling but does not strictly enforce it. In addition, it fails to provide identity at the object level and also does not have any versioning provision for the interfaces. Now you may be asking, what about JAR files? Aren't they modular? Well, although JARs provide modularization to some extent, they don't have the uniqueness that is required for modularization. They do have a provision to specify the version number, but it is rarely used and also hidden in the JAR's manifest file.</p><p class="calibre11">So we need a different design from what we already have. In simple terms, we need a modular system in which each module can contain more than one package and offers robust encapsulation compared to the standard JAR files.</p><p class="calibre11">This is what Java 9's modular system offers. In addition to this, it also replaces the fallible classpath mechanism by declaring dependencies explicitly. These enhancements improve the overall application performance as developers can now optimize the individual self-contained unit without affecting the overall system.</p><p class="calibre11">This also makes the application more scalable and provides high integrity.</p><p class="calibre11">Let's look at some of the basics of the module system and how it is tied together. To start off with, you can run the following commands to see how the module system is structured:</p><div class="calibre2"><pre class="programlisting">
<span class="emphasis"><strong class="calibre13">$java --list-modules</strong></span>
</pre></div><div class="mediaobject"><img src="Images/01_01.jpg" alt="Modular Development and Its Impact" class="calibre14"/></div><p class="calibre11">If you are interested in a particular module, you can simply add the module name at the end of the command, as shown in the following command:</p><div class="calibre2"><pre class="programlisting">
<span class="emphasis"><strong class="calibre13">$java --list-modules java.base</strong></span>
</pre></div><div class="mediaobject"><img src="Images/01_02.jpg" alt="Modular Development and Its Impact" class="calibre15"/></div><p class="calibre11">The earlier command will show all the exports in packages from the base module. Java base is the core of the system.</p><p class="calibre11">This will show all the graphical user interface packages. This will also show <code class="literal">requires</code> which are the dependencies:</p><div class="calibre2"><pre class="programlisting">
<span class="emphasis"><strong class="calibre13">$java --list-modules java.desktop</strong></span>
</pre></div><div class="mediaobject"><img src="Images/01_03.jpg" alt="Modular Development and Its Impact" class="calibre16"/></div><p class="calibre11">So far so good, right? Now you may be wondering, I got my modules developed but how to integrate them together? Let's look into that. Java 9's modular system comes with a tool called <span class="emphasis"><strong class="calibre13">JLink</strong></span>. I know you can guess what I am going to say now. You are right, it links a set of modules and creates a runtime image. Now imagine the possibilities it can offer. You can create your own executable system with your own custom modules. Life is going to be a lot more fun for you, I hope! Oh, and on the other hand, you will be able to control the execution and remove unnecessary dependencies.</p><p class="calibre11">Let's see how to link modules together. Well, it's very simple. Just run the following command:</p><div class="calibre2"><pre class="programlisting">
<span class="emphasis"><strong class="calibre13">$jlink --module-path $JAVA_HOME/jmods:mlib --add-modules java.desktop --output myawesomeimage</strong></span>
</pre></div><p class="calibre11">This linker command will link all the modules for you and create a runtime image. You need to provide a module path and then add the module that you want to generate a figure and give a name. Isn't it simple?</p><p class="calibre11">Now, let's check whether the previous command worked properly or not. Let's verify the modules from the figure:</p><div class="calibre2"><pre class="programlisting">
<span class="emphasis"><strong class="calibre13">$myawesomeimage/bin/java --list-modules</strong></span>
</pre></div><p class="calibre11">The output looks like this:</p><div class="mediaobject"><img src="Images/01_04.jpg" alt="Modular Development and Its Impact" class="calibre17"/></div><p class="calibre11">With this, you will now be able to distribute a quick runtime with your application. It is awesome, isn't it? Now you can see how we moved from a somewhat monolithic design to a self-contained cohesive one. Each module contains its own exports and dependencies and JLink allows you to create your own runtime. With this, we got our modular platform.</p><p class="calibre11">Note that the aim of this section is to just introduce you to the modular system. There is a lot more to explore but that is beyond the scope of this book. In this book, we will focus on the performance enhancement areas.</p><div class="calibre2" title="Quick Introduction to Modules"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Quick Introduction to Modules</h2></div></div></div><p class="calibre11">I am sure that after reading about the modular platform, you must be excited to dive deep into the module architecture and see how to develop one. Hold your excitement please, I will soon take you on a journey to the exciting world of modules.</p><p class="calibre11">As you must have guessed, every module has a property <code class="literal">name</code> and is organized by packages. Each module acts as a self-contained unit and may have native code, configurations, commands, resources, and so on. A module's details are stored in a file named <code class="literal">module-info.java</code>, which resides in the root directory of the module source code. In that file, a module can be defined as follows:</p><div class="calibre2"><pre class="programlisting">module &lt;name&gt;{
}</pre></div><p class="calibre11">In order to understand it better, let's go through an example. Let's say, our module name is <code class="literal">PerformanceMonitor</code>. The purpose of this module is to monitor the application performance. The input connectors will accept method names and the required parameters for that method. This method will be called from our module to monitor the module's performance. The output connectors will provide performance feedback for the given module. Let's create a <code class="literal">module-info.java</code> file in the root directory of our performance application and insert the following section:</p><div class="calibre2"><pre class="programlisting">module com.java9highperformance.PerformanceMonitor{
}</pre></div><p class="calibre11">Awesome! You got your first module declaration. But wait a minute, it does not do anything yet. Don't worry, we have just created a skeleton for this. Let's put some flesh on the skeleton. Let's assume that our module needs to communicate with our other (magnificent) modules, which we have already created and named--<code class="literal">PerformanceBase</code>, <code class="literal">StringMonitor</code>, <code class="literal">PrimitiveMonitor</code>, <code class="literal">GenericsMonitor</code>, and so on. In other words, our module has an external dependency. You may be wondering, how would we define this relationship in our module declaration? Ok, be patient, this is what we will see now:</p><div class="calibre2"><pre class="programlisting">module com.java9highperformance.PerformanceMonitor{
    exports com.java9highperformance.StringMonitor;
    exports com.java9highperformance.PrimitiveMonitor;
    exports com.java9highperformance.GenericsMonitor;
    requires com.java9highperformance.PerformanceBase;
    requires com.java9highperformance.PerformanceStat;
    requires com.java9highperformance.PerformanceIO;
}</pre></div><p class="calibre11">Yes, I know you have spotted two clauses, that is, <code class="literal">exports</code> and <code class="literal">requires</code>. And I am sure you are curious to know what they mean and why we have them there. We'll first talk about these clauses and what they mean when used in the module declaration:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">exports</code>: This clause is used when your module has a dependency on another module. It denotes that this module exposes only public types to other modules and none of the internal packages are visible. In our case, the module <code class="literal">com.java9highperformance.PerformanceMonitor</code> has a dependency on <code class="literal">com.java9highperformance.StringMonitor</code>, <code class="literal">com.java9highperformance.PrimitiveMonitor</code>, and <code class="literal">com.java9highperformance.GenericsMonitor</code>. These modules export their API packages <code class="literal">com.java9highperformance.StringMonitor</code>, <code class="literal">com.java9highperformance.PrimitiveMonitor</code>, and <code class="literal">com.java9highperformance.GenericsMonitor</code>, respectively.</li><li class="listitem"><code class="literal">requires</code>: This clause denotes that the module depends upon the declared module at both compile and runtime. In our case, <code class="literal">com.java9highperformance.PerformanceBase</code>, <code class="literal">com.java9highperformance.PerformanceStat</code>, and <code class="literal">com.java9highperformance.PerformanceIO</code> modules are required by our <code class="literal">com.java9highperformance.PerformanceMonitor</code> module. The module system then locates all the observable modules to resolve all the dependencies recursively. This transitive closure gives us a module graph which shows a directed edge between two dependent modules.</li></ul></div><div class="note" title="Note"><div class="inner"><h3 class="title3"><a id="note01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Note</h3><p class="calibre18">
<span class="emphasis"><strong class="calibre13">Note</strong></span>: Every module is dependent on <code class="literal">java.base</code> even without explicitly declaring it. As you already know, everything in Java is an object.</p></div></div><p class="calibre11">Now you know about the modules and their dependencies. So, let's draw a module representation to understand it better. The following figure shows the various packages that are dependent on <code class="literal">com.java9highperformance.PerformanceMonitor</code>.</p><div class="mediaobject"><img src="Images/01_05.jpg" alt="Quick Introduction to Modules" class="calibre19"/></div><p class="calibre11">Modules at the bottom are <code class="literal">exports</code> modules and modules on the right are <code class="literal">requires</code> modules.</p><p class="calibre11">Now let's explore a concept called <span class="emphasis"><strong class="calibre13">readability relationship</strong></span>. Readability relationship is a relationship between two modules where one module is dependent on another module. This readability relationship is a basis for reliable configuration. So in our example, we can say <code class="literal">com.java9highperformance.PerformanceMonitor</code> reads <code class="literal">com.java9highperformance.PerformanceStat</code>.</p><p class="calibre11">Let's look at <code class="literal">com.java9highperformance.PerformanceStat</code> module's description file <code class="literal">module-info.java</code>:</p><div class="calibre2"><pre class="programlisting">module com.java9highperformance.PerformanceStat{
    requires transitive java.lang;
}</pre></div><p class="calibre11">This module depends on the <code class="literal">java.lang module</code>. Let's look at the <code class="literal">PerformanceStat</code> module in detail:</p><div class="calibre2"><pre class="programlisting">package com.java9highperformance.PerformanceStat;
import java.lang.*;

public Class StringProcessor{
    public String processString(){...}
}</pre></div><p class="calibre11">In this case, <code class="literal">com.java9highperformance.PerformanceMonitor</code> only depends on <code class="literal">com.java9highperformance.PerformanceStat</code> but <code class="literal">com.java9highperformance.PerformanceStat</code> depends on <code class="literal">java.lang</code>. The <code class="literal">com.java9highperformance.PerformanceMonitor</code> module is not aware of the <code class="literal">java.lang</code> dependency from the <code class="literal">com.java9highperformance.PerformanceStat</code> module. This type of problem is taken care of by the module system. It has added a new modifier called <span class="emphasis"><strong class="calibre13">transitive</strong></span>. If you look at <code class="literal">com.java9highperformance.PerformanceStat</code>, you will find it requires transitive <code class="literal">java.lang</code>. This means that any one depending on <code class="literal">com.java9highperformance.PerformanceStat</code> reads on <code class="literal">java.lang</code>. </p><p class="calibre11">See the following graph which shows the readability graph:</p><div class="mediaobject"><img src="Images/01_06.jpg" alt="Quick Introduction to Modules" class="calibre20"/></div><p class="calibre11">Now, in order to compile the <code class="literal">com.java9highperformance.PerformanceMonitor</code> module, the system must be able to resolve all the dependencies. These dependencies can be found from the module path. That's obvious, isn't that? However, don't misunderstand the classpath with the module path. It is a completely different breed. It doesn't have the issues that the packages have.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="String Operations Performance"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec07" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>String Operations Performance</h1></div></div></div><p class="calibre11">If you are not new to programming, string must be your best friend so far. In many cases, you may like it more than your spouse or partner. As we all know, you can't live without string, in fact, you can't even complete your application without a single use of string. OK, enough has been expressed about string and I am already feeling dizzy by the string usage just like JVM in the earlier versions. Jokes apart, let's talk about what has changed in Java 9 that will help your application perform better. Although this is an internal change, as an application developer, it is important to understand the concept so you know where to focus for performance improvements.</p><p class="calibre11">Java 9 has taken a step toward improving string performance. If you have ever come across JDK 6's failed attempt <code class="literal">UseCompressedStrings</code>, then you must be looking for ways to improve string performance. Since <code class="literal">UseCompressedStrings</code> was an experimental feature that was error prone and not designed very well, it was removed in JDK 7. Don't feel bad about it, I know it's terrible but as always the golden days eventually come. The JEP team has gone through immense pain to add a compact string feature that will reduce the footprint of string and its related classes.</p><p class="calibre11">Compact strings will improve the footprint of string and help in using memory space efficiently. It also preserves compatibility for all related Java and native interfaces. The second important feature is <span class="emphasis"><strong class="calibre13">Indify String Concatenation</strong></span>, which will optimize a string at runtime.</p><p class="calibre11">In this section, we will take a closure look at these two features and their impact on overall application performance.</p><div class="calibre2" title="Compact String"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Compact String</h2></div></div></div><p class="calibre11">Before we talk about this feature, it is important to understand why we even care about this. Let's dive deep into the underworld of JVM (or as any star wars fan would put it, the dark side of the Force). Let's first understand how JVM treats our beloved string and that will help us understand this new shiny compact string improvement. Let's enter into the magical world of heap. And as a matter of fact, no performance book is complete without a discussion of this mystical world.</p><div class="calibre2" title="The World of Heap"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title4"><a id="ch01lvl3sec01" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>The World of Heap</h3></div></div></div><p class="calibre11">Each time JVM starts, it gets some memory from the underlining operating system. It is separated into two distinct regions called <span class="emphasis"><strong class="calibre13">heap space</strong></span> and <span class="emphasis"><strong class="calibre13">Permgen</strong></span>. These are home to all your application's resources. And as always with all good things in life, this home is limited in size. This size is set during the JVM initialization; however, you can increase or decrease this by specifying the JVM parameters, <code class="literal">-Xmx</code>, and <code class="literal">-XX:MaxPermSize</code>.</p><p class="calibre11">The heap size is divided into two areas, the nursery or young space and the old space. As the name suggests, the young space is home to new objects. This all sounds great but every house needs a cleanup. Hence, JVM has the most efficient cleaner called <span class="emphasis"><strong class="calibre13">garbage collector</strong></span> (most efficient? Well... let's not get into that just yet). As any productive cleaner would do, the garbage collector efficiently collects all the unused objects and reclaims memory. When this young space gets filled up with new objects, the garbage collector takes charge and moves any of those who have lived long enough in the young space to the old space. This way, there is always room for more objects in the young space.</p><p class="calibre11">And in the same way, if the old space becomes filled up, the garbage collector reclaims the memory used.</p></div></div><div class="calibre2" title="Why Bother Compressing Strings?"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec03" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Why Bother Compressing Strings?</h2></div></div></div><p class="calibre11">Now you know a little bit about heap, let's look at the <code class="literal">String</code> class and how strings are represented on heap. If you dissect the heap of your application, you will notice that there are two objects, one is the Java language <code class="literal">String</code>object that references the second object <code class="literal">char[]</code> that actually handles the data. The <code class="literal">char</code> datatype is UTF-16 and hence takes up to 2 bytes. Let's look at the following example of how two different language strings look:</p><div class="calibre2"><pre class="programlisting">2 byte per char[]
Latin1 String : 1 byte per char[]</pre></div><p class="calibre11">So you can see that <code class="literal">Latin1 String</code> only consumes 1 byte, and hence we are losing about 50% of the space here. There is an opportunity to represent it in a more dense form and improve the footprint, which will eventually help in speeding up garbage collection as well.</p><p class="calibre11">Now, before making any changes to this, it is important to understand its impact on real-life applications. It is essential to know whether applications use 1 byte per <code class="literal">char[]</code> strings or 2 bytes per <code class="literal">char[]</code> strings.</p><p class="calibre11">To get an answer to this, the JPM team analyzed a lot of heap dumps of real-world data. The result highlighted that a majority of heap dumps have around 18 percent to 30 percent of the entire heap consumed by <code class="literal">chars[]</code>, which come from string. Also, it was prominent that most strings were represented by a single byte per <code class="literal">char[]</code>. So, it is clear that if we try to improve the footprint for strings with a single byte, it will give significant performance boost to many real-life applications.</p><div class="calibre2" title="What Did They Do?"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title4"><a id="ch01lvl3sec02" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>What Did They Do?</h3></div></div></div><p class="calibre11">After having gone through a lot of different solutions, the JPM team has finally decided to come up with a strategy to compress string during its construction. First, optimistically try to compress in 1 byte and if it is not successful, copy it as 2 bytes. There are a few shortcuts possible, for example, the use of a special case encoder like ISO-8851-1, which will always spit 1 byte.</p><p class="calibre11">This implementation is a lot better than JDK 6's <code class="literal">UseCompressedStrings</code> implementation, which was only helpful to a handful of applications as it was compressing string by repacking and unpacking on every single instance. Hence the performance gain comes from the fact that it can now work on both the forms.</p></div><div class="calibre2" title="What is the Escape Route?"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title4"><a id="ch01lvl3sec03" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>What is the Escape Route?</h3></div></div></div><p class="calibre11">Even though it all sounds great, it may affect the performance of your application if it only uses 2 byte per <code class="literal">char[]</code>string. In that case, it make sense not to use the earlier mentioned, check, and directly store string as 2 bytes per <code class="literal">char[]</code>. Hence, the JPM team has provided a kill switch <code class="literal">--XX: -CompactStrings</code> using which you can disable this feature.</p></div><div class="calibre2" title="What is the Performance Gain?"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title4"><a id="ch01lvl3sec04" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>What is the Performance Gain?</h3></div></div></div><p class="calibre11">The previous optimization affects the heap as we saw earlier that the string is represented in the heap. Hence, it is affecting the memory footprint of the application. In order to evaluate the performance, we really need to focus on the garbage collector. We will explore the garbage collection topic later, but for now, let's just focus on the run-time performance.</p></div></div><div class="calibre2" title="Indify String Concatenation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec04" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Indify String Concatenation</h2></div></div></div><p class="calibre11">I am sure you must be thrilled by the concept of the compact string feature we just learned about. Now let's look at the most common usage of string, which is concatenation. Have you ever wondered what really happens when we try to concatenate two strings? Let's explore. Take the following example:</p><div class="calibre2"><pre class="programlisting">public static String getMyAwesomeString(){
    int javaVersion = 9;
    String myAwesomeString = "I love " + "Java " + javaVersion + " high       performance book by Mayur Ramgir";
    return myAwesomeString;
}</pre></div><p class="calibre11">In the preceding example, we are trying to concatenate a few strings with the <code class="literal">int</code> value. The compiler will then take your awesome strings, initialize a new <code class="literal">StringBuilder</code> instance, and then append all these individuals strings. Take a look at the following bytecode generation by <code class="literal">javac</code>. I have used the <span class="emphasis"><strong class="calibre13">ByteCode Outline</strong></span> plugin for <span class="emphasis"><strong class="calibre13">Eclipse</strong></span> to visualize the disassembled bytecode of this method. You may download it from <a class="calibre4 pcalibre3 pcalibre pcalibre1 pcalibre2" href="http://andrei.gmxhome.de/bytecode/index.html">http://andrei.gmxhome.de/bytecode/index.html</a>:</p><div class="calibre2"><pre class="programlisting">// access flags 0x9
public static getMyAwesomeString()Ljava/lang/String;
  L0
  LINENUMBER 10 L0
  BIPUSH 9
  ISTORE 0
  L1
  LINENUMBER 11 L1
  NEW java/lang/StringBuilder
  DUP
  LDC "I love Java "
  INVOKESPECIAL java/lang/StringBuilder.&lt;init&gt; (Ljava/lang/String;)V
  ILOAD 0
  INVOKEVIRTUAL java/lang/StringBuilder.append (I)Ljava/lang/StringBuilder;
  LDC " high performance book by Mayur Ramgir"
  INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
  INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
  ASTORE 1
  L2
  LINENUMBER 12 L2
  ALOAD 1
  ARETURN
  L3
  LOCALVARIABLE javaVersion I L1 L3 0
  LOCALVARIABLE myAwesomeString Ljava/lang/String; L2 L3 1
  MAXSTACK = 3
  MAXLOCALS = 2</pre></div><p class="calibre11">Quick Note: How do we interpret this?</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">INVOKESTATIC</code>: This is useful for invoking static methods</li><li class="listitem"><code class="literal">INVOKEVIRTUAL</code>: This uses of dynamic dispatch for invoking public and protected non-static methods</li><li class="listitem"><code class="literal">INVOKEINTERFACE</code>: This is very similar to <code class="literal">INVOKEVIRTUAL</code> except that the method dispatch is based on an interface type</li><li class="listitem"><code class="literal">INVOKESPECIAL</code>: This is useful for invoking constructors, methods of a superclass, and private methods</li></ul></div><p class="calibre11">However, at runtime, due to the inclusion of <code class="literal">-XX:+-OptimizeStringConcat</code> into the JIT compiler, it can now identify the append of <code class="literal">StringBuilder</code> and the <code class="literal">toString</code> chains. In case the match is identified, produce low-level code for optimum processing. Compute all the arguments' length, figure out the final capacity, allocate the storage, copy the strings, and do the in place conversion of primitives. After this, handover this array to the <code class="literal">String</code> instance without copying. It is a profitable optimization.</p><p class="calibre11">But this also has a few drawbacks in terms of concatenation. One example is that in case of a concatenating string with long or double, it will not optimize properly. This is because the compiler has to do <code class="literal">.getChar</code> first which adds overhead.</p><p class="calibre11">Also, if you are appending <code class="literal">int</code> to <code class="literal">String</code>, then it works great; however, if you have an incremental operator like <code class="literal">i++</code>, then it breaks. The reason behind this is that you need to rewind to the beginning of the expression and re-execute, so you are essentially doing <code class="literal">++</code> twice. And now the most important change in Java 9 compact string. The length spell like <code class="literal">value.length &gt;&gt; coder</code>; <code class="literal">C2</code> cannot optimize it as it does not know about the IR.</p><p class="calibre11">Hence, to solve the problem of compiler optimization and runtime support, we need to control the bytecode, and we cannot expect <code class="literal">javac</code> to handle that.</p><p class="calibre11">We need to delay the decision of which concatenation can be done at runtime. So can we have just method <code class="literal">String.concat</code> which will do the magic. Well, don't rush into this yet as how would you design the method <code class="literal">concat</code>. Let's take a look. One way to go about this is to accept an array of the <code class="literal">String</code> instance:</p><div class="calibre2"><pre class="programlisting">public String concat(String... n){
    //do the concatenation
}</pre></div><p class="calibre11">However, this approach will not work with primitives as you now need to convert each primitive to the <code class="literal">String</code>instance and also, as we saw earlier, the problem is that long and double string concatenation will not allow us to optimize it. I know, I can sense the glow on your face like you got a brilliant idea to solve this painful problem. You are thinking about using the <code class="literal">Object</code> instance instead of the <code class="literal">String</code> instance, right? As you know the <code class="literal">Object</code>instance is catch all. Let's look at your brilliant idea:</p><div class="calibre2"><pre class="programlisting">public String concat(Object... n){
    //do the concatenation
}</pre></div><p class="calibre11">First, if you are using the <code class="literal">Object</code> instance, then the compiler needs to do autoboxing. Additionally, you are passing in the <code class="literal">varargs</code> array, so it will not perform optimally. So, are we stuck here? Does it mean we cannot use the preeminent compact string feature with string concatenation? Let's think a bit more; maybe instead of using the method <code class="literal">runtime</code>, let <code class="literal">javac</code> handle the concatenation and just give us the optimized bytecode. That sounds like a good idea. Well, wait a minute, I know you are thinking the same thing. What if JDK 10 optimizes this further? Does that mean, when I upgrade to the new JDK, I have to recompile my code again and deploy it again? In some cases, its not a problem, in other cases, it is a big problem. So, we are back to square one.</p><p class="calibre11">We need something that can be handled at runtime. Ok, so that means we need something which will dynamically invoke the methods. Well, that rings a bell. If we go back in our time machine, at the dawn of the era of JDK 7 it gave us <code class="literal">invokedynamic</code>. I know you can see the solution, I can sense the sparkle in your eyes. Yes, you are right, <code class="literal">invokedynamic</code> can help us here. If you are not aware of <code class="literal">invokedynamic</code>, let's spend some time to understand it. For those who have already mastered the topic, you could skip it, but I would recommend you go through this again.</p><div class="calibre2" title="Invokedynamic"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h3 class="title4"><a id="ch01lvl3sec05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Invokedynamic</h3></div></div></div><p class="calibre11">The <code class="literal">invokedynamic</code> feature is the most notable feature in the history of Java. Rather than having a limit to JVM bytecode, we now can define our own way for operations to work. So what is <code class="literal">invokedynamic</code>? In simple terms, it is the user-definable bytecode. This bytecode (instead of JVM) determines the execution and optimization strategies. It offers various method pointers and adapters which are in the form of method handling APIs. The JVM then work on the pointers given in the bytecode and use reflection-like method pointers to optimize it. This way, you, as a developer, can get full control over the execution and optimization of code.</p><p class="calibre11">It is essentially a mix of user-defined bytecode (which is known as <span class="emphasis"><strong class="calibre13">bytecode + bootstrap</strong></span>) and method handles. I know you are also wondering about the method handles--what are they and how to use them? Ok, I heard you, let's talk about method handles.</p><p class="calibre11">Method handles provide various pointers, including field, array, and method, to pass data and get results back. With this, you can do argument manipulation and flow control. From JVM's point of view, these are native instructions that it can optimize as if it were bytecode. However, you have the option to programmatically generate this bytecode.</p><p class="calibre11">Let's zoom in to the method handles and see how it all ties up together. The main package's name is <code class="literal">java.lang.invoke</code>, which has <code class="literal">MethodHandle</code>, <code class="literal">MethodType</code>, and <code class="literal">MethodHandles</code>. <code class="literal">MethodHandle</code> is the pointer that will be used to invoke the function. <code class="literal">MethodType</code> is a representation of a set of arguments and return value coming from the method. The utility class <code class="literal">MethodHandles</code> will act as a pointer to a method which will get an instance of <code class="literal">MethodHandle</code> and map the arguments.</p><p class="calibre11">We won't be going in deep for this section, as the aim was just to make you aware of what the <code class="literal">invokedynamic</code> feature is and how it works so you will understand the string concatenation solution. So, this is where we get back to our discussion on string concatenation. I know, you were enjoying the <code class="literal">invokedynamic</code> discussion, but I guess I was able to give you just enough insight to make you understand the core idea of Indify String Concatenation.</p><p class="calibre11">Let's get back on the concatenation part where we were looking for a solution to concatenate our awesome compact strings. For concatenating the compact strings, we need to take care of types and the number of types of methods and this is what the <code class="literal">invokedynamic</code> gives us.</p><p class="calibre11">So let's use <code class="literal">invokedynamic</code> for <code class="literal">concat</code>. Well, not so quick, my friend. There is a fundamental problem with this approach. We cannot just use <code class="literal">invokedynamic</code> as it is to solve this problem. Why? Because there is a circular reference. The <code class="literal">concat</code> function needs <code class="literal">java.lang.invoke</code>, which uses <code class="literal">concat</code>. This continues, and eventually you will get <code class="literal">StackOverflowError</code>.</p><p class="calibre11">Take a look at the following code:</p><div class="calibre2"><pre class="programlisting">String concat(int i, long l, String s){
    return s + i + l
}</pre></div><p class="calibre11">So if we were to use <code class="literal">invokedynamic</code> here, the <code class="literal">invokedynamic</code> call would look like this:</p><div class="calibre2"><pre class="programlisting">InvokeDynamic #0: makeConcat(String, int, long)</pre></div><p class="calibre11">There is a need to break the circular reference. However, in the current JDK implementation, you cannot control what <code class="literal">java.invoke</code> calls from the complete JDK library. Also, removing the complete JDK library reference from <code class="literal">java.invoke</code> has severe side effects. We only need the <code class="literal">java.base</code> module for Indify String Concatenation, and if we can figure out a way to just call the <code class="literal">java.base</code> module, then it will significantly improve the performance and avoid unpleasant exceptions. I know what you are thinking. We just studied the coolest addition to Java 9, <span class="emphasis"><strong class="calibre13">Project Jigsaw</strong></span>. It provides modular source code and now we can only accept the <code class="literal">java.base</code> module. This solves the biggest problem we were facing in terms of concatenating two strings, primitives, and so on.</p><p class="calibre11">After going through a couple of different strategies, the Java Performance Management team has settled on the following strategy:</p><div class="calibre2"><ol class="orderedlist"><li class="listitem1">Make a call to the <code class="literal">toString()</code> method on all reference args.</li><li class="listitem1">Make a call to the <code class="literal">tolength()</code> method or since all the underlying methods are exposed, just call <code class="literal">T.stringSize(T t)</code> on every args.</li><li class="listitem1">Figure out the coders and call <code class="literal">coder()</code> for all reference args.</li><li class="listitem1">Allocate <code class="literal">byte[]</code> storage and then copy all args. And then, convert primitives in-place.</li><li class="listitem1">Invoke a private constructor <code class="literal">String</code> by handing over the array for concatenation.</li></ol></div><p class="calibre11">With this, we are able to get an optimized string concat in the same code and not in <code class="literal">C2 IR</code>. This strategy gives us 2.9x better performance and 6.4x less garbage.</p></div></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Storing Interned Strings in CDS Archives"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec08" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Storing Interned Strings in CDS Archives</h1></div></div></div><p class="calibre11">The main goal of this feature is to reduce memory footprint caused by creating new instances of string in every JVM process. All the classes that are loaded in any JVM process can be shared with other JVM processes via <span class="emphasis"><strong class="calibre13">Class Data Sharing</strong></span> (<span class="emphasis"><strong class="calibre13">CDS</strong></span>) archives.</p><p class="calibre11">Oh, I did not tell you about CDS. I think it's important to spend some time to understand what CDS is, so you can understand the underlying performance improvement.</p><p class="calibre11">Many times, small applications in particular spend a comparatively long time on startup operations. To reduce this startup time, a concept called CDS was introduced. CDS enables sharing of a set of classes loaded from the system JAR file into a private internal representation during the JRE installation. This helps a lot as then any further JVM invocations can take advantage of these loaded classes' representation from the shared archive instead of loading these classes again. The metadata related to these classes is shared among multiple JVM processes.</p><p class="calibre11">CDS stores strings in the form of UTF-8 in the constant pool. When a class from these loaded classes begins the initialization process, these UTF-8 strings are converted into <code class="literal">String</code> objects on demand. In this structure, every character in every confined string takes 2 bytes in the <code class="literal">String</code> object and 1 byte to 3 bytes in the UTF-8, which essentially wastes memory. Since these strings are created dynamically, different JVM processes cannot share these strings.</p><p class="calibre11">Shared strings need a feature called <span class="emphasis"><strong class="calibre13">pinned regions</strong></span> in order to make use of the garbage collector. Since the only HotSpot garbage collector that supports pinning is G1; it only works with the G1 garbage collector.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Concurrency Performance"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec09" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Concurrency Performance</h1></div></div></div><p class="calibre11">Multithreading is a very popular concept. It allows programs to run multiple tasks at the same time. These multithreaded programs may have more than one unit which can run concurrently. Every unit can handle a different task keeping the use of available resources optimal. This can be managed by multiple threads that can run in parallel.</p><p class="calibre11">Java 9 improved contended locking. You may be wondering what is contended locking. Let's explore. Each object has one monitor that can be owned by one thread at a time. Monitors are the basic building blocks of concurrency. In order for a thread to execute a block of code marked as synchronized on an object or a synchronized method declared by an object, it must own this object's monitor. Since there are multiple threads trying to get access to the mentioned monitor, JVM needs to orchestrate the process and only allow one thread at a time. It means the rest of threads go in a wait state. This monitor is then called contended. Because of this provision, the program wastes time in the waiting state.</p><p class="calibre11">Also, <span class="emphasis"><strong class="calibre13">Java Virtual Machine</strong></span> (<span class="emphasis"><strong class="calibre13">JVM</strong></span>) does some work orchestrating the lock contention. Additionally, it has to manage threads, so once the existing thread finishes its execution, it can allow a new thread to go in. This certainly adds overhead and affects performance adversely. Java 9 has taken a few steps to improve in this area. The provision refines the JVM's orchestration, which will ultimately result in performance improvement in highly contested code.</p><p class="calibre11">The following benchmarks and tests can be used to check the performance improvements of contented Java object monitors:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem"><code class="literal">CallTimerGrid</code> (This is more of a stress test than a benchmark)</li><li class="listitem"><code class="literal">Dacapo-bach</code> (earlier dacapo2009)</li><li class="listitem"><code class="literal">_ avrora</code></li><li class="listitem"><code class="literal">_ batik</code></li><li class="listitem"><code class="literal">_ fop</code></li><li class="listitem"><code class="literal">_ h2</code></li><li class="listitem"><code class="literal">_ luindex</code></li><li class="listitem"><code class="literal">_ lusearch</code></li><li class="listitem"><code class="literal">_ pmd</code></li><li class="listitem"><code class="literal">_ sunflow</code></li><li class="listitem"><code class="literal">_ tomcat</code></li><li class="listitem"><code class="literal">_ tradebeans</code></li><li class="listitem"><code class="literal">_ tradesoap</code></li><li class="listitem"><code class="literal">_ xalan</code></li><li class="listitem"><code class="literal">DerbyContentionModelCounted</code></li><li class="listitem"><code class="literal">HighContentionSimulator</code></li><li class="listitem"><code class="literal">LockLoops-JSR166-Doug-Sept2009</code> (earlier LockLoops)</li><li class="listitem"><code class="literal">PointBase</code></li><li class="listitem"><code class="literal">SPECjbb2013-critical</code> (earlier specjbb2005)</li><li class="listitem"><code class="literal">SPECjbb2013-max</code></li><li class="listitem"><code class="literal">specjvm2008</code></li><li class="listitem"><code class="literal">volano29</code> (earlier volano2509)</li></ul></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Compiler Improvements"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec10" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Compiler Improvements</h1></div></div></div><p class="calibre11">Several efforts have been made to improve the compiler's performance. In this section, we will focus on the improvements to the compiler side.</p><div class="calibre2" title="Tiered Attribution"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec05" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Tiered Attribution</h2></div></div></div><p class="calibre11">The first and foremost change providing compiler improvement is related to <span class="emphasis"><strong class="calibre13">Tiered Attribution</strong></span> (<span class="emphasis"><strong class="calibre13">TA</strong></span>). This change is more related to lambda expressions. At the moment, the type checking of poly expression is done by type checking the same tree multiple times against different targets. This process is called <span class="emphasis"><strong class="calibre13">Speculative Attribution</strong></span> (<span class="emphasis"><strong class="calibre13">SA</strong></span>), which enables the use of different overload resolution targets to check a lambda expression.</p><p class="calibre11">This way of type checking, although a robust technique, adversely affects performance significantly. For example, with this approach, <span class="emphasis"><em class="calibre12">n</em></span> number of overload candidates check against the same argument expression up to <span class="emphasis"><em class="calibre12">n * 3</em></span> once per overload phase, strict, loose, and varargs. In addition to this, there is one final check phase. Where lambda returns a poly method call results in combinatorial explosion of attribution calls, this causes a huge performance problem. So we certainly need a different method of type checking for poly expressions.</p><p class="calibre11">The core idea is to make sure that a method call creates bottom-up structural types for each poly argument expression with every single details, which will be needed to execute the overload resolution applicability check before performing the overload resolution.</p><p class="calibre11">So in summary, the performance improvement was able to achieve an attribute of a given expression by decreasing the total number of tries.</p></div><div class="calibre2" title="Ahead-of-Time Compilation"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h2 class="title2"><a id="ch01lvl2sec06" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Ahead-of-Time Compilation</h2></div></div></div><p class="calibre11">The second noticeable change for compiler improvement is Ahead-of-Time compilation. If you are not familiar with the term, let's see what AOT is. As you probably know, every program in any language needs a runtime environment to execute. Java also has its own runtime which is known as <span class="emphasis"><strong class="calibre13">Java Virtual Machine</strong></span> (<span class="emphasis"><strong class="calibre13">JVM</strong></span>). The typical runtime that most of us use is a bytecode interpreter, which is JIT compiler as well. This runtime is known as <span class="emphasis"><strong class="calibre13">HotSpot JVM</strong></span>.</p><p class="calibre11">This HotSpot JVM is famous for improving performance by JIT compilation as well as adaptive optimization. So far so good. However, this does not work well in practice for every single application. What if you have a very light program, say, a single method call? In this case, JIT compilation will not help you much. You need something that will load up faster. This is where AOT will help you. With AOT as opposed to JIT, instead of compiling to bytecode, you can compile into native machine code. The runtime then uses this native machine code to manage calls for new objects into mallocs as well as file access into system calls. This can improve performance.</p></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Security Manager Improvements"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec11" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Security Manager Improvements</h1></div></div></div><p class="calibre11">Ok, let's talk about security. If you are not one of those who cares about application security over pushing more features in a release, then the expression on your face may be like <span class="emphasis"><strong class="calibre13">Uh! What's that?</strong></span> If you are one those, then let's first understand the importance of security and find a way to consider this in your application development tasks. In today's SaaS-dominated world, everything is exposed to the outside world. A determined individual (a nice way of saying, a <span class="emphasis"><strong class="calibre13">malicious hacker</strong></span>), can get access to your application and exploit the security holes you may have introduced through your negligence. I would love to talk about application security in depth as this is another area I am very much interested in. However, application security is out of the scope of this book. The reason we are talking about it here is that the JPM team has taken an initiative to improve the existing security manager. Hence, it is important to first understand the importance of security before talking about the security manager.</p><p class="calibre11">Hopefully, this one line of description may have generated secure programming interest in you. However, I do understand that sometimes you may not have enough time to implement a complete secure programming model due to tight schedules. So, let's find a way which can fit with your tight schedule. Let's think for a minute; is there any way to automate security? Can we have a way to create a blueprint and ask our program to stay within the boundaries? Well, you are in luck, Java does have a feature called <span class="emphasis"><strong class="calibre13">security manager</strong></span>. It is nothing but a policy manager that defines a security policy for the application. It sounds exciting, doesn't it? But what does this policy look like? And what does it contain? Both are fair questions to ask. This security policy basically states actions that are dangerous or sensitive in nature. If your application does not comply with this policy, then the security manager throws <code class="literal">SecurityException</code>. On the other side, you can have your application call this security manager to learn about the permitted actions. Now, let's look at the security manager in detail.</p><p class="calibre11">In case of a web applet, a security manager is provided by the browser, or the Java Web Start plugin runs this policy. In many cases, applications other than web applets run without a security manager unless those applications implement one. It's a no brainer to say that if there is no security manager and no security policy attached, the application acts without restrictions.</p><p class="calibre11">Now we know a little about the security manager, let's look at the performance improvement in this area. As per the Java team, there may be a possibility that an application running with a security manager installed degrades performance by 10 percent to 15 percent. However, it is not possible to remove all the performance bottlenecks but narrowing this gap can assist in improving not only security but also performance.</p><p class="calibre11">The Java 9 team looked at some of the optimizations, including the enforcement of security policy and the evaluation of permissions, which will help improve the overall performance of using a security manager. During the performance testing phase, it was highlighted that even though the permission classes are thread safe, they show up as a HotSpot. Numerous improvements have been made to decrease thread contention and improve throughput.</p><p class="calibre11">Computing the <code class="literal">hashcode</code> method of <code class="literal">java.security.CodeSource</code> has been improved to use a string form of the code source URL to avoid potentially expensive DNS lookups. Also, the <code class="literal">checkPackageAccess</code> method of <code class="literal">java.lang.SecurityManager</code>, which contains the package checking algorithm, has been improved.</p><p class="calibre11">Some other noticeable changes in security manager improvements are as follows:</p><div class="calibre2"><ul class="itemizedlist"><li class="listitem">The first noticeable change is that using <code class="literal">ConcurrentHashMap</code> in place of <code class="literal">Collections.synchronizedMap</code> helps improving throughput of the <code class="literal">Policy.implie</code> method. Look at the following graph, taken from the OpenJDK site, which highlights the significant increase in the throughput with <code class="literal">ConcurrentHashMap</code>:<div class="mediaobject1"><img src="Images/01_07.jpg" alt="Security Manager Improvements" class="calibre21"/></div></li><li class="listitem">In addition to this, <code class="literal">HashMap</code>, which had been used for maintaining internal collection of <code class="literal">CodeSource</code> in <code class="literal">java.security.SecureClassLoader</code>, has been replaced by <code class="literal">ConcurrentHashMap</code>.</li><li class="listitem">There are a few other small improvements like an improvement in the throughput by removing the compatibility code from the <code class="literal">getPermissions</code> method (<code class="literal">CodeSource</code>), which synchronizes on identities.</li><li class="listitem">Another significant gain in performance is achieved using <code class="literal">ConcurrentHashMap</code> instead of <code class="literal">HashMap</code> surrounded by synchronized blocks in the permission checking code, which yielded in greater thread performance.</li></ul></div></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Graphics Rasterizers"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec12" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Graphics Rasterizers</h1></div></div></div><p class="calibre11">If you are into Java 2D and using OpenJDK, you will appreciate the efforts taken by the Java 9 team. Java 9 is mainly related to a graphics rasterizer, which is part of the current JDK. OpenJDK uses Pisces, whereas Oracle JDK uses Ductus. Oracle's closed-source Ductus rasterizer performs better than OpenJDK's Pisces.</p><p class="calibre11">These graphics rasterizers are useful for anti-aliased rendering except fonts. Hence, for a graphics-intensive application, the performance of this rasterizer is very important. However, Pisces is failing in many fronts and its performance problems are very visible. Hence, the team has decided to replace this with a different rasterizer called Marlin Graphics Renderer.</p><p class="calibre11">Marlin is developed in Java and, most importantly, it is the fork of the Pisces rasterizer. Various tests have been done on it and the results are very promising. It consistently performs better than Pisces. It demonstrates multithreaded scalability and even outperforms the closed-source Ductus rasterizer for a single-threaded application.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Summary"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec13" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Summary</h1></div></div></div><p class="calibre11">In this lesson, we have seen some of the exciting features that will improve your application's performance without making any effort from your end.</p><p class="calibre11">In the next lesson, we will learn about JShell and the <span class="emphasis"><strong class="calibre13">Ahead-of-Time</strong></span> (<span class="emphasis"><strong class="calibre13">AOT</strong></span>) compiler. We will also learn about <span class="emphasis"><strong class="calibre13">Read-Eval-Print Loop</strong></span> (<span class="emphasis"><strong class="calibre13">REPL</strong></span>) tool.</p></div></div>



  
<div id="sbo-rt-content" class="calibre1"><div class="calibre2" title="Assessments"><div class="titlepage"><div class="calibre2"><div class="calibre2"><h1 class="title1"><a id="ch01lvl1sec14" class="pcalibre pcalibre3 pcalibre1 calibre8 pcalibre2"/>Assessments</h1></div></div></div><div class="calibre2"><ol class="orderedlist"><li class="listitem1">JLink is a ___________ of Java 9 modular system.</li><li class="listitem1">What is the relationship between two modules where one module is dependent on another module?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1">Readability relationship</li><li class="listitem1">Operability relationship</li><li class="listitem1">Modular relationship</li><li class="listitem1">Entity relationship</li></ol></div></li><li class="listitem1">State whether True or False: Each time JVM starts, it gets some memory from the underlining operating system.</li><li class="listitem1">Which of the following perform some work orchestrating the lock contention?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1">Pinned regions</li><li class="listitem1">Readability relationship</li><li class="listitem1">Java Virtual Machine</li><li class="listitem1">Class data sharing</li></ol></div></li><li class="listitem1">Which of the following enables the use of different overload resolution targets to check a lambda expression?<div class="calibre2"><ol class="orderedlist1"><li class="listitem1">Tiered attribution</li><li class="listitem1">HotSpot JVM</li><li class="listitem1">Speculative attribution</li><li class="listitem1">Permgen</li></ol></div></li></ol></div></div></div>



  </body></html>