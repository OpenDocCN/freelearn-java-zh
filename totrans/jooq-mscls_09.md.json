["```java\nRecord1<Integer> fiscalYear = ctx.select(field(\"fiscal_year\", \n```", "```java\n  Integer.class)).from(table(\"sale\")).fetchAny();\n```", "```java\n// Offtake is a POJO\n```", "```java\nOfftake offtake = ctx.select(field(\"fiscal_year\"), \n```", "```java\n  field(\"sale\"), field(\"employee_number\")).from(table(\"sale\"))            \n```", "```java\n  .fetchAnyInto(Offtake.class);\n```", "```java\npublic interface Converter<T, U> {\n```", "```java\n   U from(T databaseObject);  // convert to user-defined type\n```", "```java\n   T to(U userDefinedObject); // convert to database type\n```", "```java\n   // Class instances for each type\n```", "```java\n   Class<T> fromType();\n```", "```java\n   Class<U> toType();\n```", "```java\n}\n```", "```java\npublic class YearMonthConverter \n```", "```java\n             implements Converter<Integer, YearMonth> {\n```", "```java\n  @Override\n```", "```java\n  public YearMonth from(Integer t) {\n```", "```java\n    if (t != null) {\n```", "```java\n      return YearMonth.of(1970, 1)\n```", "```java\n               .with(ChronoField.PROLEPTIC_MONTH, t);\n```", "```java\n    }\n```", "```java\n    return null;\n```", "```java\n  }\n```", "```java\n  @Override\n```", "```java\n  public Integer to(YearMonth u) {\n```", "```java\n    if (u != null) {\n```", "```java\n      return (int) u.getLong(ChronoField.PROLEPTIC_MONTH);\n```", "```java\n    }\n```", "```java\n    return null;\n```", "```java\n  }\n```", "```java\n  @Override\n```", "```java\n  public Class<Integer> fromType() {\n```", "```java\n    return Integer.class;\n```", "```java\n  }\n```", "```java\n  @Override\n```", "```java\n  public Class<YearMonth> toType() {\n```", "```java\n    return YearMonth.class;\n```", "```java\n  }\n```", "```java\n}\n```", "```java\npublic static final Converter<Integer, YearMonth> \n```", "```java\n  INTEGER_YEARMONTH_CONVERTER = new YearMonthConverter();\n```", "```java\npublic static final Converter<Integer[], YearMonth[]>    \n```", "```java\n  INTEGER_YEARMONTH_ARR_CONVERTER\n```", "```java\n    = INTEGER_YEARMONTH_CONVERTER.forArrays();\n```", "```java\npublic static final DataType<YearMonth> YEARMONTH\n```", "```java\n  = INTEGER.asConvertedDataType(INTEGER_YEARMONTH_CONVERTER);\n```", "```java\nctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ... ,  \n```", "```java\n               CUSTOMER.FIRST_BUY_DATE)\n```", "```java\n   .values(\"Atelier One\", ..., \n```", "```java\n       INTEGER_YEARMONTH_CONVERTER.to(YearMonth.of(2020, 10)))\n```", "```java\n   .execute();\n```", "```java\nList<YearMonth> resultListYM \n```", "```java\n  = ctx.select(CUSTOMER.FIRST_BUY_DATE).from(CUSTOMER)\n```", "```java\n       .where(CUSTOMER.CUSTOMER_NAME.eq(\"Atelier One\"))\n```", "```java\n       .fetch(CUSTOMER.FIRST_BUY_DATE, \n```", "```java\n              INTEGER_YEARMONTH_CONVERTER);\n```", "```java\nConverter<Integer, YearMonth> converter = \n```", "```java\n  Converter.ofNullable(Integer.class, YearMonth.class,\n```", "```java\n    (Integer t) -> {\n```", "```java\n      return YearMonth.of(1970, 1)\n```", "```java\n             .with(ChronoField.PROLEPTIC_MONTH, t);\n```", "```java\n    },\n```", "```java\n    (YearMonth u) -> {\n```", "```java\n      return (int) u.getLong(ChronoField.PROLEPTIC_MONTH);\n```", "```java\n    }\n```", "```java\n);\n```", "```java\nctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,  \n```", "```java\n CUSTOMER.FIRST_BUY_DATE.convert(INTEGER_YEARMONTH_CONVERTER))\n```", "```java\n   .values(\"Atelier One\", ..., YearMonth.of(2020, 10))\n```", "```java\n   .execute();\n```", "```java\nctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,\n```", "```java\n CUSTOMER.FIRST_BUY_DATE.convertTo(YearMonth.class, \n```", "```java\n            u -> INTEGER_YEARMONTH_CONVERTER.to(u)))\n```", "```java\n   .values(\"Atelier One\", ..., YearMonth.of(2020, 10))\n```", "```java\n   .execute();\n```", "```java\nList<YearMonth> result = ctx.select(\n```", "```java\n  CUSTOMER.FIRST_BUY_DATE.convertFrom(\n```", "```java\n       t -> INTEGER_YEARMONTH_CONVERTER.from(t)))\n```", "```java\n  .from(CUSTOMER)\n```", "```java\n  .where(CUSTOMER.CUSTOMER_NAME.eq(\"Atelier One\"))\n```", "```java\n  .fetchInto(YearMonth.class);\n```", "```java\nctx.insertInto(CUSTOMER, ...,\n```", "```java\n    CUSTOMER.FIRST_BUY_DATE.convertTo(YearMonth.class, \n```", "```java\n      u -> (int) u.getLong(ChronoField.PROLEPTIC_MONTH)))\n```", "```java\n   .values(..., YearMonth.of(2020, 10)) ...;\n```", "```java\nList<YearMonth> result = ctx.select(\n```", "```java\n    CUSTOMER.FIRST_BUY_DATE.convertFrom(\n```", "```java\n      t -> YearMonth.of(1970, 1)\n```", "```java\n       .with(ChronoField.PROLEPTIC_MONTH, t)))\n```", "```java\n   .from(CUSTOMER) ...;\n```", "```java\nDataType<YearMonth> YEARMONTH \n```", "```java\n   = INTEGER.asConvertedDataType(converter);\n```", "```java\n<forcedTypes>\n```", "```java\n  <forcedType>\n```", "```java\n    <!-- The Java type of the custom data type. \n```", "```java\n         This corresponds to the Converter's <U> type. -->\n```", "```java\n    <userType>java.time.YearMonth</userType>\n```", "```java\n    <!-- Associate that custom type with our converter. -->\n```", "```java\n    <converter>\n```", "```java\n      com.classicmodels.converter.YearMonthConverter\n```", "```java\n    </converter>\n```", "```java\n    <!-- Match the fully-qualified column. -->\n```", "```java\n    <includeExpression>\n```", "```java\n      classicmodels\\.customer\\.first_buy_date\n```", "```java\n    </includeExpression>\n```", "```java\n    <!-- Match the data type to be forced. -->\n```", "```java\n    <includeTypes>INT</includeTypes>\n```", "```java\n  </forcedType>\n```", "```java\n</forcedTypes>\n```", "```java\n<!-- All 'first_buy_date' fields in any 'customer' table, \n```", "```java\n     no matter the schema -->\n```", "```java\n.*\\.customer\\.first_buy_date\n```", "```java\n<!-- All 'first_buy_date' fields, \n```", "```java\n     no matter the schema and the table -->\n```", "```java\n.*\\.first_buy_date\n```", "```java\n<!-- All fields containing 'first_buy_' -->\n```", "```java\n.*\\.first_buy_.*\n```", "```java\n<!-- Case-insensitive expressions -->\n```", "```java\n(?i:.*\\.customer\\.first_buy_date)\n```", "```java\n(?i:classicmodels\\.customer\\.first_buy_date)\n```", "```java\npublic final TableField<CustomerRecord, YearMonth> \n```", "```java\n FIRST_BUY_DATE = createField(DSL.name(\"first_buy_date\"),   \n```", "```java\n  SQLDataType.INTEGER, this, \"\", new YearMonthConverter());\n```", "```java\nctx.insertInto(CUSTOMER, CUSTOMER.CUSTOMER_NAME, ...,  \n```", "```java\n               CUSTOMER.FIRST_BUY_DATE)\n```", "```java\n   .values(\"Atelier One\", ..., YearMonth.of(2020, 10))\n```", "```java\n   .execute();\n```", "```java\nList<YearMonth> ymList = ctx.select(CUSTOMER.FIRST_BUY_DATE)\n```", "```java\n   .from(CUSTOMER)\n```", "```java\n   .where(CUSTOMER.CUSTOMER_NAME.eq(\"Atelier One\"))\n```", "```java\n   .fetch(CUSTOMER.FIRST_BUY_DATE);\n```", "```java\nResult<Record2<String, YearMonth>> result = ctx.resultQuery(\n```", "```java\n  \"SELECT customer_name, first_buy_date FROM customer\")\n```", "```java\n  .coerce(CUSTOMER.CUSTOMER_NAME, CUSTOMER.FIRST_BUY_DATE)\n```", "```java\n.fetch();\n```", "```java\n<forcedTypes>\n```", "```java\n <forcedType>    \n```", "```java\n  <userType>java.time.YearMonth</userType>\n```", "```java\n  ...\n```", "```java\n  <converter>\n```", "```java\n   <![CDATA[\n```", "```java\n    org.jooq.Converter.ofNullable(\n```", "```java\n       Integer.class, YearMonth.class, \n```", "```java\n     (Integer t) -> { return YearMonth.of(1970, 1).with(\n```", "```java\n      java.time.temporal.ChronoField.PROLEPTIC_MONTH, t); },\n```", "```java\n     (YearMonth u) -> { return (int) u.getLong(\n```", "```java\n      java.time.temporal.ChronoField.PROLEPTIC_MONTH); }\n```", "```java\n    )\n```", "```java\n   ]]>\n```", "```java\n  </converter>    \n```", "```java\n  ...\n```", "```java\n </forcedType>\n```", "```java\n</forcedTypes>\n```", "```java\n<forcedTypes>\n```", "```java\n <forcedType>                                         \n```", "```java\n  <userType>java.time.YearMonth</userType>\n```", "```java\n  ...\n```", "```java\n  <lambdaConverter>\n```", "```java\n   <from>\n```", "```java\n    <![CDATA[(Integer t) -> { return YearMonth.of(1970, 1)\n```", "```java\n    .with(java.time.temporal.ChronoField.PROLEPTIC_MONTH, t);    \n```", "```java\n    }]]>\n```", "```java\n   </from>\n```", "```java\n   <to>\n```", "```java\n    <![CDATA[(YearMonth u) -> { return (int) \n```", "```java\n    u.getLong(java.time.temporal.ChronoField.PROLEPTIC_MONTH);    \n```", "```java\n    }]]>\n```", "```java\n   </to>                                            \n```", "```java\n  </lambdaConverter>\n```", "```java\n  ...\n```", "```java\n  </forcedType>\n```", "```java\n</forcedTypes>\n```", "```java\n<sql>\n```", "```java\n SELECT concat('classicmodels.', TABLE_NAME, '.', COLUMN_NAME)\n```", "```java\n FROM INFORMATION_SCHEMA.COLUMNS\n```", "```java\n WHERE TABLE_SCHEMA = 'classicmodels'\n```", "```java\n  AND TABLE_NAME != 'flyway_schema_history'\n```", "```java\n  AND DATA_TYPE = 'timestamp'\n```", "```java\n</sql>\n```", "```java\n<excludeExpression>\n```", "```java\n    classicmodels\\.payment\\.modified\n```", "```java\n  | classicmodels\\.token\\.updated_on\n```", "```java\n</excludeExpression>\n```", "```java\nCREATE OR REPLACE TYPE \"EVALUATION_CRITERIA\" AS OBJECT (\n```", "```java\n  \"communication_ability\" NUMBER(7), \n```", "```java\n  \"ethics\" NUMBER(7), \n```", "```java\n  \"performance\" NUMBER(7), \n```", "```java\n  \"employee_input\" NUMBER(7),\n```", "```java\n  // the irrelevant part was skipped\n```", "```java\n);\n```", "```java\npublic class JsonConverter implements \n```", "```java\n        Converter<EvaluationCriteriaRecord, JsonNode> {\n```", "```java\n   @Override\n```", "```java\n   public JsonNode from(EvaluationCriteriaRecord t) { ... }\n```", "```java\n   @Override\n```", "```java\n   public EvaluationCriteriaRecord to(JsonNode u) { ... }\n```", "```java\n   ...\n```", "```java\n}\n```", "```java\n<forcedTypes>\n```", "```java\n <forcedType>\n```", "```java\n  <userType>com.fasterxml.jackson.databind.JsonNode</userType>\n```", "```java\n  <converter>com...converter.JsonConverter</converter>\n```", "```java\n  <includeExpression>\n```", "```java\n   CLASSICMODELS\\.MANAGER\\.MANAGER_EVALUATION\n```", "```java\n  </includeExpression>\n```", "```java\n  <includeTypes>EVALUATION_CRITERIA</includeTypes>\n```", "```java\n </forcedType>\n```", "```java\n</forcedTypes>  \n```", "```java\nJsonNode managerEvaluation = \"{...}\";\n```", "```java\nctx.insertInto(MANAGER, \n```", "```java\n          MANAGER.MANAGER_NAME, MANAGER.MANAGER_EVALUATION)\n```", "```java\n   .values(\"Mark Joy\", managerEvaluation)\n```", "```java\n   .execute();\n```", "```java\nList<JsonNode> managerEvaluation = ctx.select(\n```", "```java\n      MANAGER.MANAGER_EVALUATION)\n```", "```java\n   .from(MANAGER)\n```", "```java\n   .fetch(MANAGER.MANAGER_EVALUATION);\n```", "```java\npublic interface Binding<T, U> extends Serializable { ... }\n```", "```java\n// A converter that does the conversion between \n```", "```java\n// the database type T and the user type U\n```", "```java\nConverter<T, U> converter();\n```", "```java\n// A callback that generates the SQL string for bind values of // this binding type. Typically, just ?, but also ?::json, ...\n```", "```java\nvoid sql(BindingSQLContext<U> ctx) throws SQLException;\n```", "```java\n// Register a type for JDBC CallableStatement OUT parameters\n```", "```java\nResultSet void register(BindingRegisterContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\n// Convert U to a type and set in on a JDBC PreparedStatement\n```", "```java\nvoid set(BindingSetStatementContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\n// Get a type from JDBC ResultSet and convert it to U\n```", "```java\nvoid get(BindingGetResultSetContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\n// Get a type from JDBC CallableStatement and convert it to U\n```", "```java\nvoid get(BindingGetStatementContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\n// Get a value from JDBC SQLInput (useful for Oracle OBJECT)\n```", "```java\nvoid get(BindingGetSQLInputContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\n// Get a value from JDBC SQLOutput (useful for Oracle OBJECT)\n```", "```java\nvoid set(BindingSetSQLOutputContext<U> ctx) \n```", "```java\n          throws SQLException;\n```", "```java\npublic class HstoreBinding implements \n```", "```java\n          Binding<Object, Map<String, String>> {\n```", "```java\n   private final HstoreConverter converter \n```", "```java\n      = new HstoreConverter();\n```", "```java\n   @Override\n```", "```java\n   public final Converter<Object, Map<String, String>> \n```", "```java\n                                              converter() {\n```", "```java\n      return converter;\n```", "```java\n   }\n```", "```java\n   ...\n```", "```java\n}\n```", "```java\npublic class PointBinding implements Binding<Object,Point2D> {\n```", "```java\n   private final PointConverter converter \n```", "```java\n      = new PointConverter();\n```", "```java\n   @Override\n```", "```java\n   public final Converter<Object, Point2D> converter() {\n```", "```java\n      return converter;\n```", "```java\n   }\n```", "```java\n   ...\n```", "```java\n}\n```", "```java\n@Override    \n```", "```java\npublic void sql(BindingSQLContext<Map<String, String>> ctx) \n```", "```java\n                                       throws SQLException {\n```", "```java\n   if (ctx.render().paramType() == ParamType.INLINED) {\n```", "```java\n      ctx.render().visit(inline(\n```", "```java\n         ctx.convert(converter()).value())).sql(\"::hstore\");\n```", "```java\n   } else {\n```", "```java\n      ctx.render().sql(\"?::hstore\");\n```", "```java\n   }\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void sql(BindingSQLContext<Point2D> ctx) \n```", "```java\n        throws SQLException {\n```", "```java\n  if (ctx.render().paramType() == ParamType.INLINED) {\n```", "```java\n      ctx.render().sql(\"ST_PointFromText(\")\n```", "```java\n         .visit(inline(ctx.convert(converter()).value()))\n```", "```java\n         .sql(\")\");\n```", "```java\n  } else {\n```", "```java\n      ctx.render().sql(\"ST_PointFromText(?)\");\n```", "```java\n  }\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void register(BindingRegisterContext\n```", "```java\n          <Map<String, String>> ctx) throws SQLException {\n```", "```java\n   ctx.statement().registerOutParameter(\n```", "```java\n      ctx.index(), Types.VARCHAR);\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void register(BindingRegisterContext<Point2D> ctx)  \n```", "```java\n                                       throws SQLException {\n```", "```java\n   ctx.statement().registerOutParameter(\n```", "```java\n      ctx.index(), Types.BLOB);\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void set(BindingSetStatementContext\n```", "```java\n            <Map<String, String>> ctx) throws SQLException {\n```", "```java\n   ctx.statement().setString(ctx.index(), Objects.toString(\n```", "```java\n     ctx.convert(converter()).value(), null));\n```", "```java\n}  \n```", "```java\n@Override\n```", "```java\npublic void get(BindingGetResultSetContext\n```", "```java\n           <Map<String, String>> ctx) throws SQLException {\n```", "```java\n   ctx.convert(converter()).value(\n```", "```java\n     ctx.resultSet().getString(ctx.index()));\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void get(BindingGetResultSetContext<Point2D> ctx) \n```", "```java\n                                      throws SQLException {\n```", "```java\n   ctx.convert(converter()).value(ctx.resultSet()\n```", "```java\n      .getBlob(ctx.index())); // or, getBinaryStream()\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void get(BindingGetStatementContext\n```", "```java\n           <Map<String, String>> ctx) throws SQLException {\n```", "```java\n   ctx.convert(converter()).value(\n```", "```java\n      ctx.statement().getString(ctx.index()));\n```", "```java\n}\n```", "```java\n@Override\n```", "```java\npublic void get(BindingGetStatementContext<Point2D> ctx) \n```", "```java\n                                       throws SQLException {\n```", "```java\n   ctx.convert(converter()).value(\n```", "```java\n      ctx.statement().getBlob(ctx.index()));\n```", "```java\n}\n```", "```java\n<forcedTypes>\n```", "```java\n  <forcedType>\n```", "```java\n    <userType>java.util.Map&lt;String, String&gt;</userType>   \n```", "```java\n    <binding>com.classicmodels.binding.HstoreBinding</binding>\n```", "```java\n    <includeExpression>\n```", "```java\n      public\\.product\\.specs\n```", "```java\n    </includeExpression>\n```", "```java\n    <includeTypes>HSTORE</includeTypes>\n```", "```java\n  </forcedType>\n```", "```java\n</forcedTypes>\n```", "```java\nctx.insertInto(PRODUCT, PRODUCT.PRODUCT_NAME, \n```", "```java\n               PRODUCT.PRODUCT_LINE, PRODUCT.SPECS)\n```", "```java\n   .values(\"2002 Masserati Levante\", \"Classic Cars\",\n```", "```java\n      Map.of(\"Length (in)\", \"197\", \"Width (in)\", \"77.5\", \n```", "```java\n             \"Height (in)\", \"66.1\", \"Engine\", \"Twin Turbo \n```", "```java\n             Premium Unleaded V-6\"))\n```", "```java\n   .execute();  \n```", "```java\nINSERT INTO \"public\".\"product\" (\n```", "```java\n            \"product_name\", \"product_line\", \"specs\")\n```", "```java\nVALUES (?, ?, ?::hstore)\n```", "```java\nINSERT INTO \"public\".\"product\" (\n```", "```java\n            \"product_name\", \"product_line\", \"specs\")\n```", "```java\nVALUES ('2002 Masserati Levante', 'Classic Cars', \n```", "```java\n        '\"Width (in)\"=>\"77.5\", \"Length (in)\"=>\"197\", \n```", "```java\n         \"Height (in)\"=>\"66.1\", \n```", "```java\n         \"Engine\"=>\"Twin Turbo Premium Unleaded V-6\"'::hstore)\n```", "```java\nList<Map<String, String>> specs = ctx.select(PRODUCT.SPECS)\n```", "```java\n   .from(PRODUCT)\n```", "```java\n   .where(PRODUCT.PRODUCT_NAME.eq(\"2002 Masserati Levante\"))\n```", "```java\n   .fetch(PRODUCT.SPECS);\n```", "```java\nstatic <T> Object convertToDatabaseType(Param<T> param) {\n```", "```java\n   return param.getBinding().converter().to(param.getValue());\n```", "```java\n}\n```", "```java\n'vat' ENUM ('NONE', 'MIN', 'MAX') DEFAULT NULL\n```", "```java\npublic enum VatType implements EnumType {\n```", "```java\n    NONE(\"NONE\"), MIN(\"MIN\"), MAX(\"MAX\");\n```", "```java\n    private final String literal;\n```", "```java\n    private VatType(String literal) {\n```", "```java\n        this.literal = literal;\n```", "```java\n    }\n```", "```java\n    @Override\n```", "```java\n    public Catalog getCatalog() {\n```", "```java\n        return null;\n```", "```java\n    }\n```", "```java\n    @Override\n```", "```java\n    public Schema getSchema() {\n```", "```java\n        return null;\n```", "```java\n    }\n```", "```java\n    @Override\n```", "```java\n    public String getName() {\n```", "```java\n        return \"sale_vat\";\n```", "```java\n    }\n```", "```java\n    @Override\n```", "```java\n    public String getLiteral() {\n```", "```java\n        return literal;\n```", "```java\n    }\n```", "```java\n    public static VatType lookupLiteral(String literal) {\n```", "```java\n        return EnumType.lookupLiteral(VatType.class, literal);\n```", "```java\n    }\n```", "```java\n}\n```", "```java\n<strategy>\n```", "```java\n  <matchers>                                              \n```", "```java\n    <enums>                                           \n```", "```java\n      <enum>         \n```", "```java\n        <expression>sale_vat</expression>                         \n```", "```java\n        <enumClass>                                                    \n```", "```java\n          <expression>VatType</expression>\n```", "```java\n          <transform>AS_IS</transform>                          \n```", "```java\n        </enumClass>                             \n```", "```java\n      </enum>\n```", "```java\n    </enums>\n```", "```java\n  </matchers>\n```", "```java\n</strategy>\n```", "```java\nimport jooq.generated.enums.VatType;\n```", "```java\n...\n```", "```java\nctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.VAT)\n```", "```java\n   .values(2005, ..., VatType.MAX)\n```", "```java\n   .execute();\n```", "```java\nList<VatType> vats = ctx.select(SALE.VAT).from(SALE)\n```", "```java\n   .where(SALE.VAT.isNotNull())\n```", "```java\n   .fetch(SALE.VAT);\n```", "```java\nenum Size { S, M, XL, XXL; }\n```", "```java\nConverter<String, Size> converter \n```", "```java\n   = new EnumConverter<>(String.class, Size.class);\n```", "```java\n`rate` ENUM ('SILVER', 'GOLD', 'PLATINUM') DEFAULT NULL\n```", "```java\n`vat` ENUM ('NONE', 'MIN', 'MAX') DEFAULT NULL\n```", "```java\nCREATE TYPE rate_type AS enum('SILVER', 'GOLD', 'PLATINUM');\n```", "```java\nCREATE TYPE vat_type AS enum('NONE', 'MIN', 'MAX');\n```", "```java\n…\n```", "```java\nrate rate_type DEFAULT NULL,\n```", "```java\nvat vat_type DEFAULT NULL,\n```", "```java\npublic enum RateType { SILVER, GOLD, PLATINUM }\n```", "```java\n<forcedTypes>\n```", "```java\n  <forcedType>\n```", "```java\n    <userType>com.classicmodels.enums.RateType</userType>\n```", "```java\n    <enumConverter>true</enumConverter>\n```", "```java\n    <includeExpression>\n```", "```java\n      classicmodels\\.sale\\.rate # MySQL\n```", "```java\n      public\\.sale\\.rate        # PostgreSQL\n```", "```java\n    </includeExpression>\n```", "```java\n    <includeTypes>\n```", "```java\n       ENUM      # MySQL\n```", "```java\n       rate_type # PostgreSQL\n```", "```java\n    </includeTypes>\n```", "```java\n  </forcedType>\n```", "```java\n</forcedTypes>\n```", "```java\npublic final TableField<SaleRecord, RateType> RATE \n```", "```java\n  = createField(DSL.name(\"rate\"), SQLDataType.VARCHAR(8),    \n```", "```java\n    this, \"\", new EnumConverter<String, RateType>   \n```", "```java\n                             (String.class, RateType.class));\n```", "```java\n<database>\n```", "```java\n   <excludes>\n```", "```java\n     sale_rate (MySQL) / rate_type (PostgreSQL)\n```", "```java\n   </excludes>\n```", "```java\n</database>\n```", "```java\n<generate>\n```", "```java\n  <deprecationOnUnknownTypes>false</deprecationOnUnknownTypes>\n```", "```java\n</generate>\n```", "```java\nctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)\n```", "```java\n   .values(2005, ..., RateType.PLATINUM.name())\n```", "```java\n   .execute();\n```", "```java\nList<RateType> rates = ctx.select(SALE.RATE)\n```", "```java\n   .from(SALE)\n```", "```java\n   .where(SALE.RATE.isNotNull())\n```", "```java\n   .fetch(SALE.RATE, RateType.class);\n```", "```java\nctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)\n```", "```java\n   .values(2005, ..., field(\"?::\\\"public\\\".\\\"rate_type\\\"\", \n```", "```java\n           RateType.PLATINUM.name()))\n```", "```java\n   .execute();\n```", "```java\nList<RateType> rates = ctx.select(SALE.RATE)\n```", "```java\n   .from(SALE)\n```", "```java\n   .where(SALE.RATE.isNotNull())\n```", "```java\n   .fetch(SALE.RATE.coerce(String.class), RateType.class);\n```", "```java\npublic enum TrendType { UP, DOWN, CONSTANT }\n```", "```java\n<forcedType>    \n```", "```java\n  <userType>com.classicmodels.enums.TrendType</userType>     \n```", "```java\n  <enumConverter>true</enumConverter>                                              \n```", "```java\n  <includeExpression>\n```", "```java\n    CLASSICMODELS\\.SALE\\.TREND\n```", "```java\n  </includeExpression>                                            \n```", "```java\n  <includeTypes>VARCHAR2\\(10\\)</includeTypes>\n```", "```java\n</forcedType>\n```", "```java\nvat VARCHAR2(10) DEFAULT NULL \n```", "```java\n  CHECK (vat IN('NONE', 'MIN', 'MAX'))\n```", "```java\n<forcedType>                                                                                                                                        \n```", "```java\n  <userType>com.classicmodels.enums.VatType</userType>                                                                                                                                                                                 \n```", "```java\n  <enumConverter>true</enumConverter>                                            \n```", "```java\n  <includeExpression>    \n```", "```java\n    CLASSICMODELS\\.SALE\\.VAT\n```", "```java\n  </includeExpression>                                            \n```", "```java\n  <includeTypes>VARCHAR2\\(10\\)</includeTypes>\n```", "```java\n</forcedType>\n```", "```java\npublic class SaleStrTrendConverter \n```", "```java\n           extends EnumConverter<String, TrendType> {   \n```", "```java\n  public SaleStrTrendConverter() {\n```", "```java\n     super(String.class, TrendType.class);\n```", "```java\n  }        \n```", "```java\n}\n```", "```java\npublic class SaleVatIntConverter \n```", "```java\n   extends EnumConverter<VatType, Integer> { … }\n```", "```java\npublic class SaleVatIntConverter \n```", "```java\n   implements Converter<VatType, Integer> { … }\n```", "```java\npublic enum RateType { SILVER, GOLD, PLATINUM }\n```", "```java\n<forcedType>\n```", "```java\n  <userType>com.classicmodels.enums.RateType</userType>\n```", "```java\n  <enumConverter>true</enumConverter>\n```", "```java\n  <includeExpression>\n```", "```java\n    classicmodels\\.sale\\.rate\n```", "```java\n  </includeExpression>\n```", "```java\n  <includeTypes>ENUM</includeTypes>\n```", "```java\n</forcedType>\n```", "```java\npublic enum StarType { THREE_STARS, FOUR_STARS, FIVE_STARS }\n```", "```java\npublic class SaleRateStarConverter extends \n```", "```java\n                    EnumConverter<RateType, StarType> {\n```", "```java\n   public final static SaleRateStarConverter \n```", "```java\n      SALE_RATE_STAR_CONVERTER = new SaleRateStarConverter();\n```", "```java\n   public SaleRateStarConverter() {\n```", "```java\n      super(RateType.class, StarType.class);\n```", "```java\n   }\n```", "```java\n   @Override\n```", "```java\n   public RateType to(StarType u) {\n```", "```java\n      if (u != null) {\n```", "```java\n         return switch (u) {\n```", "```java\n                case THREE_STARS -> RateType.SILVER;\n```", "```java\n                case FOUR_STARS -> RateType.GOLD;\n```", "```java\n                case FIVE_STARS -> RateType.PLATINUM;\n```", "```java\n         };\n```", "```java\n      }\n```", "```java\n      return null;\n```", "```java\n   }\n```", "```java\n}\n```", "```java\n// rely on <forcedType/> \n```", "```java\nctx.insertInto(SALE, SALE.FISCAL_YEAR, ,..., SALE.RATE)\n```", "```java\n   .values(2005, ..., RateType.PLATINUM)\n```", "```java\n   .execute();\n```", "```java\n// rely on SALE_RATE_STAR_CONVERTER\n```", "```java\nctx.insertInto(SALE, SALE.FISCAL_YEAR, ..., SALE.RATE)\n```", "```java\n   .values(2005, ...,   \n```", "```java\n           SALE_RATE_STAR_CONVERTER.to(StarType.FIVE_STARS))\n```", "```java\n   .execute();\n```", "```java\nSELECT 'CLASSICMODELS.' || tab.table_name || '.' \n```", "```java\n                        || cols.column_name\n```", "```java\nFROM sys.all_tables tab\n```", "```java\nJOIN sys.all_constraints con ON tab.owner = con.owner\n```", "```java\n   AND tab.table_name = con.table_name\n```", "```java\nJOIN sys.all_cons_columns cols ON cols.owner = con.owner\n```", "```java\n   AND cols.constraint_name = con.constraint_name\n```", "```java\n   AND cols.table_name = con.table_name\n```", "```java\nWHERE constraint_type = 'C'\n```", "```java\n   AND tab.owner in ('CLASSICMODELS')\n```", "```java\n   AND search_condition_vc \n```", "```java\n      = q'[rate IN('SILVER', 'GOLD', 'PLATINUM')]'\n```", "```java\nDataType<RateType> RATETYPE = SALE.RATE.getDataType();\n```", "```java\nDataType<VatType> VATTYPE \n```", "```java\n  = VARCHAR.asEnumDataType(VatType.class);\n```", "```java\nDataType<com.classicmodels.enums.VatType> VATTYPE\n```", "```java\n  = VARCHAR.asEnumDataType(jooq.generated.enums.VatType.class)\n```", "```java\n    .asConvertedDataType(VAT_CONVERTER);\n```", "```java\nCREATE TABLE sale (\n```", "```java\n  ...\n```", "```java\n  hot NUMBER(1,0) DEFAULT 0\n```", "```java\n  hot CHAR(1) DEFAULT '1' CHECK (hot IN('1', '0'))\n```", "```java\n  ...\n```", "```java\n}\n```", "```java\n<forcedType>\n```", "```java\n  <name>BOOLEAN</name>\n```", "```java\n  <includeExpression>CLASSICMODELS\\.SALE\\.HOT</includeExpression>\n```", "```java\n  <includeTypes>NUMBER\\(1,\\s*0\\)</includeTypes>\n```", "```java\n  <includeTypes>CHAR\\(1\\)</includeTypes>\n```", "```java\n</forcedType>\n```", "```java\nctx.insertInto(SALE, ..., SALE.HOT)\n```", "```java\n   .values(2005,..., Boolean.FALSE)\n```", "```java\n   .execute();\n```", "```java\n<embeddable>\n```", "```java\n <!-- The optional catalog of the embeddable type -->\n```", "```java\n <catalog/>\n```", "```java\n <!-- The optional schema of the embeddable type -->\n```", "```java\n <schema>classicmodels</schema>\n```", "```java\n <!-- The name of the embeddable type -->\n```", "```java\n <name>OFFICE_FULL_ADDRESS</name>\n```", "```java\n <!-- An optional, defining comment of an embeddable -->\n```", "```java\n <comment>The full address of an office</comment>\n```", "```java\n <!-- The name of the reference to the embeddable type -->\n```", "```java\n <referencingName/>\n```", "```java\n <!-- An optional, referencing comment of an embeddable -->\n```", "```java\n <referencingComment/>\n```", "```java\n <!-- A regular expression matching qualified/unqualified \n```", "```java\n      table names to which to apply this embeddable. If left \n```", "```java\n      blank, this will apply to all tables -->\n```", "```java\n <tables>.*\\.office</tables>\n```", "```java\n <!-- A list of fields to match to an embeddable. Each field   \n```", "```java\n      must match exactly one column in each matched table. A \n```", "```java\n      mandatory regular expression matches field names, and  \n```", "```java\n      an optional name can be provided to define the \n```", "```java\n      embeddable attribute name. If no name is provided, then \n```", "```java\n      the first matched field's name will be taken -->\n```", "```java\n <fields>\n```", "```java\n  <field><expression>CITY</expression></field>                                              \n```", "```java\n  <field><expression>ADDRESS_LINE_FIRST</expression></field>\n```", "```java\n  <field><expression>STATE</expression></field>\n```", "```java\n  <field><expression>COUNTRY</expression></field>                                                \n```", "```java\n  <field><expression>TERRITORY</expression></field>\n```", "```java\n </fields>                                                                             </embeddable>                                        \n```", "```java\nctx.insertInto(OFFICE, ... ,\n```", "```java\n               OFFICE.ADDRESS_LINE_SECOND, ...)\n```", "```java\n   .values(...,\n```", "```java\n           new OfficeFullAddressRecord(\"Naples\", \"Giuseppe \n```", "```java\n              Mazzini\", \"Campania\", \"Italy\", \"N/A\"),\n```", "```java\n           ...)\n```", "```java\n   .execute();\n```", "```java\nResult<Record1<OfficeFullAddressRecord>> result \n```", "```java\n       = ctx.select(OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)\n```", "```java\n   .fetch();\n```", "```java\nList<OfficeFullAddress> result \n```", "```java\n   = ctx.select(OFFICE.OFFICE_FULL_ADDRESS).from(OFFICE)\n```", "```java\n        .fetchInto(OfficeFullAddress.class);\n```", "```java\n<embeddable>\n```", "```java\n ...\n```", "```java\n <replacesFields>true</replacesFields>\n```", "```java\n</embeddable>\n```", "```java\npublic class JsonConverter implements   \n```", "```java\n           Converter<OfficeFullAddressRecord, JsonNode> {\n```", "```java\n   public static final JsonConverter JSON_CONVERTER \n```", "```java\n      = new JsonConverter();\n```", "```java\n   @Override\n```", "```java\n   public JsonNode from(OfficeFullAddressRecord t) { ... }\n```", "```java\n   @Override \n```", "```java\n   public OfficeFullAddressRecord to(JsonNode u) { ... }\n```", "```java\n   ...\n```", "```java\n}\n```", "```java\nList<JsonNode> result = ctx.select(OFFICE.OFFICE_FULL_ADDRESS)\n```", "```java\n   .from(OFFICE)\n```", "```java\n   .fetch(OFFICE.OFFICE_FULL_ADDRESS, JSON_CONVERTER);\n```", "```java\nCREATE DOMAIN postal_code AS varchar(15)\n```", "```java\nCHECK(\n```", "```java\n   VALUE ~ '^\\d{5}$'\n```", "```java\nOR VALUE ~ '^[A-Z]{2}[0-9]{3}[A-Z]{2}$'\n```", "```java\n);\n```", "```java\nCREATE TABLE office (\n```", "```java\n  ... \n```", "```java\n  \"postal_code\" postal_code NOT NULL,\n```", "```java\n  ... \n```", "```java\n);\n```", "```java\n// Maven and standalone\n```", "```java\n<database>                               \n```", "```java\n  ...\n```", "```java\n  <embeddableDomains>.*</embeddableDomains>\n```", "```java\n</database>\n```", "```java\n// Gradle\n```", "```java\ndatabase {\n```", "```java\n  embeddableDomains = '.*'\n```", "```java\n}\n```", "```java\n// programmatic\n```", "```java\nwithEmbeddableDomains(\".*\")\n```", "```java\nctx.select(OFFICE.CITY, OFFICE.COUNTRY)\n```", "```java\n   .from(OFFICE)\n```", "```java\n   .where(OFFICE.POSTAL_CODE.in(\n```", "```java\n        new PostalCodeRecord(\"AZ934VB\"),\n```", "```java\n        new PostalCodeRecord(\"DT975HH\")))\n```", "```java\n   .fetch();\n```", "```java\nctx.insertInto(OFFICE, ..., OFFICE.POSTAL_CODE, ...)\n```", "```java\n   .values(..., new PostalCodeRecord(\"OP909DD\"), ...)\n```", "```java\n   .execute();\n```"]