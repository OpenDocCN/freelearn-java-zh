<html><head></head><body>
<div id="_idContainer083">
<h1 class="chapter-number" id="_idParaDest-226"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-227"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.2.1">Setting Up Dockerfile and Kubernetes Objects for Cloud Deployment</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We spent the previous chapters exploring some of the amazing features that Quarkus provides to help us create cloud-native applications. </span><span class="koboSpan" id="kobo.3.2">Going even further, we also learned how to integrate Quarkus into a </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Now, we need to prepare the hexagonal system so that it can be deployed in cloud environments. </span><span class="koboSpan" id="kobo.5.2">Docker and Kubernetes are the leading technologies that dominate the cloud scene nowadays. </span><span class="koboSpan" id="kobo.5.3">If your application is prepared to run on these technologies, you’re safe to make it run on most </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">cloud providers.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">So, in this chapter, we’ll learn how to wrap the hexagonal system in a Docker image and run it on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.7.2">For Docker images, we’ll explore two techniques for creating such images: one that relies on an executable </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">.jar</span></strong><span class="koboSpan" id="kobo.9.1"> and another that uses a native executable. </span><span class="koboSpan" id="kobo.9.2">We’ll also learn how to deploy the hexagonal system in a local </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">minikube</span></strong><span class="koboSpan" id="kobo.11.1">-based </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">Preparing the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Docker image</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Creating </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Kubernetes objects</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">on minikube</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">By the end of this chapter, you’ll know how to make the hexagonal system run in a cloud-native environment based on Docker and Kubernetes. </span><span class="koboSpan" id="kobo.21.2">Nowadays, most modern applications run on the cloud. </span><span class="koboSpan" id="kobo.21.3">By turning the hexagonal system into a cloud-native one, you’ll be able to tap into the advantages that exist when you’re on </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">the cloud.</span></span></p>
<h1 id="_idParaDest-228"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.23.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.24.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.26.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.28.1"> installed on your computer. </span><span class="koboSpan" id="kobo.28.2">They are available for the Linux, macOS, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">You’ll also need </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Docker</span></strong><span class="koboSpan" id="kobo.32.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">minikube</span></strong><span class="koboSpan" id="kobo.34.1"> installed on </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">your machine.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.40.1">Preparing the Docker image</span></h1>
<p><span class="koboSpan" id="kobo.41.1">Container-based virtualization </span><a id="_idIndexMarker917"/><span class="koboSpan" id="kobo.42.1">technology is not something new. </span><span class="koboSpan" id="kobo.42.2">Long before Docker, there were technologies such as OpenVZ, which applied the same fundamental concepts that are applied by Docker as well. </span><span class="koboSpan" id="kobo.42.3">Even today, we have alternatives</span><a id="_idIndexMarker918"/><span class="koboSpan" id="kobo.43.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">Linux Containers</span></strong><span class="koboSpan" id="kobo.45.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.46.1">LXC</span></strong><span class="koboSpan" id="kobo.47.1">), which provides a robust container-based solution. </span><span class="koboSpan" id="kobo.47.2">What sets Docker apart is how easy and intuitive it makes handling containerized applications. </span><span class="koboSpan" id="kobo.47.3">Docker takes portability to another level, simplifying and making containers a viable technology for </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">larger audiences.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">In the past, other container platforms were not as straightforward to use as Docker is today. </span><span class="koboSpan" id="kobo.49.2">Containers were a topic more related to system administrators than to software developers. </span><span class="koboSpan" id="kobo.49.3">Today, the scenario is different because of the simple yet powerful container-based solution we have with Docker. </span><span class="koboSpan" id="kobo.49.4">Because of its simplicity, Docker rapidly became popular among developers, who started to incorporate it into </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">As I mentioned previously, Docker’s strength is in its simplicity to use and learn. </span><span class="koboSpan" id="kobo.51.2">Take, for example, how Docker abstracts the complexity required to wrap an application inside a container. </span><span class="koboSpan" id="kobo.51.3">You just need to define a Dockerfile describing how the application should be configured and executed inside the container. </span><span class="koboSpan" id="kobo.51.4">You can do this by using a simple set of instructions. </span><span class="koboSpan" id="kobo.51.5">So, Docker shields the user from low-level complexities that existed in previous </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">container technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">One of the things that makes Quarkus so special is that it’s a container-first framework. </span><span class="koboSpan" id="kobo.53.2">It’s designed to build container-based applications. </span><span class="koboSpan" id="kobo.53.3">So, Quarkus is an excellent choice if you’re targeting </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">container-based environments.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">With Quarkus, we can generate Docker images using </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">.jar</span></strong><span class="koboSpan" id="kobo.57.1"> artifacts or native executable</span><a id="_idIndexMarker919"/><span class="koboSpan" id="kobo.58.1"> artifacts. </span><span class="koboSpan" id="kobo.58.2">We’ll explore both of these </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">approaches next.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.60.1">Creating a Docker image with an uber .jar artifact</span></h2>
<p><span class="koboSpan" id="kobo.61.1">Our </span><a id="_idIndexMarker920"/><span class="koboSpan" id="kobo.62.1">approach here is to wrap the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">.jar</span></strong><span class="koboSpan" id="kobo.64.1"> artifact in the Docker image so that the container can start and run the application by executing that </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">.jar</span></strong><span class="koboSpan" id="kobo.66.1"> file. </span><span class="koboSpan" id="kobo.66.2">To build a Docker image, we need to create a Dockerfile with instructions to build such </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">an image.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">The </span><a id="_idIndexMarker921"/><span class="koboSpan" id="kobo.69.1">following code shows how to create a Dockerfile for the topology and inventory system that uses the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.72.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.73.1">
FROM eclipse-temurin:17.0.8_7-jdk-alpine
ENV APP_FILE_RUNNER bootstrap-1.0-SNAPSHOT-runner.jar
ENV APP_HOME /usr/apps
EXPOSE 8080
COPY bootstrap/target/$APP_FILE_RUNNER $APP_HOME/
WORKDIR $APP_HOME
ENTRYPOINT ["sh", "-c"]
CMD ["exec java -jar $APP_FILE_RUNNER"]</span></pre> <p><span class="koboSpan" id="kobo.74.1">This Dockerfile should be placed in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">root directory.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">The first line is the </span><a id="_idIndexMarker922"/><span class="koboSpan" id="kobo.77.1">base </span><strong class="bold"><span class="koboSpan" id="kobo.78.1">JDK 17</span></strong><span class="koboSpan" id="kobo.79.1"> image that we’ll build our image from. </span><span class="koboSpan" id="kobo.79.2">Then, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">APP_FILE_RUNNER</span></strong><span class="koboSpan" id="kobo.81.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">APP_HOME</span></strong><span class="koboSpan" id="kobo.83.1"> environment variables to define the artifact’s name and path, respectively. </span><span class="koboSpan" id="kobo.83.2">Because Quarkus is configured to run on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">8080</span></strong><span class="koboSpan" id="kobo.85.1">, we have to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">EXPOSE</span></strong><span class="koboSpan" id="kobo.87.1"> property to expose this port externally. </span><span class="koboSpan" id="kobo.87.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">COPY</span></strong><span class="koboSpan" id="kobo.89.1"> command will copy the artifact generated by Maven. </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.91.1"> defines the path that the commands will be executed from within the container. </span><span class="koboSpan" id="kobo.91.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">ENTRYPOINT</span></strong><span class="koboSpan" id="kobo.93.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">CMD</span></strong><span class="koboSpan" id="kobo.95.1">, we can define how the container will execute the application’s uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.98.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Follow these steps to generate the Docker image and start </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the container:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.101.1">First, we need to compile and generate an uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.104.1"> file:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.105.1">$ mvn clean package</span></strong></pre></li> <li><span class="koboSpan" id="kobo.106.1">Then, we </span><a id="_idIndexMarker923"/><span class="koboSpan" id="kobo.107.1">can generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">Docker</span></span><span class="No-Break"><a id="_idIndexMarker924"/></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1"> image:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.110.1">$ docker build . </span><span class="koboSpan" id="kobo.110.2">-t topology-inventory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.111.1">Sending build context to Docker daemon  38.68MB</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.112.1">Step 1/8 : FROM eclipse-temurin:17.0.8_7-jdk-alpine</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.113.1"> ---&gt; 9b2a4d2e14f6</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.114.1">Step 2/8 : ENV APP_FILE_RUNNER bootstrap-1.0-SNAPSHOT-runner.jar</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.115.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.116.1"> ---&gt; 753b39c99e78</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.117.1">Step 3/8 : ENV APP_HOME /usr/apps</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.118.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.119.1"> ---&gt; 652c7ce2bd47</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.120.1">Step 4/8 : EXPOSE 8080</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.121.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.122.1"> ---&gt; 37c6928bcae4</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.123.1">Step 5/8 : COPY bootstrap/target/$APP_FILE_RUNNER $APP_HOME/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.124.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.125.1"> ---&gt; 389c28dc9fa7</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.126.1">Step 6/8 : WORKDIR $APP_HOME</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.127.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.128.1"> ---&gt; 4ac09c0fe8cc</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.129.1">Step 7/8 : ENTRYPOINT ["sh", "-c"]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.130.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.131.1"> ---&gt; 737bbcf2402b</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.132.1">Step 8/8 : CMD ["exec java -jar $APP_FILE_RUNNER"]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.133.1"> ---&gt; Using cache</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.134.1"> ---&gt; 3b17c3fa0662</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.135.1">Successfully built 3b17c3fa0662</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.136.1">Successfully tagged topology-inventory:latest</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.137.1">The </span><a id="_idIndexMarker925"/><span class="koboSpan" id="kobo.138.1">preceding output describes all the steps that need to be executed to generate the Docker image. </span><span class="koboSpan" id="kobo.138.2">Here, we can see that Docker Engine starts building </span><a id="_idIndexMarker926"/><span class="koboSpan" id="kobo.139.1">our image on top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">eclipse-temurin:17.0.8_7-jdk-alpine</span></strong><span class="koboSpan" id="kobo.141.1"> image. </span><span class="koboSpan" id="kobo.141.2">Then, it proceeds by defining the environment variables and handling the application artifact by preparing it to be executed every time a new container from that image </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">is created.</span></span></p></li> <li><span class="koboSpan" id="kobo.143.1">Now, we can start the container with the </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.145.1">$ docker run -p 5555:8080 topology-inventory</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.146.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">-p</span></strong><span class="koboSpan" id="kobo.148.1"> parameter, we’re mapping the </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">5555</span></strong><span class="koboSpan" id="kobo.150.1"> host port to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">8080</span></strong><span class="koboSpan" id="kobo.152.1"> container port. </span><span class="koboSpan" id="kobo.152.2">So, we’ll need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">5555</span></strong><span class="koboSpan" id="kobo.154.1"> port to access </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">the system.</span></span></p></li> <li><span class="koboSpan" id="kobo.156.1">To confirm that the application is running on the Docker container, we can access the Swagger UI URL </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">http://localhost:5555/q/swagger-ui</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.160.1">Now, let’s learn how to generate a Docker image using the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">native executable.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.162.1">Creating a Docker image with a native executable</span></h2>
<p><span class="koboSpan" id="kobo.163.1">In </span><a href="B19777_10.xhtml#_idTextAnchor213"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.165.1">, </span><em class="italic"><span class="koboSpan" id="kobo.166.1">Adding Quarkus to a Modularized Hexagonal Application</span></em><span class="koboSpan" id="kobo.167.1">, we learned</span><a id="_idIndexMarker927"/><span class="koboSpan" id="kobo.168.1"> that Quarkus uses </span><strong class="bold"><span class="koboSpan" id="kobo.169.1">Ahead-Of-Time</span></strong><span class="koboSpan" id="kobo.170.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.171.1">AOT</span></strong><span class="koboSpan" id="kobo.172.1">) compilation </span><a id="_idIndexMarker928"/><span class="koboSpan" id="kobo.173.1">techniques to optimize the bytecode and generate native code that offers improved performance, mainly during </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">application startup.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">This native executable is a product of the AOT compilation that’s performed by Quarkus. </span><span class="koboSpan" id="kobo.175.2">Contrary to the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">.jar</span></strong><span class="koboSpan" id="kobo.177.1"> file, which can be distributed to run on different operating systems and CPU architectures, the native executable file is platform-dependent. </span><span class="koboSpan" id="kobo.177.2">But we can overcome this limitation by wrapping the native executable into a Docker image that can be distributed to different operating systems and </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">CPU architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">There </span><a id="_idIndexMarker929"/><span class="koboSpan" id="kobo.180.1">are different approaches to generating a native executable. </span><span class="koboSpan" id="kobo.180.2">Some of them </span><a id="_idIndexMarker930"/><span class="koboSpan" id="kobo.181.1">require us to install a </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">GraalVM</span></strong><span class="koboSpan" id="kobo.183.1"> distribution and other software. </span><span class="koboSpan" id="kobo.183.2">However, to keep things simple, we’ll follow an uncomplicated and convenient approach where Quarkus generates the native executable for us inside a Docker container that </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">contains GraalVM.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Follow these steps to generate a Docker image with a </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">native executable:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.187.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">pom.xml</span></strong><span class="koboSpan" id="kobo.189.1"> file from the project’s root directory, we need to include the following code before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">&lt;/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">project&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> tag:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.193.1">
&lt;profiles&gt;
  &lt;profile&gt;
    &lt;id&gt;native&lt;/id&gt;
    &lt;properties&gt;
      &lt;quarkus.package.type&gt;native
        &lt;/quarkus.package.type&gt;
    &lt;/properties&gt;
  &lt;/profile&gt;
&lt;/profiles&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.194.1">The preceding configuration creates a profile that sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">quarkus.package.type</span></strong><span class="koboSpan" id="kobo.196.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">native</span></strong><span class="koboSpan" id="kobo.198.1">, causing Quarkus to build a native </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">executable artifact.</span></span></p></li> <li><span class="koboSpan" id="kobo.200.1">Then, we must create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">ReflectionConfiguration</span></strong><span class="koboSpan" id="kobo.202.1"> class on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">bootst</span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.204.1">rap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.205.1"> hexagon:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.206.1">
@RegisterForReflection(targets = {
        CoreRouter.class,
        EdgeRouter.class,
        Switch.class,
        Id.class,
        IP.class,
        Location.class,
        Model.class,
        Network.class,
        Protocol.class,
        RouterType.class,
        SwitchType.class,
        Vendor.class,
})
public class ReflectionConfiguration {}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.207.1">One</span><a id="_idIndexMarker931"/><span class="koboSpan" id="kobo.208.1"> of the limitations of the native executable is that it offers partial support for reflection. </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Reflection</span></strong><span class="koboSpan" id="kobo.210.1"> is a</span><a id="_idIndexMarker932"/><span class="koboSpan" id="kobo.211.1"> technique that allows us to inspect or modify the runtime attributes of Java components, such as classes and methods. </span><span class="koboSpan" id="kobo.211.2">When we’re running an application inside a JVM, the system can detect the classes/methods/fields that are indirectly connected. </span><span class="koboSpan" id="kobo.211.3">The same is not true when we’re running a native executable. </span><span class="koboSpan" id="kobo.211.4">The reason for that is only classes that are directly connected are visible </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">for reflection.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.213.1">To overcome this limitation, we need to register all the classes for reflection that are not directly connected. </span><span class="koboSpan" id="kobo.213.2">There are two ways to do that: we can put such classes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">.json</span></strong><span class="koboSpan" id="kobo.215.1"> configuration file, or we can create a class annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">@RegisterForReflection</span></strong><span class="koboSpan" id="kobo.217.1"> annotation containing the classes we want to register for reflection. </span><span class="koboSpan" id="kobo.217.2">In the preceding code, we are using the latter approach, which relies on the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">annotated class.</span></span></p></li> <li><span class="koboSpan" id="kobo.219.1">To generate a native executable, we have to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">follo</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.221.1">wing command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.222.1">$ mvn clean package -Pnative -Dquarkus.native.container-build=true -Dnative-image.xmx=6g</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.223.1">The </span><a id="_idIndexMarker933"/><span class="koboSpan" id="kobo.224.1">compilation process of a native executable is a very expensive one in terms of memory consumption. </span><span class="koboSpan" id="kobo.224.2">So, we need to increase memory limits to avoid out-of-memory errors. </span><span class="koboSpan" id="kobo.224.3">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">6g</span></strong><span class="koboSpan" id="kobo.226.1"> is not enough for you, feel free to increase it to </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">prevent errors.</span></span></p></li> <li><span class="koboSpan" id="kobo.228.1">Next, we must create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Dockerfile-native</span></strong><span class="koboSpan" id="kobo.230.1"> that contains instructions for building a Docker image with the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">native executable:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.232.1">
FROM registry.access.redhat.com/ubi8/ubi-minimal
ENV APP_FILE_RUNNER bootstrap-1.0-SNAPSHOT-runner
ENV APP_HOME /work
EXPOSE 8080
COPY bootstrap/target/$APP_FILE_RUNNER $APP_HOME/
WORKDIR $APP_HOME
RUN echo $APP_FILE_RUNNER
CMD ["./bootstrap-1.0-SNAPSHOT-runner", "-
  Dquarkus.http.host=0.0.0.0"]</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.233.1">Instead of the JDK 17 base image, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">ubi-minimal</span></strong><span class="koboSpan" id="kobo.235.1"> image from the </span><a id="_idIndexMarker934"/><span class="koboSpan" id="kobo.236.1">official </span><strong class="bold"><span class="koboSpan" id="kobo.237.1">Red Hat</span></strong><span class="koboSpan" id="kobo.238.1"> registry. </span><span class="koboSpan" id="kobo.238.2">This image is suitable for running </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">native executables.</span></span></p></li> <li><span class="koboSpan" id="kobo.240.1">Then, we must generate the Docker image with the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">fol</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.242.1">lowing command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.243.1">$ docker build . </span><span class="koboSpan" id="kobo.243.2">-t topology-inventory-native -f Dockerfile-native</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.244.1">You should run the preceding command from the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">root directory.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.246.1">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">-t topology-inventory-native:latest</span></strong><span class="koboSpan" id="kobo.248.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">-f Dockerfile-native</span></strong><span class="koboSpan" id="kobo.250.1"> to create a different Docker image based on the native executable rather than the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">.jar</span></strong><span class="koboSpan" id="kobo.252.1"> file. </span><span class="koboSpan" id="kobo.252.2">The output of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">docker build</span></strong><span class="koboSpan" id="kobo.254.1"> command will be similar to the one we generated when we created the Docker image for </span><a id="_idIndexMarker935"/><span class="koboSpan" id="kobo.255.1">the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">.jar</span></strong><span class="koboSpan" id="kobo.257.1"> file. </span><span class="koboSpan" id="kobo.257.2">The only difference will be the entries related to the native </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">executable artifact.</span></span></p></li> <li><span class="koboSpan" id="kobo.259.1">Tag and upload your image to your personal </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Docker registry:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.261.1">$ docker tag topology-inventory-native:latest s4intlaurent/topology-inventory-native:latest</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.262.1">$ docker push s4intlaurent/topology-inventory-native:latest</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.263.1">The push refers to repository [docker.io/s4intlaurent/topology-inventory-native]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.264.1">f3216c6ba268: Pushed</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.265.1">0b911edbb97f: Layer already exists</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.266.1">54e42005468d: Layer already exists</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.267.1">latest: digest: sha256:4037e5d9c2cef01bda9c4bb5722bccbe0d003336534c28f8245076223ce77273 size: 949</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.268.1">We’ll use the system’s native image when deploying the application on a </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">minikube cluster.</span></span></p></li> <li><span class="koboSpan" id="kobo.270.1">Now, we can start </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">the container:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.272.1">docker run -p 5555:8080 topology-inventory-native:latest</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.273.1">Note that the application is bootstrapping </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">much faster!</span></span></p></li> <li><span class="koboSpan" id="kobo.275.1">To confirm that the application is running on the Docker container, we can access the Swagger UI URL </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">http://localhost:5555/q/swagger-ui</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.279.1">With that, we have configured the Docker images for both the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">.jar</span></strong><span class="koboSpan" id="kobo.281.1"> and native executable artifacts. </span><span class="koboSpan" id="kobo.281.2">These Docker images can be deployed on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.281.3">However, to </span><a id="_idIndexMarker936"/><span class="koboSpan" id="kobo.282.1">do that, we need to create the required Kubernetes objects to allow the deployment. </span><span class="koboSpan" id="kobo.282.2">So, in the next section, we’ll learn how to create Kubernetes objects for the containerized </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.284.1">Creating Kubernetes objects</span></h1>
<p><a id="_idIndexMarker937"/><span class="koboSpan" id="kobo.285.1">Docker Engine does not provide any fault-tolerance or high availability mechanism. </span><span class="koboSpan" id="kobo.285.2">It only offers container-based virtualization technology. </span><span class="koboSpan" id="kobo.285.3">So, if you plan on running a critical-mission application using Docker, you may either need to work out your solution to ensure the containers are reliable while running or delegate this responsibility to a </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">container orchestrator.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">Container orchestrators arose as a response to the increased use of containers in the IT industry. </span><span class="koboSpan" id="kobo.287.2">Among these orchestrators, we can quote Docker Swarm, Rancher, and the one that dominates the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">industry: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.289.1">Kubernetes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.291.1">Initially conceived at Google as a closed source software called Borg, it was open-sourced with the name Kubernetes. </span><span class="koboSpan" id="kobo.291.2">It’s a powerful technology that can run on your computer for development purposes or control a fleet of hundreds, even thousands, of server nodes, providing Pods for the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">running applications.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">You may be wondering, </span><em class="italic"><span class="koboSpan" id="kobo.294.1">what is a Pod?</span></em><span class="koboSpan" id="kobo.295.1"> We’ll find </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">out soon.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">It’s not our intent here to dive deep into Kubernetes' internals, but we’ll review some basic concepts to ensure we’re on the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">same page.</span></span></p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.299.1">Reviewing Kubernetes' main objects</span></h2>
<p><span class="koboSpan" id="kobo.300.1">As </span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.301.1">we saw earlier, Kubernetes is a container orchestrator that helps us manage containers. </span><span class="koboSpan" id="kobo.301.2">To accomplish this, most – if not all – Kubernetes configuration can be done through </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">.yaml</span></strong><span class="koboSpan" id="kobo.303.1"> files. </span><span class="koboSpan" id="kobo.303.2">In Kubernetes, we have the notion of the current state and the desired state. </span><span class="koboSpan" id="kobo.303.3">When the former meets the latter, we’re fine. </span><span class="koboSpan" id="kobo.303.4">Otherwise, we </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">have problems.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">The backbone of this currently desired state approach is the Kubernetes configuration mechanism based on YAML files. </span><span class="koboSpan" id="kobo.305.2">With these files, we can express the desired state of things inside the cluster. </span><span class="koboSpan" id="kobo.305.3">Kubernetes will do its magic to ensure that the current state always matches the desired state. </span><span class="koboSpan" id="kobo.305.4">But, you may be wondering, </span><em class="italic"><span class="koboSpan" id="kobo.306.1">the state of what?</span></em><span class="koboSpan" id="kobo.307.1"> The answer is the </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.308.1">state of Kubernetes objects. </span><span class="koboSpan" id="kobo.308.2">Let’s look at some </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">of them:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">Pod</span></strong><span class="koboSpan" id="kobo.311.1">: A Pod is a</span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.312.1"> Kubernetes object that controls the life cycle of containers in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.312.2">It’s possible to attach more than one container to the same Pod, although this is not a </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">common practice.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.314.1">Deployment</span></strong><span class="koboSpan" id="kobo.315.1">: If a Pod controls the life cycle of containers, we can state that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">Deployment</span></strong><span class="koboSpan" id="kobo.317.1"> object</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.318.1"> controls the life cycle of Pods. </span><span class="koboSpan" id="kobo.318.2">With a Deployment, you can specify how many Pods you want to provide for your application. </span><span class="koboSpan" id="kobo.318.3">Kubernetes will take care of finding the available resources in the cluster to bring up these Pods. </span><span class="koboSpan" id="kobo.318.4">If, for some reason, one of the Pods goes down, Kubernetes will try to bring a brand-new Pod to ensure the desired state is </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">being met.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.320.1">Service</span></strong><span class="koboSpan" id="kobo.321.1">: When</span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.322.1"> we deploy Pods on the Kubernetes cluster, they are not immediately available internally for other Pods or externally for clients outside the cluster. </span><span class="koboSpan" id="kobo.322.2">To make a deployed Pod available in the network, we need to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Service</span></strong><span class="koboSpan" id="kobo.324.1"> object attached to that Pod. </span><span class="koboSpan" id="kobo.324.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Service</span></strong><span class="koboSpan" id="kobo.326.1"> object acts as a DNS entry point that provides basic load balancing access to the Pods. </span><span class="koboSpan" id="kobo.326.2">For example, if you have an application running on three Pods, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Service</span></strong><span class="koboSpan" id="kobo.328.1"> object will handle application requests for one of the three Pods sitting behind the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Service</span></strong><span class="koboSpan" id="kobo.330.1"> object. </span><span class="koboSpan" id="kobo.330.2">More sophisticated load balancing features can be achieved by using service mesh technologies </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.331.1">such </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.333.1">Istio</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.335.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.336.1">: If</span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.337.1"> you need to provide environment variables or mount a configuration file inside a Pod, </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.339.1"> is the object that can help you </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">with that.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.341.1">Secret</span></strong><span class="koboSpan" id="kobo.342.1">: This </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.343.1">works similarly to </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.345.1"> but can be used to store sensitive information such as credentials or private keys. </span><span class="koboSpan" id="kobo.345.2">The data in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">Secret</span></strong><span class="koboSpan" id="kobo.347.1"> object should be encoded </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">base64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.351.1">Now that we’re more acquainted with some of the most important Kubernetes objects, let’s see how we can use them to prepare our hexagonal system to be deployed on a </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">Kubernetes cluster.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.353.1">Configuring Kubernetes objects for the hexagonal system</span></h2>
<p><span class="koboSpan" id="kobo.354.1">Before </span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.355.1">creating the Kubernetes objects, first, let’s configure Quarkus to enable YAML configuration and also a health check mechanism. </span><span class="koboSpan" id="kobo.355.2">We’ll need both of these when we’re deploying the application </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">on Kubernetes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quar</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.358.1">kus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-config-yaml&lt;/artifactId&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</span></pre> <p><span class="koboSpan" id="kobo.359.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">quarkus-config-yaml</span></strong><span class="koboSpan" id="kobo.361.1">, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">application.yaml</span></strong><span class="koboSpan" id="kobo.363.1"> file for most of the Quarkus configurations. </span><span class="koboSpan" id="kobo.363.2">And to enable health checks endpoints, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">quarkus-smallrye-health</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Before creating the Kubernetes objects, let’s configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">application.yaml</span></strong><span class="koboSpan" id="kobo.369.1"> file on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">bootstrap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.371.1"> hexagon:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
quarkus:
  datasource:
    username: ${QUARKUS_DATASOURCE_USERNAME:root}
    password: ${QUARKUS_DATASOURCE_PASSWORD:password}
    reactive:
      url: ${QUARKUS_DATASOURCE_REACTIVE_URL:
        mysql://localhost:3306/inventory}</span></pre> <p><span class="koboSpan" id="kobo.373.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">.yaml</span></strong><span class="koboSpan" id="kobo.375.1"> file allows us to use most, but not all, of the configurations available on Quarkus. </span><span class="koboSpan" id="kobo.375.2">So, it’s normal to use both </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">application.yaml</span></strong><span class="koboSpan" id="kobo.377.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">application.properties</span></strong><span class="koboSpan" id="kobo.379.1">. </span><span class="koboSpan" id="kobo.379.2">We’re using the YAML configuration because we can employ a</span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.380.1"> technique called </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">variable interpolation</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">Take, for </span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.383.1">example, the following </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">configuration entry:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.385.1">
${QUARKUS_DATASOURCE_USERNAME:root}</span></pre> <p><span class="koboSpan" id="kobo.386.1">When the application starts, it will try to resolve an environment variable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">QUARKUS_DATASOURCE_USERNAME</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">If the application can’t resolve the variable name, it will fall back to the default value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">root</span></strong><span class="koboSpan" id="kobo.390.1">. </span><span class="koboSpan" id="kobo.390.2">This technique is very useful for defining default configurations for local development where environment variables may not </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">be set.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">You may have noticed the presence of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">QUARKUS_DATASOURCE_USERNAME</span></strong><span class="koboSpan" id="kobo.394.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">QUARKUS_DATASOURCE_PASSWORD</span></strong><span class="koboSpan" id="kobo.396.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">QUARKUS_DATASOURCE_REACTIVE_URL</span></strong><span class="koboSpan" id="kobo.398.1"> environment variables. </span><span class="koboSpan" id="kobo.398.2">Kubernetes will provide these environment variables with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">Secret</span></strong><span class="koboSpan" id="kobo.400.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.402.1"> objects. </span><span class="koboSpan" id="kobo.402.2">So, let’s learn how to configure these and the other Kubernetes objects that are required to deploy the</span><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.403.1"> topology and inventory system (the files we will describe here are put inside a directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">k8s</span></strong><span class="koboSpan" id="kobo.405.1"> in the project’s </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">root directory):</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.407.1">We will start by configuring the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">configmap.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
apiVersion: v1
kind: ConfigMap
metadata:
  name: topology-inventory
data:
  QUARKUS_DATASOURCE_REACTIVE_URL:
    «mysql://topology-inventory-mysql:3306/inventory»</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.411.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.413.1"> provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">QUARKUS_DATASOURCE_REACTIVE_URL</span></strong><span class="koboSpan" id="kobo.415.1"> environment variable with the reactive database URL that the application needs to connect to the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">MySQL database.</span></span></p></li> <li><span class="koboSpan" id="kobo.417.1">Then, we </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.418.1">must configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">secret.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
apiVersion: v1
kind: Secret
metadata:
  name: topology-inventory
type: Opaque
data:
  QUARKUS_DATASOURCE_USERNAME: cm9vdAo=
  QUARKUS_DATASOUCE_PASSWORD: cGFzc3dvcmQK</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.422.1">In the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">Secret</span></strong><span class="koboSpan" id="kobo.424.1">, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">QUARKUS_DATASOURCE_USERNAME</span></strong><span class="koboSpan" id="kobo.426.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">QUARKUS_DATASOUCE_PASSWORD</span></strong><span class="koboSpan" id="kobo.428.1"> environment variables as the credentials to connect to the system’s </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">MySQL database.</span></span></p></li> <li><span class="koboSpan" id="kobo.430.1">To generate </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">base64</span></strong><span class="koboSpan" id="kobo.432.1">, you can execute the following command on </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">Unix-based systems:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.434.1">$ echo root | base64 &amp;&amp; echo password | base64</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.435.1">cm9vdAo=</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.436.1">cGFzc3dvcmQK</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.437.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">root</span></strong><span class="koboSpan" id="kobo.439.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">password</span></strong><span class="koboSpan" id="kobo.441.1"> values as the credentials to authenticate on the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">MySQL database.</span></span></p></li> <li><span class="koboSpan" id="kobo.443.1">Let’s configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">deployment.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.445.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.446.1">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: topology-inventory
  labels:
    app: topology-inventory
spec:
  replicas: 1
  selector:
    matchLabels:
      app: topology-inventory
  template:
    metadata:
      labels:
        app: topology-inventory
/** Code omitted **/</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.447.1">Here, we </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.448.1">describe some of the metadata entries from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">deployment.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.450.1"> file:</span></span></p><ul><li><span class="koboSpan" id="kobo.451.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">metadata.labels.app</span></strong><span class="koboSpan" id="kobo.453.1"> field: A Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Service</span></strong><span class="koboSpan" id="kobo.455.1"> object can apply load balancing by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">labels</span></strong><span class="koboSpan" id="kobo.457.1"> property to identify the Pods that are part of the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">Deployment</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">We’ll see how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">Service</span></strong><span class="koboSpan" id="kobo.461.1"> object references that </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">label shortly.</span></span></li><li><span class="koboSpan" id="kobo.463.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">replicas</span></strong><span class="koboSpan" id="kobo.465.1"> field: This defines that this </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">Deployment</span></strong><span class="koboSpan" id="kobo.467.1"> will provide just </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">one Pod.</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.469.1">Still in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">deployment.yaml</span></strong><span class="koboSpan" id="kobo.471.1"> file, we can start defining the entries for the </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">container </span></span><span class="No-Break"><a id="_idIndexMarker951"/></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">configuration:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.474.1">
    spec:
      initContainers:
        - name: topology-inventory-mysql-init
          image: busybox
          command: [ ‹sh›, ‹-c›, ‹until nc -zv
            topology-inventory-mysql.default.svc.clus
              ter.local 3306; do echo waiting
            for topology-inventory-mysql.de
              fault.svc.cluster.local; sleep 5;
            done;› ]
      containers:
        - name: topology-inventory
          image: s4intlaurent/topology-
            inventory:latest
          envFrom:
          - configMapRef:
              name: topology-inventory
          livenessProbe:
            httpGet:
              path: /q/health/ready
              port: 8080
            initialDelaySeconds: 30
            timeoutSeconds: 5
            periodSeconds: 3
          ports:
- containerPort: 8080</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.475.1">Let’s look</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.476.1"> at the entries that are used for the </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">container configuration:</span></span></p><ul><li><span class="koboSpan" id="kobo.478.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">initContainers</span></strong><span class="koboSpan" id="kobo.480.1"> field: This</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.481.1"> is used when we need to execute some tasks or wait for something before the main container starts. </span><span class="koboSpan" id="kobo.481.2">Here, we’re using an </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">init</span></strong><span class="koboSpan" id="kobo.483.1"> container to wait for a MySQL database to be available. </span><span class="koboSpan" id="kobo.483.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">.yaml</span></strong><span class="koboSpan" id="kobo.485.1"> file that loads the database is available in this book’s GitHub repository for </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">this chapter.</span></span></li><li><span class="koboSpan" id="kobo.487.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Containers</span></strong><span class="koboSpan" id="kobo.489.1"> field: This is </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.490.1">where we set the configuration for the container that the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">Pod runs.</span></span></li><li><span class="koboSpan" id="kobo.492.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">image</span></strong><span class="koboSpan" id="kobo.494.1"> field: This is </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.495.1">where we inform the image location of our application. </span><span class="koboSpan" id="kobo.495.2">It can be a public or </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">private registry.</span></span></li><li><span class="koboSpan" id="kobo.497.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">configMapRef</span></strong><span class="koboSpan" id="kobo.499.1"> field: This</span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.500.1"> is used to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">ConfigMap</span></strong><span class="koboSpan" id="kobo.502.1"> data into </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the container.</span></span></li><li><span class="koboSpan" id="kobo.504.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">livenessProbe</span></strong><span class="koboSpan" id="kobo.506.1"> field: Kubernetes</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.507.1"> can send probe packets to check whether the application is alive. </span><span class="koboSpan" id="kobo.507.2">This is where we’ll use the health check mechanism we </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">configured earlier.</span></span></li><li><span class="koboSpan" id="kobo.509.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">containerPort</span></strong><span class="koboSpan" id="kobo.511.1"> field: This</span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.512.1"> is where we’ll inform the port about the exposed </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">Docker container.</span></span></li></ul></li> <li><span class="koboSpan" id="kobo.514.1">Finally, we will configure the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">service.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1"> file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.517.1">
apiVersion: v1
kind: Service
metadata:
  name: topology-inventory
  labels:
    app: topology-inventory
spec:
  type: NodePort
  ports:
    - port: 8080
      targetPort: 8080
      nodePort: 30080
      protocol: TCP
  selector:
    app: topology-inventory</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.518.1">Kubernetes </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.519.1">provides three different Service types: </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">ClusterIP</span></strong><span class="koboSpan" id="kobo.521.1"> for internal communication, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">NodePort</span></strong><span class="koboSpan" id="kobo.523.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">LoadBalance</span></strong><span class="koboSpan" id="kobo.525.1"> for external communication. </span><span class="koboSpan" id="kobo.525.2">We’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">NodePort</span></strong><span class="koboSpan" id="kobo.527.1"> to access the application from outside the Kubernetes cluster. </span><span class="koboSpan" id="kobo.527.2">Let’s take a look at the most </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">important fields:</span></span></p><ul><li><span class="koboSpan" id="kobo.529.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">port</span></strong><span class="koboSpan" id="kobo.531.1"> field: This field declares the Service port that is available internally for other Pods in the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">Kubernetes cluster</span></span></li><li><span class="koboSpan" id="kobo.533.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">targetPort</span></strong><span class="koboSpan" id="kobo.535.1"> field: This field specifies the port that the container </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">is exposing</span></span></li><li><span class="koboSpan" id="kobo.537.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">nodePort</span></strong><span class="koboSpan" id="kobo.539.1"> field: This field specifies the external port, which allows external clients to access </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">the application</span></span></li></ul></li> </ol>
<p><span class="koboSpan" id="kobo.541.1">It’s not a trivial undertaking to prepare an application to be deployed on a Kubernetes cluster. </span><span class="koboSpan" id="kobo.541.2">In this section, we learned about the main objects of Kubernetes. </span><span class="koboSpan" id="kobo.541.3">Understanding these objects is essential because they are the building blocks for any application running on a </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">With all the required </span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.544.1">Kubernetes objects adequately configured, we can deploy the hexagonal system in a </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">Kubernetes cluster.</span></span></p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.546.1">Deploying on minikube</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.547.1">minikube</span></strong><span class="koboSpan" id="kobo.548.1"> is a </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.549.1">Kubernetes cluster that was made for development </span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.550.1">purposes. </span><span class="koboSpan" id="kobo.550.2">It allows us to create and destroy clusters with ease. </span><span class="koboSpan" id="kobo.550.3">Because of its simplicity, we’ll use minikube to </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.551.1">deploy our hexagonal system by following these steps (I recommend following the instructions at </span><a href="https://minikube.sigs.k8s.io/docs/start/"><span class="koboSpan" id="kobo.552.1">https://minikube.sigs.k8s.io/docs/start/</span></a><span class="koboSpan" id="kobo.553.1"> to install minikube on </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">your machine):</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.555.1">Once you have installed minikube, you can start your cluster by issuing the </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.557.1">$ minikube start</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.558.1">:) minikube v1.4.0 on Fedora 30</span></strong><span class="koboSpan" id="kobo.559.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.560.1">Creating virtualbox VM (CPUs=2, Memory=2000MB, Disk=20000MB) ...</span></strong><span class="koboSpan" id="kobo.561.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.562.1">Preparing Kubernetes v1.16.0 on Docker 18.09.9 ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.563.1">   Pulling images ...</span></strong><span class="koboSpan" id="kobo.564.1">
   </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">Launching Kubernetes ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.566.1">   Waiting for: apiserver proxy etcd scheduler controller dns</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.567.1">   Done! </span><span class="koboSpan" id="kobo.567.2">kubectl is now configured to use "minikube"</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.568.1">The default cluster configuration consumes 2 CPUs, 2 GB of RAM, and 20 GB of </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">disk space.</span></span></p></li> <li><span class="koboSpan" id="kobo.570.1">To confirm that your cluster is alive, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.572.1">$ kubectl get nodes</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.573.1">NAME       STATUS   ROLES    AGE   VERSION</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.574.1">minikube   Ready    master   5m    v1.16.0</span></strong></pre><p class="list-inset"><em class="italic"><span class="koboSpan" id="kobo.575.1">Nice!</span></em><span class="koboSpan" id="kobo.576.1"> Now, we can deploy the topology and inventory system to our local </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">Kubernetes cluster.</span></span></p></li> <li><span class="koboSpan" id="kobo.578.1">The </span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.579.1">Deployment process is fairly simple. </span><span class="koboSpan" id="kobo.579.2">All we have to do is apply the Kubernetes YAML files we created in the </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">previous section:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.581.1">$ kubectl apply -f k8s/</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.582.1">configmap/topology-inventory created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.583.1">deployment.apps/topology-inventory-mysql created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.584.1">service/topology-inventory-mysql created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.585.1">deployment.apps/topology-inventory created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.586.1">secret/topology-inventory created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.587.1">service/topology-inventory created</span></strong></pre></li> <li><span class="koboSpan" id="kobo.588.1">Then, we can run the following command to see whether the topology and inventory system is up </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">and running:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.590.1">$ kubectl get pods</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.591.1">NAME                                       READY   STATUS    RESTARTS   AGE</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.592.1">topology-inventory-76f4986846-zq5t8        1/1     Running   0          73s</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.593.1">topology-inventory-mysql-dc9dbfc4b-7sct6   1/1     Running   0          73s</span></strong></pre></li> <li><span class="koboSpan" id="kobo.594.1">To access the application, we need to use the minikube cluster IP. </span><span class="koboSpan" id="kobo.594.2">You can use the following code to retrieve that IP on a Unix-based </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">operating system:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.596.1">$ minikube ssh "ip addr show eth0" | grep "inet\b" | awk '{print $2}' | cut -d/ -f1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.597.1">192.168.49.2</span></strong></pre></li> <li><span class="koboSpan" id="kobo.598.1">With</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.599.1"> that IP, we can query the health check endpoint to see whether the topology and inventory system </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">is alive:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.601.1">$ curl -s http://192.168.49.2:30080/q/health/ready | jq</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.602.1">{</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.603.1">  "status": "UP",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.604.1">  "checks": [</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.605.1">    {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.606.1">      "name": "Reactive MySQL connections health</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.607.1">         check",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.608.1">      "status": "UP",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.609.1">      "data": {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.610.1">        "&lt;default&gt;": "UP"</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.611.1">      }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.612.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.613.1">  ]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.614.1">}</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.615.1">This shows that both the application and its database connection </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">are healthy.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.617.1">You can also access the Swagger UI URL at </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">http://192.168.49.2:30080/q/swagger-ui</span></strong><span class="koboSpan" id="kobo.619.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.621.1"><img alt="Figure 14.1 – Swagger UI from topology and inventory running on minikube" src="image/B19777_14_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.622.1">Figure 14.1 – Swagger UI from topology and inventory running on minikube</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.623.1">Note that </span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.624.1">we are using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">30080</span></strong><span class="koboSpan" id="kobo.626.1"> to access the Swagger UI URL on minikube. </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">30080</span></strong><span class="koboSpan" id="kobo.628.1"> is the Kubernetes node port that we configured to enable external access to </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">With that, we have completed the fundamental steps to turn the hexagonal system into a cloud-native one. </span><span class="koboSpan" id="kobo.630.2">Our application is ready to be deployed on a local minikube cluster and any cloud provider that offers </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">Kubernetes clusters.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.632.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.633.1">We started this chapter by learning about the building blocks that we can use to create a Docker image for the hexagonal system. </span><span class="koboSpan" id="kobo.633.2">Then, we created two Docker image types. </span><span class="koboSpan" id="kobo.633.3">The first one was based on the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">.jar</span></strong><span class="koboSpan" id="kobo.635.1"> file, which is used to package and run the application, while the second one was based on native executables, where we could leverage the features Quarkus provides to create a native </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">executable artifact.</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">Then, we created the Kubernetes objects that were required to deploy the hexagonal system in a Kubernetes cluster. </span><span class="koboSpan" id="kobo.637.2">Finally, we deployed the hexagonal system in a local minikube cluster. </span><span class="koboSpan" id="kobo.637.3">More than a hexagonal system, we now have a cloud-native hexagonal system ready to tap into the advantages provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">cloud environments.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">In the next chapter, we will learn how hexagonal architecture relates to layered architecture, an architectural style used by many applications. </span><span class="koboSpan" id="kobo.639.2">Understanding the differences between these two architectures helps us assess which architecture may be better to employ when starting or refactoring a </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">software project.</span></span></p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.641.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.642.1">What is the advantage of the native executable over the uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1"> artifact?</span></span></li>
<li><span class="koboSpan" id="kobo.646.1">Which Kubernetes object can we use to store environment variables and mount </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">configuration files?</span></span></li>
<li><span class="koboSpan" id="kobo.648.1">What Service type is used to make a Kubernetes Pod </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">externally available?</span></span></li>
</ol>
<h1 id="_idParaDest-238"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.650.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.651.1">The startup time is much faster than the traditional uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">jar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1"> artifact.</span></span></li>
<li><span class="koboSpan" id="kobo.655.1">We can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">ConfigMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.657.1"> object.</span></span></li>
<li><span class="koboSpan" id="kobo.658.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">NodePort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.660.1">Service type.</span></span></li>
</ol>
</div>


<div class="Content" id="_idContainer084">
<h1 id="_idParaDest-239" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.1.1">Part 4: Hexagonal Architecture and Beyond</span></h1>
<p><span class="koboSpan" id="kobo.2.1">You will learn in this part what distinguishes hexagonal architecture from the widely used layered architecture. </span><span class="koboSpan" id="kobo.2.2">We will highlight the differences between both and allow you to make a more informed decision regarding which architecture to use when starting your next software project. </span></p>
<p><span class="koboSpan" id="kobo.3.1">We will then explore how SOLID principles can be combined with hexagonal architecture ideas to build better, change-tolerant applications. </span></p>
<p><span class="koboSpan" id="kobo.4.1">Finally, to finish the book, we'll discuss some good design practices you can follow to create robust </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">hexagonal systems.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B19777_15.xhtml#_idTextAnchor305"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Comparing Hexagonal Architecture with Layered Architecture</span></em></li>
<li><a href="B19777_16.xhtml#_idTextAnchor324"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 16</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Using SOLID Principles with Hexagonal Architecture</span></em></li>
<li><a href="B19777_17.xhtml#_idTextAnchor348"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 17</span></em></a><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Good Design Practices for Your Hexagonal Application</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer085">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer086">
</div>
</div>
</body></html>