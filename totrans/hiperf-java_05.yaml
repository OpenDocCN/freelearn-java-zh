- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithm Efficiencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers focused on ensuring their Java applications perform at a high level
    must consider the efficiency of individual algorithms. We do not judge an algorithm’s
    efficiency by its lines of code; rather, we make this judgment after analyzing
    test results.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is intended to help you learn how to choose the right algorithm
    for any given requirement. It also covers the concept of time complexity to include
    strategies for reducing time complexity. We will also focus on lean and efficient
    code. This chapter also emphasizes the importance of algorithm testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low time complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing algorithms for efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a strong theoretical understanding
    of algorithm efficiencies as well as hands-on experience creating and modifying
    algorithms. This experience can help ensure you get high performance out of your
    Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best things about writing software is that there is no single solution
    to a problem. We are free to use a style that’s unique to us and to incorporate
    data structures, libraries, and algorithms as long as we obtain the correct results.
    This is a bit of an overstatement. We can write an algorithm in essentially infinite
    different ways and get the same results.
  prefs: []
  type: TYPE_NORMAL
- en: This programming flexibility can also be a detriment, as evidenced by low-performant
    algorithms. So, just because we can write algorithms with reckless abandon, it
    does not mean we should. We should be strategic in our algorithm selection and
    creation as it will have a significant impact on the overall efficiency of our
    Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at a specific process of selecting algorithms,
    a case study, and evolving trends.
  prefs: []
  type: TYPE_NORMAL
- en: Selection process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there is no industry-wide official algorithm selection process, here
    is a six-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully understand the requirements. It may seem obvious, but so many developers
    get this wrong. It is critical to fully understand the requirements. This is the
    problem we want an algorithm to solve. Understanding the problem involves learning
    about constraints, datasets, inputs, outputs, and more. Once we have fully understood
    the requirements, we can move on to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this second step, we should become familiar with the data that our algorithm
    will be associated with. This might include static data, data streams, or even
    generating data. This step is where you fully immerse yourself in anything related
    to the application’s data. In addition to data familiarity, we should start thinking
    about what type of data structures our algorithms should use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider the computational complexity of each potential algorithm. Points for
    consideration here include the time and memory requirements. You can implement
    benchmarking to help inform your decision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this step, you should identify resource limitations related to processing
    and memory. Knowing these upper boundaries will aid your algorithm decision.
  prefs: []
  type: TYPE_NORMAL
- en: This is where you test your algorithms, make refinements, and retest. This is
    an iterative process where you should make small, incremental changes to your
    algorithms to help identify what works best.
  prefs: []
  type: TYPE_NORMAL
- en: Document your final decision and all factors that led to it. The more detailed
    your document, the better. This will be helpful when revisiting your selection
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should adopt a continual process improvement mindset and not hesitate
    to question previous decisions. Even if you select and refine an algorithm that
    results in the best possible performance, it should be periodically reviewed.
    Environments, data, and other factors can change over time and impact your algorithm’s
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how these steps can be implemented by reviewing a case study
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It can be helpful to review case studies to help solidify our understanding
    of how algorithm selection can significantly improve Java application performance.
    This section details the algorithm selection for a business’ e-commerce platform.
    The business noted that its system processed search requests inefficiently, resulting
    in user complaints that the system was sluggish. So, the business hopes to improve
    the search function and, therefore, the overall performance of their application.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this case is to identify what is causing the problem. For
    our example, the e-commerce platform implemented a linear search algorithm that
    matches user requests with database entries. The search algorithm has not changed
    since the initial system was developed and the database continues to increase
    in size. All search results are slow.
  prefs: []
  type: TYPE_NORMAL
- en: Our second step is to understand the data. So, the developer reviews the database
    schema and sampled database records to become familiar with the system’s data
    requirements and use. In the next two steps, the developer reviews the computational
    complexity of the search feature and identifies any resource limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The developer is now poised to evaluate alternative algorithms. In this example,
    possible alternatives could include binary searches and other proven search patterns.
    The review of these alternatives leads to the adoption of an inverted index for
    a data structure that can be optimized for full-text searches.
  prefs: []
  type: TYPE_NORMAL
- en: Inverted index
  prefs: []
  type: TYPE_NORMAL
- en: A data structure commonly used for full-text searches. The indexing identifies
    each unique term and lists where that term appears. Implementation typically includes
    using a dictionary or hashmap.
  prefs: []
  type: TYPE_NORMAL
- en: Now the developer can tailor their selection based on their system’s needs.
    Next, they will perform multiple tests and document the results. In this example
    case, the system’s search function is now highly performant. What is left is to
    document the decision and decision factors.
  prefs: []
  type: TYPE_NORMAL
- en: The example case showed developers that they need to balance application performance
    and resource utilization. Next, let’s look at some evolving trends in algorithm
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving trends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java software development is a dynamic field, as are the algorithms we create
    and use. There are several trends regarding algorithm efficiencies, and five of
    them are described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**AI and ML**: Many people in the tech space have coined 2023 as the year of
    **Artificial Intelligence** (**AI**). AI and **Machine Learning** (**ML**) are
    not new, but their widespread use and adoption have never been more prevalent,
    thanks to OpenAI’s launch in 2015 and the introduction of **Generative Pre-trained
    Transformers** (**GPTs**), such as ChatGPT. The industry is experiencing a shift
    towards AI-related algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about leveraging AI for high-performance Java applications
    in [*Chapter 18*](B21942_18.xhtml#_idTextAnchor345).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concurrency**: With the proliferation of multi-core processors, the need
    to focus algorithms on parallel processing has increased. Fortunately, Java has
    robust support for concurrency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can learn more about concurrency strategies in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cloud optimizations**: As more applications are being hosted in the cloud,
    the need for updating our Java applications for cloud optimization increases.
    Cloud computing requires us to consider concepts such as scalability and distributed
    processing. These considerations are important for new Java applications that
    are being developed for the cloud as well as existing applications that we want
    to migrate to the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: One thing in software development that seems to remain the same
    is the ever-increasing number of cyber threats to our systems and data. Security
    is a mindset, not a step in software development. The trend here is the increased
    emphasis on security throughout the product life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community**: There is impressive growth in the area of crowdsourced algorithm
    design and other open source contributions. The systems and algorithms that result
    are increasingly robust and diverse.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have reviewed algorithm selection, shared a case study, and discussed
    evolving algorithm trends, we can look at low time complexity as it relates to
    algorithm efficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: Low time complexity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time complexity refers to the measure of the time efficiency of any given algorithm.
    We want to determine the execution time of our Java applications and ensure our
    algorithms do not add time complexity to our applications. The overall goal is
    to reduce algorithm execution time. We should test our algorithms using a variety
    of possible inputs and environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at specific strategies to help you reduce the
    time complexity of your algorithms. We will also address the common pitfalls associated
    with time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for reducing time complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several strategies we can adopt to help us reduce the time complexity
    of our algorithms. Perhaps the easiest strategy is to simply ensure our algorithms
    are not overly complicated. This strategy requires us to double-check our algorithmic
    logic and use the optimization techniques covered throughout this book. Reducing
    unnecessary calculations within a loop, especially with recursion, is a great
    optimization strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes our algorithms might seem to be overly complex and we cannot find
    a way to simplify them. In those cases, it is worth considering breaking the algorithm
    into multiple algorithms, each executing a subset of the original set of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When reviewing the common pitfalls related to algorithm time efficiency, we
    can refer to previous chapters and look at others yet to come. As you can see
    from the list of the top four common pitfalls listed here, details can be found
    in several chapters of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Improper use of data structures ([*Chapter 2*](B21942_02.xhtml#_idTextAnchor028))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overuse of non-standard libraries ([*Chapter 13*](B21942_13.xhtml#_idTextAnchor227))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inadequate testing and profiling ([*Chapter 14*](B21942_14.xhtml#_idTextAnchor250))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of focus on readability and maintainability ([*Chapter 16*](B21942_16.xhtml#_idTextAnchor307))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we might simply be overlooking the big picture of our application’s
    overall performance. Sometimes, we can get stuck in the minutiae of our code at
    the expense of overall algorithm or application efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, low-time complexity is both a concept and a goal. It is an
    essential consideration when our ultimate aim is to increase the performance of
    our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing algorithms for efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it is clear that we need our algorithms to be efficient. This
    section focuses on how we can measure algorithm efficiency based on our requirements.
    We will start with a short section on the importance of testing, then how to prepare
    for testing, how to conduct the tests, and what to do after testing.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, if we do not test our algorithms for efficiency, we will not know
    for sure if they are efficient or inefficient. Optimizations are pointless if
    we do not measure their impact on a specific algorithm and overall application
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: We might assume that we know what optimizations will result in the best performance
    based on our experience. Although this is experience-based, it is still merely
    anecdotal. Changes in input and the operating environment can challenge our previous
    knowledge of algorithm efficiency, so we should not assume without testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip: Become a testing zealot'
  prefs: []
  type: TYPE_NORMAL
- en: Good programmers focused on high performance are dedicated to the idea that
    algorithm efficiency testing is a core part of the software life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for algorithm efficiency testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It can take time to set up a testing environment, so it is important to plan
    for it and allot sufficient time in your development project for it. Here is an
    overview of a seven-step process of preparing for algorithm efficiency testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify requirements**: In this first step, we need to thoroughly understand
    what the algorithm is intended to do and what **Key Performance Indicators** (**KPIs**)
    you will use in your testing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Establish the test environment**: We rarely test in a production environment,
    so we need to replicate data and conditions in the development environment. The
    goal is to mirror, as closely as possible, the production environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tool selection**: In this step, we select the profiling and benchmarking
    tools we will use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Obtaining test data**: Here, we want to create a replica of live data so
    we can use it for testing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Benchmarking**: In this step, we establish baselines so that we can compare
    our current algorithms to future, optimized versions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Thorough documentation**: It is important to document our testing plans so
    we can replicate them in the future.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Iterative testing**: This final step is essentially a scheduling step. In
    order to support the need for iterative testing, multiple iterations should be
    scheduled.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know how to prepare for testing, let’s look at how to conduct the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are now ready to implement your testing plan. Let’s look at a simple example
    of what this looks like in Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example will be to test a bubble sort algorithm’s execution time. Here
    is our bubble sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a method for testing the execution time of our bubble
    sort algorithm. This is what that would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we created a test array with 30,000 elements and then populated
    it with random numbers. Next, we logged our start time, executed the bubble sort,
    and then logged the end time. With both the start and end times, we know how long
    the algorithm took. This is what the output might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s look at what our post-testing actions should be.
  prefs: []
  type: TYPE_NORMAL
- en: Post-test actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our work does not end after we complete our tests. We need to perform the following
    post-test actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Thoroughly analyze our test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize our algorithms based on our test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document changes to our algorithms and record why we made the changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As appropriate, share your findings and process with stakeholders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When necessary, update our test environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopt a continuous process improvement mindset with constant monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct an after-action reflection and document what you learned about the process
    and how it can be improved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we thoroughly analyze our test results and conduct the other post-test
    actions, we increase the chance of our testing plans being properly executed and
    with valid results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was intended to help you learn how to choose the right algorithm
    for any given requirement and how to measure your results. It covered the concept
    of time complexity and included strategies for reducing time complexity. We also
    emphasized the importance of algorithm testing. You should now have a strong theoretical
    understanding of algorithm efficiencies as well as hands-on experience of creating
    and modifying algorithms. This experience can help ensure you get high performance
    out of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, *Strategic Object Creation and Immutability*, we will introduce
    strategies for object creation with the mindset of improving the overall performance
    of our Java applications. That chapter covers minimizing object creation, object
    immutability, and garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Memory Optimization and I/O Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management is crucial for high-performance Java applications. This part
    focuses on strategic object creation and the use of immutability to optimize memory
    usage. It also covers the effective handling of string objects and the identification
    and prevention of memory leaks. The chapters in this part provide practical insights
    into managing memory efficiently and ensuring robust I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21942_06.xhtml#_idTextAnchor105), *Strategic Object Creation
    and Immutability*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21942_07.xhtml#_idTextAnchor127), *String Objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21942_08.xhtml#_idTextAnchor143), *Memory Leaks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
