- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algorithm Efficiencies
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers focused on ensuring their Java applications perform at a high level
    must consider the efficiency of individual algorithms. We do not judge an algorithm’s
    efficiency by its lines of code; rather, we make this judgment after analyzing
    test results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is intended to help you learn how to choose the right algorithm
    for any given requirement. It also covers the concept of time complexity to include
    strategies for reducing time complexity. We will also focus on lean and efficient
    code. This chapter also emphasizes the importance of algorithm testing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm selection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low time complexity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing algorithms for efficiency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a strong theoretical understanding
    of algorithm efficiencies as well as hands-on experience creating and modifying
    algorithms. This experience can help ensure you get high performance out of your
    Java applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    please refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here: [https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter05).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm selection
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best things about writing software is that there is no single solution
    to a problem. We are free to use a style that’s unique to us and to incorporate
    data structures, libraries, and algorithms as long as we obtain the correct results.
    This is a bit of an overstatement. We can write an algorithm in essentially infinite
    different ways and get the same results.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: This programming flexibility can also be a detriment, as evidenced by low-performant
    algorithms. So, just because we can write algorithms with reckless abandon, it
    does not mean we should. We should be strategic in our algorithm selection and
    creation as it will have a significant impact on the overall efficiency of our
    Java applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at a specific process of selecting algorithms,
    a case study, and evolving trends.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Selection process
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there is no industry-wide official algorithm selection process, here
    is a six-step approach:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Fully understand the requirements. It may seem obvious, but so many developers
    get this wrong. It is critical to fully understand the requirements. This is the
    problem we want an algorithm to solve. Understanding the problem involves learning
    about constraints, datasets, inputs, outputs, and more. Once we have fully understood
    the requirements, we can move on to the next step.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this second step, we should become familiar with the data that our algorithm
    will be associated with. This might include static data, data streams, or even
    generating data. This step is where you fully immerse yourself in anything related
    to the application’s data. In addition to data familiarity, we should start thinking
    about what type of data structures our algorithms should use.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一第二步中，我们应该熟悉我们的算法将要关联的数据。这可能包括静态数据、数据流，甚至生成数据。这一步是你完全沉浸在与应用程序数据相关的一切中的时候。除了数据熟悉之外，我们还应该开始考虑我们的算法应该使用哪种类型的数据结构。
- en: Consider the computational complexity of each potential algorithm. Points for
    consideration here include the time and memory requirements. You can implement
    benchmarking to help inform your decision.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑每个潜在算法的计算复杂度。这里需要考虑的因素包括时间和内存需求。你可以实施基准测试来帮助你做出决定。
- en: In this step, you should identify resource limitations related to processing
    and memory. Knowing these upper boundaries will aid your algorithm decision.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，你应该确定与处理和内存相关的资源限制。了解这些上限将有助于你的算法决策。
- en: This is where you test your algorithms, make refinements, and retest. This is
    an iterative process where you should make small, incremental changes to your
    algorithms to help identify what works best.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你测试你的算法、进行改进并重新测试的地方。这是一个迭代过程，你应该对你的算法进行小的、渐进性的更改，以帮助确定什么是最有效的。
- en: Document your final decision and all factors that led to it. The more detailed
    your document, the better. This will be helpful when revisiting your selection
    later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记录你的最终决定以及导致这一决定的所有因素。你的文档越详细，越好。这将在你稍后回顾你的选择时有所帮助。
- en: Ideally, you should adopt a continual process improvement mindset and not hesitate
    to question previous decisions. Even if you select and refine an algorithm that
    results in the best possible performance, it should be periodically reviewed.
    Environments, data, and other factors can change over time and impact your algorithm’s
    efficiency.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该采取持续的过程改进心态，不要犹豫去质疑之前的决定。即使你选择并改进了一个能够实现最佳性能的算法，它也应该定期进行审查。环境、数据和其他因素可能会随时间变化并影响算法的效率。
- en: Now, let’s see how these steps can be implemented by reviewing a case study
    in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过回顾下一节的案例研究来了解这些步骤如何实施。
- en: Case study
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究
- en: It can be helpful to review case studies to help solidify our understanding
    of how algorithm selection can significantly improve Java application performance.
    This section details the algorithm selection for a business’ e-commerce platform.
    The business noted that its system processed search requests inefficiently, resulting
    in user complaints that the system was sluggish. So, the business hopes to improve
    the search function and, therefore, the overall performance of their application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复习案例研究可以帮助我们巩固对算法选择如何显著提高Java应用程序性能的理解。本节详细介绍了企业电子商务平台的算法选择。该企业指出，其系统处理搜索请求效率低下，导致用户投诉系统运行缓慢。因此，该企业希望改进搜索功能，从而提高其应用程序的整体性能。
- en: The first step in this case is to identify what is causing the problem. For
    our example, the e-commerce platform implemented a linear search algorithm that
    matches user requests with database entries. The search algorithm has not changed
    since the initial system was developed and the database continues to increase
    in size. All search results are slow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中的第一步是确定导致问题的原因。在我们的例子中，电子商务平台实施了一个线性搜索算法，该算法将用户请求与数据库条目相匹配。自初始系统开发以来，搜索算法没有改变，而数据库的规模持续增加。所有搜索结果都缓慢。
- en: Our second step is to understand the data. So, the developer reviews the database
    schema and sampled database records to become familiar with the system’s data
    requirements and use. In the next two steps, the developer reviews the computational
    complexity of the search feature and identifies any resource limitations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二步是理解数据。因此，开发者审查数据库模式并查看样本数据库记录，以便熟悉系统的数据需求和用途。在接下来的两个步骤中，开发者审查搜索功能的计算复杂度，并确定任何资源限制。
- en: The developer is now poised to evaluate alternative algorithms. In this example,
    possible alternatives could include binary searches and other proven search patterns.
    The review of these alternatives leads to the adoption of an inverted index for
    a data structure that can be optimized for full-text searches.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者现在可以评估替代算法。在这个示例中，可能的替代方案可能包括二分搜索和其他经过验证的搜索模式。对这些替代方案的审查导致采用倒排索引作为可以优化全文搜索的数据结构。
- en: Inverted index
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 倒排索引
- en: A data structure commonly used for full-text searches. The indexing identifies
    each unique term and lists where that term appears. Implementation typically includes
    using a dictionary or hashmap.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用于全文搜索的数据结构。索引识别每个独特的术语并列出该术语出现的位置。实现通常包括使用字典或哈希表。
- en: Now the developer can tailor their selection based on their system’s needs.
    Next, they will perform multiple tests and document the results. In this example
    case, the system’s search function is now highly performant. What is left is to
    document the decision and decision factors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的开发者可以根据他们系统的需求来定制他们的选择。接下来，他们将进行多次测试并记录结果。在这个示例案例中，系统的搜索功能现在性能极高。剩下的是记录决策和决策因素。
- en: The example case showed developers that they need to balance application performance
    and resource utilization. Next, let’s look at some evolving trends in algorithm
    selection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 示例案例向开发者表明，他们需要在应用程序性能和资源利用之间取得平衡。接下来，让我们看看一些算法选择的发展趋势。
- en: Evolving trends
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发展趋势
- en: Java software development is a dynamic field, as are the algorithms we create
    and use. There are several trends regarding algorithm efficiencies, and five of
    them are described in this section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Java软件开发是一个动态的领域，我们创建和使用的算法也是如此。关于算法效率有几个趋势，本节描述了其中五个。
- en: '**AI and ML**: Many people in the tech space have coined 2023 as the year of
    **Artificial Intelligence** (**AI**). AI and **Machine Learning** (**ML**) are
    not new, but their widespread use and adoption have never been more prevalent,
    thanks to OpenAI’s launch in 2015 and the introduction of **Generative Pre-trained
    Transformers** (**GPTs**), such as ChatGPT. The industry is experiencing a shift
    towards AI-related algorithms.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人工智能和机器学习**：科技领域的许多人将2023年称为**人工智能**（**AI**）之年。人工智能和**机器学习**（**ML**）并不新鲜，但它们的广泛应用和采用从未如此普遍，这得益于OpenAI在2015年的推出以及**生成式预训练转换器**（**GPTs**），如ChatGPT的引入。行业正在经历向与AI相关的算法的转变。'
- en: You can learn more about leveraging AI for high-performance Java applications
    in [*Chapter 18*](B21942_18.xhtml#_idTextAnchor345).
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[*第18章*](B21942_18.xhtml#_idTextAnchor345)中了解更多关于利用AI进行高性能Java应用的信息。
- en: '**Concurrency**: With the proliferation of multi-core processors, the need
    to focus algorithms on parallel processing has increased. Fortunately, Java has
    robust support for concurrency.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：随着多核处理器的普及，算法需要专注于并行处理的需求增加。幸运的是，Java对并发提供了强大的支持。'
- en: You can learn more about concurrency strategies in [*Chapter 9*](B21942_09.xhtml#_idTextAnchor159).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[*第9章*](B21942_09.xhtml#_idTextAnchor159)中了解更多关于并发策略的信息。
- en: '**Cloud optimizations**: As more applications are being hosted in the cloud,
    the need for updating our Java applications for cloud optimization increases.
    Cloud computing requires us to consider concepts such as scalability and distributed
    processing. These considerations are important for new Java applications that
    are being developed for the cloud as well as existing applications that we want
    to migrate to the cloud.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云优化**：随着越来越多的应用程序托管在云上，我们需要更新Java应用程序以进行云优化的需求增加。云计算要求我们考虑可扩展性和分布式处理等概念。这些考虑对于正在为云开发的新Java应用程序以及我们希望迁移到云上的现有应用程序都至关重要。'
- en: '**Security**: One thing in software development that seems to remain the same
    is the ever-increasing number of cyber threats to our systems and data. Security
    is a mindset, not a step in software development. The trend here is the increased
    emphasis on security throughout the product life cycle.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：在软件开发中，似乎一直保持不变的是我们系统和数据所面临的网络威胁数量不断增加。安全是一种心态，而不是软件开发中的一个步骤。这里的趋势是在整个产品生命周期中对安全的重视程度不断提高。'
- en: '**Community**: There is impressive growth in the area of crowdsourced algorithm
    design and other open source contributions. The systems and algorithms that result
    are increasingly robust and diverse.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区**：在众包算法设计和其他开源贡献领域取得了令人印象深刻的增长。由此产生的系统和算法越来越稳健和多样化。'
- en: Now that we have reviewed algorithm selection, shared a case study, and discussed
    evolving algorithm trends, we can look at low time complexity as it relates to
    algorithm efficiencies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了算法选择，分享了一个案例研究，并讨论了算法趋势的发展，我们可以看看低时间复杂度与算法效率的关系。
- en: Low time complexity
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低时间复杂度
- en: Time complexity refers to the measure of the time efficiency of any given algorithm.
    We want to determine the execution time of our Java applications and ensure our
    algorithms do not add time complexity to our applications. The overall goal is
    to reduce algorithm execution time. We should test our algorithms using a variety
    of possible inputs and environments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度是指任何给定算法的时间效率的度量。我们希望确定Java应用程序的执行时间，并确保我们的算法不会给应用程序增加时间复杂度。总体目标是减少算法执行时间。我们应该使用各种可能的输入和环境来测试我们的算法。
- en: In this section, we will look at specific strategies to help you reduce the
    time complexity of your algorithms. We will also address the common pitfalls associated
    with time complexity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨具体的策略，以帮助您降低算法的时间复杂度。我们还将讨论与时间复杂度相关的一些常见陷阱。
- en: Strategies for reducing time complexity
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低时间复杂度的策略
- en: There are several strategies we can adopt to help us reduce the time complexity
    of our algorithms. Perhaps the easiest strategy is to simply ensure our algorithms
    are not overly complicated. This strategy requires us to double-check our algorithmic
    logic and use the optimization techniques covered throughout this book. Reducing
    unnecessary calculations within a loop, especially with recursion, is a great
    optimization strategy.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用几种策略来帮助我们降低算法的时间复杂度。可能最简单的策略就是确保我们的算法不过于复杂。这需要我们仔细检查我们的算法逻辑，并使用本书中涵盖的优化技术。减少循环中的不必要的计算，尤其是在递归中，是一种很好的优化策略。
- en: Sometimes our algorithms might seem to be overly complex and we cannot find
    a way to simplify them. In those cases, it is worth considering breaking the algorithm
    into multiple algorithms, each executing a subset of the original set of instructions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们的算法可能看起来过于复杂，我们找不到简化它们的方法。在这些情况下，考虑将算法分解成多个算法，每个算法执行原始指令集的一个子集，是值得考虑的。
- en: Common pitfalls
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: 'When reviewing the common pitfalls related to algorithm time efficiency, we
    can refer to previous chapters and look at others yet to come. As you can see
    from the list of the top four common pitfalls listed here, details can be found
    in several chapters of this book:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当审查与算法时间效率相关的常见陷阱时，我们可以参考前面的章节，并查看即将到来的其他章节。正如您从这里列出的前四个常见陷阱的列表中可以看到，详细信息可以在本书的几个章节中找到：
- en: Improper use of data structures ([*Chapter 2*](B21942_02.xhtml#_idTextAnchor028))
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构使用不当([*第2章*](B21942_02.xhtml#_idTextAnchor028))
- en: Overuse of non-standard libraries ([*Chapter 13*](B21942_13.xhtml#_idTextAnchor227))
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过度使用非标准库([*第13章*](B21942_13.xhtml#_idTextAnchor227))
- en: Inadequate testing and profiling ([*Chapter 14*](B21942_14.xhtml#_idTextAnchor250))
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和性能分析不足([*第14章*](B21942_14.xhtml#_idTextAnchor250))
- en: Lack of focus on readability and maintainability ([*Chapter 16*](B21942_16.xhtml#_idTextAnchor307))
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽视可读性和可维护性([*第16章*](B21942_16.xhtml#_idTextAnchor307))
- en: In addition, we might simply be overlooking the big picture of our application’s
    overall performance. Sometimes, we can get stuck in the minutiae of our code at
    the expense of overall algorithm or application efficiency.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能只是忽略了应用程序整体性能的大局。有时，我们可能会陷入代码的细节中，以牺牲整体算法或应用程序效率为代价。
- en: As we have seen, low-time complexity is both a concept and a goal. It is an
    essential consideration when our ultimate aim is to increase the performance of
    our Java applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，低时间复杂度既是一个概念也是一个目标。当我们的最终目标是提高Java应用程序的性能时，这是一个重要的考虑因素。
- en: Testing algorithms for efficiency
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试算法的效率
- en: At this point, it is clear that we need our algorithms to be efficient. This
    section focuses on how we can measure algorithm efficiency based on our requirements.
    We will start with a short section on the importance of testing, then how to prepare
    for testing, how to conduct the tests, and what to do after testing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很明显我们需要我们的算法是高效的。本节重点介绍如何根据我们的需求衡量算法效率。我们将从一个关于测试重要性的简短部分开始，然后介绍如何准备测试，如何进行测试，以及测试之后应该做什么。
- en: Importance of testing
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Simply put, if we do not test our algorithms for efficiency, we will not know
    for sure if they are efficient or inefficient. Optimizations are pointless if
    we do not measure their impact on a specific algorithm and overall application
    performance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果我们不对我们的算法进行效率测试，我们就无法确定它们是高效的还是低效的。如果我们不衡量它们对特定算法和整体应用性能的影响，优化就毫无意义。
- en: We might assume that we know what optimizations will result in the best performance
    based on our experience. Although this is experience-based, it is still merely
    anecdotal. Changes in input and the operating environment can challenge our previous
    knowledge of algorithm efficiency, so we should not assume without testing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会根据我们的经验假设我们知道哪些优化将带来最佳性能。尽管这是基于经验的，但它仍然只是轶事。输入和操作环境的变化可能会挑战我们对算法效率的先前知识，因此我们不应该未经测试就假设。
- en: 'Tip: Become a testing zealot'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：成为一个测试狂热者
- en: Good programmers focused on high performance are dedicated to the idea that
    algorithm efficiency testing is a core part of the software life cycle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关注高性能的优秀程序员致力于这样一个观点：算法效率测试是软件生命周期的一个核心部分。
- en: Preparing for algorithm efficiency testing
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备算法效率测试
- en: 'It can take time to set up a testing environment, so it is important to plan
    for it and allot sufficient time in your development project for it. Here is an
    overview of a seven-step process of preparing for algorithm efficiency testing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 设置测试环境可能需要时间，因此为它制定计划并分配足够的时间在你的开发项目中是很重要的。以下是准备算法效率测试的七个步骤概述：
- en: '**Identify requirements**: In this first step, we need to thoroughly understand
    what the algorithm is intended to do and what **Key Performance Indicators** (**KPIs**)
    you will use in your testing.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**识别需求**：在这个第一步，我们需要彻底理解算法旨在做什么，以及你将在测试中使用的**关键性能指标**（**KPIs**）。'
- en: '**Establish the test environment**: We rarely test in a production environment,
    so we need to replicate data and conditions in the development environment. The
    goal is to mirror, as closely as possible, the production environment.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**建立测试环境**：我们很少在生产环境中进行测试，因此我们需要在开发环境中复制数据和条件。目标是尽可能接近地反映生产环境。'
- en: '**Tool selection**: In this step, we select the profiling and benchmarking
    tools we will use.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具选择**：在这个步骤中，我们选择我们将使用的分析和基准测试工具。'
- en: '**Obtaining test data**: Here, we want to create a replica of live data so
    we can use it for testing.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**获取测试数据**：在这里，我们想要创建一个实时数据的副本，以便我们可以用它进行测试。'
- en: '**Benchmarking**: In this step, we establish baselines so that we can compare
    our current algorithms to future, optimized versions.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基准测试**：在这个步骤中，我们建立基线，以便我们可以将我们当前的算法与未来的优化版本进行比较。'
- en: '**Thorough documentation**: It is important to document our testing plans so
    we can replicate them in the future.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详尽的文档**：记录我们的测试计划是很重要的，这样我们就可以在未来复制它们。'
- en: '**Iterative testing**: This final step is essentially a scheduling step. In
    order to support the need for iterative testing, multiple iterations should be
    scheduled.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**迭代测试**：这一最后步骤本质上是一个调度步骤。为了支持迭代测试的需求，应该安排多次迭代。'
- en: Now that you know how to prepare for testing, let’s look at how to conduct the
    tests.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何准备测试，让我们看看如何进行测试。
- en: Conducting the tests
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行测试
- en: You are now ready to implement your testing plan. Let’s look at a simple example
    of what this looks like in Java code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以实施你的测试计划了。让我们看看一个简单的Java代码示例。
- en: 'Our example will be to test a bubble sort algorithm’s execution time. Here
    is our bubble sort algorithm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子将是测试冒泡排序算法的执行时间。以下是我们的冒泡排序算法：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we need to create a method for testing the execution time of our bubble
    sort algorithm. This is what that would look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个测试我们的冒泡排序算法执行时间的方法。这将是这样的：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we created a test array with 30,000 elements and then populated
    it with random numbers. Next, we logged our start time, executed the bubble sort,
    and then logged the end time. With both the start and end times, we know how long
    the algorithm took. This is what the output might look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们创建了一个包含30,000个元素的测试数组，并用随机数填充它。接下来，我们记录了开始时间，执行了冒泡排序，然后记录了结束时间。有了开始和结束时间，我们就知道算法花费了多长时间。输出可能看起来是这样的：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, let’s look at what our post-testing actions should be.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的测试后操作应该是什么。
- en: Post-test actions
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试后操作
- en: 'Our work does not end after we complete our tests. We need to perform the following
    post-test actions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试完成后，我们的工作并未结束。我们需要执行以下测试后行动：
- en: Thoroughly analyze our test results
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入分析我们的测试结果
- en: Optimize our algorithms based on our test results
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据我们的测试结果优化我们的算法
- en: Document changes to our algorithms and record why we made the changes
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录算法的更改并记录我们做出更改的原因
- en: As appropriate, share your findings and process with stakeholders
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据适当情况，与利益相关者分享您的发现和流程
- en: When necessary, update our test environments
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要时，更新我们的测试环境
- en: Adopt a continuous process improvement mindset with constant monitoring
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用持续过程改进的心态，并持续监控
- en: Conduct an after-action reflection and document what you learned about the process
    and how it can be improved
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行事后反思，并记录关于流程及其改进方法的学习内容
- en: When we thoroughly analyze our test results and conduct the other post-test
    actions, we increase the chance of our testing plans being properly executed and
    with valid results.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们彻底分析我们的测试结果并执行其他测试后行动时，我们增加了测试计划得到适当执行并产生有效结果的机会。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was intended to help you learn how to choose the right algorithm
    for any given requirement and how to measure your results. It covered the concept
    of time complexity and included strategies for reducing time complexity. We also
    emphasized the importance of algorithm testing. You should now have a strong theoretical
    understanding of algorithm efficiencies as well as hands-on experience of creating
    and modifying algorithms. This experience can help ensure you get high performance
    out of your Java applications.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助您学习如何为任何特定需求选择正确的算法，以及如何衡量您的结果。它涵盖了时间复杂度的概念，并包括了降低时间复杂度的策略。我们还强调了算法测试的重要性。您现在应该对算法效率有很强的理论理解，并且有创建和修改算法的实践经验。这种经验可以帮助确保您从Java应用程序中获得高性能。
- en: In the next chapter, *Strategic Object Creation and Immutability*, we will introduce
    strategies for object creation with the mindset of improving the overall performance
    of our Java applications. That chapter covers minimizing object creation, object
    immutability, and garbage collection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，*战略对象创建和不可变性*中，我们将介绍以提升我们Java应用程序整体性能为目标的对象创建策略。该章节涵盖了最小化对象创建、对象不可变性和垃圾回收。
- en: 'Part 2: Memory Optimization and I/O Operations'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：内存优化和I/O操作
- en: Memory management is crucial for high-performance Java applications. This part
    focuses on strategic object creation and the use of immutability to optimize memory
    usage. It also covers the effective handling of string objects and the identification
    and prevention of memory leaks. The chapters in this part provide practical insights
    into managing memory efficiently and ensuring robust I/O operations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理对于高性能Java应用程序至关重要。本部分重点介绍战略对象创建和利用不可变性来优化内存使用。它还涵盖了有效处理字符串对象以及识别和预防内存泄漏。本部分中的章节提供了关于高效管理内存和确保稳健I/O操作的实用见解。
- en: 'This part has the following chapters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B21942_06.xhtml#_idTextAnchor105), *Strategic Object Creation
    and Immutability*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21942_06.xhtml#_idTextAnchor105)，*战略对象创建和不可变性*'
- en: '[*Chapter 7*](B21942_07.xhtml#_idTextAnchor127), *String Objects*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21942_07.xhtml#_idTextAnchor127)，*字符串对象*'
- en: '[*Chapter 8*](B21942_08.xhtml#_idTextAnchor143), *Memory Leaks*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B21942_08.xhtml#_idTextAnchor143)，*内存泄漏*'
