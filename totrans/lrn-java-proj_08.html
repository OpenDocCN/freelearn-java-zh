<html><head></head><body>
		<div id="_idContainer133">
			<h1 id="_idParaDest-168" class="chapter-number"><a id="_idTextAnchor168"/>8</h1>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor169"/>Classes, Objects, and Enums</h1>
			<p>In <a href="B19793_07.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we learned about methods in Java. After understanding why methods are useful, we learned that there are two parts to methods – the method definition and the method call. We saw that the method definition is the code that’s executed when the method is invoked via the method call. We discussed how method signatures enable method overloading. We also learned how <strong class="source-inline">varargs</strong> helps us call a method with zero or more arguments. Finally, we discussed Java’s call by value mechanism, where arguments that are passed to a method are copied in memory. Depending on the type of argument passed, primitive or reference, will have implications as to the effect of the changes made in the called method to those arguments passed from the <span class="No-Break">caller method.</span></p>
			<p><a href="B19793_07.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> concluded the Java fundamentals section of this book. The topics in that section are common across many programming languages, including non-<strong class="bold">object-oriented programming </strong>(<strong class="bold">OOP</strong>) languages such as C. <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> starts the OOP section of <span class="No-Break">this book.</span></p>
			<p>In this chapter, we will cover classes, objects, records and enums. Classes and objects are unique to OOP languages (such as Java); in other words, non-OOP languages (such as C) do not support them. Though closely related, understanding the difference between a class and an object is important. We will discuss the relationship between the class and objects of the class. To access an object, we must use a reference. Separating the reference from the object will prove very useful going forward. Instance versus class members will be discussed, as well as when to use either/both. This chapter will also explain the <strong class="source-inline">'this'</strong> reference and how it relates to the object responsible for the instance method <span class="No-Break">currently executing.</span></p>
			<p>We will also explain the access modifiers in Java. These access modifiers enable one of the key cornerstones in OOP, namely encapsulation. Though basic encapsulation can be easily achieved, properly encapsulating your class requires extra care. This will be covered in the Advanced <span class="No-Break">encapsulation section.</span></p>
			<p>Understanding the object life cycle, with regard to what is happening in memory as your program executes, is crucial to avoiding many subtle errors. This topic will be explained with the aid <span class="No-Break">of diagrams.</span></p>
			<p>Toward the end of the chapter, given our understanding (and separation!) of references from the objects they refer to, we will discuss the <strong class="source-inline">instanceof</strong> keyword. Lastly, we will cover a variation of classes, namely <strong class="source-inline">enums</strong>, whereby the number of object instances <span class="No-Break">is restricted.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Understanding the differences between classes <span class="No-Break">and objects</span></li>
				<li>Contrasting instance with <span class="No-Break">class members</span></li>
				<li>Exploring the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">this'</strong></span><span class="No-Break"> reference</span></li>
				<li>Applying <span class="No-Break">access modifiers</span></li>
				<li><span class="No-Break">Achieving encapsulation</span></li>
				<li>Mastering <span class="No-Break">advanced encapsulation</span></li>
				<li>Delving into the object <span class="No-Break">life cycle</span></li>
				<li>Explaining the <span class="No-Break"><strong class="source-inline">instanceof</strong></span><span class="No-Break"> keyword</span></li>
				<li><span class="No-Break">Understanding enums</span></li>
				<li><span class="No-Break">Appreciating records</span></li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor170"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8"><span class="No-Break">https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor171"/>Understanding the differences between classes and objects</h1>
			<p>As classes and objects are integral to OOP, it is vital to understand their differences. We will discuss the relationship between a class and its objects in this section. As creating objects requires the use of the <strong class="source-inline">new</strong> keyword, this will also be covered. Understanding constructors and what they do will also be examined. All of these topics are linked: objects are the in-memory representation of the class (template); to create an object, a constructor is used and to call the constructor, we use the <strong class="source-inline">new</strong> keyword. Let’s examine these <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor172"/>Classes</h2>
			<p>A class is so integral in Java that you cannot write any program without defining one! A class is a blueprint or <a id="_idIndexMarker481"/>template for your object. It is similar to a plan of a house – using a house plan, you can discuss the house all you want; however, you cannot go into the kitchen and make a cup of tea/coffee. The house plan is abstract in that regard and so is the class. The class defines fields (properties) and methods which operate on those fields. The fields are your data and the methods enable manipulation of <span class="No-Break">that data.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor173"/>Objects</h2>
			<p>An object is your in-memory <a id="_idIndexMarker482"/>representation of your class. If the class is your house plan, then the object is your built house. Now, you can go into the kitchen and make that cup of tea/coffee. As with houses and house plans, you can create many objects based <a id="_idIndexMarker483"/>on the class. These objects are known as object <em class="italic">instances</em>, emphasizing that each object is its own <span class="No-Break">unique instance.</span></p>
			<p>In summary, the class is the template and the object is the in-memory representation of the class. You need an object (instance) if you want to execute its (instance) methods. So, how do we create an object? We use the <span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break"> keyword.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor174"/>Getting familiar with the new keyword</h2>
			<p>The <strong class="source-inline">new</strong> keyword in Java enables <a id="_idIndexMarker484"/>us to create objects. The object is created on the heap, a special area of memory reserved for objects. A reference (similar to a pointer) to the object is returned. This reference enables us to manipulate the object; for example, to execute the instance methods. Let’s examine the code example shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B19793_08_1.jpg" alt="Figure 8.1 – Creating an object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Creating an object</p>
			<p>In the preceding figure, line 3 defines a <strong class="source-inline">Person</strong> class. It contains nothing at the moment; we will expand it as we progress. Line 6 is important – we are creating a <strong class="source-inline">Person</strong> object using the <strong class="source-inline">new</strong> keyword. Apart from the <strong class="source-inline">new</strong> keyword, line 6 is very similar to any method call. The <strong class="source-inline">p</strong> reference (on the stack) is initialized to refer to an object of type <strong class="source-inline">Person</strong> (on the heap). <strong class="bold">It is very important to separate the reference from the object</strong>. For example, as we shall see when we discuss Inheritance (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>), a reference of type X does not have to refer to an object of type X; the reference can refer to an object of type <em class="italic">Y</em>, once <em class="italic">Y</em> is related to <em class="italic">X</em>. On line 6, the <strong class="source-inline">Person</strong> reference named <strong class="source-inline">p</strong> is referring to a <strong class="source-inline">Person</strong> object; however, going <a id="_idIndexMarker485"/>forward, that will rarely be the case. When “constructing” objects using the <strong class="source-inline">new</strong> keyword, the method that’s invoked is a special method known called <span class="No-Break">a </span><span class="No-Break"><em class="italic">constructor</em></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Constructors</p>
			<p class="callout">A constructor is a special <a id="_idIndexMarker486"/>method that’s invoked by the <strong class="source-inline">new</strong> keyword. It has two distinct properties that differentiate it from other methods: it has the same name as the class and defines no return type, not even <strong class="source-inline">void</strong>. (Java returns the reference to the object in <span class="No-Break">the background).</span></p>
			<p class="callout">Every class contains a constructor, even if you do not code one yourself. If you do not code a constructor for your class, Java will synthesize (or define) a “default constructor” for you. The default constructor will have the same properties as regular constructors; namely, the same name as the class and no return type. However, the default constructor will not define any parameters; it will have the same access modifier as the class and will contain only one line of code, which is <strong class="source-inline">super();</strong>. We will discuss access modifiers later in this chapter and <strong class="source-inline">super()</strong> in <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p class="callout">Note that if you insert even one constructor, the default constructor is not synthesized. It’s as if the compiler says, “Okay, you have a constructor(s), you know what you are doing, so I won’t <span class="No-Break">get involved.”</span></p>
			<p>Now that we know when default constructors are synthesized by the compiler, we <a id="_idIndexMarker487"/>can see that default constructors are required for both <strong class="source-inline">Person</strong> and <strong class="source-inline">PersonExample</strong> in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em>. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.2</em> represents the code <em class="italic">after </em>the compiler has inserted the <span class="No-Break">default constructors:</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B19793_08_2.jpg" alt="Figure 8.2 – Default constructors inserted"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Default constructors inserted</p>
			<p>The red rectangles in the preceding figure represent the default constructors inserted by the compiler. This happened to both classes because neither class defined any constructor at all and every class requires a constructor. The default constructors, in addition to having the same name as the class and not returning anything (not even <strong class="source-inline">void</strong>), define no parameters (lines 4 and 9) and simply call <strong class="source-inline">super();</strong>. As stated in the previous callout, <strong class="source-inline">super()</strong> will be discussed when we discuss Inheritance in <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p>We will discuss access modifiers in detail later but note that the access for the default constructors match the access for their respective classes. For example, <strong class="source-inline">PersonExample</strong> is a <strong class="source-inline">public</strong> class and so is its constructor (lines 8 and 9 respectively). The <strong class="source-inline">Person</strong> class mentions no <em class="italic">explicit</em> access modifier at all and neither does its constructor (lines 3 and <span class="No-Break">4 respectively).</span></p>
			<p>Now, you can see why <strong class="source-inline">new Person();</strong> on line 13 does not generate a compiler error. To be clear, there is no compiler error on line 13 because the compiler inserted the default constructor for the <strong class="source-inline">Person</strong> class (lines 4 to 6) and thus <strong class="source-inline">new Person()</strong> was able to locate the constructor and <span class="No-Break">therefore compile.</span></p>
			<p>The default <a id="_idIndexMarker488"/>constructor for <strong class="source-inline">PersonExample</strong> (lines 9 to 11) has no material effect in this program. The JVM starts every program in the <strong class="source-inline">main</strong> method. </p>
			<p>We will now move on to discuss instance members versus class members. Note that local variables (in a method) <span class="No-Break">are neither.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor175"/>Contrasting instance with class members</h1>
			<p>An object can be more correctly termed an object <em class="italic">instance</em>. This is where <em class="italic">instance</em> members (methods/data) get their names: every object gets a copy of an instance member. Class members, however, are <a id="_idIndexMarker489"/>different in that there is only one copy per class, regardless of the number of object instances created. We’ll discuss both of these <span class="No-Break">topics now.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor176"/>Instance members (methods/data)</h2>
			<p>This is<a id="_idIndexMarker490"/> more easily explained by presenting a code example first. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> presents a class with <span class="No-Break">instance members:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B19793_08_3.jpg" alt="Figure 8.3 – A class with instance members"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – A class with instance members</p>
			<p>When you create an object using <strong class="source-inline">new</strong>, you are creating an object <em class="italic">instance</em>. Each instance gets a copy <a id="_idIndexMarker491"/>of the instance members (variables and methods). Regarding instance variables, we need to define where instance variables are declared and their resultant scope. An instance variable is defined within the class but outside every method coded in the class. Thus, the scope of an instance variable is the class itself; meaning, every instance method in the class can access the <span class="No-Break">instance variables.</span></p>
			<p>Now let us <a id="_idIndexMarker492"/>discuss the code example. In the preceding figure, the <strong class="source-inline">Person</strong> class defines both instance variables and instance methods. As the instance variables are declared outside every method, they have the scope of the class. The fact that the instance variables are marked <strong class="source-inline">private</strong> and the instance methods are marked <strong class="source-inline">public</strong> will be explained later in this chapter. <a id="_idIndexMarker493"/>The constructor is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Person(String aName) { // constructor    name = aName;
    count++;
}</pre>
			<p>This constructor enables us to pass in a <strong class="source-inline">String</strong> and initialize the instance variable based on that <strong class="source-inline">String</strong>. For example, when we instantiate an object <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Person p1 = new Person("Maaike");</pre>			<p>we are passing <strong class="source-inline">"Maaike"</strong> into the constructor, so the <strong class="source-inline">name</strong> instance variable in the object referred to by <strong class="source-inline">p1</strong> refers to <strong class="source-inline">"Maaike"</strong>. The constructor is also keeping a count of the number of objects that are created by incrementing <strong class="source-inline">count</strong> each time the constructor is invoked. Note that no default <strong class="source-inline">Person</strong> constructor was inserted by the compiler in this example as a constructor was already coded in <span class="No-Break">the class.</span></p>
			<p>We also invoke the <strong class="source-inline">getName()</strong> instance method using the <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong> references <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
System.out.println(p1.getName()); // MaaikeSystem.out.println(p2.getName()); // Sean</pre>
			<p>This syntax of <strong class="source-inline">refName.instanceMethod()</strong> is known as <em class="italic">dot notation</em>. As per the comments in the code, <strong class="source-inline">"Maaike"</strong> and <strong class="source-inline">"Sean"</strong> are output to the screen (in that order). <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em> shows the in-memory representation of the code after we have created both objects, referenced by <strong class="source-inline">p1</strong> and <span class="No-Break"><strong class="source-inline">p2</strong></span><span class="No-Break"> respectively:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B19793_08_4.jpg" alt="Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)</p>
			<p>As the <a id="_idIndexMarker494"/>preceding figure shows, we have two references on the stack, namely <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong>. <strong class="source-inline">p1</strong> refers to the first <strong class="source-inline">Person</strong> object on the heap – that is, the object that was created on line 23. The instance variable values of <strong class="source-inline">p1</strong> (its “state”) are <strong class="source-inline">"Maaike"</strong> and <strong class="source-inline">1</strong> for <strong class="source-inline">name</strong> and <strong class="source-inline">count</strong>, respectively. As <a id="_idIndexMarker495"/>strings are objects, <strong class="source-inline">name</strong> is a reference to another object, a <strong class="source-inline">String</strong> object, which has a value of <strong class="source-inline">"Maaike"</strong>. Similarly, the <strong class="source-inline">p2</strong> reference refers to the object that was created on line 24. As can be seen from the diagram, the instance variable values of <strong class="source-inline">p2</strong> are <strong class="source-inline">"Sean"</strong> and <strong class="source-inline">1</strong> for <strong class="source-inline">name</strong> and <span class="No-Break"><strong class="source-inline">count</strong></span><span class="No-Break">, respectively.</span></p>
			<p>Note that each <strong class="source-inline">Person</strong> object <em class="italic">instance</em> on the heap has a copy of the <em class="italic">instance</em> variables. That is why they are called <span class="No-Break">instance variables.</span></p>
			<p>Lines 27 and 28 change the values of the <strong class="source-inline">name</strong> instance variables to <strong class="source-inline">"Maaike van Putten"</strong> and <strong class="source-inline">"Sean Kennedy"</strong> for <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong>, respectively. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em> shows <span class="No-Break">these changes:</span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B19793_08_5.jpg" alt="Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)</p>
			<p>This figure shows that <a id="_idIndexMarker496"/>the two <strong class="source-inline">String</strong> objects have been changed: <strong class="source-inline">p1</strong>’s instance variable <strong class="source-inline">name</strong> refers to <strong class="source-inline">"Maaike van Putten"</strong> and <strong class="source-inline">p2</strong>’s instance variable <strong class="source-inline">name</strong> refers to <strong class="source-inline">"Sean Kennedy"</strong>. Consequently, lines 29 to 30 output <strong class="source-inline">"Maaike van Putten"</strong> and <strong class="source-inline">"Sean </strong><span class="No-Break"><strong class="source-inline">Kennedy"</strong></span><span class="No-Break">, respectively.</span></p>
			<p class="callout-heading">String immutability</p>
			<p class="callout">Strings are immutable objects. This means that <strong class="source-inline">String</strong> objects, once created, cannot be changed. Ever. It may <a id="_idIndexMarker497"/>look like they have changed, as in the effect is created of a change, but a completely new object has been created and the original is left untouched. We will revisit <strong class="source-inline">String</strong> immutability in greater detail in <a href="B19793_12.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic">Chapter 12</em></span></a><span class="No-Break">.</span></p>
			<p class="callout">So, the original <strong class="source-inline">String</strong> objects, <strong class="source-inline">"Sean"</strong> and <strong class="source-inline">"Maaike"</strong>, are still on the heap taking up space. They are of no use because, as we have no references to them, we have no way to get to them. Remember, the <strong class="source-inline">name</strong> instance variables for both <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong> refer to the newly created <strong class="source-inline">String</strong> objects containing <strong class="source-inline">"Maaike van Putten"</strong> and <strong class="source-inline">"Sean </strong><span class="No-Break"><strong class="source-inline">Kennedy"</strong></span><span class="No-Break">, respectively.</span></p>
			<p class="callout">So, what happens to these no-longer-used objects? They are “garbage collected.” We will discuss this soon but for now, just know that the JVM runs a process called a garbage collector in the background to tidy up (reclaim) all the objects that can no longer be reached. We have no control over when this process runs but the fact that there is a garbage collector saves us from having to tidy up after ourselves (whereas in other OOP languages such as C++, you <span class="No-Break">have to!).</span></p>
			<p>The code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> has an issue – <strong class="source-inline">count</strong> is 1 and it should be 2. Instance variables that are integers are <a id="_idIndexMarker498"/>initialized to <strong class="source-inline">0</strong> by default. In each of the constructor calls, we increment <strong class="source-inline">count</strong> from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. We would like the first constructor call to increment <strong class="source-inline">count</strong> from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> and the second constructor call to increment <strong class="source-inline">count</strong> from <strong class="source-inline">1</strong> to <strong class="source-inline">2</strong>. This is where class members <span class="No-Break">come in.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/>Class members (methods/data)</h2>
			<p>To mark a field and/or method as a class member, as opposed to an instance member, you can <a id="_idIndexMarker499"/>insert the <strong class="source-inline">static</strong> keyword into the declaration of the member. Class members are shared by all instances of the class. This means that you do not have to create an object instance to access the <strong class="source-inline">static</strong> members of <span class="No-Break">the class.</span></p>
			<p>The syntax for accessing a <strong class="source-inline">static</strong> member is different from accessing an instance member. Rather than use the reference, the class name is used, as in <strong class="source-inline">className.staticMember</strong>. This emphasizes the class nature of the member being accessed. For example, the JVM starts the program in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> with <strong class="source-inline">PersonExample.main()</strong>. This is how the JVM starts every program as it saves on constructing an object and its resulting <span class="No-Break">memory footprint.</span></p>
			<p>Let’s get back to our problem with <strong class="source-inline">count</strong> (which is 1 instead of 2). <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em> represents the changes that must be made to fix <span class="No-Break">this issue:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B19793_08_6.jpg" alt="Figure 8.6 – Making “count” static"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Making “count” static</p>
			<p>Contrasting the code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em> with the code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>, we can see that <strong class="source-inline">count</strong> is declared <strong class="source-inline">static</strong> (line 5). Thus, there is only one copy of <em class="italic">count</em>, which is shared across all instances of <strong class="source-inline">Person</strong>. Thus, <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong> are looking at the <span class="No-Break">same </span><span class="No-Break"><em class="italic">count</em></span><span class="No-Break">.</span></p>
			<p>In the constructor (line 9), while not necessary, we use the correct syntax to emphasize the <strong class="source-inline">static</strong> nature of <strong class="source-inline">count</strong>. Similarly, as <strong class="source-inline">getCount</strong> (line 17) is simply returning a <strong class="source-inline">static</strong> member, we <a id="_idIndexMarker500"/>marked it as <strong class="source-inline">static</strong>. In addition, we used the <strong class="source-inline">Person.count</strong> static syntax (line 18). Lastly, line 25 accesses the <strong class="source-inline">static</strong> method using the correct syntax, <strong class="source-inline">Person.getCount</strong>, to retrieve the <strong class="source-inline">private</strong> class variable, <strong class="source-inline">count</strong>. We can see that it outputs <strong class="source-inline">2</strong>, which is correct. Comparing the other differences in code, some of the extra code in <strong class="source-inline">main</strong> (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em>) has been removed to help us focus on what we are <span class="No-Break">discussing here.</span></p>
			<p class="callout-heading">Instance to static but not vice versa</p>
			<p class="callout">If you are in an instance method, you can access a <strong class="source-inline">static</strong> member but not vice versa. We will discuss the <a id="_idIndexMarker501"/>reason why when we explain the <strong class="source-inline">this</strong> reference. This means that, in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em>, you could use the <strong class="source-inline">p1</strong> reference to access the <strong class="source-inline">getCount</strong> method (line 25). As such, <strong class="source-inline">p1.getCount()</strong> is valid but this is a <em class="italic">poor</em> programming practice as it conveys the impression that <strong class="source-inline">getCount</strong> is an instance method when it is a <strong class="source-inline">static</strong> method - use <strong class="source-inline">Person.getCount()</strong> as per <span class="No-Break">the code.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.7</em> shows the in-memory representation of the code in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B19793_08_7.jpg" alt="Figure 8.7 – In-memory representation of the code in Figure 8.6"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – In-memory representation of the code in Figure 8.6</p>
			<p>As can be seen in the <a id="_idIndexMarker502"/>bottom-right corner of the preceding figure, the <strong class="source-inline">static</strong>/<strong class="source-inline">class</strong> members of the <strong class="source-inline">Person</strong> class are stored separately from the instances themselves. There is now only one copy of <strong class="source-inline">count</strong> and it is shared between <strong class="source-inline">p1</strong> and <strong class="source-inline">p2</strong>. Thus, the <strong class="source-inline">count</strong> value of <strong class="source-inline">2</strong> <span class="No-Break">is correct.</span></p>
			<p class="callout-heading">Default values for class and instance variables</p>
			<p class="callout">Instance variables are initialized <a id="_idIndexMarker503"/>to default values every time a class <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">’ed.</span></p>
			<p class="callout">Class variables are initialized <a id="_idIndexMarker504"/>to default values the very first time a class is loaded. This could occur when using <strong class="source-inline">new</strong> or when referring to a class member (using the <span class="No-Break">class syntax).</span></p>
			<p>The default values for class and instance variables are <span class="No-Break">as follows:</span></p>
			<table id="table001-1" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">Default value</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">byte, short, </strong><span class="No-Break">and</span><span class="No-Break"><strong class="source-inline"> int</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">0</strong></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0L</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0.0f</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">0.0d</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">char</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>‘<strong class="source-inline">\u0000</strong>’ (<span class="No-Break">Unicode zero)</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="source-inline">String </strong>(or any reference to <span class="No-Break">an object)</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">boolean</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – Default values for class and instance variables</p>
			<p>In a previous <a id="_idIndexMarker505"/>callout, we highlighted that you can access class members from an instance method but not vice versa. Let’s delve into <span class="No-Break">that now.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor178"/>Exploring the “this” reference</h1>
			<p>When you call an instance <a id="_idIndexMarker506"/>method, the compiler secretly passes into the method a copy of the object reference that invoked the method. This reference is available to the instance method as the <span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break"> reference.</span></p>
			<p>Class methods do not get a <strong class="source-inline">this</strong> reference. This is why, if you are in a <strong class="source-inline">static</strong> method (context) and you try to access an instance member directly (without an object reference), you will get a compiler error. In effect, every instance member requires an object reference when accessing it. This makes sense because instance members are instance-specific and therefore, you need an instance (reference) to say, <em class="italic">“I want to access this particular instance/object as opposed to that </em><span class="No-Break"><em class="italic">particular one.”</em></span></p>
			<p>Let’s refactor the code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> so that the <strong class="source-inline">Person</strong> class uses the <strong class="source-inline">this</strong> reference explicitly. In addition, all references to the incorrectly working <strong class="source-inline">count</strong> instance variable have been removed so that <a id="_idIndexMarker507"/>we can focus on the <strong class="source-inline">this</strong> reference. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em> includes the refactored <strong class="source-inline">Person</strong> class (the <strong class="source-inline">PersonExample</strong> class <span class="No-Break">remains untouched):</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B19793_08_8.jpg" alt="Figure 8.8 – Using the “this” reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Using the “this” reference</p>
			<p>In the preceding figure, lines 7, 11, and 15 are commented out and replaced by lines 8, 12, and 16, respectively. Let’s contrast both the commented-out line 7 and the new line 8 <span class="No-Break">more closely:</span></p>
			<pre class="source-code">
// name = aName; // line 7this.name = aName; // line 8</pre>
			<p>Firstly, assume line 7 is uncommented. How does line 7 reconcile its variables? Initially, the compiler checks the current scope (the constructor block of code) and reconciles <strong class="source-inline">aName</strong> as a parameter to the constructor. However, the compiler still has not reconciled <strong class="source-inline">name</strong>, so it checks <a id="_idIndexMarker508"/>the next outer scope, the class scope, where the instance/class variables are defined. Here, it finds an instance variable called <strong class="source-inline">name</strong>, and therefore line <span class="No-Break">7 compiles.</span></p>
			<p>Line 8 operates somewhat differently. Yes, it reconciles <strong class="source-inline">aName</strong> similarly but now, it comes across <strong class="source-inline">this.name</strong> (as opposed to <strong class="source-inline">name</strong>). Upon seeing <em class="italic">this</em>, the compiler immediately checks the instance variables that have been declared. It finds an instance variable called <strong class="source-inline">name</strong>, and therefore line 8 compiles. Lines 7 and 8 are, in effect, <span class="No-Break">the same.</span></p>
			<p>Line 16 is the same as line 8 as we used the same parameter identifier, <strong class="source-inline">aName</strong>. Line 12 is simply returning the <strong class="source-inline">name</strong> <span class="No-Break">instance variable.</span></p>
			<p>So, that covers how to use <strong class="source-inline">this</strong> in a class, but how do we associate the instance <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break">?</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor179"/>Associating an instance with the “this” reference</h2>
			<p>Thankfully, the compiler does this automatically. As stated previously, the <strong class="source-inline">this</strong> reference is only <a id="_idIndexMarker509"/>passed (in secret) to instance methods <a id="_idIndexMarker510"/>and it refers to the instance that is invoking the method at that time. For example, when executing <strong class="source-inline">p1.getName()</strong>, the <strong class="source-inline">this</strong> reference in <strong class="source-inline">getName</strong> refers to <strong class="source-inline">p1</strong>, whereas when executing <strong class="source-inline">p2.getName()</strong>, the <strong class="source-inline">this</strong> reference in <strong class="source-inline">getName</strong> refers to <strong class="source-inline">p2</strong>. Thus, the <strong class="source-inline">this</strong> reference varies, depending on the instance that invokes the method. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.9</em> represents the dynamic nature of the <strong class="source-inline">this</strong> reference <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B19793_08_9.jpg" alt="Figure 8.9 – The dynamic nature of the “this” reference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – The dynamic nature of the “this” reference</p>
			<p>This figure represents the in-memory representation of the code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em> as we execute line 12 from the method call on line 24. As <strong class="source-inline">getName</strong> on line 24 is invoked on <strong class="source-inline">p2</strong> – in other words, <strong class="source-inline">p2.getName();</strong> – the <strong class="source-inline">this</strong> reference inside <strong class="source-inline">getName</strong> refers to the same object that <strong class="source-inline">p2</strong> is referring to. This is represented by the solid line from the <strong class="source-inline">this</strong> reference referring to the same object that <strong class="source-inline">p2</strong> is <span class="No-Break">referring to.</span></p>
			<p>The dashed line <a id="_idIndexMarker511"/>represents what the <strong class="source-inline">this</strong> reference was <a id="_idIndexMarker512"/>referring to on line 12, from the method call on line 23, namely <strong class="source-inline">p1</strong>. Thus, the <strong class="source-inline">this</strong> reference is dynamically referring to the instances referred to by <strong class="source-inline">p1</strong> or <strong class="source-inline">p2</strong>, depending on which invoked the <span class="No-Break">instance method.</span></p>
			<p>As we saw in the code in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em>, the <strong class="source-inline">this</strong> reference was not needed. Let’s examine a situation where the <strong class="source-inline">this</strong> reference <span class="No-Break">is needed.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor180"/>Shadowing or hiding an instance variable</h2>
			<p>Shadowing an instance <a id="_idIndexMarker513"/>variable occurs when <a id="_idIndexMarker514"/>a variable has the same identifier as the instance variable. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.10</em> presents code where this occurs so that we can observe the issue <span class="No-Break">it creates:</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B19793_08_10.jpg" alt="Figure 8.10 – Shadowing an instance variable"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Shadowing an instance variable</p>
			<p>In the preceding figure, the constructor has a logical issue; in other words, the code compiles but the code is not working as expected. Line 7 is the issue. Remember that, if a variable is not qualified with <strong class="source-inline">this</strong>, the current scope is checked to see if the variable is declared there. On line 6, we have declared a constructor parameter that uses the <strong class="source-inline">name</strong> identifier, which <a id="_idIndexMarker515"/>is the same identifier as the instance <a id="_idIndexMarker516"/>variable on line 4. Thus, line 7 is essentially assigning the local variable to itself and the instance variable remains untouched. As the instance variable is a <strong class="source-inline">String</strong> type, its default value is <strong class="source-inline">null</strong>. As a result, <strong class="source-inline">null</strong> is output on line 19 instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"Maaike"</strong></span><span class="No-Break">.</span></p>
			<p>To fix this issue, we have two options. The first option is to use a different identifier for the constructor parameter and use that new identifier. This is what <strong class="source-inline">setName</strong> does (lines 12-13): a method parameter called <strong class="source-inline">aName</strong> is used that does not shadow the <strong class="source-inline">name</strong> instance identifier. The second option is to use the <strong class="source-inline">this</strong> reference to specify that the variable being initialized is an instance variable. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em> <span class="No-Break">shows this:</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B19793_08_11.jpg" alt="Figure 8.11 – Using “this” to fix the shadowing issue"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Using “this” to fix the shadowing issue</p>
			<p>In this figure, line 7 is important: <strong class="source-inline">this.name</strong> refers to the <strong class="source-inline">name</strong> instance variable, while <strong class="source-inline">name</strong>, on its <a id="_idIndexMarker517"/>own, refers to the method parameter. Thus, <a id="_idIndexMarker518"/>shadowing has been removed and line 19 now outputs <strong class="source-inline">"Maaike"</strong> <span class="No-Break">as expected.</span></p>
			<p>We know that only non-static (instance) methods receive the <strong class="source-inline">this</strong> reference. Let’s examine how this issue can affect us and how to resolve it. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.12</em> presents code where we are in a <strong class="source-inline">static</strong> context (method) and are trying to directly access an <span class="No-Break">instance variable:</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B19793_08_12.jpg" alt="Figure 8.12 – Accessing instance variables from a “static” context"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Accessing instance variables from a “static” context</p>
			<p>In the preceding figure, we have an instance variable called <strong class="source-inline">x</strong> (line 4), an instance method called <strong class="source-inline">m</strong> (line 5), and a <strong class="source-inline">static</strong> method called <strong class="source-inline">main</strong> (lines 6 –19). As we know, <strong class="source-inline">static</strong> methods such as <strong class="source-inline">main</strong>, do not get the <strong class="source-inline">this</strong> reference automatically (as they are class methods as opposed to <span class="No-Break">instance methods).</span></p>
			<p>There are compiler errors on lines 9, 10, 11, and 12. When you access an instance member directly, as <a id="_idIndexMarker519"/>on lines 9 and 11, the compiler inserts <strong class="source-inline">this</strong> before <a id="_idIndexMarker520"/>the member. In other words, by the time the compiler is finished with lines 9 and 11, internally, they look the same as lines 10 and 12. Consequently, as <strong class="source-inline">main</strong> does not have a <strong class="source-inline">this</strong> reference, the compiler complains about lines 9, 10, 11 <span class="No-Break">and 12.</span></p>
			<p>Lines 15-18 encapsulate how to resolve this issue. When you’re in a <strong class="source-inline">static</strong> context and you want to access an instance member (variable or method), you need to create an object instance to refer to the instance member. Therefore, on line 15, we create an (object) instance of the class containing the instance member, namely <strong class="source-inline">PersonExample</strong>, and store the reference in an identifier, <strong class="source-inline">pe</strong>. Now that we have an instance, we can access the instance members, which we do on lines 16, 17 and 18. Line 16 successfully changes <strong class="source-inline">x</strong> from (its default value of) 0 to 999. This is what is <a id="_idIndexMarker521"/>output on line 18. Line 17 shows <a id="_idIndexMarker522"/>that access to <strong class="source-inline">m</strong> is not an issue either. Note that you must comment out lines 9-12 before the code will compile <span class="No-Break">and run.</span></p>
			<p>Throughout these examples, we have used the <strong class="source-inline">private</strong> and <strong class="source-inline">public</strong> access modifiers. Let’s discuss these in <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor181"/>Applying access modifiers</h1>
			<p>One of the cornerstones of OOP is the principle of <em class="italic">encapsulation</em> (data abstraction). Encapsulation <a id="_idIndexMarker523"/>can be achieved using access modifiers. Before we discuss encapsulation, we must understand the access <span class="No-Break">modifiers themselves.</span></p>
			<p>Access modifiers determine where a class, field, or method is visible and therefore available for use. The level you are annotating at, determines the available <span class="No-Break">access modifiers:</span></p>
			<ul>
				<li><strong class="bold">Top level</strong>: Classes, enums, records and interfaces – <strong class="source-inline">public</strong> or package-private (<span class="No-Break">no keyword)</span></li>
				<li><strong class="bold">Member level</strong>: The access modifiers are, in order from most restrictive to least restrictive, <strong class="source-inline">private</strong>, package-private, <strong class="source-inline">protected</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">public</strong></span></li>
			</ul>
			<p>Let’s discuss these <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor182"/>private</h2>
			<p>A member <a id="_idIndexMarker524"/>marked as <strong class="source-inline">private</strong> is accessible within its own class only. In other words, the block scope of the class defines the boundary. When in a class (scope), you cannot access the <strong class="source-inline">private</strong> members of another class, even if you have an object reference to the class containing the <span class="No-Break"><strong class="source-inline">private</strong></span><span class="No-Break"> member.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor183"/>Package-private</h2>
			<p>There is no special <a id="_idIndexMarker525"/>keyword for <strong class="source-inline">package-private</strong>. If a type (class, interface, record, or enum) has no access modifier then <strong class="source-inline">package-private</strong> is applied. Types that are <strong class="source-inline">package-private</strong> are only visible within the same package. Recall that a package is simply a named group of <span class="No-Break">related types.</span></p>
			<p>The <strong class="source-inline">Person</strong> class (line 3) in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em> is a <strong class="source-inline">package-private</strong> class, meaning <strong class="source-inline">Person</strong> cannot be imported into another package. In addition, the <strong class="source-inline">Person</strong> constructor (line 6) is package-private, meaning that you cannot create an <a id="_idIndexMarker526"/>object of the <strong class="source-inline">Person</strong> type from within a <span class="No-Break">different package.</span></p>
			<p>At a <strong class="bold">member</strong> level, there are a few exceptions to the preceding text that you need to be aware of when you omit the <span class="No-Break">access modifier:</span></p>
			<ul>
				<li>Class/record members are, as above, <strong class="source-inline">package-private</strong> <span class="No-Break">by default.</span></li>
				<li>Interface members are <strong class="source-inline">public</strong> <span class="No-Break">by default.</span></li>
				<li>Enum constants (members) are <strong class="source-inline">public</strong> <strong class="source-inline">static</strong> and <strong class="source-inline">final</strong> by default. Enum constructors are <strong class="source-inline">private</strong> by default. We will discuss enums later in <span class="No-Break">the chapter.</span></li>
			</ul>
			<p class="callout-heading">The default package</p>
			<p class="callout">The default package is also known as the package with no name or the unnamed package. Types that have no explicit package statement at the top of the file are put into this <a id="_idIndexMarker527"/>package. This is the package where the <strong class="source-inline">Person</strong> and <strong class="source-inline">PersonExample</strong> classes from <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em> <span class="No-Break">are placed.</span></p>
			<p class="callout"> The implications of this are that, given the package has no name, if we are in a different (named) package, we have no way of importing <strong class="source-inline">Person</strong> and <strong class="source-inline">PersonExample</strong>. The fact that <strong class="source-inline">PersonExample</strong> is <strong class="source-inline">public</strong> (line 16) makes no difference. Therefore, only other types in the same (default) package can <span class="No-Break">access them.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor184"/>protected</h2>
			<p>A member marked as <strong class="source-inline">protected</strong> means that it’s visible within its own package (as with package-private) but <a id="_idIndexMarker528"/>also visible to subclasses outside of the package. We will discuss subclasses and <strong class="source-inline">protected</strong> in more detail when we cover inheritance in <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor185"/>public</h2>
			<p>A type or member <a id="_idIndexMarker529"/>marked as <strong class="source-inline">public</strong> is visible everywhere. Thus, no <span class="No-Break">boundaries apply.</span></p>
			<p><em class="italic">Table 8.2</em> summarizes the access modifiers and <span class="No-Break">their visibility:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B19793_08_Table_02.jpg" alt="Table 8.2 – Access modifiers and their visibility"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – Access modifiers and their visibility</p>
			<p>Let’s examine <em class="italic">Table 8.2</em> horizontally. Only the class has access to members marked as <strong class="source-inline">private</strong>. If a class or member has no access modifier (package-private), then that class or member is only visible within the class and the package. If the member is marked as <strong class="source-inline">protected</strong>, then the member is visible to the class, package, and subclasses of that class, regardless of the package. Finally, if a class or member is marked as <strong class="source-inline">public</strong>, then the class or member is <span class="No-Break">visible everywhere.</span></p>
			<p>To further help explain <em class="italic">Table 8.2</em>, let’s diagram an example suite of classes and their associated packages and draw up another visibility table specifically for it. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em> <span class="No-Break">shows this:</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B19793_08_13.jpg" alt="Figure 8.13 – Sample example access modifiers diagram"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Sample example access modifiers diagram</p>
			<p>In this figure, the <strong class="source-inline">Dog</strong> class is in bold and underlined because the following table, <em class="italic">Table 8.3</em>, represents the visibility of <em class="italic">its</em> members. For example, when reading the <strong class="source-inline">private</strong> row, assume that we have marked a member in <strong class="source-inline">Dog</strong> as <strong class="source-inline">private</strong> and are determining its visibility in the other classes. Let’s examine <span class="No-Break"><em class="italic">Table 8.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B19793_08_Table_03.jpg" alt="Table 8.3 – Visibility when modifiers are applied to a Dog member"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.3 – Visibility when modifiers are applied to a Dog member</p>
			<p>Thus, if a <strong class="source-inline">Dog</strong> member is <strong class="source-inline">private</strong>, only <strong class="source-inline">Dog</strong> can see it. If the <strong class="source-inline">Dog</strong> member is package-private, only <strong class="source-inline">Dog</strong> and <strong class="source-inline">Cat</strong> can see it. If the <strong class="source-inline">Dog</strong> member is <strong class="source-inline">protected</strong>, <strong class="source-inline">Dog</strong> and <strong class="source-inline">Cat</strong> can see it. Lastly, if <a id="_idIndexMarker530"/>the <strong class="source-inline">Dog</strong> member is <strong class="source-inline">public</strong>, every class can <span class="No-Break">see it.</span></p>
			<p>(*) We will complete this table when revisiting <strong class="source-inline">protected</strong> in the <span class="No-Break">inheritance chapter.</span></p>
			<p class="callout-heading">How do access levels affect you?</p>
			<p class="callout">Access levels will affect you in two ways. Firstly, you could be using an external class (from the Java API, for example) and want to know if you can use that class and/or its members in your code. Secondly, when <a id="_idIndexMarker531"/>writing a class, you will want to decide the access level each class and member will have. A good rule of thumb is to keep your members as <strong class="source-inline">private</strong> as possible to avoid misuse. Additionally, avoid <strong class="source-inline">public</strong> fields unless they are constants. We will discuss this further when we <span class="No-Break">discuss encapsulation.</span></p>
			<p>Let’s look at these access modifiers in code. In particular, we will focus on the package and learn how to create one and how access is affected by <span class="No-Break">its boundary.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor186"/>packages</h2>
			<p>Recall that the fully qualified type name includes the package name.<em class="italic"> A package defines a namespace</em>. For example, in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>, the <strong class="source-inline">Dog</strong> class in <a id="_idIndexMarker532"/>the <strong class="source-inline">ch8.animals</strong> package is fully qualified as <strong class="source-inline">ch8.animals.Dog</strong>. Therefore, a <strong class="source-inline">Dog</strong> class in a package named <strong class="source-inline">kennel</strong> would have a qualified name of <strong class="source-inline">kennel.Dog</strong>; which is completely different to <strong class="source-inline">ch8.animals.Dog</strong>. Thus, Java can distinguish between the two <strong class="source-inline">Dog</strong> types and no name collisions occur. As we shall see, the package structure is also used as a directory structure for your java files. Oracle gives <a id="_idIndexMarker533"/>very good guidelines (see <a href="https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html">https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html</a>) on how to name your packages so that your types do not conflict with someone else’s. Package names are written in all lowercase letters to differentiate them from type names. Following that, companies <a id="_idIndexMarker534"/>should use reverse internet domain names to begin their package names. For example, if you work at a company called <strong class="source-inline">somecompany.com</strong> and you are creating a package called <strong class="source-inline">somepackage</strong>, then the full package name should be <strong class="source-inline">com.somecompany.somepackage</strong>. Within a company, naming can then follow company conventions, such as including the <span class="No-Break">region: </span><span class="No-Break"><strong class="source-inline">com.somecompany.region.somepackage</strong></span><span class="No-Break">.</span></p>
			<p>Let’s examine the packages from <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>. We will start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ch8.animals</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B19793_08_14.jpg" alt="Figure 8.14 – The “ch8.animals” package from Figure 8.13"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – The “ch8.animals” package from Figure 8.13</p>
			<p>In this figure, note that, for simplicity, we have grouped the two classes in the package into one Java file. This file is called <strong class="source-inline">Dog.java</strong> (as the <strong class="source-inline">public</strong> class is <strong class="source-inline">Dog</strong>). The first line is important: <strong class="source-inline">package ch8.animals</strong> states that the types (classes and so forth), that are defined here, go into this package. In addition, the file Dog.java will be put into a folder on the hard disk <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">ch8\animals</strong></span><span class="No-Break">.</span></p>
			<p>In this figure, line 4 defines a <strong class="source-inline">private</strong> instance variable called <strong class="source-inline">dogName</strong>. This is accessible within the class only (as per lines 6 and 9) but not outside the class (as per <span class="No-Break">line 18).</span></p>
			<p>Line 5 defines a <strong class="source-inline">protected</strong> instance variable called <strong class="source-inline">age</strong> which we can access from another class within the package (line 19). Line 12 <a id="_idIndexMarker535"/>defines a package-private method called <strong class="source-inline">pkgPrivate()</strong> and line 20 shows that we can access it from another class in the same package. Note also that the <strong class="source-inline">Cat</strong> class and its constructor are both package-private (lines 14 and <span class="No-Break">15, respectively).</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.15</em> shows the other <span class="No-Break">package, </span><span class="No-Break"><strong class="source-inline">ch8.farm</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B19793_08_15.jpg" alt="Figure 8.15 – The “ch8.farm” package from Figure 8.13"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – The “ch8.farm” package from Figure 8.13</p>
			<p>Again, note that line 1 states the package name – this is the <strong class="source-inline">ch8.farm</strong> package. The filename is <strong class="source-inline">Pig.java</strong> (as the <strong class="source-inline">public</strong> class is <strong class="source-inline">Pig</strong>) and the file will be put into a folder on the hard disk <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">ch\farm</strong></span><span class="No-Break">.</span></p>
			<p>Note the use of the fully qualified names when importing (lines 3 and 4). As we want access to the <strong class="source-inline">Dog</strong> class which resides in a separate package, we must import it. There is no issue importing <strong class="source-inline">Dog</strong> since it is <strong class="source-inline">public</strong>. However, we are unable to import <strong class="source-inline">Cat</strong> as <strong class="source-inline">Cat</strong> is package-private (and we are in a <span class="No-Break">different package).</span></p>
			<p>Line 8 demonstrates that <strong class="source-inline">Pig</strong> can create a <strong class="source-inline">Dog</strong> object. Note that there are two access points here: the <strong class="source-inline">Dog</strong> class is <strong class="source-inline">public</strong> (so we can <strong class="source-inline">import</strong> it); and the <strong class="source-inline">Dog</strong> constructor is also <strong class="source-inline">public</strong> (so we can <a id="_idIndexMarker536"/>create an instance of <strong class="source-inline">Dog</strong> from code in a different package). This is why the access modifiers for the class and constructors should match. Line 9 shows that, when we are in a different package, we do not have access to package-private members from <span class="No-Break">another package.</span></p>
			<p>Now that we understand access modifiers, we are in a position to <span class="No-Break">discuss encapsulation.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor187"/>Encapsulation</h1>
			<p>As previously stated, encapsulation is a key concept in OOP. The principle here is that you protect the data in your <a id="_idIndexMarker537"/>class and ensure that the data can only be manipulated (retrieved and/or changed) via your code. In other words, you have control over how external classes interact with your internal state (data). So, how do we <span class="No-Break">do this?</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor188"/>Achieving encapsulation</h2>
			<p>Basic encapsulation is very easy to achieve. You simply mark your data as <strong class="source-inline">private</strong> and manipulate the <a id="_idIndexMarker538"/>data via <strong class="source-inline">public</strong> methods. Thus, external classes cannot access the data directly (as it is <strong class="source-inline">private</strong>); these external classes must go through your <strong class="source-inline">public</strong> methods to retrieve or change <span class="No-Break">the data.</span></p>
			<p>These <strong class="source-inline">public</strong> methods make up the class’s "interface"; in other words, how you interact with the class. This “interface” (group of <strong class="source-inline">public</strong> methods) is very different from and not to be confused with the <strong class="source-inline">interface</strong> language construct (<a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>). <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.16</em> presents a code example to help us further develop <span class="No-Break">this topic:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B19793_08_16.jpg" alt="Figure 8.16 – Basic encapsulation in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Basic encapsulation in action</p>
			<p>In the preceding figure, the <strong class="source-inline">Adult</strong> class has two <strong class="source-inline">private</strong> instance variables, namely <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> (lines 4 and 5, respectively). Thus, these instance variables only have access within the <strong class="source-inline">Adult</strong> block of <a id="_idIndexMarker539"/>code. Note that even having an <strong class="source-inline">Adult</strong> object reference cannot bypass this access rule – the compiler error on (the commented out) line 29 <span class="No-Break">demonstrates this.</span></p>
			<p class="callout-heading">public class name and filename relationship</p>
			<p class="callout">In Java, the name of the <strong class="source-inline">public</strong> class must match the filename. In <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.16</em>, the <strong class="source-inline">public</strong> class is <strong class="source-inline">BasicEncapsulation</strong>. This means that the filename must be named <strong class="source-inline">BasicEncapsulation.java</strong>, which it is. This rule implies that you cannot have two <strong class="source-inline">public</strong> classes in the same file – that is why the <strong class="source-inline">Adult</strong> class is <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break">.</span></p>
			<p class="callout">What if we were in a different package and we wanted to create an <strong class="source-inline">Adult</strong> object, as defined in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.16</em>? This is an issue because <strong class="source-inline">Adult</strong> is package-private (line 3). To fix this issue, we need to make the <strong class="source-inline">Adult</strong> class <strong class="source-inline">public</strong> so that we can <strong class="source-inline">import</strong> it when in a different package. This means that we need to move the <strong class="source-inline">Adult</strong> class into a separate file, named <strong class="source-inline">Adult.java</strong>. In addition, both <strong class="source-inline">Adult</strong> and its constructor would need to be <strong class="source-inline">public</strong>. Why? Well, when we’re in a different package, the class being <strong class="source-inline">public</strong> enables us to <strong class="source-inline">import</strong> the class and the constructor being <strong class="source-inline">public</strong> enables us to create objects of the <span class="No-Break"><strong class="source-inline">Adult</strong></span><span class="No-Break"> type.</span></p>
			<p>The <strong class="source-inline">Adult</strong> constructor (line 7) has no access modifier and is therefore package-private. Thus, only classes within the same package can invoke this constructor. In other words, only classes in the <strong class="source-inline">ch8</strong> package (line 1) can create <strong class="source-inline">Adult</strong> objects. As <strong class="source-inline">BasicEncapsulation</strong> is also in <strong class="source-inline">ch8</strong>, the object creation on line 26 <span class="No-Break">is fine.</span></p>
			<p>The rest of the <strong class="source-inline">Adult</strong> class (lines 11-20) provides the getter/setter method pairs for manipulating the object <a id="_idIndexMarker540"/>state (the instance variables). These getter/setter methods are also known as accessor/mutator methods, respectively. There is usually a pair for each instance variable and they follow this format (note that this is just <span class="No-Break">an example):</span></p>
			<pre class="source-code">
public int getAge(){    return age;
}
public void setAge(int age){    
    this.age = age;
}</pre>
			<p>After creating the <strong class="source-inline">Adult</strong> object on line 26 in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.16</em>, we output the object state using the <strong class="source-inline">public</strong> accessor methods, <strong class="source-inline">getName</strong> and <strong class="source-inline">getAge</strong> (lines 27-28). As these accessor methods are <strong class="source-inline">public</strong>, these methods are available to any class in any package. Given that <strong class="source-inline">'John'</strong> and <strong class="source-inline">20</strong> are output, we know our object was <span class="No-Break">created correctly.</span></p>
			<p>Let’s assume that we are the developers of the <strong class="source-inline">Adult</strong> class and require an adult to be 18 years or older. In addition, we will assume that the developer of the <strong class="source-inline">BasicEncapsulation</strong> class is unknown to us. Line 29 demonstrates that as our <strong class="source-inline">Adult</strong> data is <strong class="source-inline">private</strong>, it is protected from direct external corruption. This is exactly what encapsulation provides; it is its <span class="No-Break">raison d’être!</span></p>
			<p>Line 30 demonstrates that the object’s state can still be corrupted. However, the corruption that’s done via the set/mutator method on line 30 is very different from the direct corruption on line 29. As the author of the <strong class="source-inline">Adult</strong> class, we can control and therefore fix the corruption error in our <strong class="source-inline">set</strong> methods. The issue with our <strong class="source-inline">set</strong> (mutator) method is replicated in the constructor. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.17</em> addresses this (internal) corruption issue in both the constructor and <span class="No-Break">mutator methods:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B19793_08_17.jpg" alt="Figure 8.17 – Ensuring “age” is at least 18"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Ensuring “age” is at least 18</p>
			<p>As <strong class="source-inline">BasicEncapsulation</strong> remains unchanged, it is not included in the preceding figure. Note that a <a id="_idIndexMarker541"/>new <strong class="source-inline">isAgeOk</strong> method has been introduced (lines 27-29). This method takes in an <strong class="source-inline">int</strong> parameter <strong class="source-inline">age</strong> and checks to see if it is <strong class="source-inline">&gt;= 18</strong>. If so, the method returns <strong class="source-inline">true</strong>; otherwise, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">isAgeOk</strong> method is invoked from the <strong class="source-inline">setAge</strong> mutator method (line 21). As the constructor calls <strong class="source-inline">setAge</strong> (line 8), it also avails of the age check logic. If an invalid age is passed into the constructor or <strong class="source-inline">setAge</strong>, an error value of –1 is set. Note that there are better ways to do this, but for now this is fine. When we run the program now, since the <strong class="source-inline">age</strong> value that is being passed into <strong class="source-inline">setAge</strong> is -99 (<strong class="source-inline">john.setAge(-99)</strong>), the instance <a id="_idIndexMarker542"/>variable <strong class="source-inline">age</strong> is set to the error value <span class="No-Break">of –1.</span></p>
			<p>That covers basic encapsulation. We will now discuss a particular issue with basic encapsulation and how advanced encapsulation <span class="No-Break">resolves it.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor189"/>Mastering advanced encapsulation</h1>
			<p>The simple maxim of “private data, public methods” (where the <strong class="source-inline">public</strong> methods manipulate the data) goes a long way to ensuring proper encapsulation of your data. However, you are not <a id="_idIndexMarker543"/>completely safe just yet. In this section, we will review Java’s call by value principle, which is used when passing arguments to and returning values from methods. We will examine how this can present a subtle issue. Lastly, we will examine how to protect your code from encountering this issue in the <span class="No-Break">first place.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor190"/>Call By value revisited</h2>
			<p>In <a href="B19793_07.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, we discussed how, when passing arguments to methods, Java’s <em class="italic">call by value</em> mechanism creates <em class="italic">copies</em> of those arguments. We saw the need to be aware that when the argument is a <a id="_idIndexMarker544"/>reference, such as to an array, the called method can now manipulate the array object that the caller method is <span class="No-Break">looking at.</span></p>
			<p>Similarly, when a method is <em class="italic">returning</em> something, call by value applies again. In other words, a copy is made of what you are returning. Depending on what the copy is of, this can result in encapsulation being broken or not. If you are returning <strong class="source-inline">private</strong> primitive data, then there is no issue – a copy of the primitive is returned and the client can do whatever it likes to the copy; your <strong class="source-inline">private</strong> primitive data is safe. As you may recall from <a href="B19793_07.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, copying primitives is like photocopying a sheet of paper. The photocopied sheet can be written on without it affecting the <span class="No-Break">original copy.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor191"/>The issue</h2>
			<p>The issue arises if your <strong class="source-inline">private</strong> data is a reference (to an object). If the client receives a copy of the reference, then the <a id="_idIndexMarker545"/>client can manipulate your <strong class="source-inline">private</strong> object! From <a href="B19793_07.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, you may recall that copying a reference is like copying a remote control to a TV. The new remote can change the channels on the same TV. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.18</em> presents code that <span class="No-Break">breaks encapsulation:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B19793_08_18.jpg" alt="Figure 8.18 – Code that breaks encapsulation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Code that breaks encapsulation</p>
			<p>In the <a id="_idIndexMarker546"/>preceding figure, the <strong class="source-inline">Seniors</strong> class has two <strong class="source-inline">private</strong> instance variables (lines 6-7), namely <strong class="source-inline">ages</strong> and <strong class="source-inline">num</strong>. The constructor (lines 9-13) initializes the instance variables. We have a public <strong class="source-inline">getNum</strong> accessor method, which returns the <strong class="source-inline">private</strong> instance variable, <strong class="source-inline">num</strong> (line 14). Note that we have put this method on one line in the interest <span class="No-Break">of space.</span></p>
			<p>We have another accessor method called <strong class="source-inline">getAges</strong> (lines 15-17) that returns a <strong class="source-inline">private</strong> array called <strong class="source-inline">ages</strong>. <em class="italic">Line 16 is the problem</em> as it breaks encapsulation. We will explain why when we discuss the code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break">.</span></p>
			<p>In <strong class="source-inline">main</strong>, the first thing we do is create an instance of <strong class="source-inline">Seniors</strong> (line 21). This is so we can access the instance methods defined in <strong class="source-inline">Seniors</strong>. The rest of <strong class="source-inline">main</strong> is divided into two sections: one section (lines 23-27) demonstrates that returning <strong class="source-inline">private</strong> primitive data is fine; the other section (lines 30-37) demonstrates that simply returning <strong class="source-inline">private</strong> <em class="italic">references </em><span class="No-Break">breaks encapsulation.</span></p>
			<p>Let’s examine the first section. Line 23 initializes the local variable, <strong class="source-inline">num</strong>, based on the return value from <strong class="source-inline">seniors.getNum()</strong>. As the <strong class="source-inline">private</strong> <strong class="source-inline">Seniors</strong> instance variable, <strong class="source-inline">num</strong>, was initialized to <strong class="source-inline">2</strong> in the <strong class="source-inline">Seniors</strong> constructor (line 10), the (completely separate) local variable, <strong class="source-inline">num</strong>, is initialized to <strong class="source-inline">2</strong>. We output this fact on line 24. We then change the local <strong class="source-inline">num</strong> variable’s value to <strong class="source-inline">-100</strong> (line 25). The question now is, when we changed the local variable <strong class="source-inline">num</strong>, was the <strong class="source-inline">private</strong> <strong class="source-inline">Seniors</strong> instance variable, <strong class="source-inline">num</strong>, changed also? To find out, we can <a id="_idIndexMarker547"/>simply retrieve <strong class="source-inline">num</strong> again using the <strong class="source-inline">public</strong> accessor method, <strong class="source-inline">getNum</strong> (line 26). Line 27 outputs <strong class="source-inline">2</strong>, proving that the <strong class="source-inline">private</strong> primitive, <strong class="source-inline">num</strong>, was safe from changes made <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break">.</span></p>
			<p>The second section is where things get interesting. Line 30 initializes a local variable called <strong class="source-inline">copyAges</strong> based on the return value from the <strong class="source-inline">public</strong> accessor method, <strong class="source-inline">seniors.getAges()</strong>. As <strong class="source-inline">getAges</strong> simply returns (a copy of) the <strong class="source-inline">private</strong> <strong class="source-inline">ages</strong> reference, we now have two references referring to the one array object. These references are the <strong class="source-inline">private</strong> instance variable, <strong class="source-inline">ages</strong>, and the local variable, <strong class="source-inline">copyAges</strong>. Line 31 outputs the values of <strong class="source-inline">copyAges</strong>, which are <strong class="source-inline">30</strong> and <strong class="source-inline">40</strong> for the indices <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, respectively. These are the same values that the <strong class="source-inline">private</strong> <strong class="source-inline">ages</strong> array was initialized to in the <strong class="source-inline">Seniors</strong> constructor (<span class="No-Break">lines 11-12).</span></p>
			<p>Now, on lines 34-35, we change the values of the <strong class="source-inline">copyAges</strong> array: index <strong class="source-inline">0</strong> is set to <strong class="source-inline">-9</strong> and index <strong class="source-inline">1</strong> is set to <strong class="source-inline">-19</strong>. As with the first section, we are now wondering, did changing the local array have any effect on the <strong class="source-inline">private</strong> instance array in <strong class="source-inline">Seniors</strong>? The answer is yes! To prove this, we can retrieve the <strong class="source-inline">private</strong> array again using <strong class="source-inline">getAges</strong> (line 36) and output its values (line 37). The output values of <strong class="source-inline">-9</strong> and <strong class="source-inline">-19</strong> demonstrate that the client, <strong class="source-inline">AdvancedEncapsulation</strong>, was able to manipulate (change) the so-called <strong class="source-inline">private</strong> data of <strong class="source-inline">Seniors</strong>. Therefore, <strong class="source-inline">Seniors</strong> is not encapsulated <span class="No-Break">after all.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.19</em> shows the situation in memory, shedding light on why <strong class="source-inline">Seniors</strong> is <span class="No-Break">not encapsulated:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B19793_08_19.jpg" alt="Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)</p>
			<p>In the preceding figure, the <a id="_idIndexMarker548"/>local variable, <strong class="source-inline">num</strong>, is on the stack. It is a copy of the <strong class="source-inline">private</strong> <strong class="source-inline">Seniors</strong> <strong class="source-inline">num</strong> instance variable, and its different values as we progress through <strong class="source-inline">main</strong> are reflected in strikethrough font. Line 25 (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.18</em>) changes the local variable to <strong class="source-inline">-100</strong>. As can be seen, this change does not affect the <strong class="source-inline">private</strong> instance variable, <strong class="source-inline">num</strong>, in <strong class="source-inline">Seniors</strong>, which <span class="No-Break">remains </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p>The issue is with the reference to the <strong class="source-inline">private</strong> array object, <strong class="source-inline">ages</strong>. Because <strong class="source-inline">getAges</strong> (line 15) simply returns the reference, a copy of that reference is stored in the local variable, <strong class="source-inline">copyAges</strong> (line 30). As the local reference, <strong class="source-inline">copyAges</strong>, and the <strong class="source-inline">private</strong> reference, <strong class="source-inline">ages</strong>, now refer to the same object, the copy reference can change the <strong class="source-inline">private</strong> array object. That is why the array object has values of <strong class="source-inline">-9</strong> and <strong class="source-inline">-19</strong> for indices <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, respectively. The <strong class="source-inline">copyAges2</strong> reference is just there to prove <span class="No-Break">that point.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor192"/>The solution</h2>
			<p>Now that we know the issue, fixing it is quite straightforward. The key is to, when returning a <a id="_idIndexMarker549"/>reference, ensure that you simply do not return the <strong class="source-inline">private</strong> reference (as call by value will return a copy of that reference). The solution is to <em class="italic">make a copy of the object you wish to return and return a reference to the new object</em>. Thus, the external class (client) can manipulate this new object without affecting your private internal object. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.20</em> is the properly encapsulated, refactored version of <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.18</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B19793_08_20.jpg" alt="Figure 8.20 – Properly encapsulated code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Properly encapsulated code</p>
			<p>In the preceding figure, we have replaced the accessor method, <strong class="source-inline">getAges</strong>, with a new version (lines 15-18). This new version is properly encapsulated. On line 16, instead of simply returning the (reference to the) array instance variable, we are copying the array, <strong class="source-inline">ages</strong>, into a new array, namely <strong class="source-inline">newArr</strong>. We achieve this using the <strong class="source-inline">Arrays.copyOf</strong> method. We return a (copy of the) reference to the new <span class="No-Break">array object.</span></p>
			<p>Now, on line 24, when we initialize <strong class="source-inline">copyAges</strong>, it is referring to the copy array that was created on line 16. That reference, <strong class="source-inline">newArr</strong>, has gone out of scope (since we returned from <strong class="source-inline">getAges</strong>) but the new array object is still on the heap, with <strong class="source-inline">copyAges</strong> referring to it. The important <a id="_idIndexMarker550"/>point here is that on line 25, we have two distinct array references: the <strong class="source-inline">ages</strong> instance and the local <strong class="source-inline">copyAges</strong>. These references now refer to two <span class="No-Break"><em class="italic">different</em></span><span class="No-Break"> objects.</span></p>
			<p>Line 25 outputs the details of the copy array; <strong class="source-inline">30</strong> for index <strong class="source-inline">0</strong> and <strong class="source-inline">40</strong> for index <strong class="source-inline">1</strong>. This is as expected. Lines 26 and 27 change the contents of the copy array indices, <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, to <strong class="source-inline">-9</strong> and <strong class="source-inline">-19</strong>, respectively. Now, we need to check something: when we changed the contents of the <strong class="source-inline">copyAges</strong> array, were the contents of the <strong class="source-inline">private</strong> internal <strong class="source-inline">Seniors</strong> array’s <strong class="source-inline">ages</strong> changed? To check, on line 28, we can initialize a <strong class="source-inline">copyAges2</strong> array with the (copy of the) contents of the <strong class="source-inline">private</strong> array, <strong class="source-inline">ages</strong>. When we output the details of <strong class="source-inline">copyAges2</strong> on line 29, we get <strong class="source-inline">30</strong> and <strong class="source-inline">40</strong>, thereby proving that the <strong class="source-inline">private</strong> internal array, <strong class="source-inline">ages</strong>, was <em class="italic">not</em> changed when we changed the local <strong class="source-inline">copyAges</strong> array (lines 26-27). Now, <strong class="source-inline">Seniors</strong> is <span class="No-Break">properly encapsulated.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.21</em> show this situation in memory as we execute <span class="No-Break">line 29:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B19793_08_21.jpg" alt="Figure 8.21 – In-memory representation of Figure 8.20"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – In-memory representation of Figure 8.20</p>
			<p>In the preceding figure, just after the <strong class="source-inline">Seniors</strong> object is constructed (line 22), we have a <strong class="source-inline">seniors</strong> reference on the stack referring to a <strong class="source-inline">Seniors</strong> object on the heap. The <strong class="source-inline">Seniors</strong> object contains a <strong class="source-inline">num</strong> primitive set to 2 (line 10) and an <strong class="source-inline">ages</strong> array reference referring to the array object (<span class="No-Break">lines 11-12).</span></p>
			<p>When we call <strong class="source-inline">getAges</strong> (line 24), the copy array, <strong class="source-inline">newArr</strong>, is created (line 16) and although not shown here, the new array initially contains the values of <strong class="source-inline">30</strong> and <strong class="source-inline">40</strong> (indices <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, respectively), as per line 25. When <strong class="source-inline">newArr</strong> is returned from <strong class="source-inline">getAges</strong> (line 17), the (copy of the) reference is assigned to <strong class="source-inline">copyAges</strong> (line 24). As shown in the preceding diagram, the <strong class="source-inline">copyAges</strong> local variable and the <strong class="source-inline">ages</strong> instance variable refer to two different array objects. This is what we want. <em class="italic">Any changes made using </em><strong class="source-inline">copyAges</strong><em class="italic"> will not affect the private </em><span class="No-Break"><em class="italic">array </em></span><span class="No-Break"><strong class="source-inline">ages</strong></span><span class="No-Break">.</span></p>
			<p>This is what the changes on lines 26-27 demonstrate. The changes that were made using the <strong class="source-inline">copyAges</strong> reference are reflected in the diagram. To prove that the changes on lines 26-27 did not <a id="_idIndexMarker551"/>affect the <strong class="source-inline">private</strong> array, <strong class="source-inline">ages</strong>, we call <strong class="source-inline">getAges</strong> again. A new array, representing a copy of the <strong class="source-inline">private</strong> array, is again created (line 16) and the (copy of) the new array reference is returned and assigned to the local reference, <strong class="source-inline">copyAges2</strong>. When we output the new array’s contents on line 29, we get <strong class="source-inline">30</strong> and <strong class="source-inline">40</strong>, demonstrating that the <strong class="source-inline">private</strong> array is unaffected by changes to the local array (<span class="No-Break">lines 26-27).</span></p>
			<p>Now that we understand call by value and advanced encapsulation, we are in an excellent position to discuss the object <span class="No-Break">life cycle.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor193"/>Delving into the object life cycle</h1>
			<p>To understand Java, it is extremely helpful to have an appreciation of what is happening in the background, in <a id="_idIndexMarker552"/>memory. This section will help cement what is happening on the stack and the heap when we call methods, declare local/instance variables, and <span class="No-Break">so forth.</span></p>
			<p>Local variables are kept on the stack (for fast access), whereas instance variables and objects live on the heap (a large area of memory). As we know, we use the <strong class="source-inline">new</strong> keyword to create a Java object. The <strong class="source-inline">new</strong> keyword allocates space on the heap for the object and returns <a id="_idIndexMarker553"/>the reference to the object. What happens if the object is no longer accessible? For example, the <a id="_idIndexMarker554"/>reference may have gone out of scope. How do we reclaim that memory? This is where garbage collection comes <span class="No-Break">into play.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor194"/>Garbage collection</h2>
			<p>As mentioned previously, garbage collection reclaims memory taken up by objects that are no longer being used; as in the objects have no references pointing to them. This garbage collection process is a JVM process that runs in the <a id="_idIndexMarker555"/>background. The JVM may decide during an idle time <a id="_idIndexMarker556"/>to run garbage collection and then it may not. Simply put, we have no control over when garbage collection runs. Even if we invoke <strong class="source-inline">System.gc()</strong>, this is but a suggestion to the JVM to run garbage collection – the JVM is free to ignore this suggestion. The major advantage of garbage collection is that we do not have to do the tidy-up ourselves; whereas in languages such as C++, <span class="No-Break">we do.</span></p>
			<p>For further detail on Java Memory Management please see our previous <span class="No-Break">book: </span><a href="https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&amp;keywords=java+memory+management+maaike&amp;qid=1699112145&amp;sprefix=java+memory+management+maaike%2Caps%2C148&amp;sr=8-1"><span class="No-Break">https://www.amazon.com/Java-Memory-Management-comprehensive-collection/</span> <span class="No-Break">dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&amp;keywords=java+memory+management+maaike&amp;qid=1699112145&amp;sprefix=java+memory+</span> <span class="No-Break">management+maaike%2Caps%2C148&amp;sr=8-1</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor195"/>Object life cycle example</h2>
			<p>A sample program <a id="_idIndexMarker557"/>will help at this point. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.22</em> presents a program to suit <span class="No-Break">our purposes:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B19793_08_22.jpg" alt="Figure 8.22 – Sample program to explain an object’s life cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Sample program to explain an object’s life cycle</p>
			<p>As this (simple and very contrived) program executes, three methods are pushed onto the <a id="_idIndexMarker558"/>stack, namely <strong class="source-inline">main</strong>, <strong class="source-inline">tagAnimal</strong>, and <strong class="source-inline">setCountry</strong>. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.23</em> represents the in-memory representation when we are just about to exit the <strong class="source-inline">setCountry</strong> method (<span class="No-Break">line 19):</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B19793_08_23.jpg" alt="Figure 8.23 – In-memory representation of code in Figure 8.22"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – In-memory representation of code in Figure 8.22</p>
			<p>Let’s look at <a id="_idIndexMarker559"/>this in <span class="No-Break">more detail.</span></p>
			<h3>The main method</h3>
			<p>As can be seen from the previous two figures, line 9 creates the <strong class="source-inline">Cow</strong> object on the heap, and the local <a id="_idIndexMarker560"/>reference, <strong class="source-inline">cow1</strong>, on the stack in the frame for <strong class="source-inline">main</strong>, refers to it. The instance variables in the <strong class="source-inline">Cow</strong> object on the heap, namely <strong class="source-inline">tag</strong> and <strong class="source-inline">country</strong>, will be <strong class="source-inline">null</strong> at <span class="No-Break">this point.</span></p>
			<p>Line 10 assigns the value in <strong class="source-inline">cow1</strong> to another local reference in <strong class="source-inline">main</strong>, namely <strong class="source-inline">cow2</strong>. Now, at line 11, we have a frame for <strong class="source-inline">main</strong> on the stack with two local reference variables, namely <strong class="source-inline">cow1</strong> and <strong class="source-inline">cow2</strong>, both referring to the one <strong class="source-inline">Cow</strong> object on <span class="No-Break">the heap.</span></p>
			<p>Line 11 uses the <strong class="source-inline">cow2</strong> reference to execute the instance method, <strong class="source-inline">tagAnimal</strong>. Thus, when inside the <strong class="source-inline">tagAnimal</strong> method (during this invocation), the <strong class="source-inline">this</strong> reference will be referring to whatever <strong class="source-inline">cow2</strong> is referring to (which is the <strong class="source-inline">Cow</strong> object on the heap). In addition, the <strong class="source-inline">cow1</strong> reference is passed as an argument to the <strong class="source-inline">tagAnimal</strong> method. This is not necessary as <strong class="source-inline">tagAnimal</strong> already has a reference to the <strong class="source-inline">Cow</strong> object (using <strong class="source-inline">this</strong>) but this program is just for <span class="No-Break">example purposes.</span></p>
			<h3>The tagAnimal method</h3>
			<p>As with any method invocation, a stack frame for <strong class="source-inline">tagAnimal</strong> is pushed on the stack. As per call by value rules, <strong class="source-inline">tagAnimal</strong> (line 13) aliases the method parameter <strong class="source-inline">cow</strong> for <strong class="source-inline">cow1</strong> from line 11 (the method call). Thus, the <strong class="source-inline">cow</strong> reference in <strong class="source-inline">tagAnimal</strong> and the <strong class="source-inline">cow1</strong> reference in <strong class="source-inline">main</strong> are pointing at the same <strong class="source-inline">Cow</strong> object, which was created on <span class="No-Break">line 9.</span></p>
			<p>As we know, the <strong class="source-inline">this</strong> reference refers to the object instance responsible for the method call – in this case, <strong class="source-inline">cow2</strong> (line 11). Therefore, the reference to <strong class="source-inline">tag</strong> on line 14 (which is <strong class="source-inline">this.tag</strong> in effect) is <a id="_idIndexMarker561"/>referring to the <strong class="source-inline">tag</strong> instance <a id="_idIndexMarker562"/>variable that can be accessed via <strong class="source-inline">cow2</strong>. As a result, line 14 creates a new <strong class="source-inline">Tag</strong> object on the heap and stores its reference in the <strong class="source-inline">tag</strong> instance variable of the <strong class="source-inline">Cow</strong> object, overwriting its previous default value of <strong class="source-inline">null</strong>. Note that at this point, given the contrived nature of this example, the <strong class="source-inline">Cow</strong> object is referred to by three different references: <strong class="source-inline">cow1</strong> and <strong class="source-inline">cow2</strong> in <strong class="source-inline">main</strong>; and <strong class="source-inline">cow</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">tagAnimal</strong></span><span class="No-Break">.</span></p>
			<p>Line 15 specifies a <strong class="source-inline">String</strong> literal of <strong class="source-inline">"France"</strong>. As <strong class="source-inline">String</strong> literals are objects, a <strong class="source-inline">String</strong> object is created on the heap. Using the <strong class="source-inline">cow</strong> reference, the <strong class="source-inline">setCountry</strong> method is called, passing down the <strong class="source-inline">String</strong> <span class="No-Break">literal, </span><span class="No-Break"><strong class="source-inline">"France"</strong></span><span class="No-Break">.</span></p>
			<h3>The setCountry method</h3>
			<p>A stack frame for <strong class="source-inline">setCountry</strong> is pushed onto the stack. The <strong class="source-inline">setCountry</strong> declaration aliases the method parameter <strong class="source-inline">country</strong> to refer to the <strong class="source-inline">String</strong> literal, “<strong class="source-inline">France"</strong>, which is passed down <a id="_idIndexMarker563"/>in the method call (line 15). Line 18 initializes <a id="_idIndexMarker564"/>the <strong class="source-inline">country</strong> instance variable to the argument passed down, namely <strong class="source-inline">"France"</strong>. Line 18 explicitly uses the <strong class="source-inline">this</strong> reference because the parameter name and instance variable have the same identifier, <strong class="source-inline">country</strong>. The <em class="italic">this</em> reference refers to <a id="_idIndexMarker565"/>whatever <strong class="source-inline">cow</strong> is referring to, which is the <strong class="source-inline">Cow</strong> object on the heap. This is because the <strong class="source-inline">setCountry</strong> method call (line 15) was executed on the <span class="No-Break">reference </span><span class="No-Break"><strong class="source-inline">cow</strong></span><span class="No-Break">.</span></p>
			<p>Now that we know how methods are pushed onto the stack, let’s examine the memory as we return from these method calls – in other words, as we pop the stack. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.24</em> represents memory after we have exited the <strong class="source-inline">setCountry</strong> method but before we exit the <span class="No-Break"><strong class="source-inline">tagAnimal</strong></span><span class="No-Break"> method:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B19793_08_24.jpg" alt="Figure 8.24 – In-memory representation after the “setCountry” method completes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – In-memory representation after the “setCountry” method completes</p>
			<p>As can be seen from <a id="_idIndexMarker566"/>the preceding figure, the <strong class="source-inline">setCountry</strong> frame has <a id="_idIndexMarker567"/>been popped from the stack. However, the <strong class="source-inline">String</strong> object, <strong class="source-inline">"France"</strong>, remains on the heap because the <strong class="source-inline">country</strong> instance variable from the <strong class="source-inline">Cow</strong> instance object still refers to it. Only objects that have no references pointing to them are eligible for <span class="No-Break">garbage collection.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.25</em> represents the in-memory representation just after <strong class="source-inline">tagAnimal</strong> finishes but before <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> completes:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B19793_08_25.jpg" alt="Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes</p>
			<p>There is very little change in this figure from the previous figure, except that the stack frame for <strong class="source-inline">tagAnimal</strong> has been popped. The <strong class="source-inline">Cow</strong> object on the heap cannot be garbage collected because both <a id="_idIndexMarker568"/>the references, <strong class="source-inline">cow1</strong> and <strong class="source-inline">cow2</strong>, in <strong class="source-inline">main</strong> refer to it. In addition, because the <strong class="source-inline">Cow</strong> object cannot be <a id="_idIndexMarker569"/>removed, neither can the <strong class="source-inline">Tag</strong> or <strong class="source-inline">String</strong> objects. This is because the <strong class="source-inline">Cow</strong> instance variables, <strong class="source-inline">tag</strong> and <strong class="source-inline">country</strong>, refer to them. This figure represents the situation in memory until <strong class="source-inline">main</strong> exits, at which point everything can <span class="No-Break">be reclaimed.</span></p>
			<p>That concludes our discussion on an object’s life cycle. We will now move on and discuss the <span class="No-Break"><strong class="source-inline">instanceof</strong></span><span class="No-Break"> keyword.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor196"/>Explaining the instanceof keyword</h1>
			<p>The <strong class="source-inline">instanceof</strong> keyword enables us to determine the object type that a reference is referring to. That is <a id="_idIndexMarker570"/>why it is so critical to separate the reference from the object. The reference’s type and the object’s type are often very different. In fact, in most cases, they are different. We will discuss <strong class="source-inline">instanceof</strong> in greater detail when we cover inheritance (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>) but also when we discuss interfaces (<a href="B19793_10.xhtml#_idTextAnchor249"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">).</span></p>
			<p>So, for the moment, we will keep it simple – where the reference type and object type are the same. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.26</em> presents one such <span class="No-Break">code example:</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B19793_08_26.jpg" alt="Figure 8.26 – Basic “instanceof” example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – Basic “instanceof” example</p>
			<p>In this figure, line 7 creates a <strong class="source-inline">Dog</strong> object referred to by a <strong class="source-inline">Dog</strong> reference named <strong class="source-inline">dog</strong>. Line 8 creates a <strong class="source-inline">Cat</strong> object referred to by a <strong class="source-inline">Cat</strong> reference named <strong class="source-inline">cat</strong>. Line 9 checks if the object at the end <a id="_idIndexMarker571"/>of the <strong class="source-inline">dog</strong> reference is “an instance of” <strong class="source-inline">Dog</strong>. It is, so line 10 executes. Similarly, line 12 checks to see if the object referred to by <strong class="source-inline">cat</strong> is of the <strong class="source-inline">Cat</strong> type. It is, so line <span class="No-Break">13 executes.</span></p>
			<p>Line 15 is commented out as it generates a compiler error. As <strong class="source-inline">Cat</strong> and <strong class="source-inline">Dog</strong> are completely unrelated classes (lines 3-4), the compiler knows that there is no way a <strong class="source-inline">Cat</strong> reference, namely <strong class="source-inline">cat</strong>, can refer to a <strong class="source-inline">Dog</strong> object. Conversely, a <strong class="source-inline">Dog</strong> reference, such as <strong class="source-inline">dog</strong>, cannot refer to a <span class="No-Break"><strong class="source-inline">Cat</strong></span><span class="No-Break"> object.</span></p>
			<p>We will come back to <strong class="source-inline">instanceof</strong> later in this chapter. For now, let us move on to our next topic, which is closely related to classes: <span class="No-Break">namely, enumerations.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor197"/>Understanding enums</h1>
			<p><strong class="bold">Enumerations</strong>, or <strong class="bold">enums</strong> for short, are a special type of class. Whereas with a class, you can have as many <a id="_idIndexMarker572"/>instances (of the class) as you wish; with enums, the instances are predefined and therefore restricted. Enums are very useful for situations where a finite set of values apply – for example, days of the week, seasons of the year, <span class="No-Break">and directions.</span></p>
			<p>This ensures <em class="italic">type-safety</em> because, with the help of the compiler, only the instances defined are allowed. It is always better to find an issue at compile time than runtime. For example, if you had a method that defined a <strong class="source-inline">String</strong> parameter, namely <strong class="source-inline">direction</strong>, then someone could invoke the method with <em class="italic">"WESTT"</em> (note the incorrect spelling). The compiler would not catch this error as it is a valid <strong class="source-inline">String</strong>, so the error would manifest at runtime. If, however, the method parameter were an enum instead, the compiler would catch it. We will see <span class="No-Break">this shortly.</span></p>
			<p>There are two types of enums: simple and complex. We will discuss <span class="No-Break">them now.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor198"/>Simple enums</h2>
			<p>A simple enum is named as <a id="_idIndexMarker573"/>such because it is, well, simple. This is in the <a id="_idIndexMarker574"/>sense that when you look at the enum, there is very little code present. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.27</em> presents code using a <span class="No-Break">simple enum:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B19793_08_27.jpg" alt="Figure 8.27 – A simple enum"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – A simple enum</p>
			<p>In the preceding figure, the <strong class="source-inline">Water</strong> enum is defined (lines 3-5). The values of an enum are expressed in <a id="_idIndexMarker575"/>capital letters (similar to constants). It is <a id="_idIndexMarker576"/>not mandatory to do this but it is common practice. What this enum is saying is that we have an <strong class="source-inline">enum</strong> named <strong class="source-inline">Water</strong> and there are only two instances allowed, namely <strong class="source-inline">STILL</strong> and <strong class="source-inline">SPARKLING</strong>. In effect, <strong class="source-inline">STILL</strong> and <strong class="source-inline">SPARKLING</strong> are references to the only object instances allowed. The semicolon at the end of line 4 is optional for simple enums. The corresponding semicolon for complex enums is mandatory. The enum values are given ordinal values starting at <strong class="source-inline">0</strong>. So, for <strong class="source-inline">Water</strong>, <strong class="source-inline">STILL</strong> has an ordinal value of <strong class="source-inline">0</strong> and <strong class="source-inline">SPARKLING</strong> has an ordinal value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
			<p>As stated previously, enums are a special type of class. However, there are some differences. One is that <strong class="source-inline">enum</strong> constructors are <strong class="source-inline">private</strong> by default. This includes the default constructor generated by the compiler (as in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.27</em> for <strong class="source-inline">Water</strong>). Contrast this with the default constructor of a class, which has the same access as the class itself. Thus, you cannot instantiate an enum as you would a normal object. This is why line 8 will not compile – the default <strong class="source-inline">enum</strong> constructor generated by the compiler is <strong class="source-inline">private</strong> and therefore inaccessible to <span class="No-Break">external types.</span></p>
			<p>So, if we cannot <strong class="source-inline">new</strong> an <strong class="source-inline">enum</strong>, how do we create an <strong class="source-inline">enum</strong> instance? In other words, where are the constructor calls? <em class="italic">The declaration of the enum values, </em><strong class="source-inline">STILL</strong><em class="italic"> and </em><strong class="source-inline">SPARKLING</strong><em class="italic">, (line 4) are the constructor calls!</em> As they are within the class, they have access to the <strong class="source-inline">private</strong> constructor. These enum values are initialized only once – that is, when the enum is <span class="No-Break">first used.</span></p>
			<p>So, to create an enum (object), use the relevant <strong class="source-inline">enum</strong> value. This is done on line 11, where we now <a id="_idIndexMarker577"/>have a reference, <strong class="source-inline">stillWater</strong>, referring <a id="_idIndexMarker578"/>to the <strong class="source-inline">STILL</strong> instance. Contrast line 11 with line 9 (which does not compile). Attempting to use any other value such as <strong class="source-inline">EXTRA_SPARKLING</strong> will not compile. This is the type safety we discussed previously. Only two instances of <strong class="source-inline">Water</strong> are allowed, <strong class="source-inline">STILL</strong> and <strong class="source-inline">SPARKLING</strong>, and the compiler enforces <span class="No-Break">this rule.</span></p>
			<p>Lines 12 and 13 demonstrate that only one instance of <strong class="source-inline">Water.STILL</strong> is created. As the equivalence operator and the <strong class="source-inline">equals</strong> method both return <strong class="source-inline">true</strong>, there can be only <span class="No-Break">one instance.</span></p>
			<p class="callout-heading">Inherited methods</p>
			<p class="callout">Although inheritance will be discussed in detail in <a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we need to dip into the topic to understand enums. Every class in Java implicitly inherits from a class called <strong class="source-inline">Object</strong>. This means that there are methods in <strong class="source-inline">Object</strong> that you get by default. This is how Java ensures every class has certain important methods. You can accept the version from <strong class="source-inline">Object</strong> or replace it (known as <em class="italic">overriding</em> <span class="No-Break">the method).</span></p>
			<p class="callout">One of these methods that’s inherited from <strong class="source-inline">Object</strong> is <strong class="source-inline">equals</strong>. The version in <strong class="source-inline">Object</strong> compares the references to see if they are equal and returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> depending on that comparison. Essentially, this is the same as using <strong class="source-inline">==</strong> to compare <span class="No-Break">the references.</span></p>
			<p class="callout">Enums implicitly inherit from the <strong class="source-inline">Enum</strong> class (and <strong class="source-inline">Enum</strong> inherits from <strong class="source-inline">Object</strong>, so there is no escaping <strong class="source-inline">Object</strong>!). Thus, enums have access to methods such as <strong class="source-inline">valueOf</strong>, <strong class="source-inline">values</strong>, <strong class="source-inline">ordinal</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">switch</strong> statement (lines 14-20) switches on the <strong class="source-inline">Water</strong> reference, namely <strong class="source-inline">stillWater</strong> (line 14). The <strong class="source-inline">case</strong> label is the unqualified <strong class="source-inline">enum</strong> value (<strong class="source-inline">STILL</strong>, line 15). Line 18 shows <a id="_idIndexMarker579"/>that the qualified <strong class="source-inline">enum</strong> value is <a id="_idIndexMarker580"/>incorrect. Line 19 (and line 21) demonstrate that even though <strong class="source-inline">enum</strong> values have ordinal values, enums are types and <span class="No-Break">not integers.</span></p>
			<p>Several interesting methods in the <strong class="source-inline">Enum</strong> type are available to us due to inheritance. Let’s start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">valueOf(String)</strong></span><span class="No-Break">.</span></p>
			<h3>The valueOf(String) method</h3>
			<p>This is an implicitly <a id="_idIndexMarker581"/>declared method, which, when given <a id="_idIndexMarker582"/>one of the enum constant names, returns that enum instance (line 22). Thus, this method provides a quick and easy way to create an enum instance, once you know the <span class="No-Break">constant name.</span></p>
			<p>Let’s examine how we can iterate over all the enum instances using the <span class="No-Break"><strong class="source-inline">values()</strong></span><span class="No-Break"> method.</span></p>
			<h3>The values() method</h3>
			<p>This is another implicit method. On line 25, we use an enhanced <strong class="source-inline">for</strong> loop to iterate over the enums in the <a id="_idIndexMarker583"/>order they are declared on line 4, namely <strong class="source-inline">STILL</strong> followed <a id="_idIndexMarker584"/>by <strong class="source-inline">SPARKLING</strong>. Once we have an enum instantiated, we can use other methods to get details of that <span class="No-Break">particular enum.</span></p>
			<p>Let’s see how the <strong class="source-inline">ordinal()</strong> method provides the ordinal number for <span class="No-Break">the enum.</span></p>
			<h3>The ordinal() method</h3>
			<p>The <strong class="source-inline">ordinal()</strong> method (line 28) returns <a id="_idIndexMarker585"/>the ordinal value of this enum. The <a id="_idIndexMarker586"/>initial <strong class="source-inline">enum</strong> constant is given an ordinal value of 0; therefore, <strong class="source-inline">ordinal()</strong> for <strong class="source-inline">STILL</strong> returns 0, and <strong class="source-inline">ordinal()</strong> for <strong class="source-inline">SPARKLING</strong> <span class="No-Break">returns 1.</span></p>
			<p>To determine an enum’s name, we can use the <span class="No-Break"><strong class="source-inline">name()</strong></span><span class="No-Break"> method.</span></p>
			<h3>The name() method</h3>
			<p>The <strong class="source-inline">name()</strong> method (line 28) returns the name of this <strong class="source-inline">enum</strong>, exactly as declared in the enum (line 4). For example, <strong class="source-inline">name()</strong> for <strong class="source-inline">STILL</strong> returns <strong class="source-inline">"STILL"</strong> and <strong class="source-inline">name()</strong> for <strong class="source-inline">SPARKLING</strong> returns <strong class="source-inline">"SPARKLING"</strong>. Note that rather than use the <strong class="source-inline">name</strong> method, the better option would <a id="_idIndexMarker587"/>be to override the <strong class="source-inline">toString()</strong> method as<a id="_idIndexMarker588"/> you can customize the <strong class="source-inline">String</strong> that’s displayed (to the user) to be more user-friendly. We will do a lot of this in inheritance (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">).</span></p>
			<p>Now that we have examined simple enums, let’s move on and discuss <span class="No-Break">complex enums.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor199"/>Complex enums</h2>
			<p>As stated earlier, enums are a special type of class where the instances are finite. As simple enums are so straightforward, it can be a little harder to see the class/enum relationship. With complex enums, identifying the relationship between an enum and a class is <span class="No-Break">much easier.</span></p>
			<p>Complex enums have instance <a id="_idIndexMarker589"/>variables, constructors, and methods, so <a id="_idIndexMarker590"/>they are quite similar to classes. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.28</em> presents a complex enum <span class="No-Break">for discussion:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B19793_08_28.jpg" alt="Figure 8.28 – A complex enum"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – A complex enum</p>
			<p>In this figure, we declare <a id="_idIndexMarker591"/>the <strong class="source-inline">WorkDay</strong> enum (lines 3-25). This <strong class="source-inline">enum</strong> encapsulates <a id="_idIndexMarker592"/>that we work 9 to 5, Monday to Friday at the office and 10 to 1 on Saturday from home. Presumably, we try to rest <span class="No-Break">on Sunday!</span></p>
			<p>The <strong class="source-inline">enum</strong> constants are declared from lines 5-13. There is a <strong class="source-inline">private</strong> instance variable called <strong class="source-inline">hoursOfWork</strong> (line 15), which is initialized by the constructor (lines 16-18). Note that the constructor is <strong class="source-inline">private</strong> by default. The accessor method, <strong class="source-inline">getHoursOfWork</strong> (lines 19-21), is how external classes gain access to the <strong class="source-inline">private</strong> instance variable, <strong class="source-inline">hoursOfWork</strong>. The other accessor method, <strong class="source-inline">getWorkLocation</strong> (lines 22-24), assumes that we work from the office every day (a pre-pandemic assumption for sure!). The <strong class="source-inline">SATURDAY</strong> constant (lines 10-13) merits discussion and we will come to <span class="No-Break">that shortly.</span></p>
			<p>Let’s examine line 5 closely: this is <em class="italic">a constructor call</em> to the constructor that’s declared (lines 16-18). In other <a id="_idIndexMarker593"/>words, the <strong class="source-inline">hoursOfWork</strong> instance <a id="_idIndexMarker594"/>variable is set to <strong class="source-inline">"9-5"</strong> for <strong class="source-inline">MONDAY</strong>. The other constants – <strong class="source-inline">TUESDAY</strong>, <strong class="source-inline">WEDNESDAY</strong>, <strong class="source-inline">THURSDAY</strong>, and <strong class="source-inline">FRIDAY</strong> (lines 6-9) – are <span class="No-Break">initialized similarly.</span></p>
			<p>What about <strong class="source-inline">SATURDAY</strong>? Since we haven’t covered inheritance yet, this may be a little tricky. What we are saying is that for Saturday, we only work from home. To do this, we have to replace (“override”) the default <strong class="source-inline">getWorkLocation</strong> method (lines 22-24). The default <strong class="source-inline">getWorkLocation</strong> method returns <strong class="source-inline">"Office"</strong> but our custom <strong class="source-inline">getWorkLocation</strong> (line 12) returns <strong class="source-inline">"Home"</strong> for <strong class="source-inline">SATURDAY</strong>. The <strong class="source-inline">SATURDAY</strong> constant defines a “constant specific class body,” which starts with the curly brace on line 10 and ends with the curly brace on <span class="No-Break">line 13.</span></p>
			<p>Note that the semicolon on line 13 <em class="italic">is</em> required at the end of the complex enum constants, regardless of whether they declare a constant specific class body or not. That particular semicolon (line 13) tells the compiler, “We have now finished defining the <strong class="source-inline">enum</strong> constants, so you can expect instance variables or constructors or methods from <span class="No-Break">here on.”</span></p>
			<p>Now that we have defined our <strong class="source-inline">enum</strong>, let’s use it. Line 28 instantiates <strong class="source-inline">MONDAY</strong>, resulting in the enum constant (line 5) executing the constructor (lines 16-18), thereby initializing <strong class="source-inline">hoursOfWork</strong> for the <strong class="source-inline">MONDAY</strong> instance to <strong class="source-inline">"9-5"</strong>. Line 29 proves this fact by outputting <strong class="source-inline">"9-5"</strong>. Line 30 calls the (default) version of <strong class="source-inline">getWorkLocation</strong> (lines 22-24), thereby outputting <strong class="source-inline">"Office"</strong> to <span class="No-Break">the screen.</span></p>
			<p>Line 31 instantiates <strong class="source-inline">SATURDAY</strong> and outputs <strong class="source-inline">"10-1"</strong> for <strong class="source-inline">hoursOfWork</strong> as that is what is passed into the constructor from line 10. Line 32 invokes the constant-specific version of <strong class="source-inline">getWorkLocation</strong> for <strong class="source-inline">SATURDAY</strong>, which outputs <strong class="source-inline">"Home"</strong> to <span class="No-Break">the screen.</span></p>
			<p>That completes <a id="_idIndexMarker595"/>our discussion on enumerations. Let us now discuss a very useful feature, <span class="No-Break">namely records.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor200"/>Appreciating records</h1>
			<p>Records are a <a id="_idIndexMarker596"/>special type of class, and are considered “data carriers”. They help us avoid typing in copious amounts of boilerplate code. Records are specified using a record declaration where you list the <em class="italic">components</em> of the record. Implicitly generated in the background are a canonical constructor; <strong class="source-inline">toString</strong>, <strong class="source-inline">equals</strong>, and <strong class="source-inline">hashCode</strong> methods and <strong class="source-inline">public</strong> accessor methods for each of the components specified. The accessor methods take on the same names as the components themselves (as opposed to the more traditional <strong class="source-inline">get</strong> methods). Records are best explained by contrasting them to regular classes. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.29</em> presents a normal class with a lot of <span class="No-Break">boilerplate code:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B19793_08_29.jpg" alt="Figure 8.29 - A class with a lot of boilerplate code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 - A class with a lot of boilerplate code</p>
			<p>The <strong class="source-inline">Person</strong> class in<a id="_idIndexMarker597"/> the preceding figure is customized somewhat to map to a record more easily. For example, the class itself is <strong class="source-inline">final</strong> (line 5) and the instance variables, namely <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> (lines 6-7), are also <strong class="source-inline">final</strong>. The fact that the instance variables are <em class="italic">blank final</em>’s (declared as <strong class="source-inline">final</strong> but not initialized at declaration time) means that the instance variables must be initialized in the constructor. This is what the constructor does (<span class="No-Break">lines 10-11).</span></p>
			<p>There are two accessor methods for retrieving the instance variables, namely <strong class="source-inline">name</strong> (lines 13-15) and <strong class="source-inline">age</strong> (lines 16-18). Note that the method names are deliberately not preceded by <strong class="source-inline">get</strong>, in other words, <strong class="source-inline">getName</strong> and <strong class="source-inline">getAge</strong>. This is because, records use the components identifiers for both naming the instance variables <em class="italic">and</em> the <span class="No-Break">accessor methods.</span></p>
			<p>In addition, this<a id="_idIndexMarker598"/> class also has custom versions of <strong class="source-inline">equals</strong>, <strong class="source-inline">hashCode</strong>, and <strong class="source-inline">toString</strong>, lines 20-26, 28-30 and 32-36 respectively. Each of these methods is overriding an inherited version by providing a specific, custom version. This topic of overriding is discussed in detail in Inheritance (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>). The job of <strong class="source-inline">toString</strong> is to return a string containing the instance variables values (the component values). The <strong class="source-inline">equals</strong> method ensures that two records are considered equal if they are of the same type and contain equal component values. The <strong class="source-inline">hashCode</strong> method ensures that equal objects return the same hashcode value (more on this in <a href="B19793_13.xhtml#_idTextAnchor317"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">).</span></p>
			<p>Now let us examine the equivalent record in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.30</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B19793_08_30.jpg" alt="Figure 8.30 - Equivalent record of class from Figure 8.29"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 - Equivalent record of class from Figure 8.29</p>
			<p>Yes – just one line of code! As you can see, this saves us from a lot of boilerplate code. In fact, <em class="italic">Figures 8.29</em> and <em class="italic">8.30</em> are equivalent (by the time the compiler is finished). The two parameters are called components and the preceding one liner leads to the following code being generated in <span class="No-Break">the background:</span></p>
			<ul>
				<li>A <strong class="source-inline">final class</strong> named after the record (<strong class="source-inline">Person</strong> in <span class="No-Break">this example).</span></li>
				<li><strong class="source-inline">private final</strong> instance variables, one for each component, named after <span class="No-Break">the components.</span></li>
				<li>A canonical constructor for initializing the components (<span class="No-Break">instance variables).</span></li>
				<li>Accessor methods, one for each component, named after <span class="No-Break">the components.</span></li>
				<li>Custom <strong class="source-inline">toString</strong>, <strong class="source-inline">equals</strong> and <span class="No-Break"><strong class="source-inline">hashCode</strong></span><span class="No-Break"> methods.</span></li>
			</ul>
			<p>Records are customizable. In other words, we can override (replace) all the default versions if we so wish. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.31</em> presents such <span class="No-Break">a situation.</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B19793_08_31.jpg" alt="Figure 8.31 - canonical and compact constructors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.31 - canonical and compact constructors</p>
			<p>In this figure, we are<a id="_idIndexMarker599"/> customizing the canonical constructor (lines 7-13) as we want to validate the <strong class="source-inline">age</strong> component of the person – if they are younger than 18, that is an error and we generate custom error values. Note again that there are better ways to handle error values but for now, this is fine. Otherwise, the components are initialized to the values <span class="No-Break">passed in.</span></p>
			<p>However, this canonical constructor can be written in an even more concise fashion. The compact constructor (lines 15-19) is replacing the canonical constructor. Compact constructors are a variation of the canonical constructor and are specific to records. Note that there is not even a pair of round brackets on line 15 – the components can be inferred from the component list (line 5). Also, there is no need to initialize the components as per lines 11-12; again, the compiler can do this <span class="No-Break">for us.</span></p>
			<p>Lines 23-26 demonstrate how to use the record <strong class="source-inline">Person</strong> that we have declared. Line 23 declares a <strong class="source-inline">Person</strong> instance referred to by <strong class="source-inline">p1</strong>. Line 24 calls the implicit <strong class="source-inline">toString</strong> provided by the <strong class="source-inline">Record</strong> class (which every record inherits from). Lines 25-26 invokes the two accessor methods; note their names are <strong class="source-inline">name()</strong> and <strong class="source-inline">age()</strong> respectively. The output is in comments on the right of each line (<span class="No-Break">lines 24-26).</span></p>
			<p>As records are so closely related to classes, it is no surprise that records can be used with the <strong class="source-inline">instanceof</strong> keyword. This is what we will examine in <span class="No-Break">record patterns.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor201"/>Record patterns</h2>
			<p>Over the<a id="_idIndexMarker600"/> years, the <strong class="source-inline">instanceof</strong> keyword has evolved past the simple <strong class="source-inline">instanceof</strong>-and-cast idiom to support both type patterns and record patterns. Let us first discuss what a “type pattern” is and “<span class="No-Break">pattern matching”.</span></p>
			<h3>Type patterns and pattern matching</h3>
			<p>In Java 16, <strong class="source-inline">instanceof</strong> was<a id="_idIndexMarker601"/> extended to take a type pattern and perform <a id="_idIndexMarker602"/>pattern matching. Prior to Java 16 the following code <span class="No-Break">was commonplace:</span></p>
			<pre class="source-code">
if(obj instanceof String){ // 'obj' is of type Object    String s = (String)obj;
    System.out.println(s.toUpperCase());
}</pre>
			<p>This code is checking to see if the <strong class="source-inline">Object</strong> reference <strong class="source-inline">obj</strong> is referring to a <strong class="source-inline">String</strong> object and if so, to (safely) cast the reference to a <strong class="source-inline">String</strong> so we can access the <strong class="source-inline">String</strong> methods. Remember, the methods you can access are based on the reference type. However, if the object at the end of the reference is a <strong class="source-inline">String</strong> object then we can safely cast the reference to a <strong class="source-inline">String</strong> and thus access the <strong class="source-inline">String</strong> methods using the new <strong class="source-inline">String</strong> reference. We will discuss this in more detail in Inheritance (<a href="B19793_09.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">).</span></p>
			<p>As of Java 16, we can write the previous code segment more concisely <span class="No-Break">and safely:</span></p>
			<pre class="source-code">
if(obj instanceof String s){ // "String s" - type pattern//    String s = (String)obj; // no longer needed
    System.out.println(s.toUpperCase());
}</pre>
			<p>There are two changes to note. The first one is the use of a type pattern <strong class="source-inline">String s</strong> as part of the <strong class="source-inline">instanceof</strong>. Pattern matching occurs at runtime whereby <strong class="source-inline">instanceof</strong> checks the type against the provided type pattern and if there is a match, performs the cast for us as well. The second change is that, as <strong class="source-inline">instanceof</strong> performs the cast on our behalf, we no longer need to do the cast ourselves. This leads to a more declarative style (where you state what you want rather than how to get what <span class="No-Break">you want).</span></p>
			<p>This leads on <a id="_idIndexMarker603"/>nicely to record patterns which were introduced in Java 21. Prior to record patterns, the following code was required (assuming the <strong class="source-inline">Person</strong> record from <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.30</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
if(obj instanceof Person p){ // type pattern    String name = p.name(); // accessor
    int age     = p.age();  // accessor
    System.out.println(name + "," + age);
}</pre>
			<p> Using record patterns, the previous code can be expressed <span class="No-Break">more concisely:</span></p>
			<pre class="source-code">
if(obj instanceof Person(String sName, Integer nAge))    System.out.println(sName + "," + nAge);
}</pre>
			<p>In this code, <strong class="source-inline">Person(String sName, Integer nAge)</strong> is a record pattern. A record pattern consists of a type, a component pattern list (which may be empty) and an optional identifier. A record pattern does two things for us: firstly, it checks to see if the object passes the <strong class="source-inline">instanceof</strong> test and secondly, disaggregates the record instance into its components. So, in our example, assuming <strong class="source-inline">obj</strong> is referring to a <strong class="source-inline">Person</strong> object, then the local variable <strong class="source-inline">sName</strong> will be initialized to the return value of the <strong class="source-inline">name()</strong> accessor method and the local variable <strong class="source-inline">nAge</strong> will be initialized to the return value from the <strong class="source-inline">age()</strong> accessor method. We deliberately used different identifiers for our local variables to highlight the fact that they do not have to match the component identifiers used in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.30</em>. Note however that the order of the types must match; in other words, the record pattern must specify a <strong class="source-inline">String</strong> variable followed by an <strong class="source-inline">Integer</strong> variable, as that is the order of the component list in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.30</em></span><span class="No-Break">.</span></p>
			<p>That completes our discussion on records and indeed concludes <a href="B19793_08.xhtml#_idTextAnchor168"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. Now, let’s put that knowledge into practice to reinforce the concepts <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor202"/>Exercises</h1>
			<p>Classes, objects, and enums are great for enhancing our Mesozoic Eden software. In these exercises, you will be creating classes to represent different entities in our park and using enums to define fixed sets <span class="No-Break">of constants:</span></p>
			<ol>
				<li>We have many types of dinosaurs in our park, each with unique characteristics. Define a class called <strong class="source-inline">Dinosaur</strong> with properties such as name, age, <span class="No-Break">and species.</span></li>
				<li>Our park’s heart and soul lie in its employees. Create a class called <strong class="source-inline">Employee</strong> that encapsulates properties such as name, job title, and years <span class="No-Break">of experience.</span></li>
				<li>With these classes in place, create some instances of <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> and practice manipulating these objects. It’s hard for me to provide more details for this exercise, but for example, you could create a new class called <strong class="source-inline">App</strong>. Then, in this class, you could create a few instances of <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong>. If you want to go wild, you can add a method that takes  <strong class="source-inline">Dinosaur</strong> as an argument and then prints the information (such as its name, age, and so on) of this dinosaur. Of course, you could do the same thing <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Employee</strong></span><span class="No-Break">.</span></li>
				<li>The “park” itself can be thought of as an object with its own properties and behavior. Design a <strong class="source-inline">Park</strong> class that contains methods for opening and closing the park, adding or removing dinosaurs, and so on. You can also consider giving it an array of employees and an array <span class="No-Break">of dinosaurs.</span></li>
				<li>The food we serve to our dinosaurs varies greatly. Define a class for <strong class="source-inline">Food</strong> with properties such as name, nutritional value, <span class="No-Break">and cost.</span></li>
				<li>As you know, safety is our main priority. For obvious safety reasons, our dinosaurs are housed in different enclosures. Create an <strong class="source-inline">Enclosure</strong> class that contains an array of <span class="No-Break"><strong class="source-inline">Dinosaur</strong></span><span class="No-Break"> objects.</span></li>
				<li>To add more clarity, let’s define an enumeration for dinosaur types, such as herbivore, carnivore, <span class="No-Break">and omnivore.</span></li>
				<li>A park visit isn’t complete without a ticket. Create a <strong class="source-inline">Ticket</strong> class with properties such as price, visitor’s name, and <span class="No-Break">visit date.</span></li>
			</ol>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor203"/>Project – Mesozoic Eden park manager</h1>
			<p>In this project, you’ll be creating a fully interactive console application known as Mesozoic Eden park manager. This application allows the park manager to oversee and manage the various aspects of the dinosaur park. The park manager can use this application to <a id="_idIndexMarker604"/>efficiently manage multiple dinosaurs, park employees, and park tickets. Some of the key features of this system should be <span class="No-Break">as follows:</span></p>
			<ol>
				<li>The ability to create, edit, or remove dinosaur profiles, park employee profiles, and <span class="No-Break">park tickets.</span></li>
				<li>A real-time tracking system that monitors the location and status of the dinosaurs within <span class="No-Break">the park.</span></li>
				<li>A fundamental roster system to organize and manage park <span class="No-Break">employee schedules.</span></li>
				<li>A robust ticketing system to manage guest admissions and ensure the park maintains <span class="No-Break">optimal capacity.</span></li>
				<li>The system should also handle special scenarios such as emergencies or VIP <span class="No-Break">guest visits.</span></li>
			</ol>
			<p>This might sound like a lot. So, here’s a step-by-step guide to <span class="No-Break">achieve this:</span></p>
			<ol>
				<li><strong class="bold">Expand the data structures</strong>: Start working from the <strong class="source-inline">Dinosaur</strong> and <strong class="source-inline">Employee</strong> classes. Also, add a class called <strong class="source-inline">Guest</strong>. Each class should include more properties <span class="No-Break">and methods.</span></li>
				<li><strong class="bold">Enhance initialization</strong>: Create the necessary data initialization to support multiple dinosaurs, employees, and ticket types. This could involve creating arrays or lists of <strong class="source-inline">Dinosaur</strong>, <strong class="source-inline">Guest</strong>, and <span class="No-Break"><strong class="source-inline">Employee</strong></span><span class="No-Break"> objects.</span></li>
				<li><strong class="bold">Implement interaction</strong>: Implement an interactive console-based interface using the <strong class="source-inline">Scanner</strong> class. This interface should provide the park manager with a variety of options to manage <span class="No-Break">the park.</span></li>
				<li><strong class="bold">Enhance menu creation</strong>: The menu should now include options to manage multiple dinosaurs, employees, and tickets. Each option should correspond to a particular function in <span class="No-Break">the program.</span></li>
				<li><strong class="bold">Handle actions</strong>: Each menu item should trigger a function. For example, selecting the <strong class="bold">Manage Dinosaurs</strong> option could trigger a function to add, remove, or edit <span class="No-Break">dinosaur profiles.</span></li>
				<li><strong class="bold">Exit the program</strong>: Provide an option for the user to exit <span class="No-Break">the program.</span></li>
			</ol>
			<p>Here is a<a id="_idIndexMarker605"/> starting <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
import java.util.Scanner;public class Main {
    // Use Scanner for reading input from the user
    Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        Main main = new Main();
        main.start();
    }
    public void start() {
        // This is the main loop of the application. It
          will keep running until the user decides to exit.
        while (true) {
            displayMenu();
            int choice = scanner.nextInt();
            handleMenuChoice(choice);
        }
    }
    public void displayMenu() {
        System.out.println("Welcome to Mesozoic Eden Park
          Manager!");
        System.out.println("1. Manage Dinosaurs");
        System.out.println("2. Manage Park Employees");
        System.out.println("3. Manage Tickets");
        System.out.println("4. Check Park Status");
        System.out.println("5. Handle Special Events");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }
    public void handleMenuChoice(int choice) {
        switch (choice) {
            case 1:
                // manageDinosaurs();
                break;
            case 2:
                // manageEmployees();
                break;
            case 3:
                // manageTickets();
                break;
            case 4:
                // checkParkStatus();
                break;
            case 5:
                // handleSpecialEvents();
                break;
            case 6:
                System.out.println("Exiting...");
                System.exit(0);
        }
    }
}</pre>
			<p>The commented-out method calls are placeholders for methods you need to implement according to<a id="_idIndexMarker606"/> your data structures <span class="No-Break">and functionality.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor204"/>Summary</h1>
			<p>In this chapter, we started our discussion by differentiating objects and classes. Classes are similar to a plan of a house, whereas an object is the (built) house itself. We create an object using the <strong class="source-inline">new</strong> keyword and manipulate the object using its reference. Differentiating the reference from the object is very important going forward. A useful analogy is that the reference is like a remote control and the object is <span class="No-Break">the TV.</span></p>
			<p>Constructors are special methods that are used when constructing an object. The constructor is a method that has the same name as the class but with no return type. There is always a constructor present – if you don’t provide one, the compiler intervenes and inserts the default constructor. The constructor is typically used to initialize the <span class="No-Break">instance variables.</span></p>
			<p>Every object gets a copy of the instance members (variables and methods). Class members are marked as <strong class="source-inline">static</strong>, and are shared by all instances. When accessing an instance member, we use the reference but when accessing a class member, we use the class name. Dot notation applies to <span class="No-Break">both syntaxes.</span></p>
			<p>The <strong class="source-inline">this</strong> reference is a special reference available to us in instance methods. It refers to the object instance responsible for the method call. Consequently, it is dynamic since its value depends on the reference used to invoke the method. It is not available to class (<span class="No-Break"><strong class="source-inline">static</strong></span><span class="No-Break">) methods.</span></p>
			<p>Access modifiers apply at both the top (class/interface/record) level, and the member level. At the top level, <strong class="source-inline">public</strong> or package-private access applies. Package-private is achieved by not specifying any keyword at all and ensures that the top-level construct is visible within the same package only. If the top-level construct is <strong class="source-inline">public</strong>, then it is available everywhere; there are <span class="No-Break">no restrictions.</span></p>
			<p>Members (variables/methods) can, in addition to <strong class="source-inline">public</strong> and package-private (with the same semantics), be <strong class="source-inline">private</strong> and <strong class="source-inline">protected</strong>. <strong class="source-inline">private</strong> means that the member is visible within the class only. <strong class="source-inline">protected</strong> is similar to package-private except that subclasses, regardless of package, can access <span class="No-Break">the member.</span></p>
			<p>Encapsulation is one of the cornerstones of OOP. It means that a class can hide its data from external misuse; this is often called “data hiding.” In Java, it is achieved by marking data as <strong class="source-inline">private</strong> and providing <strong class="source-inline">public</strong> accessor/mutator (get/set) methods to manipulate the data. The important concept here is that external code has to access <strong class="source-inline">private</strong> data via your <strong class="source-inline">public</strong> methods. Thus, by using conditional logic in your <strong class="source-inline">public</strong> methods, you can prevent your data from <span class="No-Break">being corrupted.</span></p>
			<p>However, the principle of “private data, public methods” only goes so far. When returning a reference to a <strong class="source-inline">private</strong> object, Java’s call by value mechanism returns a copy of that reference. Thus, the <strong class="source-inline">private</strong> object is now <em class="italic">directly</em> accessible via external code. Advanced encapsulation combats this by copying the <strong class="source-inline">private</strong> object and returning the reference to the copy object. Thus, your <strong class="source-inline">private</strong> object is still private and safe from <span class="No-Break">external interference.</span></p>
			<p>Understanding an object’s life cycle is extremely beneficial. Local variables live on the stack, whereas objects and instance variables reside on the heap. When an object no longer has any references referring to it, it is eligible for garbage collection. Garbage collection is an automatic process run by the JVM, at a time of the JVM’s choosing. When the garbage collector runs, objects eligible for garbage collection are removed and the heap space <span class="No-Break">is reclaimed.</span></p>
			<p>The <strong class="source-inline">instanceof</strong> keyword enables us to determine the object type that a reference is referring to. This will be very useful <span class="No-Break">going forward.</span></p>
			<p>Enumerations (enums) are closely related to classes in that enums are simply classes, where the number of instances are finite and specified. They are very useful for ensuring type safety, whereby the compiler flags an error as opposed to discovering the error <span class="No-Break">at runtime.</span></p>
			<p>Enums are categorized into two separate types: simple and complex. Simple enums just specify the constant values; the compiler synthesizes the default constructor. All enum constructors are <strong class="source-inline">private</strong> by default. Thus, external classes cannot <strong class="source-inline">new</strong> them – the constants that are defined are, in fact, the constructor calls. Complex enums look very similar to classes as they have instance variables, (explicit) constructors, <span class="No-Break">and methods.</span></p>
			<p>Records are useful when you have classes with a lot of boilerplate code. The components of the record are specified in the record declaration. The compiler, in the background, generates the instance variables, canonical constructor, accessor methods, <strong class="source-inline">toString</strong>, <strong class="source-inline">equals</strong>, and <strong class="source-inline">hashCode</strong> methods. Records are <strong class="source-inline">final</strong>, as are the instance variables (components). A compact constructor is a more concise variation of the <span class="No-Break">canonical constructor.</span></p>
			<p>That completes our discussion of classes, objects, and enums. We will now move onto another important OOP <span class="No-Break">chapter: inheritance.</span></p>
		</div>
	</body></html>