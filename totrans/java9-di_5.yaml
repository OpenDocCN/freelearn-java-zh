- en: Scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On this journey, we've learned dependency injection concepts in Java 9, Spring,
    and Google Guice, with the help of examples.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Spring*, and [Chapter 4](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Google Guice,* we came across the word scope,which is a very important
    element of Spring beans and Google Guice. So, let's understand what a scope is,
    and why it is important when talking about dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will first learn about various scopes provided by Spring,
    and how they can be defined for Spring beans. We will also learn the relation
    between bean scope and dependency injection. Finally, we will look into the scopes
    available in Google Guice. The topics we are going to cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to bean scopes in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define a bean scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection and bean scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose a bean scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes in Google Guice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to bean scopes in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection with Google Guice,* we learned about different Spring modules along
    with dependency injection. In Spring, beans are the backbone of an application,
    and they are managed by a Spring IOC container. A bean is a class or object that
    is created using the configuration of metadata that we can pass to an IOC container.
    Before learning about scope, let's define a bean in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Bean definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The metadata of a **bean** has its own properties with independent bean definitions.
    Some of these bean definitions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: This will be used to create a bean, and it is mandatory to mention
    a class name for which we are supposed to create a bean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: If we want to define different aliases for the bean, then we use
    the `name` attribute, with the help of a separator, such as a comma (`,`) or semicolon
    (`;`). When we have XML-based configuration, we can use the `name` and/or `id`
    attribute as an identifier for a bean. A bean with an `id` attribute is preferred,
    because it is mapped with an actual XML ID element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor-arg**: A constructor argument is used to inject dependencies
    by passing a parameter as an argument in a constructor, which we saw in [Chapter
    3](part0066.html#1UU540-255b24dd0eb24162a557b7d0d84b0b16), *Dependency Injection
    with Spring*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: We can directly pass properties with key-value pairs in a Spring
    bean for injecting. This is useful sometimes if we need to pass certain fixed
    values to a bean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autowiring mode**: Autowiring can be used to reduce the use of properties
    and constructor arguments. To enable autowiring mode, we need to use the `autowire`
    attribute in a Spring bean. Attributes can have values such as `byName`, `byType`,
    and `constructor`*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy initialization mode**: By default, a Spring bean is created with a singleton
    scope, which initializes all the properties in eager mode. If a bean is defined
    with lazy mode, then an IOC container creates a bean instance the first time the
    request comes, rather than during the startup process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initialization method**: Spring initialization works after all the properties
    are set by an IOC container. In XML-based configuration, we can define an `init`
    method by defining an `init-method` attribute. The `init` method should be void,
    and without arguments. A `@PostConstruct` annotation can be used for initializing
    methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destruction method**: On completion of a bean lifecycle, if we have to close
    resources or want to perform actions before destruction of a bean, we can use
    the `destroy-method` attribute of a bean in XML configuration. The `@PreDestroy`
    annotation is also used instead of the XML attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following configuration file contains different types of bean definition syntax
    and for that, the `application-context.xml` file could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Lazy instantiation is most effective when the scope is **singleton**. With the **prototype**
    scope, a bean initializes with lazy mode by default.
  prefs: []
  type: TYPE_NORMAL
- en: Spring scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have understood how a bean definition works with different attributes, and
    **s****cope** is one of the attributes in a bean definition. Before going on to
    learn about scope types, one question comes to mind: what are scopes?'
  prefs: []
  type: TYPE_NORMAL
- en: If we look from a Spring perspective, the meaning of **scope** is, *to characterize
    the life cycle of a bean and define visibility of that bean within a specific
    context in which the bean is utilized*. When the scope of the object ends, it
    will be considered **out of scope** and can no longer be injected into different instances.
  prefs: []
  type: TYPE_NORMAL
- en: From the **The Oxford English Dictionary**, scope means "*the extent of the
    area or subject matter that something deals with or to which it is relevant*."
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring has seven scopes, and out of them, five are used for web application
    development. The following is a diagram of **Bean Scopes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Singleton scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each bean created by a Spring container has a default **Singleton** scope; Spring
    treats it as one instance of the bean, and it is served for each request for that
    bean from the cache inside the container. In dependency injection, a bean defined
    as a singleton is injected as a shared bean from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: A **Singleton** bean scope is restricted to the Spring container, compared to
    this Singleton pattern in Java, where only one instance of a specific class will
    ever be created per `ClassLoader`. This scope is useful in web applications as
    well as standalone applications, and stateless beans can also utilize a **Singleton**
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the off chance that three beans have distinctive IDs but the same class
    with a **Singleton** scope, at that point, three instances will be made of that
    class and in terms of bean ID, as only one instance of the singleton bean is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.gif)'
  prefs: []
  type: TYPE_IMG
- en: Prototype scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to create multiple instances of a bean, then we use the prototype
    scope. A `prototype` scoped bean is mostly used for stateful beans. So, on each
    and every request, a new instance of the bean will be created by the IoC container.
    This bean can be injected into another bean, or used by calling a `getBean()`
    method of a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, a container does not maintain the record of a `prototype` bean after initialization.
    We have to implement a custom `BeanPostProcessor` to release the resources occupied
    by the prototype bean. A `destroy` method of the life cycle is not called in the
    case of a prototype scope, only initial `call-back` methods are called for all
    the objects irrespective of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we have seen **Singleton** and Prototype scopes. Both can be used in
    standalone and web applications, but there are five more scopes that only work
    in web applications. If we used these scopes with `ClassPathXmlApplicationContext`,
    then it will throw an `IllegalStateException` for an unknown scope.
  prefs: []
  type: TYPE_NORMAL
- en: To use the request, session, global session, application, and websocket scopes,
    we need to use a web-aware application context implementation (`XmlWebApplicationContext`).
    Let's look at all the web scopes in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Request scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a web application, every HTTP request from a client gets a new bean instance
    if the bean is scoped as a **request**. On an HTTP request completion, a bean
    will immediately be considered out of scope, and memory will be released. If a
    server has 100 concurrent requests, then there will be 100 distinct instances
    of a bean class available. If there is any change in one instance, it will not
    affect other instances. Following is an image of the request scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Session scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **session** is a group of interactive information, also known as a *conversion*
    between client and server within a specific time frame on a website. In an **Apache
    Tomcat** server, the default time frame of one session is 30 minutes, which includes
    all the operations made by a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Spring session bean scope is similar to an HTTP session; an IoC container
    creates a new instance of a bean for each user session. On user logout, its session
    bean will be out of scope. Like a request, if 50 users are concurrently using
    a website, then a server has 50 active sessions, and a Spring container also has
    50 different instances of a bean class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous image illustrates that all HTTP requests from the user are included
    in a single session, and all requests may have lifetime access of a single bean
    instance in that session scope. Session instances are destroyed, as before long,
    the session is destroyed/quit on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Application scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application scope only works on a web application. An IoC container creates
    single instances of bean definitions per web application during runtime. Following
    are two ways to define the application scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as the Singleton scope, but the main difference is that a Singleton
    scope bean is worked as a Singleton per `ApplicationContext`, whereas an application
    scope bean is worked as Singleton per `ServletContext`. These beans are stored
    as attributes in `ServletContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Global session scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **global session scope** is similar to a session scope. The only difference
    is that it will be used in a Portlet application. Global sessions can be used
    when we have an application that is built on the JSR-168, JSR-286, and JSR-362
    portal specifications. There will be multiple sites/applications that work under
    a single portlet container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Portlet containers have different portlets, and all have their own portlet
    context, as well as portlet session. Portlet sessions work with the portlet boundary,
    but when we have to share common information between multiple sites, then we can
    define beans with a `globalSession` scope. Spring has separate portlet MVC modules
    for portal applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider an intranet application that consists of server sites. Users could
    be members of multiple sites. In such scenarios, user preferences with common
    information can be stored as global sessions for the logged-in user, and the same
    will be utilized between multiple sites and portlets. The following image shows
    how G**lobal Sessions** are shared between portlet containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: websocket scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This scope is used when two-way communication between a customer and remote
    site is enabled using the **websocket** protocol. It is mainly useful when applications
    are used by multiple users with simultaneous actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, an HTTP request is used to do an initial handshake, and once it is established,
    the TCP port remains open for a client and server for communication. The websocket
    bean is similar to a singleton, and injected into Spring controllers. The life
    of a websocket bean is longer compared to a typical websocket session. The following
    example shows how a websocket is declared using Scope annotation and traditional
    XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to define a bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we understand the different scopes and their usage. Now it is time to see
    how we can use them in coding. We will mainly look at singleton and prototype
    bean scopes with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides two different ways to write an application: one is traditional
    XML metadata configuration, and the second is Java configuration using annotations.
    Let''s look at how XML configuration is used.'
  prefs: []
  type: TYPE_NORMAL
- en: XML metadata configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, bean configuration is declared in an XML file of our choice. This
    file is used by an IoC container to initialize the application context, and at
    the same time, all bean definitions are initialized based on the provided attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using the singleton scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The singleton scope is a very common scope used in major applications. Here,
    we will start to use the singleton scope. First, we will create a bean class named
    `EmailService`, which consists of a simple `getter/setter` method and `Constructor`
    method with a `print` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Spring application requires a context file that describes the configuration
    of the beans. Configuration of the previously mentioned bean class can be written
    as follows in `application-context.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the bean definition, we have mentioned `emailService` as an ID attribute,
    and a class name provided as `com.packt.springbean.EmailService` to point our
    bean class to the package path. For learning purposes, we have used a `scope`
    attribute with a `singleton` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `scope` attribute is not defined in the bean definition, then by default,
    a Spring IoC container creates an instance of the bean with a singleton scope.
    Now, let''s check what will happen if we try to access the `EmailService` bean
    two times. For that, let''s use the `SpringBeanApplication.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In a standalone application, the Spring context is acquired using `ClassPathXMLApplicationContext`
    by passing a context file as a parameter in a String array. A Spring IoC container
    initializes the application context, and returns an object of it.
  prefs: []
  type: TYPE_NORMAL
- en: A bean is retrieved by passing a bean `name` in the form of an argument in the `getBean()`
    method. In the preceding example, we get two instances of the `EmailService` bean
    using the `getBean()` method. But, the first time we are only setting the value
    into a bean and we are getting the same by writing `printing message`. Even a
    constructor creates an object of bean only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when we run `SpringBeanApplication`, the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since the `EmailService` bean has the Singleton scope, the second instance of `emailServiceInstanceB`
    prints the message with a value set by `emailServiceInstanceA` as well, even though
    it is `get` by a new `getBean()` method. The Spring IoC container creates and
    maintains only a single instance of a bean per container; no matter how many times
    you reclaim it with `getBean()`, it will continuously return the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Using the prototype scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, the **prototype scope** is used to get a new instance of a
    bean every time when requested. To understand prototype, we will take the same
    bean class, `EmailService`, and we just need to change the value of the scope
    attribute for the `emailService` bean in `application-context.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code used for the singleton scope will the same as before, while the output
    of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From output, the `EmailService` constructor is called two times, and gets a
    new instance for each `getBean()` method called. For the second instance, `emailServiceInstanceB`,
    we get a `null` value, because we haven't set any value for that.
  prefs: []
  type: TYPE_NORMAL
- en: Java configuration using annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once annotation was introduced in `Java 1.5`, Spring Framework also added support
    for annotations in version 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides several standard annotations, which are used on stereotype classes
    in the application. By using such annotations, we don't need to maintain bean
    definitions in XML files. We just need to write one line, `<context:component-scan>`,
    in the Spring XML configuration for a scanning component, and the Spring IoC container
    scans the defined package to register all the annotated classes and their bean
    definitions in the application context.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, `@Component` and `@Service` are used to scan beans in the provided
    package. Here, we will use `@Service` annotation, because the `@Service` annotation
    is too specialized for the `@Component` annotation. It doesn’t give us any extra
    behavior than the `@Component` explanation, but it’s better to choose `@Service`
    over `@Component` in service-layer classes, since it indicates expectations way
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'For singleton and prototype beans, our `application-context.xml` file will
    be the same, and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Singleton scope with annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@Scopes` annotation is used to indicate the scope of a bean, either singleton, prototype, request,
    session, or a few custom scopes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the `EmailService` bean class a singleton, we need to annotate the
    class with `@Scope` and `@Service`. So, our `EmailService` class will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We will use the same `SpringBeanApplication.java` class to test our annotation
    changes, and the output will also be the same as the XML configuration example.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype scope with annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use prototype scope with annotations, we only need to mention `prototype` in
    the `@Scope` annotation instead of `singleton`. So, our `EmailService.java` class
    will be the same, except we change the annotation value, and it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As like the XML example output, this will also create a new instance each time
    it is called. In a similar way, we can use other scopes, such as request, session,
    application, and global session, using XML metadata or annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection and the bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We understand each scope has a different boundary. Now, we will write one REST
    controller to understand how different scope beans are injected to other reference
    beans by writing simple Spring boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, the **StudentController** has injected the reference
    to all other classes. The `ClassDetail` class with the `session` scope has two
    references to singleton and prototype, and the student application contains a
    few other associations between classes as well. **Autowired** annotation is utilized
    to fulfill dependency between beans. Just to clarify, Spring controllers are always
    created with the singleton scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we are writing a Spring boot application with REST. Will will have to create
    a maven project and the configuration of `pom.xml` file would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We start with the `StudentController` class, injected with four beans that
    have different scopes defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand each scope, I have created simple interfaces with scope names
    for better visualization, and this will also help when we add the dependency of
    one bean into another bean. `@Scope` annotation is utilized to mention the `StudentDetail`
    bean as a singleton and it is implementing the `SingletonBeanScope` interface.
    This class has been injected with a `PrototypeBeanScope` bean. Moreover, we are
    printing incremental values of the static integer variable` increment`  to track
    how many times the singleton bean is initialized in the constructor. The same
    is written for all other bean classes. `StudentDetail.java` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`SubjectPreference.java` is defined with a prototype bean scope as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The request scope and session scope are only worked in a web-aware application
    context. `Address.java` is annotated with the request scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, the `session` scope is used in the `ClassDetail.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: An extra `proxyMode` attribute is utilized to make an intermediary, which will
    be injected as a dependency by Spring, and Spring starts the `target` bean when
    it's required. Note that there is no dynamic request when the web application setting
    is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a successful run, we will see the following console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Following is the analysis of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: The `StudentDetail` bean is created only once, which is, at most, a singleton
    class, and it loads during application startup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subsequently, the `SubjectPreference` bean is created with the prototype scope.
    It is injected into the `StudentDetail` singleton bean and, because of that, it
    also initializes with it. Here, we all know that the prototype scope bean is created
    each time it is called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, the `StudentDetail` singleton bean depends on `PrototypeBeanScope`, which
    is implemented by the `SubjectPreference` class, and dependencies are resolved
    at instantiation time. So, the first instance of `SubjectPreference` is created,
    and then it will be injected into the `StudentDetail` singleton bean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring container is initializing the `StudentController` class only one
    time because `controller` is, by default, a singleton.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As `StudentController`  has injected a reference of the `PrototypeBeanScope`,
    once again an instance of the `SubjectPreference` bean is created. Controllers
    also have a reference of the `SingletonbeanScope` bean, but an instance of that
    is not created again, because it is already loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of `SessionScopeBean` and `RequestScopeBean` is not created, because
    there is no HTTP request or HTTP session at this instant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check the `request` and `session` scope, go to `http://localhost:8080` in
    a browser and observe the console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.gif)'
  prefs: []
  type: TYPE_IMG
- en: The log shows that one instance each for the `ClassDetail` and `Address` classes
    are created because they define with the session and request scope respectively.
    Both the `ClassDetail` and `Address` classes also injected `PrototypeBeanScope`,
    and because of that, the `SubjectPreference` instance has been created two more
    times—a total of four times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `http://localhost:8080 URL again`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.gif)'
  prefs: []
  type: TYPE_IMG
- en: It will create one more instance of the `Address` class, which is marked as
    a request scope, and a new instance of `SubjectPreference` class with prototype
    scope will be created. It will not create an instance of the `ClassDetail` class
    because we have not created a new session, our session is still going.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initiate a new session, we need to close the browser and go to the URL.
    Open another browser, and go to the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.gif)'
  prefs: []
  type: TYPE_IMG
- en: By doing this, two new sessions will be created, and a total of three instances
    are created for the  `ClassDetail` class, along with two instances of the `Address`
    class, and two instances of the `SubjectPreference` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the event that we need to inject a request scope bean into another bean of
    a longer-lived scope, you may select to inject an AOP proxy in the scoped bean.
    We require to injecting an intermediary object that exposes the same public interface
    as the scoped object. But that can recover the target object from the applicable
    scope and provide method calls onto the genuine object.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the bean is going through an intermediate proxy that is serializable.
    The same bean subsequently can re-obtain the `target` singleton bean by doing
    deserialization. `<aop:scoped-proxy/>` is used by the beans that are marked as
    a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, when using the prototype bean scope, each method calls on the
    shared proxy will lead to the creation of a new target instance which the call
    is, at that point, being sent to.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a CGLIB-based class proxy is made when the Spring holder makes a proxy for
    a bean that is checked up with the `<aop:scoped-proxy/>` component.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose a bean scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each scope in Spring has a different feature, and it falls to us as programmers
    to know how to utilize those scopes.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, if we have a stateless object and there is no impact on the
    object creation process then the use of a scope is unnecessary. In contrast, if
    an object has state then it is advisable to use a scope such as singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dependency injection is in business, then the singleton scope is not adding
    much value. In spite of the fact that singletons spare object creation (and afterward
    garbage collection), synchronization requires us to initialize a singleton bean.
    Singletons are most valuable for:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of stateful beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lookup of objects that are costly to build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database association pool object that is associated with resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we consider concurrency, classes defined with a singleton or session scope
    must be thread-safe, and anything injected in these classes should be thread-safe.
    On the other hand, the request scope cannot be thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes in Google Guice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the scopes we have seen for the Spring Framework similarly exist in
    Google Guice. Scope defines that code should work in a specific context, and in
    Guice, the Injector manages the scope context. **Default scope** (No Scope), **singleton**,
    **session**, and **request** are the main scopes in Guice.
  prefs: []
  type: TYPE_NORMAL
- en: Default scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Guice injects a new and separate instance of an object for each
    dependency (similar to the prototype scope in Spring), whereas Spring provides
    singletons by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example of a house that has a family with three people,
    all with their own personal car. Every time they call the `injector.getInstance()`
    method, a new instance of a car object is available for each family member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Singleton scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to create only one instance of the class, then the `@Singleton`
    annotation can be used to mark the implementation class. As long as a the singleton
    object lives, the injector lives in context, but in the same application, it is
    possible to have multiple injectors, and in that case, each injector is associated
    with a different instance of a singleton-scoped object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to configure a scope is by using a bind statement in the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use linked binding in a module, then the scope only applies to binding
    the source, not to the `target`. For example, we have a class `UserPref` that
    implements both `Professor` and `Student` interfaces. This will create two instance
    of type: one for `Professor` and another one for `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is because the singleton scope applies at the binding type level, which
    is `Professor` and `Student`, not at the target type, `UserPref`.
  prefs: []
  type: TYPE_NORMAL
- en: Eager singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Guice provides special syntax for making an object that has the singleton scope,
    and is initialized to eager mode rather than lazy mode. Following is the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Eager singletons uncover initialization issues sooner, and guarantee end users
    get a reliable, smart encounter. Lazy singletons empower a quicker edit-compile-run
    development cycle. We can utilize the stage enum to indicate which procedure ought
    to be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table defines stage-wise use of syntax of the singleton and supported
    object initialize mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax** | **PRODUCTION** | **DEVELOPMENT** |'
  prefs: []
  type: TYPE_TB
- en: '| @Singleton | eager* | lazy |'
  prefs: []
  type: TYPE_TB
- en: '| .asEagerSingleton() | eager | eager |'
  prefs: []
  type: TYPE_TB
- en: '| .in(Singleton.class) | eager | lazy |'
  prefs: []
  type: TYPE_TB
- en: '| .in(Scopes.SINGLETON) | eager | lazy |'
  prefs: []
  type: TYPE_TB
- en: Guice eagerly creates singleton instances only for the modules that are defined
    as singleton.
  prefs: []
  type: TYPE_NORMAL
- en: '`@SessionScoped`  and `@RequestedScoped` scope functionality and behavior is
    the same as Spring in Guice, and it will only be applicable when used in a web
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter with a Spring bean definition attribute, which is important
    to learn as the whole IoC container is a relay on bean initialization. After that
    we learned the classification of scope with syntax.
  prefs: []
  type: TYPE_NORMAL
- en: On our journey, we learned how scope is configured using XML metadata and Java
    configuration in Spring. Without dependency injection, we cannot complete the
    chapter. That's why, by writing a **Spring Boot** application, we try to understand
    how the main scopes work in standalone as well as in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: We intentionally skipped the scope topic in [Chapter 4](part0096.html#2RHM00-255b24dd0eb24162a557b7d0d84b0b16),
    *Dependency Injection with Google Guice*. So, we have covered the Google Guice
    scope in this chapter with basic scopes. Spring and Google Guice have almost the
    same scope, but the default behavior of object initialization is different. Spring
    creates instances with the singleton, whereas Guice creates with the prototype
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at an important feature called **aspect-oriented
    programming** in Spring.
  prefs: []
  type: TYPE_NORMAL
