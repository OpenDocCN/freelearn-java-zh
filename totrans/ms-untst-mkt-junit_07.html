<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Unit Testing the Web Tier"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Unit Testing the Web Tier</h1></div></div></div><div class="blockquote"><blockquote class="blockquote1"><p class="calibre20">"If you don't like unit testing your product, most likely your customers won't like to test it either."</p><p class="calibre20">—Anonymous</p></blockquote></div><p class="calibre9">Enterprise applications follow the <span class="strong"><strong class="calibre10">N-tier architecture model</strong></span><a id="id586" class="calibre1"/> to handle numerous nonfunctional concerns such as upgradability, scalability, and maintainability. The best design approach is to decouple the tiers from each other; this allows scaling out a tier without affecting another tier, or refactoring code in one tier without affecting the other tiers. Usually, any web application contains three tiers: presentation, business logic, and a database tier. This chapter deals with unit testing the web tier or presentation layer. The next chapters cover the application and database layers.</p><p class="calibre9">The following topics will be covered in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit testing a servlet controller in MVC</li><li class="listitem">Understanding what to test in the presentation layer</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Unit Testing the Web Tier">
<div class="book" title="Unit testing servlets"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec39" class="calibre1"/>Unit testing servlets</h1></div></div></div><p class="calibre9">
<span class="strong"><strong class="calibre10">Model View Controller</strong></span> (<span class="strong"><strong class="calibre10">MVC</strong></span>) is a widely used web development pattern. MVC pattern defines three interconnected components: model, view, and controller.</p><p class="calibre9">The model represents<a id="id587" class="calibre1"/> the application data, logic, or business rules.</p><p class="calibre9">A view is a <a id="id588" class="calibre1"/>representation of information <a id="id589" class="calibre1"/>or model. A model can have multiple views; for example, the marks of a student can be represented in a tabular format or on a graphical chart.</p><p class="calibre9">The controller <a id="id590" class="calibre1"/>accepts the client request and initiates commands to either update the model or change the view.</p><p class="calibre9">The controller controls the flow of the application. In JEE applications, a controller is usually implemented as a servlet. A controller servlet intercepts requests and then maps each request to an appropriate handler resource. In this section, we will build a classic MVC front controller servlet to redirect requests to views.</p><p class="calibre9">Requests with only a context path, such as <code class="literal">http://localhost:8080/context/</code>, are routed to the <code class="literal">login.jsp</code> page, all home<a id="id591" class="calibre1"/> page requests (with URL <code class="literal">/home.do</code>) are routed to the <code class="literal">home.jsp</code> page, and all other requests are routed to the <code class="literal">error.jsp</code> page.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Unit Testing the Web Tier">
<div class="book" title="Unit testing servlets">
<div class="book" title="Building and unit testing a J2EE web application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec43" class="calibre1"/>Building and unit testing a J2EE web application</h2></div></div></div><p class="calibre9">Follow the ensuing <a id="id592" class="calibre1"/>steps to build a web application and test the<a id="id593" class="calibre1"/> controller logic:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a dynamic web project named <code class="literal">DemoServletTest</code> in Eclipse.</li><li class="listitem" value="2">Create a controller servlet named <code class="literal">com.packt.servlet.DemoController</code>, and add the following lines to the <code class="literal">doGet</code> method:<div class="informalexample"><pre class="programlisting">protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
  String urlContext = req.getServletPath();
  <span class="strong"><strong class="calibre10">if(urlContext.equals("/"))</strong></span> {
    req.getRequestDispatcher("<span class="strong"><strong class="calibre10">login.jsp</strong></span>").forward(req, res);  
  }else if(<span class="strong"><strong class="calibre10">urlContext.equals("/home.do")</strong></span>) {
    req.getRequestDispatcher("<span class="strong"><strong class="calibre10">home.jsp</strong></span>").forward(req, res);  
  }else {
    req.setAttribute("error", "Invalid request path '"+urlContext+"'");
    req.getRequestDispatcher("<span class="strong"><strong class="calibre10">error.jsp</strong></span>").forward(req, res);  
  }
}</pre></div><p class="calibre15">This method gets the servlet path from the request and matches the path with <code class="literal">/</code> tokens. When no match is found, then the <code class="literal">doGet</code> method sets an error attribute to the request.</p></li><li class="listitem" value="3">Create three JSP files: <code class="literal">login.jsp</code>, <code class="literal">home.jsp</code>, and <code class="literal">error.jsp</code>. Modify the <code class="literal">error.jsp</code> file, and add the following scriptlet to display the error message:<div class="informalexample"><pre class="programlisting">&lt;body&gt;
  &lt;font color="RED"&gt;&lt;%=request.getAttribute("error") %&gt;&lt;/font&gt;
&lt;/body&gt;</pre></div></li><li class="listitem" value="4">Modify the <code class="literal">web.xml</code> file to map all requests to <code class="literal">DemoController</code>. Add the following lines of code to the <code class="literal">web.xml</code> file:<div class="informalexample"><pre class="programlisting">&lt;web-app    xsi:schemaLocation="http://java.sun.com/xml/ ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" id="WebApp_ID" version="3.0"&gt;
 &lt;display-name&gt;DemoServletTest&lt;/display-name&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.packt.servlet.DemoController
   &lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;demo&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><p class="calibre15">The <code class="literal">demo</code> servlet maps the <code class="literal">url-pattern</code> tag.</p></li></ol><div class="calibre17"/></div><p class="calibre9">The application is ready, but how do we<a id="id594" class="calibre1"/> unit test the controller logic?</p><p class="calibre9">We cannot<a id="id595" class="calibre1"/> instantiate the <code class="literal">HttpServletRequest</code> or <code class="literal">HttpServletResponse</code> objects. We can mock the <code class="literal">HttpServletRequest</code> or <code class="literal">HttpServletResponse</code> objects using Mockito.</p><p class="calibre9">Create a test class named <code class="literal">DemoControllerTest</code> and add the following code snippet:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class DemoControllerTest {
  @Mock   HttpServletRequest req;
  @Mock   HttpServletResponse res;
  @Mock   RequestDispatcher dispatcher;
  DemoController controllerServlet;
  
  @Before
  public void setup() {
    controllerServlet = new DemoController();
    <span class="strong"><strong class="calibre10">when(req.getRequestDispatcher(anyString())).</strong></span>      <span class="strong"><strong class="calibre10">thenReturn(dispatcher);</strong></span>
  }
  
  @Test
  public void when_servlet_path_is_empty_then_opens_login_page(){
    when(req.getServletPath()).thenReturn("/");
    controllerServlet.doGet(req, res);
    <span class="strong"><strong class="calibre10">ArgumentCaptor&lt;String&gt; dispatcherArgument =  </strong></span>      <span class="strong"><strong class="calibre10">ArgumentCaptor.forClass(String.class);</strong></span>
    <span class="strong"><strong class="calibre10">verify(req).getRequestDispatcher(</strong></span>      <span class="strong"><strong class="calibre10">dispatcherArgument.capture());</strong></span>
    <span class="strong"><strong class="calibre10">assertEquals("login.jsp", dispatcherArgument.getValue());</strong></span>
  }
  
  @Test
  public void when_home_page_request_then_opens_home_page(){
    when(req.getServletPath()).thenReturn("/home.do");
    controllerServlet.doGet(req, res);
    
    <span class="strong"><strong class="calibre10">ArgumentCaptor&lt;String&gt; dispatcherArgument = </strong></span>      <span class="strong"><strong class="calibre10">ArgumentCaptor.forClass(String.class);</strong></span>
    <span class="strong"><strong class="calibre10">verify(req).getRequestDispatcher(</strong></span>      <span class="strong"><strong class="calibre10">dispatcherArgument.capture());</strong></span>
    <span class="strong"><strong class="calibre10">assertEquals("home.jsp", dispatcherArgument.getValue());</strong></span>
  }
  
  @Test
  public void when_invalid_request_then_opens_error_page(){
    when(req.getServletPath()).thenReturn("/xyz.do");
    controllerServlet.doGet(req, res);
    <span class="strong"><strong class="calibre10">ArgumentCaptor&lt;String&gt; dispatcherArgument = </strong></span>      <span class="strong"><strong class="calibre10">ArgumentCaptor.forClass(String.class);</strong></span>
    <span class="strong"><strong class="calibre10">verify(req).getRequestDispatcher(</strong></span>      <span class="strong"><strong class="calibre10">dispatcherArgument.capture());</strong></span>
    <span class="strong"><strong class="calibre10">assertEquals("error.jsp", dispatcherArgument.getValue());</strong></span>
  }
}</pre></div><p class="calibre9">Note that the <code class="literal">request</code> and <code class="literal">response</code> objects are mocked using mockito and then expectations are set to get <code class="literal">ServletPath</code>, and <code class="literal">verify</code> is used to check the view name returned by the controller. We<a id="id596" class="calibre1"/> added three tests to verify the controller logic: one to check the default context path, one to check the <code class="literal">home.do</code> URL, and <a id="id597" class="calibre1"/>the other to verify the error condition.</p><p class="calibre9">Create a Tomcat server instance from the server view (right-click on the server view and create a new server; from the server wizard choose Tomcat and set the runtime configuration) and run the application. Open the browser and go to <code class="literal">http://localhost:8080/DemoServletTest/</code>, and check that the application opens the <span class="strong"><strong class="calibre10">Login page</strong></span>. The following is the browser output:</p><div class="mediaobject"><img src="../images/00107.jpeg" alt="Building and unit testing a J2EE web application" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Go to <code class="literal">http://localhost:8080/DemoServletTest/home.do</code>; it will open the <span class="strong"><strong class="calibre10">Home page</strong></span>. The following is the browser output:</p><div class="mediaobject"><img src="../images/00108.jpeg" alt="Building and unit testing a J2EE web application" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Go to any other URL, such as <code class="literal">http://localhost:8080/DemoServletTest/abc</code>. It will open an error page and<a id="id598" class="calibre1"/> display an error message. The<a id="id599" class="calibre1"/> following is the error output:</p><div class="mediaobject"><img src="../images/00109.jpeg" alt="Building and unit testing a J2EE web application" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The results of the preceding browser verify that our JUnit tests work fine.</p><p class="calibre9">
<code class="literal">DemoServletTest</code> acts as a<a id="id600" class="calibre1"/> <span class="strong"><strong class="calibre10">front controller</strong></span>. A <a id="id601" class="calibre1"/>front controller is a design pattern where a single servlet handles all web requests and routes them to other controllers or handlers for actual processing. All dynamic web applications written in the Java or Servlet API need a front controller servlet to handle HTTP requests, so all projects write logically duplicate code to handle requests through the front controller servlets.</p><p class="calibre9">Spring MVC was built to provide a flexible framework for web application developers. Spring's <code class="literal">DispatcherServlet</code> acts as the front controller; similar to the <code class="literal">DemoServletTest</code> test, it receives all incoming requests and delegates the processing of the requests to handlers. It allows developers to concentrate on business logic rather than work on the boilerplate of a custom front controller. The next section describes the Spring MVC architecture and how web applications can be unit tested using Spring MVC.</p></div></div></div>
<div class="book" title="Playing with Spring MVC"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec40" class="calibre1"/>Playing with Spring MVC</h1></div></div></div><p class="calibre9">In Spring MVC, the following is a pattern of a simplified request handling mechanism:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1"><code class="literal">DispatcherServlet</code> receives a request and confers the request with handler mappings to find out which controller can handle the request, and then passes the request to that controller.</li><li class="listitem" value="2">The controller <a id="id602" class="calibre1"/>performs the business logic (can delegate the request to a service or business logic processor) and returns some information back to <code class="literal">DispatcherServlet</code> for user display or response. Instead of sending the information (model) directly to the user, the controller returns a view name that can render the model.</li><li class="listitem" value="3"><code class="literal">DispatcherServlet</code> then resolves the physical view from the view name and passes the model object to the view. This way, <code class="literal">DispatcherServlet</code> is decoupled from the view implementation.</li><li class="listitem" value="4">The view renders the model. A view could be a JSP page, a servlet, a PDF file, an excel report, or any presentable component.</li></ol><div class="calibre17"/></div><p class="calibre9">The following sequence diagram represents the flow and interaction of Spring MVC components:</p><div class="mediaobject"><img src="../images/00110.jpeg" alt="Playing with Spring MVC" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">We will build a Spring web application and unit test the code using JUnit. The following are the steps to be <a id="id603" class="calibre1"/>performed:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Launch Eclipse and <a id="id604" class="calibre1"/>create a dynamic web project named <code class="literal">SpringMvcTest</code>.</li><li class="listitem" value="2">Open <code class="literal">web.xml</code> and enter the following lines:<div class="informalexample"><pre class="programlisting">&lt;display-name&gt;SpringMVCTest&lt;/display-name&gt;
&lt;servlet&gt;
  &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
  &lt;servlet-class&gt;
    org.springframework.web.servlet.DispatcherServlet
  &lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
      /WEB-INF/dispatcher-servlet.xml
    &lt;/param-value&gt;
  &lt;/context-param&gt;
&lt;/web-app&gt;</pre></div><p class="calibre15">The dispatcher is named <code class="literal">DispatcherServlet</code>, and it maps all requests. Note the <code class="literal">contextConfigLocation</code> parameter. This indicates that the Spring beans are defined in <code class="literal">/WEB-INF/dispatcher-servlet.xml</code>.</p></li><li class="listitem" value="3">Create an XML<a id="id605" class="calibre1"/> file named <code class="literal">dispatcher-servlet.xml</code> in <code class="literal">WEB-INF</code> and<a id="id606" class="calibre1"/> add the following lines:<div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans 
  
  
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans     
  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/context 
  http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;
 <span class="strong"><strong class="calibre10">&lt;context:component-scan base-package="com.packt" /&gt;</strong></span>
 &lt;bean class= "org.springframework.web.servlet.view.
    InternalResourceViewResolver"&gt;
  &lt;property name="prefix"&gt;
    &lt;value&gt;/WEB-INF/pages/&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="suffix"&gt;
      &lt;value&gt;.jsp&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre></div><p class="calibre15">This XML defines a Spring view resolver. Any view will be found under the <code class="literal">/WEB-INF/pages</code> location with the <code class="literal">.jsp</code> suffix, and all beans are configured under the <code class="literal">com.packt</code> package with Spring annotations.</p></li><li class="listitem" value="4">Create a class <a id="id607" class="calibre1"/>named <code class="literal">LoginInfo</code> in the <code class="literal">com.packt.model</code> package. This class represents <a id="id608" class="calibre1"/>the login information. Add two private <code class="literal">String</code> fields, <code class="literal">userId</code> and <code class="literal">password</code>, and generate the getters and setters.</li><li class="listitem" value="5">Create a JSP page named <code class="literal">login.jsp</code> under <code class="literal">/WEB-INF/view</code>, and add the following lines to create a form using the Spring tag library. Modify the form and add normal HTML input for username and password:<div class="informalexample"><pre class="programlisting">&lt;%@ taglib prefix="sf" uri="http://www.springframework.org/tags/form"%&gt;
&lt;sf:form method="POST" modelAttribute="loginInfo" action="/onLogin"&gt;
  
&lt;/sf:form&gt;</pre></div></li><li class="listitem" value="6">Create a controller class named <code class="literal">com.packt.controller.LoginController</code> to handle login requests. Add the following lines:<div class="informalexample"><pre class="programlisting">@Controller
@Scope("session")
public class LoginController implements Serializable {
  @RequestMapping({ "/", "/login" })
  public String onStartUp(ModelMap model) {
    model.addAttribute("loginInfo", new LoginInfo());
    return "login";
  }
}</pre></div><p class="calibre15">The <code class="literal">@Controller</code> annotation indicates that the class is a Spring MVC controller class. In <code class="literal">smapl-servlet.xml</code>, we defined <code class="literal">&lt;context:component-scan base-package="com.packt" /&gt;</code>, so Spring will scan this <code class="literal">@Controller</code> annotation and create a bean. The <code class="literal">@RequestMapping</code> annotation maps any request with the default path <code class="literal">/SpringMvcTest/</code> or <code class="literal">/SpringMvcTest/login</code> to the <code class="literal">onStartUp</code> method. This method returns a logical view name <code class="literal">login</code>. The view resolver defined in the XML file will map the login request to the physical view<code class="literal"> login.jsp</code> page under <code class="literal">/WEB-INF/pages</code>.</p></li><li class="listitem" value="7">Create another method in the <code class="literal">Login</code> class<a id="id609" class="calibre1"/> to handle the login and submit requests, as follows:<div class="informalexample"><pre class="programlisting">@RequestMapping({ "/onLogin" })
public String onLogin(@ModelAttribute("loginInfo") LoginInfo loginInfo, ModelMap model) {
  if(!"junit".equals(loginInfo.getUserId())) {
    model.addAttribute("error", "invalid login name");
    return "login";
  }
  if(!"password".equals(loginInfo.getPassword())) {
    model.addAttribute("error", "invalid password");
    return "login";
  }
  model.addAttribute("name", "junit reader!");
  return "greetings";
}</pre></div><p class="calibre15">The <code class="literal">onLogin</code> method is mapped with <code class="literal">/onLogin</code>. The <code class="literal">@ModelAttribute("loginInfo")</code> method is the model submitted from the <code class="literal">login.jsp</code> form. This method checks whether the username is <code class="literal">junit</code> and password is <code class="literal">password</code>. If the user ID or password does not match, then an error message is shown on the login page, otherwise, the <code class="literal">greetings</code> view is opened.</p></li><li class="listitem" value="8">Change the content of the <code class="literal">login.jsp</code> file to submit the form to <code class="literal">/SpringMvcTest/onLogin</code> and the <code class="literal">modelattribute</code> name to <code class="literal">loginInfo</code>, as follows:<div class="informalexample"><pre class="programlisting">&lt;sf:form method="POST" modelAttribute="loginInfo" action="/SpringMvcTest/onLogin"&gt;</pre></div><p class="calibre15">Also, add the <code class="literal">&lt;h1&gt;${error}&lt;/h1&gt;</code> JSTL expression to display the error message.</p></li><li class="listitem" value="9">Create a JSP file named <code class="literal">greetings.jsp</code> and add the following lines:<div class="informalexample"><pre class="programlisting">&lt;h1&gt;Hello :${name}&lt;/h1&gt;</pre></div></li><li class="listitem" value="10">In the browser, enter <code class="literal">http://localhost:8080/SpringMvcTest/</code>; this will open the login page. On the login page, do not enter any value and just click on <span class="strong"><strong class="calibre10">Submit</strong></span>. It will show the <span class="strong"><strong class="calibre10">invalid login name</strong></span> error message. Now, enter <code class="literal">junit</code> in the <span class="strong"><strong class="calibre10">User Id</strong></span> field and <code class="literal">password</code> in the <span class="strong"><strong class="calibre10">Password</strong></span> field and hit <span class="strong"><em class="calibre11">Enter</em></span>. The application will greet you with the message shown in the following screenshot:<div class="mediaobject"><img src="../images/00111.jpeg" alt="Playing with Spring MVC" class="calibre12"/></div><p class="calibre16"> </p></li></ol><div class="calibre17"/></div><p class="calibre9">We can unit test the <code class="literal">controller</code> class. The following<a id="id610" class="calibre1"/> are the steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a <code class="literal">LoginControllerTest.java</code> class in <code class="literal">com.packt.controller</code>.</li><li class="listitem" value="2">Using the following code, add a test to check that when the user ID is null, the error message is thrown:<div class="informalexample"><pre class="programlisting">public class LoginControllerTest {
  LoginController controller = new LoginController();
  @Test
  public void when_no_name_entered_shows_error_message(){
    ModelMap model = new ModelMap();
    String viewName = controller.onLogin(new LoginInfo(), model);
    assertEquals("login", viewName);
    assertEquals("invalid login name", model.get("error"));
  }
}</pre></div></li><li class="listitem" value="3">Add another test to check invalid passwords, as follows:<div class="informalexample"><pre class="programlisting">@Test
public void when_invalid_password_entered_shows_error_message()   {
  ModelMap model = new ModelMap();
  LoginInfo loginInfo = new LoginInfo();
  loginInfo.setUserId("junit");
  String viewName =controller.onLogin(loginInfo, model);
  assertEquals("login", viewName);
  assertEquals("invalid password", model.get("error"));
}</pre></div></li><li class="listitem" value="4">Add a <code class="literal">happyPath</code> test, as follows:<div class="informalexample"><pre class="programlisting">@Test   public void happyPath(){
  loginInfo.setUserId("junit");
  loginInfo.setPassword("password");
  String viewName =controller.onLogin(loginInfo, model);
  assertEquals("greetings", viewName);
}</pre></div></li></ol><div class="calibre17"/></div><p class="calibre9">This is just an example of Spring MVC, so we<a id="id611" class="calibre1"/> checked the username and password with the hardcoded constants. In the real world, a service looks up the database for the user and returns an error message; the service can be autowired to the controller. This way, we can unit test the controller and the service layer.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec41" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter explained the unit testing strategy for the presentation layer and provided examples on front controller servlets and Spring MVC.</p><p class="calibre9">By now, you should be able to unit test the web tier components and isolate the view components from the presentation logic.</p><p class="calibre9">The next chapter will cover the unit testing of the database layer.</p></div></body></html>