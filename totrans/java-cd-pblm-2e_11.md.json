["```java\nList<Thread> vtThreads = IntStream.range(0, 5)\n  .mapToObj(i -> Thread.ofVirtual().unstarted(() -> {\n    if (i == 0) { \n      logger.info(Thread.currentThread().toString()); \n    }\n    try { Thread.sleep(1000); } \n      catch (InterruptedException ex) {}\n   if (i == 0) { \n      logger.info(Thread.currentThread().toString()); \n   }\n })).toList();\n vtThreads.forEach(Thread::start);\n vtThreads.forEach(thread -> {\n   try { thread.join(); } catch (InterruptedException ex) {}\n }); \n```", "```java\nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-4 \n```", "```java\nexplains this statement:\n```", "```java\nContinuationScope cscope = new ContinuationScope(\"cscope\");\nContinuation continuation = new Continuation(cscope, () ->\n    logger.info(\"Continuation is running ...\");\n});\ncontinuation.run(); \n```", "```java\nContinuation is running ... \n```", "```java\nContinuation continuation = new Continuation(cscope, () ->\n   logger.info(\"Continuation is running ...\");\n   **Continuation.yield(cscope);**\n   logger.info(\"Continuation keeps running ...\");\n});\ncontinuation.run(); \n```", "```java\nContinuation is running ... \n```", "```java\ncontinuation.run();\nlogger.info(\"The continuation was suspended ...\"); \n```", "```java\nContinuation is running ...\nThe continuation was suspended ... \n```", "```java\ncontinuation.run();\nlogger.info(\"The continuation was suspended ...\");\ncontinuation.run();\nlogger.info(\"The continuation is done ...\"); \n```", "```java\nContinuation is running ...\nThe continuation was suspended ...\nContinuation keeps running ...\nThe continuation is done ... \n```", "```java\nsleep() method in the Thread class:\n```", "```java\n// this is the JDK 21 code\npublic static void sleep(long millis) \n    throws InterruptedException {\n  ...\n  long nanos = MILLISECONDS.toNanos(millis);\n  ...\n  if (currentThread() instanceofVirtualThread vthread) {\n    **vthread.sleepNanos(nanos);**\n  }\n...\n} \n```", "```java\n// this is the JDK 21 code\nvoid sleepNanos(long nanos) throws InterruptedException {  \n  ...\n  if (nanos == 0) {\n    **tryYield();**\n  } else {\n    // park for the sleep time\n    try {\n      ...\n      **parkNanos(remainingNanos);**\n      ...\n    } finally {\n      // may have been unparked while sleeping\n      setParkPermit(true);\n    }\n  }\n} \n```", "```java\n// this is the JDK 21 code \nprivate boolean yieldContinuation() {\n  // unmount\n  notifyJvmtiUnmount(/*hide*/true);\n  unmount();\n  try {\n    **return** **Continuation.yield(VTHREAD_SCOPE);**\n  } finally {\n    // re-mount\n    mount();\n    notifyJvmtiMount(/*hide*/false);\n  }\n} \n```", "```java\n// this is the JDK 21 code\nVirtualThread(Executor scheduler, String name, \n    int characteristics, Runnable task) {\n  super(name, characteristics, /*bound*/ false);\n  Objects.requireNonNull(task);\n  // choose scheduler if not specified\n  if (scheduler == null) {\n    Thread parent = Thread.currentThread();\n    if (parent instanceofVirtualThread vparent) {\n      scheduler = vparent.scheduler;\n    } else {\n      scheduler = DEFAULT_SCHEDULER;\n    }\n  }\n  **this****.scheduler = scheduler;**\n  **this****.cont =** **new****VThreadContinuation****(****this****, task);**\n  **this****.runContinuation =** **this****::runContinuation;**\n} \n```", "```java\n// this is the JDK 21 code \n@Override\nvoid start(ThreadContainer container) {\n**if** **(!compareAndSetState(NEW, STARTED)) {**\n**throw****new****IllegalThreadStateException****(****\"Already started\"****);**\n **}**\n  ...\n  // start thread\n  boolean started = false;\n  ...\n  try {\n    ...\n    // submit task to run thread\n **submitRunContinuation();**\n    started = true;\n  } finally {\n    if (!started) {\n      setState(TERMINATED);\n      ...\n    }\n  }\n} \n```", "```java\n// this is the JDK 21 code\nprivate void runContinuation() {\n  ...\n  // set state to RUNNING\n  int initialState = state();\n**if** **(initialState == STARTED** \n **&& compareAndSetState(STARTED, RUNNING)) {**\n**// first run**\n  } else if (initialState == RUNNABLE \n        && compareAndSetState(RUNNABLE, RUNNING)) {\n    // consume parking permit\n    setParkPermit(false);\n  } else {\n    // not runnable\n    return;\n  }\n  // notify JVMTI before mount\n  notifyJvmtiMount(/*hide*/true);\n  try {\n    **cont.run();**\n  } finally {\n    if (cont.isDone()) {\n      afterTerminate();\n    } else {\n      afterYield();\n    }\n  }\n} \n```", "```java\nString loc = \"124 NW Bobcat L, St. Robert\"; // from user\nString dest = \"129 West 81st Street\";       // from user \n```", "```java\npublic record RidesharingOffer(String company, Duration \n  minutesToYou, Duration minutesToDest, double price) {} \n```", "```java\npublic static RidesharingOffer\n    fetchRidesharingOffers(String loc, String dest) \n        throws InterruptedException {\n  try (StructuredTaskScope scope \n    = new StructuredTaskScope<RidesharingOffer>()) {\n    Subtask<RidesharingOffer> carOneOffer\n     = scope.fork(() -> Ridesharing.carOneServer(loc, dest));\n    Subtask<RidesharingOffer> starCarOffer\n     = scope.fork(() -> Ridesharing.starCarServer(loc, dest));\n    Subtask<RidesharingOffer> topCarOffer\n     = scope.fork(() -> Ridesharing.topCarServer(loc, dest));\n    scope.join();\n    ... \n```", "```java\n RidesharingOffer offer\n     = Stream.of(carOneOffer, starCarOffer, topCarOffer)\n     .filter(s -> s.state() == Subtask.State.SUCCESS)\n     .<RidesharingOffer>mapMulti((s, c) -> {\n        c.accept((RidesharingOffer) s.get());\n     })\n     .min(Comparator.comparingDouble(RidesharingOffer::price))\n     .orElseThrow(() -> {\n       RidesharingException exceptionWrapper\n        = new RidesharingException(\"Ridesharing exception\");\n       Stream.of(carOneOffer, starCarOffer, topCarOffer)\n             .filter(s -> s.state() == Subtask.State.FAILED)\n             .<Throwable>mapMulti((s, c) -> {\n                c.accept(s.exception());\n             }).forEach(exceptionWrapper::addSuppressed);\n      throw exceptionWrapper;\n      });  \n     ... \n```", "```java\n return offer;\n} \n```", "```java\nRidesharingOffer[company=TopCar, minutesToYou=PT9M, minutesToDest=PT16M, price=7.62] \n```", "```java\npublic record PublicTransportOffer(String transport, \n  String station, LocalTime goTime) {} \n```", "```java\npublic class PublicTransportScope\n    extends StructuredTaskScope<List<PublicTransportOffer>> {\n  ... \n```", "```java\n private final List<List<PublicTransportOffer>> results \n    = new CopyOnWriteArrayList<>();\n  private final List<Throwable> exceptions \n    = new CopyOnWriteArrayList<>();\n  ... \n```", "```java\n@Override\nprotected void handleComplete(\n    Subtask<? extends List<PublicTransportOffer>> subtask) {\n    switch (subtask.state()) {\n      case SUCCESS ->\n        results.add(subtask.get());\n      case FAILED ->\n        exceptions.add(subtask.exception());\n      case UNAVAILABLE ->\n        throw new IllegalStateException(\n          \"Subtask may still running ...\");\n    }\n  }\n  ... \n```", "```java\n public PublicTransportOffer recommendedPublicTransport() {\n    super.ensureOwnerAndJoined();\n    return results.stream()\n      .flatMap(t -> t.stream())\n      .min(Comparator.comparing(PublicTransportOffer::goTime))\n      .orElseThrow(this::wrappingExceptions);\n  }\n  ... \n```", "```java\n private PublicTransportException wrappingExceptions() {\n    super.ensureOwnerAndJoined();\n    PublicTransportException exceptionWrapper = new \n      PublicTransportException(\"Public transport exception\");\n    exceptions.forEach(exceptionWrapper::addSuppressed);\n    return exceptionWrapper;\n  }\n} \n```", "```java\npublic static PublicTransportOffer\n    fetchPublicTransportOffers(String loc, String dest) \n        throws InterruptedException {\n  try (PublicTransportScope scope \n                = new PublicTransportScope()) {\n    scope.fork(() -> PublicTransport\n      .busTransportServer(loc, dest));\n    scope.fork(() -> PublicTransport\n      .subwayTransportServer(loc, dest));\n    scope.fork(() -> PublicTransport\n      .trainTransportServer(loc, dest));\n    scope.fork(() -> PublicTransport\n      .tramTransportServer(loc, dest));\n    scope.join();\n    PublicTransportOffer offer\n      = scope.recommendedPublicTransport();\n    logger.info(offer.toString());\n    return offer;\n  }\n} \n```", "```java\nPublicTransportOffer[transport=Tram, station=Tram_station_0, goTime=10:26:39] \n```", "```java\nRidesharingOffer roffer\n  = fetchRidesharingOffers(loc, dest);\nPublicTransportOffer ptoffer\n  = fetchPublicTransportOffers(loc, dest); \n```", "```java\npublic record TravelOffer(RidesharingOffer ridesharingOffer, \n  PublicTransportOffer publicTransportOffer) {} \n```", "```java\npublic class TravelScope extends StructuredTaskScope<Travel> {\n  ... \n```", "```java\npublic sealed interface Travel \n  permits RidesharingOffer, PublicTransportOffer {}\npublic record RidesharingOffer(String company, \n  Duration minutesToYou, Duration minutesToDest, double price) \n    implements Travel {}\npublic record PublicTransportOffer(String transport, \n  String station, LocalTime goTime) implements Travel {} \n```", "```java\n private volatile RidesharingOffer ridesharingOffer;\n  private volatile PublicTransportOffer publicTransportOffer;\n  private volatile RidesharingException ridesharingException;\n  private volatile PublicTransportException\n    publicTransportException;\n  ... \n```", "```java\n @Override\n  protected void handleComplete(\n      Subtask<? extends Travel> subtask) {\n    switch (subtask.state()) {\n      case SUCCESS -> {\n        switch (subtask.get()) {\n          case RidesharingOffer ro ->\n            this.ridesharingOffer = ro;\n            case PublicTransportOffer pto ->\n            this.publicTransportOffer = pto;\n        }\n      }\n      case FAILED -> {\n        switch (subtask.exception()) {\n          case RidesharingException re ->\n            this.ridesharingException = re;\n          case PublicTransportException pte ->\n            this.publicTransportException = pte;\n          case Throwable t ->\n            throw new RuntimeException(t);\n        }\n      }\n      case UNAVAILABLE ->\n        throw new IllegalStateException(\n          \"Subtask may still running ...\");\n    }\n  }\n  ... \n```", "```java\n public TravelOffer recommendedTravelOffer() {\n    super.ensureOwnerAndJoined();\n    return new TravelOffer(\n      ridesharingOffer, publicTransportOffer);\n  }\n} \n```", "```java\npublic static TravelOffer fetchTravelOffers(\n    String loc, String dest)\n        throws InterruptedException {\n  try (TravelScope scope = new TravelScope()) {\n    scope.fork(() -> fetchRidesharingOffers(loc, dest));\n    scope.fork(() -> fetchPublicTransportOffers(loc, dest));\n    scope.join();\n    return scope.recommendedTravelOffer();\n  }\n} \n```", "```java\nTravelOffer toffer = fetchTravelOffers(loc, dest); \n```", "```java\nTravelOffer[\n  ridesharingOffer=RidesharingOffer[company=CarOne, \n  minutesToYou=PT5M, minutesToDest=PT5M, price=3.0], \n  publicTransportOffer=PublicTransportOffer[transport=Train, \n  station=Train_station_0, goTime=11:59:10]\n] \n```", "```java\npublic static RidesharingOffer fetchRidesharingOffers(\n    String loc, String dest) \n      throws InterruptedException, TimeoutException {\n  try (StructuredTaskScope scope \n    = new StructuredTaskScope<RidesharingOffer>()) {\n    ...\n    scope.joinUntil(Instant.now().plusMillis(10));\n    ...\n  }\n} \n```", "```java\npublic final class Ridesharing { \n  public static RidesharingOffer carOneServer(\n    String loc, String dest) throws InterruptedException {\n    ...\n    Thread.sleep(100); // simulating a delay\n    ...\n  }\n  ...\n} \n```", "```java\npublic class TravelScope extends StructuredTaskScope<Travel> {\n  ...\n  private volatile TimeoutException timeoutException;\n  @Override\n  protected void handleComplete(Subtask<? extends Travel> subtask) {\n    switch (subtask.state()) {\n      ...\n      case FAILED -> {\n        switch (subtask.exception()) {\n          ...\n          case TimeoutException te ->\n               this.timeoutException = te;\n          ...\n        }\n      }\n      ...\n    }\n  }\n  ... // the recommendedTravelOffer() method from below\n} \n```", "```java\npublic TravelOffer recommendedTravelOffer() {\n  super.ensureOwnerAndJoined();\n  if (timeoutException != null) {\n    logger.warning(\"Some of the called services \n                    did not respond in time\");\n  }\n  return new TravelOffer(\n    ridesharingOffer, publicTransportOffer);\n} \n```", "```java\n[14:53:34] [WARNING] Some of the called services\n                     did not respond in time\n[14:53:35] [INFO] TravelOffer[ridesharingOffer=null, publicTransportOffer=PublicTransportOffer[transport=Bus, station=Bus_station_2, goTime=15:02:34]] \n```", "```java\nprivate static final ThreadLocal<StringBuilder> threadLocal\n  = ThreadLocal.<StringBuilder>withInitial(() -> {\n     return new StringBuilder(\"Nothing here ...\");\n}); \n```", "```java\nRunnable task = () -> { \n  threadLocal.set(\n    new StringBuilder(Thread.currentThread().toString()));\n  logger.info(() -> \" before sleep -> \" \n    + Thread.currentThread().toString()\n       + \" [\" + threadLocal.get() + \"]\");\n  try {\n    Thread.sleep(Duration.ofSeconds(new Random().nextInt(5)));\n  } catch (InterruptedException ex) {} \n  logger.info(() -> \" after sleep -> \" \n    + Thread.currentThread().toString()\n        + \" [\" + threadLocal.get() + \"]\");\n  threadLocal.remove();\n}; \n```", "```java\ntry (ExecutorService executor \n      = Executors.newFixedThreadPool(10)) {\n  for (int i = 0; i < 10; i++) {\n    executor.submit(task);\n  }\n} \n look as follows:\n```", "```java\n[16:14:05] before sleep -> Thread[#24,pool-1-thread-3,5,main] [Thread[#24,pool-1-thread-3,5,main]] \n[16:14:05] before sleep -> Thread[#31,pool-1-thread-10,5,main] [Thread[#31,pool-1-thread-10,5,main]] \n[16:14:05] before sleep -> Thread[#22,pool-1-thread-1,5,main] [Thread[#22,pool-1-thread-1,5,main]]\n...\n[16:14:06] after sleep -> Thread[#24,pool-1-thread-3,5,main] [Thread[#24,pool-1-thread-3,5,main]] \n[16:14:07] after sleep -> Thread[#31,pool-1-thread-10,5,main] [Thread[#31,pool-1-thread-10,5,main]] \n[16:14:09] after sleep -> Thread[#22,pool-1-thread-1,5,main] [Thread[#22,pool-1-thread-1,5,main]]\n... \n```", "```java\ntry (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n  for (int i = 0; i < 10; i++) {\n    executor.submit(task);\n  }\n} \n```", "```java\n[16:24:24] before sleep ->VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 [VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3] \n[16:24:24] before sleep ->VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 [VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5] \n[16:24:24] before sleep ->VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 [VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6]\n...\n[16:24:24] after sleep ->VirtualThread[#28]/runnable@ForkJoinPool-1-worker-3 [VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6]\n[16:24:27] after sleep ->VirtualThread[#25]/runnable@ForkJoinPool-1-worker-4 [VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3] \n[16:24:27] after sleep ->VirtualThread[#27]/runnable@ForkJoinPool-1-worker-8 [VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5]\n... \n```", "```java\nScopedValue<String> SCOPED_VALUE = ScopedValue.newInstance(); \n```", "```java\npublic static <T> Carrier where(ScopedValue<T> key, T value) \n```", "```java\npublic static <T> void runWhere(\n  ScopedValue<T> key, T value, Runnable op)\npublic static <T,R> R callWhere(\n  ScopedValue<T> key, T value, Callable<? extends R> op) \n    throws Exception \n```", "```java\nScopedValue.where(key, value).run(op);  // like runWhere()\nScopedValue.where(key, value).call(op); // like callWhere() \n```", "```java\nRunnable taskr = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE.isBound() ? \n    SCOPED_VALUE.get() : \"Not bound\");\n}; \n```", "```java\ntaskr.run(); \n```", "```java\nThread[#1,main,5,main] \nNot bound \n```", "```java\nCarrier cr = ScopedValue.where(SCOPED_VALUE, \"Kaboooom!\");\ncr.run(taskr); \n```", "```java\nThread[#1,main,5,main] \nKaboooom! \n```", "```java\nScopedValue.where(SCOPED_VALUE, \"Kaboooom!\").run(taskr); \n```", "```java\nScopedValue.runWhere(SCOPED_VALUE, \"Kaboooom!\", taskr); \n```", "```java\nScopedValue.where(SCOPED_VALUE, \"Mike\").run(\n  () -> sayGoodByeSV()); \n```", "```java\nCallable<Boolean> taskc = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE.isBound() ? \n    SCOPED_VALUE.get() : \"Not bound\");\n  return true;\n}; \n```", "```java\ntaskc.call();\nScopedValue.where(SCOPED_VALUE, \"Kaboooom-1!\").call(taskc);\nScopedValue.callWhere(SCOPED_VALUE, \"Kaboooom-2!\", taskc);\nCarrier cc = ScopedValue.where(SCOPED_VALUE, \"Kaboooom-3!\");\ncc.call(taskc);\ntaskc.call(); \n```", "```java\nThread[#1,main,5,main] \nNot bound \nThread[#1,main,5,main] \nKaboooom-1! \nThread[#1,main,5,main] \nKaboooom-2! \nThread[#1,main,5,main] \nKaboooom-3! \nThread[#1,main,5,main] \nNot bound \n```", "```java\nThread tpr = new Thread(() ->\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-r!\").run(taskr));\nThread tpc = new Thread(() -> {\n try {\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-c!\").call(taskc);\n } catch (Exception ex) { /* handle exception */ }\n}); \n```", "```java\nThread tpr = Thread.ofPlatform().unstarted(\n () -> ScopedValue.where(SCOPED_VALUE, \"Kaboooom-r!\")\n  .run(taskr));\nThread tpc = Thread.ofPlatform().unstarted(()-> {\n try {\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-c!\").call(taskc);\n } catch (Exception ex) { /* handle exception */ }\n}); \n```", "```java\nThread tvr = Thread.ofVirtual().unstarted(\n () -> ScopedValue.where(SCOPED_VALUE, \"Kaboooom-r!\")\n  .run(taskr));\nThread tvc = Thread.ofVirtual().unstarted(() -> {\n try {\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-c!\").call(taskc);\n } catch (Exception ex) { /* handle exception */ }\n}); \n```", "```java\nThread tpcx = new Thread(() ->\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-tpcx!\")\n    .run(taskr)); \nThread tpcy = new Thread(() ->\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-tpcy!\")\n    .run(taskr)); \n```", "```java\nThread tpca = new Thread(() ->\n  ScopedValue.where(SCOPED_VALUE, \"Kaboooom-tpca!\")\n    .run(taskr)); \nThread tpcb = new Thread(taskr); \n```", "```java\nRunnable taskr1 = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE.orElse(\"Not bound\"));\n};\nRunnable taskr2 = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE.orElseThrow(() ->\n    new RuntimeException(\"Not bound\")));\n}; \n```", "```java\nRunnable taskr = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE.get());\n};\nThread.ofVirtual().start(() -> ScopedValue.runWhere(\n  SCOPED_VALUE, SCOPED_VALUE.orElse(\"Kaboooom\"), taskr))\n    .join();\nThread.ofVirtual().start(() -> ScopedValue.runWhere(\n  SCOPED_VALUE, SCOPED_VALUE.orElseThrow(() ->\n    new RuntimeException(\"Not bound\")), taskr)).join(); \n```", "```java\nRunnable task = () -> { \n  logger.info(() -> Thread.currentThread().toString() \n    + \" | before sleep | \" + (SCOPED_VALUE.isBound() \n    ? SCOPED_VALUE.get() : \"Not bound\"));\n  try {\n    Thread.sleep(Duration.ofSeconds(new Random().nextInt(5)));\n  } catch (InterruptedException ex) {} \n  logger.info(() -> Thread.currentThread().toString() \n    + \" | after sleep | \" + (SCOPED_VALUE.isBound() \n    ? SCOPED_VALUE.get() : \"Not bound\"));\n}; \n```", "```java\ntry (ExecutorService executor \n    = Executors.newFixedThreadPool(10)) {\n  for (int i = 0; i < 10; i++) {\n    int copy_i = i;\n    executor.submit(() -> ScopedValue.where(\n      SCOPED_VALUE, \"Kaboooom-\" + copy_i).run(task));\n  }\n} \n```", "```java\nThread[#30,pool-1-thread-9,5,main] | before sleep | Kaboooom-8 \nThread[#24,pool-1-thread-3,5,main] | before sleep | Kaboooom-2 \nThread[#27,pool-1-thread-6,5,main] | before sleep | Kaboooom-5\n...\nThread[#30,pool-1-thread-9,5,main] | after sleep | Kaboooom-8\nThread[#27,pool-1-thread-6,5,main] | after sleep | Kaboooom-5\nThread[#24,pool-1-thread-3,5,main] | after sleep | Kaboooom-2\n... \n```", "```java\ntry (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n  ...\n} \n```", "```java\nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n | before sleep | Kaboooom-0 \nVirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 \n | before sleep | Kaboooom-2 \nVirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 \n | before sleep | Kaboooom-4\n...\nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n| after sleep | Kaboooom-0\nVirtualThread[#25]/runnable@ForkJoinPool-1-worker-1 \n | after sleep | Kaboooom-2 \nVirtualThread[#27]/runnable@ForkJoinPool-1-worker-7 \n | after sleep | Kaboooom-4\n... \n```", "```java\nprivate static final ScopedValue<String> SCOPED_VALUE_1 \n = ScopedValue.newInstance();\nprivate static final ScopedValue<String> SCOPED_VALUE_2 \n = ScopedValue.newInstance();\nprivate static final ScopedValue<String> SCOPED_VALUE_3 \n = ScopedValue.newInstance(); \n```", "```java\nRunnable task = () -> {\n  logger.info(Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE_1.isBound() \n    ? SCOPED_VALUE_1.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_2.isBound() \n    ? SCOPED_VALUE_2.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_3.isBound() \n    ? SCOPED_VALUE_3.get() : \"Not bound\");\n}; \n```", "```java\nScopedValue.where(SCOPED_VALUE_1, \"Kaboooom - 1\")\n           .where(SCOPED_VALUE_2, \"Kaboooom - 2\")\n           .where(SCOPED_VALUE_3, \"Kaboooom - 3\")\n           .run(task); \n```", "```java\nRunnable taskB = () -> {\n  logger.info(() -> \"taskB:\" \n    + Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE_1.isBound() \n    ? SCOPED_VALUE_1.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_2.isBound() \n    ? SCOPED_VALUE_2.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_3.isBound() \n    ? SCOPED_VALUE_3.get() : \"Not bound\");\n}; \n```", "```java\nRunnable taskA = () -> {\n  logger.info(() -> \"taskA: \" \n    + Thread.currentThread().toString());\n  logger.info(() -> SCOPED_VALUE_1.isBound() \n    ? SCOPED_VALUE_1.get() : \"Not bound\");\n  ScopedValue.where(SCOPED_VALUE_1, \"No kaboooom\") // rebind\n             .where(SCOPED_VALUE_2, \"Kaboooom - 2\")\n             .where(SCOPED_VALUE_3, \"Kaboooom - 3\")\n             .run(taskB);\n  logger.info(() -> SCOPED_VALUE_1.isBound() \n    ? SCOPED_VALUE_1.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_2.isBound() \n    ? SCOPED_VALUE_2.get() : \"Not bound\");\n  logger.info(() -> SCOPED_VALUE_3.isBound() \n    ? SCOPED_VALUE_3.get() : \"Not bound\");\n}; \n```", "```java\nScopedValue.where(SCOPED_VALUE_1, \"Kaboooom - 1\").run(taskA); \n```", "```java\ntaskA: Thread[#1,main,5,main] \nKaboooom - 1 \ntaskB: Thread[#1,main,5,main] \nNo kaboooom                   // this is the rebinded value\nKaboooom - 2 \nKaboooom - 3 \nKaboooom– 1                   // back in taskA\nNot bound\nNot bound \n```", "```java\npublic static final ScopedValue<String> USER \n  = ScopedValue.newInstance();\npublic static final ScopedValue<String> LOC \n  = ScopedValue.newInstance();\npublic static final ScopedValue<String> DEST \n  = ScopedValue.newInstance();\npublic static final ScopedValue<Double> CAR_ONE_DISCOUNT \n  = ScopedValue.newInstance();\npublic static final ScopedValue<Boolean>\n  PUBLIC_TRANSPORT_TICKET = ScopedValue.newInstance(); \n```", "```java\nTravelOffer offer;\nif (user != null && !user.isBlank()) { // is user logged in ?\n  offer = ScopedValue.where(USER, user)\n    .call(() -> fetchTravelOffers(loc, dest));\n} else {\n  offer = fetchTravelOffers(loc, dest);\n} \n```", "```java\npublic static TravelOffer fetchTravelOffers(\n    String loc, String dest) throws Exception {\n  return ScopedValue\n    .where(LOC, loc)\n    .where(DEST, dest)\n    .call(() -> {\n      try (TravelScope scope = new TravelScope()) {\n        if (USER.isBound()) {\n          scope.fork(() -> fetchRidesharingOffers());\n        } else {\n          logger.warning(\"Ridesharing services can be \n                          accessed only by login users\");\n        }\n        scope.fork(() ->\n          ScopedValue.where(PUBLIC_TRANSPORT_TICKET, true)\n            .call(Main::fetchPublicTransportOffers));\n        scope.join();\n        return scope.recommendedTravelOffer();\n      }\n    });\n} \n```", "```java\nif (USER.isBound()) {\n  scope.fork(() -> fetchRidesharingOffers());\n} else {\n  logger.warning(\"Ridesharing services can be \n                  accessed only by login users\"); \n```", "```java\nscope.fork(() ->\n  ScopedValue.where(PUBLIC_TRANSPORT_TICKET, true)\n    .call(Main::fetchPublicTransportOffers)); \n```", "```java\n return ScopedValue\n    .where(LOC, loc)\n    .where(DEST, dest)\n    .call(() -> {\n       ...\n    }); \n```", "```java\npublic static RidesharingOffer fetchRidesharingOffers() \n    throws InterruptedException, Exception {\n  logger.info(() -> \"Ridesharing: Processing request for \"\n   + USER.orElseThrow(() -> new RuntimeException(\n     \"Ridesharing: User not login\")));\n  ...\n} \n```", "```java\nSubtask<RidesharingOffer> carOneOffer\n  = scope.fork(() -> ScopedValue.where(CAR_ONE_DISCOUNT, 0.5)\n    .call(Ridesharing::carOneServer)); \n```", "```java\npublic static PublicTransportOffer\n    fetchPublicTransportOffers() throws InterruptedException {\n  logger.info(() -> \"Public Transport: Processing \n    request for \" + USER.orElse(\"anonymous\"));\n  ...\n} \n```", "```java\npublic static RidesharingOffer carOneServer() {\n  ...\n  if (CAR_ONE_DISCOUNT.isBound()) {\n    logger.info(() -> \"Congrats \" + USER.get()\n      + \"! You have a discount of \"\n      + CAR_ONE_DISCOUNT.orElse(0.0));\n    price = price - CAR_ONE_DISCOUNT.orElse(0.0);\n  }\n  ...\n  throw new RidesharingException(\n    \"No drivers are available at CarOne for route: \"\n      + LOC.get() + \" -> \" + DEST.get());\n} \n```", "```java\npublic static List<PublicTransportOffer>\n      tramTransportServer() {\n  List<PublicTransportOffer> listOfOffers = new ArrayList<>();\n  Random rnd = new Random();\n  boolean makeAnOffer = rnd.nextBoolean();\n  if (makeAnOffer && PUBLIC_TRANSPORT_TICKET.isBound() \n    && PUBLIC_TRANSPORT_TICKET.get()) {\n    ...\n  }\n  if (listOfOffers.isEmpty()) {\n    throw new RidesharingException(\n      \"No public tram-transport is available for route: \"\n        + LOC.get() + \" -> \" + DEST.get());\n  }\n  return listOfOffers;\n} \n```", "```java\nRunnable task = () -> {\n  try {\n    Thread.sleep(5000);\n  } catch (InterruptedException ex) { /* handle exception */ }\n  logger.info(Thread.currentThread().toString());\n}; \n```", "```java\nprivate static final int NUMBER_OF_TASKS = 15;\nprivate static final int NUMBER_OF_THREADS = 3; \n```", "```java\n// using cached platform threads\ntry (ExecutorService executor = \n  Executors.newFixedThreadPool(NUMBER_OF_THREADS)) {\n  for (int i = 0; i < NUMBER_OF_TASKS; i++) {\n    executor.submit(task);\n  }\n} \n```", "```java\nThread[#24,pool-1-thread-3,5,main] \nThread[#22,pool-1-thread-1,5,main] \nThread[#23,pool-1-thread-2,5,main] \nThread[#22,pool-1-thread-1,5,main] \nThread[#24,pool-1-thread-3,5,main] \nThread[#23,pool-1-thread-2,5,main]\n... \n```", "```java\nSemaphore semaphore = new Semaphore(NUMBER_OF_THREADS); \n```", "```java\nThread vt = Thread.currentThread();\nfor (int i = 0; i < NUMBER_OF_TASKS; i++) {\n  vt = Thread.ofVirtual().start(() -> {\n    try {\n      semaphore.acquire();\n    } catch (InterruptedException ex) { /* handle it */ }\n      try {\n        task.run();\n      } finally {\n        semaphore.release();\n      }\n  });\n}\nvt.join(); \noutput:\n```", "```java\nVirtualThread[#27]/runnable@ForkJoinPool-1-worker-2 \nVirtualThread[#33]/runnable@ForkJoinPool-1-worker-8 \nVirtualThread[#28]/runnable@ForkJoinPool-1-worker-3 \nVirtualThread[#30]/runnable@ForkJoinPool-1-worker-3 \nVirtualThread[#25]/runnable@ForkJoinPool-1-worker-8 \nVirtualThread[#31]/runnable@ForkJoinPool-1-worker-4\n... \n```", "```java\nRunnable task1 = () -> {\n  synchronized (Main.class) {\n    try {\n      Thread.sleep(1000);\n    } catch (InterruptedException ex) { /* handle it */ }\n    logger.info(() -> \"Task-1 | \" \n      + Thread.currentThread().toString());\n  }\n}; \n```", "```java\nprivate static final int NUMBER_OF_TASKS = 25;\ntry (ExecutorService executor \n     = Executors.newVirtualThreadPerTaskExecutor()) {\n  for (int i = 0; i < NUMBER_OF_TASKS; i++) {\n    executor.submit(task1);\n  }\n} \n```", "```java\nTask-1 | VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \nTask-1 | VirtualThread[#30]/runnable@ForkJoinPool-1-worker-8 \nTask-1 | VirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 \nTask-1 | VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 \nTask-1 | VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 \nTask-1 | VirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 \nTask-1 | VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 \nTask-1 | VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 \nTask-1 | VirtualThread[#37]/runnable@ForkJoinPool-1-worker-3 \nTask-1 | VirtualThread[#36]/runnable@ForkJoinPool-1-worker-4 \nTask-1 | VirtualThread[#35]/runnable@ForkJoinPool-1-worker-5 \nTask-1 | VirtualThread[#34]/runnable@ForkJoinPool-1-worker-6\n... \n```", "```java\nLock lock = new ReentrantLock();\nRunnable task2 = () -> {\n  lock.lock();\n  try {\n    Thread.sleep(1000);\n    logger.info(() -> \"Task-2 | \" \n      + Thread.currentThread().toString());\n  } catch (InterruptedException ex) { /* handle it */\n  } finally {\n    lock.unlock();\n  }\n}; \n```", "```java\nexecutor.submit(task2); \n```", "```java\nTask-2 | VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#24]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#25]/runnable@ForkJoinPool-1-worker-5 \nTask-2 | VirtualThread[#26]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#27]/runnable@ForkJoinPool-1-worker-3 \nTask-2 | VirtualThread[#28]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#29]/runnable@ForkJoinPool-1-worker-3 \nTask-2 | VirtualThread[#30]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#31]/runnable@ForkJoinPool-1-worker-3 \nTask-2 | VirtualThread[#33]/runnable@ForkJoinPool-1-worker-1 \nTask-2 | VirtualThread[#32]/runnable@ForkJoinPool-1-worker-5 \nTask-2 | VirtualThread[#34]/runnable@ForkJoinPool-1-worker-1\n... \n```", "```java\nprivate static ExecutorService producerService;\nprivate static ExecutorService consumerService;\n...\nproducerService = Executors.newVirtualThreadPerTaskExecutor();\nfor (int i = 0; i < PRODUCERS; i++) {\n  producerService.execute(producer);\n}\nconsumerService = Executors.newVirtualThreadPerTaskExecutor();\nfor (int i = 0; i < CONSUMERS; i++) {\n  consumerService.execute(consumer);\n} \n```", "```java\nChecked: bulb-106 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 \nChecked: bulb-58 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-2 \nPacked: bulb-106 by consumer: VirtualThread[#26]/runnable@ForkJoinPool-1-worker-2 \nPacked: bulb-58 by consumer: VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5\n... \n```", "```java\nprivate final static Semaphore producerService\n    = new Semaphore(PRODUCERS);\n...\nfor (int i = 0; i < PRODUCERS; i++) {\n  Thread.ofVirtual().start(() -> {\n    try {\n      producerService.acquire();\n    } catch (InterruptedException ex) {  /* handle it */ }\n    try {\n      producer.run();\n    } finally {\n      producerService.release();\n    }\n  });\n} \n```", "```java\nprivate final static Semaphore consumerService\n    = new Semaphore(CONSUMERS);\n...\nfor (int i = 0; i < CONSUMERS; i++) {\n  Thread.ofVirtual().start(() -> {\n    try {\n      consumerService.acquire();\n    } catch (InterruptedException ex) { /* handle it */ }\n    try {\n      consumer.run();\n    } finally {\n      consumerService.release();\n    }\n  });\n} \n```", "```java\nprivate static final int PRODUCERS = 3;\nprivate static final int CONSUMERS = 2; \n```", "```java\nprivate static final int MAX_PROD_TIME_MS = 1 * 1000;\nprivate static final int MAX_CONS_TIME_MS = 10 * 1000; \n```", "```java\nprivate static final int MAX_QUEUE_SIZE_ALLOWED = 5; \n```", "```java\nprivate static final int MAX_NUMBER_OF_CONSUMERS = 50; \n```", "```java\nprivate static ScheduledExecutorService monitorService; \n```", "```java\nprivate static final int \n  MONITOR_QUEUE_INITIAL_DELAY_MS = 5000;\nprivate static final int MONITOR_QUEUE_RATE_MS = 3000;\nprivate static final AtomicInteger nrOfConsumers\n  = new AtomicInteger(CONSUMERS);\n...\nprivate static void monitorQueueSize() {\n  monitorService = Executors\n    .newSingleThreadScheduledExecutor();\n  monitorService.scheduleAtFixedRate(() -> {\n    if (queue.size() > MAX_QUEUE_SIZE_ALLOWED\n      && nrOfConsumers.get() < MAX_NUMBER_OF_CONSUMERS) {\n      addNewConsumer();\n    } else {\n      if (nrOfConsumers.get() > CONSUMERS) {\n      removeConsumer();\n    }\n  }\n  logger.warning(() -> \"### Bulbs in queue: \" + queue.size()\n    + \" | Consumers waiting: \" \n      + consumerService.getQueueLength()\n    + \" | Consumer available permits: \" \n      + consumerService.availablePermits()\n    + \" | Running consumers: \" + nrOfConsumers.get());\n  }, MONITOR_QUEUE_INITIAL_DELAY_MS, \n     MONITOR_QUEUE_RATE_MS, TimeUnit.MILLISECONDS);\n} \n```", "```java\nprivate static void addNewConsumer() {\n  logger.warning(\"### Adding a new consumer ...\");\n  if (consumerService.availablePermits() == 0) {\n    consumerService.release();\n  }\n  Thread.ofVirtual().start(() -> {\n    try {\n      consumerService.acquire();\n    } catch (InterruptedException ex) { /* handle it */ }\n    try {\n      consumer.run();\n    } finally {\n      consumerService.release();\n    }\n  });\n  nrOfConsumers.incrementAndGet();\n} \n```", "```java\nprivate static final AtomicBoolean\n    removeConsumer = new AtomicBoolean();\n...\nprivate static void removeConsumer() {\n  logger.warning(\"### Removing a consumer ...\");\n  removeConsumer.set(true);\n} \n```", "```java\nprivate static class Consumer implements Runnable {\n  @Override\n  public void run() {\n    while (runningConsumer) {\n      ...\n      if (removeConsumer.get()) {\n        nrOfConsumers.decrementAndGet();\n        removeConsumer.set(false);\n        Thread.currentThread().interrupt();\n      }\n    }\n  }\n} \n```", "```java\nprivate static int extraProdTime;\nprivate static final int EXTRA_TIME_MS = 4 * 1000;\nprivate static final int SLOW_DOWN_PRODUCER_MS = 150 * 1000;\nprivate static ScheduledExecutorService slowdownerService;\n...\nprivate static void slowdownProducer() {\n  slowdownerService = Executors\n    .newSingleThreadScheduledExecutor();\n  slowdownerService.schedule(() -> {\n    logger.warning(\"### Slow down the producers ...\");\n    extraProdTime = EXTRA_TIME_MS;\n  }, SLOW_DOWN_PRODUCER_MS, TimeUnit.MILLISECONDS);\n} \n```", "```java\nThread.sleep(rnd.nextInt(MAX_PROD_TIME_MS) + extraProdTime); \n```", "```java\n...\n[14:20:41] [INFO] Checked: bulb-304 by producer: VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n[14:20:42] [INFO] Checked: bulb-814 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-1 \n[14:20:42] [INFO] Checked: bulb-155 by producer: VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n**[14:20:42] [WARNING] ### Adding a new consumer ...** \n[14:20:42] [INFO] Checked: bulb-893 by producer: **VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1** \n**[14:20:42] [WARNING] ### Bulbs in queue: 27 | Consumers waiting: 0 | Consumer available permits: 0 | Running consumers: 3**\n... \n```", "```java\n...\n[14:22:09] [INFO] Checked: bulb-388 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1 \n[14:22:09] [INFO] Packed: bulb-501 by consumer: VirtualThread[#43]/runnable@ForkJoinPool-1-worker-1 \n[14:22:09] [INFO] Packed: bulb-768 by consumer: VirtualThread[#27]/runnable@ForkJoinPool-1-worker-3 \n**[14:22:09] [WARNING] ### Adding a new consumer ...** \n**[14:22:09] [WARNING] ### Bulbs in queue: 237 | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: 32**\n... \n```", "```java\n...\n[14:22:24] [WARNING] ### Adding a new consumer ... \n[14:22:24] [WARNING] ### Bulbs in queue: **214** | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: **37**\n...\n[14:22:27] [WARNING] ### Adding a new consumer ... \n[14:22:27] [WARNING] ### Bulbs in queue: **203** | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: **38**\n... \n```", "```java\n...\n[14:23:15] [INFO] Packed: bulb-180 by consumer: VirtualThread[#46]/runnable@ForkJoinPool-1-worker-3 \n[14:23:15] [INFO] Packed: bulb-261 by consumer: VirtualThread[#67]/runnable@ForkJoinPool-1-worker-3 \n**[14:23:15] [WARNING] ### Removing a consumer ...** \n**[14:23:15] [WARNING] ### Bulbs in queue: 0 | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: 49**\n... \n```", "```java\n...\n[14:23:07] [WARNING] ### Slow down the producers ...\n... \n```", "```java\n...\n**[14:28:24] [WARNING] ### Bulbs in queue: 3 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2**\n[14:28:26] [INFO] Checked: bulb-812 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 \n[14:28:26] [INFO] Packed: bulb-207 by consumer: VirtualThread[#102]/runnable@ForkJoinPool-1-worker-3 \n...\n**[14:28:27] [WARNING] ### Bulbs in queue: 4 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2**\n[14:28:28] [INFO] Checked: bulb-259 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-3 \n...\n**[14:28:30] [WARNING] ### Bulbs in queue: 3 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2**\n... \n```", "```java\nprivate static final int MAX_NR_OF_THREADS = 200;\nprivate static final int WEBSERVER_PORT = 8001;\nprivate static void startWebServer(\n    boolean virtual, boolean withLock) throws IOException {\n  HttpServer httpServer = HttpServer\n    .create(new InetSocketAddress(WEBSERVER_PORT), 0);\n  ... \n```", "```java\n httpServer.createContext(\"/webserver\", \n    new WebServerHandler(withLock));\n  ... \n```", "```java\n if (virtual) {\n    httpServer.setExecutor(\n      Executors.newVirtualThreadPerTaskExecutor());\n  } else {\n    httpServer.setExecutor(\n      Executors.newFixedThreadPool(MAX_NR_OF_THREADS));\n  }\n  ... \n```", "```java\n httpServer.start();\n  logger.info(() -> \" Server started on port \" \n    + WEBSERVER_PORT);\n} \n```", "```java\npublic class WebServerHandler implements HttpHandler {\n  private final static Logger logger\n    = Logger.getLogger(WebServerHandler.class.getName());\n  private final static int PERMITS = 20;\n  private final static Semaphore semaphore\n    = new Semaphore(PERMITS);\n  private final static AtomicLong\n    requestId = new AtomicLong();\n  private static final Callable<String> task = () -> {\n    String response = null;\n    try {\n      Thread.sleep(200);\n      response = \"Request id_\" + requestId.incrementAndGet();\n    } catch (InterruptedException e) {\n      throw new RuntimeException(e);\n    }\n    return response;\n  };\n  private final boolean withLock;\n  public WebServerHandler(boolean withLock) {\n    this.withLock = withLock;\n  }\n  ... \n```", "```java\n @Override\n  public void handle(HttpExchange exchange) \n    throws IOException {\n    String response = null;\n    if (withLock) {\n      try {\n        semaphore.acquire();\n      } catch (InterruptedException e) { \n        throw new RuntimeException(e); }\n      try {\n        response = task.call();\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      } finally {\n        semaphore.release();\n      }\n    } else {\n       try {\n         response = task.call();\n       } catch (Exception e) { \n         throw new RuntimeException(e); }\n        }\n        logger.log(Level.INFO, \"{0} | {1}\", \n          new Object[]{response, Thread.currentThread()\n    });\n    ... \n```", "```java\n exchange.sendResponseHeaders(\n      200, response == null ? 0 : response.length());\n    try (OutputStream os = exchange.getResponseBody()) {\n      os.write(response == null ? new byte[0] \n        : response.getBytes());\n    }\n  }\n} \n```", "```java\nprivate static final ExecutorService executor \n  = Executors.newVirtualThreadPerTaskExecutor(); \n```", "```java\npublic static CompletableFuture<String> fetchTester1() {\n  return CompletableFuture.supplyAsync(() -> {\n  String tester1 = null;\n  try {\n    logger.info(Thread.currentThread().toString());\n    tester1 = fetchTester(1);\n  } catch (IOException | InterruptedException ex) \n    { /* handle exceptions */ }\n  return tester1;\n  }**, executor);**\n}\npublic static CompletableFuture<String> fetchTester2() { … }\npublic static CompletableFuture<String> fetchTester3() { … } \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  CompletableFuture<String> cfTester1 = fetchTester1();\n  CompletableFuture<String> cfTester2 = fetchTester2();\n  CompletableFuture<String> cfTester3 = fetchTester3();\n  CompletableFuture<Void> fetchTesters\n    = CompletableFuture.allOf(\n      cfTester1, cfTester2, cfTester3);\n  fetchTesters.get();\n  TestingTeam team = new TestingTeam(cfTester1.resultNow(), \n    cfTester2.resultNow(), cfTester3.resultNow());\n  return team;\n} \n```", "```java\n[12:04:32] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n[12:04:32] VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 \n[12:04:32] VirtualThread[#26]/runnable@ForkJoinPool-1-worker-3 \n```", "```java\nObject object = new Object();\nThread wThread = Thread.ofVirtual().unstarted(() -> {\n  synchronized (object) {\n    try {\n      logger.info(\"Before calling wait()\");\n      logger.info(() -> Thread.currentThread() + \" | \" \n        + Thread.currentThread().getState());\n      object.wait();\n      logger.info(\"After calling notify()\");\n      logger.info(() -> Thread.currentThread() + \" | \" \n        + Thread.currentThread().getState());\n    } catch (InterruptedException e) {}\n  }\n}); \n```", "```java\nThread nThread = Thread.ofVirtual().unstarted(() -> {\n  synchronized (object) {\n    logger.info(() -> Thread.currentThread() \n      + \" calls notify()\");\n    object.notify();\n  }\n}); \n```", "```java\nwThread.start();\nThread.sleep(1000); // give time to 'wThread' to start\nlogger.info(\"'wThread' current status\");\nlogger.info(() -> wThread + \" | \" + wThread.getState()); \n```", "```java\nnThread.start();\nThread.sleep(1000); // give time to 'nThread' to start \n```", "```java\nlogger.info(\"After executing 'wThread'\");\nlogger.info(() -> wThread + \" | \" + wThread.getState()); \n```", "```java\n[14:25:06] Before calling wait() \n[14:25:06] VirtualThread[#22]\n           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE \n[14:25:07] 'wThread' current status\n[14:25:07] VirtualThread[#22]\n           /waiting@ForkJoinPool-1-worker-1 | WAITING \n[14:25:07] VirtualThread[#23]\n           /runnable@ForkJoinPool-1-worker-3 calls notify() \n[14:25:07] After calling notify() \n[14:25:07] VirtualThread[#22]\n           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE \n[14:25:08] After executing 'wThread'\n[14:25:08] VirtualThread[#22]/terminated | TERMINATED \n```", "```java\nnThread.start();\nThread.sleep(1000); // give time to 'nThread' to start\nwThread.start();\nThread.sleep(1000); // give time to 'wThread' to start\nlogger.info(\"'wThread' current status\");\nlogger.info(() -> wThread + \" | \" + wThread.getState()); \nwThread.join(); // waits indefinitely - notify() was missed \n```", "```java\n[14:38:25] VirtualThread[#23]\n           /runnable@ForkJoinPool-1-worker-1 calls notify() \n[14:38:26] Before calling wait() \n[14:38:26] VirtualThread[#22]\n           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE \n[14:38:27] 'wThread' current status\n[14:38:27] VirtualThread[#22]\n           /waiting@ForkJoinPool-1-worker-1 | WAITING \n```", "```java\npublic class SignaledObject {\n  private static final Logger logger\n    = Logger.getLogger(SignaledObject.class.getName());\n  private int counter;\n  public void callWait() throws InterruptedException {\n    synchronized (this) {\n      counter = counter - 1;\n      if (counter >= 0) {\n        logger.info(() -> Thread.currentThread() \n          + \" | Missed signals: \" + counter\n          + \" | 'wait() will not be called'\");\n        return;\n      }\n      logger.info(\"Before calling wait()\");\n      logger.info(() -> Thread.currentThread() + \" | \" \n        + Thread.currentThread().getState());\n      wait();\n      logger.info(\"After calling notify()\");\n      logger.info(() -> Thread.currentThread() + \" | \" \n        + Thread.currentThread().getState());\n    }\n  }\n  ... \n```", "```java\n public void callNotify() {\n    synchronized (this) {\n      counter = counter + 1;\n      logger.info(() -> \"Signal counter: \" + counter);\n      notify();\n    }\n  }\n} \n```", "```java\n[14:50:32] Before calling wait() \n[14:50:32] VirtualThread[#22]\n           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE \n[14:50:33] 'wThread' current status\n[14:50:33] VirtualThread[#22]\n           /waiting@ForkJoinPool-1-worker-1 | WAITING \n**[14:50:33] Signal counter: 0** \n[14:50:33] After calling notify() \n[14:50:33] VirtualThread[#22]\n           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE \n[14:50:34] After executing 'wThread'\n[14:50:34] VirtualThread[#22]/terminated | TERMINATED \n```", "```java\n[14:52:24] Signal counter: 1 \n[14:52:25] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n           | Missed signals: 0 | 'wait() will not be called' \n[14:52:26] 'wThread' current status\n[14:52:26] VirtualThread[#22]/terminated | TERMINATED \n```"]