<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Implicits"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Implicits</h1></div></div></div><p>In the previous chapter, we covered the 
<code class="literal">type</code> system and polymorphism. We also covered the different types of variance which provide ways to constrain parameterized types. Finally, we covered some advanced 
<code class="literal">types</code> such as abstract type members, option, and so on.
</p><p>In this chapter, we will 
<a class="indexterm" id="id295"/>cover implicit parameters and implicit conversions. We'll be learning about how they work, how to use them, and what kind of benefits and perils they provide.
</p><p>When using a third-party library in your code, you usually have to take its code as it is. This can make some libraries unpleasant to deal with. It can be either the code style that differs from the one in your code base or simply some functionality that the library lacks that you can't elegantly supply.</p><p>Some languages have come up with solutions to alleviate this problem. Ruby has modules, Smalltalk allows packages to add to each other's classes, and C# 3.0 has static extension methods.</p><p>Scala has implicit parameters and conversions. When used in a controlled manner, implicits
<a class="indexterm" id="id296"/> can make working with external libraries more pleasant, and also enable some elegant patterns that you can use in your own code.
</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Describe implicits and how the Scala compiler handles them</li><li class="listitem" style="list-style-type: disc">Explain the design patterns that implicits enable</li><li class="listitem" style="list-style-type: disc">Analyze the common issues that may arise by overusing implicits</li></ul></div><div class="section" title="Implicit Parameters and Implicit Conversions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Implicit Parameters and Implicit Conversions</h1></div></div></div><p>Scala has implicit parameters and conversions. When used in a controlled manner, implicit can make working with external libraries more pleasant, and also enable some elegant patterns that you can use in your own code.</p><div class="section" title="Implicit Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Implicit Parameters</h2></div></div></div><p>
<span class="strong"><strong>Implicit parameters</strong></span>
<a class="indexterm" id="id297"/>are a way to make the compiler automatically fill in some arguments when a method call misses them for some (or all) of the (implicit) parameters. The compiler will look for definitions labelled implicit of the required types. For example, suppose you want to write a program that prompts the user for some action, after displaying a message. You want to customize both the message and the string that appear on the prompt. We can assume that the prompt string will have a more default value than the message, so one way to implement it using implicit parameters is like the following:
</p><div class="informalexample"><pre class="programlisting">case class Prompt(value: String)
def message(msg: String)(implicit prompt: Prompt) = {
  println(msg)
  println(s"${prompt.value}&gt;")
}</pre></div><p>With the previous implementation, you can call the message function, supplying an argument to the prompt parameter explicitly:</p><div class="informalexample"><pre class="programlisting">message("Welcome!")(Prompt("action"))</pre></div><p>However, if we want to reuse the prompt in different message calls, we can create a default object.</p><p>
<code class="literal">default</code>:
</p><div class="informalexample"><pre class="programlisting">object Defaults {
  implicit val defaultPrompt = Prompt("action")
}</pre></div><p>We can 
<a class="indexterm" id="id298"/>then bring that 
<code class="literal">default</code> into scope when we use the message method and avoid having to explicitly supply the prompt parameter:
</p><div class="informalexample"><pre class="programlisting">import Defaults._
message("Welcome!")
message("What do you want to do next?")</pre></div><p>There can be only one implicit parameter list per method, but it can have multiple parameters. The implicit parameter list must be the last parameter list of the function.</p><p>The eligible arguments for an implicit parameter are identifiers that can be accessed at the point of the method call without a prefix and that denote an implicit definition or an implicit parameter, and members of companion modules of the implicit parameter's type that are labelled implicit. For example, in the previous example, if you were to put the 
<code class="literal">defaultPrompt</code> implicit in the companion object of 
<code class="literal">Prompt</code>, it wouldn't be necessary to import 
<code class="literal">Prompt</code> to put 
<code class="literal">defaultPrompt</code> into scope on calls to message:
</p><div class="informalexample"><pre class="programlisting">object Prompt {
  implicit val defaultPrompt = Prompt("action")
}
message("Welcome!")
message("What do you want to do next?")</pre></div></div><div class="section" title="Implicit Conversions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Implicit Conversions</h2></div></div></div><p>
<span class="strong"><strong>Implicit </strong></span>
<a class="indexterm" id="id299"/>
<span class="strong"><strong>conversions</strong></span> provide a way to transparently convert between 
<code class="literal">types</code>. Implicit conversions are useful when you need a 
<code class="literal">type</code> that you don't control (from an external library, for example) to adhere to a specified interface. For example, suppose you want to handle an integer as a traversable, so you can iterate through its digits. One way to do this is by supplying an implicit conversion:
</p><div class="informalexample"><pre class="programlisting">implicit def intToIterable(i: Int): Traversable[Int] = 
  new Traversable[Int] {
  override def foreach[U](f: Int =&gt; U): Unit = {
    var value = i
    var l = List.empty[Int]
   do {
      l = value % 10 :: l
      value /= 10
    } while (value != 0)
    l.foreach(f)
  }
}</pre></div><p>The 
<code class="literal">intToIterable</code> implicit conversion works as a normal method. The special thing is the implicit
<a class="indexterm" id="id300"/> keyword at the start of the definition. You can still apply the conversion explicitly or leave it out and get the same behavior:
</p><div class="informalexample"><pre class="programlisting">scala&gt; intToIterable(123).size
res0: Int = 3
scala&gt; 123.size
res1: Int = 3
scala&gt; 123 ++ 456
res2: Traversable[Int] = List(1, 2, 3, 4, 5, 6)</pre></div><p>The best thing about implicit conversions is that they support conversions for a type that's needed at some point in the code. For example, if you have the following function, which returns an ordered 
<code class="literal">Seq</code> from a 
<code class="literal">Traversable</code>:
</p><div class="informalexample"><pre class="programlisting">def orderedSeq[A: Ordering](t: Traversable[A]) = t.toSeq.sorted</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>You can pass an 
<code class="literal">Int</code> to 
<code class="literal">orderedSeq</code>, since there's an implicit conversion from 
<code class="literal">Int</code> to 
<code class="literal">Traversable[Int]</code>.
</p></div></div><div class="informalexample"><pre class="programlisting">orderedSeq(472).toList
// Returns List(2, 4, 7)</pre></div><p>When used indiscriminately, implicits can be dangerous, as they can enable runtime errors in locations where we would preferably want the compiler to not compile the code.</p><p>You should avoid implicit conversions between common types. The Scala compiler signals implicit conversions as dangerous by warning when you define one by default.</p><p>As seen before, implicit 
<a class="indexterm" id="id301"/>conversions enable syntax-like extensions to the language. The pattern is common throughout the standard library and libraries in the Scala ecosystem. The pattern is usually called "rich wrappers", so when you see a class named 
<code class="literal">RichFoo</code>, it is likely that it is adding syntax-like extensions to the Foo type.
</p><p>To provide allocation-free extension methods, you can use implicit classes combined with value classes. For example, if you have the following 
<code class="literal">RichInt</code> definition:
</p><div class="informalexample"><pre class="programlisting">implicit class RichInt(val self: Int) extends AnyVal {
  def toHexString: String = java.lang.Integer.toHexString(self)
}</pre></div><p>A call to 
<code class="literal">3.toHexString</code>, for example, will result in a method call in a 
<code class="literal">static</code> object (
<code class="literal">RichInt$.MODULE$.extension$toHexString(3)</code>) rather than a method call on a newly instantiated one.
</p></div><div class="section" title="Implicit Resolution"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Implicit Resolution</h2></div></div></div><p>It is important 
<a class="indexterm" id="id302"/>to know where the compiler looks for implicits and, even more importantly, how it decides which implicit to use in situations of apparent ambiguity.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>For more information on implicit resolution, refer to: 
<a class="ulink" href="https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">https://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a>.
</p><p>For choosing the most specific implicit definition based on the rules of static overloading resolution, refer to: 
<a class="ulink" href="http://scala-lang.org/files/archive/spec/2.11/06-expressions.html">http://scala-lang.org/files/archive/spec/2.11/06-expressions.html</a>.
</p></div></div><p>The rules of implicit resolution are a bit challenging to remember, so experimenting with them can give you more intuition over the Scala compiler.</p><p>The following
<a class="indexterm" id="id303"/> list defines where the compiler looks for implicits:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implicits which are defined in the current scope</li><li class="listitem" style="list-style-type: disc">Explicit Imports</li><li class="listitem" style="list-style-type: disc">Wildcard Imports</li><li class="listitem" style="list-style-type: disc">Companion Objects of Type</li><li class="listitem" style="list-style-type: disc">Implicit Scope of an Argument's Type</li><li class="listitem" style="list-style-type: disc">Implicit Scope of Type Arguments</li><li class="listitem" style="list-style-type: disc">Outer Objects for Nested Types</li></ul></div></div><div class="section" title="Activity: Creation of Extension Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Activity: Creation of Extension Methods</h2></div></div></div><p>In this 
<a class="indexterm" id="id304"/>activity, we'll be creating extension methods for the 
<code class="literal">Int</code> type by relying on implicit conversions.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by defining a new class, <code class="literal">RichInt</code>, which will implement your desired methods.</li><li class="listitem">Create an implicit conversion from <code class="literal">Int</code> to <code class="literal">RichInt</code>. You can either create an implicit method or an implicit value class. Since it's important to avoid the runtime overhead, an implicit value class is advisable.</li><li class="listitem">Implement the methods <code class="literal">square</code> and <code class="literal">plus</code>.</li><li class="listitem">Make sure the implicit conversion is in scope, and experiment with calling <code class="literal">square</code> and <code class="literal">plus</code> on values of type <code class="literal">Int</code>.</li></ol></div><p>This section 
<a class="indexterm" id="id305"/>covered implicit parameters and implicit conversions. We saw how to enable elegant extension methods for your code. We also had a look at how the Scala compiler resolves implicits.
</p></div></div></div>
<div class="section" title="Ad Hoc Polymorphism and Type Classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec29"/>Ad Hoc Polymorphism and Type Classes</h1></div></div></div><p>In this section, we'll be exploring ad hoc polymorphism, but through the usage of type classes.</p><div class="section" title="Types of Polymorphism"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec90"/>Types of Polymorphism</h2></div></div></div><p>In computer science, polymorphism is 
<a class="indexterm" id="id306"/>the provision of a single interface to entities of different types. Polymorphism consists of three types: subtyping, parametric polymorphism, and ad hoc polymorphism.
</p><p>Subtyping enables polymorphism by having different implementations of the same method (but keeping the interface) in the different subclasses. Parametric polymorphism enables polymorphism by allowing code to be written without the mention of a specific type. For example, when you operate over a generic 
<code class="literal">List</code>, you're applying parametric polymorphism. Ad hoc polymorphism enables polymorphism by allowing different and heterogeneous implementations
<a class="indexterm" id="id307"/> depending on specified types. Method overloading is an example
<a class="indexterm" id="id308"/> of ad hoc polymorphism.
</p></div><div class="section" title="Type Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Type Classes</h2></div></div></div><p>Type classes 
<a class="indexterm" id="id309"/>are a construct that enable ad hoc polymorphism. They originally appeared in Haskell, which has native support for them, but transitioned to Scala through the use of implicits.
</p><p>At its core, a 
<code class="literal">type</code> class is a class with a 
<code class="literal">type</code> parameter that aims to bridge type hierarchies. That is, we want to provide behavior to a type hierarchy by parameterizing our 
<code class="literal">type</code> class and providing specific implementations for concrete types. Type classes provide an easy way to extend libraries without touching existing code.
</p><p>As a running example throughout this section, consider the following implementation of JSON:</p><div class="informalexample"><pre class="programlisting">sealed trait JsValue
case class JsObject(fields: Map[String, JsValue]) extends JsValue
case class JsArray(elements: Vector[JsValue]) extends JsValue
case class JsString(value: String) extends JsValue
case class JsNumber(value: BigDecimal) extends JsValue

sealed trait JsBoolean extends JsValue
case object JsTrue extends JsBoolean
case object JsFalse extends JsBoolean

case object JsNull extends JsValue</pre></div><p>We will be introducing a type class called 
<code class="literal">JsonWriter[A]</code>, whose interface has a single method 
<code class="literal">write</code>, which, given an 
<code class="literal">A</code>, returns a 
<code class="literal">JsValue</code>. Let's define 
<code class="literal">JsonWriter</code> and
<a class="indexterm" id="id310"/> provide two implementations of it, one for 
<code class="literal">Int</code> and another for 
<code class="literal">String</code>:
</p><div class="informalexample"><pre class="programlisting">trait JsonWriter[A] {
  def write(value: A): JsValue
}

object JsonWriter {
  implicit object IntJsonWriter extends JsonWriter[Int] {
    def write(value: Int): JsValue = JsNumber(value)
  }

  implicit object StringJsonWriter extends JsonWriter[String] {
    def write(value: String): JsValue = JsString(value)
  }
}</pre></div><p>We can use these specific implementations of 
<code class="literal">JsonWriter</code> to convert 
<code class="literal">Ints</code> and Strings to JSON. For example, we can call 
<code class="literal">IntJsonWriter.write(4)</code> and 
<code class="literal">StringJsonWriter.write("Hello World")</code>. However, we don't want to be calling writers explicitly.
</p><p>Instead of calling 
<code class="literal">JsonWriters</code> explicitly, we introduce the 
<code class="literal">toJson</code> method, which is capable of converting a type to JSON, provided that there is a 
<code class="literal">JsonWriter</code> in the scope:
</p><div class="informalexample"><pre class="programlisting">def toJson[A](value: A)(implicit jw: JsonWriter[A]) =
  jw.write(value)</pre></div><p>We have now introduced ad hoc polymorphism in the 
<code class="literal">toJson</code> function. Based on the type of value provided to 
<code class="literal">toJson</code>, we have different behaviors for the 
<code class="literal">toJson</code> function, controlled by the 
<code class="literal">JsonWriters</code> available in scope. The matter of scope is important. Recall that there is precedence to the implicit resolution. As such, library authors can provide their own default implementations
<a class="indexterm" id="id311"/> for their type classes, but you can always override it in your client code while keeping the same interface.
</p></div><div class="section" title="Context Bounds and Implicitly"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Context Bounds and Implicitly</h2></div></div></div><p>
<span class="strong"><strong>Context bounds</strong></span>
<a class="indexterm" id="id312"/>are syntactic sugar that reduce verbosity when you need to pass implicits around. By using a context bound, you reduce the need of an implicit parameter list. However, when using a context bound, you lose access to the implicit argument used when calling the method. To provide access to it, you can use the 
<code class="literal">implicitly</code> function. Implicitly 
<a class="indexterm" id="id313"/>provides access to the implicit of the requested type in scope. Its implementation is simply this:
</p><div class="informalexample"><pre class="programlisting">def implicitly[T](implicit e: T) = e</pre></div></div><div class="section" title="Type Classes in the Standard Library"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>Type Classes in the Standard Library</h2></div></div></div><p>The type class pattern 
<a class="indexterm" id="id314"/>is heavily used in the Scala standard library. Prime examples of its usage are the 
<code class="literal">Ordering</code> type classes previously introduced and the 
<code class="literal">CanBuildFrom</code> type class, which represents builder factories for Scala collections.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Please take a look at the 
<code class="literal">Ordering</code> and 
<code class="literal">CanBuildFrom</code> type classes on your own. A good overview of the 
<code class="literal">CanBuildFrom</code> type class can be obtained from the following guide: 
<a class="ulink" href="http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html">http://docs.scala-lang.org/overviews/core/architecture-of-scala-collections.html</a>.
</p></div></div><div class="section" title="Activity: Implementing Type Classes to Support Conversion"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl4sec02"/>Activity: Implementing Type Classes to Support Conversion</h3></div></div></div><p>In this activity, we'll be implementing 
<code class="literal">type</code> classes to support conversions to 
<code class="literal">JsValue</code> for
<a class="indexterm" id="id315"/> common Scala types. Consider the 
<code class="literal">JsValue</code> ADT that was introduced in the beginning of the section.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by defining, if you haven't already, the <code class="literal">toJson</code> method:<div class="informalexample"><pre class="programlisting">def toJson[A](value: A)(implicit jw: JsonWriter[A]): JsValue and 
the JsonWriter trait as trait JsonWriter[A] { def write(value: A): JsValue }</pre></div></li><li class="listitem">Implement <code class="literal">JsonWriter</code> for <code class="literal">Int</code>, <code class="literal">String,</code> and <code class="literal">Boolean</code>. The implementation for <code class="literal">Int</code> and <code class="literal">String</code> was already provided. A good place to put those implementations, according to the implicit resolution rules previously introduced, is in the companion object of <code class="literal">JsonWriter</code>.</li><li class="listitem">Implement <code class="literal">JsonWriter</code> for <code class="literal">List</code>, <code class="literal">Set,</code> and <code class="literal">Map</code>. In these generic collections, note that you can provide a <code class="literal">JsonWriter[List[A]]</code>, for example, if you have a <code class="literal">JsonWriter</code> for <code class="literal">A</code>. Not all maps are convertible to JSON, so only provide a <code class="literal">Js</code><code class="literal">onWriter[Map[String, A]]</code>.</li></ol></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Summary</h1></div></div></div><p>In this chapter, we covered implicit parameters and implicit conversions. We saw how to enable elegant extension methods for your code. We also had a look at how the Scala compiler resolves implicits. Finally, we covered how implicits work, how to use them, and what kind of benefits they provide.</p><p>In the next chapter, we'll cover the core concepts of functional programming such as Pure functions, immutability, and higher-order functions. We'll build upon this understanding and introduce some of the design patterns that are prevalent in large functional programs that you'll no doubt run into once you start to use Scala libraries that focus on functional programming. Finally, we'll cover two popular functional programming libraries called 
<code class="literal">Cats</code> and 
<code class="literal">Doobie</code>, and use them to write some interesting programs.
</p></div></body></html>