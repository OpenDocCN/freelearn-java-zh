<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;WebSockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. WebSockets</h1></div></div></div><p>Traditionally, web applications have been developed using the request/response model followed by the HTTP protocol. In this model, the request is always initiated by the client and then the server returns a response back to the client.</p><p>There has never been any way for the server to send data to the client independently (without having to wait for a request from the browser) until now. The <a id="id664" class="indexterm"/>WebSocket protocol allows full-duplex, two-way communication between the client (browser) and the server.</p><p>Java EE 7 introduce<a id="id665" class="indexterm"/>s the Java API for WebSocket, which allows us to develop WebSocket endpoints in Java. The Java API<a id="id666" class="indexterm"/> for WebSocket is a brand-new technology in the Java EE Standard.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>A socket is a<a id="id667" class="indexterm"/> two-way pipe that stays alive longer than a single request. Applied to an HTML5-compliant browser, this would allow for continuous communication to or from a web server without the need to load a new page (similar to AJAX).</p></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developing WebSocket server endpoints</li><li class="listitem" style="list-style-type: disc">Developing WebSocket clients in JavaScript</li><li class="listitem" style="list-style-type: disc">Developing WebSocket clients in Java</li></ul></div><div class="section" title="Developing a WebSocket server endpoint"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Developing a WebSocket server endpoint</h1></div></div></div><p>A WebSocket server endpoint is a<a id="id668" class="indexterm"/> Java class deployed to the application server that handles WebSocket requests.</p><p>There are two ways in which we can implement a WebSocket server endpoint via the Java API for WebSocket: either by developing an endpoint programmatically, in which case we need to extend the <code class="literal">javax.websocket.Endpoint</code> class, or by decorating <span class="strong"><strong>Plain Old Java Objects</strong></span> (<span class="strong"><strong>POJOs</strong></span>)<a id="id669" class="indexterm"/> with WebSocket-specific annotations. The two approaches are very similar; therefore, we will be discussing only the annotation approach in detail and briefly explaining the second approach, that is, developing WebSocket server endpoints programmatically, later<a id="id670" class="indexterm"/> in this section.</p><p>In this chapter, we will develop a simple web-based chat application, taking full advantage of the Java API for WebSocket.</p><div class="section" title="Developing an annotated WebSocket server endpoint"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec54"/>Developing an annotated WebSocket server endpoint</h2></div></div></div><p>The following Java class code<a id="id671" class="indexterm"/> illustrates how to develop a WebSocket server<a id="id672" class="indexterm"/> endpoint by annotating a Java class:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.websocketchat.serverendpoint;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.websocket.OnClose;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.server.ServerEndpoint;

<span class="strong"><strong>@ServerEndpoint("/websocketchat")</strong></span>
public class WebSocketChatEndpoint {

  private static final Logger LOG = Logger.getLogger(WebSocketChatEndpoint.class.getName());

<span class="strong"><strong>  @OnOpen</strong></span>
  public void connectionOpened() {
    LOG.log(Level.INFO, "connection opened");
  }

<span class="strong"><strong>  @OnMessage</strong></span>
  public synchronized void processMessage(Session session, String message) {
    LOG.log(Level.INFO, "received message: {0}", message);

    try {
<span class="strong"><strong>      for (Session sess : session.getOpenSessions()) {</strong></span>
<span class="strong"><strong>        if (sess.isOpen()) {</strong></span>
<span class="strong"><strong>          sess.getBasicRemote().sendText(message);</strong></span>
<span class="strong"><strong>        }</strong></span>
<span class="strong"><strong>      }</strong></span>
    } catch (IOException ioe) {
      LOG.log(Level.SEVERE, ioe.getMessage());
    }
  }

  @OnClose
  public void connectionClosed() {
    LOG.log(Level.INFO, "connection closed");
  }

}</pre></div><p>The class-level <code class="literal">@ServerEndpoint</code> annotation<a id="id673" class="indexterm"/> indicates that the class is a WebSocket server endpoint. The <a id="id674" class="indexterm"/>
<span class="strong"><strong>URI</strong></span> (<span class="strong"><strong>Uniform Resource Identifier</strong></span>) of the server endpoint is the value specified within the parentheses following the annotation (which is <code class="literal">"/websocketchat"</code> in this example)—WebSocket clients will use this URI to communicate with our endpoint.</p><p>The <code class="literal">@OnOpen</code> annotation is used to decorate a method that needs to be executed whenever a WebSocket connection is opened by any<a id="id675" class="indexterm"/> of the clients. In our example, we are simply sending some output to the server log, but of course, any valid server-side Java code can be placed here.</p><p>Any method annotated with the <code class="literal">@OnMessage</code> annotation<a id="id676" class="indexterm"/> will be invoked whenever our server endpoint receives a message from a client. Since we are developing a chat application, our code simply<a id="id677" class="indexterm"/> broadcasts the message it receives to all connected clients.</p><p>In our example, the <code class="literal">processMessage()</code> method<a id="id678" class="indexterm"/> is annotated with <code class="literal">@OnMessage</code>, and takes two parameters: an instance of a class implementing the <code class="literal">javax.websocket.Session</code> interface and a <code class="literal">String</code> parameter containing the message that was received. Since we are developing a chat application, our WebSocket server endpoint simply broadcasts the received message to all connected clients.</p><p>The <code class="literal">getOpenSessions()</code> method <a id="id679" class="indexterm"/>of the <code class="literal">Session</code> interface returns a set of session objects representing all open sessions. We iterate through this set to broadcast the received message to all connected clients by invoking the <code class="literal">getBasicRemote()</code> method<a id="id680" class="indexterm"/> on each session instance and then invoking the <code class="literal">sendText()</code> method<a id="id681" class="indexterm"/> on the resulting <code class="literal">RemoteEndpoint.Basic</code> implementation returned by calling the previous method.</p><p>The <code class="literal">getOpenSessions()</code> method<a id="id682" class="indexterm"/> on the <code class="literal">Session</code> interface returns all the open sessions at the time it was invoked. It is possible for one or more of the sessions to have closed after the method was invoked; therefore, it is recommended to invoke the <code class="literal">isOpen()</code> method<a id="id683" class="indexterm"/> on a <code class="literal">Session</code> implementation before attempting to return data back to the client. An exception may be thrown if we attempt to access a closed session.</p><p>Finally, we need to decorate a method with the <code class="literal">@OnClose</code> annotation in case we need to handle the event when a client <a id="id684" class="indexterm"/>disconnects from the server endpoint. In our example, we simply log a message into the server log.</p><p>There is one additional annotation that we didn't use in our example—the <code class="literal">@OnError</code> annotation; it is used to decorate a method that needs to be invoked in case there's an error while sending or receiving data to or from the client.</p><p>As we can see, developing an annotated <a id="id685" class="indexterm"/>WebSocket server endpoint is straightforward. We simply need to add a few annotations, and the application server will invoke our annotated methods as necessary.</p><p>If we wish to develop a WebSocket server endpoint programmatically, we need to write a Java class that extends <code class="literal">javax.websocket.Endpoint</code>. This class has the <code class="literal">onOpen()</code>, <code class="literal">onClose()</code>,<a id="id686" class="indexterm"/> and <code class="literal">onError()</code> methods<a id="id687" class="indexterm"/> that are called at appropriate times during the endpoint's life cycle. There is no method equivalent to the <code class="literal">@OnMessage</code> annotation to handle incoming messages from clients. The <code class="literal">addMessageHandler()</code> method<a id="id688" class="indexterm"/> needs to be invoked in the session, passing an instance of a class implementing the <code class="literal">javax.websocket.MessageHandler</code> interface (or one of its subinterfaces) as its sole parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>In general, it is easier and more straightforward to develop annotated WebSocket endpoints compared to their programmatic counterparts. Therefore, we recommend that you use the annotated approach whenever possible.</p></div></div></div></div></div>
<div class="section" title="Developing WebSocket clients"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Developing WebSocket clients</h1></div></div></div><p>Most WebSocket clients are implemented as HTML5 web pages, taking advantage of the JavaScript WebSocket API. As such, they must be accessed using an HTML5-compliant web browser (most modern <a id="id689" class="indexterm"/>web browsers are HTML5 compliant).</p><p>The Java API for WebSocket provides a client API that allows us to develop WebSocket clients as standalone Java applications. <a id="id690" class="indexterm"/>We will cover how to do this in a later section,<span class="emphasis"><em> Developing WebSocket clients in Java</em></span>.</p><div class="section" title="Developing JavaScript client-side WebSocket code"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec55"/>Developing JavaScript client-side WebSocket code</h2></div></div></div><p>In this section, we will cover how to develop client-side JavaScript code to interact with the WebSocket endpoint <a id="id691" class="indexterm"/>we developed in the previous section.</p><p>The client page for our WebSocket example is implemented as a JSF page using HTML5-friendly markup (as explained in <a class="link" href="ch02.html" title="Chapter 2. JavaServer Faces">Chapter 2</a>, <span class="emphasis"><em>JavaServer Faces</em></span>).</p><p>Our client page consists of a text area where we can see what the users of our application are saying (it is, after all, a chat application) and an input text we can use to send a message to the other users, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_07_01.jpg" alt="Developing JavaScript client-side WebSocket code"/></div><p>The markup for our client page looks like the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE html&gt;
&lt;html &gt;
  &lt;head&gt;
    &lt;title&gt;WebSocket Chat&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width"/&gt;
<span class="strong"><strong>    &lt;script type="text/javascript"&gt;</strong></span>
<span class="strong"><strong>      var websocket;</strong></span>
<span class="strong"><strong>      function init() {</strong></span>
<span class="strong"><strong>        websocket = new WebSocket('ws://localhost:8080/websocketchat/websocketchat');</strong></span>

<span class="strong"><strong>        websocket.onopen = function(event) {</strong></span>
<span class="strong"><strong>          websocketOpen(event)</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>        websocket.onmessage = function(event) {</strong></span>
<span class="strong"><strong>          websocketMessage(event)</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>        websocket.onerror = function(event) {</strong></span>
<span class="strong"><strong>          websocketError(event)</strong></span>
<span class="strong"><strong>        };</strong></span>
<span class="strong"><strong>      }</strong></span>

<span class="strong"><strong>      function websocketOpen(event) {</strong></span>
<span class="strong"><strong>        console.log("webSocketOpen invoked");</strong></span>
<span class="strong"><strong>      }</strong></span>

<span class="strong"><strong>      function websocketMessage(event) {</strong></span>
<span class="strong"><strong>        console.log("websocketMessage invoked");</strong></span>
<span class="strong"><strong>        document.getElementById('chatwindow').value += '\r' + event.data;</strong></span>
<span class="strong"><strong>      }</strong></span>

<span class="strong"><strong>      function websocketError(event) {</strong></span>
<span class="strong"><strong>        console.log("websocketError invoked");</strong></span>
<span class="strong"><strong>      }</strong></span>

<span class="strong"><strong>      function sendMessage() {</strong></span>
<span class="strong"><strong>        var userName =</strong></span>
<span class="strong"><strong>        document.getElementById('userName').value;</strong></span>
<span class="strong"><strong>        var msg =</strong></span>
<span class="strong"><strong>        document.getElementById('chatinput').value;</strong></span>

<span class="strong"><strong>        websocket.send(userName + ": " + msg);</strong></span>
<span class="strong"><strong>      }</strong></span>
<span class="strong"><strong>      function closeConnection(){</strong></span>
<span class="strong"><strong>        websocket.close();</strong></span>
<span class="strong"><strong>      }</strong></span>

<span class="strong"><strong>      window.addEventListener("load", init);</strong></span>
<span class="strong"><strong>    &lt;/script&gt;</strong></span>
  &lt;/head&gt;
  &lt;body&gt;
    &lt;form jsf:prependId="false"&gt;
      &lt;input type="hidden" id="userName" value="#{user.userName}"/&gt;
      &lt;table border="0"&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &lt;label for="chatwindow"&gt;
              Chat Window
            &lt;/label&gt;
          &lt;/td&gt;
          &lt;td&gt;
<span class="strong"><strong>            &lt;textArea id="chatwindow" rows="10"/&gt;</strong></span>
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &lt;label for="chatinput"&gt;
              Type Something Here
            &lt;/label&gt;
          &lt;/td&gt;
          &lt;td&gt;
<span class="strong"><strong>            &lt;input type="text" id="chatinput"/&gt;</strong></span>
<span class="strong"><strong>            &lt;input id="sendBtn" type="button" value="Send" onclick="sendMessage()"/&gt;</strong></span>
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;
<span class="strong"><strong>          &lt;input type="button" id="exitBtn" value="Exit" onclick="closeConnection()"/&gt;</strong></span>
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The last line of our JavaScript code (<code class="literal">window.addEventListener("load", init);</code>) sets our JavaScript <code class="literal">init()</code> function to be executed as soon as the page loads.</p><p>Within the <code class="literal">init()</code> method, we initialize a new JavaScript <code class="literal">websocket</code> object, passing the URI of our server endpoint as a<a id="id692" class="indexterm"/> parameter. This tells our JavaScript code the location of our server endpoint.</p><p>The JavaScript <code class="literal">websocket</code> object has a number of function types used to handle different events, such as opening the connection, receiving a message, and handling errors. We need to set these types to our own JavaScript functions so that we can handle these events, which is what we do in our <code class="literal">init()</code> method<a id="id693" class="indexterm"/> right after invoking the constructor for the JavaScript <code class="literal">websocket</code> object. In our example, the functions we assigned to the <code class="literal">websocket</code> object simply delegate their functionality to standalone JavaScript functions.</p><p>Our <a id="id694" class="indexterm"/>
<code class="literal">websocketOpen()</code> function is called every time the WebSocket connection is opened. In our example, we simply send a message to the browser's JavaScript console.</p><p>The <a id="id695" class="indexterm"/>
<code class="literal">webSocketMessage()</code> function is invoked every time the browser receives a WebSocket message from our WebSocket endpoint. In our example, we updated the contents of the text area whose <code class="literal">id</code> is <code class="literal">chatWindow</code> and the contents of the message.</p><p>The <code class="literal">websocketError()</code> function<a id="id696" class="indexterm"/> is called every time there is a WebSocket-related error. In our example, we simply send a message to the browser's JavaScript console.</p><p>The JavaScript <code class="literal">sendMessage()</code> function<a id="id697" class="indexterm"/> sends a message to the WebSocket server endpoint, containing both the username and the contents of the text input whose <code class="literal">id</code> is <code class="literal">chatinput</code>. This function is called when the user clicks on the button whose <code class="literal">id</code> is <code class="literal">sendBtn</code>.</p><p>The <code class="literal">closeConnection()</code> JavaScript function<a id="id698" class="indexterm"/> closes the connection to our WebSocket server endpoint. This function is called when the user clicks on the button whose <code class="literal">id</code> is <code class="literal">exitBtn</code>.</p><p>As we can see from this example, writing client-side JavaScript code to interact with WebSocket endpoints is fairly straightforward.</p></div><div class="section" title="Developing WebSocket clients in Java"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec56"/>Developing WebSocket clients in Java</h2></div></div></div><p>Although developing <a id="id699" class="indexterm"/>web-based WebSocket clients is currently the most common way of developing WebSocket clients, the Java API for WebSocket provides a client API that we can use to develop WebSocket clients in Java.</p><p>In this section, we will be developing a simple WebSocket client using the client API of the Java API for WebSocket. <a id="id700" class="indexterm"/>The final product looks as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_07_02.jpg" alt="Developing WebSocket clients in Java"/></div><p>However, we won't be covering the GUI code in this section (developed using the Swing framework), since it is not relevant to this discussion. The complete code for the example, including the GUI code, can be downloaded from the Packt Publishing website at <a class="ulink" href="http://www.packtpub.com">www.packtpub.com</a>.</p><p>Just as with WebSocket server <a id="id701" class="indexterm"/>endpoints, Java WebSocket clients can be developed either programmatically or using annotations. Once again, we will cover only the annotation approach: developing a programmatic client is very similar to the way programmatic server endpoints are developed, that is, programmatic clients must extend <code class="literal">javax.websocket.Endpoint</code> and override the appropriate methods.</p><p>Without further ado, the following is the code for our Java WebSocket client:</p><div class="informalexample"><pre class="programlisting">package net.ensode.websocketjavaclient;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import javax.websocket.ClientEndpoint;
import javax.websocket.CloseReason;
import javax.websocket.ContainerProvider;
import javax.websocket.DeploymentException;
import javax.websocket.OnClose;
import javax.websocket.OnError;
import javax.websocket.OnMessage;
import javax.websocket.OnOpen;
import javax.websocket.Session;
import javax.websocket.WebSocketContainer;

<span class="strong"><strong>@ClientEndpoint</strong></span>
public class WebSocketClient {

  private String userName;
  private Session session;
  private final WebSocketJavaClientFrame webSocketJavaClientFrame;

  public WebSocketClient(WebSocketJavaClientFrame webSocketJavaClientFrame) {
  this.webSocketJavaClientFrame = webSocketJavaClientFrame;

  try {
<span class="strong"><strong>    WebSocketContainer webSocketContainer = ContainerProvider.getWebSocketContainer();</strong></span>
<span class="strong"><strong>    webSocketContainer.connectToServer(this, new URI("ws://localhost:8080/websocketchat/websocketchat"));</strong></span>
  }
  catch (DeploymentException | IOException | URISyntaxException ex) {
    ex.printStackTrace();
  }

  }

<span class="strong"><strong>  @OnOpen</strong></span>
  public void onOpen(Session session) {
    System.out.println("onOpen() invoked");
    this.session = session;
  }

<span class="strong"><strong>  @OnClose</strong></span>
  public void onClose(CloseReason closeReason) {
    System.out.println("Connection closed, reason: "+ closeReason.getReasonPhrase());
  }

<span class="strong"><strong>  @OnError</strong></span>
  public void onError(Throwable throwable) {
    System.out.println("onError() invoked");
    throwable.printStackTrace();
  }

<span class="strong"><strong>  @OnMessage</strong></span>
  public void onMessage(String message, Session session) {
    System.out.println("onMessage() invoked");
    webSocketJavaClientFrame.getChatWindowTextArea().setText(webSocketJavaClientFrame.getChatWindowTextArea().getText() + "\n" + message);
  }

  public void sendMessage(String message) {
    try {
      System.out.println("sendMessage() invoked, message = " + message);
<span class="strong"><strong>      session.getBasicRemote().sendText(userName + ": " + message);</strong></span>
    }
    catch (IOException ex) {
      ex.printStackTrace();
    }
  }

  public String getUserName() {
    return userName;
  }

  public void setUserName(String userName) {
    this.userName = userName;
  }

}</pre></div><p>The class-level <code class="literal">@ClientEndPoint</code> annotation<a id="id702" class="indexterm"/> denotes<a id="id703" class="indexterm"/> that our class is a WebSocket client—all Java WebSocket clients must<a id="id704" class="indexterm"/> be annotated with this annotation.</p><p>The code to establish a connection to the WebSocket server endpoint is in our class constructor. First, we need to invoke <code class="literal">ContainerProvider.getWebSocketContainer()</code> to obtain an instance of <code class="literal">javax.websocket.WebSocketContainer</code>. We then establish a connection by invoking the <code class="literal">connectToServer()</code> method<a id="id705" class="indexterm"/> on our <code class="literal">WebSocketContainer</code> instance; then we pass a class annotated with <code class="literal">@ClientEndpoint</code> as the first parameter (we use <code class="literal">this</code> in our example since the connection code is within <a id="id706" class="indexterm"/>our WebSocket Java client code); and then we pass a URI object containing the WebSocket server endpoint URI as the second parameter.</p><p>After the connection is <a id="id707" class="indexterm"/>established, we are ready to respond to WebSocket events. Alert readers may have noticed that the exact same annotations we used to develop our server endpoint are used again in our client code.</p><p>Any method annotated with the <a id="id708" class="indexterm"/>
<code class="literal">@OnOpen</code> annotation will be invoked automatically when the connection to the WebSocket server endpoint is established. The method must return void and can have an optional parameter of the type <code class="literal">javax.websocket.Session</code>. In our example, we send some output to the console and initialize a class variable with the <code class="literal">Session</code> instance, which we received as a parameter.</p><p>Methods annotated with the <code class="literal">@OnClose</code> annotation<a id="id709" class="indexterm"/> are invoked whenever the WebSocket session is closed. The annotated method can have optional parameters of the types <code class="literal">javax.websocket.Session</code> and <code class="literal">CloseReason</code>. In our example, we chose to use only the <code class="literal">CloseReason</code> optional parameter since its class has a handy <code class="literal">getReasonPhrase()</code> method<a id="id710" class="indexterm"/> that provides a short explanation of why the session was closed.</p><p>The <code class="literal">@OnError</code> annotation<a id="id711" class="indexterm"/> is used to decorate any methods that are called when an error occurs. Methods annotated with <code class="literal">@OnError</code> must have a parameter of type <code class="literal">java.lang.Throwable</code> (the parent class of <code class="literal">java.lang.Exception</code>), and can have an optional parameter of type <code class="literal">Session</code>. In our example, we simply send the stack trace of the <a id="id712" class="indexterm"/>
<code class="literal">Throwable</code> parameter to <code class="literal">stderr</code>.</p><p>Methods annotated with <code class="literal">@OnMessage</code> are invoked every time an incoming WebSocket message is received. The <code class="literal">@OnMessage</code> methods <a id="id713" class="indexterm"/>can have different parameters depending on the type of message received and how we wish to handle it. In our example, we used the most common case: receiving a text message. In this particular case, we need a <code class="literal">String</code> parameter that will hold the contents of the message, and an optional <code class="literal">Session</code> parameter.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Refer to the JavaDoc documentation for <code class="literal">@OnMessage</code>, available at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html">http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html</a> for information on how to handle other types of messages.</p></div></div><p>In our example, we simply update the <span class="strong"><strong>Chat Window</strong></span> text area, appending the received message to its contents.</p><p>To send a WebSocket message,<a id="id714" class="indexterm"/> we invoke the <code class="literal">getBasicRemote()</code> method<a id="id715" class="indexterm"/> on our <code class="literal">Session</code> instance, then invoke the <code class="literal">sendText()</code> method<a id="id716" class="indexterm"/> on the resulting <code class="literal">RemoteEndpoint.Basic</code> implementation returned by this call (if this looks familiar, it is because we did the exact same<a id="id717" class="indexterm"/> thing in the WebSocket server endpoint code). In our example, we do this in the <code class="literal">sendMessage()</code> method<a id="id718" class="indexterm"/>.</p></div></div>
<div class="section" title="Additional information about the Java API for WebSocket"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Additional information about the Java API for WebSocket</h1></div></div></div><p>In this chapter, we covered the bulk of<a id="id719" class="indexterm"/> the functionality provided by the Java API for<a id="id720" class="indexterm"/> WebSocket. For additional information, refer to the user guide for Tyrus, the Java API for WebSocket reference implementation, at <a class="ulink" href="https://tyrus.java.net/documentation/1.3.1/user-guide.html">https://tyrus.java.net/documentation/1.3.1/user-guide.html</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we covered the Java API for WebSocket, which is a new Java EE API to develop WebSocket server endpoints and clients.</p><p>We first saw how to develop WebSocket server endpoints by taking advantage of the Java API for WebSockets. We focused on developing annotation-based WebSocket endpoints.</p><p>Then, we covered how to develop web-based WebSocket clients using JavaScript and the JavaScript built-in WebSocket API.</p><p>Finally, we explained how to develop WebSocket client applications in Java via the <code class="literal">@ClientEndpoint</code> annotation.</p><p>In the next chapter, we will cover the <span class="strong"><strong>Java Message Service</strong></span> (<span class="strong"><strong>JMS</strong></span>).</p></div></body></html>