- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding Bottlenecks and Optimizing Your Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding what makes your application perform below your expectations can be difficult
    if you don’t follow a systematic approach. When optimizing an application, it’s
    important to focus your efforts on facts, not guesses. For that reason, in this
    chapter, we’ll leverage the tools and learnings from [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    and we’ll tackle some common challenges by analyzing the footprints of the changes
    applied.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use observability tools to find the bottlenecks
    of your application and apply some common techniques of application optimization,
    such as caching and runtime tuning. You will also learn how to improve your application’s
    startup time and resource consumption by using native applications, which have
    been supported since Spring Boot 3’s release.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll run some load tests to apply stress to our application, and we’ll learn
    how to analyze the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go through the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Tuning the database connection pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared cache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Testcontainers with Redis cache
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a native image using Spring Boot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GraalVM Tracing Agent to configure the native application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a native executable using Spring Boot
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a native executable from a JAR
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I created an application that we’ll optimize during this chapter. This application
    provides some RESTful APIs to manage football data. The application uses PostgreSQL
    as a data repository. You can find it on https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/,
    in the `chapter7/football` folder. This application is already configured for
    observability, exposing a Prometheus endpoint with Actuator. To monitor the application,
    you can use Prometheus and Grafana.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus configuration
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: You will need to configure Prometheus, as explained in the *Integrating your
    application with Prometheus and Grafana* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103).
    I have already prepared the `prometheus.yml` file. You will need to get the IP
    address of your computer and set the value in the `prometheus.yml` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'I created a Grafana dashboard to monitor the application’s performance. To
    make it, I used the following dashboard as a starting point and adapted it for
    our purposes: [https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/](https://grafana.com/grafana/dashboards/12900-springboot-apm-dashboard/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to PostgreSQL, Prometheus, and Grafana, we’ll also use Redis for
    some recipes. As usual, the simplest way to run all these services on your computer
    is using Docker. You can get Docker from the product page: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    I will explain how to deploy each tool in its corresponding recipe.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: You may need a tool to execute SQL scripts in PostgreSQL. You can use the `psql`
    command-line tool or the more user-friendly *PgAdmin* tool. You can check the
    *Connect your application to PostgreSQL* recipe in [*Chapter 5*](B21646_05.xhtml#_idTextAnchor203)
    for more details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要一个工具来在PostgreSQL中执行SQL脚本。您可以使用`psql`命令行工具或更用户友好的*PgAdmin*工具。您可以在[*第5章*](B21646_05.xhtml#_idTextAnchor203)中查看*将应用程序连接到PostgreSQL*的菜谱以获取更多详细信息。
- en: I prepared some JMeter tests to generate some load over the application. You
    can download JMeter from the project website at [https://jmeter.apache.org](https://jmeter.apache.org).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一些JMeter测试来在应用程序上生成一些负载。您可以从项目网站[https://jmeter.apache.org](https://jmeter.apache.org)下载JMeter。
- en: For some of the recipes related to native applications, you will need the **GraalVM**
    JDK. You can follow the instructions to install it from the official website at
    [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些与原生应用程序相关的菜谱，您将需要**GraalVM** JDK。您可以根据官方网站[https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/)上的说明进行安装。
- en: 'All the recipes that will be demonstrated in this chapter can be found at:
    [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要演示的所有菜谱都可以在以下位置找到：[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter7)
- en: Tuning the database connection pool
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整数据库连接池
- en: Database connections are an expensive resource that can take some time when
    they’re created for the first time. For that reason, Spring Boot uses a technique
    known as connection pooling. When a connection pool is used, the application doesn’t
    create a direct connection to the database; instead, it requests an available
    connection to the connection pool. When the application doesn’t need a connection,
    it returns it to the pool. The connection pool usually creates some connections
    at the start of the application. When the connections are returned to the pool,
    they are not closed but reused by other parts of the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接是一种昂贵的资源，当它们第一次创建时可能需要一些时间。因此，Spring Boot使用一种称为连接池的技术。当使用连接池时，应用程序不会直接与数据库建立连接；相反，它向连接池请求一个可用的连接。当应用程序不需要连接时，它会将其返回到池中。连接池通常在应用程序启动时创建一些连接。当连接返回到池中时，它们不会被关闭，而是由应用程序的其他部分重用。
- en: A common challenge when operating applications is deciding on the connection
    pool size. If the size is too small, under a certain load, some requests will
    take longer as they wait for a connection to become available in the pool. If
    the connection pool is too large, it will waste resources in the database server,
    as open connections are expensive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作应用程序时，一个常见的挑战是确定连接池的大小。如果大小太小，在一定的负载下，一些请求会因为等待连接池中的连接变得可用而花费更长的时间。如果连接池太大，它将在数据库服务器上浪费资源，因为打开的连接是昂贵的。
- en: In this recipe, we’ll learn how to monitor the database connection pool in a
    Spring Boot application using standard metrics and monitoring tools. We’ll use
    the techniques and tools learned in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用标准指标和监控工具在Spring Boot应用程序中监控数据库连接池。我们将使用在[*第3章*](B21646_03.xhtml#_idTextAnchor103)中学到的技术和工具。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will optimize an application that I have already prepared
    for this purpose. You can find the application in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/football` folder. I recommend copying the folder’s content to
    your working directory, as we’ll apply different optimizations over the base project
    on each recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将优化我已经为此目的准备的应用程序。您可以在书籍的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)中找到该应用程序，在`chapter7/football`文件夹中。我建议将文件夹的内容复制到您的当前工作目录，因为我们将对每个菜谱在基础项目上应用不同的优化。
- en: 'The application uses PostgreSQL as a database engine and is configured for
    monitoring using Zipkin, Prometheus, and Grafana. You can run all these dependent
    services in Docker; for that purpose, I have prepared a `docker-compose-base.yml`
    file that you can find in the `chapter7/docker` folder. You can run this `docker-compose-base.yml`
    file by opening a terminal in the directory containing the file and executing
    the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用PostgreSQL作为数据库引擎，并配置了使用Zipkin、Prometheus和Grafana进行监控。你可以在Docker中运行所有这些依赖服务；为此，我在`chapter7/docker`文件夹中准备了一个`docker-compose-base.yml`文件。你可以通过在包含文件的目录中打开终端并执行以下命令来运行此`docker-compose-base.yml`文件：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Prometheus service has a configuration file named `prometheus.yml` that
    contains the application scrapping configuration. It points to my computer’s IP,
    but you will need to change it to your IP configuration. You should configure
    the Prometheus data source and the *SpringBoot APM Dashboard*. See the *Integrating
    your application with Prometheus and Grafana* recipe in [*Chapter 3*](B21646_03.xhtml#_idTextAnchor103),
    for more details.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus服务有一个名为`prometheus.yml`的配置文件，其中包含应用程序抓取配置。它指向我的电脑IP，但你需要将其更改为你的IP配置。你应该配置Prometheus数据源和*SpringBoot
    APM仪表板*。有关更多详细信息，请参阅[*第3章*](B21646_03.xhtml#_idTextAnchor103)中的*将应用程序与Prometheus和Grafana集成*配方。
- en: 'I have prepared a JMeter test to generate workload on the application. You
    can find it in `chapter7/jmeter/Football.jmx`. This test simulates a common use
    case for the sample Football Trading application. The test performs the following
    steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经准备了一个JMeter测试来在应用程序上生成工作负载。你可以在`chapter7/jmeter/Football.jmx`中找到它。此测试模拟了示例足球交易应用程序的常见用例。测试执行以下步骤：
- en: One user buys some cards.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个用户购买了一些卡片。
- en: Another user buys some cards.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一位用户购买了一些卡片。
- en: Both users try to use the cards in their albums.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两位用户都试图在他们自己的专辑中使用这些卡片。
- en: Then, the first user gets all available cards from the second user and vice
    versa, the second user gets all available cards from the first user.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，第一位用户从第二位用户那里获得了所有可用的卡片，反之亦然，第二位用户从第一位用户那里获得了所有可用的卡片。
- en: Both users examine the players on the cards from the other user.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两位用户检查来自另一位用户的卡片上的球员。
- en: They trade between them their available cards.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们之间交换他们可用的卡片。
- en: The test has 10 threads running simultaneously with no think time between requests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有10个线程同时运行，请求之间没有思考时间。
- en: How to do it…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We’ll launch the application and ensure we see the application metrics in Grafana.
    Ready to find the application bottleneck and optimize it? Let’s go for it!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动应用程序，并确保我们在Grafana中看到应用程序指标。准备好寻找应用程序瓶颈并优化它了吗？让我们行动起来吧！
- en: 'First, we’ll start the application, and we’ll check that we see the application
    metrics in Grafana. I’ll assume you have already started all dependent services
    as explained in the *Getting* *ready* section:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将启动应用程序，并检查我们是否在Grafana中看到应用程序指标。我将假设你已经按照*准备就绪*部分中解释的那样启动了所有依赖服务：
- en: Open Grafana at `http://localhost:3000`, then open the SpringBoot APM Dashboard.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`http://localhost:3000`打开Grafana，然后打开SpringBoot APM仪表板。
- en: Check that you can see data in the **Basic Statics** and **HikariCP** **Statics**
    sections.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保你可以在**基本静态**和**HikariCP静态**部分看到数据。
- en: Start the JMeter application and open the `football.jmx` file, which you can
    find in the `chapter7/jmeter` folder.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动JMeter应用程序并打开`football.jmx`文件，该文件位于`chapter7/jmeter`文件夹中。
- en: 'Execute the JMeter test and wait until it finishes. The test execution can
    take some minutes to complete:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行JMeter测试，等待其完成。测试执行可能需要几分钟才能完成：
- en: During the execution of the test, check the connection metrics in the **HikariCP
    Statistics** section in Grafana.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试执行过程中，检查Grafana中**HikariCP统计**部分的连接指标。
- en: 'You will see that there are pending connections:'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会看到存在挂起的连接：
- en: '![Figure 7.1: Hikari connection metrics](img/B21646_07_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：Hikari连接指标](img/B21646_07_1.jpg)'
- en: 'Figure 7.1: Hikari connection metrics'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：Hikari连接指标
- en: You can also see that the **Connection Acquire Time** value is over 4 ms all
    the time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到**连接获取时间**值始终超过4毫秒。
- en: '![Figure 7.2: Connection Acquire Time](img/B21646_07_2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：连接获取时间](img/B21646_07_2.jpg)'
- en: 'Figure 7.2: Connection Acquire Time'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：连接获取时间
- en: You can see the results summary by opening the **Summary** **Report** item.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过打开**摘要** **报告**项来查看结果摘要。
- en: '![Figure 7.3: Summary Report](img/B21646_07_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：摘要报告](img/B21646_07_3.jpg)'
- en: 'Figure 7.3: Summary Report'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：摘要报告
- en: You can also see them while the test runs, but the baseline will be taken once
    completed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在测试运行时查看它们，但基线将在完成后确定。
- en: '![Figure 7.4: Summary Report results – baseline results](img/B21646_07_4.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：总结报告结果 – 基线结果](img/B21646_07_4.jpg)'
- en: 'Figure 7.4: Summary Report results – baseline results'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：总结报告结果 – 基线结果
- en: In my environment, the total throughput is 987.5 **requests per second** (**RPS**),
    and the most used request is **get-user-player**, with a total of 145,142 requests
    and a throughput of 798 RPS. Note that the average time of the **get-user-player**
    operation is 6 milliseconds. Save the results of executing this test on your computer,
    as we’ll compare them after the optimizations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的环境中，总吞吐量为 987.5 **每秒请求**（**RPS**），最常用的请求是 **get-user-player**，总共有 145,142
    个请求，吞吐量为 798 RPS。请注意，**get-user-player** 操作的平均时间为 6 毫秒。请将您电脑上执行此测试的结果保存下来，因为我们在优化后将会比较它们。
- en: Now, we’ll change the HikariCP settings by increasing the maximum number of
    database connections. For that, open the `application.yml` file in the `resources`
    folder and modify the `spring.datasource.hikari.maximum-pool-size` setting by
    increasing it to `10`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过增加数据库连接的最大数量来更改 HikariCP 设置。为此，打开 `resources` 文件夹中的 `application.yml`
    文件，并将 `spring.datasource.hikari.maximum-pool-size` 设置增加至 `10`。
- en: 'Let’s repeat the same performance test and see the difference. But before that,
    let’s do a clean-up of the data to execute the test in the same conditions:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们重复相同的性能测试并看看差异。但在那之前，让我们清理数据以在相同的条件下执行测试：  '
- en: I prepared a script named `cleanup.sql` that you can run to clean up the database.
    You can find it in the `chapter7/dbscripts` folder.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我准备了一个名为 `cleanup.sql` 的脚本，您可以通过运行它来清理数据库。您可以在 `chapter7/dbscripts` 文件夹中找到它。
- en: In JMeter, use the **Clear all** button to reset the results.
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JMeter 中，使用 **清除所有** 按钮重置结果。
- en: 'Once the test is done, compare the results with the baseline. The results on
    my computer are the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，将结果与基线进行比较。我的电脑上的结果如下：
- en: The total throughput is 1,315 RPS. That is approximately a 33% performance increase
    compared to the baseline 987.5 RPS.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总吞吐量为 1,315 RPS。这比基线 987.5 RPS 大约提高了 33% 的性能。
- en: The **get-user-player** request throughput is 1,085.3 RPS. That is approximately
    a 36% performance increase compared to the baseline 798 RPS.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 请求的吞吐量为 1,085.3 RPS。这比基线 798 RPS 大约提高了 36% 的性能。'
- en: The average response time of the **get-user-player** operation is 2 milliseconds.
    In the baseline, it was 6 milliseconds. That is three times faster.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 操作的平均响应时间为 2 毫秒。在基线中，它是 6 毫秒。这快了三倍。'
- en: If you look at **HikariCP Statistics** in Grafana, you will see that there are
    no connections pending and the connection-acquire time has reduced. The connection
    acquire time metric on my computer is always below 10 microseconds.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在 Grafana 中查看 **HikariCP 统计信息**，您将看到没有挂起的连接，并且连接获取时间已经减少。我的电脑上的连接获取时间指标始终低于
    10 微秒。
- en: How it works…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Spring Boot uses HikariCP as a JDBC data source connection pool. If you don’t
    specify any pool size, the default is 10\. I configured the initial example with
    a maximum of four connections for learning purposes. During the initial load test,
    we observed in Grafana that the number of pending connections remained consistently
    above zero throughout the entire testing period. That means that there is always
    a request that is waiting for an available database connection.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 使用 HikariCP 作为 JDBC 数据源连接池。如果您没有指定任何池大小，默认值为 10。为了学习目的，我在初始示例中将最大连接数配置为四个。在初始负载测试期间，我们在
    Grafana 中观察到挂起的连接数在整个测试期间始终保持在零以上。这意味着始终有一个请求正在等待可用的数据库连接。
- en: As we saw with the connection acquire time metric, on average, the time waited
    to acquire a connection is 4 milliseconds. That means that for every request,
    we need to add 4 milliseconds for each database operation involved. For fast operations,
    such as **get-user-player**, that is two times the time required when there’s
    a connection available. Once we increased the size of the connection pool, this
    operation boosted its performance, and it was the most used operation in this
    scenario.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在连接获取时间指标中看到的那样，平均来说，获取连接所需的时间为 4 毫秒。这意味着对于每个请求，我们需要为每个涉及的数据库操作添加 4 毫秒。对于像
    **get-user-player** 这样的快速操作，在没有连接可用时，所需时间是两倍。一旦我们增加了连接池的大小，这个操作就提高了其性能，并且在这个场景中是最常用的操作。
- en: The rest of the operations also benefited from this new configuration, but as
    the request time with available connections is longer, the relative performance
    improvement is not that high.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的操作也受益于这种新的配置，但由于可用连接的请求时间较长，相对性能提升并不高。
- en: In this recipe, we focused on the number of database connections. But the same
    approach can be applied to other types of application metrics, for instance, the
    number of Tomcat concurrent threads. You can use the observability data exposed
    by the application and tune your settings accordingly to adjust to your workload.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们专注于数据库连接的数量。但同样的方法可以应用于其他类型的应用程序指标，例如Tomcat并发线程的数量。您可以使用应用程序暴露的可观察性数据，并相应地调整您的设置以适应您的负载。
- en: There’s more…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we fixed the connection availability by adding the maximum number
    of connections used simultaneously at a given moment, that is, 10 connections.
    As mentioned, database connections are an expensive resource that should be used
    wisely. Let’s consider a scenario with multiple instances of your service. Every
    additional connection for your application should be multiplied by the number
    of instances. Say you have 10 application instances; then, any additional connection
    should be multiplied by 10.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们通过增加在某一时刻同时使用的最大连接数来固定连接可用性，即10个连接。正如所述，数据库连接是一种昂贵的资源，应该明智地使用。让我们考虑一个具有多个服务实例的场景。为您的应用程序提供的每个额外连接都应该乘以实例的数量。比如说，您有10个应用程序实例；那么，任何额外的连接都应该乘以10。
- en: During the execution of the baseline test, we detected a maximum of six pending
    connections, so we added those six connections to the four initial connections.
    If the maximum number of pending connections happens only during a few spikes,
    we can adjust the number of maximum connections to 1 or 2 fewer connections than
    the maximum detected. For instance, in our scenario, we could adjust the number
    of maximum connections to 9, repeat the load test, and observe the impact.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试执行期间，我们检测到最多有六个挂起的连接，因此我们将这六个连接添加到最初的四个连接中。如果最大挂起连接数仅在少数几个峰值期间发生，我们可以将最大连接数调整为比检测到的最大值少1或2个连接。例如，在我们的场景中，我们可以将最大连接数调整为9，重复负载测试，并观察其影响。
- en: Another potential adjustment is configuring the minimum and maximum number of
    connections. Then, if there is a spike and no available connections, HikariCP
    will create a connection to the database. Remember the time required to create
    the connection to the database and the time this connection will be idle. When
    the minimum and maximum connections are defined, HikariCP can close physical connections
    when idle. If the spike is too short, you may create a connection that will take
    longer than just waiting for an available connection, and then you will have an
    idle connection consuming resources in the database server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个潜在的调整是配置最小和最大连接数。然后，如果有峰值且没有可用连接，HikariCP将创建一个数据库连接。记住创建数据库连接所需的时间和这个连接将空闲的时间。当定义了最小和最大连接数时，HikariCP可以在空闲时关闭物理连接。如果峰值太短，您可能会创建一个连接，其创建时间将比等待可用连接更长，然后您将有一个空闲连接在数据库服务器上消耗资源。
- en: Caching dependencies
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存依赖
- en: 'The most common flow in the Football Trading application that we want to optimize
    is the following: sometimes, the users buy some cards, and after using them in
    their albums, they try to exchange the redundant cards they already have with
    other users. Before starting the exchange process, the users see which players
    are available from other users. There can be thousands and even millions of cards,
    but the total number of football players is around 700, and they are constantly
    retrieved from the Football Trading application.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要优化的足球交易应用中最常见的流程如下：有时，用户购买一些卡片，并在他们的专辑中使用后，试图与其他用户交换他们已经拥有的冗余卡片。在开始交换过程之前，用户会查看其他用户可用的球员。可能会有数千甚至数百万张卡片，但足球运动员的总数大约为700，他们不断从足球交易应用中检索。
- en: Now, you want to optimize the application’s performance. So, you are considering
    using a cache mechanism to avoid retrieving data from the database that is accessed
    frequently but changes very infrequently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您想要优化应用程序的性能。因此，您正在考虑使用缓存机制来避免从数据库检索频繁访问但很少更改的数据。
- en: In this recipe, you will learn how to identify a database bottleneck and how
    to apply the caching mechanisms provided by Spring Boot. You will learn how to
    measure the improvement using the observability tools you learned about in [*Chapter
    3*](B21646_03.xhtml#_idTextAnchor103).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将学习如何识别数据库瓶颈以及如何应用Spring Boot提供的缓存机制。您将学习如何使用您在[*第3章*](B21646_03.xhtml#_idTextAnchor103)中了解到的可观察性工具来衡量改进。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will continue optimizing the application that I prepared
    for this purpose. You can use the version resulting from the *Tuning the database
    connection pool* recipe. You can find the application in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-2/start` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将继续优化我为这个目的准备的应用程序。您可以使用来自*调整数据库连接池*配方版本的版本。您可以在本书的GitHub存储库中找到该应用程序，在[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)的`chapter7/recipe7-2/start`文件夹中。
- en: 'As we explained in the previous recipe, you can run all dependent services
    in Docker by running the `docker-compose-base.yml` Docker Compose file that you
    can find in the `chapter7/docker` folder. For that, open a terminal and execute
    the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的配方中解释的那样，您可以通过运行位于`chapter7/docker`文件夹中的`docker-compose-base.yml` Docker
    Compose文件来在Docker中运行所有依赖服务。为此，打开一个终端并执行以下命令：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We’ll use the same JMeter test we used in the previous recipe. You can find
    it in `chapter7/jmeter/football.jmx`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前配方中使用的相同的JMeter测试。您可以在`chapter7/jmeter/football.jmx`中找到它。
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s start by executing the JMeter load test to determine the performance
    baseline. Then, we’ll apply caching on different parts of the application, and
    we’ll measure the improvements:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从执行JMeter负载测试以确定性能基线开始。然后，我们将对应用程序的不同部分应用缓存，并测量改进：
- en: We can use the results of the JMeter execution from the *Tuning database connection
    pool* recipe test.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用来自*调整数据库连接池*配方测试的JMeter执行结果。
- en: '![Figure 7.5: JMeter summary report – baseline requests throughput detail](img/B21646_07_5.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：JMeter总结报告 – 基线请求吞吐量详情](img/B21646_07_5.jpg)'
- en: 'Figure 7.5: JMeter summary report – baseline requests throughput detail'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：JMeter总结报告 – 基线请求吞吐量详情
- en: In my environment, the total throughput is 1,340.3 RPS, and the most used request
    is **get-user-player**, with a total of 145,683 requests and a throughput of 1,085.3
    RPS. Save the results of executing this test on your computer, as we’ll compare
    them after the optimizations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的环境中，总吞吐量为1,340.3 RPS，最常用的请求是**get-user-player**，总共有145,683个请求，吞吐量为1,085.3
    RPS。请将执行此测试的结果保存在您的计算机上，因为我们在优化后将会比较它们。
- en: 'Now that we have our application baseline, we’ll enable caching:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序基线，我们将启用缓存：
- en: 'First, add the *Spring Cache Abstraction* starter to the `pom.xml` file:'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将*Spring Cache Abstraction*启动器添加到`pom.xml`文件中：
- en: '[PRE2]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in the `FootballApplication` class, add the `@``EnableCaching` annotation:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`FootballApplication`类中，添加`@EnableCaching`注解：
- en: '[PRE3]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we’ll modify the `getPlayer` method of the `FootballService` class to
    cache the responses. This is the method called in the `@Cacheable` as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改`FootballService`类的`getPlayer`方法以缓存响应。这是在`@Cacheable`中调用的方法如下：
- en: '[PRE4]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s execute the JMeter test again. But before that, let’s do a cleanup of
    the data to execute the test in the same conditions:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次执行JMeter测试。但在那之前，让我们清理数据以在相同条件下执行测试：
- en: I prepared a script named `cleanup.sql` that you can run to clean up the database.
    You can find it in the `chapter7/dbscripts` folder.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我准备了一个名为`cleanup.sql`的脚本，您可以通过运行它来清理数据库。您可以在`chapter7/dbscripts`文件夹中找到它。
- en: In JMeter, use the **Clear all** button to reset the results.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JMeter中，使用**清除所有**按钮重置结果。
- en: 'Once the test is done, check the results and compare them with the baseline.
    The results on my computer are the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试完成，检查结果并与基线进行比较。我的计算机上的结果如下：
- en: '![Figure 7.6: Summary report after applying caching on the FootballService](img/B21646_07_6.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：在FootballService上应用缓存后的总结报告](img/B21646_07_6.jpg)'
- en: 'Figure 7.6: Summary report after applying caching on the FootballService'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：在FootballService上应用缓存后的总结报告
- en: The total throughput jumped to 1,806.7 RPS from 1,340.3 RPS, approximately a
    34% performance increase.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总吞吐量从1,340.3 RPS跃升至1,806.7 RPS，大约提高了34%的性能。
- en: '**get-user-player** requests are 1,458.5 RPS, and the baseline was 1,085.3
    RPS, which means around a 34% performance increase as well.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get-user-player** 请求为 1,458.5 RPS，基线为 1,085.3 RPS，这意味着性能也提高了大约 34%。'
- en: The rest of the requests also increased by around 34% of the overall throughput.
    For instance, **get-user-cards** rose to 100.1 RPS from 74.5 RPS, and the other
    requests went from 37.2 RPS to 50.1 RPS.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余的请求也增加了大约 34% 的整体吞吐量。例如，**get-user-cards** 从 74.5 RPS 上升到 100.1 RPS，其他请求从
    37.2 RPS 上升到 50.1 RPS。
- en: 'Let’s use the caching in a different place in our application. Instead of applying
    the `@Cacheable` annotation in `FootballService`, apply the annotation in the
    `PlayersController` class in the `getPlayer` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在应用程序的不同位置使用缓存。不是在 `FootballService` 中应用 `@Cacheable` 注解，而是在 `PlayersController`
    类的 `getPlayer` 方法中应用注解：
- en: '[PRE5]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By adding the *Spring Cache Abstraction* starter and using the `@EnableCaching`
    annotation, Spring Boot inspects the Beans for the presence of caching annotations
    on public methods, and a proxy is created to intercept the method call and handle
    the caching behavior accordingly; in our case, the methods annotated with `@Cacheable`.
    Spring Boot registers a `CacheManager` Bean to handle the cached items, as we
    didn’t specify any specific `CacheManager`. Spring Boot uses the default implementation,
    a `ConcurrentHashMap` object, and it’s handled in the process. This approach is
    valid for elements that do not change and where the dataset is small. Otherwise,
    you may want to use an external shared cache. In the next recipe, we’ll tackle
    this scenario.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 *Spring Cache Abstraction* 启动器并使用 `@EnableCaching` 注解，Spring Boot 会检查 Beans
    中公共方法上是否存在缓存注解，并创建一个代理来拦截方法调用并相应地处理缓存行为；在我们的例子中，是带有 `@Cacheable` 注解的方法。Spring
    Boot 注册了一个 `CacheManager` Bean 来处理缓存项，因为我们没有指定任何特定的 `CacheManager`。Spring Boot
    使用默认实现，一个 `ConcurrentHashMap` 对象，并在处理过程中进行管理。这种方法适用于不经常变化且数据集较小的元素。否则，你可能想使用外部共享缓存。在下一个菜谱中，我们将处理这种情况。
- en: In this recipe, we optimized only `get-user-player`. It’s the best candidate
    for all operations performed in this recipe. The reason is that the operations
    that modify data frequently are not candidates for caching, so `buy-cards`, `use-cards`,
    and `trade-cards` cannot be cached as they modify the data and are frequently
    used. The only operations that read just data are `get-user-cards` and `get-user-player`.
    `get-user-cards` is not a good candidate as the cards available owned by a user
    change every time they buy cards, exchange cards, or use them in an album. That
    means that the cache will be updated frequently. In addition, the number of users
    is high, around 100,000, so adding all those elements to the application memory
    can be counterproductive. On the other hand, `get-user-player` just retrieves
    the player’s information. That information changes very infrequently, and there
    are just a few hundred players. For that reason, `get-user-player` is the best
    candidate for caching.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只优化了 `get-user-player`。它是这个菜谱中所有操作的最佳候选者。原因是修改数据频率较高的操作不适合缓存，所以 `buy-cards`、`use-cards`
    和 `trade-cards` 不能被缓存，因为它们修改数据并且经常被使用。唯一只读取数据的操作是 `get-user-cards` 和 `get-user-player`。`get-user-cards`
    不是一个好的候选者，因为用户拥有的卡片每次购买、交换或用于专辑时都会改变，这意味着缓存将频繁更新。此外，用户数量很高，大约有 100,000，所以将这些元素添加到应用程序内存中可能是适得其反的。另一方面，`get-user-player`
    只检索球员信息。这些信息变化非常不频繁，而且只有几百名球员。因此，`get-user-player` 是缓存的最佳候选者。
- en: By adding the cache in the `FootballService` class, the throughput of that operation
    improved significantly, but it also benefited the rest of the operations. The
    reason is that even though it is a quick request on the database, it is the most
    frequent operation. The number of database connections available is defined by
    the `hikaricp` connection pool; we configured 10 connections. All operations should
    acquire a connection from `hikaricp`. As the most frequent operation is reduced,
    it’s easier for the rest of the operations to acquire a connection faster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `FootballService` 类中添加缓存，该操作的吞吐量显著提高，但它也使其他操作受益。原因是尽管这是一个快速的数据库请求，但它是最频繁的操作。可用的数据库连接数由
    `hikaricp` 连接池定义；我们配置了 10 个连接。所有操作都应该从 `hikaricp` 获取连接。由于最频繁的操作减少了，其他操作获取连接的速度更快。
- en: There’s more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'I recommend you check the metrics exposed by the application in Grafana while
    you run the tests. There are two main areas to observe in this scenario:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在运行测试时检查应用在 Grafana 中暴露的指标。在这个场景中，有两个主要区域需要观察：
- en: '**Basic statistics**: Here we can find the classic metrics for every application:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本统计**：在这里，我们可以找到每个应用的经典指标：'
- en: '**CPU Usage**: This is often the limiting factor for demanding computing applications.
    During the tests on my computer, it was always under 70%.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU 使用率**：这通常是要求高的计算应用的限制因素。在我的电脑上的测试中，它始终低于 70%。'
- en: '**Heap Used**: This is the heap memory used by our application. It could limit
    the performance of our application.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆内存使用**：这是我们的应用使用的堆内存。它可能会限制我们应用的性能。'
- en: '**Non-heap Used**: This is all other memory used by our application. It usually
    accounts for less than 30% of the total memory used by the application, and its
    usage remains more stable than heap memory.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非堆内存使用**：这是我们的应用使用的所有其他内存。它通常占应用总内存使用的不到 30%，并且其使用比堆内存更稳定。'
- en: '**HikariCP** **S****tatistics**: As we saw in the previous recipe, HikariCP
    is the default database connection pool in Spring Boot. Creating a database connection
    to PostgreSQL or any other database engine is expensive. You can check the following
    metrics related to HikariCP:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HikariCP 统计**：正如我们在前面的菜谱中所见，HikariCP 是 Spring Boot 中的默认数据库连接池。创建到 PostgreSQL
    或任何其他数据库引擎的连接都是昂贵的。你可以检查以下与 HikariCP 相关的指标：'
- en: '**Active**: This is the number of connections out of the pool actively used
    to perform an operation in the database.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃**：这是池外用于在数据库中执行操作的连接数量。'
- en: '**Idle**: This is the number of available connections in the pool ready to
    be used when needed.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闲置**：这是池中可供使用以备不时之需的可用连接数量。'
- en: '**Pending**: This is the number of operations waiting for an available connection
    to access the database. Ideally, this metric should be 0.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：这是等待可用连接以访问数据库的操作数量。理想情况下，这个指标应该是 0。'
- en: '**Connection creation time**: This is the time spent creating the physical
    connection to the database.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接创建时间**：这是创建到数据库的物理连接所花费的时间。'
- en: '**Connection usage time**: This is how long a connection is used before being
    returned to the pool.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接使用时间**：这是连接被返回到池中之前的使用时长。'
- en: '**Connection acquire time**: This is the time required to get a connection.
    When there are idle connections, the time required will be very low. When there
    are pending connections, the time required will be higher.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接获取时间**：这是获取连接所需的时间。当有闲置连接时，所需时间会非常低。当有挂起的连接时，所需时间会更高。'
- en: '![Figure 7.7: HikariCP metrics in Grafana](img/B21646_07_7.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7：Grafana 中的 HikariCP 指标](img/B21646_07_7.jpg)'
- en: 'Figure 7.7: HikariCP metrics in Grafana'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：Grafana 中的 HikariCP 指标
- en: You may want to cache operations, as we did in this recipe, to reduce the number
    of connections to the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要缓存操作，就像我们在本菜谱中所做的那样，以减少对数据库的连接次数。
- en: In the next recipe, we’ll learn how to use Redis as an external cache and how
    to update it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习如何使用 Redis 作为外部缓存以及如何更新它。
- en: Using shared cache
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享缓存
- en: The sample Football Trading application needs to cover a new scenario. Some
    football players can play in different positions, sometimes as defenders and sometimes
    as midfielders. Players do not change their position frequently, but it may happen.
    As we learned in the previous recipe, caching the players can improve the application’s
    performance significantly. We assume it’s possible and recommended to have more
    than one application instance running simultaneously. When a player is updated,
    all the application instances should return the latest version of the player.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 样本足球交易应用需要覆盖一个新的场景。一些足球运动员可以胜任不同的位置，有时是后卫，有时是中场。球员不会频繁更换位置，但这种情况可能发生。正如我们在前面的菜谱中学到的，缓存球员可以显著提高应用性能。我们假设同时运行多个应用实例是可能的，也是推荐的。当一个球员被更新时，所有应用实例都应该返回球员的最新版本。
- en: In this recipe, we’ll learn how to use an external cache shared among all application
    instances and how to update the cache when the underlying data is modified.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用所有应用实例共享的外部缓存，以及当底层数据被修改时如何更新缓存。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll reuse the application resulting from the previous recipe,
    as it has already been configured for caching. I have prepared a working version
    in the GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/).
    It is in the `chapter7/recipe7-3/start` folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重用前一个菜谱生成的应用程序，因为它已经配置好了缓存。我在GitHub仓库中准备了一个工作版本，网址为[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/)。它位于`chapter7/recipe7-3/start`文件夹中。
- en: The application uses PostgreSQL as a database engine, configured for observability
    with Zipkin, Prometheus, and Grafana.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用PostgreSQL作为数据库引擎，配置了Zipkin、Prometheus和Grafana以进行可观察性。
- en: As we’ll add support for caching using Redis, we’ll need a Redis server. The
    easiest way to run Redis on your computer is using Docker.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将添加对Redis的缓存支持，我们需要一个Redis服务器。在您的计算机上运行Redis的最简单方法是使用Docker。
- en: 'I prepared a Docker Compose file named `docker-compose-redis.yml`, with all
    dependent services, that is, PostgreSQL, Zipkin, Prometheus, Grafana, and Redis.
    You can find that file in the `chapter7/docker` folder. To run all dependent services,
    open a terminal in the `chapter7/docker` folder and run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我准备了一个名为`docker-compose-redis.yml`的Docker Compose文件，其中包含所有依赖服务，即PostgreSQL、Zipkin、Prometheus、Grafana和Redis。你可以在`chapter7/docker`文件夹中找到该文件。要运行所有依赖服务，请在`chapter7/docker`文件夹中打开一个终端并运行以下命令：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I prepared a JMeter test to generate load for this recipe. You can find it in
    `chapter7/jmeter/Football-updates.jmx`. In addition to the flow implemented in
    the previous recipe, it updates the position of a football player from time to
    time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我为这个菜谱准备了一个JMeter测试来生成负载。你可以在`chapter7/jmeter/Football-updates.jmx`中找到它。除了前一个菜谱中实现的流程外，它还会不时更新足球运动员的位置。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We’ll start by preparing the application to use Redis, and later, we’ll ensure
    that the cache is updated when the players are modified:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先准备应用程序以使用Redis，然后确保当球员被修改时缓存会更新：
- en: 'First, we’ll add the *Spring Data Redis* starter dependency. For that, just
    add the following dependency in the `pom.xml` file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加`Spring Data Redis`启动器依赖项。为此，只需在`pom.xml`文件中添加以下依赖项：
- en: '[PRE7]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will need to add the following dependency to manage `LocalDate` fields:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要添加以下依赖来管理`LocalDate`字段：
- en: '[PRE8]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we need to configure Redis. For that, we will register a `RedisCacheConfiguration`
    Bean. Let’s create a new configuration class; you can name it `RedisConfig`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置Redis。为此，我们将注册一个`RedisCacheConfiguration` Bean。让我们创建一个新的配置类；你可以命名为`RedisConfig`：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, you must ensure that the cache is updated when the underlying data
    is updated. Let’s modify the `updatePlayerPosition` method in the `FootballService`
    class by adding the `@``CacheEvict` annotation:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你必须确保当底层数据更新时，缓存也会更新。让我们通过在`FootballService`类中添加`@CacheEvict`注解来修改`updatePlayerPosition`方法：
- en: '[PRE10]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, you can run the JMeter test to validate the application and measure the
    performance footprint. I prepared a test named `Football-updates.jmx` for that
    purpose. You can find it in the `chapter7/jmeter` folder. This test updates the
    player’s position randomly but very infrequently, then retrieves the player to
    validate that it has the position updated.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以运行JMeter测试来验证应用程序并测量性能影响。为此，我准备了一个名为`Football-updates.jmx`的测试。你可以在`chapter7/jmeter`文件夹中找到它。这个测试会随机但非常不频繁地更新球员的位置，然后检索球员以验证其位置是否已更新。
- en: '![Figure 7.8: JMeter test, showing the details of the player update](img/B21646_07_8.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图7.8：JMeter测试，显示球员更新的详细信息](img/B21646_07_8.jpg)'
- en: 'Figure 7.8: JMeter test, showing the details of the player update'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：JMeter测试，显示球员更新的详细信息
- en: On my computer, the total throughput is 1,497.5 RPS, and `get-user-players`
    is 1,210.6 RPS. The performance of Redis caching is slightly lower than in-process
    caching. However, externalizing the cache makes it possible to scale horizontally
    by adding additional instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，总吞吐量为1,497.5 RPS，`get-user-players`为1,210.6 RPS。Redis缓存的性能略低于进程内缓存。然而，将缓存外部化使得可以通过添加更多实例来实现水平扩展。
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When adding an external caching implementation, the application needs to serialize
    the objects to be cached to send them over the network and save them in Redis.
    The default Redis configuration can manage basic types such as `String` or `int`
    with no additional configuration. However, in this sample application, we need
    to cache `Player` objects. To use the default configuration, the `Player` class
    should implement the `Serializable` interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加外部缓存实现时，应用程序需要将需要缓存的对象序列化以通过网络发送并将它们保存到Redis中。默认的Redis配置可以管理基本类型，如`String`或`int`，无需额外配置。然而，在这个示例应用程序中，我们需要缓存`Player`对象。为了使用默认配置，`Player`类应该实现`Serializable`接口。
- en: To avoid modifying our domain classes, we configured a `Jackson2JsonRedisSerializer`
    serializer. This serializer represents the objects as JSON strings. The player
    has a catch with the `birthDate` field, as it is of the `LocalDate` type and cannot
    be managed with the default implementation. That is the reason we added the `com.fasterxml.jackson.datatype:jackson-datatype-jsr310`
    dependency and registered `JavaTimeModule` in `ObjectMapper` for `RedisCacheConfiguration`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免修改我们的领域类，我们配置了一个`Jackson2JsonRedisSerializer`序列化器。这个序列化器将对象表示为JSON字符串。玩家有一个关于`birthDate`字段的限制，因为它属于`LocalDate`类型，无法使用默认实现来管理。这就是我们添加`com.fasterxml.jackson.datatype:jackson-datatype-jsr310`依赖并在`ObjectMapper`中注册`JavaTimeModule`以用于`RedisCacheConfiguration`的原因。
- en: 'It’s important to consider the implications of using an external cache repository:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用外部缓存存储库的影响很重要：
- en: As we just learned, we must ensure the cached objects can be serialized.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚刚学习的，我们必须确保缓存的对象可以被序列化。
- en: You need to consider the network latency as well. I executed all load tests
    locally on my computer, so there was no network latency. In real environments,
    it can also impact the performance of the application.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要考虑网络延迟。我在我的电脑上本地执行了所有负载测试，所以没有网络延迟。在实际环境中，它也可能影响应用程序的性能。
- en: The caching server may become the new bottleneck. Redis is very performant,
    but it may imply adding new resources to your solution, such as new servers.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存服务器可能成为新的瓶颈。Redis非常高效，但它可能意味着需要向你的解决方案添加新资源，例如新服务器。
- en: I didn’t notice significant performance differences in my load test results
    because everything ran on the same computer; however, you may expect slight differences
    in a production environment with services distributed across different servers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的负载测试结果中，我没有注意到显著的性能差异，因为所有操作都在同一台电脑上运行；然而，你可能在具有跨不同服务器分布的服务器的生产环境中期望有轻微的差异。
- en: You must configure the server address if you run Redis on a different server.
    By default, the *Spring Data Redis* starter assumes that Redis runs on `localhost`
    and listens to port `6379`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将Redis运行在不同的服务器上，你必须配置服务器地址。默认情况下，*Spring Data Redis*启动器假定Redis运行在`localhost`并监听端口`6379`。
- en: 'In this recipe, we used the `@CacheEvict` annotation to update the cache. This
    annotation deletes the entry using a key. By default, this annotation uses all
    method parameters as the cache entry key. However, the `updatePlayerPosition`
    method has two parameters: the player `id` and the new `position`. As the key
    is just the player `id`, we specified that in the `position` field of the `@CacheEvict`
    annotation. Other options, such as clearing all entries, don’t apply to our scenario.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用了`@CacheEvict`注解来更新缓存。这个注解通过键来删除条目。默认情况下，这个注解使用所有方法参数作为缓存条目的键。然而，`updatePlayerPosition`方法有两个参数：玩家的`id`和新的`position`。因为键只是玩家的`id`，所以我们指定了`@CacheEvict`注解的`position`字段中。其他选项，如清除所有条目，不适用于我们的场景。
- en: Using Testcontainers with Redis cache
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用带有Redis缓存的Testcontainers
- en: If you have executed the automated tests available in the sample project in
    the previous recipe, you may have noticed that the tests using methods that require
    Redis are failing. The reason is that Redis is not available during the execution
    of the tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前一个菜谱中执行了示例项目中可用的自动化测试，你可能已经注意到使用需要Redis的方法的测试失败。原因是测试执行期间Redis不可用。
- en: In this recipe, we’ll learn how to set up a Redis server hosted as a Docker
    container using Testcontainers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Testcontainers设置作为Docker容器托管的Redis服务器。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll create the tests for the project created in the *Using
    shared cache* recipe. If you haven’t completed it yet, use the version I prepared
    as a starting point for this recipe. You can find it in the book’s GitHub repository
    at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter7/recipe7-4/start` folder.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为在*使用共享缓存*菜谱中创建的项目创建测试。如果你还没有完成，请使用我为这个菜谱准备的版本作为起点。你可以在书的GitHub仓库[https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)中的`chapter7/recipe7-4/start`文件夹中找到它。
- en: As we use Testcontainers, you will need Docker installed on your computer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们使用Testcontainers，你需要在电脑上安装Docker。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We like reliable applications. Let’s make our tests work!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢可靠的应用程序。让我们让我们的测试工作起来！
- en: 'We’ll make all changes in the `FootballServiceTest` class. So, open it and
    add a new static field of type `GenericContainer`. We’ll expose the default Redis
    port at `6379`, and we’ll use the latest `redis` image:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`FootballServiceTest`类中做出所有更改。所以，打开它并添加一个新的静态字段，类型为`GenericContainer`。我们将暴露默认的Redis端口`6379`，并使用最新的`redis`镜像：
- en: '[PRE11]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: static class Initializer
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static class Initializer
- en: implements ApplicationContextInitializer<ConfigurableApplicationContext> {
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: implements ApplicationContextInitializer<ConfigurableApplicationContext> {
- en: public void initialize(ConfigurableApplicationContext configurableApplicationContext)
    {
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public void initialize(ConfigurableApplicationContext configurableApplicationContext)
    {
- en: TestPropertyValues.of(
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TestPropertyValues.of(
- en: '"spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.url=" + postgreSQLContainer.getJdbcUrl(),'
- en: '"spring.datasource.username=" + postgreSQLContainer.getUsername(),'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.username=" + postgreSQLContainer.getUsername(),'
- en: '"spring.datasource.password=" + postgreSQLContainer.getPassword(),'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.datasource.password=" + postgreSQLContainer.getPassword(),'
- en: '"spring.data.redis.host=" + redisContainer.getHost(),'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.data.redis.host=" + redisContainer.getHost(),'
- en: '"spring.data.redis.port=" + redisContainer.getMappedPort(6379))'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"spring.data.redis.port=" + redisContainer.getMappedPort(6379))'
- en: .applyTo(configurableApplicationContext.getEnvironment());
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .applyTo(configurableApplicationContext.getEnvironment());
- en: '}'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE12]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, start the container before executing the tests:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在执行测试之前启动容器：
- en: '[PRE13]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can run the tests now. They should work fine!
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行测试了。它们应该能正常工作！
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To integrate Redis into our tests, we only need an available Redis server. There
    is a specialized Redis module in Testcontainers. You can find it at [https://testcontainers.com/modules/redis/](https://testcontainers.com/modules/redis/).
    As the integration is pretty simple, we can use just `GenericContainer` instead
    of the specialized `RedisContainer`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Redis集成到我们的测试中，我们只需要一个可用的Redis服务器。Testcontainers中有一个专门的Redis模块。你可以在[https://testcontainers.com/modules/redis/](https://testcontainers.com/modules/redis/)找到它。由于集成相当简单，我们可以使用`GenericContainer`而不是专门的`RedisContainer`。
- en: 'As we learned in previous recipes, by adding the `@Testcontainers` annotation
    in our test class, it automatically scans all container fields and integrates
    them into the test. `FootballServiceTest` was already annotated with `@Testcontainers`
    as it integrated PostgreSQL. We only needed to add a new container, in this case
    just `GenericContainer`, and perform the basic configuration to set it up. That
    is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在之前的菜谱中学习到的，通过在我们的测试类中添加`@Testcontainers`注解，它将自动扫描所有容器字段并将它们集成到测试中。`FootballServiceTest`已经通过集成PostgreSQL而注解了`@Testcontainers`。我们只需要添加一个新的容器，在这种情况下就是`GenericContainer`，并执行基本的配置来设置它。具体如下：
- en: 'Configure the container with the minimum configuration: image and exposed port.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最少的配置：镜像和暴露的端口来配置容器。
- en: Set the Redis configuration connection data in the application context. We did
    this in the `FootballServiceTest.Initializer` class. The Redis starter expects
    the configuration under `spring.data.redis`. We added the host and port, but only
    the port is required. By default, it expects the host on `localhost`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序上下文中设置Redis配置连接数据。我们在`FootballServiceTest.Initializer`类中做了这件事。Redis启动器期望在`spring.data.redis`下配置。我们添加了主机和端口，但只需要端口。默认情况下，它期望主机在`localhost`。
- en: Start the container before the test execution. We did it in the method annotated
    with `@BeforeAll`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试执行之前启动容器。我们在带有`@BeforeAll`注解的方法中做了这件事。
- en: Creating a native image using Spring Boot
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot创建原生镜像
- en: Usually, when we design solutions using a microservice-oriented approach, we
    imagine that we can easily scale our applications by adding and removing new instances
    of our application, and we also imagine that this process happens immediately.
    However, starting new instances of our application can take longer than we initially
    expected. Spring Boot orchestrates Bean initialization, dependency injection,
    and event handling during application startup, and most of these steps happen
    dynamically. This is not a major issue for small applications, but for complex
    applications, this process can take up to minutes to complete.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor when designing applications is the efficient use of
    computing resources. We want the applications to consume as little memory as possible
    and process the workload efficiently.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: For this kind of scenario, we can consider creating native applications, that
    is, applications that are built as final binaries for a specific processor family
    and operating system. A normal Java application generates intermediate code that
    is processed by the **Java Virtual Machine** (**JVM**) and converted into binary
    code during the application runtime. In a native application, this process happens
    during build time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to create a new Spring Boot native application.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we’ll need Docker. You can check the *Technical requirements*
    section of this chapter for more information.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create a native application using Spring Boot!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the *Spring Boot Initializr* tool at [https://start.spring.io](https://start.spring.io)
    and use the same options as you did in the *Create a RESTful API* recipe in [*Chapter
    1*](B21646_01.xhtml#_idTextAnchor020), and use the same parameters, except the
    following options:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `footballnative`
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Dependencies**, select **Spring Web** and **GraalVM** **Native Support**
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, create a sample RESTful controller; for instance, create a `TeamController`
    controller and a method that returns a list of teams:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can run the application on the JVM as usual, but what we’ll do now is create
    a native Docker image. For that, open your terminal and execute the following
    Maven command:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Be patient, as this step can take up to a few minutes to complete depending
    on the resources of your computer.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once the build completes, you can run the Docker image with our native application
    by executing the following command in your terminal:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, you can perform a request to the RESTful application normally; for instance,
    you can use the following `curl` command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GraalVM Native Support dependency adds a new `native` profile that can be
    used with the standard Spring Boot `build-image` goal to generate an image that
    targets **GraalVM**. GraalVM is a Java runtime that can compile your applications
    **Ahead of Time** (**AOT**) into native executables with low resource usage, fast
    startup, and improved security. To create the native image, the Maven plugin builds
    the native GraalVM executable in a Docker container using **Paketo Buildpacks**.
    Paketo Buildpacks are a set of community-driven tools that simplify the process
    of building and deploying applications as container images. That is the reason
    you don’t need to download GraalVM tools on your computer.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The result is a Docker image that contains our application as a native executable.
    Just as a reference for performance improvements, the application takes around
    1.5 seconds to start on my computer running on the JVM, while the native image
    takes 0.07 seconds to do the same. That is around 21 times faster. However, when
    running 10,000 requests, the total throughput of both versions is pretty similar,
    with the JVM version being a bit better performant. That could be because the
    native version runs on Docker, while the JVM runs directly on my computer. I prepared
    a JMeter test that you can use to compare the results on your computer. You can
    find a test named `teams-native.jmx` in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook),
    in the `chapter7/jmeter` folder.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: A native application is not a silver bullet that fits all scenarios. You need
    to consider that some features require dynamic processing during runtime, and
    they are difficult to handle with native applications. If your application doesn’t
    have a quick boot-time requirement, native applications do not add many benefits
    and there can be many inconveniences. In terms of performance, a JVM application
    performs as well as a native application in the long term. That is, after warming
    up, it works as well as a native one; there can be some gains in terms of memory
    management, but in terms of performance, they are quite similar.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Using GraalVM Tracing Agent to configure the native application
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The small native application we created in the previous recipe looks so promising
    that we’ve decided to build a bigger football application as a native app.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The application we created in the *Creating a native image using Spring Boot*
    recipe didn’t require any special configuration. But native applications are built
    AOT. That means the compiler needs to analyze all code statically and detect the
    code reached during runtime. There are some Java technologies, such as the **Java
    Native Interface** (**JNI**), **Reflection**, **dynamic proxy** objects, and class-path
    resources, that are very difficult to detect just by using static code analysis.
    The native compiler can use configuration files to include the required components
    in the final binary. As you may have figured out, the difficult part is configuring
    those files by detecting the components to be included in the final binary. For
    that purpose, GraalVM provides an agent that traces all usages to those types
    of technologies during the execution of an application on a regular JVM application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build as a native image the sample application provided
    in this chapter. If you try to build the application as a native image as is,
    you will find some errors during runtime. In this recipe, we’ll learn how to use
    GraalVM Tracing Agent to find all the required components and build a native image
    for an existing application. Then, you will be able to run your application in
    Docker.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll adapt the application you created in the *Using Testcontainers
    with Redis cache* recipe. If you haven’t finished it yet, you can use a functional
    project I’ve provided as a starting point for this recipe. You can find it in
    the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook)
    in the `chapter7/recipe7-6/start` folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: You will need the GraalVM JDK installed on your computer. You can install it
    following the instructions from the official website at [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The application depends on PostgreSQL, Redis, and other services. As we’ll see
    in the *How to do it…* section, we’ll run the application as a Docker container.
    To facilitate the execution in your development computer, I prepared a Docker
    Compose file named `docker-compose-all.yml` with the application and all dependent
    services.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build a native executable image of our Spring Boot application. We’ll
    see how fast it runs now! Remember that we initially created this application
    as a regular JVM application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll add the *GraalVM Native Support* plugin to our `pom.xml` application.
    You should include the following configuration in the `build/plugins` element:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we’ll need to add the Hibernate Enhance plugin as well. You should include
    the following configuration in the `build/plugins` element:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this step, we’ll run the application using the GraalVM JVM with a special
    setting to trace the components that our application uses at runtime. The native
    compiler will use these traces to include those components in the final binary
    executable:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This step requires that you use the GraalVM JVM. Depending on which installation
    method you used, switching Java versions may differ. I used the *SDKMAN!* tool,
    which just executes the following command in your terminal:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To ensure you use the right JVM version, execute the following command in your
    terminal:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Check that the response includes GraalVM. As a reference, this is the output
    when I execute this command on my computer:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.9: Sample java -version output for GraalVM JVM](img/B21646_07_9.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Sample java -version output for GraalVM JVM'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the application normally, that is, by executing the `package` goal in
    Maven. Execute this command on a terminal in the application root folder:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command creates the JAR file for your application. By default, the filename
    will be `football-0.0.1-SNAPSHOT.jar`, and it will be created in the `target`
    directory.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, run the GraalVM tracing tool. That is achieved by executing the application
    specifying an agent for the JVM, that is, specifying the `-agentlib:native-image-agent`
    parameter and passing the folder to save the configuration output. We’ll set the
    folder where the native compiler expects the special configuration, that is, in
    `src/main/resources/META-INF/native-image`. This is how to execute your application
    specifying the GraalVM tracing tool:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that our application is up and running, let’s make sure that we cover all
    our bases. It’s important that we execute every path of the application so that
    we can trace all the dynamic components and ensure everything is ready to build
    the native application. You’ll see that the `src/main/resources/META-INF/native-image`
    folder contains several JSON files.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you complete the execution of all application paths, you can stop the application.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It’s time to build the native application! You can do it by executing the following
    Maven command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained in the *Creating a native image using Spring Boot* recipe, adding
    *GraalVM Native Support* to our application creates a new Spring Boot profile
    that we can use to build a Docker image with a native version of our application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Some Hibernate operations generate Hibernate Proxy instances at runtime. If
    we don’t include the Hibernate Enhance plugin, the native compiler doesn’t have
    the required references at build time. For that reason, we need to include this
    plugin in our application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'In a simple application like the one created in the *Creating a native image
    using Spring Boot* recipe, we could skip *steps 3* and *4* and build the native
    application directly. However, we would realize that many operations do not work.
    That happens because the static build analysis doesn’t detect some dynamic loading
    components, mostly related to Hibernate. To tackle this issue, GraalVM provides
    the Tracing Agent tool. This tool traces all usages of JNI, Java Reflection, dynamic
    proxy objects (`java.lang.reflect.Proxy`), or class-path resources and saves them
    in the specified folder. The files generated are the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`jni-config.json`: This contains JNI-related information'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reflect-config.json`: This contains reflection-related details'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy-config.json`: This contains dynamic proxy object details'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resource-config.json`: This contains class-path resource information'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`predefined-classes-config.json`: This contains metadata for predefined classes'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialization-config.json`: This contains serialization-related data'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the native compiler can use this configuration to include the referenced
    components in the final native executable. With this approach, we may find most
    of the components used at runtime, but some components may not be detected. In
    that case, we will need to include them manually.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: As we run the application as a container, it’s executed in the context of Docker.
    This means that to locate the dependent services, such as PostgreSQL, it’s necessary
    to specify the internal Docker DNS name. In the previous recipes, all dependent
    services were accessible using `localhost`. For that reason, it’s necessary to
    specify the address of all dependent components, for instance, by setting the
    environment variables, and the easiest way to set these environment variables
    is by creating a Docker Compose file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I executed the same JMeter tests we used in the *Using shared cache* recipe
    to compare the results of executing the same application running on a JVM and
    as a native application. In the following figure, you can see the results of running
    as a native application:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: JMeter throughput for native image running on Docker](img/B21646_07_10.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: JMeter throughput for native image running on Docker'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: The results may seem surprising, as the application running as a native application
    performs significantly worse than the JVM version.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two factors to keep in mind:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The application now runs on Docker, while the application running on a JVM was
    executed directly on my computer
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the application running on a JVM did the **Just-in-Time** (**JIT**) compilation,
    there were no significant gains in performance compared to running
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next recipe, we’ll build the application natively instead of running
    on a container. Then, we’ll be able to compare the applications running with similar
    conditions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Creating a native executable using Spring Boot
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we built the native application to run as a container.
    Even if that is a convenient solution for most modern cloud-native scenarios,
    we may need to build a native executable to be executed directly without a container
    engine.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to configure our computer to build native applications
    using the GraalVM JDK.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll reuse the result of the *Using GraalVM Tracing Agent to
    configure the native application* recipe. I prepared a version of the application
    that you can use as a starting point for this recipe. You can find it in the book’s
    GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-6/start` folder.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: You will need the GraalVM JDK version 21 installed on your computer. You can
    follow the instructions from the official website at [https://www.graalvm.org/downloads/](https://www.graalvm.org/downloads/).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: The application depends on some services, such as PostgreSQL and Redis. To facilitate
    the execution of these services on your computer, you can reuse the `docker-compose-redis.yml`
    file prepared in the *Using shared* *cache* recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we’ll build our application as a native image that can be executed directly
    on our computer:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you are using the GraalVM JVM for this process. For that, execute
    the following command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Verify that the message contains GraalVM, as shown in *Figure 7**.5*.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll build the native executable. For that, open a terminal, change
    the directory to the root application folder, and execute the following command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The native build takes longer than a regular JVM build, even up to a few minutes.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we have our binary executable in the `target` folder. Its name is the
    same as the project, this time without a version suffix. If you use Windows, it
    will be `football.exe`; in Unix-like systems, it will be just `football`. It’s
    time to run the application. As I’m using Linux, I’ll execute the following commands
    in my terminal:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Be sure that the dependent services, such as PostgreSQL and Redis, are up and
    running. As explained in the *Getting ready* section, you can use the `docker-compose-redis.yml`
    Docker Compose file to run all dependent services.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did in the *Using GraalVM Tracing Agent to configure the native application*
    recipe, we must prepare our application for the native build. In this recipe,
    we reused the application, and we already had the hints for the dynamic components
    that GraalVM needs to generate the native application. However, if you start from
    scratch, you will need to prepare the configuration as we did in the *Using GraalVM
    Tracing Agent to configure the native* *application* recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot *GraalVM Native Support* starter includes the native profile
    and the `native:compile` goal. This starter was already included in the application
    we reused in this recipe. This time, the compilation process runs on your computer
    instead of being executed in a container.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can execute the load test using JMeter. This scenario is comparable to the
    one tested in the *Using Testcontainers with Redis cache* recipe, as both applications
    run directly on the computer and the dependent services run on Docker. These are
    the results of executing the same JMeter test on my computer:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: JMeter summary for a native application](img/B21646_07_11.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: JMeter summary for a native application'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The throughput for `get-user-player` is 622.1 RPS, compared to the 566.3 RPS
    achieved using a JVM version. That is approximately a 9.86% increase. For the
    total requests, it is 773.5 RPS compared to 699.2 RPS, which is approximately
    a 10.6% increase.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: You must consider the benefits and trade-offs of using a native image. The main
    benefits are quick start-up time and better memory management and performance.
    The main trade-offs are the complexities of preparing the build image with all
    hints required to avoid runtime errors due to dynamic components. This configuration
    can be very painful and difficult to detect. You also need to consider the time
    required to build your application, which can be significantly longer than the
    JVM counterpart.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Creating a native executable from a JAR
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we realized during the completion of the previous recipes, building a native
    image takes way more time than building a regular JVM application. Another important
    consideration in certain environments is that GraalVM currently doesn’t support
    cross-platform builds. That means if we need to build an application for Linux,
    as it’s the most popular platform for server environments, but our development
    computer is a Windows or macOS computer, we cannot build the application directly.
    For these reasons, it could be a good choice to keep working with a regular JVM
    development process and create the native executable in a **Continuous Integration**
    (**CI**) platform. For instance, you can create a GitHub action for the native
    executable creation. In that way, we maintain the productivity for our development
    processes, we don’t need to change our development platform, and we can target
    platforms for our application.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll generate a native executable for our football application
    using the *native-image* tool from the GraalVM JDK.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we’ll use the outcome from the *Creating a native executable
    using Spring Boot* recipe. Creating a native executable using a *native-image*
    tool requires an AOT-processed JAR. If you plan to convert another application
    into a native executable, follow the instructions from the previous recipe to
    generate the AOT-processed JAR file. If you haven’t completed the previous recipe
    yet, I prepared a working version that you can use as the starting point for this
    recipe. You can find it in the book’s GitHub repository at [https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/](https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/),
    in the `chapter7/recipe7-8/start` folder.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: You will need the *native-image* tool. This tool is part of the GraalVM JDK.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can work normally with a JVM and keep the native build for CI. Let’s see
    what you will need to do then!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is ensuring that you generate a JAR with AOT processed. For
    that, open your terminal at the root of your project and package the JAR file
    using the `native` profile with Maven. To do so, execute the following command:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we’ll create a new directory for our native executable. Let’s name it
    `native`. We’ll create this directory inside the `target` directory:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change your current directory to the new directory created:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we’ll extract the classes from the JAR file created in *step 1*. We’ll
    use the JAR tool, which is part of the JDK:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can build the native application. For that, we’ll use the `native-image`
    tool. We need to set the following arguments:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-H:name=football`: This is the executable filename; in our case, it will be
    `football`.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@META-INF/native-image/argfile`: The `@` symbol indicates that the argument
    is read from a file. The specified file (`argfile`) likely contains additional
    configuration options or arguments for the native image generation process.'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-cp`: This argument sets the class path for the native image. We must pass
    the current directory, the `BOOT-INF/classes` directory, and all files contained
    in `BOOT-INF/lib`. This argument will look like this: ``-cp .:BOOT-INF/classes:`find
    BOOT-INF/lib | tr ''\[PRE32]'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: native-image -H:Name=football @META-INF/native-image/argfile \
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'`
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ./football
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we reused the application from the previous recipes, we have already defined
    the hints. See the *Using GraalVM Tracing Agent to configure the native application*
    recipe for more details. To make them available for the native build, we must
    package our application using the `native` profile.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: A JAR file contains the classes and resources of our application in a ZIP file.
    We could use a standard ZIP tool, but the JAR tool is more convenient for our
    purposes. We passed the `-xvf` arguments with the JAR file to be processed. The
    `x` argument instructs the tool to extract the content. `f` means that it will
    get the content from a file that is passed as an argument as well. Finally, `v`
    is just to generate a verbose output; we could get rid of this parameter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: For the `native-image` tool, we need to pass all files contained in the `BOOT-INF/lib`
    directory. Unfortunately, the `cp` argument doesn’t admit wildcards. In Unix-like
    systems, you can use the `find` and `tr` tools. `find` lists the files in the
    directory, and `tr` removes `\n` and`:` characters. `\n` is the new line character.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
