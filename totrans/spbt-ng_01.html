<html><head></head><body>
		<div id="_idContainer011">
			<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Spring Boot and Angular – The Big Picture</h1>
			<p>First of all, we would like to thank you for getting a copy of this book, which was created for developers to learn how to build a full-stack web application using the standards that are being used in the development industry. This book is tailored based on the applications we have developed from our training and workshops. So, let’s begin <span class="No-Break">our adventure.</span></p>
			<p>This chapter will serve as a short recap regarding the Java Spring Boot and Angular foundations to give you an idea of what lies ahead in terms of conducting web development for them. You will also learn how large the community is and that the support that’s available for Angular makes it reliable for <span class="No-Break">developing applications.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Introducing <span class="No-Break">Spring Boot</span></li>
				<li>The advantages of using <span class="No-Break">Spring Boot</span></li>
				<li>What’s new in <span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Introducing Angular</span></li>
				<li>The advantages of <span class="No-Break">using Angular</span></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The GitHub repository for the application we will be building can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular</span></a><span class="No-Break">.</span></p>
			<p>Every chapter has a directory where the completed portion of the project <span class="No-Break">is located.</span></p>
			<p class="callout-heading"><a id="_idTextAnchor018"/><a id="_idTextAnchor019"/>Note</p>
			<p class="callout">No directories will be available for <a href="B18159_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Spring Boot and Angular – The Big Picture</em>, to <a href="B18159_04.xhtml#_idTextAnchor079"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Setting Up the Database and Spring Data JPA</em> because most of the topics we will be covering will consist of theories and some sample code. The actual project will begin in <a href="B18159_05.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Building APIs </em><span class="No-Break"><em class="italic">with Spring</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/>Introducing Spring Boot</h1>
			<p><strong class="bold">Spring Boot</strong> is an<a id="_idIndexMarker000"/> open source micro framework from Pivotal. It is an enterprise-level framework for developers to create standalone applications on <strong class="bold">Java Virtual Machines</strong> (<strong class="bold">JVMs</strong>). Its <a id="_idIndexMarker001"/>primary focus is to shorten your code so that it’s easier for you to run <span class="No-Break">your application.</span></p>
			<p>The framework extends the Spring Framework, which provides you with a more opinionated way of configuring your applications. In addition, it comes with built-in autoconfiguration capabilities that configure both the Spring Framework<a id="_idIndexMarker002"/> and third-party packages based on your settings. Spring Boot uses this knowledge to avoid code errors at configuration time as it reduces boilerplate code when you’re setting up <span class="No-Break">our application.</span></p>
			<p>Now, let’s discuss the main advantages of using <span class="No-Break">Spring Boot.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor021"/>The advantages of using Spring Boot</h1>
			<p>The following are the four main advantages of using Spring Boot to <span class="No-Break">develop applications:</span></p>
			<ul>
				<li><strong class="bold">Autoconfiguration</strong>: When<a id="_idIndexMarker003"/> you’re configuring your Spring Boot application, it downloads all the dependencies that will be needed to run your application. It will also configure your Spring Framework with the relevant third-party packages, depending on the settings you have applied. Thus, Spring Boot avoids boilerplate code and configuration errors, and you can directly start developing your <span class="No-Break">Spring application.</span></li>
				<li><strong class="bold">Opinionated approach</strong>: Spring Boot uses a narrow approach to installing dependencies based on your application needs. It will install all the required packages of your application and removes the idea of configuring <span class="No-Break">it manually.</span></li>
				<li><strong class="bold">Spring starters</strong>: You can choose a list of starter dependencies to define your application’s expected needs during the initialization process. One example of a Spring Starter<a id="_idIndexMarker004"/> is Spring Web, which allows you to initialize a Spring-based web application without configuring the dependencies that are required to run the application. Instead, it will automatically install the Apache Tomcat Web Server and Spring Security for <span class="No-Break">authentication features.</span></li>
				<li><strong class="bold">Create standalone applications</strong>: Spring <a id="_idIndexMarker005"/>Boot can run standalone applications that have no dependencies on external web servers. For example, we can embed servers such as Tomcat and run <span class="No-Break">the application.</span></li>
			</ul>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Differences between Spring and Spring Boot</h2>
			<p>So, what is the difference between Spring and Spring Boot? And do you need to learn about the <a id="_idIndexMarker006"/>Spring Framework before working with Spring Boot? Let’s start with the <span class="No-Break">first question.</span></p>
			<p>The following table shows the difference between the <span class="No-Break">two frameworks:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><img alt="C:\Users\Seiji Villafranca\AppData\Local\Microsoft\Windows\INetCache\Content.MSO\943B62F6.tmp" src="image/Table1.png"/></p>
						</td>
						<td class="No-Table-Style">
							<p><img alt="spring-boot-logo - THE CURIOUS DEVELOPER" src="image/Table2.png"/></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>The developers configure the dependencies for <span class="No-Break">the project.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Using Spring Starters, Spring Boot will configure all the dependencies that will be needed to run <span class="No-Break">the application.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Spring is <a id="_idIndexMarker007"/>a <strong class="bold">Java EE framework</strong> for <span class="No-Break">building applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Spring Boot is commonly used<a id="_idIndexMarker008"/> to build <span class="No-Break"><strong class="bold">REST APIs</strong></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Spring simplifies the development of Java EE applications since modules such as Spring JDBC, Spring MVC, and Spring Security are <span class="No-Break">already provided.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Spring Boot provides the configuration for the dependencies, reducing the boilerplate code for the layouts of modules. This makes it easier to run <span class="No-Break">the application.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) and <strong class="bold">inversion of control</strong> (<strong class="bold">IOC</strong>) are<a id="_idIndexMarker009"/> the main features of <a id="_idIndexMarker010"/>Spring for <span class="No-Break">building applications.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Spring Boot Actuator</strong> is a<a id="_idIndexMarker011"/> feature that exposes operational information about your apps, such as metrics <span class="No-Break">and traffic.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>We can identify that <a id="_idIndexMarker012"/>Spring Boot is built on top of Spring and that the main difference is that Spring Boot automatically configures the dependencies we need to run a Spring application. So, to answer the question about needing to learn about the Spring Framework before working with Spring Boot, the answer is <strong class="bold">no</strong> – Spring Boot is just an extension of Spring, which makes configuring it faster because of its <span class="No-Break">opinionated approach.</span></p>
			<p>Now, let’s look at the dependencies we need in Spring and Spring Boot to configure a <span class="No-Break">web application.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Dependency examples for Spring and Spring Boot</h2>
			<p>In Spring, the <a id="_idIndexMarker013"/>minimum dependencies that we need<a id="_idIndexMarker014"/> for our <a id="_idIndexMarker015"/>application to <a id="_idIndexMarker016"/>run are <strong class="bold">Spring Web</strong> and <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Web MVC</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
     &lt;version&gt;5.3.5&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework&lt;/groupId&gt;
     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
&lt;version&gt;5.3.5&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>Spring Boot <a id="_idIndexMarker017"/>only requires <strong class="source-inline">spring-boot-starter-web</strong>, which is a Spring Starter for our application to run. The necessary dependencies are added automatically at build time as the starter will be responsible for <span class="No-Break">the configuration:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;version&gt;2.4.4&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>Another thing to consider in <a id="_idIndexMarker018"/>Spring is that we need to define some configurations, such as dispatcher servlets and mappings, for our application to run on <span class="No-Break">the server:</span></p>
			<pre class="source-code">
public class SpringInitializer implements WebApplicationInitializer {
@Override
public void onStartup(ServletContext container) {
AnnotationConfigWebApplicationContext context =
    new AnnotationConfigWebApplicationContext();
context.setConfigLocation("com.springexample");
container.addListener(new        ContextLoaderListener(context));
 ServletRegistration.Dynamic dispatcher =
     container.  addServlet("dispatcher",
         new  DispatcherServlet(context));
 dispatcher.setLoadOnStartup(1);
 dispatcher.addMapping("/");
   }
}</pre>
			<p>After initializing the dispatcher servlets, we also need to use <strong class="source-inline">@EnableWebMvc</strong> and have a <strong class="source-inline">Configuration</strong> class with a <strong class="source-inline">@Configuration</strong> annotation where we will instantiate a view resolver for <span class="No-Break">the applications.</span></p>
			<p>A new <strong class="source-inline">InternalResourceViewResolver()</strong> instance will be created in the configuration class. This will be a bean for Spring. Here, all the files that are under the <strong class="source-inline">/WEB-INF/view</strong> path with<a id="_idIndexMarker019"/> a <strong class="source-inline">.jsp</strong> file extension will <span class="No-Break">be resolved:</span></p>
			<pre class="source-code">
@EnableWebMvc
@Configuration
public class SpringWebConfig implements WebMvcConfigurer {
   @Bean
   public ViewResolver viewResolver() {
       InternalResourceViewResolver bean =
           new  InternalResourceViewResolver();
   bean.setViewClass(JstlView.class);
   bean.setPrefix("/WEB-INF/view/");
   bean.setSuffix(".jsp");
   return bean;
   }
}</pre>
			<p>In Spring Boot, all <a id="_idIndexMarker020"/>these configurations will be omitted because this code is already included in the Spring Starters. We only need to define some properties for our application to run using the <span class="No-Break">web starter:</span></p>
			<pre class="source-code">
spring.mvc.view.prefix=/WEB-INF/jsp/
spring.mvc.view.suffix=.jsp</pre>
			<p>After defining these properties, our application will run since all the necessary configurations, such<a id="_idIndexMarker021"/> as the <strong class="bold">Web Initializer</strong> and <strong class="bold">MVC Configuration</strong>, have <a id="_idIndexMarker022"/><span class="No-Break">been included.</span></p>
			<p>With that, we have discussed the advantages of Spring Boot and, at the same time, the main differences between Spring Boot and the Spring Framework and how it reduces boilerplate code at <span class="No-Break">configuration time.</span></p>
			<p>As you may already know, the primary language of Spring is Java, and Java 17 has now been released. In the next section, we’ll learn about the new features in <span class="No-Break">Java 17.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>What’s new in Java 17?</h1>
			<p>We have decided to discuss<a id="_idIndexMarker023"/> Java 17 in this book as this is<a id="_idIndexMarker024"/> the next <strong class="bold">long-term support</strong> (<strong class="bold">LTS</strong>) version of Java, meaning that this version will be maintained for a more extended period. It was released on September 14, 2021, and includes several new security and <span class="No-Break">development features.</span></p>
			<p>Let’s look at some of the new features that have been included, as well as some modifications that have been applied to <span class="No-Break">Java 17.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Sealed classes</h2>
			<p><strong class="bold">Sealed classes</strong> were<a id="_idIndexMarker025"/> in the second preview stage in Java 16. Let’s say, for example, that <a id="_idIndexMarker026"/>we have a class that we have created in our code. We can assume that this class can be extended with any subclasses in our application. Thus, by making our classes sealed, we can ensure that our class can’t be extended by subclasses. If we want to allow some subclasses to extend our class, we can use the <strong class="source-inline">permits</strong> keyword to identify the specific classes we want to grant permission to, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
public sealed class Animal permits Cat, Dog, Horse</pre>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>The foreign function and memory API</h2>
			<p>A new API <a id="_idIndexMarker027"/>was introduced for accessing and using <a id="_idIndexMarker028"/>code outside the Java runtime, which it did by applying foreign functions (code outside the JVM) and safely accessing foreign memory (memory not handled by the JVM). The API allows a Java application to call native libraries without<a id="_idIndexMarker029"/> the <strong class="bold">Java Native </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JNI</strong></span><span class="No-Break">).</span></p>
			<p>The API aims to<a id="_idIndexMarker030"/> replace the JNI with a pure Java development<a id="_idIndexMarker031"/> model and better performance while accessing off-heap data and omitting <span class="No-Break">insecure operations.</span></p>
			<h3>Foreign memory</h3>
			<p>One common problem in Java today is accessing <a id="_idIndexMarker032"/>off-heap data. <strong class="bold">Off-heap data</strong> is data that’s stored in <a id="_idIndexMarker033"/>memory outside the Java runtime. We can say that this is a third-party library. Accessing this data is very critical to performance in that Java garbage collectors work only on on-heap data, which lets them avoid the unpredictability of garbage collections. The following APIs are used to handle <span class="No-Break">off-heap data:</span></p>
			<ul>
				<li><strong class="bold">The ByteBuffer API</strong>: This<a id="_idIndexMarker034"/> API allows you to create direct <a id="_idIndexMarker035"/>ByteBuffers in off-heap data so that data can be managed outside the Java runtime. However, the major drawback of ByteBuffer is that its maximum size is 2 GB and that it is not deallocated promptly, causing the application’s runtime performance to <span class="No-Break">slow down.</span></li>
				<li><strong class="bold">The Sun.misc.Unsafe API</strong>: The <a id="_idIndexMarker036"/>Unsafe API exposes access operations<a id="_idIndexMarker037"/> that work on off-heap data. This API makes this process efficient since the <strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) compiler optimizes access operations. However, using the Unsafe API is discouraged as we are allowing access to any <span class="No-Break">memory location.</span></li>
				<li><strong class="bold">The Foreign Function and Memory API</strong>: This API solves the dilemma of accessing the memory’s location and <a id="_idIndexMarker038"/>sacrificing runtime <a id="_idIndexMarker039"/>performance as it provides classes and interfaces where applications can do <span class="No-Break">the following:</span><ul><li>Allocate <span class="No-Break">Foreign Memory</span></li><li>Manipulate and access <span class="No-Break">foreign memory</span></li><li>Call <span class="No-Break">Foreign Functions</span></li></ul></li>
			</ul>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Pattern matching with switch statements</h2>
			<p>Pattern matching<a id="_idIndexMarker040"/> is the idea of testing patterns and complicated expressions in switch statements. This new feature allows for more extensible and flexible usage of <a id="_idIndexMarker041"/>switch statements to accept<a id="_idIndexMarker042"/> <span class="No-Break">complex expressions.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>The Applet API</h2>
			<p><strong class="bold">The Applet API</strong> is rarely<a id="_idIndexMarker043"/> used in Java as <a id="_idIndexMarker044"/>all browsers have removed support for Java <span class="No-Break">browser plugins.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>The experimental AOT and JIT compilers</h2>
			<p>The experimental Java-based <strong class="bold">ahead-of-time</strong> (<strong class="bold">AOT</strong>) and <strong class="bold">JIT</strong> compilers have been <a id="_idIndexMarker045"/>removed since <a id="_idIndexMarker046"/>their features have<a id="_idIndexMarker047"/> <span class="No-Break">limited</span><span class="No-Break"><a id="_idIndexMarker048"/></span><span class="No-Break"> usage.</span></p>
			<p>These are just some of the changes that have been applied to Java 17. Now, let’s learn about Angular, one of the top JavaScript frameworks today, and the advantages of using the Angular framework to develop <span class="No-Break">your frontend.</span></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Introducing Angular</h1>
			<p><strong class="bold">Angular</strong> is a<a id="_idIndexMarker049"/> free and open source JavaScript framework that’s maintained by Google. It was built mainly for developing web applications and has expanded its capabilities to being used to create mobile and desktop applications using plugins. Angular uses component-based code, is progressive, and offers many libraries and extensions that shorten the time of developing <span class="No-Break">large-scale applications.</span></p>
			<p>At the time of writing, Angular is very popular for building frontend applications. It is the primary framework for developing applications for large and well-known companies such as Samsung, Upwork, PayPal, and Google. It also has a very active community and has 76,000 stars on GitHub, with around 1,500 people contributing to the framework. In addition, it has thousands <a id="_idIndexMarker050"/>of functional NPM libraries that you can use to speed up <span class="No-Break">your development.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>History of Angular</h2>
			<p>Before it<a id="_idIndexMarker051"/> became Angular, the first developed framework by Google was <strong class="bold">AngularJS</strong> or <a id="_idIndexMarker052"/>Angular Version 1. Although developers are typically confused by this, due to thinking that AngularJS and Angular are similar, AngularJS was released as an open source framework by <em class="italic">Miško Hevery</em>, a Google employee, who was developing AngularJS to develop web <span class="No-Break">applications faster.</span></p>
			<p>AngularJS, where you use JavaScript or Dart, became popular as its community became more extensive. At the same time, the Ionic framework was released, which allowed developers to use AngularJS to build native <span class="No-Break">mobile applications.</span></p>
			<h3>The Great Rewrite</h3>
			<p>The fast and rapid<a id="_idIndexMarker053"/> development of <a id="_idIndexMarker054"/>JavaScript technology has affected the popularity of AngularJS, and the team came to the end of the road regarding the framework – no improvements were to be made. From 2014 to 2015, the Google team and the community decided to support mobile and large enterprise applications with the framework. Their first port of call was <strong class="bold">The Great Rewrite</strong> and not incrementing the design of AngularJS. The Great Rewrite is <a id="_idIndexMarker055"/>where <strong class="bold">Angular 2.0</strong>, or simply Angular, <span class="No-Break">was released.</span></p>
			<h3>The problem with action</h3>
			<p>Many applications <a id="_idIndexMarker056"/>were already running on AngularJS, which meant that if a completely new version of Angular was released, support would come to an end for AngularJS users. So, another main question here was, "<em class="italic">How would those applications be supported after </em><span class="No-Break"><em class="italic">several years?</em></span><span class="No-Break">"</span></p>
			<p>The other issue that emerged is that there was no direct way to migrate from AngularJS to Angular 2.0, which was difficult for developers. This was a massive step for teams – so much so that new concepts and breaking changes were introduced on <span class="No-Break">every release.</span></p>
			<h3>The framework’s comeback</h3>
			<p>Even though migrating Angular<a id="_idIndexMarker057"/> was painful, the enterprise applications that had been created by Google were supported. Around 2018, this became more stabilized as the framework had a large set of features that were ready to be used to build large applications. In addition, it didn’t depend on third-party libraries to create forms and call HTTP requests because all the dependencies were already included. Google also released some documentation to help developers migrate AngularJS to the latest version <span class="No-Break">of Angular.</span></p>
			<p>Angular is very popular and is very effective at developing enterprise applications. Now, let’s look at the advantages of Angular and why it is effective <span class="No-Break">for development.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor032"/>The advantages of using Angular</h1>
			<p>Angular is a <a id="_idIndexMarker058"/>component-based framework, which means that we develop parts of our applications into smaller pieces, and we can reuse these pieces throughout the application. This feature reduces boilerplate code and code errors by ensuring there’s not as much repetitive code. One of the main advantages of Angular is its language. Let’s take a <span class="No-Break">closer look.</span></p>
			<h3>TypeScript-based framework</h3>
			<p>Angular is a <strong class="bold">TypeScript language-based framework</strong>. This language is a significant advantage since<a id="_idIndexMarker059"/> TypeScript offers features that are beneficial to development. In addition, it is a superset of JavaScript, which added new concepts that make code maintainable <span class="No-Break">and effective:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 1.1 – TypeScript – a superset language" src="image/B18159_01_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – TypeScript – a superset language</p>
			<p>As we can see, TypeScript <a id="_idIndexMarker060"/>is built on top of ES6 and <a id="_idIndexMarker061"/>JavaScript, which is intended to add more features for development. Some of TypeScript’s components include Generics, Types, and Interfaces, which we know are directly related <a id="_idIndexMarker062"/>to <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). Now, let’s look at <span class="No-Break">another advantage.</span></p>
			<h4>Static type data</h4>
			<p>TypeScript can define static type data, which allows variables to be strictly typed. Compared to plain JavaScript, the compiler <a id="_idIndexMarker063"/>alerts you if there are any type-related mistakes – that is, which errors were caught at runtime. Thus, TypeScript can avoid mistakes in production by prompting you with these issues at <span class="No-Break">compile time.</span></p>
			<h4>Predictability and maintainability</h4>
			<p>Since TypeScript is strictly typed, this contributes to the concept of <a id="_idIndexMarker064"/>predictability. For example, a variable is declared as a number. Therefore, it will always stay a number throughout the application, and functions will specify how to implement them as all parameters are also strictly typed. Furthermore, TypeScript is also <a id="_idIndexMarker065"/>maintainable as it gives developers the power to debug applications at <span class="No-Break">compilation time.</span></p>
			<h4>IDE support</h4>
			<p>Since TypeScript is becoming a <a id="_idIndexMarker066"/>more widely used language, more IDEs are supporting it. IDEs offer several features such as code navigation, autocompletion, <span class="No-Break">and plugins.</span></p>
			<p>Microsoft Visual Studio is the primary IDE that’s used for TypeScript. However, some IDEs and editors are also available for <span class="No-Break">running TypeScript:</span></p>
			<ul>
				<li><strong class="bold">Atom</strong>: A <a id="_idIndexMarker067"/><span class="No-Break">cross-platform editor</span></li>
				<li><strong class="bold">Eclipse</strong>: An IDE <a id="_idIndexMarker068"/>that has a plugin <span class="No-Break">for TypeScript</span></li>
				<li><strong class="bold">Visual Studio Code</strong>: A <a id="_idIndexMarker069"/>lightweight cross-platform editor <span class="No-Break">by Microsoft</span></li>
			</ul>
			<h4>OOP</h4>
			<p>TypeScript is an <strong class="bold">object-oriented language</strong>, which means it supports concepts such as classes, interfaces, and <a id="_idIndexMarker070"/>inheritance. OOP is very scalable as we develop our applications into objects, which can be an advantage if we’re developing <span class="No-Break">growing applications.</span></p>
			<h4>Early spotted bugs</h4>
			<p>Browsers do not understand <a id="_idIndexMarker071"/>TypeScript directly. Instead, they use <strong class="bold">transpilers</strong>, which<a id="_idIndexMarker072"/> compile the code into plain JavaScript. Here, all errors related to syntax and types are caught, allowing developers to worry about the code <span class="No-Break">logic instead.</span></p>
			<p>These are just the advantages of the TypeScript language. Now, let’s look at the benefits of <span class="No-Break">Angular itself.</span></p>
			<h3>Support for large enterprise applications</h3>
			<p>Angular is considered an <a id="_idIndexMarker073"/>all-in-one package framework in that most of the standard features that are needed to build an application are already included. This includes modules. For example, to use forms in an Angular application, we must import <strong class="source-inline">FormsModule</strong> and <strong class="source-inline">ReactiveormsModule</strong>. Other examples are navigation and routes. Angular provides <strong class="source-inline">RouterModule</strong> so that you can create routes within <span class="No-Break">the application.</span></p>
			<h3>Single-page application</h3>
			<p>Angular is a <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>), which<a id="_idIndexMarker074"/> means that when a user navigates from one page to another, the page doesn’t reload as it’s the data that’s being fetched by the server. In addition, the client’s resources are independent and are already loaded in the browser, which contributes to the loading performance of <span class="No-Break">the application.</span></p>
			<h3>Progressive web apps (PWAs)</h3>
			<p><strong class="bold">Progressive web apps</strong> (<strong class="bold">PWAs</strong>) are <a id="_idIndexMarker075"/>becoming a trend nowadays. They are a solution that allows web applications to run on mobile apps, as well as different platforms, both online and offline. It is straightforward to configure Angular as a PWA thanks to its schematics – with just a single line of code, your Angular app is configured. PWAs can also be uploaded into the Android Play Store and Microsoft Store using <span class="No-Break">PWA Builder.</span></p>
			<p>The following command uses the Angular CLI to convert our application into <span class="No-Break">a PWA:</span></p>
			<pre class="console">
ng add @angular/pwa</pre>
			<h3>The Angular CLI</h3>
			<p>We don’t need to create or<a id="_idIndexMarker076"/> configure Angular from scratch. Instead, we can use the Angular CLI, which helps install the necessary dependencies to run our Angular application successfully. Although the schematics features are responsible for creating the required files, installing the packages, and configuring the values that we need for our application, the Angular CLI generates boilerplate code for <strong class="bold">modules</strong>, <strong class="bold">components</strong>, <strong class="bold">services</strong>, and <strong class="bold">directives</strong> for <span class="No-Break">faster development.</span></p>
			<p>In the following code, we’re using <strong class="source-inline">npm</strong> to install the Angular CLI and generate our code using the <span class="No-Break"><strong class="source-inline">ng</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
//command for installing angular CLI
npm install -g @angular/cli
//command for creating a new Angular App
ng new –project-name
// command for creating a new Component
ng generate component –component-name
// command for creating a new Service
ng generate service –component-name
// command for creating a new Module
ng generate module –component-name</pre>
			<h3>Module and component-based framework</h3>
			<p>Angular is grouped into <strong class="bold">modules</strong>, which <a id="_idIndexMarker077"/>makes it easier to maintain the code’s structure. In addition, each part of the application can be grouped by its function and placed in a single module, making it easier to navigate the application’s features. It is also beneficial in unit testing as the code is tested separately, allowing for complete <span class="No-Break">quality control.</span></p>
			<p>Creating code as components promotes reusability and boilerplate reduction. Let’s look at an example of a <span class="No-Break">navigation menu:</span></p>
			<pre class="source-code">
&lt;!— Example code for nav bar --&gt;
&lt;nav class="navbar navbar-default"&gt;
  &lt;div class="container-fluid"&gt;
    &lt;div class="navbar-header"&gt;
      &lt;a class="navbar-brand" href="#"&gt;Nav bar&lt;/a&gt;
    &lt;/div&gt;
    &lt;ul class="nav navbar-nav"&gt;
      &lt;li class="active"&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#"&gt;Home&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#"&gt;About&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="#"&gt;Contact Us&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/nav&gt;</pre>
			<p>The navigation bar must be present on every page of our application. This process will cause redundant <a id="_idIndexMarker078"/>code, which means we will have to repeat this code over and over again. However, in Angular, it has been developed into a component, allowing us to reuse the code in different parts of the application. A specific selector is assigned to the navigation bar code and used as the HTML tag for the component, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&lt;!—example selector for the navigation bar component--&gt;
&lt;app-navigation-bar/&gt;</pre>
			<h3>Cross-platform-enabled</h3>
			<p>Angular is used to<a id="_idIndexMarker079"/> build applications for the web, as well as native mobile and desktop applications. This is now possible through frameworks, such as Ionic, NativeScript, and Electron. Aside from PWAs, Ionic and NativeScript are also used to create mobile apps using Angular. On the other hand, Electron is a framework that transforms your Angular app into a desktop application using a similar code base. This feature makes Angular very flexible as a single framework can cover all the platforms for <span class="No-Break">your application.</span></p>
			<h3>Web components</h3>
			<p>Angular supports <strong class="bold">web components</strong>, which<a id="_idIndexMarker080"/> are also<a id="_idIndexMarker081"/> known as <strong class="bold">Angular elements</strong>. Here, the idea is to break an application into smaller pieces and distribute it into an independent application or package that can be distributed and used on other applications. Angular elements cover the concepts of micro frontends. Every element has a pipeline for deployment. This component can also be used in different JavaScript frameworks, such as React <span class="No-Break">and Vue.</span></p>
			<h3>Supports lazy loading</h3>
			<p>Loading all the JavaScript <a id="_idIndexMarker082"/>code in the client browser could introduce some issues. If the applications get more extensive, more code would be packed into one chunk. We don’t want to bootstrap all of our code as this would cause our application to load slowly when it’s started for the first time. We only want to load what is needed on demand. The lazy loading feature by Angular solves this. It only loads the modules, components, services, directives, and other elements of the application that are needed for a specific route. This feature reduces the loading time as the user initially opens <span class="No-Break">the application.</span></p>
			<p>In the following code, we’ve defined some routes as an array where we add new routes as an object. To enable lazy loading, we must use the <strong class="source-inline">loadChildren</strong> properties to load the modules <span class="No-Break">on demand:</span></p>
			<pre class="source-code">
const route: Routes = [
    {
     path: "about",
 loadChildren: () =&gt;
   import("./src/app/AboutModule").then(m =&gt;
      m.AboutModule)
    },
   {
     path: "contact",
     loadChildren: () =&gt;
       import("./src/app/ContactModule").then(m =&gt;
         m.ContactModule)
    }
];</pre>
			<p>In the preceding code, as the<a id="_idIndexMarker083"/> user navigates to the <strong class="source-inline">about</strong> path, it will only load <strong class="source-inline">AboutModule</strong>, which contains the resources for that specific route. It will not load the resources under <strong class="source-inline">ContactModule</strong> unless the user navigates to the <span class="No-Break"><strong class="source-inline">contact</strong></span><span class="No-Break"> path.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor033"/>Summary</h1>
			<p>In this chapter, you learned that Spring Boot is an open source framework extension for Spring and that it mainly solves the boilerplate code when you’re configuring the Spring Framework. In addition, it provides <strong class="bold">Spring Starters</strong>, which developers can use to allow Spring Boot to configure the required <span class="No-Break">dependencies automatically.</span></p>
			<p>On the other hand, Angular is a component-based framework that’s built with the TypeScript language to give it OOP powers. Moreover, it has cross-platform support, which allows developers to create applications on the web, mobile, and desktop. Angular is one of the top JavaScript frameworks as it is used by several large companies and is supported by Google and a <span class="No-Break">large community.</span></p>
			<p>In the next chapter, you will learn about the software that you must install on your computer and set up the development environment for full <span class="No-Break">stack development.</span></p>
		</div>
	</body></html>