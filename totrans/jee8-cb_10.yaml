- en: Using Event-Driven Programming to Build Reactive Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件驱动编程来构建响应式应用程序
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Building reactive applications using asynchronous servlets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步servlet构建响应式应用程序
- en: Building reactive applications using events and observers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件和观察者构建响应式应用程序
- en: Building reactive applications using websockets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用websockets构建响应式应用程序
- en: Building reactive applications using message-driven beans
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用消息驱动的bean构建响应式应用程序
- en: Building reactive applications using JAX-RS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JAX-RS构建响应式应用程序
- en: Building reactive applications using asynchronous session beans
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步会话bean构建响应式应用程序
- en: Using lambdas and `CompletableFuture` to improve reactive applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda和`CompletableFuture`来改进响应式应用程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Reactive development became a trending topic in many developers conferences,
    meetups, blog posts, and other countless content sources (both online and offline).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式开发成为许多开发者会议、聚会、博客文章和其他无数内容来源（包括在线和离线）的热门话题。
- en: But what is a reactive application? Well, there's a official definition of it
    contained in something called **The Reactive Manifesto** (please refer to [https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)
    for more details).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是响应式应用程序？嗯，有一个官方的定义包含在被称为**《响应式宣言》**（请参阅[https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)以获取更多详细信息）的东西中。
- en: 'In short, according to the manifesto, reactive systems are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，根据宣言，响应式系统是：
- en: '**Responsive**: The system responds in a timely manner if at all possible'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：如果可能的话，系统会及时响应'
- en: '**Resilient**: The system stays responsive in the face of failure'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：面对失败时，系统保持响应性'
- en: '**Elastic**: The system stays responsive under varying workloads'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统在变化的工作负载下保持响应性'
- en: '**Message driven**: Reactive systems rely on asynchronous message-passing to
    establish a boundary between components that ensures loose coupling, isolation,
    and location transparency'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：响应式系统依赖于异步消息传递来建立组件之间的边界，确保松散耦合、隔离和位置透明'
- en: So, this chapter will show you how to use Java EE 8 features to meet one or
    more of those reactive system requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章将向您展示如何使用Java EE 8功能来满足一个或多个那些响应式系统要求。
- en: Building reactive applications using asynchronous servlets
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步servlet构建响应式应用程序
- en: Servlets are probably one of most well-known Java EE technologies (perhaps even
    the most known). Actually, servlets existed even before J2EE became a real specification.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet可能是最著名的Java EE技术之一（也许是最著名的）。实际上，servlet在J2EE成为真正的规范之前就已经存在了。
- en: This recipe will show you how to use servlets asynchronously.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将向您展示如何异步使用servlet。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a `User` POJO:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, create a slow `UserBean` to return a `User`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个慢速的`UserBean`来返回`User`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And finally, create our asynchronous servlet:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建我们的异步servlet：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'From the all important things here, we should start with a simple annotation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里所有重要的事情中，我们应该从一个简单的注解开始：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will tell the application server that this very servlet supports asynchronous
    features. By the way, you will need this in the whole servlet chain (including
    filters, if there are any), otherwise application server will not work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉应用程序服务器这个servlet支持异步功能。顺便说一句，你需要在整个servlet链中（包括过滤器，如果有）使用它，否则应用程序服务器将无法工作。
- en: 'As the servlets are instantiated by the server, we can inject other context
    members on it, such as our stateless bean:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于servlet是由服务器实例化的，我们可以在其上注入其他上下文成员，例如我们的无状态bean：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The main servlet method holds the actual request and response references, and
    the request will give us the context reference to the async API:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 主要servlet方法持有实际的请求和响应引用，请求将给我们异步API的上下文引用：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, you can execute your previous blocking function in a non-blocking way:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以以前非阻塞的方式执行您之前的阻塞函数：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码位于[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet)。
- en: Building reactive applications using events and observers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件和观察者构建响应式应用程序
- en: Events and observers are a great way to write code in a reactive way without
    thinking too much about it, thanks to the great work done by the CDI specification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和观察者是编写反应式代码的绝佳方式，无需过多思考，这要归功于 CDI 规范的出色工作。
- en: This recipe will show you how easy is to use it to improve the user experience
    of your application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何轻松地使用它来提高您应用程序的用户体验。
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的 Java EE 8 依赖项：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s first create a `User` POJO:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先创建一个 `User` POJO：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And then, let''s create a REST endpoint with event and observer features:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个具有事件和观察器功能的 REST 端点：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we ask the application server to create a `Event` source for the `User`
    POJO:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要求应用服务器为 `User` POJO 创建一个 `Event` 源：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means that it will listen to any events fired against any `User` object.
    So what we need to do is create a method to deal with it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它将监听针对任何 `User` 对象触发的任何事件。因此，我们需要创建一个方法来处理它：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So now this method is the proper listener. The `@ObserversAsync` annotation
    guarantees it. So once an async event is fired, it will do whatever we asked (or
    coded).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在这种方法是合适的监听器。`@ObserversAsync` 注解保证了这一点。所以一旦异步事件被触发，它就会执行我们要求（或编码）的任何操作。
- en: 'Then, we created a simple asynchronous endpoint to fire it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个简单的异步端点来触发它：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer).
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方的完整源代码在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer)。
- en: Building reactive applications using websockets
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WebSocket 构建反应式应用程序
- en: Websockets are a great way to create decoupled communication channels for your
    applications. Doing it asynchronously is even better and cooler for non-blocking
    features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Websockets 是为您的应用程序创建解耦通信通道的绝佳方式。以异步方式执行甚至更好，更酷，因为这样可以实现非阻塞功能。
- en: This recipe will show how to do it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何实现。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的 Java EE 8 依赖项：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The first thing we need is our server endpoint:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是我们的服务器端点：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we need a client to communicate with the server:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要一个客户端与服务器进行通信：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, we need a simple REST endpoint to talk to the client:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个简单的 REST 端点与客户端通信：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first important thing in our server is this annotation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务器中的第一件重要的事情是这个注解：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, we must ensure that we have one and only one instance of the server
    endpoint. This will ensure that all `peers` are managed under the same umbrella.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们必须确保我们只有一个服务器端点实例。这将确保所有 `peers` 都在同一个伞下管理。
- en: 'Let''s move on to talk about `peers`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 `peers`：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The list holding them is a synchronized list. This is important because you
    will add/remove peers while iterating on the list, so things could be messed up
    if you don't protect it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 存储它们的列表是同步的。这很重要，因为您将在迭代列表时添加/删除对等方，如果不保护它，事情可能会变得混乱。
- en: 'All the default websocket methods are managed by the application server:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有默认的 WebSocket 方法都由应用服务器管理：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, let''s give a special mention to the code on our `onMessage` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们特别提一下我们 `onMessage` 方法上的代码：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are sending a message to the peer only if it is open.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在连接打开时向对等方发送消息。
- en: 'Now looking to our client, we have a reference to the server URI:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看我们的客户端，我们有一个指向服务器 URI 的引用：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the protocol is `ws`, specific to websocket communication.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，协议是 `ws`，这是针对 WebSocket 通信的特定协议。
- en: 'Then, we have a method to open the connection with the server endpoint:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个方法可以打开与服务器端点的连接：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And once we have the message confirmation from the server, we can do something
    about it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从服务器收到消息确认，我们就可以对它采取行动：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This response will appear on the endpoint that is calling the client:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应将出现在调用客户端的端点上：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We are passing the reference to the client so the client can use it to write
    the message on it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在传递客户端的引用，以便客户端可以使用它来在它上面写入消息。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个配方的完整源代码在 [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket)。
- en: Building reactive applications using message-driven beans
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用消息驱动豆构建反应式应用程序
- en: 'The Java Messaging Service is one of the oldest Java EE APIs, and it''s been
    reactive since day one: just read the manifesto linked in the introduction of
    this chapter.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Java 消息服务是 Java EE 最古老的 API 之一，它从一开始就是反应式的：只需阅读本章引言中链接的宣言。
- en: This recipe will show you how to use message-driven beans, or MDBs, to deliver
    and consume asynchronous messages with just a few annotations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示如何使用消息驱动豆，或称为 MDB，仅通过几个注解即可发送和消费异步消息。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的 Java EE 8 依赖项：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To check the details about queue setup in GlassFish 5, please refer to the recipe
    *Using Messaging Services for Asynchronous Communication* at [Chapter 5](e8021c0e-e762-4e43-8d9b-5c7040a453f3.xhtml),
    *Security of Enterprise Architecture*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 GlassFish 5 中队列设置的详细信息，请参阅第 5 章*使用消息服务进行异步通信*的食谱*企业架构的安全性*。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a `User` POJO:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we create a message sender:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个消息发送者：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we create a message consumer. This is our MDB:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个消息消费者。这是我们自己的 MDB：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, we create an endpoint, just to send a mock user to the queue:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个端点，仅用于向队列发送模拟用户：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by asking the application server a JMS context instance:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向应用程序服务器请求一个 JMS 上下文实例：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We also send a reference to the queue we want to work with:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发送了一个我们想要与之工作的队列的引用：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, using the context, we create a producer to send the message to the queue:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用上下文，我们创建一个生产者来将消息发送到队列：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Pay attention to these three methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这三个方法：
- en: '`setDeliveryMode`: This method can be `PERSISTENT` or `NON_PERSISTENT`. If
    using `PERSISTENT`, the server will take special care of the message and not lose
    it.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDeliveryMode`：此方法可以是`PERSISTENT`或`NON_PERSISTENT`。如果使用`PERSISTENT`，服务器将特别关注消息，不会丢失它。'
- en: '`setDisableMessageID`: This one is used for creating `MessageID`, which increases
    the server effort to create and deliver the message and also increases its size.
    This property (`true` or `false`) gives a hint to the server that you are not
    going to need/use it, so it can improve the process.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDisableMessageID`：此选项用于创建`MessageID`，这会增加服务器创建和发送消息的努力，并增加其大小。此属性（`true`
    或 `false`）向服务器提供提示，表明您不需要/使用它，因此它可以改进此过程。'
- en: '`setDisableMessageTimestamp`: This is the same as for `setDisableMessageID`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setDisableMessageTimestamp`：这与`setDisableMessageID`相同。'
- en: Also, note that we are sending a `User` instance to the queue. So you can easily
    send object instances, not only text messages, as long as they implement the serializable
    interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们正在向队列发送一个`User`实例。因此，您可以轻松地发送对象实例，而不仅仅是文本消息，只要它们实现了可序列化接口。
- en: The MDB itself, or our message consumer, is basically a few annotations and
    an interface implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MDB 本身，或我们的消息消费者，基本上是几个注解和一个接口实现。
- en: 'Here is its annotation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其注解：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we are using two properties: one to define which queue we are looking
    up (`destinationLookup`) and another to define that it is really the queue type
    we are using (`destinationType`).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个属性：一个用于定义我们正在查找哪个队列（`destinationLookup`），另一个用于定义它确实是我们要使用的队列类型（`destinationType`）。
- en: 'Here is the implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其实施：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that it is easy to get the `User` instance from the message''s body:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从消息体中获取`User`实例很容易：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: No heavy lifting at all.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完全没有繁重的任务。
- en: 'And the endpoint used to send the message couldn''t be simpler. We inject the
    `Sender` (which is a stateless bean):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 并且用于发送消息的端点非常简单。我们注入了`Sender`（这是一个无状态豆）：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we call an asynchronous method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用一个异步方法：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb).
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb)中查看本食谱的完整源代码。
- en: Building reactive applications using JAX-RS
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JAX-RS 构建反应式应用程序
- en: The JAX-RS API also has some great features for event-driven programming. This
    recipe will show you can use an async invoker from the request to write responses
    through callbacks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JAX-RS API 还有一些针对事件驱动编程的出色功能。本食谱将展示您如何使用异步调用者从请求中编写回调函数来生成响应。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的 Java EE 8 依赖项：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'First, we create a `User` POJO:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we define `UserBean`, which will act as a remote endpoint:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了`UserBean`，它将作为远程端点：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then finally, we define a local endpoint that will consume the remote one:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们定义一个本地端点，它将消费远程端点：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start the bean by creating the communication with the remote endpoint right
    in the bean instantiation. Doing this will avoid the overhead of doing it later
    while the invocation is happening:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在Bean实例化时直接与远程端点建立通信来启动Bean。这样做将避免在调用发生时稍后执行的开销：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we created an anonymous `InvocationCallback` implementation within our
    async invoker:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在我们的异步调用器中创建了一个匿名`InvocationCallback`实现：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That way, we can rely on the `completed` and `failed` events and deal with them
    properly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以依赖`completed`和`failed`事件，并妥善处理它们。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs)中查看这个菜谱的完整源代码。
- en: Building reactive applications using asynchronous session beans
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步会话Bean构建反应式应用程序
- en: Session beans can also become reactive and event driven just by using annotations.
    This recipe will show you how to do it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 会话Bean也可以仅通过使用注解成为反应式和事件驱动的。这个菜谱将向您展示如何做到这一点。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we create a `User` POJO:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we create our asynchronous session bean:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的异步会话Bean：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And finally, we create the endpoint that will call the bean:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建了将调用Bean的端点：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s first check the `getUser` method from the session bean:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先检查会话Bean中的`getUser`方法：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Once we user the `@Asynchronous` annotation, we have to turn its returning value
    to a `Future` instance of something (in our case, `User`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们使用`@Asynchronous`注解，我们必须将其返回值转换为某种（在我们的情况下，`User`）的`Future`实例。
- en: 'We also created a `void` method to show you how to create a non-blocking code
    with session beans:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个`void`方法来向您展示如何使用会话Bean创建非阻塞代码：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, we created our calling endpoint:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了我们的调用端点：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As `getUser` returns `Future`, we can work with an async status check. Once
    it is done, we write the results in the response (also asynchronous).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getUser`返回`Future`，我们可以处理异步状态检查。一旦完成，我们将结果写入响应（也是异步的）。
- en: See also
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean)中查看这个菜谱的完整源代码。
- en: Using lambdas and CompletableFuture to improve reactive applications
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda和CompletableFuture来提高反应式应用程序
- en: The Java language always had the reputation of being a verbose language. But
    since the advent of lambdas, this issue has improved a lot.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言一直以冗长著称。但自从lambda出现以来，这个问题已经大大改善。
- en: We can use lambdas and also bring `CompletableFuture` to the party to improve
    not only the coding, but also the behavior of reactive applications. This recipe
    will show you how.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用lambda表达式，并引入`CompletableFuture`来提高不仅编码，而且反应式应用程序的行为。这个菜谱将向您展示如何做到这一点。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s first add our Java EE 8 dependency:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we create a `User` POJO:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we call `UserBean` to return a `User` instance:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用`UserBean`以返回一个`User`实例：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And finally, we create an async endpoint to call the bean:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个异步端点来调用Bean：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We are using basically two `CompletableFuture` methods:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基本上使用两个`CompletableFuture`方法：
- en: '`supplyAsync`: This will start an async call to whatever you put inside of
    it. We put in a lambda call.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`supplyAsync`：这将启动对您放入其中的任何内容的异步调用。我们放入一个lambda调用。'
- en: '`thenAcceptAsync`: Once the async process is done, the returning value will
    come here. Thanks to lambdas, we can call this returning value as `u` (and could
    be whatever we want). Then, we use it to write it down to the asynchronous response.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenAcceptAsync`：一旦异步过程完成，返回值将在这里。多亏了lambda，我们可以将这个返回值称为`u`（可以是任何我们想要的）。然后，我们用它来写入异步响应。'
- en: See also
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看此菜谱的完整源代码，请访问[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future).
