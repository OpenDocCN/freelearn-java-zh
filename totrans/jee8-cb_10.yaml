- en: Using Event-Driven Programming to Build Reactive Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building reactive applications using asynchronous servlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using events and observers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using websockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using message-driven beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using JAX-RS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using asynchronous session beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas and `CompletableFuture` to improve reactive applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive development became a trending topic in many developers conferences,
    meetups, blog posts, and other countless content sources (both online and offline).
  prefs: []
  type: TYPE_NORMAL
- en: But what is a reactive application? Well, there's a official definition of it
    contained in something called **The Reactive Manifesto** (please refer to [https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, according to the manifesto, reactive systems are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: The system responds in a timely manner if at all possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: The system stays responsive in the face of failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: The system stays responsive under varying workloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message driven**: Reactive systems rely on asynchronous message-passing to
    establish a boundary between components that ensures loose coupling, isolation,
    and location transparency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this chapter will show you how to use Java EE 8 features to meet one or
    more of those reactive system requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Building reactive applications using asynchronous servlets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servlets are probably one of most well-known Java EE technologies (perhaps even
    the most known). Actually, servlets existed even before J2EE became a real specification.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use servlets asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a slow `UserBean` to return a `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, create our asynchronous servlet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the all important things here, we should start with a simple annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will tell the application server that this very servlet supports asynchronous
    features. By the way, you will need this in the whole servlet chain (including
    filters, if there are any), otherwise application server will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the servlets are instantiated by the server, we can inject other context
    members on it, such as our stateless bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The main servlet method holds the actual request and response references, and
    the request will give us the context reference to the async API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can execute your previous blocking function in a non-blocking way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-servlet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using events and observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events and observers are a great way to write code in a reactive way without
    thinking too much about it, thanks to the great work done by the CDI specification.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how easy is to use it to improve the user experience
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, let''s create a REST endpoint with event and observer features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we ask the application server to create a `Event` source for the `User`
    POJO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that it will listen to any events fired against any `User` object.
    So what we need to do is create a method to deal with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So now this method is the proper listener. The `@ObserversAsync` annotation
    guarantees it. So once an async event is fired, it will do whatever we asked (or
    coded).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created a simple asynchronous endpoint to fire it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-event-observer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using websockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Websockets are a great way to create decoupled communication channels for your
    applications. Doing it asynchronously is even better and cooler for non-blocking
    features.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need is our server endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a client to communicate with the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we need a simple REST endpoint to talk to the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first important thing in our server is this annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we must ensure that we have one and only one instance of the server
    endpoint. This will ensure that all `peers` are managed under the same umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to talk about `peers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The list holding them is a synchronized list. This is important because you
    will add/remove peers while iterating on the list, so things could be messed up
    if you don't protect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the default websocket methods are managed by the application server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s give a special mention to the code on our `onMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are sending a message to the peer only if it is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now looking to our client, we have a reference to the server URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the protocol is `ws`, specific to websocket communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a method to open the connection with the server endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And once we have the message confirmation from the server, we can do something
    about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This response will appear on the endpoint that is calling the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We are passing the reference to the client so the client can use it to write
    the message on it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-websocket).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using message-driven beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java Messaging Service is one of the oldest Java EE APIs, and it''s been
    reactive since day one: just read the manifesto linked in the introduction of
    this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to use message-driven beans, or MDBs, to deliver
    and consume asynchronous messages with just a few annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To check the details about queue setup in GlassFish 5, please refer to the recipe
    *Using Messaging Services for Asynchronous Communication* at [Chapter 5](e8021c0e-e762-4e43-8d9b-5c7040a453f3.xhtml),
    *Security of Enterprise Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a message sender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we create a message consumer. This is our MDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create an endpoint, just to send a mock user to the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by asking the application server a JMS context instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We also send a reference to the queue we want to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using the context, we create a producer to send the message to the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to these three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setDeliveryMode`: This method can be `PERSISTENT` or `NON_PERSISTENT`. If
    using `PERSISTENT`, the server will take special care of the message and not lose
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDisableMessageID`: This one is used for creating `MessageID`, which increases
    the server effort to create and deliver the message and also increases its size.
    This property (`true` or `false`) gives a hint to the server that you are not
    going to need/use it, so it can improve the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setDisableMessageTimestamp`: This is the same as for `setDisableMessageID`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note that we are sending a `User` instance to the queue. So you can easily
    send object instances, not only text messages, as long as they implement the serializable
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The MDB itself, or our message consumer, is basically a few annotations and
    an interface implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is its annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using two properties: one to define which queue we are looking
    up (`destinationLookup`) and another to define that it is really the queue type
    we are using (`destinationType`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is easy to get the `User` instance from the message''s body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: No heavy lifting at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the endpoint used to send the message couldn''t be simpler. We inject the
    `Sender` (which is a stateless bean):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call an asynchronous method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-mdb).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using JAX-RS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JAX-RS API also has some great features for event-driven programming. This
    recipe will show you can use an async invoker from the request to write responses
    through callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define `UserBean`, which will act as a remote endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then finally, we define a local endpoint that will consume the remote one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start the bean by creating the communication with the remote endpoint right
    in the bean instantiation. Doing this will avoid the overhead of doing it later
    while the invocation is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we created an anonymous `InvocationCallback` implementation within our
    async invoker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That way, we can rely on the `completed` and `failed` events and deal with them
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-jaxrs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive applications using asynchronous session beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Session beans can also become reactive and event driven just by using annotations.
    This recipe will show you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our asynchronous session bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create the endpoint that will call the bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first check the `getUser` method from the session bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Once we user the `@Asynchronous` annotation, we have to turn its returning value
    to a `Future` instance of something (in our case, `User`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created a `void` method to show you how to create a non-blocking code
    with session beans:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we created our calling endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As `getUser` returns `Future`, we can work with an async status check. Once
    it is done, we write the results in the response (also asynchronous).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-async-bean).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using lambdas and CompletableFuture to improve reactive applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java language always had the reputation of being a verbose language. But
    since the advent of lambdas, this issue has improved a lot.
  prefs: []
  type: TYPE_NORMAL
- en: We can use lambdas and also bring `CompletableFuture` to the party to improve
    not only the coding, but also the behavior of reactive applications. This recipe
    will show you how.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call `UserBean` to return a `User` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create an async endpoint to call the bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are using basically two `CompletableFuture` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`supplyAsync`: This will start an async call to whatever you put inside of
    it. We put in a lambda call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenAcceptAsync`: Once the async process is done, the returning value will
    come here. Thanks to lambdas, we can call this returning value as `u` (and could
    be whatever we want). Then, we use it to write it down to the asynchronous response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter10/ch10-completable-future).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
