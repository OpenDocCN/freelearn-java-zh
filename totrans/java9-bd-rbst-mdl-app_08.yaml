- en: Leveraging the New Default G1 Garbage Collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we examined **Java Shell** (**JShell**), Java 9's new
    **read-eval-print loop** (**REPL**) command-line tool. We started with introductory
    information regarding the tool and looked closely at the read-eval-print loop
    concept. We spent considerable time reviewing JShell commands and command-line
    options. Our coverage included practical guides to feedback modes, asset listing,
    and editing in the shell. We also gained experience working with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take an in-depth look at **garbage collection** and
    how it is handled in Java 9\. We will start with an overview of garbage collection,
    and then look at specifics in the pre-Java 9 realm. Armed with that foundational
    information, we will look at specific garbage collection changes in the Java 9
    platform. Lastly, we will look at some garbage collection issues that persist,
    even after Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pre-Java 9 garbage collection schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting garbage with the new Java platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Garbage collection is the mechanism used in Java to deallocate unused memory.
    Essentially, when an object is created, memory space is allocated and dedicated
    to that object until it no longer has any references pointing to it. At that time,
    the system deallocates the memory. Java performs this garbage collection automatically
    for us, which can lead to a lack of attention to memory usage and poor programming
    practices in the area of memory management and system performance.
  prefs: []
  type: TYPE_NORMAL
- en: Java's garbage collection is considered an automatic memory management schema
    because programmers do not have to designate objects as ready to be deallocated.
    The garbage collection runs on a low-priority thread and, as you will read later
    in this chapter, has variable execution cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our overview of garbage collection, we will look at the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Object life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java methods relevant to garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at each of these concepts in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Object life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to fully understand Java's garbage collection, we need to look at the
    entire life cycle of an object. Because the core of garbage collection is automatic
    in Java, it is not uncommon to see the terms *garbage collection* and *memory
    management* as assumed components of the object life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our review of the object life cycle with object creation.
  prefs: []
  type: TYPE_NORMAL
- en: Object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objects are declared and created. When we write an object declaration, or declare
    an object, we are declaring a name or identifier so that we can refer to an object.
    For example, the following line of code declares `myObjectName` as the name of
    an object of type `CapuchinMonkey`. At this point, no object was created and no
    memory allocated for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `new` keyword to create an object. The following example illustrates
    how to invoke the `new` operation to create an object. This operation results
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we can combine the declaration and creation statements together by
    using `CapuchinMonkey myObjectName = new CapuchinMonkey();` instead of `CapuchinMonkey
    myObjectName;` and `myObjectName = new CapuchinMonkey();`. They were separated
    in the preceding example for illustrative purposes.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is created, a specific amount of memory is allocated for storing
    that object. The amount of memory allocated can differ based on architecture and
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Next look at the mid-life of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Object mid-life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are created and Java allocates system memory for storing that object.
    If the object is not used, the memory allocated to it is considered wasted. This
    is something we want to avoid. Even with small applications, this type of wasted
    memory can lead to poor performance and even out-of-memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to deallocate or release the memory, any previously allocated memory
    that we no longer need. Fortunately, with Java, there is a mechanism for handling
    this issue. It is called garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: When an object, such as our `myObjectName` example, no longer has any references
    pointing to it, the system will reallocate the associated memory.
  prefs: []
  type: TYPE_NORMAL
- en: Object destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of Java having a garbage collector running in the dark shadows of your
    code (usually a low-priority thread) and deallocating memory currently allocated
    to unreferenced objects, is appealing. So, how does this work? The garbage collection
    system monitors objects and, as feasible, counts the number of references to each
    object.
  prefs: []
  type: TYPE_NORMAL
- en: When there are no references to an object, there is no way to get to it with
    the currently running code, so it makes perfect sense to deallocate the associated
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: The term **memory leak** refers to small memory chunks to be lost or improperly
    deallocated. These leaks are avoidable with Java's garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several garbage collection algorithms, or types, for use by the Java
    virtual machine. In this section, we will cover the following garbage collection
    algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark and sweep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMS garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: G1 garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark and sweep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java''s initial garbage collection algorithm, *mark and sweep*, used a simple
    two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Java first step, mark, is to step through all objects that have accessible references,
    marking those objects as alive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second step, sweep, involves scanning the sea for any object that is not
    marked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can readily determine, the mark and sweep algorithm seems effective,
    but probably not very efficient due to the two-step nature of this approach. This
    eventually lead to a Java garbage collection system with vastly improved efficiencies.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mark sweep (CMS) garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **concurrent mark sweep** (**CMS**) algorithm for garbage collection scans
    heap memory using multiple threads. Similar to the mark and sweep method, it marks
    objects for removal and then makes a sweep to actually remove those objects. This
    method of garbage collection is essentially an upgraded mark and sweep method.
    It was modified to take advantage of faster systems and had performance enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually invoke the concurrent mark sweep garbage collection algorithm for
    your application, use the following command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use the concurrent mark sweep garbage collection algorithm and
    dictate the number of threads to use, you can use the following command-line option.
    In the following example, we are telling the Java platform to use the concurrent
    mark sweep garbage collection algorithm with eight threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Serial garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java's serial garbage collection works on a single thread. When executing, it
    freezes all other threads until garbage collection operations have concluded.
    Due to the thread-freezing nature of serial garbage collection, it is only feasible
    for very small programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually invoke the serial garbage collection algorithm for your application,
    use the following command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Parallel garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to Java 9, the parallel garbage collection algorithm was the default garbage
    collector. It uses multiple threads but freezes all non-garbage collection threads
    in the application until garbage collection functions have completed, just like
    the serial garbage collection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: G1 garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The G1 garbage collection algorithm was created for use with large memory heaps.
    This approach involves segmenting the memory heap into regions. Garbage collection,
    using the G1 algorithm, takes place in parallel with each heap region.
  prefs: []
  type: TYPE_NORMAL
- en: Another part of the G1 algorithm is that when memory is deallocated, the heap
    space is compacted. Unfortunately, the compacting operation takes place using
    the *Stop the World* approach.
  prefs: []
  type: TYPE_NORMAL
- en: The G1 garbage collection algorithm also prioritizes the regions based on those
    that have the most garbage to be collected.
  prefs: []
  type: TYPE_NORMAL
- en: The G1 name refers to Garbage First.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually invoke the G1 garbage collection algorithm for your application,
    use the following command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Garbage collection options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of JVM sizing options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sizing description** | **JVM option flag** |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial heap size (young space plus tenured space). | `-XX:InitialHeapSize=3g`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum heap size (young space plus tenured space). | `-XX:MaxHeapSize=3g`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial and maximum heap size (young space plus tenured space).
    | `-Xms2048m -Xmx3g` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial size of young space. | `-XX:NewSize=128m` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum size of young space. | `-XX:MaxNewSize=128m` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets young space size. Uses ration of young verses tenured space. In the
    sample flag to the right, `3` means that young space will be three times smaller
    than tenured space. | `-XX:NewRation=3` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the size of single survivor space as a portion of Eden space size. |
    `-XX:SurvivorRatio=15` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial size of the permanent space. | `-XX:PermSize=512m` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum size of the permanent space. | `-XX:MaxPermSize=512m` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the size of the stack area dedicated to each thread in bytes. | `-Xss512k`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the size of the stack area dedicated to each thread in Kbytes. | `-XX:ThreadStackSize=512`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum size of off-heap memory available to the JVM. | `-XX:MaxDirectMemorySize=3g`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a list of young garbage collection options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Young garbage collection tuning option** | **Flag** |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial value for the number of collections before an object will
    be promoted from young to tenured space. This is referred to as the **tenuring
    threshold**. | `-XX:InitialTenuringThreshold=16` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum value for tenuring threshold. | `-XX:MaxTenuringThreshold=30`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the maximum object size allowed to be allocated in young space. If an
    object is larger than the maximum size it will be allocated to tenured space and
    bypass young space. | `-XX:PretenureSizeThreshold=3m` |'
  prefs: []
  type: TYPE_TB
- en: '| This can be used to promote all young objects surviving the young collection
    to tenured space. | `-XX:+AlwaysTenure` |'
  prefs: []
  type: TYPE_TB
- en: '| With this tag, objects from young space never get promoted to tenured space
    as long as the survivor space has sufficient room for them. | `-XX:+NeverTenure`
    |'
  prefs: []
  type: TYPE_TB
- en: '| We can indicate that we want to use thread local allocation blocks in the
    young space. This is enabled by default. | `-XX:+UseTLAB` |'
  prefs: []
  type: TYPE_TB
- en: '| Toggle this to allow the JVM to adaptively resize the **TLAB** (**Thread
    Local Allocation Blocks**) for threads. | `-XX:+ResizeTLAB` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the initial size of TLAB for a thread. | `-XX:TLABSize=2m` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the minimum allowable size of TLAB. | `-XX:MinTLABSize=128k` |'
  prefs: []
  type: TYPE_TB
- en: 'Here is a list of **concurrent mark sweep** (**CMS**) tuning options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CMS tuning option** | **Flag** |'
  prefs: []
  type: TYPE_TB
- en: '| Indicates that you want to solely use occupancy as a criterion for starting
    a CMS collection operation. | `-XX:+UseCMSInitiatingOccupancyOnly` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the percentage CMS generation occupancy to start a CMS collection cycle.
    If you indicate a negative number, you are telling the JVM you want to use `CMSTriggerRatio`.
    | `-XX:CMSInitiatingOccupancyFraction=70` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the percentage CMS generation occupancy that you want to initiate a
    CMS collection for bootstrapping collection statistics. | `-XX:CMSBootstrapOccupancy=10`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This is the percentage of `MinHeapFreeRatio` in CMS generation that is allocated
    prior to a CMS cycle starts. | `-XX:CMSTriggerRatio=70` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the percentage of `MinHeapFreeRatio` in the CMS permanent generation
    that is allocated before starting a CMS collection cycle. | `-XX:CMSTriggerPermRatio=90`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This is the wait duration after a CMS collection is triggered. Use the parameter
    to specify how long the CMS is allowed to wait for young collection. | `-XX:CMSWaitDuration=2000`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enables parallel remark. | `-XX:+CMSParallelRemarkEnabled` |'
  prefs: []
  type: TYPE_TB
- en: '| Enables parallel remark of survivor space. | `-XX:+CMSParallelSurvivorRemarkEnabled`
    |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this to force young collection before the remark phase. | `-XX:+CMSScavengeBeforeRemark`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Use this to prevent scheduling remark if Eden used is below the threshold
    value. | `-XX:+CMSScheduleRemarkEdenSizeThreshold` |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the Eden occupancy percentage that you want CMS to try and schedule
    a remark pause. | `-XX:CMSScheduleRemarkEdenPenetration=20` |'
  prefs: []
  type: TYPE_TB
- en: '| This is where you want to start sampling Eden top at least before young generation
    occupancy reaches *1/4*^(th) (in our sample to the right) of the size at which
    you want to schedule remark. | `-XX:CMSScheduleRemarkSamplingRatio=4` |'
  prefs: []
  type: TYPE_TB
- en: '| You can select `variant=1` or `variant=2` of verification following remark.
    | `-XX:CMSRemarkVerifyVariant=1` |'
  prefs: []
  type: TYPE_TB
- en: '| Elects to use the parallel algorithm for young space collection. | `-XX:+UseParNewGC`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Enables the use of multiple threads for concurrent phases. | `-XX:+CMSConcurrentMTEnabled`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the number of parallel threads used for the concurrent phases. | `-XX:ConcGCThreads=2`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sets the number of parallel threads you want used for *stop-the-world* phases.
    | `-XX:ParallelGCThreads=2` |'
  prefs: []
  type: TYPE_TB
- en: '| You can enable **incremental CMS** (**iCMS**) mode. | `-XX:+CMSIncrementalMode`
    |'
  prefs: []
  type: TYPE_TB
- en: '| If this is not enabled, CMS will not clean permanent space. | `-XX:+CMSClassUnloadingEnabled`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This allows `System.gc()` to trigger concurrent collection instead of a full
    garbage collection cycle. | `-XX:+ExplicitGCInvokesConcurrent` |'
  prefs: []
  type: TYPE_TB
- en: '| This allows `System.gc()` to trigger concurrent collection of permanent space.
    | `-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses` |'
  prefs: []
  type: TYPE_TB
- en: '**iCMS** (**incremental concurrent mark sweep**) mode is intended for servers
    with a small number of CPUs. It should not be employed on modern hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some miscellaneous garbage collection options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Miscellaneous garbage collection options** | **Flag** |'
  prefs: []
  type: TYPE_TB
- en: '| This will cause the JVM to ignore any `System.gc()` method invocations by
    an application. | `-XX:+DisableExplicitGC` |'
  prefs: []
  type: TYPE_TB
- en: '| This is the (soft reference) time to live in milliseconds per MB of free
    space in the heap. | `-XX:SoftRefLRUPolicyMSPerMB=2000` |'
  prefs: []
  type: TYPE_TB
- en: '| This is the **use policy** used to limit the time spent in garbage collection
    before an `OutOfMemory` error is thrown. | `-XX:+UseGCOverheadLimit` |'
  prefs: []
  type: TYPE_TB
- en: '| This limits the proportion of time spent in garbage collection before an
    `OutOfMemory` error is thrown. This is used with `GCHeapFreeLimit`. | `-XX:GCTimeLimit=95`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This sets the minimum percentage of free space after a full garbage collection
    before an `OutOfMemory` error is thrown. This is used with `GCTimeLimit`. | `-XX:GCHeapFreeLimit=5`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, here are some G1 specific options. Note that, these are all supported
    starting with JVM 6u26:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **G1 garbage collection options** | **Flag** |'
  prefs: []
  type: TYPE_TB
- en: '| Size of the heap region. The default is 2,048 and the acceptable range is
    1 MiB to 32 MiB. | `-XX:G1HeapRegionSize=16m` |'
  prefs: []
  type: TYPE_TB
- en: '| This is the confidence coefficient pause prediction heuristics. | `-XX:G1ConfidencePercent=75`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This determines the minimum reserve in the heap. | `-XX:G1ReservePercent=5`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This is the garbage collection time per MMU--time slice in milliseconds.
    | `-XX:MaxGCPauseMillis=100` |'
  prefs: []
  type: TYPE_TB
- en: '| This is the pause interval time slice per MMU in milliseconds. | `-XX:GCPauseIntervalMillis=200`
    |'
  prefs: []
  type: TYPE_TB
- en: '**MiB** stands for **Mebibyte** which is a multiple of bytes for digital information.'
  prefs: []
  type: TYPE_NORMAL
- en: Java methods relevant to garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at two specific methods associated with garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: The System.gc() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although garbage collection is automatic in Java, you can make explicit calls
    to the `java.lang.System.gc()` method to aid in the debugging process. This method
    does not take any parameters and does not return any value. It is an explicit
    call that runs Java''s garbage collector. Here is a sample implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a more in-depth example. In the following code, we start by
    creating an instance of the `Runtime`, using `Runtime myRuntime = Runtime.getRuntime();`
    which returns a singleton. This gives us access to the JVM. After printing some
    header information and initial memory stats, we create an `ArrayList` with a size
    of `300000`. Then, we create a loop that generates `100000` array list objects.
    Lastly, we provide output in three passes, asking the JVM to invoke the garbage
    collector with `1` second pauses in between. Here is the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the garbage collector did not reallocate
    all of the ''garbage'' during the first or even the second pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a3d2619-3fad-4bb4-8b81-37917e313c73.png)'
  prefs: []
  type: TYPE_IMG
- en: There is an alternative to using the `System.gc()` method to invoke the garbage
    collector. In our example, we could have used `myRuntime.gc()`, our earlier singleton
    example.
  prefs: []
  type: TYPE_NORMAL
- en: The finalize() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can think of Java's garbage collector as a death dealer. When it removes
    something from memory, it is gone. This so-called death dealer is not without
    compassion as it provides each method with their final last words. The objects
    give their *last words* through a `finalize()` method. If an object has a `finalize()`
    method, the garbage collector invokes it before the object is removed and the
    associated memory deallocated. The method takes no parameters and has a return
    type of `void`.
  prefs: []
  type: TYPE_NORMAL
- en: The `finalize()` method is only called once and there can be variability when
    it is run. Certainly, the method is invoked before it is removed, but when the
    garbage collector runs is dependent on the system. If, as an example, you have
    a relatively small app that is running a memory-rich system, the garbage collector
    might not run at all. So, why include a `finalize()` method at all? It is considered
    poor programming practice to override the `finalize()` method. That being said,
    you can use the method if needed. In fact, you can add code there to add a reference
    to your object to ensure it is not removed by the garbage collector. Again, this
    is not advisable.
  prefs: []
  type: TYPE_NORMAL
- en: Because all objects in Java, even the ones you create yourself are child classes
    of `java.lang.Object`, every object in Java has a `finalize()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector, as sophisticated as it is, might not close databases,
    files, or network connections the way you want it done. If your application requires
    specific considerations when its objects are collected, you can override the object's
    `finalize()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example implementation that demonstrates a use case for when you
    might want to override an object''s `finalize()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the `objectTally` count is incremented
    each time an object of type `Animal` is created and decremented when one is removed
    by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding an object's `finalize()` method is usually discouraged. The `finalize()`
    method should normally be declared as `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-Java 9 garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java's garbage collection is not new to Java 9, it has existed since the initial
    release of Java. Java has long had a sophisticated garbage collection system that
    is automatic and runs in the background. By running in the background, we are
    referring to garbage collection processes running during idle times.
  prefs: []
  type: TYPE_NORMAL
- en: Idle times refer to the time in between input/output such as between keyboard
    input, mouse clicks, and output generation.
  prefs: []
  type: TYPE_NORMAL
- en: This automatic garbage collection has been one of the key factors in developers
    selecting Java for their programming solutions. Other programming languages such
    as C# and Objective-C have implemented garbage collection following the success
    of the Java platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s next take a look at the following listed concepts before we look at
    the changes to garbage collection in the Java 9 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection upgrades in Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Case study - Games written with Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizing garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, the preceding code generates the output provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What might not be clear is that the sample code results in five unreferenced
    string objects. This is due, in part, because strings are immutable. As you can
    see in the following illustration, with each successive line of code, the referenced
    object is updated and an additional object becomes unreferenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ecc5e95-dc0b-4998-a8dd-37452ec0d9ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding unreferenced objects listed certainly will not break the memory
    bank, but it is indicative of how quickly a large number of unreferenced objects
    can accumulate.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection upgrades in Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of Java 8, the default garbage collection algorithm was the parallel garbage
    collector. Java 8 was released with some improvements to the G1 garbage collection
    system. One of these improvements was the ability to use the following command-line
    option to optimize the heap memory by removing duplicative string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The G1 garbage collector can view the character arrays when it sees a string.
    It then takes the value and stores it with a new, weak reference to the character
    array. If the G1 garbage collector finds a string with the same hash code, it
    will compare the two strings with a character-by-character review. If a match
    is found, both strings end up pointing to the same character array. Specifically,
    the first string will point to the character array of the second string.
  prefs: []
  type: TYPE_NORMAL
- en: This method can require substantial processing overhead and should only be used
    if deemed beneficial or absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Case study - Games written with Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiplayer games require extensive management techniques, both for server and
    client systems. The JVM runs the garbage collection thread in a low-priority thread
    and periodically runs. Server administrators previously used an incremental garbage
    collection schema using the now depreciated `-Xincgc` command-line option to avoid
    **server stalls** that occur when the server is overloaded. The goal is to have
    garbage collection run more frequently and with much shorter execution cycles
    each time.
  prefs: []
  type: TYPE_NORMAL
- en: When considering memory usage and garbage collection, it is important to use
    as little memory on the target system as possible and to limit pauses for garbage
    collection to the extent feasible. These tips are especially important for games,
    simulations, and other applications that require real-time performance.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM manages the heap where Java memory is stored. The JVM starts with a
    small heap by default and grows as additional objects are created. The heap has
    two partitions--young and tenured. When objects are initially created, they are
    created in the young partition. Persistent objects are moved to the tenure partition.
    The creation of objects is usually very quick with not much more than pointer
    incrementation. Processing in the young partition is much faster than that of
    the tenured partition. This is important because it applies to the overall app,
    or in our case, a game's efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'It becomes important for us to monitor our game''s memory usage and when garbage
    collection occurs. To monitor garbage collection, we can add the verbose flag
    (`-verbose:gc`) when we launch our game such as with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The JVM will then provide a line of formatted output for each garbage collection.
    Here is the format of the verbose GC output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at two examples. In this first example, we see `GC` for type which
    refers to the young partition we previously discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second example, `Full GC` indicates that the garbage collection action
    was taken on the tenured partition of the memory heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain more detailed information from the garbage collector using the
    `-XX:+PrintGCDetails` option as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Collecting garbage with the new Java platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java came out of the gate with automatic garbage collection, making it a development
    platform of choice for many programmers. It was commonplace to want to avoid manual
    memory management in other programming languages. We have looked in-depth at the
    garbage collection system to include the various approaches, or algorithms, used
    by the JVM. Java 9 includes some relevant changes to the garbage collection system
    and was the focus of three **Java Enhancement Program** (**JEP**) issues. Those
    issues are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Default garbage collection (JEP 248)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depreciated garbage collection combinations (JEP 214)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unified garbage collection logging (JEP 271)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will review each one of these garbage collection concepts and their corresponding
    **Java Enhancement Plan** (**JEP**) issue in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Default garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We previously detailed the following garbage collection approaches used by
    the JVM prior to Java 9\. These are still plausible garbage collection algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: CMS garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: G1 garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s briefly recap each of these approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CMS garbage collection**: The CMS garbage collection algorithm scans heap
    memory using multiple threads. Using this approach, the JVM marks objects for
    removal and then makes a sweep to actually remove them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial garbage collection**: This approach uses a thread-freezing schema
    on a single thread. When the garbage collection is in progress, it freezes all
    other threads until garbage collection operations have concluded. Due to the thread-freezing
    nature of serial garbage collection, it is only feasible for very small programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel garbage collection**: This approach uses multiple threads but freezes
    all non-garbage collection threads in the application until garbage collection
    functions have completed, just like the serial garbage collection algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**G1 garbage collection**: This is the garbage collection algorithm with the
    following characteristics:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is used with large memory heaps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Involves segmenting the memory heap into regions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Takes place in parallel with each heap region
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compacts the heap space when memory is deallocated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compacting operations take place using the *Stop the World* approach
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritizes the regions based on those that have the most garbage to be collected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to Java 9, the parallel garbage collection algorithm was the default garbage
    collector. In Java 9, the G1 garbage collector is the new default implementation
    of Java's memory management system. This is true for both 32 and 64-bit server
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oracle assessed that the G1 garbage collector, mostly due to its low-pause
    nature, was a better performing garbage collection method than the parallel approach.
    This change was predicated on the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to limit latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximizing throughput is less important than limiting latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The G1 garbage collection algorithm is stable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two assumptions involved with making the G1 garbage collection method
    the default method over the parallel approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Making G1 the default garbage collection method will significantly increase
    its use. This increased usage might unveil performance or stability issues not
    realized before Java 9.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The G1 approach is more processor-intensive than the parallel approach. In some
    use cases, this could be somewhat problematic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the surface this change might seem like a great step for Java 9 and that
    very well might be the case. Caution, however, should be used when blindly accepting
    this new default collection method. It is recommended that systems be tested if
    switching to G1 to ensure your applications do not suffer from performance degradation
    or have unexpected issues that are caused by the use of G1\. As previously suggested,
    G1 has not benefited from the widespread testing that the parallel method has.
  prefs: []
  type: TYPE_NORMAL
- en: This last point about the lack of widespread testing is significant. Making
    G1 the default automatic memory management (garbage collection) system with Java
    9 is tantamount to turning developers into unsuspecting testers. While no major
    problems are expected, knowing that there is potential for performance and stability
    issues when using G1 with Java 9 will place greater emphasis on testing your Java
    9 applications.
  prefs: []
  type: TYPE_NORMAL
- en: Depreciated garbage collection combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Oracle has been great about depreciating features, APIs, and libraries before
    removing them from a new release to the Java platform. With this schema in place,
    language components that were depreciated in Java 8 are subject for removal in
    Java 9\. There are a few garbage collection combinations that were deemed to be
    rarely used and depreciated in Java 8\. Those combinations, listed here, have
    been removed in Java 9:'
  prefs: []
  type: TYPE_NORMAL
- en: DefNew + CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ParNew + SerialOld
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental CMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These combinations, in addition to having been rarely used, introduced an unneeded
    level of complexity to the garbage collection system. This resulted in an extra
    drain on system resources without providing a commensurate benefit to the user
    or developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listed garbage collection configurations were affected by the
    aforementioned depreciation in the Java 8 platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Garbage collection configuration** | **Flag(s)** |'
  prefs: []
  type: TYPE_TB
- en: '| DefNew + CMS | `-XX:+UseParNewGC``-XX:UseConcMarkSweepGC` |'
  prefs: []
  type: TYPE_TB
- en: '| ParNew + SerialOld | `-XX:+UseParNewGC` |'
  prefs: []
  type: TYPE_TB
- en: '| ParNew + iCMS | `-Xincgc` |'
  prefs: []
  type: TYPE_TB
- en: '| ParNew + iCMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC` |'
  prefs: []
  type: TYPE_TB
- en: '| Defnew + ICMS | `-XX:+CMSIncrementalMode``-XX:+UseConcMarkSweepGC``-XX:-UseParNewGC`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The **Java Enhancement Program 214** (**JEP 214**) removed garbage collection
    combinations depreciated in JDK 8\. Those combinations are listed above along
    with the flags that control those combinations. In addition, the flags to enable
    CMS foreground collections were removed and are not present in JDK 9\. Those flags
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Garbage collection combinations** | **Flag** |'
  prefs: []
  type: TYPE_TB
- en: '| CMS foreground | `-XX:+UseCMSCompactAtFullCollection` |'
  prefs: []
  type: TYPE_TB
- en: '| CMS foreground | `-XX+CMSFullGCsBeforeCompaction` |'
  prefs: []
  type: TYPE_TB
- en: '| CMS foreground | `-XX+UseCMSCollectionPassing` |'
  prefs: []
  type: TYPE_TB
- en: The only assessed downside to the removal of the depreciated garbage collection
    combinations is that applications that use JVM start up files with any of the
    flags listed in this section, will need to have their JVM start up files modified
    to remove or replace the old flags.
  prefs: []
  type: TYPE_NORMAL
- en: Unified garbage collection logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Java Enhancement Program #271** (**JEP-271**) titled, *Unified GC Logging*,
    is intended to re-implement garbage collection logging using the unified JVM logging
    framework that was previously introduced with JEP-158\. So, let''s first review
    the Unified JVM Logging (JEP-158).'
  prefs: []
  type: TYPE_NORMAL
- en: Unified JVM logging (JEP-158)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a unified logging schema for the JVM was the central goal of JEP-158\.
    Here is a high-level list of the goals of the JEP:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JVM-wide set of command-line options for all logging operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use categorized tags for logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Provide six levels of logging:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Trace
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not an exhaustive list of goals. We will discuss JEP-158 in greater
    detail in Chapter 14, *Command Line Flags*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes to the JVM, in the context of logging, can be categorized into:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly look at these categories.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging tags are identified in the JVM and can be changed in source code if
    needed. The tags should be self-identifying, such as `gc` for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each log message has an associated level. As previously listed, the levels
    are error, warning, information, debug, trace, and develop. The following chart
    shows how the levels have an increasing level of verbosity in respect to how much
    information is logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a924575f-0997-4289-a024-1747463ddca0.png)'
  prefs: []
  type: TYPE_IMG
- en: Decorations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the context of Java 9''s logging framework, decorations is metadata about
    the log message. Here is the alphabetic list of decorations that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: timemillis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: timenanos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uptime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uptimemillis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: uptimenanos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an explanation of these decorations, please refer to Chapter 14, *Command
    Line Flags*.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java 9 logging framework supports three types of output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'stderr: Provides output to stderr'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stdout: Provides output to stdout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'text file: Writes the output to text files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new command-line option was added to the logging framework to provide overall
    control of the JVM''s logging operations. The `-Xlog` command-line option has
    an extensive array of parameters and possibilities. Here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are telling the JVM to take the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Log all messages tagged with, at a minimum, the `gc` and `rt` tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `debug` level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide output to `stdout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unified GC logging (JEP-271)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a general understanding of the changes to Java 9''s logging
    framework, let''s look at what changes JEP-271 introduced. In this section we
    will look at the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection logging options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `gc` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection logging options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of garbage collection logging options and flags we had available
    to us before the introduction of Java 9''s logging framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Garbage collection logging option** | **JVM option flag(s)** |'
  prefs: []
  type: TYPE_TB
- en: '| This prints the basic garbage collection information. | `-verbose:gc` or
    `-XX:+PrintGC` |'
  prefs: []
  type: TYPE_TB
- en: '| This will print more detailed garbage collection information. | `-XX:+PrintGCDetails`
    |'
  prefs: []
  type: TYPE_TB
- en: '| You can print timestamps for each garbage collection event. The seconds are
    sequential and begin from the JVM start time. | `-XX:+PrintGCTimeStamps` |'
  prefs: []
  type: TYPE_TB
- en: '| You can print date stamps for each garbage collection event. Sample format:`2017-07-26T03:19:00.319+400:[GC
    . . . ]` | `-XX:+PrintGCDateStamps` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this flag to print timestamps for individual garbage collection
    work thread tasks. | `-XX:+PrintGCTaskTimeStamps` |'
  prefs: []
  type: TYPE_TB
- en: '| Using this you can redirect garbage collection output to a file instead of
    the console. | `-Xloggc:` |'
  prefs: []
  type: TYPE_TB
- en: '| You can print detailed information regarding young space following each collection
    cycle. | `-XX:+PrintTenuringDistribution` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this flag to print TLAB allocation statistics. | `-XX:+PrintTLAB`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Using this flag, you can print the times for reference processing (that is,
    weak, soft, and so on) during *stop-the-world* pauses. | `-XX:+PrintReferenceGC`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This reports if the garbage collection is waiting for native code to unpin
    objects in memory. | `-XX:+PrintJNIGCStalls` |'
  prefs: []
  type: TYPE_TB
- en: '| This will print a pause summary after each *stop-the-world* pause. | `-XX:+PrintGCApplicationStoppedTime`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This flag will print time for each concurrent phase of garbage collection.
    | `-XX:+PrintGCApplicationConcurrentTime` |'
  prefs: []
  type: TYPE_TB
- en: '| Using this flag will print a class histogram after a full garbage collection.
    | `-XX:+PrintClassHistogramAfterFullGC` |'
  prefs: []
  type: TYPE_TB
- en: '| Using this flag will print a class histogram before a full garbage collection.
    | `-XX:+PrintClassHistogramBeforeFullGC` |'
  prefs: []
  type: TYPE_TB
- en: '| This creates a heap dump file after full garbage collection. | `-XX:+HeapDumpAfterFullGC`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This creates a heap dump file before full garbage collection. | `-XX:+HeapDumpBeforeFullGC`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This creates a heap dump file in an out-of-memory condition. | `-XX:+HeapDumpOnOutOfMemoryError`
    |'
  prefs: []
  type: TYPE_TB
- en: '| You use this flag to specify the path where you want your heap dumps saved
    on your system. | `-XX:HeapDumpPath=<path>` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this to print CMS statistics, `if n >= 1`. Applies specifically
    to CMS only. | `-XX:PrintCMSStatistics=2` |'
  prefs: []
  type: TYPE_TB
- en: '| This will print CMS initialization details. Applies specifically to CMS only.
    | `-XX:+PrintCMSInitiationStatistics` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this flag to print additional information concerning free lists.
    Applies specifically to CMS only. | `-XX:PrintFLSStatistics=2` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this flag to print additional information concerning free lists.
    Applies specifically to CMS only. | `-XX:PrintFLSCensus=2` |'
  prefs: []
  type: TYPE_TB
- en: '| You can use this flag to print detailed diagnostic information following
    a promotion (young to tenure) failure. Applies specifically to CMS only. | `-XX:+PrintPromotionFailure`
    |'
  prefs: []
  type: TYPE_TB
- en: '| This flag allows you to dump useful information regarding the state of the
    CMS old generation when a promotion (young to tenure) failure occurs. Applies
    specifically to CMS only. | `-XX:+CMSDumpAtPromotionFailure` |'
  prefs: []
  type: TYPE_TB
- en: '| When the `-XX:+CMSDumpAtPromotionFailure` flag is used, you can use `-XX:+CMSPrintChunksInDump`
    to include additional details regarding free chunks. Applies specifically to CMS
    only. | `-XX:+CMSPrintChunksInDump` |'
  prefs: []
  type: TYPE_TB
- en: '| When using the `-XX:+CMSPrintChunksInDump` flag, you can include additional
    information about the allocated objects using the `-XX:+CMSPrintObjectsInDump`
    flag. Applies specifically to CMS only. | `-XX:+CMSPrintObjectsInDump` |'
  prefs: []
  type: TYPE_TB
- en: The gc tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the `gc` tag with the `-Xlog` option to inform the JVM to only log
    `gc` tagged items at the info level. As you will recall, this is similar to using
    `-XX:+PrintGC`. With both options, the JVM will log one line for each garbage
    collection operation.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `gc` tag was not intended to be used on its
    own; rather, it is recommended that it be used in conjunction with other tags.
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create macros to add logic to our garbage collection logging. Here is
    the general syntax for the log macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of a log macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example skeleton log macro shows how you can use the new Java
    9 logging framework to create scripts for greater fidelity in logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Additional considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some additional items to be considered in regards to garbage collection
    logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the new `-Xlog:gc` should produce similar results to the `-XX:+PrintGCDetails`
    command-line option and flag pairing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `trace` level provides the level of detail previously provided with
    the `verbose` flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with the advent of Java 9, there were downsides to Java's garbage collection
    system. Because it is an automatic process, we do not have complete control of
    when the collector runs. We, as developers, are not in control of garbage collection,
    the JVM is. The JVM makes the decision when to run garbage collection. As you
    have seen earlier in this chapter, we can ask the JVM to run garbage collection
    using the `System.gc()` method. Despite our use of this method, we are guaranteed
    that our request will be honored or that it will be complied with in a timely
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we reviewed several approaches and algorithms for garbage
    collection. We discussed how we, as developers, can take control of the process.
    That assumes that we have the ability to take control of garbage collection. Even
    when we specify a specific garbage collection technique, for example using `-XX:+UseConcMarkSweepGC`
    for CMS garbage collection, we are not guaranteed that the JVM will use that implementation.
    So, we can do our best to control how the garbage collector works, but should
    remember that the JVM has the ultimate authority regarding how, when, and if garbage
    collection occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Our lack of complete control over garbage collection underscores the importance
    of writing efficient code with memory management in mind. In the next sections,
    we will examine how to write code to explicitly make objects eligible for garbage
    collection by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: Making objects eligible for garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An easy method for making objects available for garbage collection is to assign
    `null` to the reference variable that refers to the object. Let''s review this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As indicated in the in-code comments, once the string object reference variable
    is set to null, in this case using the `junk = null;` statement, the object becomes
    available for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next example, we will abandon an object by setting its reference variable
    to point to a different object. As you can see in the following code, that results
    in the first object being available for garbage collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review one final method of making objects available for garbage collection.
    In this example, we have a single instance variable (`objectNbr`) that is a reference
    variable to an instance of the `GarbageCollectionExperimentThree` class. The class
    does not do anything interesting other than create additional reference variables
    to instances of the `GarbageCollectionExperimentThree` class. In our example,
    we set the `objectNbr2`, `objectNbr3`, `objectNbr4`, and `objectNbr5` references
    to `null`. Although these objects have instance variables and can refer to each
    other, their accessibility outside of the class has been terminated by setting
    their references to `null`. This makes them ( `objectNbr2`, `objectNbr3`, `objectNbr4`,
    and `objectNbr5` ) eligible for garbage collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we took an in-depth review of garbage collection as a critical
    pre-Java 9 platform component. Our review included object life cycle, garbage
    collection algorithms, garbage collection options, and methods related to garbage
    collection. We looked at upgrades to garbage collection in Java 8 and looked at
    a case study to help our understanding of modern garbage collection. We then turned
    our focus to the changes to garbage collection with the new Java 9 platform. Our
    exploration of garbage collection in Java 9 included looks at default garbage
    collection, depreciated garbage collection combinations, and unified garbage collection
    logging. We concluded our exploration of garbage collection by looking at a few
    garbage collection issues that persist, even after Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look at how to write performance tests using the
    **Java Microbenchmark Harness** (**JMH**), a Java harness library for writing
    benchmarks for the JVM.
  prefs: []
  type: TYPE_NORMAL
