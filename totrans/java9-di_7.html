<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">IoC Patterns and Best Practices</h1>
                
            
            <article>
                
<p class="calibre2">Now that you have reached this chapter, you should know what <strong class="calibre4">Dependency Injection</strong> (<strong class="calibre4">DI</strong>) is, why it's so important, how it's projected in recent versions of Java, and how to implement it with popular frameworks, such as Spring and Google Guice, with various scopes.</p>
<p class="calibre2">It's said that knowing something is not enough until it's applied with best methodologies and practices. Knowledge is power only when it's implemented in the right manner. An improper approach may create a big mess. </p>
<p class="calibre2">The software industry is moving toward modularity. The concepts of DI and <strong class="calibre4">Inversion of Control</strong> (<strong class="calibre4">IoC</strong>) containers were created due to this, and this is why they are so popular today. Still, many developers don't know how to utilize DI to its full potential. </p>
<p class="calibre2"><span class="calibre11">In this chapter, we will explore the real strength of DI by learning the right patterns and best practices to apply the expertise we gained in DI in previous chapters. This chapter is not meant to do anything new; instead, we will learn how to do things in the right manner.</span></p>
<p class="calibre2">In this chapter, we will cover the following topics:</p>
<ul class="calibre9">
<li class="calibre10"><span>Various patterns to achieve IoC</span></li>
<li class="calibre10">Configuration styles</li>
<li class="calibre10">Injection using the setter method versus constructor</li>
<li class="calibre10">Circular dependency</li>
<li class="calibre10">Best practices and anti-patterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Various patterns to achieve IoC</h1>
                
            
            <article>
                
<p class="calibre2">Let's recall what the  <strong class="calibre4">Dependency Inversion Principle</strong> (<strong class="calibre4">DIP</strong>) states: high-level modules should not depend upon low-level modules; both should depend upon abstraction. This is a fundamental requirement for making any application modular and adjustable.</p>
<p class="calibre2">While designing any system, we should make sure that high-level classes do not instantiate low-level classes; instead, they should rely on abstraction (the interface or abstract class) rather than depending on other concrete classes directly. The DIP does not specify how this happens, so a technique is required to separate the low-level modules from the high-level modules. <span class="calibre11">IoC</span><span class="calibre11"> provides this technique.</span></p>
<p class="calibre2">There are various patterns to achieve IoC, including inverting the object creation process from your class to some other class and reducing the coupling between modules or classes. Let's discuss these patterns, focusing more on how they decouple the modules and achieve separation of concerns:</p>
<ul class="calibre9">
<li class="calibre10">The factory method pattern</li>
<li class="calibre10">The service locator pattern</li>
<li class="calibre10">The template method pattern</li>
<li class="calibre10">The strategy pattern</li>
</ul>
<p class="calibre2">All of these patterns encapsulate a specific responsibility, which makes the system modular. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The factory method pattern</h1>
                
            
            <article>
                
<p class="calibre2">The factory method pattern concerns defining an interface (or abstract class) method for creating dependency objects. This method is called a factory method. <span class="calibre11">The class (or interface) that holds the factory method will be considered an abstract creator.</span> <span class="calibre11">The actual object creation process does not happen in the factory method directly.</span> </p>
<p class="calibre2">The concrete creators (which implement the factory method) will decide which dependent class to instantiate. In short, the dependent object is decided at runtime. <span class="calibre11">This process has been described in the following diagram:</span></p>
<div class="mce-root"><img src="../images/00052.gif" class="calibre70"/></div>
<p class="calibre2">The factory pattern's implementation is a four-step process:</p>
<ol class="calibre14">
<li value="1" class="calibre10">Declaring the product (the abstract product type).</li>
<li value="2" class="calibre10">Creating the concrete product.</li>
<li value="3" class="calibre10">Defining the factory method – a creator.</li>
<li value="4" class="calibre10">Creating concrete creators (concrete subclasses).</li>
</ol>
<p class="calibre2">Let's understand these steps by using an example. Suppose you are developing an application for a message service provider. Initially, the company provides an SMS service for cellular devices. So, the first version of your application code is handling message distribution with SMS only, assuming that the bulk of code is written in the <kbd class="calibre12">SMS</kbd> class.</p>
<p class="calibre2">Gradually, the service becomes popular and you want to add other bulk message services, such as email, WhatsApp, and other social media message services. This requires code changes because you have added all the code to the <kbd class="calibre12">SMS</kbd> class. This change in code is required for every new messaging service that is introduced into the system in future.</p>
<p class="calibre2">The factory method pattern suggests that the solution to this problem will be inverting the object creation process from the client code (with a new operator) to a specific method: the factory method. <span class="calibre11">The factory method defines a common interface that returns an abstract product type. A concrete product's creation is done in the child classes, which implement the factory method. </span><span class="calibre11">The objects returned from the factory method are referred to as <strong class="calibre4">Product</strong> in the preceding diagram. First, let's define an abstract product type and its concrete implementation for the preceding example.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining the product (abstract type) and its concrete implementation</h1>
                
            
            <article>
                
<p class="calibre2">In our case, the <strong class="calibre4">MessageApp</strong> interface represents an abstract product type. The implementation of each messaging app would reside in their respective concrete classes, which are concrete product types, such as <strong class="calibre4">SMSMessage</strong>, <strong class="calibre4">EmailMessage</strong>, and <strong class="calibre4">WhatsAppMessage</strong>. This relationship is described with the following diagram:</p>
<div class="mce-root"><img src="../images/00053.gif" class="calibre71"/></div>
<p class="calibre2">The product (abstract type) and all of the concrete product classes should look as follows:</p>
<pre class="calibre17">// Product (abstract type)<br class="title-page-name"/>public interface MessageApp {<br class="title-page-name"/>  void sendMessage(String message);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Product<br class="title-page-name"/>public class EmailMessage implements MessageApp {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void sendMessage(String message) {<br class="title-page-name"/>    //Mail specific implementation<br class="title-page-name"/>    System.out.println("Sending eMail message ...."+message);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Product<br class="title-page-name"/>public class SMSMessage implements MessageApp {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void sendMessage(String message) {<br class="title-page-name"/>    //SMS specific implementation.<br class="title-page-name"/>    System.out.println("sending SMS message ..."+message);<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Product<br class="title-page-name"/>public class WhatsAppMessage implements MessageApp {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void sendMessage(String message) {<br class="title-page-name"/>    //Whatsapp specific implementation<br class="title-page-name"/>    System.out.println("Sending Whatsapp message ..."+message);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining the factory method (creator interface) and its concrete implementation</h1>
                
            
            <article>
                
<p class="calibre2">The next step is to create a class and define the factory method that returns the abstract product type <span class="calibre11">(</span><strong class="calibre4">MessageApp</strong>,<span class="calibre11"> in our case)</span>. This class is considered an abstract creator. The factory method would be in the form of either an interface or the abstract method. All concrete creators must implement this factory method. The following diagram describes the complete relationship between these components:</p>
<div class="mce-root"><img src="../images/00054.gif" class="calibre41"/></div>
<p class="calibre2">Here, <strong class="calibre4">MessagingService</strong> is the creator, while <strong class="calibre4">EmailServices</strong>, <strong class="calibre4">SMSServices</strong>, and <strong class="calibre4">WhatsAppServices</strong> are concrete creators. Each concrete creator produces the respective concrete product type.</p>
<p class="calibre2">The factory method and its concrete implementation classes should look as follows:</p>
<pre class="calibre17">//Abstract creator<br class="title-page-name"/>public abstract class MessagingService {<br class="title-page-name"/>  //This is Factory method.<br class="title-page-name"/>  public abstract MessageApp createMessageApp();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete creator<br class="title-page-name"/>public class EmailServices extends MessagingService{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public MessageApp createMessageApp() {<br class="title-page-name"/>    return new EmailMessage();<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete creator<br class="title-page-name"/>public class SMSServices extends MessagingService {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public MessageApp createMessageApp() {<br class="title-page-name"/>    return new SMSMessage();<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete creator<br class="title-page-name"/>public class WhatsAppServices extends MessagingService {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public MessageApp createMessageApp() {<br class="title-page-name"/>    return new WhatsAppMessage();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<div class="packt_infobox">In the preceding case, we have used an abstract class, but you can also use an interface for the factory method (abstract creator). If you are planning to provide any common methods, you can choose an abstract class, or else an interface would be an appropriate choice.</div>
<p class="calibre2">Finally, the factory class that provided the specific implementation looks as follows:</p>
<pre class="calibre17">public class MessagingFactory {<br class="title-page-name"/>  public MessageApp getMessageApp(MessageType messageType) {<br class="title-page-name"/>    MessageApp messageApp = null;<br class="title-page-name"/>    // 1.Based on messageType value, create concrete implementation.<br class="title-page-name"/>    // 2.Call factory method on each of them to get abstract product type - MessageApp in our case<br class="title-page-name"/>    // 3.call common method on abstract product type to execute desire operation.<br class="title-page-name"/>    <br class="title-page-name"/>    switch(messageType) {<br class="title-page-name"/>    case SMSType:<br class="title-page-name"/>      messageApp = new SMSServices().createMessageApp();<br class="title-page-name"/>      break;<br class="title-page-name"/>    case EmailType:<br class="title-page-name"/>      messageApp = new EmailServices().createMessageApp();<br class="title-page-name"/>      break;<br class="title-page-name"/>    case WhatsAppType:<br class="title-page-name"/>      messageApp = new WhatsAppServices().createMessageApp();<br class="title-page-name"/>      break;<br class="title-page-name"/>    default: System.out.println(" Unknown message type .. Please provide valid message type "); <br class="title-page-name"/>    }<br class="title-page-name"/>    return messageApp;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This class returns the concrete implementation based on a specific <kbd class="calibre12">enum</kbd> type. The following code snippet depicts how client code can use the factory method:</p>
<pre class="calibre17">public class Client {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    MessagingFactory messagingFactory = new MessagingFactory();<br class="title-page-name"/>    MessageApp smsApp = messagingFactory.getMessageApp(MessageType.SMSType);<br class="title-page-name"/>    MessageApp emailApp = messagingFactory.getMessageApp(MessageType.EmailType);<br class="title-page-name"/>    MessageApp whatsAppApp = messagingFactory.getMessageApp(MessageType.WhatsAppType);<br class="title-page-name"/>    smsApp.sendMessage(" Hello ");<br class="title-page-name"/>    emailApp.sendMessage(" this is test ");<br class="title-page-name"/>    whatsAppApp.sendMessage(" Good Morning");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This is described with the following diagram:</p>
<div class="mce-root"><img src="../images/00055.gif" class="calibre72"/></div>
<p class="calibre2">With the factory method pattern, you can make the product creation process abstracted from the client class. This way, the factory method pattern removes the dependency of the concrete product classes from the rest of the system. Additionally, the factory method delegates the actual object creation process to concrete creators. As long as the client code knows the type, the factory class will <span class="calibre11">supply the dependency object of that type.</span> This way, the factory method allows client code to depend on abstraction rather than concrete implementation. This is how IoC is achieved through the factory method pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The service locator pattern</h1>
                
            
            <article>
                
<p class="calibre2">The service locator pattern entails removing dependencies from the client object by introducing a mediator. The client object will talk to the mediator to get a desired dependency. We will call this mediator the service locator, or just the locator.</p>
<p class="calibre2">The service locator involves the process of obtaining services with the abstract layer. Ideally, the locator should hold all the services (dependencies) and provide them with a single interface. <span class="calibre11">It is a kind of central repository to find a service, usually by a string or interface type. </span></p>
<p class="calibre2">The service locator describes how to register and locate the service rather than telling us how to instantiate it. It lets the application register the concrete implementation for the given contract. You can add services either programmatically or through configuration. The implementation of the service locator is described in the following diagram:</p>
<div class="mce-root"><img src="../images/00056.gif" class="calibre73"/></div>
<p class="calibre2"><span class="calibre11">This is a very simple form of the service locator pattern. <strong class="calibre4">ModuleA</strong> is dependent on <strong class="calibre4">ServiceB</strong> and <strong class="calibre4">ServiceC</strong>, which are provided by the <strong class="calibre4">Service Locator</strong>. However, you can make the <strong class="calibre4">Service Locator</strong> more abstract so that it can handle any type of service. Let's understand how to do that.</span></p>
<p class="calibre2">It is always a good idea to expose any service with an interface. We will take an example of two such service interfaces and their implementations in the following snippet:</p>
<pre class="calibre17">public interface CompressionAlgorithm {<br class="title-page-name"/>  void doCompress();<br class="title-page-name"/>}<br class="title-page-name"/>public interface EncryptionAlgorithm {<br class="title-page-name"/>  void doEncryption();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class RARCompression implements CompressionAlgorithm {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void doCompress() {<br class="title-page-name"/>    System.out.println(" Compressing in RAR format ... ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ZIPCompression implements CompressionAlgorithm {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void doCompress() {<br class="title-page-name"/>    System.out.println(" Compressing in ZIP format ... ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">We want to get compression and encryption services from the service locator. We will write the <kbd class="calibre12">ServiceLocator</kbd> class, which is a singleton, and allows us to register these services. Once this is done, the client can get the services by the type of service interface. The <kbd class="calibre12"><span>ServiceLocator</span></kbd> class will look as follows:</p>
<pre class="calibre17">public class ServiceLocator {<br class="title-page-name"/>  // Map which holds all services.<br class="title-page-name"/>  private Map&lt;Class&lt;?&gt;,Map&lt;String,Object&gt;&gt; serviceRegistry = new HashMap&lt;Class&lt;?&gt;,Map&lt;String,Object&gt;&gt;(); <br class="title-page-name"/>  private static ServiceLocator serviceLocator;<br class="title-page-name"/>  <br class="title-page-name"/>  // private constructor to make this class singleton <br class="title-page-name"/>  private ServiceLocator() {<br class="title-page-name"/>    <br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  //Static method to get only existing instance. If no instance is there, create the new one.<br class="title-page-name"/>  public static ServiceLocator getInstance() {<br class="title-page-name"/>    if(serviceLocator == null) {<br class="title-page-name"/>      serviceLocator = new ServiceLocator();<br class="title-page-name"/>    }<br class="title-page-name"/>    return serviceLocator;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public &lt;T&gt; void registerService(Class&lt;T&gt; interfaceType, String key, Object serviceObject) {<br class="title-page-name"/>    <br class="title-page-name"/>    Map&lt;String,Object&gt; serviceOfSameTypeMap = serviceRegistry.get(interfaceType);<br class="title-page-name"/>    if(serviceOfSameTypeMap !=null) {<br class="title-page-name"/>      serviceRegistry.get(interfaceType).put(key, serviceObject);<br class="title-page-name"/>    }else {<br class="title-page-name"/>      serviceOfSameTypeMap = new HashMap&lt;String,Object&gt;();<br class="title-page-name"/>      serviceOfSameTypeMap.put(key, serviceObject);<br class="title-page-name"/>      serviceRegistry.put(interfaceType, serviceOfSameTypeMap);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  public &lt;T&gt; T getSerivce(Class&lt;T&gt; interfaceType, String key) {<br class="title-page-name"/>    Map&lt;String,Object&gt; serviceOfSameTypeMap = serviceRegistry.get(interfaceType);<br class="title-page-name"/>    if(serviceOfSameTypeMap != null) {<br class="title-page-name"/>      T service = (T)serviceOfSameTypeMap.get(key);<br class="title-page-name"/>      if(service !=null) {<br class="title-page-name"/>        return service;<br class="title-page-name"/>      }else {<br class="title-page-name"/>        System.out.println(" Service with key "+ key +" does not exist");<br class="title-page-name"/>        return null;<br class="title-page-name"/>      }<br class="title-page-name"/>    }else {<br class="title-page-name"/>      System.out.println(" Service of type "+ interfaceType.toString() + " does not exist");<br class="title-page-name"/>      return null;<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">It is not mandatory to use the interface for registering the services, but it is good practice. In future, if any new service of the same interface is introduced or a completely new set of services of a brand new interface is introduced, they can be easily accommodated without affecting the client code.</p>
<p class="calibre2">Also, with an interface, client code is more generic and you can change the implementation just by changing the key, making the system more flexible and loosely coupled. Finally, the service locator is used in client code, as you can see in the following snippet:</p>
<pre class="calibre17">public class ServiceLocatorDemo {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    <br class="title-page-name"/>    ServiceLocator locator = ServiceLocator.getInstance();<br class="title-page-name"/>    initializeAndRegisterServices(locator);<br class="title-page-name"/>    CompressionAlgorithm rarCompression = locator.getSerivce(CompressionAlgorithm.class, "rar");<br class="title-page-name"/>    rarCompression.doCompress();<br class="title-page-name"/>    <br class="title-page-name"/>    CompressionAlgorithm zipCompression = locator.getSerivce(CompressionAlgorithm.class, "zip");<br class="title-page-name"/>    zipCompression.doCompress();<br class="title-page-name"/>    <br class="title-page-name"/>    EncryptionAlgorithm rsaEncryption = locator.getSerivce(EncryptionAlgorithm.class, "rsa");<br class="title-page-name"/>    rsaEncryption.doEncryption();<br class="title-page-name"/>    <br class="title-page-name"/>    EncryptionAlgorithm aesEncryption = locator.getSerivce(EncryptionAlgorithm.class, "aes");<br class="title-page-name"/>    aesEncryption.doEncryption();<br class="title-page-name"/> }<br class="title-page-name"/>  <br class="title-page-name"/>  <br class="title-page-name"/>  private static void initializeAndRegisterServices( ServiceLocator locator ) {<br class="title-page-name"/>    <br class="title-page-name"/>    CompressionAlgorithm rarCompression = new RARCompression();<br class="title-page-name"/>    CompressionAlgorithm zipCompression = new ZIPCompression();<br class="title-page-name"/>    EncryptionAlgorithm rsaEncryption = new RSAEncrption();<br class="title-page-name"/>    EncryptionAlgorithm aesEncryption = new AESEncrption();<br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/>    locator.registerService(CompressionAlgorithm.class, "rar", rarCompression);<br class="title-page-name"/>    locator.registerService(CompressionAlgorithm.class, "zip", zipCompression);<br class="title-page-name"/>    locator.registerService(EncryptionAlgorithm.class, "rsa", rsaEncryption);<br class="title-page-name"/>    locator.registerService(EncryptionAlgorithm.class, "aes", aesEncryption);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The service locator decouples the classes from their dependencies. The direct benefit of this arrangement is that the dependency can be replaced with little or (ideally) no code change. This way, the service locator pattern inverts the flow of control from the client code to the locator component. This is how IoC is implemented. </p>
<div class="packt_tip">In the service locator pattern, you need to make sure that all services are readily available before your objects start consuming it.</div>
<p class="calibre2">At first glance, it looks like the factory method pattern and service locator pattern work similarly. However, there are a few differences, as follows:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Construction cost:</strong> If the class instantiation process inside the factory method is very expensive (in terms of resource consumption), then creating a new object in the factory method will result in performance issues. In short, the cost of construction in the factory method may impact overall system performance. In the service locator pattern, all of the dependency objects are created (ideally) during the application startup. The client can get the dependency service from a pre-instantiated registry.</li>
<li class="calibre10"><strong class="calibre1">Existing versus new objects:</strong> Sometimes, you need same object every time. <span>In the factory method pattern, we are returning a new instance every time, while the service locator pattern returns an existing instance of the dependency service to the caller. </span></li>
<li class="calibre10"><strong class="calibre1">Ownership:</strong> Since the factory class returns a fresh new instance to the caller, the ownership lies with the caller class, whereas the service locator <span>locates and returns an existing instance of the service, and so the ownership of the returned objects would be with the service locator.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The template method pattern</h1>
                
            
            <article>
                
<p class="calibre2">The template method pattern involves defining the common structure of an algorithm, and then allowing subclasses to change or redefine some portion of the algorithm without changing the complete structure. <span class="calibre11">In other words, the template method pattern defines a function in a set of operations, allowing subclasses to redefine a few steps without altering the complete structure.</span></p>
<p class="calibre2">In this pattern, the base class declares the generic procedure with placeholders and lets subclasses provide the specific implementations of those placeholders while keeping the overall structure unchanged.</p>
<p class="calibre2">Let's understand the template method pattern with an example. Suppose you are writing a program to take row data, validate it, format it, and insert it into a database. Initially, the row data is provided in a CSV file, so you have created a class called <kbd class="calibre12">ProcessCSVData</kbd>. This class contains the logic for the following steps:</p>
<ol class="calibre14">
<li value="1" class="calibre10">Reading the CSV file</li>
<li value="2" class="calibre10">Validating data</li>
<li value="3" class="calibre10">Formatting data</li>
<li value="4" class="calibre10">Inserting the data into the database</li>
</ol>
<p class="calibre2">A year later, a few more formats of raw data are introduced, such as HTML, XML, text, and Excel. For each of these formats, if you a create separate class, you will end up having lots of similar code. It is obvious that each of these classes is quite different in file formats, while their other logic of data validation, formation, and insertion into the database is identical among them.</p>
<p class="calibre2">Think about the client code where these classes are used. You need to provide lots of <kbd class="calibre12">if...else</kbd> conditions to choose a specific implementation. This is not a good design. To achieve reusability, it is essential to get rid of code duplication and make the algorithm structure unbroken. If all of these classes are sharing a common base class, this problem can be solved by using polymorphism.</p>
<p class="calibre2">To implement the template method pattern, you need to identify which steps of the algorithm are common and which are variants or customizable in nature. The common steps should be implemented in the base class, while the variant steps should be placed in the base class with either the default implementation or no implementation at all. The variant steps will be considered as placeholder or extension points that must be supplied by a concrete-derived class.</p>
<p class="calibre2">In our example, reading data from a file is the only varying step, so we will keep it in the base class with default (or no) implementation in the method. This is considered as a template method. All concrete subclasses must provide implementations of this template method (reading the file from the respective formats). Other steps, such as validating, formatting, and inserting into the database, are common or invariant, so keep them in the base class as is. This implementation is described by the following diagram:</p>
<div class="mce-root"><img src="../images/00057.jpeg" class="calibre41"/></div>
<p class="calibre2">The following code snippet represents this implementation:</p>
<pre class="calibre17">public abstract class ProcessData {<br class="title-page-name"/>  //Template method<br class="title-page-name"/>  public abstract void readFile(); <br class="title-page-name"/>  public void validate() {<br class="title-page-name"/>    System.out.println(" Validating data ..");<br class="title-page-name"/>  }<br class="title-page-name"/>  public void format() {<br class="title-page-name"/>    System.out.println(" Formatting data ..");<br class="title-page-name"/>  }<br class="title-page-name"/>  public void insertInDB() {<br class="title-page-name"/>    System.out.println(" Inserting data into Database ..");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The implementation's subclasses should look as follows:</p>
<pre class="calibre17">public class ProcessExcelData extends ProcessData{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void readFile() {<br class="title-page-name"/>    System.out.println(" Reading Excel file");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ProcessHTMLData extends ProcessData{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void readFile() {<br class="title-page-name"/>    System.out.println(" Reading HTML file");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ProcessTEXTData extends ProcessData{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void readFile() {<br class="title-page-name"/>    System.out.println(" Reading Text file");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class ProcessXMLData extends ProcessData{<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void readFile() {<br class="title-page-name"/>    System.out.println(" Reading Excel file");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, the client code that uses the template method should look as follows:</p>
<pre class="calibre17">public class TemplateDemo {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String args[]) {<br class="title-page-name"/>    <br class="title-page-name"/>    ProcessData processData = new ProcessExcelData();<br class="title-page-name"/>    processData.readFile();<br class="title-page-name"/>    processData.validate();<br class="title-page-name"/>    processData.format();<br class="title-page-name"/>    processData.insertInDB();<br class="title-page-name"/>    <br class="title-page-name"/>    processData = new ProcessHTMLData();<br class="title-page-name"/>    processData.readFile();<br class="title-page-name"/>    processData.validate();<br class="title-page-name"/>    processData.format();<br class="title-page-name"/>    processData.insertInDB();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have used just two subclasses in client code. Similarly, you can use the remaining two subclasses. You will get the following output:</p>
<pre class="calibre17"> Reading Excel file<br class="title-page-name"/> Validating data ..<br class="title-page-name"/> Formatting data ..<br class="title-page-name"/> Inserting data into Database ..<br class="title-page-name"/> Reading HTML file<br class="title-page-name"/> Validating data ..<br class="title-page-name"/> Formatting data ..<br class="title-page-name"/> Inserting data into Database ..</pre>
<p class="calibre2">The template method pattern allows the framework to define invariant pieces of the program and to specify the hook or placeholder for all possible customization options. This way, the framework becomes the center point of the product, while the customization is considered as an additional capability or add-on on top of the core functionality.</p>
<p class="calibre2">The customization written for each of the template methods will get common functionalities from a generic framework or component. In other words, each client's customization receives the flow of control from the generic framework. The inverted control mechanism has been affectionately named <span class="calibre11">the Hollywood Principle – "do not call us, we will call you". </span>This is how IoC is achieved through the template method pattern. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The strategy pattern</h1>
                
            
            <article>
                
<p class="calibre2">The strategy<span class="calibre11"> pattern defines a set of algorithms, encapsulates each of them, and makes them interchangeable at runtime. This pattern lets the implementation vary independently from the clients that use it. In short, you can </span><span class="calibre11">change the output of a class by changing the algorithm at runtime. The strategy pattern focuses on creating an interface with different implementations that follows the same behavioral contract. </span></p>
<p class="calibre2">Let's understand this pattern with an example. Suppose you are developing an application to upload documents into the cloud. Initially, you have been provided with a Google Drive upload. You probably wrote the <kbd class="calibre12">GoogleDriveCloud</kbd> class and put all of the logic in that.</p>
<p class="calibre2">At a later stage, you decided to support uploading documents on a few more cloud platforms, such as Dropbox, OneDrive, and Amazon S3. At this moment in time, you write separate classes for each of them, such as <kbd class="calibre12">DropboxCloud</kbd>, <kbd class="calibre12">OneDriveCloud</kbd>, and <kbd class="calibre12">AmazoneS3Cloud</kbd>.</p>
<p class="calibre2">All of these classes are used to upload documents onto the respective cloud. When you use them in your code, you will probably write the code to choose a specific implementation based on some condition.</p>
<p class="calibre2">In the preceding case, the <kbd class="calibre12">CloudUpload</kbd> class is tightly coupled with each of the cloud implementations, which is not a good design. You can think about the problems when you try to accommodate more cloud support in future. Every new implementation requires a change to the <kbd class="calibre12">CloudUpload</kbd> class. This is a clear violation of the open-closes principle: which talks about <strong class="calibre4">open for extension but closed for modification</strong>.</p>
<p class="calibre2">This situation can be mitigated with the strategy pattern. The pattern involves <span class="calibre11">defining a set of related algorithms (implementations of various cloud platforms) and encapsulating them in classes that are separate from the host class (</span><kbd class="calibre12">CloudUpload</kbd><span class="calibre11">). The solution is described with the following diagram:</span></p>
<div class="mce-root"><img src="../images/00058.gif" class="calibre41"/></div>
<p class="calibre2">The implementation of the preceding diagram will look as follows:</p>
<pre class="calibre17">//Interface<br class="title-page-name"/>public interface Cloud {<br class="title-page-name"/>  void upload();<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Algorithm<br class="title-page-name"/>public class GoogleDriveCloud implements Cloud {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void upload() {<br class="title-page-name"/>    System.out.println(" Uploading on Google Drive ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Algorithm<br class="title-page-name"/>public class DropboxCloud implements Cloud {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void upload() {<br class="title-page-name"/>    System.out.println(" Uploading on Dropbox ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Algorithm<br class="title-page-name"/>public class OneDriveCloud implements Cloud {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void upload() {<br class="title-page-name"/>    System.out.println(" Uploading on OneDrive ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>//Concrete Algorithm<br class="title-page-name"/>public class AmazoneS3Cloud implements Cloud {<br class="title-page-name"/>  @Override<br class="title-page-name"/>  public void upload() {<br class="title-page-name"/>    System.out.println(" Uploading on Amazone S3 ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We have declared an interface called <kbd class="calibre12">Cloud</kbd>, which will be implemented by each concrete class. The  <kbd class="calibre12">CloudUpload</kbd> class represents a <kbd class="calibre12">Context</kbd> class. It holds the reference to <kbd class="calibre12">Cloud</kbd>, which is supplied through a constructor which is as follows:</p>
<pre class="calibre17">public class CloudUpload {<br class="title-page-name"/>  private final Cloud cloud;<br class="title-page-name"/>  public CloudUpload(Cloud cloud) {<br class="title-page-name"/>    this.cloud = cloud;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void upload() {<br class="title-page-name"/>    this.cloud.upload();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">In this design, each cloud implementation class has the logic of uploading a document to that particular cloud only, obeying the <strong class="calibre4">single responsibility</strong> principle. The <kbd class="calibre12">CloudUpload</kbd> class does not have a direct reference to any concrete class, but a reference of type <kbd class="calibre12">Cloud</kbd>, which holds the actual implementation. In this case, we are following this principle: <strong class="calibre4">program to an interface, not implementation</strong>.</p>
<p class="calibre2">After applying the strategy pattern, you may now upload the document by creating an object of the <kbd class="calibre12">CloudUpload</kbd> class and passing the appropriate implementation in the constructor, as in the following snippet:</p>
<pre class="calibre17">public class StrategyDemo {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    CloudUpload googleCloud = new CloudUpload(new GoogleDriveCloud());<br class="title-page-name"/>    googleCloud.upload();<br class="title-page-name"/>    CloudUpload dropBpxCloud = new CloudUpload(new DropboxCloud());<br class="title-page-name"/>    dropBpxCloud.upload();<br class="title-page-name"/>    CloudUpload oneDriveCloud = new CloudUpload(new OneDriveCloud());<br class="title-page-name"/>    oneDriveCloud.upload();<br class="title-page-name"/>    CloudUpload amazoneS3Cloud = new CloudUpload(new AmazoneS3Cloud());<br class="title-page-name"/>    amazoneS3Cloud.upload();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre11">In case of additional cloud implementation support in future, there is no change to the <kbd class="calibre12">CloudUpload</kbd> class. Unit testing becomes straightforward and easy. The <kbd class="calibre12">CloudUpload</kbd> class simply knows what to do with the strategy classes (the <kbd class="calibre12">Cloud</kbd> implementation) instead of putting conditional blocks to choose a specific implementation.</span></p>
<p class="calibre2"><span class="calibre11">This way, the strategy pattern helps us to achieve pluggable behavior. The logic of choosing the <kbd class="calibre12">Cloud</kbd> implementation is now shifted from the <kbd class="calibre12">CloudUpload</kbd> class. This is how IoC is achieved with the help of the strategy pattern. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Configuration styles</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">Almost all IoC containers allow you to choose either code or file-based (XML) configuration for declaring dependencies. Although they serve the same purpose, you might feel confused as to which option is best for the given scenario. </span></p>
<p class="calibre2">For instance, file-based (mainly XML) configuration is appropriate for the applications that need deployment to multiple environments. On the other hand, there are specific scenarios where code-based configuration is chosen over file-based configuration. Identifying the difference between these two will help you choose which one is right for you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">File-based (XML) versus code-based configuration</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">The benefit of XML-based configuration is that you can alter dependencies without recompiling, building, and deploying the application code. This sounds useful in a situation where you need to swap the dependencies of the same type. But again, is this really what you are looking for? In other words, if you do not have the requirements for changing the implementation of dependencies on the fly at runtime, then file-based configuration is not that useful.</span></p>
<p class="calibre2">On the downside, f<span class="calibre11">ile-based configuration is generally more difficult to read and analyze, especially when it becomes large and clumsy.</span> XML-based configuration does not warn you about any errors at compile time. Such errors can only be picked up at runtime, and they are quite tricky and time-consuming to fix. On the other hand, code-based configuration supports compile-time error checking. This means that if the build is successful, you are done and will not get any surprises at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injection using the setter method versus the constructor</h1>
                
            
            <article>
                
<p class="calibre2">There are two straightforward options of <span class="calibre11"><span class="calibre11">DI</span></span> – setter- or constructor-based DI. Both of these methods perform the same operation—injecting dependencies—but at different times of the object's lifespan. One happens during object instantiation, while the other happens on calling the setter method explicitly.</p>
<p class="calibre2">A very obvious dilemma comes into the picture when you implement DI with these two options. Understanding the difference is important because it reflects the basic problem of the object-oriented programming context: do we initiate the field variable with the constructor argument or through the setter method?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor-based DI</h1>
                
            
            <article>
                
<p class="calibre2">Passing dependencies with a constructor is more clear in terms of describing what is required to create an object. You may write multiple versions of constructors, each taking a different combination of dependency objects, if that is allowed.</p>
<p class="calibre2">Alongside initializing fields with the constructor, you can hide them by not providing a setter method. The advantage of this arrangement is that you can make sure the dependencies being set through the constructor will be available for the lifespan of an object. This is important, because if you do not want a particular dependency to be changed with the birth of an object, then initializing it with the constructor and not providing a setter will make it immutable. A constructor-based DI will decide the <span class="calibre11"><span class="calibre11">DI</span></span> order while loading the context.</p>
<p class="calibre2">Passing the dependencies through the constructor will manage the order of the object creation graph and will eventually reduce the risk of circular dependency. Conversely, for constructor-based DI, Spring does not allow you to create a proxy with the <span class="calibre11"><strong class="calibre4">Code Generation Library</strong> </span>(<strong class="calibre4"><span class="calibre11">CGLIB</span></strong>). You need to use either an interface-based proxy or a no-argument constructor.</p>
<p class="calibre2">You should choose the approach of passing dependencies into a constructor as your default preference. Ideally, all active/mandatory dependencies must be passed through a constructor. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setter-based DI</h1>
                
            
            <article>
                
<p class="calibre2">The basic idea behind setter-based DI is that once the object is created (mainly with no argument constructors), a setter can be called to supply the dependencies to form an object graph, or just to supply the mock object for testing purposes.</p>
<p class="calibre2">Constructor-based DI is appropriate if there are only a couple of constructor parameters. If there are lots of constructor parameters, it will look messy. Even multiple versions of a constructor will not help much. In this case, you should rely on setter-based DI.</p>
<p class="calibre2">Ideally, all optional or conditional dependencies should be supplied through setter-based DI. The drawback to this approach is that you should make sure the setter methods are called before a client object starts using it. Another risk in using the setter method is that the dependency being altered at a later part of execution will result in an unexpected or ambiguous result, which is sometimes hard to trace. Also, if configuration is not done properly with the setter approach, you may end up with a circular dependency, which you could face at runtime.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Circular dependency</h1>
                
            
            <article>
                
<p class="calibre2">A circular or cyclic dependency is a situation where two or more independent modules or components rely on each other to function properly. This is referred to as mutual recursion. Circular dependency generally occurs in a modular framework while defining a dependency between modules or components.</p>
<p class="calibre2">The term circular dependency is very common across domain models where a set of objects are associated with each other. Circular dependencies between<span class="calibre11"> </span>classes<span class="calibre11"> are</span> not necessarily harmful. In fact, in particular situations, they are appropriate. Take an example of an application where you are dealing with domain objects such as a student and a course. You probably need a <kbd class="calibre12">Student</kbd> class that gets courses a student has enrolled in, and a <kbd class="calibre12">Course</kbd> class that gets a list of students enrolled on that course. It is clear that the <kbd class="calibre12">Student</kbd> and the <kbd class="calibre12">Course</kbd> classes are interdependent, but if circular dependency is required in this case, then taking a chance to remove it may introduce some other problems.</p>
<p class="calibre2"><span class="calibre11">In a software design context, circular dependency between software components or modules produces a negative effect and is hence considered a bad practice. This is probably a design issue. </span>Generally, a software design with a poorly managed dependency is harder to maintain than one with a clear and layered module structure. While designing the system in a modular fashion, you need to keep in mind the problems that occur, especially due to circular dependency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Problems of circular dependency</h1>
                
            
            <article>
                
<p class="calibre2">Circular dependency can create many redundant effects in software programs. The very first among them in terms of design is the<span class="calibre11"> </span>tight coupling<span class="calibre11"> between </span>mutually dependent modules, which results in reusing an individual module becoming more difficult or impossible. <span class="calibre11">In general, there are several reasons why you should avoid circular references between objects. It</span> creates the following problems:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">No dependency hierarchy and no reusability:</strong> Generally, we quantify the code with the layer it is at; for example, high level, low level, and so on. Every layer should only set a dependency (if any) on the layers below it. <span>Normally, when you define dependency between modules, a dependency graph or hierarchy will be created, but in the case of a circular dependency situation, this will be eradicated. This means that there is no dependency hierarchy. For example, say you have the following dependency hierarchy:</span>
<ul class="calibre62">
<li class="calibre10">Module A depends on module B</li>
<li class="calibre10">Module B depends on module C</li>
<li class="calibre10">Assume that, at present, module C has no dependencies</li>
</ul>
</li>
</ul>
<p class="calibre74">Based on this arrangement, we can identify module A as the top level, module B as somewhere in the middle level, and module C as the lower level of the hierarchy. Let's say that, after some time, we need to make module C dependent on module A (for whatever reason).</p>
<p class="calibre74">When this happens, there is n<span class="calibre11">o more differentiation between the high, middle, and low levels, which means that there is no longer a hierarchy. All modules are at the same level. Also, since they are in a circular dependency, they are no longer independent. This situation forms a single giant virtual module, which is divided into interdependent pieces. You cannot use any of them independently. </span></p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Changing replication:</strong> Circular dependency creates a ripple effect of changes. For example, if any change happens in one module, this may impact other modules, which results in undesirable effects on the overall software architecture, such as compilation errors, and logical program errors. Due to its nature, circular dependency may create other unpredictable issues, such as endless recursion.</li>
<li class="calibre10"><strong class="calibre1">Readability and maintainability:</strong> Code that has a circular reference is naturally harder to understand and read than code that doesn't have a circular reference. Such code is intrinsically delicate and easy to breach. Ensuring that your code is free from circular dependencies will make the code easy to work with and make the code be able to accommodate changes with ease, resulting in easy maintenance. From a unit testing point of view, code that has a circular dependency is more difficult to test since it can't be isolated.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Causes and solutions</h1>
                
            
            <article>
                
<p class="calibre2">As we have already seen, circular dependency mostly occurs as a result of bad design/coding practice. In large software application development, the coders may deviate from the context and produce a circular reference.</p>
<p class="calibre2">To overcome this, you can take the help of various tools to find unwanted circular dependencies. This should be an ongoing activity and be applied from the beginning of the development cycle. For example, Eclipse has a plugin called Java Dependency Viewer, which will help to see the dependency between classes and Java packages. </p>
<p class="calibre2">Issues of circular dependency can be addressed by following certain patterns and principles, which are discussed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The single responsibility principle</h1>
                
            
            <article>
                
<p class="calibre2">Let's understand how circular dependency can be eliminated by applying the single responsibility principle. Let's assume you are following three modules in a system:</p>
<ul class="calibre9">
<li class="calibre10">Salary module</li>
<li class="calibre10">Employee module</li>
<li class="calibre10">HR module</li>
</ul>
<p class="calibre2">The <strong class="calibre4">Salary module</strong> generates salary and sends it over email. Generating salary depends upon the <strong class="calibre4">Employee module</strong>. To get a few details, such as the appraisal process, and reward points the <strong class="calibre4">Employee module</strong> depends upon the HR module. At this moment, the dependency hierarchy will be as shown in the following diagram:</p>
<div class="mce-root"><img src="../images/00059.gif" class="calibre75"/></div>
<p class="calibre2">At some point in time, let's say you need email functionality in the <strong class="calibre4">HR module</strong>. Since email functionality is present in the <strong class="calibre4">Salary module</strong>, you decide to give dependency of the <strong class="calibre4">Salary module</strong> to the <strong class="calibre4">HR module</strong>. At this moment, the dependency graph looks like the following diagram:</p>
<div class="mce-root"><img src="../images/00060.gif" class="calibre76"/></div>
<p class="calibre2">This situation forms a circular dependency. To avoid this, you need to follow the single responsibility principle. This principle states that a module or class should hold responsibility of a single part of the functionality. That module or class should take total ownership of that functionality and must be encapsulated entirely. All services provided by the module must not deviate from the main functionality.</p>
<p class="calibre2">In our case, the Salary module not only generates salary, but sends emails, too. This is a violation of the single responsibility principle. When a single module performs more than one responsibility, there's a chance of poor dependency management, which may result in either:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Code duplication:</strong> You may write similar and common functionalities in multiple modules. For example, in this case, you may write an email sending functionality in the HR module to avoid circular dependency, but will end up with code duplication, which raises maintenance problems later on.</li>
<li class="calibre10"><strong class="calibre1">Circular dependency:</strong> As we have seen in the preceding case.</li>
</ul>
<p class="calibre2">You need to write a separate module called the Utility module and put the email sending functionality in that. After you have refactored this code, both the <strong class="calibre4">HR module</strong> and the <strong class="calibre4">Salary module</strong> are now dependent on the Utility module. This is how circular dependency can be removed: by following the single responsibility principle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deferring the setting of a dependency from constructor to setter</h1>
                
            
            <article>
                
<p class="calibre2">Let's understand how solves circular dependency by providing a dependency from the constructor to the setter method. There is a special case where due to circular dependency, you can't even create the object of the domain model. For example, say you are developing an application for a <kbd class="calibre12">tyre</kbd> manufacturer; who uses these tyres for cars. Based on the car's max speed, you need to set the min rim size of the <kbd class="calibre12">tyre</kbd>. For this, you have created the <kbd class="calibre12">Car</kbd> and <kbd class="calibre12">Tyre</kbd> classes, as in the following snippet:</p>
<pre class="calibre17">public class Car {<br class="title-page-name"/>  private Tyre tyre;<br class="title-page-name"/>  private int maxSpeed;<br class="title-page-name"/><br class="title-page-name"/>  public Car(Tyre tyre) {<br class="title-page-name"/>    this.tyre = tyre;<br class="title-page-name"/>    setMaxSpeed(150);<br class="title-page-name"/>  }<br class="title-page-name"/>  public int getMaxSpeed() {<br class="title-page-name"/>    return maxSpeed;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setMaxSpeed(int maxSpeed) {<br class="title-page-name"/>    this.maxSpeed = maxSpeed;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>public class Tyre {<br class="title-page-name"/>  private Car car;<br class="title-page-name"/>  private int minRimSize;<br class="title-page-name"/>  <br class="title-page-name"/>  public Tyre(Car car) {<br class="title-page-name"/>    this.car = car;<br class="title-page-name"/>    if(this.car.getMaxSpeed()&gt;100 &amp;&amp; this.car.getMaxSpeed()&lt;200) {<br class="title-page-name"/>      setMinRimSize(15);<br class="title-page-name"/>    }else if(this.car.getMaxSpeed()&lt;100) {<br class="title-page-name"/>      System.out.println("Minimum RIM size is 14");<br class="title-page-name"/>      setMinRimSize(14);<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  public int getMinRimSize() {<br class="title-page-name"/>    return minRimSize;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setMinRimSize(int minRimSize) {<br class="title-page-name"/>    this.minRimSize = minRimSize;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">As you can see, the <kbd class="calibre12">Car</kbd> and <kbd class="calibre12">Tyre</kbd> classes are dependent on each another. The dependency is passed through the constructor, hence why it is a circular dependency. You can't create an object for either of them. To handle this situation, you need to defer setting the dependency from the constructor to the setter in each case. We decided to make this change in the <kbd class="calibre12">Car</kbd> class, as in the following snippet:</p>
<pre class="calibre17">public class Car{<br class="title-page-name"/>  private Tyre tyre;<br class="title-page-name"/>  private int maxSpeed;<br class="title-page-name"/>  <br class="title-page-name"/>  public Car() {<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setTyre(Tyre tyre) {<br class="title-page-name"/>    this.tyre = tyre;<br class="title-page-name"/>  }<br class="title-page-name"/>  public Tyre getTyre() {<br class="title-page-name"/>    return tyre;<br class="title-page-name"/>  }<br class="title-page-name"/>  public int getMaxSpeed() {<br class="title-page-name"/>    return maxSpeed;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setMaxSpeed(int maxSpeed) {<br class="title-page-name"/>    this.maxSpeed = maxSpeed;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">The dependency (of <kbd class="calibre12">Tyre</kbd>) is moved from the constructor to the setter method. In the <kbd class="calibre12">Tyre</kbd> class, you need to set a reference of the current class (<kbd class="calibre12">Tyre</kbd>) into the <kbd class="calibre12">Car</kbd> object, as in the following snippet:</p>
<pre class="calibre17">public class Tyre {<br class="title-page-name"/><br class="title-page-name"/>  private Car car;<br class="title-page-name"/>  private int minRimSize;<br class="title-page-name"/>  <br class="title-page-name"/>  public Tyre(Car car) {<br class="title-page-name"/>    this.car = car;<br class="title-page-name"/>    this.car.setTyre(this);<br class="title-page-name"/>    <br class="title-page-name"/>    if(this.car.getMaxSpeed()&gt;100 &amp;&amp; this.car.getMaxSpeed()&lt;200) {<br class="title-page-name"/>      System.out.println("Minimum RIM size is 15");<br class="title-page-name"/>      setMinRimSize(15);<br class="title-page-name"/>    }else if(this.car.getMaxSpeed()&lt;100) {<br class="title-page-name"/>      System.out.println("Minimum RIM size is 14");<br class="title-page-name"/>      setMinRimSize(14);<br class="title-page-name"/>    }<br class="title-page-name"/>    <br class="title-page-name"/>  }<br class="title-page-name"/>  public int getMinRimSize() {<br class="title-page-name"/>    return minRimSize;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void setMinRimSize(int minRimSize) {<br class="title-page-name"/>    this.minRimSize = minRimSize;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Everything is settled now. You can create an object of type <kbd class="calibre12">Car</kbd> first, then create an object of type <kbd class="calibre12">Tyre</kbd> so that you can pass the reference of the <kbd class="calibre12">car</kbd> object to it. The client code will be as in the following code snippet:</p>
<pre class="calibre17">public class CircularDependencyWithSetterDemo {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>      Car car = new Car();<br class="title-page-name"/>      car.setMaxSpeed(120);<br class="title-page-name"/>      Tyre tyre = new Tyre(car);<br class="title-page-name"/>      <br class="title-page-name"/>      car.setMaxSpeed(90);<br class="title-page-name"/>      tyre = new Tyre(car);<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Relocation of classes and packages</h1>
                
            
            <article>
                
<p class="calibre2">One of the possible reasons for circular dependency is a chain of dependencies starting from some classes in a Java package. Let's say that <kbd class="calibre12">com.packt.util</kbd> traverses with a different package and reaches some other class in the same package, <kbd class="calibre12">com.packt.util</kbd>. This is a package arrangement issue that can be solved by moving the classes and restructuring the packages. You can perform such refactoring activities with modern IDEs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Circular dependency in the Spring framework</h1>
                
            
            <article>
                
<p class="calibre2">Let's explore how circular dependency occurs in the Spring framework and how to deal with it. Spring provides an IoC container that loads all the beans and tries to create objects in a specific order so that they work properly. For example, say we have three beans with the following dependency hierarchy:</p>
<ul class="calibre9">
<li class="calibre10"><kbd class="calibre12">Employee</kbd> bean</li>
<li class="calibre10"><kbd class="calibre12">HRService</kbd><span> bean</span></li>
<li class="calibre10"><kbd class="calibre12">CommonUtilService</kbd><span> bean</span></li>
</ul>
<p class="calibre2">The <kbd class="calibre12">Employee</kbd> bean depends on the <kbd class="calibre12">HRService</kbd> bean, which depends on the <kbd class="calibre12">CommonUtilService</kbd> bean.</p>
<p class="calibre2">In this case, <kbd class="calibre12">CommonUtilService</kbd> is considered a low-level bean, while the Employee bean is considered a high-level bean. Spring will first create an object for all low-level beans so that it creates the <kbd class="calibre12">CommonUtilService</kbd> bean, then it will create the <kbd class="calibre12">HRService</kbd> bean (and inject the object of the <kbd class="calibre12">CommonUtilService</kbd> bean into it), and then it will create an object of the <kbd class="calibre12">Employee</kbd> bean (and inject the object of the <kbd class="calibre12">HRService</kbd> bean into it).</p>
<p class="calibre2">Now, you need to make the <kbd class="calibre12">CommonUtilService</kbd><strong class="calibre4"> </strong>bean dependent on the <kbd class="calibre12">Employee</kbd>.<strong class="calibre4"> </strong>This is circular dependency. Furthermore, all dependencies are set through a constructor.</p>
<p class="calibre2">In the case of circular dependency, the difference between high and low-level modules disappears. This means that Spring will be in a dilemma of which bean should be instantiated first, since they depend on each other. As a result, Spring will raise a<span class="calibre11"> </span><kbd class="calibre12">BeanCurrentlyInCreationException</kbd> error.</p>
<div class="packt_infobox">This will only happen in the case of constructor injection. If dependencies are set through the setter method, this problem will not occur, even if beans are interdependent. This is because at the time of context loading, no dependencies are present.</div>
<p class="calibre2">Let's create the code for this and see how Spring detects circular dependency. The code will be as follows:</p>
<pre class="calibre17">@Component("commonUtilService")<br class="title-page-name"/>public class CommonUtilService {<br class="title-page-name"/>  private Employee employee;<br class="title-page-name"/>  public CommonUtilService(Employee employee) {<br class="title-page-name"/>    this.employee = employee;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("employee")<br class="title-page-name"/>public class Employee {<br class="title-page-name"/>  private HRService hrService;<br class="title-page-name"/>  public Employee(HRService hrService) {<br class="title-page-name"/>    this.hrService=hrService;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("hrService")<br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  private CommonUtilService commonUtilService;<br class="title-page-name"/>  public HRService(CommonUtilService commonUtilService) {<br class="title-page-name"/>    this.commonUtilService=commonUtilService;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The Java config and client code will be as in the following snippet:</p>
<pre class="calibre17">@Configuration<br class="title-page-name"/>@ComponentScan(basePackages="com.packt.spring.circulardependency.model.simple")<br class="title-page-name"/>public class SpringConfig {<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class SpringCircularDependencyDemo {<br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>    ApplicationContext springContext = new AnnotationConfigApplicationContext(SpringConfig.class);<br class="title-page-name"/>    Employee employee = (Employee) springContext.getBean("employee");<br class="title-page-name"/>    HRService hrService = (HRService) springContext.getBean("hrService");<br class="title-page-name"/>    CommonUtilService commonUtilService = (CommonUtilService) springContext.getBean("commonUtilService");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">On running this code, you will get a <kbd class="calibre12">BeanCurrentlyInCreationException</kbd> error for all the beans, as follows:</p>
<pre class="calibre17">Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'employee' defined in file </pre>
<p class="calibre2">To avoid this situation, you need to redesign the preceding structure. In a few circumstances, it's not possible to change the structure, maybe due to design limitations of the legacy code. In this case, Spring provides some solutions, as follows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using setter/field injection over constructor injection</h1>
                
            
            <article>
                
<p class="calibre2">This is probably the most easy and straightforward option. In circular dependency, if constructor injection creates a circular reference, you can defer the DI in the setter method. This allows Spring to load a bean context without any issues. The updated code would be as follows:</p>
<pre class="calibre17">@Component("employee")<br class="title-page-name"/>public class Employee {<br class="title-page-name"/>  private HRService hrService;<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setHrService(HRService hrService) {<br class="title-page-name"/>    this.hrService = hrService;<br class="title-page-name"/>    System.out.println(" HRService dependency is set ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("hrService")<br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  private CommonUtilService commonUtilService;<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setCommonUtilService(CommonUtilService commonUtilService) {<br class="title-page-name"/>    this.commonUtilService = commonUtilService;<br class="title-page-name"/>    System.out.println(" CommonUtilService dependency is set ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("commonUtilService")<br class="title-page-name"/>public class CommonUtilService {<br class="title-page-name"/>  private Employee employee;<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  public void setEmployee(Employee employee) {<br class="title-page-name"/>    this.employee = employee;<br class="title-page-name"/>    System.out.println(" Employee dependency is set ");<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">All dependencies are set in the setter method with the <kbd class="calibre12">@Autowired</kbd> annotation. Spring will create instances of all three beans first and will then set them with the setter method.</p>
<div class="packt_infobox">Setting the <kbd class="calibre37">@Autowired</kbd> annotation on fields of the bean is equivalent to setter injection. If you annotate the fields of the class with the <kbd class="calibre37">@Autowired</kbd> annotation, Spring will not complain about circular dependency.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the @Lazy annotation</h1>
                
            
            <article>
                
<p class="calibre2">Another workaround is to use the <kbd class="calibre12">@Lazy</kbd> annotation. This annotation will instruct Spring to load the bean only when it is used, instead of at the time of context loading. Spring will create a proxy of the bean during context loading and will pass it into another object. The updated code will look as follows:</p>
<pre class="calibre17">@Component("employee")<br class="title-page-name"/>public class Employee {<br class="title-page-name"/>  private HRService hrService;<br class="title-page-name"/>  public Employee(@Lazy HRService hrService) {<br class="title-page-name"/>    this.hrService=hrService;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void displayEmployeeName() {<br class="title-page-name"/>    System.out.println(" Employee name is Nilang ");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("hrService")<br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  private CommonUtilService commonUtilService;<br class="title-page-name"/>  public HRService(@Lazy CommonUtilService commonUtilService) {<br class="title-page-name"/>    this.commonUtilService=commonUtilService;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Component("commonUtilService")<br class="title-page-name"/>public class CommonUtilService {<br class="title-page-name"/>  private Employee employee;<br class="title-page-name"/>  public CommonUtilService(@Lazy Employee employee) {<br class="title-page-name"/>    this.employee = employee;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void showEmployeeNameFromDependency() {<br class="title-page-name"/>    this.employee.displayEmployeeName();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The constructor dependencies are set through the <kbd class="calibre12">@Lazy</kbd> annotation. This code will run without any issue. The actual dependency is injected only when it's being called. To demonstrate this, the  <kbd class="calibre12">displayEmployeeName</kbd> method is created in the <kbd class="calibre12">Employee</kbd> bean, which we will call with the dependency reference from the <kbd class="calibre12">CommonUtilService</kbd> bean, as in the following snippet:</p>
<pre class="calibre17">ApplicationContext springContext = new AnnotationConfigApplicationContext(SpringConfigForLazy.class);<br class="title-page-name"/>    <br class="title-page-name"/>    Employee employee = (Employee) springContext.getBean("employee");<br class="title-page-name"/>    HRService hrService = (HRService) springContext.getBean("hrService");<br class="title-page-name"/>    CommonUtilService commonUtilService = (CommonUtilService) springContext.getBean("commonUtilService");<br class="title-page-name"/>    commonUtilService.showEmployeeNameFromDependency();</pre>
<p class="calibre2">When the <kbd class="calibre12">showEmployeeNameFromDependency</kbd> method is called, it will internally call the <kbd class="calibre12">displayEmployeeName</kbd> method on the employee reference in <kbd class="calibre12">CommonUtilService</kbd>. When this happens, Spring will actually inject the dependency. You will get the following output:</p>
<pre class="calibre17"> Employee name is Nilang </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Best practices and anti-patterns</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have talked about using IoC containers to achieve DI, but one of the most common mistakes is to use IoC containers without doing real DI. This may sound strange, but it is a fact. Such mistakes are possible in the absence of having a proper understanding of underlying concepts.</p>
<p class="calibre2"><span class="calibre11">Ideally, DI implementation should only reference the IoC container during the time of the application's startup. If a developer wraps the IoC container itself and passes it into other component to reduce any dependency, this is not a good design. Let's understand this issue with an example.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What to inject – the container itself or just dependencies?</h1>
                
            
            <article>
                
<p class="calibre2">The situation of injecting container occurs when you try to wrap the container itself either in a singleton class or a public static method to provide the dependency to other components or modules, as in the following snippet:</p>
<pre class="calibre17">public class AccountService {<br class="title-page-name"/>  //Service method.<br class="title-page-name"/>  public void getVariablePay() {<br class="title-page-name"/>    System.out.println("getting variable pay..");<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class HRService {<br class="title-page-name"/>  public int getLeaveInGivenMonth(int monthNo) {<br class="title-page-name"/>    System.out.println(" getting no of leaves for month "+monthNo);<br class="title-page-name"/>    return 2; // just for demo purpose.<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/>/* ServiceManager serves like dependency supplier */<br class="title-page-name"/>public class ServiceManager {<br class="title-page-name"/>  private static ApplicationContext springContext = new ClassPathXmlApplicationContext("application-context.xml");<br class="title-page-name"/> private ServiceManager() {<br class="title-page-name"/>  }<br class="title-page-name"/>  //This method will return the dependency <br class="title-page-name"/>  public static Object getDependentService(String serviceName) {<br class="title-page-name"/>    Object dependency = null;<br class="title-page-name"/>    if(springContext !=null) {<br class="title-page-name"/>      dependency = springContext.getBean(serviceName);<br class="title-page-name"/>    }<br class="title-page-name"/>    return dependency;<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class EmployeeService {<br class="title-page-name"/>  private AccountService accountService;<br class="title-page-name"/>  private HRService hrService;<br class="title-page-name"/>  //constructor<br class="title-page-name"/>  public EmployeeService() {<br class="title-page-name"/>    if(ServiceManager.getDependentService("accountService") !=null) {<br class="title-page-name"/>      accountService = (AccountService) ServiceManager.getDependentService("accountService");<br class="title-page-name"/>    }<br class="title-page-name"/>    if(ServiceManager.getDependentService("hrService") !=null) {<br class="title-page-name"/>      hrService = (HRService) ServiceManager.getDependentService("hrService");<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>  public void generateRewardPoints() {<br class="title-page-name"/>    if(hrService !=null &amp;&amp; accountService !=null) {<br class="title-page-name"/>      int noOfLeaves = this.hrService.getLeaveInGivenMonth(8);<br class="title-page-name"/>      System.out.println("No of Leaves are : "+noOfLeaves);<br class="title-page-name"/>      this.accountService.getVariablePay();<br class="title-page-name"/>      //Some complex logic to generate rewards points based on variable  pay and total leave <br class="title-page-name"/>      //taken in given month.<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">This is equivalent to the service locator pattern. In this code, the<span class="calibre11"> </span><kbd class="calibre12">ServiceManager</kbd><span class="calibre11"> </span>class holds the reference of the container. It will return the dependency (services) through its static method. The <span class="calibre11"> </span><kbd class="calibre12">EmployeeService </kbd> class uses the<span class="calibre11"> </span><kbd class="calibre12">ServiceManager</kbd><span class="calibre11"> </span>to get its dependencies (<kbd class="calibre12">HRService</kbd> and <kbd class="calibre12">AccountService</kbd>). At first glance, this looks perfectly fine as we don't want the<span class="calibre11"> </span><kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> </span>to be tightly coupled with<span class="calibre11"> </span><kbd class="calibre12">HRService</kbd><span class="calibre11"> </span>and<span class="calibre11"> </span><kbd class="calibre12">AccountService</kbd>. </p>
<p class="calibre2">Though we removed the coupling of dependencies in the preceding code, this is not what we mean by DI.  The fundamental mistake in the preceding case is that instead of providing the dependency, we are relying on other classes to supply it. In reality, we are removing the dependency of one entity, but adding another. This is one of the classic examples of using an IoC container very badly and without implementing DI properly.</p>
<p class="calibre2">The<span class="calibre11"> </span><kbd class="calibre12">ServiceManager</kbd><span class="calibre11"> class </span>is a singleton class that supplies the dependencies with its static method. Instead of injecting <kbd class="calibre12">HRService</kbd><span class="calibre11"> </span>and<span class="calibre11"> </span><kbd class="calibre12">AccountService</kbd> into<span class="calibre11"> </span><kbd class="calibre12">EmployeeService</kbd>, we are relying on<span class="calibre11"> </span><kbd class="calibre12">SerivceManager</kbd><span class="calibre11"> </span>to provide the dependency. </p>
<p class="calibre2">You might argue that the preceding approach will replace multiple dependencies with a single class, and will effectively reduce the dependency. However, the benefits of DI are not 100% achieved. The design issue of being tightly dependent on<span class="calibre11"> </span><kbd class="calibre12">ServiceManager</kbd>  is unseen until any change happens in that class. For example, if you change the configuration of either the<span class="calibre11"> </span><kbd class="calibre12">HRManager</kbd><span class="calibre11"> </span>or<span class="calibre11"> </span><kbd class="calibre12">AccoutService</kbd><span class="calibre11"> </span>class, you need to change the code of<span class="calibre11"> </span><kbd class="calibre12">ServiceManager</kbd>. </p>
<p class="calibre2">Another side effect of this scenario is that things are not clear from a unit testing point of view. The benefit of DI is that just by looking at the constructor of the class, you should know what things are dependent on it so that you can inject the mock object very easily while doing unit testing.</p>
<p class="calibre2">The scenario in this case is the opposite. Ideally, the caller should supply the dependency, but in our case, the caller doesn't provide anything, while the component (<kbd class="calibre12">EmployeeService</kbd>) is getting the dependencies by using its own singleton class. The constructor of the<span class="calibre11"> </span><kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> </span>class will be empty and you probably won't determine its dependency until you refer to its source code thoroughly.</p>
<p class="calibre2">The preceding design is more of a service locator implementation. However, there are a few other limitations of the service locator, as follows:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Isolation: </strong> The services added into the registry are ultimately black boxes to the caller or client class. This results in a less reliable system as it would be difficult to identify and rectify the errors that occur in the dependency services.</li>
</ul>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Concurrency: </strong> The service locator has a unique registry of services, which may cause a performance bottleneck if it is accessed by concurrent components. </li>
<li class="calibre10"><strong class="calibre1">Dependency resolution:</strong> For the client code, the registry provided by the service locator is kind of a black box, and this may cause issues at runtime, for example, if dependencies are not yet registered, or there are any dependency-specific issues. </li>
<li class="calibre10"><strong class="calibre1">Maintainability:</strong> In the service locator, since the code of the service implementation is isolated from clients, it is unclear when the new changes will break this functionality at runtime.</li>
<li class="calibre10"><strong class="calibre1">Testability:</strong> The service locator stores all of the services in the registry, which makes unit testing a bit harder since all of the tests may rely on the registry to set various mock service classes explicitly.</li>
</ul>
<p class="calibre2">Our goal is to make the client code 100% decoupled from its dependencies or any class who supplies the dependencies. In the preceding case, we want to break the coupling between <kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> </span>and its dependencies.</p>
<p class="calibre2">Let's improve the preceding design and rewrite the<span class="calibre11"> </span><kbd class="calibre12">EmployeeSerice</kbd><span class="calibre11"> </span>class, as in the following snippet:</p>
<pre class="calibre17">public class EmployeeService {<br class="title-page-name"/>  private AccountService accountService;<br class="title-page-name"/>  private HRService hrService;<br class="title-page-name"/>  //constructor<br class="title-page-name"/>  public EmployeeService(AccountService accountService,HRService hrService) {<br class="title-page-name"/>    this.accountService = accountService;<br class="title-page-name"/>    this.hrService = hrService;<br class="title-page-name"/>  }<br class="title-page-name"/>  public void generateRewardPoints() {<br class="title-page-name"/>    if(hrService !=null &amp;&amp; accountService !=null) {<br class="title-page-name"/>      int noOfLeaves = this.hrService.getLeaveInGivenMonth(8);<br class="title-page-name"/>      System.out.println("No of Leaves are : "+noOfLeaves);<br class="title-page-name"/>      this.accountService.getVariablePay();<br class="title-page-name"/>      //Some complex logic to generate rewards points based on variable pay and total leave <br class="title-page-name"/>      //taken in given month.<br class="title-page-name"/>    }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, the<span class="calibre11"> </span><kbd class="calibre12">EmployeeService</kbd><span class="calibre11"> </span>class does not depend on the<span class="calibre11"> </span><kbd class="calibre12">HRService</kbd><span class="calibre11"> </span>and<span class="calibre11"> </span><kbd class="calibre12">AccountService</kbd><span class="calibre11"> </span>classes. This is what we wanted to achieve. Your business code should not know anything about its dependencies. It is the IoC container's job to provide them. This code is now more readable and easy to understand. The dependencies can be predicated just by looking at the constructor.</p>
<p class="calibre2">If you wish to instantiate<span class="calibre11"> </span><kbd class="calibre12">EmployeeService</kbd>, you just need to pass the object of the<span class="calibre11"> </span><kbd class="calibre12">HRService</kbd><span class="calibre11"> </span>and<span class="calibre11"> </span><kbd class="calibre12">AccountService</kbd><span class="calibre11"> </span>classes. While doing unit testing, you can just pass the mock objects and test the integration between these services. The process becomes very simple now. This is the correct implementation and meaning of DI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Excessive injection</h1>
                
            
            <article>
                
<p class="calibre2">Every design pattern solves specific design problems, but any single pattern is not necessarily appropriate for every case that you come across. <span class="calibre11">A pattern or methodology you are applying should be chosen because it is the right choice for the given problem, not just because you know it and wish to implement it.</span></p>
<p class="calibre2">Dependency injection is a pattern (and not a framework), so you need to consider the right scenario to implement it. There are chances that may make DI become redundant. It is not necessary to inject everything in your code. If you do so, the purpose of making the code decoupled is not achieved properly; instead, the dependency graph becomes ineffectual.</p>
<p class="calibre2">Evidently, DI produces great flexibility in terms of code maintenance, executing unit testing in a more meaningful and useful way to achieve modularity. However, you should utilize its flexibility only when you really need to. The intention of DI is to diminish coupling instead of wrapping and supplying every single dependency, which is not a wise decision.</p>
<p class="calibre2">For example, let's say that you need a <kbd class="calibre12">Calendar</kbd> object to perform various calendar-related operations. The traditional way is by using a static method - <kbd class="calibre12">getInstance</kbd> of the <kbd class="calibre12">Calendar</kbd> class, for example, <kbd class="calibre12">Calendar.getInstance()</kbd> . It is a kind of static factory within the <kbd class="calibre12">Calendar</kbd> class, which creates the object.</p>
<p class="calibre2">If you try to pass the <kbd class="calibre12">Calendar</kbd> object with DI, you will not achieve anything new. All of the methods in which the <kbd class="calibre12">Calendar</kbd> object is passed through (an entire call chain – from where it is injected to where it is used) will have additional arguments. This ultimately adds the burden of passing the <kbd class="calibre12">Calendar</kbd> object to the programmer. Also, the <kbd class="calibre12">Calendar</kbd> object is not injected with an abstraction, so the argument is of the <kbd class="calibre12">Calendar</kbd> type rather than any abstract or interface. This means that there is no clear benefit of changing the implementation because we are passing the dependency with the concrete type rather than the abstract type (because that is not possible for the <kbd class="calibre12">Calendar</kbd> class in Java).</p>
<p class="calibre2">Ideally, any Java, third library, or custom class that simply provides static functionality that can be common across all components or modules should be used either statically (class reference) or in a single instance mechanism (if an instance is required) instead of injecting them into classes.</p>
<p class="calibre2">Another example is using <kbd class="calibre12">Logger</kbd> in Java. A typical way of getting a logger instance is to call the <kbd class="calibre12">getLogger</kbd> static method of the <kbd class="calibre12">Logger</kbd> class and pass the class which you want to provide the logging feature of. In this case, passing the <kbd class="calibre12">Logger</kbd> object with DI would be overkill.</p>
<p class="calibre2">Not only that, but injecting such a library with DI would result in reducing the availability of functionalities available only to those components that take the dependencies either through a constructor, the method, or property injection. Also, there is almost no chance of providing any meaningful abstraction that can be easily applied to any such libraries. This will keep you from getting any meaningful flexibility over the implementation. </p>
<p class="calibre2">Choose DI patterns when you need to supply dependencies with different configurations of dependencies or when you want to back different implementations of the same dependency. If it is not required to mix up your dependencies or to supply different implementations, then DI is not an appropriate solution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Achieving IoC in the absence of a container</h1>
                
            
            <article>
                
<p class="calibre2">Now, we are well aware that DI is meant to provide the dependencies to components through either a constructor, the setter method, or properties to make them separate from dependency services. The conventional understanding is that this can only <span class="calibre11">be </span>possible by using IoC containers. However, this is not true for all cases.</p>
<p class="calibre2">Ideally, IoC containers should be used for configuring and resolving a comparatively large set of dependencies in complex applications. If you are dealing with a simple application that has just a few components and dependencies, it is sensible not to use containers. Instead, you can wire dependencies manually. </p>
<p class="calibre2">Also, in the case of any legacy system where the integration of a container is difficult, you can opt for supplying dependencies <span class="calibre11">manually. You can implement various patterns, such as the factory method, service locator, strategy, or template method patterns, to manage the dependencies.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We have learned a few important points about the best practices and patterns for managing dependencies in this chapter. Though it is proven that DI brings greater flexibility and modularity in the code by decoupling the client code from its dependencies, there are a few things that we should follow to get the best out of it. </p>
<p class="calibre2">In the beginning, we learned about patterns other than DI that help us to implement IoC. You can definitely use them in your code to decouple modules where the use of IoC containers is not possible. For example, in a legacy code where managing dependencies is not possible through an IoC container, these patterns are useful to achieve IoC.</p>
<p class="calibre2">We became familiar with various configuration options and learned how to choose the right one. We also saw the injection styles used in wiring the dependencies. When working with dependency management, one very obvious problem that occurs is circular reference, which causes circular dependency. We have observed what problems circular dependencies create, what the cause of them is, and how to avoid them in coding.</p>
<p class="calibre2">At the end, we dived into best practices, patterns, and anti-patterns that you should follow while using DI. If we know how to do something, it does not mean that it is applicable all the time. The same is applicable to DI. It is a pattern, and hence it should be used in the right manner to solve specific problems. It may not be suitable for all conditions.</p>
<p class="calibre2">We are taking a pause here. We hope you enjoyed the journey <span class="calibre11">of learning about DI throughout the book</span>. We tried to convey the fundamentals as simply as possible.</p>


            </article>

            
        </section>
    </body></html>