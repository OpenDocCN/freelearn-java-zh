<html><head></head><body>
		<div>
			<div id="_idContainer314" class="Content">
			</div>
		</div>
		<div id="_idContainer315" class="Content">
			<h1 id="_idParaDest-348"><a id="_idTextAnchor451"/>Appendix</h1>
		</div>
		<div id="_idContainer358" class="Content">
			<h2>About</h2>
			<p>This section is included to assist the students to perform the activities present in the book. It includes detailed steps that are to be performed by the students to complete and achieve the objectives of the book.</p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor452"/>1. Hello REPL!</h1>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor453"/>Activity 1.01: Performing Basic Operations</h2>
			<p>Solution:</p>
			<ol>
				<li>Open the REPL.</li>
				<li>Print the message <strong class="source-inline">"I am not afraid of parentheses"</strong> to motivate yourself:<p class="source-code">user=&gt; (println "I am not afraid of parentheses")</p><p class="source-code">I am not afraid of parentheses</p><p class="source-code">nil</p></li>
				<li>Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to the following <strong class="source-inline">infix</strong> notation: (1 + 2 + 3) * (10 - 3):<p class="source-code">user=&gt; (* (+ 1 2 3) (- 10 3))</p><p class="source-code">42</p></li>
				<li>Print the message <strong class="source-inline">"Well done!"</strong> to congratulate yourself:<p class="source-code">user=&gt; (println "Well done!")</p><p class="source-code">Well done!</p><p class="source-code">Nil</p></li>
				<li>Exit the REPL by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em> or typing the following command:<p class="source-code">user=&gt; (System/exit 0)</p></li>
			</ol>
			<p>By completing this activity, you have written code that prints a message to the standard output. You have also performed some mathematical operations using the <em class="italic">prefix</em> notation and nested expressions.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor454"/>Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Open your favorite editor and a REPL window next to it.</li>
				<li>In your editor, define two constants, <strong class="source-inline">base-co2</strong> and <strong class="source-inline">base-year</strong>, with the values 382 and 2006, respectively:<p class="source-code">(def base-co2 382)</p><p class="source-code">(def base-year 2006)</p></li>
				<li>In your editor, write the code to define the <strong class="source-inline">co2-estimate</strong> function without forgetting to document it with the <strong class="source-inline">doc-string</strong> parameter.</li>
				<li>You may be tempted to write the function body in a single line, but nesting a lot of function calls decreases the readability of the code. It is also easier to reason about each step of the process by decomposing them in a <strong class="source-inline">let</strong> block. Write the body of the function using <strong class="source-inline">let</strong> to define the local binding, <strong class="source-inline">year-diff</strong>, which is the subtraction of 2006 from the <strong class="source-inline">year</strong> parameter:<p class="source-code">(defn co2-estimate</p><p class="source-code"> "Returns a (conservative) year's estimate of carbon dioxide parts per million in the atmosphere"</p><p class="source-code"> [year]</p><p class="source-code"> (let [year-diff (- year base-year)]</p><p class="source-code">  (+ base-co2 (* 2 year-diff))))</p></li>
				<li>Test your function by evaluating <strong class="source-inline">(co2-estimate 2050)</strong>. You should get <strong class="source-inline">470</strong> as the result:<p class="source-code">user=&gt; (co2-estimate 2050)</p><p class="source-code">470</p></li>
				<li>Look up the documentation of your function with <strong class="source-inline">doc</strong> and make sure that it has been defined correctly:<p class="source-code">user=&gt; (doc co2-estimate)</p><p class="source-code">-------------------------</p><p class="source-code">user/co2-estimate</p><p class="source-code">([year])</p><p class="source-code">  Returns a (conservative) year's estimate of carbon dioxide parts per million in the atmosphere</p><p class="source-code">nil</p></li>
			</ol>
			<p>In this activity, we calculated the estimated level of CO2 parts per million for a given year.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor455"/>Activity 1.03: The meditate Function v2.0</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Open your favorite editor and a REPL window next to it.</li>
				<li>In your editor, define a function with the name <strong class="source-inline">meditate</strong>, taking two arguments, <strong class="source-inline">calmness-level</strong> and <strong class="source-inline">s</strong>, without forgetting to write its documentation.</li>
				<li>In the function body, start by writing an expression that prints the string, "<strong class="source-inline">Clojure Meditate v2.0</strong>":<p class="source-code">(defn meditate</p><p class="source-code">  "Return a transformed version of the string 's' based on the 'calmness-level'"</p><p class="source-code">  [s calmness-level]</p><p class="source-code">  (println "Clojure Meditate v2.0"))</p></li>
				<li>Following the specification, write the first condition to test whether the calmness level is strictly inferior to 5. Write the first branch of the conditional expression (the "then").</li>
				<li>Write the second condition, which should be nested in the second branch of the first condition (the "else").</li>
				<li>Write the third condition, which should be nested in the second branch of the second condition. It will check that <strong class="source-inline">calmness-level</strong> is exactly 10 and return the reverse of the <strong class="source-inline">s</strong> string when that is the case:<p class="source-code">(defn meditate</p><p class="source-code">  "Return a transformed version of the string 's' based on the 'calmness-level'"</p><p class="source-code">  [s calmness-level]</p><p class="source-code">  (println "Clojure Meditate v2.0")</p><p class="source-code">  (if (&lt; calmness-level 4)</p><p class="source-code">    (str (clojure.string/upper-case s) ", I TELL YA!")</p><p class="source-code">    (if (&lt;= 4 calmness-level 9)</p><p class="source-code">        (clojure.string/capitalize s)</p><p class="source-code">        (if (= 10 calmness-level)</p><p class="source-code">          (clojure.string/reverse s)))))</p></li>
				<li>Test your function by passing a string with different levels of calmness. The output should be similar to the following:<p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 1)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"WHAT WE DO NOW ECHOES IN ETERNITY, I TELL YA!"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 6)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"What we do now echoes in eternity"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 10)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">"ytinrete ni seohce won od ew tahw"</p><p class="source-code">user=&gt; (meditate "what we do now echoes in eternity" 50)</p><p class="source-code">Clojure Meditate v2.0</p><p class="source-code">nil</p><p>If you have been using the <strong class="source-inline">and</strong> operator to find out whether a number was between two other numbers, rewrite your function to remove it and only use the <strong class="source-inline">&lt;=</strong> operator. Remember that <strong class="source-inline">&lt;=</strong> can take more than two arguments.</p></li>
				<li>Look up the <strong class="source-inline">cond</strong> operator in the documentation and rewrite your function to replace the nested conditions with <strong class="source-inline">cond</strong>:<p class="source-code">user=&gt; (doc cond)</p><p class="source-code">-------------------------</p><p class="source-code">clojure.core/cond</p><p class="source-code">([&amp; clauses])</p><p class="source-code">Macro</p><p class="source-code">  Takes a set of test/expr pairs. It evaluates each test one at a</p><p class="source-code">  time.  If a test returns logical true, cond evaluates and returns</p><p class="source-code">  the value of the corresponding expr and doesn't evaluate any of the</p><p class="source-code">  other tests or exprs. (cond) returns nil.</p><p class="source-code">nil</p><p class="source-code">user=&gt; </p><p class="source-code">(defn meditate</p><p class="source-code">  "Return a transformed version of the string 's' based on the 'calmness-level'"</p><p class="source-code">  [s calmness-level]</p><p class="source-code">  (println "Clojure Meditate v2.0")</p><p class="source-code">  (cond</p><p class="source-code">    (&lt; calmness-level 4)  (str (clojure.string/upper-case s) ", I TELL YA!")</p><p class="source-code">    (&lt;= 4 calmness-level 9) (clojure.string/capitalize s)</p><p class="source-code">    (= 10 calmness-level) (clojure.string/reverse s)))</p></li>
			</ol>
			<p>By completing this activity, you have written a documented function that takes multiple parameters, prints a message, and conditionally returns a transformation of a string.</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor456"/>2. Data Types and Immutability</h1>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor457"/>Activity 2.01: Creating a Simple In-Memory Database</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">First, create the helper functions. You can get the Hash Map by executing the <strong class="source-inline">read-db</strong> function with no arguments, and write to the database by executing the <strong class="source-inline">write-db</strong> function with a Hash Map as an argument:<p class="source-code">user=&gt;</p><p class="source-code">(def memory-db (atom {}))</p><p class="source-code">#'user/memory-db</p><p class="source-code">(defn read-db [] @memory-db)</p><p class="source-code">#'user/read-db</p><p class="source-code">user=&gt; (defn write-db [new-db] (reset! memory-db new-db))</p><p class="source-code">#'user/write-db</p></li>
				<li>Start by creating the <strong class="source-inline">create-table</strong> function. This function should take one parameter: the table name. It should add a new key (the table name) at the root of our Hash Map database, and the value should be another Hash Map containing two entries – an empty vector at the <strong class="source-inline">data</strong> key and an empty Hash Map at the <strong class="source-inline">indexes</strong> key:<p class="source-code">user=&gt;</p><p class="source-code">(defn create-table</p><p class="source-code">  [table-name]</p><p class="source-code">  (let [db (read-db)]</p><p class="source-code">    (write-db (assoc db table-name {:data [] :indexes {}}))))</p><p class="source-code">#'user/create-table</p></li>
				<li>Test that your <strong class="source-inline">create-table</strong> function works. The output should be as follows:<p class="source-code">user=&gt; (create-table :clients)</p><p class="source-code">{:clients {:data [], :indexes {}}}</p><p class="source-code">user=&gt; (create-table :fruits)</p><p class="source-code">{:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}</p></li>
				<li>Let's create the next function: <strong class="source-inline">drop-table</strong>. The function should take one parameter as well: the table name. It should remove a table, including all its data and indexes from our database:<p class="source-code">user=&gt;</p><p class="source-code">(defn drop-table</p><p class="source-code">  [table-name]</p><p class="source-code">  (let [db (read-db)]</p><p class="source-code">    (write-db (dissoc db table-name))))</p><p class="source-code">#'user/drop-table</p></li>
				<li>Test that your <strong class="source-inline">drop-table</strong> function works. The output should be as follows: <p class="source-code">user=&gt; (create-table :clients)</p><p class="source-code">{:clients {:data [], :indexes {}}}</p><p class="source-code">user=&gt; (create-table :fruits)</p><p class="source-code">{:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}</p><p class="source-code">user=&gt; (drop-table :clients)</p><p class="source-code">{:fruits {:data [], :indexes {}}}</p></li>
				<li>Let's move on to the <strong class="source-inline">insert</strong> function. This function should take three parameters: <strong class="source-inline">table</strong>, <strong class="source-inline">record</strong>, and <strong class="source-inline">id-key</strong>. The <strong class="source-inline">record</strong> parameter is a Hash Map, and <strong class="source-inline">id-key</strong> corresponds to a key in the record map that will be used as a unique index. For example, inserting a record in the <strong class="source-inline">fruits</strong> table would look like this:<p class="source-code">user=&gt; (insert :fruits {:name "Pear" :stock 3} :name)</p><p class="source-code">{:fruits {:data [{:name "Pear", :stock 3}], :indexes {:name {"Pear" 0}}}}</p><p>For now, we will not handle cases where a table does not exist or when an index key already exists in a given table.</p><p>Try to use a <strong class="source-inline">let</strong> block to divide the work of the <strong class="source-inline">insert</strong> function into multiple steps.</p><p>In a <strong class="source-inline">let</strong> statement, create a binding for the value of the database, retrieved with <strong class="source-inline">read-db</strong>:</p><p class="source-code">(defn insert</p><p class="source-code">  [table-name record id-key]</p><p class="source-code">    (let [db (read-db)</p><p>In the same <strong class="source-inline">let</strong> statement, create a second binding for the new value of the database (after adding the record in the <strong class="source-inline">data</strong> vector):</p><p class="source-code">(defn insert</p><p class="source-code">  [table-name record id-key]</p><p class="source-code">    (let [db (read-db)</p><p class="source-code">          new-db (update-in db [table-name :data] conj record)</p><p>In the same <strong class="source-inline">let</strong> statement, retrieve the index at which the record was inserted by counting the number of elements in the <strong class="source-inline">data</strong> vector:</p><p class="source-code">(defn insert</p><p class="source-code">  [table-name record id-key]</p><p class="source-code">    (let [db (read-db)</p><p class="source-code">          new-db (update-in db [table-name :data] conj record)</p><p class="source-code">          index (- (count (get-in new-db [table-name :data])) 1)]</p><p>In the body of the <strong class="source-inline">let</strong> statement, update the index at <strong class="source-inline">id-key</strong> and write the resulting map to the database with <strong class="source-inline">write-db</strong>:</p><p class="source-code">user=&gt;</p><p class="source-code">(defn insert</p><p class="source-code">  [table-name record id-key]</p><p class="source-code">    (let [db (read-db)</p><p class="source-code">          new-db (update-in db [table-name :data] conj record)</p><p class="source-code">          index (- (count (get-in new-db [table-name :data])) 1)]</p><p class="source-code">      (write-db</p><p class="source-code">        (update-in new-db [table-name :indexes id-key] assoc (id-key record) index))))</p><p class="source-code">#'user/insert</p></li>
				<li>To verify that your <strong class="source-inline">insert</strong> function works, try to use it multiple times to insert new records. The output should look like this:<p class="source-code">user=&gt;  (insert :fruits {:name "Apricot" :stock 30} :name)</p><p class="source-code">{:fruits {:data [{:name "Pear", :stock 3} {:name "Apricot", :stock 30}], :indexes {:name {"Pear" 0, "Apricot" 1}}}}</p><p class="source-code">user=&gt;  (insert :fruits {:name "Grapefruit" :stock 6} :name)</p><p class="source-code">{:fruits {:data [{:name "Pear", :stock 3} {:name "Apricot", :stock 30} {:name "Grapefruit", :stock 6}], :indexes {:name {"Pear" 0, "Apricot" 1, "Grapefruit" 2}}}}</p></li>
				<li>Create a <strong class="source-inline">select-*</strong> function that will return all the records of a table passed as a parameter. Given the three preceding records, the output should be similar to this:<p class="source-code">user=&gt; (select-* :fruits)</p><p class="source-code">[{:name "Pear", :stock 3} {:name "Apricot", :stock 30} {:name "Grapefruit", :stock 6}]</p><p class="source-code">user=&gt;</p><p class="source-code">(defn select-*</p><p class="source-code">  [table-name]</p><p class="source-code">  (get-in (read-db) [table-name :data]))</p><p class="source-code">#'user/select-*</p></li>
				<li>Create a <strong class="source-inline">select-*-where</strong> function that takes three arguments: <strong class="source-inline">table-name</strong>, <strong class="source-inline">field</strong>, and <strong class="source-inline">field-value</strong>. The function should use the index map to retrieve the index of the record in the data vector and return the element. Given the three preceding records, the output should be similar to this:<p class="source-code">user=&gt; (select-*-where :fruits :name "Apricot")</p><p class="source-code">{:name "Apricot", :stock 30}</p><p class="source-code">user=&gt;</p><p class="source-code">(defn select-*-where</p><p class="source-code">  [table-name field field-value]</p><p class="source-code">  (let [db (read-db)</p><p class="source-code">        index (get-in db [table-name :indexes field field-value])</p><p class="source-code">        data (get-in db [table-name :data])]</p><p class="source-code">    (get data index)))</p><p class="source-code">#'user/select-*-where</p></li>
				<li>Modify the <strong class="source-inline">insert</strong> function to reject any index duplicate. When a record with <strong class="source-inline">id-key</strong> already exists in the <strong class="source-inline">indexes</strong> map, we should not modify the database and print an error message to the user. The output should be similar to this:<p class="source-code">user=&gt;  (insert :fruits {:name "Pear" :stock 3} :name)</p><p class="source-code">Record with :name Pear already exists. Aborting</p><p class="source-code">user=&gt; (select-* :fruits)</p><p class="source-code">[{:name "Pear", :stock 3} {:name "Apricot", :stock 30} {:name "Grapefruit", :stock 6}]</p><p class="source-code">user=&gt;</p><p class="source-code">(defn insert</p><p class="source-code">  [table-name record id-key]</p><p class="source-code">  (if-let [existing-record (select-*-where table-name id-key (id-key record))]</p><p class="source-code">    (println (str "Record with " id-key ": " (id-key record) " already exists.       Aborting"))</p><p class="source-code">    (let [db (read-db)</p><p class="source-code">          new-db (update-in db [table-name :data] conj record)</p><p class="source-code">          index (- (count (get-in new-db [table-name :data])) 1)]</p><p class="source-code">      (write-db</p><p class="source-code">        (update-in new-db [table-name :indexes id-key] assoc (id-key record)           index)))))</p><p class="source-code">#'user/insert</p><p>The final output should be similar to this:</p><p class="source-code">user=&gt; (create-table :fruits)</p><p class="source-code">{:clients {:data [], :indexes {}}, :fruits {:data [], :indexes {}}}</p><p class="source-code">user=&gt; (insert :fruits {:name "Pear" :stock 3} :name)</p><p class="source-code">Record with :name Pear already exists. Aborting</p><p class="source-code">user=&gt; (select-* :fruits)</p><p class="source-code">[{:name "Pear", :stock 3} {:name "Apricot", :stock 30} {:name "Grapefruit", :stock 6}]</p><p class="source-code">user=&gt; (select-*-where :fruits :name "Apricot")</p><p class="source-code">{:name "Apricot", :stock 30}</p></li>
			</ol>
			<p>In this activity, we have used our new knowledge about reading and updating both simple and deeply nested data structures to implement a simple in-memory database.</p>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor458"/>3. Functions in Depth</h1>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor459"/>Activity 3.01: Building a Distance and Cost Calculator</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Start by defining the <strong class="source-inline">walking-speed</strong> and <strong class="source-inline">driving-speed</strong> constants:<p class="source-code"> (def walking-speed 4)</p><p class="source-code">(def driving-speed 70)</p></li>
				<li>Create two other constants representing two locations with the coordinates <strong class="source-inline">:lat</strong> and <strong class="source-inline">:lon</strong>. You can use the previous example with Paris and Bordeaux or look up your own. You will be using them to test your distance and itinerary functions:<p class="source-code"> (def paris {:lat 48.856483 :lon 2.352413})</p><p class="source-code">(def bordeaux {:lat 44.834999  :lon -0.575490})</p></li>
				<li>Create the distance function. It should take two parameters representing the two locations for which we need to calculate the distance. You can use a combination of sequential and associative destructuring right in the function parameters to disassemble the latitude and longitude from both locations. You can decompose the steps of the calculation in a <strong class="source-inline">let</strong> expression and use the <strong class="source-inline">Math/cos</strong> function to calculate the cosine and <strong class="source-inline">Math/sqrt</strong> to calculate the square root of a number:<p class="source-code"> (defn distance</p><p class="source-code">  "Returns a rough estimate of the distance between two coordinate points, in     kilometers. Works better with smaller distance"</p><p class="source-code">  [{lat1 :lat lon1 :lon} {lat2 :lat lon2 :lon}]</p><p class="source-code">  (let [deglen 110.25</p><p class="source-code">        x (- lat2 lat1)</p><p class="source-code">        y (* (Math/cos lat2) (- lon2 lon1))]</p><p class="source-code">    (* deglen (Math/sqrt (+ (* y y) (* x x))))))</p></li>
				<li>Create a multimethod called <strong class="source-inline">itinerary</strong>. It will offer the flexibility of adding more types of transport in the future. It should use the value at <strong class="source-inline">:transport</strong> as a dispatch <em class="italic">value</em>:<p class="source-code"> (defmulti itinerary</p><p class="source-code">    "Calculate the distance of travel between two location, and the cost and       duration based on the type of transport"</p><p class="source-code">    :transport)</p></li>
				<li>Create the itinerary function for the <strong class="source-inline">:walking</strong> dispatch value. You can use associative destructuring in the function parameters to retrieve the <strong class="source-inline">:from</strong> and <strong class="source-inline">:to</strong> keys from the <strong class="source-inline">HashMap</strong> parameter. You can use a <strong class="source-inline">let</strong> expression to decompose the calculations of the distance and duration. The distance should simply use the <strong class="source-inline">distance</strong> function you created before. To calculate the duration, you should use the <strong class="source-inline">walking-speed</strong> constant that you defined in <em class="italic">Step 1</em>:<p class="source-code"> (defmethod itinerary :walking</p><p class="source-code">  [{:keys [:from :to]}]</p><p class="source-code">  (let [walking-distance (distance from to)</p><p class="source-code">    duration (/ (distance from to) walking-speed)]</p><p class="source-code">    {:cost 0 :distance walking-distance :duration duration}))</p></li>
				<li>For the <strong class="source-inline">:driving</strong> itinerary function, you could use a <em class="italic">dispatch table</em> that contains the vehicle associated with their costing function. Create a <strong class="source-inline">vehicle-cost-fns</strong> dispatch table. It should be a <strong class="source-inline">HashMap</strong> with the keys being the types of vehicles, and the values being cost calculation functions based on the distance:<p class="source-code"> (def vehicle-cost-fns</p><p class="source-code">  {</p><p class="source-code">    :sporche (partial * 0.12 1.3)</p><p class="source-code">    :tayato (partial * 0.07 1.3)</p><p class="source-code">    :sleta (partial * 0.2 0.1)</p><p class="source-code">  })</p></li>
				<li>Create the itinerary function for the <strong class="source-inline">:driving</strong> dispatch value. You can use associative destructuring in the function parameters to retrieve the <strong class="source-inline">:from</strong>, <strong class="source-inline">:to</strong>, and <strong class="source-inline">:vehicle</strong> keys from the <strong class="source-inline">HashMap</strong> parameter. The driving distance and duration can be calculated similarly to the walking distance and duration. The cost can be calculated by retrieving the <strong class="source-inline">cost</strong> function from the dispatch table using the <strong class="source-inline">:vehicle</strong> key:<p class="source-code"> (defmethod itinerary :driving</p><p class="source-code">  [{:keys [:from :to :vehicle]}]</p><p class="source-code">  (let [driving-distance (distance from to)</p><p class="source-code">        cost ((vehicle vehicle-cost-fns) driving-distance)</p><p class="source-code">        duration (/ driving-distance driving-speed)]</p><p class="source-code">    {:cost cost :distance driving-distance :duration duration}))</p><p>Now try the following:</p><p class="source-code">user=&gt; (def london {:lat 51.507351, :lon -0.127758})</p><p class="source-code">#'user/london</p><p class="source-code">user=&gt; (def manchester {:lat 53.480759, :lon -2.242631})</p><p class="source-code">#'user/manchester</p><p class="source-code">user=&gt; (itinerary {:from london :to manchester :transport :walking})</p><p class="source-code">{:cost 0, :distance 318.4448148814284, :duration 79.6112037203571}</p><p class="source-code">user=&gt; (itinerary {:from manchester :to london :transport :driving :vehicle :sleta})</p><p class="source-code">{:cost 4.604730845743489, :distance 230.2365422871744, :duration 3.2890934612453484}</p></li>
			</ol>
			<p>In this activity, we've put in practice the destructuring and multimethod techniques that we have learned in this chapter by building a distance and cost calculator between two locations. In the future, you could imagine putting this code behind a web server and finishing building a fully blown itinerary calculation app!</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor460"/>4. Mapping and Filtering</h1>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor461"/>Activity 4.01: Using map and filter to Report Summary Information</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">To start, set up a simple framework using the <strong class="source-inline">-&gt;&gt;</strong> threading macro:<p class="source-code">(defn max-value-by-status [field status users]</p><p class="source-code">               (-&gt;&gt; </p><p class="source-code">                 users</p><p class="source-code">                 ;; code will go here</p><p class="source-code">                 ))</p><p>This defines the fundamental structure of our function, which we can sum up as follows: start with <strong class="source-inline">users</strong> and send it through a series of transformations.</p></li>
				<li>The first of these transformations will be to filter out all the users that don't have the status we are looking for. We'll use <strong class="source-inline">filter</strong> for that, naturally, and we'll include a predicate that compares the <strong class="source-inline">:status</strong> field from each user with the <strong class="source-inline">status</strong> parameter that was passed into the function: <strong class="source-inline">(filter #(= (:status %) status))</strong>.<p>With that, our function now looks like this:</p><p class="source-code">(defn max-value-by-status [field status users]</p><p class="source-code">               (-&gt;&gt; </p><p class="source-code">                 users</p><p class="source-code">                  ;; step 1: use filter to only keep users who</p><p class="source-code">                  ;; have the status we are looking for </p><p class="source-code">                 (filter #(= (:status %) status))</p><p class="source-code">                  ;; More to come!</p><p class="source-code">                 ))</p><p>We know that we have the correct set of users. Now, we need to extract the field we're interested in. The <strong class="source-inline">field</strong> parameter is a keyword, so we can use it as a function to extract the necessary data as we map over each user, like this: <strong class="source-inline">(map field)</strong>.</p><p>Now, our function looks like this:</p><p class="source-code">(defn max-value-by-status [field status users]</p><p class="source-code">               (-&gt;&gt; </p><p class="source-code">                 users</p><p class="source-code">                  ;; step 1: use filter to only keep users who</p><p class="source-code">                  ;; have the status we are looking for </p><p class="source-code">                 (filter #(= (:status %) status))</p><p class="source-code">                 ;; step 2: field is a keyword, so we can use it as </p><p class="source-code">                 ;; a function when calling map.</p><p class="source-code">                 (map field)</p><p class="source-code">                 ;; Watch this space!</p><p class="source-code">                 ))</p></li>
				<li>In the final step, we use <strong class="source-inline">(apply max)</strong> to find the needle in this haystack: the maximum value corresponding to <strong class="source-inline">field</strong>.<p>The complete function looks like this:</p><p class="source-code">(defn max-value-by-status [field status users]</p><p class="source-code">               (-&gt;&gt; </p><p class="source-code">                 users</p><p class="source-code">                 (filter #(= (:status %) status))</p><p class="source-code">                 (map field)</p><p class="source-code">                 (apply max 0)))</p><p class="source-code">(defn min-value-by-status [field status users]</p><p class="source-code">               (-&gt;&gt; </p><p class="source-code">                 users</p><p class="source-code">                 (filter #(= (:status %) status))</p><p class="source-code">                 (map field)</p><p class="source-code">                 (apply min 0)))</p></li>
			</ol>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor462"/>Activity 4.02: Arbitrary Tennis Rivalries</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">The first step will be to set up the function and the <strong class="source-inline">with-open</strong> macro:<p class="source-code">(defn rivalry-data [csv player-1 player-2]</p><p class="source-code">  (with-open [r (io/reader csv)]</p><p class="source-code">    ))</p></li>
				<li>Inside that, set up a <strong class="source-inline">let</strong> binding. The first binding will be to the <strong class="source-inline">lazy-seq</strong> returned by <strong class="source-inline">csv/read-csv</strong>:<p class="source-code">(let [rivalry-seq (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">                       sc/mappify</p><p class="source-code">                       (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">                                      :loser_sets_won sc/-&gt;int</p><p class="source-code">                                      :winner_games_won sc/-&gt;int</p><p class="source-code">                                      :loser_games_won sc/-&gt;int}))]</p><p class="source-code">  ;; more to come</p><p class="source-code">  )</p></li>
				<li>In the same <strong class="source-inline">-&gt;&gt;</strong> chain, we also want to keep only the matches where our players are actually against each other. Like we did previously, we'll use the set pattern to see whether the set "winner and loser in the match" is equal to the set of the two players we are looking for. We'll also use <strong class="source-inline">map</strong> and <strong class="source-inline">select-keys</strong> to only keep the fields we want:<p class="source-code">(filter #(= (hash-set (:winner_name %) (:loser_name %))</p><p class="source-code">                                       #{player-1 player-2}))</p><p class="source-code">                           (map #(select-keys % [:winner_name</p><p class="source-code">                                                 :loser_name</p><p class="source-code">                                                 :winner_sets_won</p><p class="source-code">                                                 :loser_sets_won</p><p class="source-code">                                                 :winner_games_won</p><p class="source-code">                                                 :loser_games_won</p><p class="source-code">                                                 :tourney_year_id</p><p class="source-code">                                                 :tourney_slug]))</p></li>
				<li>We can already start gathering some data here, so we'll make some more bindings in the same <strong class="source-inline">let</strong> statement:<p class="source-code">player-1-victories (filter #(= (:winner_name %) player-1) rivalry-seq)</p><p class="source-code">          player-2-victories (filter #(= (:winner_name %) player-2) rivalry-            seq)</p><p>These are simple filter calls that give us two lists of victories.</p></li>
				<li>We have all the bindings we need, so now it's time to do some work with them inside the scope of the <strong class="source-inline">let</strong> statement. Everything can happen inside the map that we are going to return. Now that we have our three sequences, that is, <strong class="source-inline">player-1-victories</strong>, <strong class="source-inline">player-2-victories</strong>, and the overall <strong class="source-inline">rivalry-seq</strong>, it becomes easier to grab some of our summary data with calls to <strong class="source-inline">count</strong> and <strong class="source-inline">first</strong>. We'll also write one more call to <strong class="source-inline">filter</strong> that inspects the score difference in the rivalry:<p class="source-code">      {:first-victory-player-1 (first player-1-victories)</p><p class="source-code">       :first-victory-player-2 (first player-2-victories)</p><p class="source-code">       :total-matches (count rivalry-seq)</p><p class="source-code">       :total-victories-player-1 (count player-1-victories)</p><p class="source-code">       :total-victories-player-2 (count player-2-victories)</p><p class="source-code">       :most-competitive-matches (-&gt;&gt; rivalry-seq</p><p class="source-code">                                      (filter #(= 1 (- (:winner_sets_won %)                                         (:loser_sets_won %)))))}</p><p class="callout-heading">Note</p><p class="callout">You may be surprised that we did not need to call <strong class="source-inline">doall</strong> in this solution. This is because <strong class="source-inline">rivalry-seq</strong> is fully realized by the call to <strong class="source-inline">count</strong>. The final code can be found at <a href="https://packt.live/2Ri3904">https://packt.live/2Ri3904</a>.</p></li>
			</ol>
			<p>By completing this activity, we have produced the summary data for any two players who have actually played against each other.</p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor463"/>5. Many to One: Reducing</h1>
			<h2 id="_idParaDest-361">Activity 5.01: Calculating Elo Ratings for Tenni<a id="_idTextAnchor464"/>s</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Here is the minimal <strong class="source-inline">deps.edn</strong> file you'll need:<p class="source-code">{:deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}</p><p class="source-code">  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}}}</p></li>
				<li>Here is the corresponding namespace declaration:<p class="source-code">(ns packt-clj.elo</p><p class="source-code">  (:require [clojure.math.numeric-tower :as math]</p><p class="source-code">            [clojure.java.io :as io]</p><p class="source-code">            [clojure.data.csv :as csv]</p><p class="source-code">            [semantic-csv.core :as sc])</p></li>
				<li>For the overall structure of your function, we will follow the same patterns we've used so far: a <strong class="source-inline">with-open</strong> macro with some pre-processing code:<p class="source-code">(defn elo-world</p><p class="source-code">  ([csv k]</p><p class="source-code">   (with-open [r (io/reader csv)]</p><p class="source-code">     (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">          sc/mappify</p><p class="source-code">          (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">                         :loser_sets_won sc/-&gt;int</p><p class="source-code">                         :winner_games_won sc/-&gt;int</p><p class="source-code">                         :loser_games_won sc/-&gt;int})</p><p class="source-code">          ;; TODO: just getting started</p><p class="source-code">          )))) </p></li>
				<li>The next step is to outline the call to <strong class="source-inline">reduce</strong>. The <strong class="source-inline">:match-count</strong>, <strong class="source-inline">:predictable-match-count</strong>, and <strong class="source-inline">:correct-predictions</strong> fields are just counters that will need to be updated depending on whether each match is correctly predicted. The <strong class="source-inline">:players</strong> map will contain a key for each player; the values will be their Elo ratings:<p class="source-code">(defn elo-world</p><p class="source-code">  ([csv k]</p><p class="source-code">   (with-open [r (io/reader csv)]</p><p class="source-code">     (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">          sc/mappify</p><p class="source-code">          (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">                         :loser_sets_won sc/-&gt;int</p><p class="source-code">                         :winner_games_won sc/-&gt;int</p><p class="source-code">                         :loser_games_won sc/-&gt;int})</p><p class="source-code">          (reduce (fn [{:keys [players] :as acc} {:keys [:winner_name <a id="_idTextAnchor465"/>:winner_slug</p><p class="source-code">                                                         :loser_name :loser_slug] :as match}]</p><p class="source-code">                    ;; TODO: more code</p><p class="source-code">                    )</p><p class="source-code">                  {:players {}</p><p class="source-code">                   :match-count 0</p><p class="source-code">                   :predictable-match-count 0</p><p class="source-code">                   :correct-predictions 0})))))</p></li>
				<li>From here, it is just a question of applying logic that we've already developed. First, we extract and calculate, and then we update the accumulator. The body of the reducing function starts with some <strong class="source-inline">let</strong> bindings:<p class="source-code">(let [winner-rating (get players winner_slug 400)</p><p class="source-code">       loser-rating (get players loser_slug 400)</p><p class="source-code">       winner-probability (match-probability winner-rating loser-rating)</p><p class="source-code">       loser-probability (- 1 winner-probability)</p><p class="source-code">       predictable-match? (not= winner-rating loser-rating)</p><p class="source-code">       prediction-correct? (&gt; winner-rating loser-rating)</p><p class="source-code">       correct-predictions (if (and predictable-match? prediction-correct?)</p><p class="source-code">                             (inc (:correct-predictions acc))</p><p class="source-code">                             (:correct-predictions acc))</p><p class="source-code">       predictable-matches (if predictable-match?</p><p class="source-code">                             (inc (:predictable-match-count acc))</p><p class="source-code">                             (:predictable-match-count acc))]</p><p class="source-code">                      </p><p class="source-code">   ;; TODO: update the accumulator</p><p class="source-code">   )</p><p><strong class="source-inline">winner-rating</strong> and <strong class="source-inline">loser-rating</strong> are extracted from the <strong class="source-inline">:players</strong> map in the accumulator. After we make our prediction regarding the match winner by calling <strong class="source-inline">match-probability</strong>, the remainder of the operations simply apply the consequences of whether our prediction was correct.</p></li>
				<li>Now, we can finally update the accumulator. The following code goes inside the <strong class="source-inline">let</strong> expression above. This is what the reducing function will return. We use the <strong class="source-inline">-&gt;</strong> macro to thread the existing <strong class="source-inline">acc</strong> through a series of changes:<p class="source-code">(-&gt; acc</p><p class="source-code">    (assoc :predictable-match-count predictable-matches)</p><p class="source-code">    (assoc :correct-predictions correct-predictions)</p><p class="source-code">    (assoc-in [:players winner_slug] (recalculate-rating k winner-rating winner-probability 1))</p><p class="source-code">    (assoc-in [:players loser_slug] (recalculate-rating k loser-rating loser-probability 0))</p><p class="source-code">    (update :match-count inc))</p></li>
				<li>Here is the entire function, when we put everything back together:</li>
			</ol>
			<p class="source-code-heading">tennis.clj</p>
			<p class="source-code"><a id="_idTextAnchor466"/>16  (defn elo-world-simple</p>
			<p class="source-code">17  ([csv k]</p>
			<p class="source-code">18   (with-open [r (io/reader csv)]</p>
			<p class="source-code">19     (-&gt;&gt; (csv/read-csv r)</p>
			<p class="source-code">20          sc/mappify</p>
			<p class="source-code">21          (sc/cast-with {:winner_sets_won sc/-&gt;int</p>
			<p class="source-code">22                         :loser_sets_won sc/-&gt;int</p>
			<p class="source-code">23                         :winner_games_won sc/-&gt;int</p>
			<p class="source-code">24                         :loser_games_won sc/-&gt;int})</p>
			<p class="source-code">25          (reduce (fn [{:keys [players] :as acc} {:keys [:winner_name               :winner_slug</p>
			<p class="source-code">26                                                         :loser_name                                                              :loser_slug] :as match}]</p>
			<p class="source-code-link">The complete code for this snippet can be found at: <a href="https://packt.live/38wSCUn">https://packt.live/38wSCUn</a></p>
			<p>It might be interesting to experiment with different values of <strong class="source-inline">k</strong> to see whether the precision of the predictions can be improved. This is why we keep track of <strong class="source-inline">:correction-predictions</strong> and <strong class="source-inline">:predictable-match-count</strong>. There are many other kinds of improvements that could be made: modifying the function to run on multiple CSV files (if the ratings started at the very beginning of the dataset, in 1877, we would expect the quality to improve); perhaps contextually adjusting <strong class="source-inline">k</strong> depending on the relative strength of the two players, or based on current winning and losing streaks; or attributing bonuses to players who win more in certain locations. You now have a framework for experimentation.</p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor467"/>6. Recursion and Looping</h1>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor468"/>Activity 6.01: Generating HTML from Clojure Vectors</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">We'll use <strong class="source-inline">clojure.string</strong> in our solution. It is not strictly necessary, but <strong class="source-inline">clojure.string/join</strong> is a very convenient function. Because <strong class="source-inline">clojure.string</strong> is a standard Clojure namespace, a <strong class="source-inline">deps.edn</strong> file containing only an empty map is sufficient for this activity:<p class="source-code">(ns my-hiccup</p><p class="source-code"> (:require [clojure.string :as string]))</p></li>
				<li>Here are the smaller functions that we'll use later in the main HTML-producing function: <p class="source-code">(defn attributes [m]</p><p class="source-code"> (clojure.string/join " "</p><p class="source-code">            (map (fn [[k v]]</p><p class="source-code">               (if (string? v)</p><p class="source-code">                (str (name k) "=\"" v "\"")</p><p class="source-code">                (name k)))</p><p class="source-code">              m)))</p><p>The first one, <strong class="source-inline">attributes</strong>, takes <strong class="source-inline">map</strong> attribute names and values. We treat the map like a sequence and map over the <strong class="source-inline">[key value]</strong> pairs. The keys are Clojure keywords, so they need to be converted to strings with the name function. The key-value pair becomes a string, <strong class="source-inline">key="value"</strong>. Then, we use <strong class="source-inline">clojure.string/join</strong> to combine all the substrings into a single string, making sure that each attribute is separated from the others by some whitespace. If the input map, <strong class="source-inline">m</strong>, is empty, <strong class="source-inline">clojure.string/join</strong> will return an empty string. </p></li>
				<li>The next functions are simple formatting tools for building different kinds of tags:<p class="source-code">(defn keyword-&gt;opening-tag [kw]</p><p class="source-code"> (str "&lt;" (name kw) "&gt;"))</p><p class="source-code">(defn keyword-attributes-&gt;opening-tag [kw attrs]</p><p class="source-code"> (str "&lt;" (name kw) " " (attributes attrs) "&gt;"))</p><p class="source-code">(defn keyword-&gt;closing-tag [kw]</p><p class="source-code"> (str "&lt;/" (name kw) "&gt;"))</p><p>The next set of helper functions are predicates that we will need since the main recursive function walks the tree of nested vectors. They all take the same kind of argument: the tree or subtree that we are analyzing. </p></li>
				<li>We need to be able to distinguish between input vectors that have attributes and those that don't. We do this by looking at the type of the second item in the vector:<p class="source-code">(defn has-attributes? [tree]</p><p class="source-code"> (map? (second tree)))</p></li>
				<li>The second item of a simple element like <strong class="source-inline">[:h1 "Hello world"]</strong> is a string, so <strong class="source-inline">has-attributes?</strong> would return <strong class="source-inline">nil</strong>. If the second item was another vector, the result would be the same. On <strong class="source-inline">[:h1 {:class "title"} "Hello Universe"]</strong>, <strong class="source-inline">has-attributes?</strong> would return <strong class="source-inline">true</strong>. Because <strong class="source-inline">(map? nil)</strong> returns <strong class="source-inline">nil</strong>, we don't need to have a special case for single-item vectors. <strong class="source-inline">(has-attributes? [:br])</strong> simply returns <strong class="source-inline">nil</strong>:<p class="source-code">(defn singleton? [tree]</p><p class="source-code"> (and (vector? tree)</p><p class="source-code">    (#{:img :meta :link :input :br} (first tree))))</p></li>
				<li>The <strong class="source-inline">singleton?</strong> function tests whether an element is a member of a small set of HTML elements that are not allowed to have closing tags. Naturally, we use a Clojure set to test this. First, though, we make sure that the current item is a vector because, sometimes, the current item will be a string (such as the second item in <strong class="source-inline">[:h1 "Hello world"]</strong>):<p class="source-code">(defn singleton-with-attrs? [tree]</p><p class="source-code"> (and (singleton? tree) (has-attributes? tree)))</p><p class="source-code">(defn element-with-attrs? [tree]</p><p class="source-code"> (and (vector? tree) (has-attributes? tree)))</p><p>These two predicates follow the same basic logic but build on the function we've already defined.</p></li>
				<li>Now it's time for the main recursive function. Like the predicates, it will take a tree as an argument, which can, of course, be the entire vector tree or a subtree. Like most recursive functions, there is a <strong class="source-inline">cond</strong> with several branches.<p>Here is the basic structure:</p><p class="source-code">(defn my-hiccup [tree]</p><p class="source-code"> (cond</p><p class="source-code">  ))</p></li>
				<li>Let's go through the various conditions one by one, before putting them all back together:<p class="source-code">  (not tree) tree</p></li>
				<li>If <strong class="source-inline">tree</strong> is not truthy, it means there is nothing we can do, so we simply return <strong class="source-inline">nil</strong>. For the rest of the inputs, we won't have to worry about getting <strong class="source-inline">nil</strong>:<p class="source-code">  (string? tree) tree</p></li>
				<li>If <strong class="source-inline">tree</strong> is a string, we don't want to transform it. It can be integrated into the output string as is:<p class="source-code">  (singleton-with-attrs? tree)</p><p class="source-code">  (keyword-attributes-&gt;opening-tag (first tree) (second tree))</p></li>
				<li>This is why we needed the <strong class="source-inline">singleton-with-attrs?</strong> predicate. Now, all we need to do is match the singleton tree with the corresponding formatting function. Because singleton elements don't have any content, no recursion is possible here:<p class="source-code">  (singleton? tree)</p><p class="source-code">  (keyword-&gt;opening-tag (first tree))</p></li>
				<li>This is a simpler version of the previous condition:<p class="source-code">  (element-with-attrs? tree)</p><p class="source-code">  (apply str</p><p class="source-code">      (concat</p><p class="source-code">       [(keyword-attributes-&gt;opening-tag (first tree) (second tree))]</p><p class="source-code">       (map my-hiccup (next (next tree)))</p><p class="source-code">       [(keyword-&gt;closing-tag (first tree))]))</p></li>
				<li>Now, we finally get to do some recursion! If an element has attributes, start making a string out of a list. That's what <strong class="source-inline">(apply str…)</strong> is for. We'll use <strong class="source-inline">concat</strong> to prepend the opening tag and the attributes, now formatted as a string, to a list that will be produced by <strong class="source-inline">next</strong> calls to <strong class="source-inline">my-hiccup</strong>, which will happen with the call to <strong class="source-inline">map</strong>. And, at the end of the list, we have the formatted closing tag. This is the classic case where we cannot use <strong class="source-inline">recur:</strong> the call to <strong class="source-inline">(apply str (concat…))</strong> cannot complete until all the underlying calls to <strong class="source-inline">my-hiccup</strong> have completed:<p class="source-code">  (vector? tree)</p><p class="source-code">  (apply str</p><p class="source-code">      (concat</p><p class="source-code">       [(keyword-&gt;opening-tag (first tree))]</p><p class="source-code">       (map my-hiccup (next tree))</p><p class="source-code">       [(keyword-&gt;closing-tag (first tree))]))</p></li>
				<li>The last condition follows the same pattern as the previous pattern. We could have made this a default condition instead of testing with <strong class="source-inline">vector?</strong>. If our input vector tree is malformed, the error indicating no matching case should put us on the right track for debugging. In production code, we could add an <strong class="source-inline">:otherwise</strong> condition that would throw an exception. You'll learn about exceptions in <em class="italic">Chapter 9</em>, <em class="italic">Host Platform Interoperability with Java and JavaScript</em>.<p>If we reassemble <strong class="source-inline">my-hiccup</strong>, it looks like this:</p><p class="source-code"><a id="_idTextAnchor469"/>(defn my-hiccup [tree]</p><p class="source-code"> (cond</p><p class="source-code">  (not tree) tree</p><p class="source-code">  (string? tree) tree</p><p class="source-code">  (singleton-with-attrs? tree)</p><p class="source-code">  (keyword-attributes-&gt;opening-tag (first tree) (second tree))</p><p class="source-code">  (singleton? tree)</p><p class="source-code">  (keyword-&gt;opening-tag (first tree))</p><p class="source-code">  (element-with-attrs? tree)</p><p class="source-code">  (apply str</p><p class="source-code">      (concat</p><p class="source-code">       [(keyword-attributes-&gt;opening-tag (first tree) (second tree))]</p><p class="source-code">       (map my-hiccup (next (next tree)))</p><p class="source-code">       [(keyword-&gt;closing-tag (first tree))]))</p><p class="source-code">  (vector? tree)</p><p class="source-code">  (apply str</p><p class="source-code">      (concat</p><p class="source-code">       [(keyword-&gt;opening-tag (first tree))]</p><p class="source-code">       (map my-hiccup (next tree))</p><p class="source-code">       [(keyword-&gt;closing-tag (first tree))]))))</p><p>If you try the <strong class="source-inline">my-hiccup</strong> function in the REPL, you should be able to produce the string for a complete HTML page:</p><div id="_idContainer316" class="IMG---Figure"><img src="image/B14502_06_10.jpg" alt="Figure 6.10: Final output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.10: Final output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Feel free to try different inputs and page structures. You can even copy the output string into a text file to load into your browser.</p>
			<p>By completing this activity, we are now able to take any vector written with this syntax, including an arbitrary number of descendant vectors, and produce a single string containing correctly structured HTML.</p>
			<h1 id="_idParaDest-364"><a id="_idTextAnchor470"/>7. Recursion II: Lazy Sequences</h1>
			<h2 id="_idParaDest-365"><a id="_idTextAnchor471"/>Activity 7.01: Historical, Player-Centric Elo</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Set up your project, which should be based on the code written for the last exercises in this chapter.</li>
				<li>The solution follows the pattern established with <strong class="source-inline">take-matches</strong>. Let's start with the parameters. We need to define separate behaviors for matches played by the "focus player" and matches played between other players. The first thing we need is, of course, a way to identify the player, so we'll add a <strong class="source-inline">player-slug</strong> argument. This wasn't necessary in <strong class="source-inline">take-matches</strong> because there we treated all the matches the same, regardless of who played in them. <p>In <strong class="source-inline">take-matches</strong>, we had a <strong class="source-inline">limit</strong> argument to control how deeply we walked the tree. In this case, we need two different parameters, which we will call <strong class="source-inline">focus-depth</strong> and <strong class="source-inline">opponent-depth</strong>. Together, that gives us the following parameters for our new <strong class="source-inline">focus-history</strong> function:</p><p class="source-code">(defn focus-history [tree player-slug focus-depth opponent-depth f]</p><p class="source-code">;;...</p><p class="source-code">)</p><p>The <strong class="source-inline">tree</strong> parameter is, of course, the result of a call to <strong class="source-inline">match-tree-by-player</strong>, as before. </p><p>Finally, the <strong class="source-inline">f</strong> argument will work the same way as in <strong class="source-inline">take-matches</strong>.</p></li>
				<li>Controlling the function's movement through the tree will end up being a challenge. As usual, we will set up a <strong class="source-inline">cond</strong> form that will determine how the function reacts to the incoming data. The first two conditions are quite simple, and in fact, are nearly identical to the code in <strong class="source-inline">take-matches</strong>:<p class="source-code">(defn focus-history [tree player-slug focus-depth opponent-depth f]</p><p class="source-code">    (cond</p><p class="source-code">      (zero? focus-depth)</p><p class="source-code">      '()</p><p class="source-code">      (= 1 focus-depth)</p><p class="source-code">      (f (first tree))))	</p><p>The only change from <strong class="source-inline">take-matches</strong> is that now we are using <strong class="source-inline">focus-depth</strong> instead of <strong class="source-inline">limit</strong>. The fact that we are using <strong class="source-inline">focus-depth</strong> here is important nonetheless. We are only concerned about <strong class="source-inline">focus-depth</strong> at this stage, and not <strong class="source-inline">opponent-depth</strong>, because if <strong class="source-inline">focus-depth</strong> is zero or one, the entire operation stops and in this case we no longer care about <strong class="source-inline">opponent-depth</strong>.</p></li>
				<li>The final condition is where this function behaves differently from <strong class="source-inline">take-matches</strong>. It is also more complex, though perhaps not as much as you might think at first glance. To understand this, let's look at the equivalent part of <strong class="source-inline">take-matches</strong>:<p class="source-code">:otherwise-continue</p><p class="source-code">        (cons</p><p class="source-code">          (f (first tree))</p><p class="source-code">          (cons</p><p class="source-code">            [(take-matches (dec limit) (first (second tree)) f)</p><p class="source-code">             (take-matches (dec limit) (second (second tree)) f)]</p><p class="source-code">            '()))</p></li>
				<li>At this point, we are placing <strong class="source-inline">(f (first tree))</strong> at the head of the current lazy seq. As such, we are connecting it onto the rest of the sequence, whose first item will be a vector containing the starting point for two more branch lazy seqs.<p>All we need to do here, in order to introduce separate behaviors for the two possible cases, is to replace the calls to <strong class="source-inline">take-matches</strong> inside the two-item vector. Those two matches are the "parent" matches of the current match; that is, they are the matches played by the winner and loser before the current match. We need to test first to find which "parent" matches belong to the focus player and which belong to an opponent. For the focus player's previous match, we call <strong class="source-inline">focus-history</strong>. For the opponent's previous match we call <strong class="source-inline">take-matches</strong>. In other words, instead of just having two calls to <strong class="source-inline">take-matches</strong>, as above, we have two branching conditions:</p><p class="source-code"> :otherwise</p><p class="source-code"> (cons</p><p class="source-code">   (f (first tree))</p><p class="source-code">   (cons [(if (player-in-match? (ffirst (second tree)) player-slug)</p><p class="source-code">            (focus-history (first (second tree)) player-slug (dec focus-depth) opponent-depth f)</p><p class="source-code">            (take-matches opponent-depth (first (second tree))  f))</p><p class="source-code">          (if (player-in-match? (first (second (second tree))) player-slug)</p><p class="source-code">            (focus-history (second (second tree)) player-slug (dec focus-depth) opponent-depth f)</p><p class="source-code">            (take-matches opponent-depth (second (second tree)) f))]</p><p class="source-code">         '()))</p></li>
				<li>In both of these cases, whether we call <strong class="source-inline">focus-history</strong> or <strong class="source-inline">take-matches</strong>, we have to be careful to adjust the <strong class="source-inline">tree</strong> argument and the <strong class="source-inline">focus-depth</strong> arguments correctly. Remember that <strong class="source-inline">tree</strong> is always relative to the current two-item sequence composed of a match and a two-item vector, which is why we use <strong class="source-inline">(first (second tree))</strong> and <strong class="source-inline">(second (second tree))</strong>, that is, the first and the second of the two lazy sequences in the vector. While it would be tempting to assign these to <strong class="source-inline">let</strong> bindings to avoid repeating <strong class="source-inline">(second tree)</strong>, it is generally better in these cases to avoid "holding onto the head."<p>Here's the complete function:</p><p class="source-code">(defn focus-history [tree player-slug focus-depth opponent-depth f]</p><p class="source-code">    (cond</p><p class="source-code">      (zero? focus-depth)</p><p class="source-code">      '()</p><p class="source-code">      (= 1 focus-depth)</p><p class="source-code">      (f (first tree))</p><p class="source-code">      :otherwise</p><p class="source-code">      (cons</p><p class="source-code">        (f (first tree))</p><p class="source-code">        (cons [(if (player-in-match? (ffirst (second tree)) player-slug)</p><p class="source-code">                 (focus-history (first (second tree)) player-slug (dec focus-depth)                    opponent-depth f)</p><p class="source-code">                 (take-matches opponent-depth (first (second tree))  f))</p><p class="source-code">               (if (player-in-match? (first (second (second tree))) player-slug)</p><p class="source-code">                 (focus-history (second (second tree)) player-slug (dec focus-depth)                    opponent-depth f)</p><p class="source-code">                 (take-matches opponent-depth (second (second tree)) f))]</p><p class="source-code">              '()))))</p></li>
				<li>It's worth noting that this function is only slightly more complex than <strong class="source-inline">take-matches</strong>. As is often the case with recursive solutions, the code itself is rather simple. The difficulty is in choosing the best strategy.<p>Here is the function in action, from start to finish. First, we read in the data and generate the ratings:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (def ratings (elo-db   "match_scores_1991-2016_unindexed_csv.csv" 35))</p><p>Then we build the lazy match tree for the player we're interested in:</p><p class="source-code">#'packt-clojure.lazy-tennis/ratings</p><p class="source-code">packt-clojure.lazy-tennis&gt; (def federer (match-tree-by-player ratings   "roger-federer"))</p><p class="source-code">#'packt-clojure.lazy-tennis/federer</p><p>And now we call our new function:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (<a id="_idTextAnchor472"/>focus-history federer </p><p class="source-code">                                          "roger-federer" </p><p class="source-code">                                          4 </p><p class="source-code">                                          2 </p><p class="source-code">                                          #(select-keys % [:winner_name :loser_name                                             :winner_rating :loser_rating]))</p><p>The indentation in the results reveals a<a id="_idTextAnchor473"/> tree structure:</p><div id="_idContainer317" class="IMG---Figure"><img src="image/B14502_07_10.jpg" alt="Figure 7.10: The results of focus-history&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.10: The results of focus-history</p>
			<p>Matches played by Federer contain deeper sub-trees of the preceding matches. The data is ready to be passed to the frontend team, who will translate it into a beautiful visualization.</p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor474"/>8. Namespaces, Libraries and Leiningen</h1>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor475"/>Activity 8.01: Altering the Users List in an Application</h2>
			<p>So<a id="_idTextAnchor476"/>lution:</p>
			<ol>
				<li value="1">Import the <strong class="source-inline">clojure.string</strong> namespace with <strong class="source-inline">use</strong> and the <strong class="source-inline">:rename</strong> keyword for the <strong class="source-inline">replace</strong> and <strong class="source-inline">reverse</strong> functions:<p class="source-code">(use '[clojure.string :rename {replace str-replace, reverse str-reverse}])</p></li>
				<li>Create a set of users:<p class="source-code">(def users #{"mr_paul smith" "dr_john blake" "miss_katie hudson"})</p></li>
				<li>Replace the underscore between honorifics and first names:<p class="source-code">(map #(str-replace % #"_" " ") users)</p><p>This will return the following:</p><p class="source-code">("mr paul smith" "miss katie hudson" "dr john blake")</p></li>
				<li>Use the <strong class="source-inline">capitalize</strong> function to capitalize each person's initials in the user group:<p class="source-code">(map #(capitalize %) users)</p><p>This will return the following:</p><p class="source-code">("Mr_paul smith" "Miss_katie hudson" "Dr_john blake")</p></li>
				<li>Update the user list by using the string's <strong class="source-inline">replace</strong> and <strong class="source-inline">capitalize</strong> functions:<p class="source-code">(def updated-users (into #{}</p><p class="source-code">                         (map #(join " "</p><p class="source-code">                                     (map (fn [sub-str] (capitalize sub-str))</p><p class="source-code">                                          (split (str-replace % #"_" " ") #" ")))</p><p class="source-code">                              users)))</p><p class="source-code">updated-users</p><p>The output is as follows:</p><p class="source-code">#{"Mr Paul Smith" "Dr John Blake" "Miss Katie Hudson"}</p></li>
				<li>Import only the <strong class="source-inline">print-table</strong> function from the <strong class="source-inline">clojure.pprint</strong> namespace:<p class="source-code">(use '[clojure.pprint :only (print-table)])</p></li>
				<li>Print a table with users:<p class="source-code">(print-table (map #(hash-map :user-name %) updated-users))</p><p>The output is as follows:</p><div id="_idContainer318" class="IMG---Figure"><img src="image/B14502_08_23.jpg" alt="Figure 8.23: Printing the table of users&#13;&#10;"/></div><p class="figure-caption">Figure 8.23: Printing the table of users</p></li>
				<li>Import the <strong class="source-inline">clojure.set</strong> namespace, excluding the <strong class="source-inline">join</strong> function:<p class="source-code">(use '[clojure.set :exclude (join)])</p></li>
				<li>Create and display a set of admins:<p class="source-code">(def admins #{"Mr Paul Smith" "Miss Katie Hudson" "Dr Mike Rose" "Mrs Tracy Ford"})</p><p>The output is as follows:</p><p class="source-code">#'user/admins</p></li>
				<li>Now execute the following:<p class="source-code">admins</p><p>The output is as follows:</p><p class="source-code">#{"Mr Paul Smith" "Dr Mike Rose" "Miss Katie Hudson" "Mrs Tracy Ford"}</p></li>
				<li>Call the <strong class="source-inline">subset?</strong> function on two sets:<p class="source-code">(subset? users admins)</p><p>The output is as follows:</p><p class="source-code">false</p></li>
				<li>To print the final output, execute the following:<p class="source-code">(print-table (map #(hash-map :user-name %) updated-users))</p><p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer319" class="IMG---Figure">
					<img src="image/B14502_08_24.jpg" alt="Figure 8.24: Printing the final user table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24: Printing the final user table</p>
			<p>In this activity, we worked on two features. With the first feature, we capitalized usernames. With the second feature, we used <strong class="source-inline">Clojure.set</strong> functions to check whether any users were also admins.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor477"/>Activity 8.02: Summing Up Numbers</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Create a Leiningen application:<p class="source-code">lein new app hello-leiningen</p></li>
				<li>Convert string arguments to integers:<p class="source-code">(map #(Integer/parseInt %) args)</p></li>
				<li>Add integers to calculate the sum:<p class="source-code">apply +</p></li>
				<li>Print the result as follows:<p class="source-code">println</p><p>The output will look like the following:</p></li>
			</ol>
			<div>
				<div id="_idContainer320" class="IMG---Figure">
					<img src="image/B14502_08_25.jpg" alt="Figure 8.25: Printing the sum&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25: Printing the sum</p>
			<p>The complete solution should look as follows:</p>
			<p class="source-code">(ns hello-leiningen.core)</p>
			<p class="source-code">(defn<a id="_idTextAnchor478"/> -main</p>
			<p class="source-code">  "Sum integers passed as arguments."</p>
			<p class="source-code">  [&amp; args]</p>
			<p class="source-code">  (println (apply + (map #(Integer/parseInt %) args))))</p>
			<p>In this activity, we created a new Leiningen project. This application accepted parameters from the command line. Numbers input into the command line were summed and the result was displayed.</p>
			<h2 id="_idParaDest-369">Activ<a id="_idTextAnchor479"/>ity 8.03: Building a Format-Converting Application</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">project.clj</strong>, add the <strong class="source-inline">cheshire</strong> dependency:<p class="source-code">(defproject json-parser "0.1.0-SNAPSHOT"</p><p class="source-code">;;; code committed</p><p class="source-code">   :dependencies [[org.clojure/clojure "1.10.0"]</p><p class="source-code">                            [cheshire "3.0.0"]]</p><p class="source-code">;;; code ommited</p><p class="source-code">)</p></li>
				<li>Create a function to convert from hash to JSON. Inside the core namespace, add the following:<p class="source-code">(ns json-parser.core</p><p class="source-code">    (:require [cheshire.core :as json])</p><p class="source-code">    (:gen-class))</p><p class="source-code">(defn generate-json-from-hash [hash]</p><p class="source-code">      (json/generate-string hash))</p><p>Testing the <strong class="source-inline">generate-json-from-hash</strong> function in the REPL should give us the following result:</p><div id="_idContainer321" class="IMG---Figure"><img src="image/B14502_08_26.jpg" alt="Figure 8.26: Generating JSON from hash&#13;&#10;"/></div><p class="figure-caption">Figure 8.26: Generating JSON from hash</p></li>
				<li>Create a function to convert from JSON to hash:<p class="source-code">(defn generate-hash-from-json [json]</p><p class="source-code">      (json/parse-string json))</p><p>Testing <strong class="source-inline">generate-hash-from-json</strong> in the REPL should give us the following result:</p><div id="_idContainer322" class="IMG---Figure"><img src="image/B14502_08_27.jpg" alt="Figure 8.27: Generating hash from JSON&#13;&#10;"/></div><p class="figure-caption">Figure 8.27: Generating hash from JSON</p></li>
				<li>Add the <strong class="source-inline">expectations</strong> library to the testing profile defined for the project. In <strong class="source-inline">project.clj</strong>, add the following:<p class="source-code">(defproject json-parser "0.1.0-SNAPSHOT"</p><p class="source-code"> ;;; code ommited</p><p class="source-code">  :profiles {:qa  {:dependencies [[expectations "2.1.10"]]}</p><p class="source-code">;;; code ommited</p><p class="source-code">})</p></li>
				<li>Add the <strong class="source-inline">lein-expectations</strong> plugin for the project:<p class="source-code">(defproject json-parser "0.1.0-SNAPSHOT"</p><p class="source-code"> ;;; code ommited</p><p class="source-code">  :profiles {:qa  {:plugins      [[lein-expectations "0.0.8"]]}</p><p class="source-code">;;; code ommited</p><p class="source-code">})</p></li>
				<li>Write the test for the JSON functions. Inside the <strong class="source-inline">json-parser/test/json_parser/core_test.clj</strong> files, add the following:<p class="source-code">(ns json-parser.core-test</p><p class="source-code">  (:require [expectations :refer [expect]]</p><p class="source-code">            [json-parser.core :refer :all]))</p><p class="source-code">(expect (generate-json-from-hash {:name "John" :occupation "programmer"})</p><p class="source-code">        "{\"name\":\"John\",\"occupation\":\"programmer\"}")</p><p class="source-code">(expect (generate-hash-from-json "{\"name\":\"Mike\",\"occupation\":\"carpenter\"}")</p><p class="source-code">        {"name" "Mike", "occupation" "carpenter"})</p><p>Calling tests with the <strong class="source-inline">qa</strong> profile should give us the following:</p><div id="_idContainer323" class="IMG---Figure"><img src="image/B14502_08_28.jpg" alt="Figure 8.28: Executing the test profile&#13;&#10;"/></div><p class="figure-caption">Figure 8.28: Executing the test profile</p></li>
				<li>Add <strong class="source-inline">lein-ancient</strong> to user-wide profiles. In <strong class="source-inline">~/.lein/profiles.clj</strong>, add the following:<p class="source-code">{:user {:plugins [[lein-ancient "0.6.15"]]</p><p class="source-code">        :dependencies [[clojure-humanize "0.2.2"]]}}</p><p>Checking for outdated dependencies should show the following:</p><div id="_idContainer324" class="IMG---Figure"><img src="image/B14502_08_29.jpg" alt="Figure 8.29: Checking for outdated dependencies&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 8.29: Checking for outdated dependencies</p>
			<p>In this activity, we have created an application that performs a conversion from JSON format to Clojure data and back. In order to make sure that our application runs correctly, we created a testing profile where we included dependencies on the <strong class="source-inline">expectations</strong> library and a plugin. To make sure that the libraries in all our projects are not outdated, we included the <strong class="source-inline">lein-ancient</strong> plugin in our user-wide profile.</p>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor480"/>9. Host Platform Interoperability with Java and JavaScript</h1>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor481"/>Activity 9.01: Book-Ordering Application </h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Create a new project:<p class="source-code">lein new app books-app</p></li>
				<li>Import the necessary namespaces:<p class="source-code">(ns books-app.core</p><p class="source-code">  (:require [books-app.utils :as utils])</p><p class="source-code">  (:import [java.util Scanner])</p><p class="source-code">  (:gen-class))</p></li>
				<li>Create a map to hold books by year:<p class="source-code">(def ^:const books {:2019 {:clojure {:title "Hands-On Reactive Programming with Clojure" :price 20}</p><p class="source-code">                           :go      {:title "Go Cookbook" :price 18}}</p><p class="source-code">                    :2018 {:clojure {:title "Clojure Microservices" :price 15}</p><p class="source-code">                           :go {:title "Advanced Go programming" :price 25}}})</p></li>
				<li>Create a variable for a file that stores orders:<p class="source-code">(def ^:const orders-file "orders.edn")</p></li>
				<li>Create the initial menu with options to order a book and list orders:<p class="source-code">(def input (Scanner. System/in))</p><p class="source-code">(defn- start-app []</p><p class="source-code">       "Displaying main menu and processing user choices."</p><p class="source-code">       (let [run-application (ref true)]</p><p class="source-code">            (while (deref run-application)</p><p class="source-code">                   (println "\n|     Books app         |")</p><p class="source-code">                   (println "| 1-Menu 2-Orders 3-Exit |\n")</p><p class="source-code">                   (let [choice (.nextInt input)]</p><p class="source-code">                        (case choice</p><p class="source-code">                              1 (show-menu)</p><p class="source-code">                              2 (show-orders)</p><p class="source-code">                              3 (dosync (alter run-application (fn [_]                                   false))))))))</p><p>The output is as follows:</p><div id="_idContainer325" class="IMG---Figure"><img src="image/B14502_09_53.jpg" alt="Figure 9.53: Output for the initial menu&#13;&#10;"/></div><p class="figure-caption">Figure 9.53: Output for the initial menu</p></li>
				<li>Create a menu to display books by year:<p class="source-code">(defn- show-menu []</p><p class="source-code">       (println "| Available books by year |")</p><p class="source-code">       (println "|1. 2019   2. 2018 |")</p><p class="source-code">       (let [choice (.nextInt input)]</p><p class="source-code">            (case choice</p><p class="source-code">                  1 (show-year-menu :2019)</p><p class="source-code">                  2 (show-year-menu :2018))))</p><p>The output is as follows:</p><div id="_idContainer326" class="IMG---Figure"><img src="image/B14502_09_54.jpg" alt="Figure 9.54: Output for available books by the year&#13;&#10;"/></div><p class="figure-caption">Figure 9.54: Output for available books by the year</p></li>
				<li>Create the application's <strong class="source-inline">main</strong> method:<p class="source-code">(defn -main</p><p class="source-code">  "Main function to run the app."</p><p class="source-code">  [&amp; args]</p><p class="source-code">  (start-app))</p></li>
				<li>Create a function to save data to a file:<p class="source-code">(ns books-app.utils</p><p class="source-code">    (:require [clojure.java.io :as io])</p><p class="source-code">    (:import [java.io PushbackReader]))</p><p class="source-code">(defn save-to [location data]</p><p class="source-code">      (spit location data :append true))</p></li>
				<li>Create a function to save an order:<p class="source-code">(defn save-book-order [orders-file year prog-lang number price]</p><p class="source-code">      (save-to orders-file {:year year :prog-lang prog-lang :number number :price price}))</p></li>
				<li>Create a function to calculate the price of a book:<p class="source-code">(defn calculate-book-price [books title number]</p><p class="source-code">      (-&gt;</p><p class="source-code">        (get books title)</p><p class="source-code">        :price</p><p class="source-code">        (* number)</p><p class="source-code">        float))</p></li>
				<li>Create a function to display an order confirmation message:<p class="source-code">(defn display-bought-book-message [title number total]</p><p class="source-code">      (println "Buying" number title "for total:€" total))</p><p>The output is as follows:</p><div id="_idContainer327" class="IMG---Figure"><img src="image/B14502_09_55.jpg" alt="Figure 9.55: Order confirmation message&#13;&#10;"/></div><p class="figure-caption">Figure 9.55: Order confirmation message</p></li>
				<li>Create a function to display the bought order:<p class="source-code">(defn display-order [order books]</p><p class="source-code">      (str "Bought " (:number order) ": " (:title (get (get books (:year order)) (:prog-lang order))) " published in " (name (:year order)) " for €" (:price order)))</p><p>The output is as follows:</p><div id="_idContainer328" class="IMG---Figure"><img src="image/B14502_09_56.jpg" alt="Figure 9.56: Displaying the purchased order&#13;&#10;"/></div><p class="figure-caption">Figure 9.56: Displaying the purchased order</p></li>
				<li>Create a function to read a single order:<p class="source-code">(defn read-one-order</p><p class="source-code">      [r]</p><p class="source-code">      (try</p><p class="source-code">        (read r)</p><p class="source-code">        (catch java.lang.RuntimeException e</p><p class="source-code">          (if (= "EOF while reading" (.getMessage e))</p><p class="source-code">            ::EOF</p><p class="source-code">            (throw e)))))</p></li>
				<li>Create a function to check whether a file exists:<p class="source-code">(defn file-exists [location]</p><p class="source-code">      (.exists (io/as-file location)))</p></li>
				<li>Create a function to load orders from a file:<p class="source-code">(defn load-orders</p><p class="source-code">      "Reads a sequence of orders in file at path."</p><p class="source-code">      [file]</p><p class="source-code">      (if (file-exists file)</p><p class="source-code">        (with-open [r (PushbackReader. (io/reader file))]</p><p class="source-code">                   (binding [*read-eval* false]</p><p class="source-code">                            (doall (take-while #(not= ::EOF %) (repeatedly                               #(read-one-order r))))))</p><p class="source-code">        []))</p></li>
				<li>Create a submenu to order a book:<p class="source-code">(ns coffee-app.core)</p><p class="source-code">(defn- show-year-menu [year]</p><p class="source-code">       (let [year-books (get books year)]</p><p class="source-code">            (println "| Books in" (name year) "|")</p><p class="source-code">            (println "| 1. " (:title (:clojure year-books)) " 2. " (:title                (:go year-books))  "|")</p><p class="source-code">            (let [choice (.nextInt input)]</p><p class="source-code">                 (case choice</p><p class="source-code">                       1 (buy-book year :clojure)</p><p class="source-code">                       2 (buy-book year :go)))))</p><p>The output is as follows:</p><div id="_idContainer329" class="IMG---Figure"><img src="image/B14502_09_57.jpg" alt="Figure 9.57: Submenu for book order&#13;&#10;"/></div><p class="figure-caption">Figure 9.57: Submenu for book order</p></li>
				<li>Create a function to buy a book by year:<p class="source-code">(defn- buy-book [year prog-lang]</p><p class="source-code">       (println "How many books do you want to buy?")</p><p class="source-code">       (let [choice (.nextInt input)</p><p class="source-code">             price (utils/calculate-book-price (get books year) prog-lang                choice)]</p><p class="source-code">            (utils/save-book-order orders-file year prog-lang choice price)</p><p class="source-code">            (utils/display-bought-book-message (:title (get (get books year)               prog-lang)) choice price)))</p><p>The output is as follows:</p><div id="_idContainer330" class="IMG---Figure"><img src="image/B14502_09_58.jpg" alt="Figure 9.58: Function to buy books by year&#13;&#10;"/></div><p class="figure-caption">Figure 9.58: Function to buy books by year</p></li>
				<li>Create a function to show orders by year:<p class="source-code">(defn- show-orders-by-year [year]</p><p class="source-code">       (println "\n")</p><p class="source-code">       (doseq [order (filter #(= year (:year %)) (utils/load-orders orders-         file))]</p><p class="source-code">              (println (utils/display-order order books))))</p></li>
				<li>Create a submenu to list orders:<p class="source-code">(defn show-orders []</p><p class="source-code">      (println "| Books by publish year |")</p><p class="source-code">      (println "|1. 2019   2. 2018 |")</p><p class="source-code">      (let [choice (.nextInt input)]</p><p class="source-code">           (case choice</p><p class="source-code">                 1 (show-orders-by-year :2019)</p><p class="source-code">                 2 (show-orders-by-year :2018)))) </p><p>The output is as follows:</p><div id="_idContainer331" class="IMG---Figure"><img src="image/B14502_09_59.jpg" alt="Figure 9.59: Creating submenu&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.59: Creating submenu</p>
			<p>In this activity, we created an application for ordering books and displaying orders. We used our new knowledge about I/O and Java to complete this activity.</p>
			<p>Once you complete the activity, you should have an output similar to the following.</p>
			<p>Initial menu:</p>
			<div>
				<div id="_idContainer332" class="IMG---Figure">
					<img src="image/B14502_09_60.jpg" alt="Figure 9.60: Initial menu&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.60: Initial menu</p>
			<p>Listing years:</p>
			<div>
				<div id="_idContainer333" class="IMG---Figure">
					<img src="image/B14502_09_61.jpg" alt="Figure 9.61: Listing years&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.61: Listing years</p>
			<p>Books in one year:</p>
			<div>
				<div id="_idContainer334" class="IMG---Figure">
					<img src="image/B14502_09_62.jpg" alt="Figure 9.62: Books purchased in 2019&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.62: Books purchased in 2019</p>
			<p>Asking how many books to buy:</p>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/B14502_09_63.jpg" alt="Figure 9.63: Asking for the numbers of books to be bought&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.63: Asking for the numbers of books to be bought</p>
			<p>Order confirmation message:</p>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/B14502_09_64.jpg" alt="Figure 9.64: Order confirmation message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.64: Order confirmation message</p>
			<p>Listing purchased books:</p>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/B14502_09_65.jpg" alt="Figure 9.65: Listing purchased books&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.65: Listing purchased books</p>
			<p>In this section, we used our knowledge of Java interoperability to create a command-line application. In the next section, we will learn how to use JavaScript in ClojureScript.</p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor482"/>Activity 9.02: Creating a Support Desk</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Create a new project:<p class="source-code">lein new figwheel-main support-desk</p></li>
				<li>Add the <strong class="source-inline">jayq</strong> and <strong class="source-inline">cuerdas</strong> libraries as dependencies in <strong class="source-inline">project.clj</strong>:<p class="source-code">:dependencies [[org.clojure/clojure "1.9.0"]</p><p class="source-code">               [org.cloj<a id="_idTextAnchor483"/>ure/clojurescript "1.10.520"]</p><p class="source-code">               [funcool/cuerdas "2.2.0"]</p><p class="source-code">               [jayq "2.5.4"]</p><p class="source-code">      <a id="_idTextAnchor484"/>         [rum "0.11.2"]]</p></li>
				<li>Create the <strong class="source-inline">utils</strong> function to filter the issues list by priority:<p class="source-code">(ns support-desk.utils)</p><p class="source-code">(defn get-priorities-list [list priority]</p><p class="source-code">      (filter #(&lt;= (:p<a id="_idTextAnchor485"/>riority %) priority) list))</p></li>
				<li>Create the <strong class="source-inline">utils</strong> function to get the sorted issues list:<p class="source-code">(defn get-sorted-priorities-list [list]</p><p class="source-code">      (sort-by :priori<a id="_idTextAnchor486"/>ty list))</p></li>
				<li>Create the <strong class="source-inline">utils</strong> function to get the sort message by issues count:<p class="source-code">(defn get-sort-message [items-count]</p><p class="source-code">      (str (cond</p><p class="source-code">             (&lt; items-count 3) "little"</p><p class="source-code">             (&lt; items-count 6) "medium"</p><p class="source-code">             :else "ma<a id="_idTextAnchor487"/>ny") " (" items-count ")"))</p><p>For <strong class="source-inline">0</strong> issues, the output is as follows:</p><p class="source-code">Sorting done: little (0) times</p><p>For <strong class="source-inline">3</strong> issues, the output is as follows:</p><p class="source-code">Sorting done: medium (3) times</p></li>
				<li>Create the <strong class="source-inline">utils</strong> function to delete issue from a list:<p class="source-code"> (defn delete-item-fro<a id="_idTextAnchor488"/>m-list-by-title [title list]</p><p class="source-code">      (remove #(= title (:title %)) list))</p></li>
				<li>Create the <strong class="source-inline">utils</strong> function called when sorting is finished:<p class="source-code">(defn handle-sort-finish [state]</p><p class="source-code">      (fn [ev ui]</p><p class="source-code">          (swap! state<a id="_idTextAnchor489"/> update-in [:sort-counter] inc)))</p></li>
				<li>Add jQuery and jQuery UI to <strong class="source-inline">index.html</strong>:<p class="source-code">&lt;script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"&gt;&lt;/script&gt;</p><p class="source-code">&lt;script src="https://c<a id="_idTextAnchor490"/>ode.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"&gt;&lt;/script&gt;</p></li>
				<li>Import <strong class="source-inline">jayq</strong>, <strong class="source-inline">cuerdas</strong>, and <strong class="source-inline">utils</strong> to the core namespace:<p class="source-code">(ns ^:figwheel-hooks support-desk.core</p><p class="source-code">  (:require [cuerdas.core :as str]</p><p class="source-code">            [goog.dom :as gdom]</p><p class="source-code">            [jayq.core :as jayq :refer [$]]</p><p class="source-code">            [rum.core :as rum]</p><p class="source-code">            [support-desk.utils :a<a id="_idTextAnchor491"/>s utils]))</p></li>
				<li>Define the priorities list as follows:<p class="source-code">(def priorities-list [{:title "IE bugs" :priority 2} {:title "404 page" :priority 1} {:title "Forgotten username" :priority 2}</p><p class="source-code">                      {:title "Login token" :priority 1} {:title "Mobile version" :priority 3} {:title "Load time" :priority 5}])</p></li>
				<li>Define <strong class="source-inline">app-state </strong>as follows:<p class="source-code">(defonce app-state (atom {:sort-counter 0</p><p class="source-code">                          :items        (utils/get-sorted-priorities-list (utils/get-priorities-list priorities-list 3))}))</p></li>
				<li>Define the <strong class="source-inline">counter </strong>Rum component:<p class="source-code">(rum/defc counter [number]</p><p class="source-code">          [:div</p><p class="source-code">           (str/format "Sorting done: %s times" (utils/get-sort-message number))])</p></li>
				<li>Create the issue on <strong class="source-inline">click </strong>function:<p class="source-code">(defn done-button-click [item]</p><p class="source-code">      (swap! app-state update-in [:items] #(utils/delete-item-from-list-by-        title (:title item) %)))</p></li>
				<li>Define the issue item in the Rum component:<p class="source-code">(rum/defc item [item]</p><p class="source-code">          [:li.ui-state-default {:key (:title item)}</p><p class="source-code">           (str/format "Priority %s for: %s " (:priority item) (:title               item))</p><p class="source-code">           [:button.delete</p><p class="source-code">            {:on-click #(done-button-click item)}</p><p class="source-code">            "Done"]])</p><p>The output is as follows:</p><div id="_idContainer338" class="IMG---Figure"><img src="image/B14502_09_66.jpg" alt="Figure 9.66: Defining an issue item in a Rum component&#13;&#10;"/></div><p class="figure-caption">Figure 9.66: Defining an issue item in a Rum component</p></li>
				<li>Define the <strong class="source-inline">reactive </strong>issue items component:<p class="source-code">(rum/defc items &lt; rum/reactive [num]</p><p class="source-code">          [:ul#sortable (vec (for [n num]</p><p class="source-code">                                  (item n)))])</p></li>
				<li>Define the reactive page <strong class="source-inline">content</strong> component:<p class="source-code">(rum/defc content &lt; rum/reactive []</p><p class="source-code">          [:div {}</p><p class="source-code">           (items (:items (deref app-state)))</p><p class="source-code">           (counter (:sort-counter (rum/react app-state)))])</p></li>
				<li>Make the item components sortable:<p class="source-code">(defn attrs [a]</p><p class="source-code">      (clj-&gt;js (sablono.util/html-to-dom-attrs a)))</p><p class="source-code">(defn make-sortable []</p><p class="source-code">      (.sortable ($ (str "#sortable"))</p><p class="source-code">                 (attrs {:stop (utils/handle-sort-finish app-state)})))</p></li>
				<li>Mount the page component:<p class="source-code">(defn mount [el]</p><p class="source-code">  (rum/mount (content) el))</p><p class="source-code">(defn mount-app-element []</p><p class="source-code">  (when-let [el (get-app-element)]</p><p class="source-code">    (mount el)))</p></li>
				<li>Call the <strong class="source-inline">mount</strong> function:<p class="source-code">(mount-app-element)</p></li>
				<li>Call the <strong class="source-inline">sortable</strong> function:<p class="source-code">(make-sortable)</p></li>
				<li>Run the application:<p class="source-code">lein fig:build</p><p>The initial issues list will look as follows:</p><div id="_idContainer339" class="IMG---Figure"><img src="image/B14502_09_67.jpg" alt="Figure 9.67: Initial issue list&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.67: Initial issue list</p>
			<p>The issues list after sorting will look as follows:</p>
			<div>
				<div id="_idContainer340" class="IMG---Figure">
					<img src="image/B14502_09_68.jpg" alt="Figure 9.68: Issue list after sorting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.68: Issue list after sorting</p>
			<p>The issues list after resolving three issues will look as follows:</p>
			<div>
				<div id="_idContainer341" class="IMG---Figure">
					<img src="image/B14502_09_69.jpg" alt="Figure 9.69: Issue list after resolving issues&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.69: Issue list after resolving issues</p>
			<p>In this activity, we created a support desk application. The application displays a list of issues. The issues can be sorted and resolved. We used JavaScript interoperability to add a sorting feature. </p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor492"/>10. Testing</h1>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor493"/>Activity 10.01: Writing Tests for the Coffee-Ordering Application</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Import the testing namespaces:<p class="source-code">(ns coffee-app.utils-test</p><p class="source-code">    (:require [clojure.test :refer :all]</p><p class="source-code">              [coffee-app.core :refer [price-menu]]</p><p class="source-code">              [coffee-app.utils :refer :all]))</p></li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to display the orders messages.</li>
				<li>Test the application using the <strong class="source-inline">is</strong> macro:<p class="source-code">(deftest display-order-test</p><p class="source-code">         (testing "Multiple tests with is macro"</p><p class="source-code">                  (is (= (display-order {:number 4 :price 3.8 :type :latte}) "Bought 4 cups of latte for €3.8"))</p><p class="source-code">                  (is (= (display-order {:number 7 :price 6.3 :type :espresso}) "Bought 7 cups of espresso for €6.3"))))</p></li>
				<li>Tests using the <strong class="source-inline">are</strong> macro:<p class="source-code">(deftest display-order-test</p><p class="source-code">         (testing "Multiple tests with are macro"</p><p class="source-code">                  (are [order result]</p><p class="source-code">                       (= (display-order order) result)</p><p class="source-code">                       {:number 2 :price 1.5 :type :latte} "Bought 2 cups of                          latte for €1.5"</p><p class="source-code">                       {:number 3 :price 6.3 :type :mocca} "Bought 3 cups of                          mocca for €6.3"</p><p class="source-code">                       {:number 8 :price 10 :type :espresso} "Bought 8 cups                          of espresso for €10")))</p></li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to check whether the file exists.<p>Test whether the file does not exist:</p><p class="source-code">(deftest file-exists-test</p><p class="source-code">   (testing "File does not exist"</p><p class="source-code">                  (testing "Multiple tests with is macro"</p><p class="source-code">                           (is (false? (file-exists "no-file")))</p><p class="source-code">                           (is (false? (file-exists "missing-file"))))</p><p class="source-code">                  (testing "Multiple tests with are macro"</p><p class="source-code">                           (are [file] (false? (file-exists file))</p><p class="source-code">                                "eettcc"</p><p class="source-code">                                "tmp-tmp"</p><p class="source-code">                                "no-file-here"))))</p><p>Test whether the file does exist:</p><p class="source-code">(deftest file-exists-test</p><p class="source-code">         (testing "File does exist"</p><p class="source-code">                  (testing "Multiple tests with is macro"</p><p class="source-code">                           (is (file-exists "/etc"))</p><p class="source-code">                           (is (file-exists "/lib")))</p><p class="source-code">                  (testing "Multiple tests with are macro"</p><p class="source-code">                           (are [file] (true? (file-exists file))</p><p class="source-code">                                "/etc"</p><p class="source-code">                                "/var"</p><p class="source-code">                                "/tmp"))))</p></li>
				<li>Create tests using the <strong class="source-inline">clojure.test</strong> library to save and load orders.<p>Save orders:</p><p class="source-code">(defn uuid [] (str (java.util.UUID/randomUUID)))</p><p class="source-code">(deftest saves-coffee-order</p><p class="source-code">         (testing "Saves cofee order"</p><p class="source-code">                  (let [test-file (str "/tmp/" (uuid) ".edn")</p><p class="source-code">                        test-data {:type :latte, :number 2, :price 2.6}]</p><p class="source-code">                       (save-coffee-order test-file :latte 2 2.6)</p><p class="source-code">                       (is (= (list test-data) (load-orders test-file))))))</p><p>Load empty orders:</p><p class="source-code">(deftest loads-empty-vector-from-not-existing-file</p><p class="source-code">         (testing "saving and loading"</p><p class="source-code">                  (let [test-file (str "/tmp/" (uuid) ".edn")]</p><p class="source-code">                       (is (= [] (load-orders test-file))))))</p><p>Load coffee orders:</p><p class="source-code">(deftest can-save-and-load-some-data</p><p class="source-code">         (testing "saving and loading"</p><p class="source-code">                  (let [test-file (str "/tmp/" (uuid) ".edn")</p><p class="source-code">                        test-data {:number 1 :type :latte}]</p><p class="source-code">                       (save-to test-file test-data)</p><p class="source-code">                       (is (= (list test-data) (load-orders test-file))))))</p><p>The output is as follows:</p><div id="_idContainer342" class="IMG---Figure"><img src="image/B14502_10_57.jpg" alt="Figure 10.57: Output after saving and loading orders&#13;&#10;"/></div><p class="figure-caption">Figure 10.57: Output after saving and loading orders</p></li>
				<li>Create tests using the expectations library to display the orders message:<p class="source-code">(ns coffee-app.utils-test-expectations</p><p class="source-code">    (:require [coffee-app.utils :refer :all]</p><p class="source-code">              [expectations :refer [expect side-effects]]))</p><p class="source-code">(expect "Bought 4 cups of latte for €3.8" (display-order {:number 4 :price 3.8 :type :latte}))</p><p class="source-code">(expect "Bought 7 cups of espresso for €6.3" (display-order {:number 7 :price 6.3 :type :espresso}))</p><p class="source-code">(expect String (display-order {:number 7 :price 6.3 :type :espresso}))</p><p class="source-code">(expect #"Bought 7 cups" (display-order {:number 7 :price 6.3 :type :espresso}))</p><p class="source-code">(expect #"cups of espresso" (display-order {:number 7 :price 6.3 :type :espresso}))</p><p class="source-code">(expect #"for €6.3" (display-order {:number 7 :price 6.3 :type :espresso}))</p></li>
				<li>Create tests using the <strong class="source-inline">Expectations</strong> library to check whether the file exists:<p class="source-code">(expect true (file-exists "/tmp"))</p><p class="source-code">(expect false (file-exists "no-file"))</p><p class="source-code">(expect Boolean (file-exists "etc"))</p></li>
				<li>Create tests using the <strong class="source-inline">Expectations</strong> library to save and load orders.<p>Save data to a file:</p><p class="source-code">(expect [["/tmp/menu.edn" {:type :latte :number 1 :price 2.4} :append true]</p><p class="source-code">         ["/tmp/menu.edn" {:type :latte :number 3 :price 4.7} :append true]]</p><p class="source-code">        (side-effects [spit]</p><p class="source-code">                      (save-to "/tmp/menu.edn" {:type :latte :number 1 :price 2.4})</p><p class="source-code">                      (save-to "/tmp/menu.edn" {:type :latte :number 3 :price 4.7})))</p><p>Save coffee orders:</p><p class="source-code">(expect [["/tmp/orders.edn" :latte 1 2.4]</p><p class="source-code">         ["/tmp/orders.edn" :latte 2 3.9]]</p><p class="source-code">        (side-effects [save-coffee-order]</p><p class="source-code">                      (save-coffee-order "/tmp/orders.edn" :latte 1 2.4)</p><p class="source-code">                      (save-coffee-order "/tmp/orders.edn" :latte 2 3.9)))</p><p>Save coffee data:</p><p class="source-code">(expect [["/tmp/coffees.edn" {:type :latte :number 1 :price 2.4}]</p><p class="source-code">         ["/tmp/coffees.edn" {:type :latte :number 2 :price 3.9}]]</p><p class="source-code">        (side-effects [save-to]</p><p class="source-code">                      (save-coffee-order "/tmp/coffees.edn" :latte 1 2.4)</p><p class="source-code">                      (save-coffee-order "/tmp/coffees.edn" :latte 2 3.9)))</p><p class="source-code">Load orders:</p><p class="source-code">(expect [] (load-orders "/tmp/data.edn"))</p><p>The output is as follows:</p><div id="_idContainer343" class="IMG---Figure"><img src="image/B14502_10_58.jpg" alt="Figure 10.58: Testing using the Expectations library&#13;&#10;"/></div><p class="figure-caption">Figure 10.58: Testing using the Expectations library</p></li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to display the orders messages:<p class="source-code">(ns coffee-app.utils-test-midje</p><p class="source-code">    (:require [coffee-app.utils :refer :all]</p><p class="source-code">              [midje.sweet :refer :all]))</p><p class="source-code">(facts "Passing an order should return display message"</p><p class="source-code">       (fact (display-order {:number 4 :price 3.8 :type :latte}) =&gt; "Bought 4 cups of latte for €3.8")</p><p class="source-code">       (fact (display-order {:number 7 :price 6.3 :type :espresso}) =&gt; "Bought 7 cups of espresso for €6.3"))</p><p class="source-code">(facts "Returned message should match regular expression"</p><p class="source-code">       (fact (display-order {:number 7 :price 6.3 :type :espresso}) =&gt; #"Bought 7 cups")</p><p class="source-code">       (fact (display-order {:number 7 :price 6.3 :type :espresso}) =&gt; #"cups of espresso")</p><p class="source-code">       (fact (display-order {:number 7 :price 6.3 :type :espresso}) =&gt; #"for €6.3"))</p></li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to checking whether the file exists:<p class="source-code">(facts "True should be returned when a file exists"</p><p class="source-code">       (fact (file-exists "/tmp") =&gt; true)</p><p class="source-code">       (fact (file-exists "/etc") =&gt; true))</p><p class="source-code">(facts "False should be returned when a file does not exist"</p><p class="source-code">       (fact (file-exists "no-file") =&gt; false)</p><p class="source-code">       (fact (file-exists "missing-file") =&gt; false))</p></li>
				<li>Create tests using the <strong class="source-inline">Midje</strong> library to load orders:<p class="source-code">(facts "Empty vector should be returned when there is no orders file"</p><p class="source-code">       (fact (load-orders "/tmp/data.edn") =&gt; [])</p><p class="source-code">       (fact (load-orders "/tmp/no-data.edn") =&gt; []))</p><p>The output is as follows:</p><div id="_idContainer344" class="IMG---Figure"><img src="image/B14502_10_59.jpg" alt="Figure 10.59: Test for loading orders using the Midje library&#13;&#10;"/></div><p class="figure-caption">Figure 10.59: Test for loading orders using the Midje library</p></li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to displaying the orders messages. Import the <strong class="source-inline">test.check</strong> namespaces:<p class="source-code"> (ns coffee-app.utils-test-check</p><p class="source-code">    (:require [coffee-app.utils :refer :all]</p><p class="source-code">      [clojure.test.check :as tc]</p><p class="source-code">      [clojure.test.check.generators :as gen]</p><p class="source-code">      [clojure.test.check.properties :as prop]</p><p class="source-code">      [clojure.test.check.clojure-test :refer [defspec]]))</p></li>
				<li>Test displaying the order function:<p class="source-code">(defspec display-order-test-check 1000</p><p class="source-code">         (prop/for-all [order (gen/fmap (fn [[number type price]]</p><p class="source-code">                                            {:number number</p><p class="source-code">                                             :type type</p><p class="source-code">                                             :price price})</p><p class="source-code">                                        (gen/tuple (gen/large-integer* {:min                                           0})</p><p class="source-code">                                                   gen/keyword</p><p class="source-code">                                                   (gen/double* {:min 0.1 :max 999 :infinite? false :NaN? false} )))]</p><p class="source-code">                       (= (str "Bought " (:number order) " cups of " (name (:type order)) " for €" (:price order)) (display-order order))))</p></li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to check whether the file exists:<p class="source-code">(defspec file-exists-test-check 1000</p><p class="source-code">         (prop/for-all [file gen/string-alphanumeric]</p><p class="source-code">                       (false? (file-exists file))))</p></li>
				<li>Create tests using <strong class="source-inline">test.check</strong> to load orders:<p class="source-code">(defspec load-orders-test-check 1000</p><p class="source-code">         (prop/for-all [file gen/string-alphanumeric]</p><p class="source-code">                       (vector? (load-orders file))))</p><p>The output is as follows:</p><div id="_idContainer345" class="IMG---Figure"><img src="image/B14502_10_60.jpg" alt="Figure 10.60: Using test.check to create tests for loading orders&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.60: Using test.check to create tests for loading orders</p>
			<p>In this activity, we created a test suite for the coffee-ordering application. We wrote tests for utility functions using four unit testing libraries. We started with tests using <strong class="source-inline">clojure.test</strong>, followed by tests with <strong class="source-inline">Expectations</strong> and <strong class="source-inline">Midje</strong>. Finally, we wrote property-based tests using the <strong class="source-inline">test.check</strong> library.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor494"/>Activity 10.02: Support Desk Application with Tests</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Add the testing dependencies to the <strong class="source-inline">project.clj</strong> file:<p class="source-code">:dependencies [[org.clojure/test.check "0.10.0"]]</p></li>
				<li>Import the namespaces to the <strong class="source-inline">core_test.cljs</strong> file:<p class="source-code">(ns support-desk.core-test</p><p class="source-code">  (:require</p><p class="source-code">    [cljs.test :refer-macros [are deftest is testing use-fixtures]]</p><p class="source-code">    [clojure.test.check.generators :as gen]</p><p class="source-code">    [clojure.test.check.properties :refer-macros [for-all]]</p><p class="source-code">    [clojure.test.check.clojure-test :refer-macros [defspec]]</p><p class="source-code">    [cuerdas.core :as str]</p><p class="source-code">    [support-desk.utils :refer [delete-item-from-list-by-title get-priorities-list get-sort-message get-sorted-priorities-list handle-sort-finish]]))</p></li>
				<li>Create fixtures with issues in the application state:<p class="source-code">(ns support-desk.core-test)</p><p class="source-code">(use-fixtures :each</p><p class="source-code">              {:before (fn [] (do</p><p class="source-code">                                (def priorities-list [{:title "IE bugs" :priority 2} {:title "404 page" :priority 1} {:title "Forgotten username" :priority 2}</p><p class="source-code">                                                      {:title "Login token" :priority 1} {:title "Mobile version" :priority 3} {:title "Load time" :priority 5}])</p><p class="source-code">                                (def app-state (atom {:sort-counter 0}))))})</p></li>
				<li>Write tests for the sort message function using <strong class="source-inline">cljs.test</strong>:<p class="source-code">(deftest get-sort-message-test</p><p class="source-code">         (testing "Using is macro"</p><p class="source-code">                  (is (= "little (1)" (get-sort-message 1)))</p><p class="source-code">                  (is (= "medium (4)" (get-sort-message 4)))</p><p class="source-code">                  (is (= "many (8)" (get-sort-message 8))))</p><p class="source-code">         (testing "Using are macro"</p><p class="source-code">                  (are [result number] (= result (get-sort-message number))</p><p class="source-code">                       "little (1)" 1</p><p class="source-code">                       "little (2)" 2</p><p class="source-code">                       "medium (3)" 3</p><p class="source-code">                       "medium (4)" 4</p><p class="source-code">                       "medium (5)" 5</p><p class="source-code">                       "many (6)" 6)))</p></li>
				<li>Write tests for the sort message function using <strong class="source-inline">test.check</strong>:<p class="source-code">(defspec get-sort-message-test-check 10</p><p class="source-code">         (for-all [count gen/nat]</p><p class="source-code">                  (= (str/format "%s (%s)"</p><p class="source-code">                                 (cond</p><p class="source-code">                                   (&lt; count 3) "little"</p><p class="source-code">                                   (&lt; count 6) "medium"</p><p class="source-code">                                   :else "many")</p><p class="source-code">                                 count)</p><p class="source-code">                     (get-sort-message count))))</p></li>
				<li>Write tests for the filter issues by priority function using <strong class="source-inline">cljs.test</strong>:<p class="source-code">(deftest get-priorities-list-test</p><p class="source-code">         (testing "Testing filtering priorities based on priority number"</p><p class="source-code">                  (is (= []</p><p class="source-code">                         (get-priorities-list priorities-list 0)))</p><p class="source-code">                  (is (= [{:title "404 page", :priority 1} {:title "Login token",                     :priority 1}]</p><p class="source-code">                         (get-priorities-list priorities-list 1)))</p><p class="source-code">                  (is (= [{:title "IE bugs", :priority 2}</p><p class="source-code">                          {:title "404 page", :priority 1}</p><p class="source-code">                          {:title "Forgotten username", :priority 2}</p><p class="source-code">                          {:title "Login token", :priority 1}]</p><p class="source-code">                         (get-priorities-list priorities-list 2)))</p><p class="source-code">                  (is (=</p><p class="source-code">                        [{:title "IE bugs", :priority 2}</p><p class="source-code">                         {:title "404 page", :priority 1}</p><p class="source-code">                         {:title "Forgotten username", :priority 2}</p><p class="source-code">                         {:title "Login token", :priority 1}</p><p class="source-code">                         {:title "Mobile version", :priority 3}]</p><p class="source-code">                        (get-priorities-list priorities-list 3)))))</p></li>
				<li>Write tests to sort the issues list using <strong class="source-inline">cljs.test</strong>:<p class="source-code">(deftest get-sorted-priorities-list-test</p><p class="source-code">         (testing "Sorting priorities list"</p><p class="source-code">                  (is (= [{:title "404 page", :priority 1}</p><p class="source-code">                          {:title "Login token", :priority 1}</p><p class="source-code">                          {:title "IE bugs", :priority 2}</p><p class="source-code">                          {:title "Forgotten username", :priority 2}</p><p class="source-code">                          {:title "Mobile version", :priority 3}</p><p class="source-code">                          {:title "Load time", :priority 5}]</p><p class="source-code">                         (get-sorted-priorities-list priorities-list)))))</p></li>
				<li>Write tests to delete issues from the list using <strong class="source-inline">cljs.test</strong>:<p class="source-code">(deftest delete-item-from-list-by-title-test</p><p class="source-code">         (testing "Passing empty list"</p><p class="source-code">                  (is (= []</p><p class="source-code">                         (delete-item-from-list-by-title "Login token" [])))</p><p class="source-code">                  (is (= []</p><p class="source-code">                        (delete-item-from-list-by-title "Login token" nil))))</p><p class="source-code">         (testing "Passing valid list"</p><p class="source-code">                  (is (= (delete-item-from-list-by-title "Login token"                     priorities-list)))))</p></li>
				<li>Write tests for the handle the sort function using <strong class="source-inline">cljs.test</strong>:<p class="source-code">(deftest handle-sort-finish-test</p><p class="source-code">         (testing "Calling fn once"</p><p class="source-code">                  (is (= {:sort-counter 1}</p><p class="source-code">                         ((handle-sort-finish app-state) "event"                            "object"))))</p><p class="source-code">         (testing "Calling fn twice"</p><p class="source-code">                  (is (= {:sort-counter 2}</p><p class="source-code">                        ((handle-sort-finish app-state) "event"                            "object")))))</p></li>
				<li>We will use the command line to run the tests:<p class="source-code">lein fig:test</p><p>When the tests are run, they should show the following:</p><div id="_idContainer346" class="IMG---Figure"><img src="image/B14502_10_61.jpg" alt="Figure 10.61: Output after running the tests&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 10.61: Output after running the tests</p>
			<p>In this activity, we added ClojureScript tests to a support desk application. We wrote unit tests using <strong class="source-inline">cljs.test</strong> and property-based tests using the <strong class="source-inline">test.check</strong> library.</p>
			<h1 id="_idParaDest-376"><a id="_idTextAnchor495"/>11. Macros</h1>
			<h2 id="_idParaDest-377">Activity 11.01: A Tennis CSV Ma<a id="_idTextAnchor496"/>cro</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Here is one possibility for the expanded code:<p class="source-code">(with-open [reader (io/reader csv)]</p><p class="source-code">  (-&gt;&gt; (csv/read-csv reader)</p><p class="source-code">       sc/mappify</p><p class="source-code">       (sc/cast-with {:winner_games_won sc/-&gt;int</p><p class="source-code">                      :loser_games_won sc/-&gt;int})</p><p class="source-code">       (map #(assoc % :games_diff (- (:winner_games_won %) (:loser_games_won %))))</p><p class="source-code">       (filter #(&gt; (:games_diff %) threshold))</p><p class="source-code">       (map #(select-keys % [:winner_name :loser_name :games_diff]))</p><p class="source-code">       doall))</p><p>This should be taken as a rough sketch for the final output.   </p></li>
				<li>Set up your project. The <strong class="source-inline">deps.edn</strong> file should look like this:<p class="source-code">{:deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}</p><p class="source-code">  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}}}</p><p>The namespace declaration of the <strong class="source-inline">tennis_macro.clj</strong> file should look like this:</p><p class="source-code">(ns packt-clj.tennis-macro</p><p class="source-code">    (:require [clojure.java.io :as io]</p><p class="source-code">              [clojure.data.csv :as csv]</p><p class="source-code">              [semantic-csv.core :as sc]))</p></li>
				<li>The macro's call signature should look like this:<p class="source-code"><strong class="source-inline">(defmacro with-tennis-csv [csv casts fields &amp; forms])</strong></p><p>Because the macro needs to be able to handle a variable number of forms, we use <strong class="source-inline">&amp; forms</strong>, which will provide us with a list of forms inside the body of the macro.</p></li>
				<li>Add the <strong class="source-inline">with-open</strong> and  <strong class="source-inline">-&gt;&gt;</strong> expressions and add the threaded function calls that never change. Don't forget to use a gensym for the <strong class="source-inline">reader</strong> binding:<p class="source-code">(defmacro with-tennis-csv [csv casts fields &amp; forms]</p><p class="source-code">  '(with-open [reader# (io/reader ~csv)]</p><p class="source-code">     (-&gt;&gt; (csv/read-csv reader#)</p><p class="source-code">          sc/mappify</p><p class="source-code">          (sc/cast-with ~casts)</p><p class="source-code">          ;; TODO: what goes here?</p><p class="source-code">          doall)))</p><p>It turns out that if <strong class="source-inline">sc/cast-with</strong> is supplied with an empty <strong class="source-inline">map</strong>, that is, no fields to change, it simply changes nothing. On the other hand, <strong class="source-inline">select-keys</strong> does the opposite: with no keys to preserve, it returns an empty <strong class="source-inline">map</strong>. It will require some more logic so that when no fields are provided, we get all the fields, rather than no fields at all. That's why we haven't included it yet.</p></li>
				<li>Use unquote-splice (<strong class="source-inline">~@</strong>) to insert the threaded forms:<p class="source-code">(defmacro with-tennis-csv [csv casts fields &amp; forms]</p><p class="source-code">  '(with-open [reader# (io/reader ~csv)]</p><p class="source-code">     (-&gt;&gt; (csv/read-csv reader#)</p><p class="source-code">          sc/mappify</p><p class="source-code">          (sc/cast-with ~casts)</p><p class="source-code">          ~@forms</p><p class="source-code">          ;; TODO: select-keys</p><p class="source-code">          doall)))</p></li>
				<li>We need a way to conditionally apply <strong class="source-inline">select-keys</strong>, depending on whether or not there are fields to select or not. There are a lot of ways to solve this, but perhaps the simplest is to define a specialized version of <strong class="source-inline">select-keys</strong>. We'll call it <strong class="source-inline">maybe-select-keys</strong>:<p class="source-code">(defn maybe-select-keys [m maybe-keys]</p><p class="source-code">  (if (seq maybe-keys)</p><p class="source-code">    (select-keys m maybe-keys)</p><p class="source-code">    m))</p><p>This allows us to add a call to <strong class="source-inline">map</strong> that can be the same, regardless of the presence of fields to select or not:</p><p class="source-code"> (defmacro with-tennis-csv [csv casts fields &amp; forms]</p><p class="source-code">  '(with-open [reader# (io/reader ~csv)]</p><p class="source-code">     (-&gt;&gt; (csv/read-csv reader#)</p><p class="source-code">          sc/mappify</p><p class="source-code">          (sc/cast-with ~casts)</p><p class="source-code">          ~@forms</p><p class="source-code">          (map #(maybe-select-keys % ~fields))</p><p class="source-code">          doall)))</p><p>Many other solutions to this part of the problem probably involve referring to fields more than once. In these cases, a gensym should be used:</p><p class="source-code">  (let [fields# ~fields]</p><p class="source-code">    )</p></li>
				<li>Test the macro. Let's try it with the <strong class="source-inline">blowouts</strong> function (this assumes that the CSV file has been copied into the project directory):<p class="source-code">user&gt; (blowouts "match_scores_1991-2016_unindexed_csv.csv" 16)</p><p class="source-code">({:winner_name "Jean-Philippe Fleurian",</p><p class="source-code">  :loser_name "Renzo Furlan",</p><p class="source-code">  :games_diff 17}</p><p class="source-code"> {:winner_name "Todd Witsken",</p><p class="source-code">  :loser_name "Kelly Jones",</p><p class="source-code">  :games_diff 17}</p><p class="source-code"> {:winner_name "Nicklas Kulti",</p><p class="source-code">  :loser_name "German Lopez",</p><p class="source-code">  :games_diff 17}</p><p class="source-code"> {:winner_name "Jim Courier",</p><p class="source-code">  :loser_name "Gilad Bloom",</p><p class="source-code">  :games_diff 16}</p><p class="source-code"> {:winner_name "Andrei Medvedev",</p><p class="source-code">  :loser_name "Lars Koslowski",</p><p class="source-code">  :games_diff 17}</p><p class="source-code">;;; etc.</p><p class="source-code">)</p><p>These are the most lopsided victories in the dataset. Our macro seems to work.</p><p>Here, we've obtained a list of all the players who have defeated Roger Federer (from 1991 to 2016):</p><p class="source-code">user&gt; (with-tennis-csv "match_scores_1991-2016_unindexed_csv.csv"</p><p class="source-code">   {}</p><p class="source-code">   [:winner_name]</p><p class="source-code">   (filter #(= "Roger Federer" (:loser_name %))))</p><p class="source-code">({:winner_name "Lucas Arnold Ker"}</p><p class="source-code"> {:winner_name "Jan Siemerink"}</p><p class="source-code"> {:winner_name "Andre Agassi"}</p><p class="source-code"> {:winner_name "Arnaud Clement"}</p><p class="source-code"> {:winner_name "Yevgeny Kafelnikov"}</p><p class="source-code"> {:winner_name "Kenneth Carlsen"}</p><p class="source-code"> {:winner_name "Vincent Spadea"}</p><p class="source-code"> {:winner_name "Patrick Rafter"}</p><p class="source-code"> {:winner_name "Byron Black"}</p><p class="source-code"> ;; .... etc.</p><p class="source-code"> )</p></li>
			</ol>
			<p>There is one question that should always be asked when writing a macro: could this be a function instead? The answer here is probably somewhere between "yes" and "maybe."</p>
			<p>One approach might be to write a function that simply extracts all the data from the CSV file. After passing through <strong class="source-inline">doall</strong>, any kind of transformation would be possible. With this solution, however, the benefits of lazy evaluation would be lost, which means that the entire CSV file would need to be loaded into memory. If one of the processing steps involves filtering out some of the matches, the macro solution would be more efficient because the filtering would occur before the entire file was read.</p>
			<p>Another approach would be to use functional composition. The user would supply a series of functions that would be wrapped inside a single function called from inside the <strong class="source-inline">with-open</strong> macro. This approach would preserve the advantages of lazy evaluation. However, the supplied functions would have to be written in a precise way that might not be as clear. Here, we've been writing the following:</p>
			<p class="source-code">(filter #(&gt; (:games_diff %) threshold))</p>
			<p>Instead, we would have to define a function:</p>
			<p class="source-code">(fn [ms] (filter #(&gt; (:games_diff %)) threshold))</p>
			<p>This might not be a deal-breaker. Everything depends on the intended use and the intended audience. Macros can often provide a very flexible interface, which can be an important factor in choosing to use them.</p>
			<p>When you find yourself repeating code that cannot be easily encapsulated with functions, for whatever reason, writing a macro can often be the solution. In this case, as in <em class="italic">Exercise 11.04</em>, <em class="italic">Monitoring Functions</em> writing a macro is probably the least obtrusive way to simplify your code. Writing a macro is always a trade-off in terms of added complexity: as we said at the beginning of this chapter, macro code is hard to debug, and it can make the rest of your code harder to debug as well. But, as is often said, code you never need to debug is code you don't have to write. So, if a solid macro can help you avoid writing many lines of code, it might be worth it.</p>
			<h1 id="_idParaDest-378"><a id="_idTextAnchor497"/>12. Concurrency</h1>
			<h2 id="_idParaDest-379">Activit<a id="_idTextAnchor498"/>y 12.01: A DOM Whack-a-mole Game</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Create a project with <strong class="source-inline">lein figwheel</strong>:<p class="source-code">lein new figwheel packt-clj.dom-whackamole -- --rum</p></li>
				<li>Move to the new <strong class="source-inline">packt-clj.dom-whackamole</strong> directory and start a ClojureScript REPL:<p class="source-code">lein figwheel</p><p>In your browser, at <strong class="source-inline">localhost:3449/index.html</strong>, you should see the default Figwheel page:</p><div id="_idContainer347" class="IMG---Figure"><img src="image/B14502_12_26.jpg" alt="Figure 12.26: Default Figwheel page&#13;&#10;"/></div><p class="figure-caption">Figure 12.26: Default Figwheel page</p></li>
				<li>Open <strong class="source-inline">dom-whackamole/src/packt-clj/dom-whackamole/core.cljs</strong> in your editor or IDE. This is where you will write all the remaining code.</li>
				<li>Define the atoms that will determine the game's state:<p class="source-code">(def game-length-in-seconds 20)</p><p class="source-code">(def millis-remaining (atom (* game-length-in-seconds 1000)))</p><p class="source-code">(def points (atom 0))</p><p class="source-code">(def game-state (atom :waiting))</p><p class="source-code">(def clock-interval (atom nil))</p><p class="source-code">(def moles (atom (into []</p><p class="source-code">            (repeat 5 {:status :waiting</p><p class="source-code">                 :remaining-millis 0}))))</p><p>Most of these are fairly self-explanatory. The <strong class="source-inline">clock-interval</strong> atom will be set to a JavaScript interval when the game starts. Defining <strong class="source-inline">game-length-in-seconds</strong> and then multiplying by 1,000 isn't necessary but it helps to make our code more readable.</p><p>The <strong class="source-inline">moles</strong> atom will be a vector of maps with <strong class="source-inline">:status</strong> and <strong class="source-inline">:remaining-millis</strong> fields. Why type out five identical maps when <strong class="source-inline">repeat</strong> can do the work for us? Later, we'll update the moles using their index in the vector, which is why we really want to have a vector here, and not a list. By itself, <strong class="source-inline">repeat</strong> would return a simple list. To avoid that, we use <strong class="source-inline">(into [] …)</strong> to be sure we have a real vector.</p></li>
				<li>Another equally valid approach would be to wrap all of these items in a single atom that could be structured like this:<p class="source-code">(def app-state</p><p class="source-code"> (atom</p><p class="source-code">  {:points 0</p><p class="source-code">   :millis-remaining (* game-length-in-seconds 1000)</p><p class="source-code">   :game-state :waiting</p><p class="source-code">   :clock-interval nil</p><p class="source-code">   :moles (into []</p><p class="source-code">         (repeat 5 {:status :waiting</p><p class="source-code">               :remaining-millis 0}))}))</p><p>This approach would mean changing most of the functions involving data access but would not fundamentally change how the game is built.</p><p class="callout-heading">Note</p><p class="callout">Generally, in more complex applications, the single atom approach would be preferable. The downside to this is that any change to the atom would cause all the components to update. If only one part of the multi-level map contained in the atom has changed, many of these updates would be useless. To avoid this, React-based ClojureScript frameworks all have some means for tracking changes to only one part of the application state atom. Rum, as well as Om and Reagent, calls these cursors. A cursor allows a component to listen to a particular part of the atom state, thus avoiding unnecessary re-renders when unrelated parts of the atom change.</p></li>
				<li>Define functions for making changes to the application state atoms:<p class="source-code">(defn activate-mole [mole-idx]</p><p class="source-code"> (swap! moles</p><p class="source-code">     (fn [ms]</p><p class="source-code">      (update ms mole-idx</p><p class="source-code">          #(if (= :waiting (:status %))</p><p class="source-code">           {:status :live :remaining-millis 3000}</p><p class="source-code">           %)))))</p><p class="source-code">(defn deactivate-mole [mole-idx]</p><p class="source-code"> (swap! moles</p><p class="source-code">     (fn [ms]</p><p class="source-code">      (assoc ms mole-idx</p><p class="source-code">          {:status :waiting :remaining-millis 0}))))</p></li>
				<li>The first two functions are fairly straightforward. <strong class="source-inline">activate-mole</strong> uses <strong class="source-inline">update</strong> instead of <strong class="source-inline">assoc</strong> in order to test whether the mole is already activated or not. If it is already <strong class="source-inline">:live</strong>, we don't want to change the number of remaining milliseconds back to 3,000:<p class="source-code-heading">core.cljs</p><p class="source-code">43 (defn mole-countdown []</p><p class="source-code">44  (swap! moles</p><p class="source-code">45      (fn [ms]</p><p class="source-code">46       (into []</p><p class="source-code">47          (map (fn [m]</p><p class="source-code">48             (if (= (:status m) :live)</p><p class="source-code">49              (let [new-remaining (max (- (:remaining-millis m) 100)                   0)]</p><p class="source-code">50               (if (pos? new-remaining)</p><p class="source-code">51                (assoc m :remaining-millis new-remaining)</p><p class="source-code">52                {:status :waiting :remaining-millis 0}))</p><p class="source-code">53              m))</p><p class="source-code">54            ms)))))</p><p class="source-code-link">The full code for this step is available at <a href="https://packt.live/2Rmq8aq">https://packt.live/2Rmq8aq</a>.</p><p>These functions are the heart of the game's logic.</p><p>The first function, <strong class="source-inline">mole-countdown</strong>, removes 100 from the <strong class="source-inline">:remaining-millis</strong> field of any active moles. To do this, it maps over the list of moles. If a mole is not <strong class="source-inline">:live</strong>, it is left alone. (We can't use <strong class="source-inline">filter</strong> here because we don't want to eliminate the inactive moles; we only want to ignore them.) If the mole is <strong class="source-inline">:live</strong>, we subtract 100 from the remaining time. If there is still time left, we just update the remaining time in the mole. If we've reached zero, though, we set the status back to <strong class="source-inline">:waiting</strong>. This is the case when the player has not clicked on the mole after 3 seconds.</p><p>The next function, <strong class="source-inline">update-moles</strong>, will be called on each 100-millisecond tick of the game clock. It calls <strong class="source-inline">mole-countdown</strong> and then checks whether there are enough active moles in the list. If there aren't two active moles, <strong class="source-inline">activate-mole</strong> is called with a random index between 0 and 4.</p><p>You might be surprised that we don't check to see whether the mole we are activating here is already <strong class="source-inline">:live</strong> or not. Because this check will happen every 100 milliseconds (and because the gameplay of Whack-a-mole doesn't require extreme precision), we can avoid doing so. If we try to activate an already active mole, nothing will happen (thanks to how we wrote <strong class="source-inline">activate-mole</strong>) and we can try again on the next clock tick.</p><p>The <strong class="source-inline">reset-moles</strong> function will be called when the game clock gets to zero. All the moles hide when the game is over.</p><p>Finally, the <strong class="source-inline">whack!</strong> function will actually be the click handler. It looks up the mole by its index and then calls <strong class="source-inline">deactivite-mole</strong> if the mole happens to be <strong class="source-inline">:live</strong>, in which case it also adds a point to the player's score.</p><p>It's important to note here that all of these functions interact directly with the atoms. They all use <strong class="source-inline">deref</strong> (via the <strong class="source-inline">@</strong> reader macro) and not <strong class="source-inline">rum/react</strong>. All of this logic, so far, is independent of the Rum components.</p></li>
				<li>Write the game clock functions:<p class="source-code">(defn clock-tick []</p><p class="source-code"> (if (= @millis-remaining 0)</p><p class="source-code">  (do</p><p class="source-code">   (reset! game-state :waiting)</p><p class="source-code">   (reset-moles))</p><p class="source-code">  (do</p><p class="source-code">   (update-moles)</p><p class="source-code">   (swap! millis-remaining #(- % 100)))))</p><p class="source-code">(defn start-clock []</p><p class="source-code"> (when @clock-interval</p><p class="source-code">  (js/clearInterval @clock-interval))</p><p class="source-code"> (swap! clock-interval</p><p class="source-code">     (fn [] (js/setInterval clock-tick 100))))</p><p>The <strong class="source-inline">clock-tick</strong> function determines what happens every 100 milliseconds. Either the game is over (<strong class="source-inline">millis-remaining</strong> has reached zero) or it is still going. If the game is over, we reset the moles and change the game state back to <strong class="source-inline">:waiting</strong>. If not, we call <strong class="source-inline">update-moles</strong> to advance their internal time counters and then we advance the global <strong class="source-inline">millis-remaining</strong> atom.</p><p>The <strong class="source-inline">start-clock</strong> function does just that. The first step here is to check for an existing interval and stop it. We definitely don't want more than one interval running at the same time. (If you notice the clock running at a very fast rate, that is probably what is happening.)</p><p>Our call to <strong class="source-inline">swap!</strong> is then just a call to <strong class="source-inline">setInterval</strong> with the <strong class="source-inline">clock-tick</strong> function and the 100-millisecond interval.</p></li>
				<li>Now we're ready to write our <strong class="source-inline">start-game</strong> function that will be called when the user clicks on the <strong class="source-inline">Start</strong> button:<p class="source-code">(defn start-game []</p><p class="source-code"> (start-clock)</p><p class="source-code"> (reset! game-state :playing)</p><p class="source-code"> (reset! points 0)</p><p class="source-code"> (reset! millis-remaining (* game-length-in-seconds 1000)))</p></li>
				<li>Let's start writing some simple Rum components that just display the current state:<p class="source-code">(rum/defc clock &lt; rum/reactive []</p><p class="source-code"> [:div.clock</p><p class="source-code">  [:span "Remaining time: "]</p><p class="source-code">  [:span.time</p><p class="source-code">  (Math/floor (/ (rum/react millis-remaining) 1000))]])</p><p class="source-code">(rum/defc score &lt; rum/reactive []</p><p class="source-code"> [:div.score</p><p class="source-code">  [:span "Score: "]</p><p class="source-code">  [:span (rum/react points)]])</p><p>The <strong class="source-inline">clock</strong> and <strong class="source-inline">score</strong> views simply display those values. Since we don't want to actually display milliseconds on the clock, we divide by 1,000. And since we don't want show times like 5.034, we round down using the <strong class="source-inline">floor</strong> method from the JavaScript <strong class="source-inline">Math</strong> library. (Don't worry if you don't know about this JavaScript library: displaying milliseconds works fine for this exercise.)</p></li>
				<li>Write a component for the <strong class="source-inline">start-game</strong> button:<p class="source-code">(rum/defc start-game-button &lt; rum/reactive []</p><p class="source-code"> (if (= (rum/react game-state) :waiting)</p><p class="source-code">  [:button</p><p class="source-code">   {:onClick start-game}</p><p class="source-code">   "Click to play!"]</p><p class="source-code">  [:div "Game on!"]))</p><p>The <strong class="source-inline">start-game-button</strong> view observes the <strong class="source-inline">game-state</strong> atom and shows either a <strong class="source-inline">Click to play!</strong> button or an encouraging message.</p></li>
				<li>Write the mole views:<p class="source-code">(rum/defc single-mole-view [mole-idx {:keys [status remaining-millis]}]</p><p class="source-code"> [:div {:class [(str "mole " (name status))]}</p><p class="source-code">  [:a {:onClick (partial whack! mole-idx)}</p><p class="source-code">  (str "MOLE " (name status) "!")]])</p><p class="source-code">(rum/defc moles-view &lt; rum/reactive []</p><p class="source-code"> (let [ms (rum/react moles)]</p><p class="source-code">  [:div {:class "game moles"}</p><p class="source-code">   (single-mole-view 0 (first ms))</p><p class="source-code">   (single-mole-view 1 (second ms))</p><p class="source-code">   (single-mole-view 2 (nth ms 2))</p><p class="source-code">   (single-mole-view 3 (nth ms 3))</p><p class="source-code">   (single-mole-view 4 (nth ms 4))]))</p><p>A lot of important game logic is related to the moles, so we split out a separate <strong class="source-inline">mole</strong> component. Notice that <strong class="source-inline">single-mole-view</strong> does not have the <strong class="source-inline">&lt; rum/reactive</strong> mixin. These views will get all of their props from their parent view. As a result, they do not need to react directly to changes in the atoms; they will receive the changes through their arguments.</p><p>The <strong class="source-inline">single-mole-view</strong> displays the state of the mole, <strong class="source-inline">:waiting</strong> or <strong class="source-inline">:live</strong>, and sets up the click handler. We've set up the <strong class="source-inline">whack!</strong> function to do nothing if the mole's status is <strong class="source-inline">:waiting</strong>, so we don't have to add any logic about that here.</p><p>The <strong class="source-inline">moles-view</strong> simply wraps the calls to <strong class="source-inline">single-mole-view</strong> in a <strong class="source-inline">&lt;div&gt;</strong> element and provides them with the appropriate data from the <strong class="source-inline">moles</strong> atom.</p></li>
				<li>Write the base view:<p class="source-code">(rum/defc app []</p><p class="source-code"> [:div#main</p><p class="source-code">  [:div.header</p><p class="source-code">  [:h1 "Welcome to DOM Whack-a-mole"]</p><p class="source-code">  [:p "When a MOLE goes goes 'live', click on it as fast as you can."]</p><p class="source-code">  (start-game-button)</p><p class="source-code">  (clock)</p><p class="source-code">  (score)]</p><p class="source-code">  (moles-view)])</p><p>The <strong class="source-inline">app</strong> view simply reunites all the previous views in a single while providing some additional presentation.</p></li>
				<li>Make sure that you the <strong class="source-inline">app</strong> view is mounted at the end of your file:<p class="source-code">(defn on-js-reload []</p><p class="source-code"> (rum/mount (app) (.getElementById js/document "app")))</p><p class="source-code">(on-js-reload)</p><p>The call to <strong class="source-inline">on-js-reload</strong> ensures that your code is read again when the browser reloads.</p><p>Now you can play the game!:</p><div id="_idContainer348" class="IMG---Figure"><img src="image/B14502_12_27.jpg" alt="Figure 12.27: Playing DOM Whack-a-mole&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.27: Playing DOM Whack-a-mole</p>
			<h1 id="_idParaDest-380"><a id="_idTextAnchor499"/>13. Database Interaction and the Application Layer</h1>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor500"/>Activity 13.01: Persisting Historic Tennis Results and ELO Calculations</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">In a new project, begin with the following dependencies:<p class="source-code">{:deps {clojure.java-time {:mvn/version "0.3.2"}</p><p class="source-code">        hikari-cp {:mvn/version "2.8.0"}</p><p class="source-code">        org.apache.derby/derby {:mvn/version "10.14.2.0"}</p><p class="source-code">        org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">        org.clojure/java.jdbc {:mvn/version "0.7.9"}</p><p class="source-code">        semantic-csv {:mvn/version "0.2.1-alpha1"}}}</p></li>
				<li>In our <strong class="source-inline">src</strong> directory, create the following namespaces:<p class="source-code">packt-clj.tennis.database</p><p class="source-code">packt-clj.tennis.elo</p><p class="source-code">packt-clj.tennis.ingest</p><p class="source-code">packt-clj.tennis.parse</p><p class="source-code">packt-clj.tennis.query</p></li>
				<li>Creating our connection pool in the database namespace is straightforward using <strong class="source-inline">hikari</strong>:<p class="source-code">(ns packt-clj.tennis.database</p><p class="source-code">  (:require</p><p class="source-code">    [hikari-cp.core :as hikari]))</p><p class="source-code">(def db {:datasource (hikari/make-datasource {:jdbc-url "jdbc:derby:tennis;create=true"})})</p></li>
				<li>Our DDL should look similar to the following. Field data types may vary, although not significantly:<p class="source-code">(def ^:private create-player-ddl "CREATE TABLE player (</p><p class="source-code">  id varchar(4) CONSTRAINT PLAYER_ID_PK PRIMARY KEY,</p><p class="source-code">  full_name varchar(128))")</p><p class="source-code">(def ^:private create-tennis-match-ddl "CREATE TABLE tennis_match (</p><p class="source-code">  id varchar(32) CONSTRAINT MATCH_ID_PK PRIMARY KEY,</p><p class="source-code">  tournament_year int,</p><p class="source-code">  tournament varchar(32),</p><p class="source-code">  tournament_order int,</p><p class="source-code">  round_order int,</p><p class="source-code">  match_order int,</p><p class="source-code">  winner_id varchar(4) REFERENCES player(id) ON DELETE CASCADE,</p><p class="source-code">  loser_id varchar(4) REFERENCES player(id) ON DELETE CASCADE)")</p><p class="source-code">(def ^:private create-elo-ddl "CREATE TABLE elo (</p><p class="source-code">  id int GENERATED ALWAYS AS IDENTITY CONSTRAINT ELO_ID_PK PRIMARY KEY,</p><p class="source-code">  player_id varchar(4) REFERENCES player(id) ON DELETE CASCADE,</p><p class="source-code">  rating DECIMAL(6,2))")</p></li>
				<li>Leveraging <strong class="source-inline">clojure.java.jdbc</strong>, we can apply the schema, taking care of the ordering:<p class="source-code">(ns packt-clj.tennis.database</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]</p><p class="source-code">    [hikari-cp.core :as hikari]))</p><p class="source-code">(defn load []</p><p class="source-code">  (jdbc/db-do-commands db [create-player-ddl create-tennis-match-ddl create-elo-ddl]))</p><p class="source-code">(require '[packt-clj.tennis.database :as database])</p><p class="source-code">user=&gt; (database/load)</p><p class="source-code">(0 0 0)</p></li>
				<li>This is perhaps one of the more creative aspects of the activity, meaning that there are many ways to solve the problem, with the following only being one of them.<p>In the <strong class="source-inline">parse</strong> namespace, we begin by defining the accessors required to extract each of the fields we're interested in:</p><p class="source-code">(ns packt-clj.tennis.parse</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.string :as str]))</p><p class="source-code">(def ^:private winning-player-accessors</p><p class="source-code">  {:id        :winner_player_id</p><p class="source-code">   :full_name :winner_name})</p><p class="source-code">(def ^:private losing-player-accessors</p><p class="source-code">  {:id        :loser_player_id</p><p class="source-code">   :full_name :loser_name})</p><p class="source-code">(def ^:private match-accessors</p><p class="source-code">  {:id               #(str (:match_id %) "-" (:round_order %))</p><p class="source-code">   :tournament_year  (comp first #(str/split % #"-") :tourney_year_id)</p><p class="source-code">   :tournament       :tourney_slug</p><p class="source-code">   :tournament_order :tourney_order</p><p class="source-code">   :round_order      :round_order</p><p class="source-code">   :match_order      :match_order</p><p class="source-code">   :winner_id        :winner_player_id</p><p class="source-code">   :loser_id         :loser_player_id})</p><p>Each preceding definition is a map of <strong class="source-inline">target-key</strong> (that is, where we want to store the value in our data structure) to <strong class="source-inline">accessor</strong> (that is, a single-arity function that, given a row, will extract, format, and aggregate fields as required).</p></li>
				<li>We can then define a function that will perform the application of these accessors on any given row:<p class="source-code">(defn apply-accessors</p><p class="source-code">  [row accessors]</p><p class="source-code">  (reduce-kv</p><p class="source-code">    (fn [acc target-key accessor]</p><p class="source-code">      (assoc acc target-key (accessor row)))</p><p class="source-code">    {}</p><p class="source-code">    accessors))</p></li>
				<li>Some well-named helper functions can be defined to perform the extraction for each of our target structures, which are combined in a simple <strong class="source-inline">parse-row</strong> function:<p class="source-code">(defn extract-winning-player</p><p class="source-code">  [row]</p><p class="source-code">  (apply-accessors row winning-player-accessors))</p><p class="source-code">(defn extract-losing-player</p><p class="source-code">  [row]</p><p class="source-code">  (apply-accessors row losing-player-accessors))</p><p class="source-code">(defn extract-match</p><p class="source-code">  [row]</p><p class="source-code">  (apply-accessors row match-accessors))</p><p class="source-code">(defn parse-row</p><p class="source-code">  [row]</p><p class="source-code">  {:winning-player (extract-winning-player row)</p><p class="source-code">   :losing-player  (extract-losing-player row)</p><p class="source-code">   :match          (extract-match row)})</p></li>
				<li>Finally, we can combine these into our historic function as follows, adding the relevant requires:<p class="source-code">(ns packt-clj.tennis.parse</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.data.csv :as csv]</p><p class="source-code">    [clojure.java.io :as io]</p><p class="source-code">    [clojure.string :as str]</p><p class="source-code">    [semantic-csv.core :as sc]))</p><p class="source-code">(defn new-player?</p><p class="source-code">  [seen candidate]</p><p class="source-code">  (not (seen (:id candidate))))</p><p class="source-code">(defn historic</p><p class="source-code">  [file-path]</p><p class="source-code">  (-&gt;&gt; (io/reader file-path)</p><p class="source-code">       (csv/read-csv)</p><p class="source-code">       sc/mappify</p><p class="source-code">       (reduce (fn</p><p class="source-code">                 [{:keys [player-ids-seen] :as acc} row]</p><p class="source-code">                 (let [{:keys [winning-player losing-player match]} (parse-row row)</p><p class="source-code">                       new-players (filter #(new-player? player-ids-seen %) [winning-player losing-player])]</p><p class="source-code">                   (-&gt; acc</p><p class="source-code">                       (update-in [:data :players] into new-players)</p><p class="source-code">                       update-in [:data :matches] conj match)</p><p class="source-code">                       (update :player-ids-seen into (map :id new-players)))))</p><p class="source-code">               {:player-ids-seen #{}</p><p class="source-code">                :data            {:players []</p><p class="source-code">                                  :matches []}})</p><p class="source-code">       :data))</p><p>The <strong class="source-inline">reduce</strong> function we've defined here begins by parsing the incoming row into the three target data structures we're interested in: the players (<strong class="source-inline">winning</strong> and <strong class="source-inline">losing</strong>) as well as the match itself. We then check to ensure we're only going to persist a player if we've not already seen it. We do this by checking against the <strong class="source-inline">player-ids-seen</strong> set using the appropriately named <strong class="source-inline">helper</strong> function.</p><p>Finally, we use the thread-first macro to maintain our accumulator, adding new players/matches and maintaining the set of player IDs we've already processed, before extracting the <strong class="source-inline">:data</strong> portion of the map and returning.</p></li>
				<li>In the <strong class="source-inline">ingest</strong> namespace, a simple call to <strong class="source-inline">parse/historic</strong>, along with a destructure in our <strong class="source-inline">let</strong> binding, is enough to extract the players and matches we are going to insert into the <strong class="source-inline">db</strong> variable:<p class="source-code">(ns packt-clj.tennis.ingest</p><p class="source-code">  (:require</p><p class="source-code">    [packt-clj.tennis.parse :as parse]</p><p class="source-code">    [clojure.java.jdbc :as jdbc]))</p><p class="source-code">(defn historic</p><p class="source-code">  [db file-path]</p><p class="source-code">  (let [{:keys [players matches]} (parse/historic file-path)]</p><p class="source-code">    (jdbc/insert-multi! db :player players)</p><p class="source-code">    (jdbc/insert-multi! db :tennis_match matches)))</p></li>
				<li>Having taken the <strong class="source-inline">match_scores_1991-2016_unindexed_csv.csv</strong> file and placed it in the <strong class="source-inline">resources</strong> directory, we can now ingest our historic data and perform a few sanity checks to see whether our <strong class="source-inline">player</strong> and <strong class="source-inline">tennis_match</strong> counts match those as follows:<p class="source-code">(require '[packt-clj.tennis.ingest :as ingest]</p><p class="source-code">         '[clojure.java.jdbc :as jdbc]</p><p class="source-code">         '[clojure.java.io :as io]</p><p class="source-code">           '[packt-clj.tennis.database :as database])</p><p class="source-code">user=&gt; (ingest/historic database/db (io/file "packt-clj/resources/match_scores_1991-2016_unindexed_csv.csv"))</p><p class="source-code">user=&gt; (jdbc/query database/db ["select count(*) from player"])</p><p class="source-code">=&gt; ({:1 3483})</p><p class="source-code">user=&gt; (jdbc/query database/db ["select count(*) from tennis_match"])</p><p class="source-code">=&gt; ({:1 95359})</p></li>
				<li>The SQL to extract all tennis matches in the <strong class="source-inline">query</strong> namespace is fairly straightforward; however, attention should be drawn to the <strong class="source-inline">round_order desc</strong>. Since <strong class="source-inline">round_order</strong> <em class="italic">decreases</em> as the tournament progresses, we must sort this into reverse order:<p class="source-code">(ns packt-clj.tennis.query</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]))</p><p class="source-code">(defn all-tennis-matches</p><p class="source-code">  [db]</p><p class="source-code">  (jdbc/query db ["select *</p><p class="source-code">               from tennis_match</p><p class="source-code">                   order by tournament_year, tournament_order, round_order desc, match_order"]))</p></li>
				<li>Leveraging our functions from <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, our <strong class="source-inline">elo</strong> namespace starts off as follows:<p class="source-code">(ns packt-clj.tennis.elo</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.java.jdbc :as jdbc]</p><p class="source-code">    [packt-clj.tennis.query :as query]))=</p><p class="source-code">(def k-factor 32)</p><p class="source-code">(defn match-probability [player-1-rating player-2-rating]</p><p class="source-code">  (/ 1</p><p class="source-code">     (+ 1 (Math/pow 10 (/ (- player-2-rating player-1-rating) 1000)))))</p><p class="source-code">(defn recalculate-rating [previous-rating expected-outcome real-outcome]</p><p class="source-code">  (+ previous-rating (* k-factor (- real-outcome expected-outcome))))</p></li>
				<li>Calculating the ELO rating for all matches can be achieved as follows. First, we can define two helper functions, the first of which yields a tuple of expected outcomes.  Since probabilities must sum to 1, we can calculate one probability and then subtract it from 1 to get the other probability:<p class="source-code">(defn- expected-outcomes</p><p class="source-code">  [winner-rating loser-rating]</p><p class="source-code">  (let [winner-expected-outcome (match-probability winner-rating loser-rating)]</p><p class="source-code">    [winner-expected-outcome (- 1 winner-expected-outcome)]))</p></li>
				<li>We then destructure the tuple in the body of our second helper function, which allows us to calculate the new ratings for each player returning an updated player data structure that is destructured in <strong class="source-inline">calculate-all</strong>:<p class="source-code">(defn- calculate-new-ratings [current-player-ratings {:keys [winner_id loser_id]}]</p><p class="source-code">  (let [winner-rating (get current-player-ratings winner_id 1000)</p><p class="source-code">        loser-rating  (get current-player-ratings loser_id 1000)</p><p class="source-code">        [winner-expected-outcome loser-expected-outcome] (expected-outcomes winner-rating loser-rating)]</p><p class="source-code">    [{:player_id winner_id</p><p class="source-code">      :rating    (recalculate-rating winner-rating winner-expected-outcome 1)}</p><p class="source-code">     {:player_id loser_id</p><p class="source-code">      :rating    (recalculate-rating loser-rating loser-expected-outcome 0)}]))</p></li>
				<li>Finally, we destructure the result of the call to <strong class="source-inline">calculate-new-ratings</strong>, extracting the <strong class="source-inline">winner</strong> and <strong class="source-inline">loser</strong> IDs so that we can update the <strong class="source-inline">current-player-ratings</strong> data structure for the next iteration:<p class="source-code">(defn calculate-all</p><p class="source-code">  [db]</p><p class="source-code">  (-&gt;&gt; (query/all-tennis-matches db)</p><p class="source-code">       (reduce</p><p class="source-code">         (fn [{:keys [current-player-ratings] :as acc} match]</p><p class="source-code">           (let [[{winner-id :player_id :as new-winner-rating} {loser-id :player_id :as new-loser-rating}] (calculate-new-ratings current-player-ratings match)]</p><p class="source-code">             (-&gt; acc</p><p class="source-code">                 (update :elo-ratings into [new-winner-rating</p><p class="source-code">                                            new-loser-rating])</p><p class="source-code">                 (assoc-in [:current-player-ratings winner-id] (:rating new-winner-rating))</p><p class="source-code">                 (assoc-in [:current-player-ratings loser-id] (:rating new-loser-rating)))))</p><p class="source-code">         {:elo-ratings            []</p><p class="source-code">          :current-player-ratings {}})</p><p class="source-code">       :elo-ratings))</p><p>Using <strong class="source-inline">winner_id</strong> and <strong class="source-inline">loser_id</strong> for the current match, we can look up their existing ratings in our accumulator (defaulting to <strong class="source-inline">1000</strong>) if they're not found. Next, we determine the expected outcomes using the function described previously. Once we have that, we can plug this into the <strong class="source-inline">recalculate-rating</strong> function and store the updated values in our accumulator for the next iteration.</p><p><strong class="source-inline">current-player-rating</strong> is effectively an in-memory cache; we would not want to persist ratings to the database only to look them up again.</p></li>
				<li>It is also more performant to do a single call to <strong class="source-inline">jdbc/insert-multi!</strong> in the <strong class="source-inline">persist-all</strong> function than it is to persist as we go:<p class="source-code">(defn persist-all</p><p class="source-code">  [db]</p><p class="source-code">  (let [elo-ratings (calculate-all db)]</p><p class="source-code">    (jdbc/insert-multi! db :elo elo-ratings)))</p><p class="source-code">user=&gt;(require '[packt-clj.tennis.elo :as elo]</p><p class="source-code">               '[packt-clj.tennis.query :as query])</p><p class="source-code">nil</p><p class="source-code">user=&gt; (elo/persist-all database/db)</p></li>
				<li>The SQL required to extract all names and ratings is straightforward. Bolting on a <strong class="source-inline">result-set-fn</strong> function that iterates over the results one at a time is straightforward and intuitive, if less performant than a raw SQL approach:<p class="source-code">(defn select-max-elo</p><p class="source-code">  [db]</p><p class="source-code">  (jd<a id="_idTextAnchor501"/>bc/query db ["select p.full_name, e.rating</p><p class="source-code">                   from player p, elo e</p><p class="source-code">                   where p.id = e.player_id"]</p><p class="source-code">              {:result-set-fn (fn [rs]</p><p class="source-code">                                (reduce (fn [{:keys [max-rating] :as acc} {:keys                                   [full_name rating]}]</p><p class="source-code">                                          (cond-&gt; acc</p><p class="source-code">                                                  (&lt; max-rating rating) (assoc                                                     :max-rating rating</p><p class="source-code">                                                    :player-name full_name)))</p><p class="source-code">                                        {:max-rating Integer/MIN_VALUE</p><p class="source-code">                                         :player-name nil}</p><p class="source-code">                                        rs))}))</p><p>We begin by defining the maximum rating as the smallest integer, guaranteeing that it won't end up featuring in our final result!  A simple comparison of the existing highest rating with the candidate rating allows us to determine whether we update our accumulator using the conditional thread-first macro.</p></li>
				<li>Finally, let's confirm that the player with the highest ELO value matches what was expected:<p class="source-code">user =&gt; (query/select-max-elo database/db<a id="_idTextAnchor502"/><a id="_idTextAnchor503"/>)</p><p class="source-code">=&gt; {:max-rating 2974.61M, :player-name "Novak Djokovic"}</p></li>
			</ol>
			<p>Excellent! We've successfully built an application layer allowing us to ingest, query, and perform calculations on our large tennis results CSV dataset. Anyone new to the application should be able to grasp the purpose of it from the namespaces alone. The intention of each individual function, when taken in the context of the namespace, should also be clear.  </p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor504"/>14. HTTP with Ring</h1>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor505"/>Activity 14.01: Exposing Historic Tennis Results and ELO Calculations via REST</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">Add the following dependencies to <strong class="source-inline">packt-clj.tennis</strong> in the <strong class="source-inline">deps.edn</strong> file:<p class="source-code">{:deps {..</p><p class="source-code">        clj-http {:mvn/version "3.10.0"}</p><p class="source-code">        compojure {:mvn/version "1.6.1"}</p><p class="source-code">        metosin/muuntaja {:mvn/version "0.6.4"}</p><p class="source-code">        org.clojure/data.json {:mvn/version "0.2.6"}</p><p class="source-code">        ring/ring-core {:mvn/version "1.7.1"}</p><p class="source-code">        ring/ring-jetty-adapter {:mvn/version "1.7.1"}}</p></li>
				<li>Create our namespace with the following <strong class="source-inline">require</strong> route:<p class="source-code">(ns packt-clj.tennis.api</p><p class="source-code">  (:require</p><p class="source-code">    [clojure.edn :as edn]</p><p class="source-code">    [compojure.core :refer [context defroutes GET PUT]]</p><p class="source-code">    [compojure.route :as route]</p><p class="source-code">    [muuntaja.middleware :as middleware]</p><p class="source-code">    [packt-clj.tennis.database :as database]</p><p class="source-code">    [packt-clj.tennis.elo :as elo]</p><p class="source-code">    [packt-clj.fitness.ingest :as ingest]</p><p class="source-code">    [packt-clj.tennis.query :as query]</p><p class="source-code">    [ring.adapter.jetty :refer [run-jetty]]</p><p class="source-code">    [ring.middleware.params :as params]))</p></li>
				<li>The routes required to expose our player resources and the tennis matches they've taken part in are as follows:<p class="source-code">(defroutes routes</p><p class="source-code">           (context "/players" []</p><p class="source-code">             (GET "/" []</p><p class="source-code">               {:body (query/all-players database/db)})</p><p class="source-code">             (GET "/:id" [id]</p><p class="source-code">               (when-first [user (query/player database/db id)]</p><p class="source-code">                 {:body user}))</p><p class="source-code">             (GET "/:id/tennis-matches" [id]</p><p class="source-code">               {:body (query/tennis-matches-by-player database/db id)}))</p><p class="source-code">           (route/not-found "Not found"))</p></li>
				<li>The <strong class="source-inline">query</strong> functions referenced are defined in the <strong class="source-inline">query</strong> namespace like so:<p class="source-code">(defn all-players</p><p class="source-code">  [db]</p><p class="source-code">  (jdbc/query db ["select * from player"]))</p><p class="source-code">(defn player</p><p class="source-code">  [db id]</p><p class="source-code">  (jdbc/query db [(str "select * from player where id = '" id "'")]))</p><p class="source-code">(defn tennis-matches-by-player</p><p class="source-code">  [db id]</p><p class="source-code">  (jdbc/query db [(str "select * from tennis_match</p><p class="source-code">                   where winner_id = '" id "' or loser_id = '" id "'")]))</p></li>
				<li>Our <strong class="source-inline">run</strong> function looks similar to that we've used before, leveraging the <strong class="source-inline">wrap-format</strong> and <strong class="source-inline">wrap-params</strong> middleware:<p class="source-code">(defn run</p><p class="source-code">  []</p><p class="source-code">  (run-jetty</p><p class="source-code">    (-&gt; routes</p><p class="source-code">        middleware/wrap-format</p><p class="source-code">        params/wrap-params)</p><p class="source-code">    {:port  8080</p><p class="source-code">     :join? false}))</p></li>
				<li>We can add the following route to our <strong class="source-inline">players</strong> context for ELO retrieval, along with the means to extract it from our <strong class="source-inline">query</strong> namespace:<p class="source-code">(GET "/:id/elo" [id]</p><p class="source-code">               (when-first [elo (query/player-elo database/db id)]</p><p class="source-code">                 {:body elo}))</p><p class="source-code">(defn player-elo</p><p class="source-code">  [db id]</p><p class="source-code">  (jdbc/query db [(str "select e.rating, e.id</p><p class="source-code">                        from elo e, player p</p><p class="source-code">                        where e.player_id = p.id and</p><p class="source-code">                        p.id = '" id "' and</p><p class="source-code">                        e.id in (select max(e2.id)</p><p class="source-code">                                 from elo e2</p><p class="source-code">                                 where e2.player_id = '" id "')")]))</p></li>
				<li>Define a new <strong class="source-inline">tennis-matches</strong> context, along with the new <strong class="source-inline">query/tennis-match</strong> function:<p class="source-code">(context "/tennis-matches" []</p><p class="source-code">             (GET "/" []</p><p class="source-code">               {:body (query/all-tennis-matches database/db)})</p><p class="source-code">             (GET "/:id" [id]</p><p class="source-code">               (when-first [tennis-match (query/tennis-match database/db id)]</p><p class="source-code">                 {:body tennis-match})))</p><p class="source-code">(defn tennis-match</p><p class="source-code">  [db id]</p><p class="source-code">  (jdbc/query db [(str "select * from tennis_match where id = '" id "'")]))</p><p>Optionally, if starting from a clean database, we can populate it with relevant data using the following:</p><p class="source-code">(require '[packt-clj.tennis.database :as database]</p><p class="source-code">         '[packt-clj.tennis.ingest :as ingest]</p><p class="source-code">         '[packt-clj.tennis.elo :as elo])</p><p class="source-code">(database/load)</p><p class="source-code">(ingest/historic database/db "./resources/match_scores_1991-2016_unindexed_csv.csv")</p><p class="source-code">(elo/persist-all database/db) </p></li>
				<li>After starting the web server, we can use a browser to retrieve the current ELOs for reference:<p class="source-code">(require '[packt-clj.tennis.api :as api])</p><p class="source-code">(def app (api/run))</p><p>The output is as follows:</p><div id="_idContainer349" class="IMG---Figure"><img src="image/B14502_14_22.jpg" alt="Figure 14.22: Printing Sampras' current rating&#13;&#10;"/></div><p class="figure-caption">Figure 14.22: Printing Sampras' current rating</p><p>Printing the current rating of <strong class="source-inline">Djokovic</strong>:</p><div id="_idContainer350" class="IMG---Figure"><img src="image/B14502_14_23.jpg" alt="Figure 14.23: Printing Djokovic's current rating&#13;&#10;"/></div><p class="figure-caption">Figure 14.23: Printing Djokovic's current rating</p></li>
				<li>We define our <strong class="source-inline">tennis-match</strong> creation route using <strong class="source-inline">PUT</strong> since we know the ID ahead of time. This is added to the <strong class="source-inline">tennis-matches</strong> context. We must query the ELO of the two players involved in the match, then create a new record for each of them with their updated ELO. This requires a new <strong class="source-inline">ingest/tennis-match</strong> and <strong class="source-inline">elo/persist</strong> functions, as shown. Note that the <strong class="source-inline">elo/calculate-new-ratings</strong> function should now be marked as public (<strong class="source-inline">defn</strong> rather than <strong class="source-inline">defn-</strong>) now that we require it outside of the <strong class="source-inline">elo</strong> namespace:<p class="source-code">(defn tennis-match</p><p class="source-code">  [db tennis-match]</p><p class="source-code">  (first (jdbc/insert! db :tennis_match tennis-match)))</p><p class="source-code">(defn persist</p><p class="source-code"> [db elo-ratings]</p><p class="source-code"> (jdbc/insert-multi! db :elo elo-ratings))</p><p class="source-code">(PUT "/:id" req</p><p class="source-code">               (let [id (-&gt; req :params :id)</p><p class="source-code">                     {:keys [winner_id loser_id] :as tennis-match} (assoc (edn/read-string (slurp (:body req)))</p><p class="source-code">                                                                     :id id)</p><p class="source-code">                     [{winner-elo :rating}] (query/player-elo database/db                        winner_id)</p><p class="source-code">                     [{loser-elo :rating}] (query/player-elo database/db                        loser_id)</p><p class="source-code">                     new-player-ratings (elo/<strong class="bold">calculate-new-ratings</strong></p><p class="source-code">                                          {winner_id winner-elo</p><p class="source-code">                                           loser_id  loser-elo}</p><p class="source-code">                                          tennis-match)]</p><p class="source-code">                 (ingest/tennis-match database/db tennis-match)</p><p class="source-code">                 (elo/persist database/db new-player-ratings)</p><p class="source-code">                 {:status  201</p><p class="source-code">                  :headers {"Link" (str "/tennis-matches/" id)}}))</p><p>After restarting our app, we can use <strong class="source-inline">clj-http</strong> to submit a <strong class="source-inline">PUT</strong> instruction to our web service as follows:</p><p class="source-code">(.stop app)</p><p class="source-code">(def app (api/run))</p><p class="source-code">(require '[clj-http.client :as http])</p><p class="source-code">(http/put "http://localhost:8080/te<a id="_idTextAnchor506"/>nnis-matches/2019-1-d643-s403-5"</p><p class="source-code">          {:body (pr-str {:tournament_year  2019,</p><p class="source-code">                          :tournament       "umag",</p><p class="source-code">                          :tournament_order 1,</p><p class="source-code">                          :round_order      5,</p><p class="source-code">                          :match_order      1,</p><p class="source-code">                          :winner_id        "d643",</p><p class="source-code">                          :loser_id         "s402"})})</p></li>
				<li>Since Sampras lost our fictitious match, we see his ELO decrease slightly, while Djokovic's has increased:<div id="_idContainer351" class="IMG---Figure"><img src="image/B14502_14_24.jpg" alt="Figure 14.24: Printing Sampras' rating&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.24: Printing Sampras' rating</p>
			<p>Following are Djokovic's ratings:</p>
			<div>
				<div id="_idContainer352" class="IMG---Figure">
					<img src="image/B14502_14_25.jpg" alt="Figure 14.25: Printing Djokovic's current rating&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.25: Printing Djokovic's current rating</p>
			<p>Thus, by completing this activity, we have made our application layer more widely available via a REST web service.</p>
			<h1 id="_idParaDest-384"><a id="_idTextAnchor507"/>15. The Frontend: A ClojureScript UI</h1>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor508"/>Activity 15.01: Displaying a Grid of Images from the Internet</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">At the command-line prompt, create a new Figwheel project using the following Leiningen command:<p class="source-code">lein new figwheel packt-clj.images -- --reagent</p></li>
				<li>Move to the <strong class="source-inline">packt-clj.images/</strong> directory and type:<p class="source-code">lein figwheel</p><p>After a few seconds, your browser should open to the default Figwheel page:</p><div id="_idContainer353" class="IMG---Figure"><img src="image/B14502_15_08.jpg" alt="Figure 15.8: A fresh ClojureScript project waiting for your code&#13;&#10;"/></div><p class="figure-caption">Figure 15.8: A fresh ClojureScript project waiting for your code</p></li>
				<li>Open the <strong class="source-inline">src/packt_clj/images/core.cljs</strong> file in your preferred editor and modify the code:<p class="source-code">(ns packt-clj.images.core</p><p class="source-code">    (:require [reagent.core :as r]))</p></li>
				<li>The commonly used alias for Reagent is <strong class="source-inline">r</strong> instead of Reagent:<p class="source-code">(defonce app-state (r/atom {:images []</p><p class="source-code">                                       :author-display true}))</p><p>The <strong class="source-inline">app-state</strong> is made of two pieces of data: a vector of images that we fetched, initially an empty vector, and whether to display the author's name, initially true.</p></li>
				<li>Let's create a button that fetches images from the HTTP endpoint and updates the <strong class="source-inline">:images</strong> value of the <strong class="source-inline">app-state</strong>. We need two handlers: <strong class="source-inline">fetch-images</strong>, which updates <strong class="source-inline">:images</strong> in the <strong class="source-inline">app</strong> state with a vector of images, and <strong class="source-inline">clear-images</strong>, which updates <strong class="source-inline">:images</strong> in the <strong class="source-inline">app</strong> state with an empty vector:<p class="source-code">(defn fetch-images []</p><p class="source-code"> (-&gt; (js/fetch "https://picsum.photos/v2/list?limit=6")</p><p class="source-code">       (. then (fn [response] (.json response)))</p><p class="source-code">      (. then (fn [json] (swap! app-state assoc-in [:images] (js-&gt;clj json :keywordize-keys true))))))</p><p class="source-code">(defn clear-images []</p><p class="source-code">     (swap! app-state assoc-in [:images] []))</p></li>
				<li>And here is the code for the <strong class="source-inline">fetch-or-clear-button</strong> component:<p class="source-code">(defn fetch-or-clear-button []</p><p class="source-code">  (let [handler (if (empty? (:images @app-state)) fetch-images clear-images)</p><p class="source-code">           text    (if (empty? (:images @app-state)) "Fetch Images" "Clear Images")]</p><p class="source-code">     [:button.btn {:on-click handler} text]))</p></li>
				<li>We apply the <strong class="source-inline">btn</strong> class to the button by using the <strong class="source-inline">:button.btn</strong> short Hiccup syntax. The <strong class="source-inline">btn</strong> class is defined in <strong class="source-inline">resources/public/css/style.css</strong>:<p class="source-code">.btn {</p><p class="source-code">  padding: 7px 20px;</p><p class="source-code">  cursor: pointer;</p><p class="source-code">  margin-left: 10px;</p><p class="source-code">  margin-bottom: 10px;</p><p class="source-code">  border: 1px solid gray;</p><p class="source-code">}</p></li>
				<li>Let's build an <strong class="source-inline">image</strong> component and an <strong class="source-inline">image-grid</strong> component:<p class="source-code">(defn image [{:keys [download_url author]}]</p><p class="source-code">  [:div</p><p class="source-code">   [:img {:src download_url</p><p class="source-code">               :height "130px"</p><p class="source-code">               :style {:border "solid gray 3px"</p><p class="source-code">                           :border-radius "10px"}}]</p><p class="source-code">   (when (:author-display @app-state)</p><p class="source-code">      [:div {:style {:font-size "15px"</p><p class="source-code">                              :color "gray" }}</p><p class="source-code">        (str "Image by ") author])])</p><p class="source-code">(defn image-grid [images]</p><p class="source-code">   (if (empty? images)</p><p class="source-code">      [:div "Click the button to fetch images"]</p><p class="source-code">      (into [:div] (map (fn [image-data] [:div {:style {:float "left"</p><p class="source-code">                                          :margin-left "20px"}}</p><p class="source-code"> [image image-data]])</p><p class="source-code">                                     images))))</p></li>
				<li>The last component is a button that hides or displays author names:<p class="source-code">(defn author-display-button []</p><p class="source-code">  (let [text (if (:author-display @app-state)</p><p class="source-code">                 "Hide author"</p><p class="source-code">                 "Show author")]</p><p class="source-code">  [:button.btn {:on-click #(swap! app-state update-in [:author-display] not)}</p><p class="source-code">           text]))</p></li>
				<li>Now, we add all the components as children of the <strong class="source-inline">main</strong> component. We renamed the <strong class="source-inline">hello-world</strong> function <strong class="source-inline">app</strong>:<p class="source-code">(defn app []</p><p class="source-code">  [:div</p><p class="source-code">   [fetch-or-clear-button]</p><p class="source-code">   [author-display-button]</p><p class="source-code">   [image-grid (:images @app-state)]])</p></li>
				<li>Finally, we render the main component (named <strong class="source-inline">app</strong> instead of <strong class="source-inline">hello-world</strong>):<p class="source-code">(r/render-component [app] (. js/document (getElementById "app")))</p><p>If everything went well, you should see a screen like this:</p></li>
			</ol>
			<div>
				<div id="_idContainer354" class="IMG---Figure">
					<img src="image/B14502_15_09.jpg" alt="Figure 15.9: Buttons to fetch and clear images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.9: Buttons to fetch and clear images</p>
			<p>When you click on the <strong class="source-inline">Fetch Images</strong> button, the images appear with authors' names:</p>
			<div>
				<div id="_idContainer355" class="IMG---Figure">
					<img src="image/B14502_15_10.jpg" alt="Figure 15.10: Fetching the images&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10: Fetching the images</p>
			<p>Fina<a id="_idTextAnchor509"/>lly, when you click on the <strong class="source-inline">Hide author</strong> button, the authors' names disappear:</p>
			<div>
				<div id="_idContainer356" class="IMG---Figure">
					<img src="image/B14502_15_11.jpg" alt="Figure 15.11: Hiding the authors&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11: Hiding the authors</p>
			<p>Here, we have created a single-page application that can load and clear images and text as required.</p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor510"/>Activity 15.02: Tennis Players with Ranking</h2>
			<p>Solution:</p>
			<ol>
				<li value="1">At the command-line prompt, create a new Figwheel project using the following Leiningen command:<p class="source-code">lein new figwheel packt-clj.tennis -- --reagent</p></li>
				<li>Move to the <strong class="source-inline">packt-clj.tennis/</strong> directory and type the following:<p class="source-code">lein figwheel</p><p>After a few seconds, your browser should open to the default Figwheel page:</p><div id="_idContainer357" class="IMG---Figure"><img src="image/B14502_15_12.jpg" alt="Figure 15.12: A fresh ClojureScript project waiting for your code&#13;&#10;"/></div><p class="figure-caption">Figure 15.12: A fresh ClojureScript project waiting for your code</p></li>
				<li>Open the <strong class="source-inline">src/packt_clj/tennis/core.cljs</strong> file in your preferred editor and modify the code:<p class="source-code">(ns packt-clj.tennis.core</p><p class="source-code">    (:require [r<a id="_idTextAnchor511"/>eagent.core :as r]))</p><p><strong class="source-inline">app-state</strong> consists of the list of players and the details about the currently selected player.</p></li>
				<li>We start with an empty list of players:<p class="source-code">(defonce app-state (r/atom {:players []</p><p class="source-code">                            :current-player nil}))</p></li>
				<li>Here is the code that fetches the ranking data from the server about a specific player:<p class="source-code">(defn fetch-player [id full_name]</p><p class="source-code">  (-&gt; (js/fetch (str "http://localhost:8080/players/" id "/elo"))</p><p class="source-code">      (.then (fn [response] (.json response)))</p><p class="source-code">      (.then (fn [json] (swap! app-state assoc-in [:current-player] (assoc (js-&gt;clj json :keywordize-keys true)</p><p class="source-code">                                                                          :full_name full_name))))))</p></li>
				<li>Here is a player component that displays the name of a player and their ranking: <p class="source-code">(defn player-alone [{:keys [rating full_name]}]</p><p class="source-code">  [:div</p><p class="source-code">   (str full_name " has a rating of: " rating)])</p></li>
				<li>Let's create a button that clears the current player and goes back to the list of all the players:<p class="source-code">(defn player-list-button []</p><p class="source-code">  [:button.btn {:on-click #(swap! app-state assoc-in [:current-player] nil)} "Display all players"])</p></li>
				<li>Let's write the code for the list of players. We start by writing a component for an element of the list. The content is the name of the player. When we click on it, it fetches the ranking data about the selected player:<p class="source-code">(defn player [{:keys [id full_name]}]</p><p class="source-code">  [:div [:span</p><p class="source-code">         [:a</p><p class="source-code">          {:href "#"</p><p class="source-code">           :on-click (partial fetch-player id full_name)}</p><p class="source-code">          full_name]]])</p></li>
				<li>We now build the <strong class="source-inline">player-list</strong> component. It receives a vector of players and returns a <strong class="source-inline">:div</strong> that contains a player component for each player:<p class="source-code">(defn player-list [players]</p><p class="source-code">  (if (empty? players)</p><p class="source-code">    [:div "Click the button to fetch players"]</p><p class="source-code">    (into [:div] (map player players))))</p></li>
				<li>This is the code for the function that fetches the players data from the server:<p class="source-code">(defn fetch-players []</p><p class="source-code">  (-&gt; (js/fetch "http://localhost:8080/players/")</p><p class="source-code">      (.then (fn [response] (.json response)))</p><p class="source-code">      (.then (fn [json] (swap! app-state assoc-in [:players] (js-&gt;clj json         :keywordize-keys true))))))</p></li>
				<li>We also need a function that clears the list of players by modifying <strong class="source-inline">app-state</strong>:<p class="source-code">(defn clear-players []</p><p class="source-code">  (swap! app-state assoc-in [:players] []))</p></li>
				<li>Now we add a button that either clears or fills the list of players:<p class="source-code">(defn fetch-or-clear-button []</p><p class="source-code">  (let [handler (if (empty? (:players @app-state)) fetch-players clear-players)</p><p class="source-code">        text    (if (empty? (:players @app-state)) "Fetch Players" "Clear Players")]</p><p class="source-code">    [:button.btn {:on-click handler} text]))</p></li>
				<li>Now, we write the <strong class="source-inline">main</strong> component. When the value associated to <strong class="source-inline">:current-player</strong> is not <strong class="source-inline">nil</strong>, we display the currently selected player. Otherwise, we display a list of players. This is the code for the main <strong class="source-inline">app</strong> component:<p class="source-code">(defn app []</p><p class="source-code">  (if (:current-player @app-s<a id="_idTextAnchor512"/>tate)</p><p class="source-code">    [:d<a id="_idTextAnchor513"/>iv</p><p class="source-code">     [player-list-button]</p><p class="source-code">     [<a id="_idTextAnchor514"/>player-alo<a id="_idTextAnchor515"/>ne (:current-player @app-s<a id="_idTextAnchor516"/>tate)]]</p><p class="source-code">    [:div</p><p class="source-code">     [fetch-or-clear-button]</p><p class="source-code">   <a id="_idTextAnchor517"/>  [player-<a id="_idTextAnchor518"/>list (:players @app-state)]])<a id="_idTextAnchor519"/>)</p></li>
				<li>Finally, we render the main component:<p class="source-code">(r/render-component [app] (. js/document (<a id="_idTextAnchor520"/>getElementById "app")))</p></li>
			</ol>
			<p>By completing the activities, we have seen how to organize the different components of a Reagent application: the CSS, HTML, and <strong class="source-inline">cljs</strong> files. Being able to iteratively modify the code and have the web page immediately update without any page refresh was helpful and time-saving. We learned how to store the state of the app in a ratom and access the state for the code of the Reagent components.</p>
		</div>
	</body></html>