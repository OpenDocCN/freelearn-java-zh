<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Configuring Storage for Your Applications</h1>
                </header>
            
            <article>
                
<p class="western"><span><span>In this chapter, we will start by learning the theoretical basis of OpenShift storage configuration. Later, we will show you how to deploy a database in the cloud and configure your cloud applications to use it.</span></span></p>
<p>In the last section of the preceding chapter, we deployed the simple version of <kbd>CatalogService</kbd> in the cloud, using OpenShift. We also got an initial feeling for the web console and OpenShift <kbd>cli</kbd>. Now, it is time to go further. We will reconfigure our application to use the database.</p>
<p>Before doing that, we will cover OpenShift persistence storage concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">OpenShift storage concepts</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we hinted a the volume concept—the tool that is used by OpenShift to implement storage. Let's start by looking at it more thoroughly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Volumes</h1>
                </header>
            
            <article>
                
<p>As we mentioned in the preceding chapter, OpenShift's unit of deployment and scaling is a pod, which can contain many containers. The containers in the pod are ephemeral—they can be stopped and started at any moment by Kubernetes. The data stored in the container will be lost when the container goes down because during the restart the fresh container is recreated from the image.</p>
<p>As a result, we will need another tool to implement the storage. Such a tool is the volume.</p>
<p>So, what is a volume? From the technical point of view, volumes are basically directories on the node that runs the pod, which are mapped into the container filesystem. Also, volumes have an explicitly defined life cycle, which equals the pod life cycle. Whenever the pod is stopped, the volume is destroyed. On the other hand, when the containers inside the pod are restarted, the volume is unchanged; it just has to be remounted inside the container.</p>
<div class="packt_infobox">Linux directory can also be a link to another directory or remote filesystem, such as <strong>Network File System</strong> (<strong>NFS</strong>). As a result, removing the directory when the pod is stopped doesn't necessarily mean removing all the pieces of data. As a result, the way in which a volume behaves depends on its type—we will describe it in the next section.</div>
<p>OpenShift allows you to configure a number of volume types. Let's look at the most common of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Empty directory</h1>
                </header>
            
            <article>
                
<p>Empty directory is, as its name suggests, an empty directory created in the node's filesystem. The directory is created when the pod is instantiated and is present as long as the pod runs on that node. When the pod is removed from the node for any reason, the directory is deleted.</p>
<p>The empty directory can be mounted inside any of the containers running inside the pod. An example usage for this kind of pod may be a directory shared between the containers that are used to gather common data.</p>
<div class="packt_infobox">As we mentioned in the <em>Volumes</em> section, restarting any of the containers does not result in the deletion of the directory. The directory will be present till the pod exists and will be remounted inside a container that has a dependency on it after the container restart.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Host path</h1>
                </header>
            
            <article>
                
<p>Host path is another type of persistent volume, which mounts the directory from the node's filesystem. In contrast to the empty directory, this kind of persistent volume does not create or destroy any new directories. For example, when a container needs access to some part of a configuration of the host, an administrator can mount the directory with this configuration inside the container filesystem.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remote filesystems</h1>
                </header>
            
            <article>
                
<p>As we hinted previously, a volume's directory doesn't have to point to the local filesystem. It can also point to remote filesystem directories. It is here that interesting stuff starts to happen. Let's look at it closer.</p>
<p>Quick recall here, when you use a remote filesystem, you have to create the storage on the server, export it, and then mount it on the client. On the client side, the mounting directory will be implemented as a remote filesystem client. As a result, operations on that directory will be propagated (using the given remote filesystem protocol) to the server.</p>
<p>OpenShift supports a number of remote filesystem protocols, for example, NFS, or Fiber Channel. Additionally, if you have knowledge of your cluster architecture, you can use proprietary remote filesystems, such as gcePersistentDisk (Google Cloud) or awsElasticBlockStore (Amazon Web Services).</p>
<p>Given the knowledge that we have, let's analyze the behavior of remote filesystems with OpenShift. When the pod with a remote filesystem volume is started, OpenShift creates a client directory on the node and mounts it inside the appropriate containers, according to the configuration. As usual, when containers are stopped, nothing happens to the directory, and it is remounted again when a container is restarted.</p>
<p>More interesting stuff happens when the pod is being removed or when the node crashes. In this scenario, the client directory is being deleted. Contrary to the empty directory scenario, this doesn't mean a loss of data. Deleting a client directory means that <span>only</span> one of the clients of the remote filesystem has been destroyed. The data inside the filesystem stays untouched.</p>
<p>As you can see, remote volumes enable us to create persistent storage, which can be mounted to our application. Also, the lifecycle is independent of the pods.</p>
<p>OK, we already know how volumes work and would gladly add them to our application. However, there is one problem, the configuration. The developer who would like to use one of those volumes has to have a lot of information on the cluster configuration: what kind of remote filesystem has been configured, or on which node it runs. More importantly, even if you gather such information from your administrator, you would need to ensure that it is configured correctly in each of your environments.</p>
<p>That's not good for a number of reasons. Firstly, we would like to decouple a developer from the cluster administrator. Ideally, the developer will specify the type of volume they need without needing to learn the details of the cluster configuration. Secondly, we emphasized in the preceding chapter the importance of a unified view of the cloud. Since this unified view is compromised now, you would have to reconfigure your pods for the testing environment to use NFS instead of Google disk. We clearly don't want that.</p>
<p>We need a tool that will solve those problems. Let's discuss <strong>persistent volumes</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PersistentVolume and PersistentVolumeClaims</h1>
                </header>
            
            <article>
                
<p>Persistent volumes, similar to regular volumes, allow you to define different types of persistent storage. In fact, you can use persistent volumes to define storage types analogous to regular volumes, such as node directories or remote filesystems. <span>Then, w</span>hat is the difference?</p>
<p>Persistent volumes <span>are Kubernetes objects, just as pods and services are objects. Th</span>eir lifecycle is not related to any of the pods. In this context, we can think about persistent modules similar to the nodes—they are part of cluster infrastructure. Let's take a look at the sample <kbd>PersistentVolume</kbd>:</p>
<pre>apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>//1 <br/>name: nfs<br/>labels: <br/>  zone: 5<br/>//2 <br/>spec:<br/>   capacity:<br/>      storage: 100Mi<br/>   accessModes:<br/>   - ReadWriteMany<br/>   nfs:<br/>   server: 10.244.1.4<br/>   path: "/exports"</pre>
<p>As you can see in the preceding code, the <kbd><span>PersistentVolume</span></kbd> specifies the NFS server to which it is going to connect, in the same way as the volume. Compared to regular volume, it has a few additional fields: capacity, access mode, and metadata labels. You will learn in a moment why they are needed.</p>
<p>In the end, we would like to have this persistent storage mounted to our containers. How can we achieve that? We can do so using <kbd>PersistentVolumeClaims</kbd>. The <kbd>PersistentVolumeClaim</kbd> is an object that specifies the characteristics of the <kbd>PersistentVolume</kbd> that we need.</p>
<p>Let's look at the example again:</p>
<pre class="highlight"><span class="s">kind</span><span class="pi">:</span> <span class="s">PersistentVolumeClaim</span>
<span class="s">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="s">metadata</span><span class="pi">:</span>
  <span class="s">name</span><span class="pi">:</span> <span class="s">myclaim</span>
<span class="s">spec</span><span class="pi">:</span>
  <span class="s">accessModes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">ReadWriteMany</span>
  <span class="s">resources</span><span class="pi">:</span>
    <span class="s">requests</span><span class="pi">:</span>
      <span class="s">storage</span><span class="pi">:</span> <span class="s">10Mi</span>
  <span class="s">selector</span><span class="pi">:</span>
    <span class="s">matchLabels</span><span class="pi">:</span>
      <span class="s">zone</span><span class="pi">: 5</span></pre>
<p>As you can see in the preceding code, the <kbd>PersistentModule</kbd> claim specifies the amount of storage we need and the access type. As usual, in OpenShift, you are also able to use the label mechanism to provide additional match characteristics. In our example, we use those to specify from which zone the <kbd>PersistentVolume</kbd> should be taken.</p>
<div class="packt_infobox">The <kbd>PersistentVolume</kbd> provides us with the capability of declaring persistent storage, which is a part of cluster infrastructure, and the <kbd>PersistentVolumeClaim</kbd> is a set of criteria that allows us to specify the <kbd>PersistentStorage</kbd> that we need.</div>
<p>However, how does the match process look and how does it actually relate to the pods that we are creating?</p>
<p>The <kbd>PersistentVolumeClaim</kbd> technically is a kind of a volume, and, as a result, you can refer to the given <kbd>PersistentVolumeClaim</kbd> from within your pod configuration. When the pod with such a claim is started, the <kbd>PersistentStorage</kbd> objects available in the system are evaluated. If a matching <kbd>PersistentVolume</kbd> can be found, it is mounted inside the containers that depend on that claim.</p>
<p>Let's take a look at the following example:</p>
<pre class="highlight"><span class="s">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="s">metadata</span><span class="pi">:</span>
  <span class="s">name</span><span class="pi">:</span> <span class="s">mypod</span>
<span class="s">spec</span><span class="pi">:</span>
  <span class="s">containers</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">name</span><span class="pi">:</span> <span class="s">my-container</span>
      <span class="s">image</span><span class="pi">:</span> <span class="s">tadamski/container</span>
      <span class="s">volumeMounts</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mountPath</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/mount/storage1"</span>
        <span class="s">name</span><span class="pi">:</span> <span class="s">pod</span>
  <span class="s">volumes</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">name</span><span class="pi">:</span> <span class="s">mypod</span>
      <span class="s">persistentVolumeClaim</span><span class="pi">:</span>
        <span class="s">claimName</span><span class="pi">:</span> <span class="s">myclaim</span></pre>
<p>As you can note, we were able to refer to the previously created <kbd>PersistentVolumeClaim</kbd> in our pod configuration. With this configuration, when <kbd>mypod</kbd> starts, <kbd>myclaim</kbd> would be evaluated, and if a matching <kbd>PersistentVolume</kbd> is found, it will be mounted inside <kbd>my-container</kbd>.</p>
<p>It's time to take a look at the bigger picture of the <kbd>PersistentVolume</kbd> and <kbd>PersistentVolumeClaims</kbd> architecture; those objects decouple storage provisioning from pod configuration. As a result, a developer is able to specify the characteristics of the storage that they need. They don't have to configure those volumes, and don't need to have the knowledge of the architecture of the given cluster. Also, the <kbd>PersistentVolume</kbd> is part of a cluster configuration, whereas the <kbd>PersistentVolumeClaim</kbd> is part of an application configuration; both can be created independently. The application that contains <kbd>PersistentVolumeClaim</kbd> objects can be created by a developer and deployed without changes in many OpenShift clusters. On the other hand, those clusters may contain different persistent storage configurations created by the administrators of those clusters. The details of those configurations are abstracted away from the developer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The catalog-service with database</h1>
                </header>
            
            <article>
                
<p>You have learned the essential knowledge to understand how to work with persistent storage in the OpenShift cloud. Now, let's take a look at this with a practical example. Let's update our <span class="packt_screen">catalog-service</span> deployment so that it connects to the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring PostgreSQL database</h1>
                </header>
            
            <article>
                
<p class="mce-root">First, let's ensure that we have removed the previous version of the <kbd>catalog-service</kbd>. In order to do that, we will need to use the <kbd>oc</kbd> delete command. The command interface is the same as the interface for the get operation. You will be able to delete an object by directly specifying its name or use labels to indicate objects that you want to delete. There are many objects related to a single application, and we obviously don't want to delete them one by one. As a result, we will use the label version of the <kbd>delete</kbd> command for that:</p>
<pre><span>oc delete all -l app=catalog-service</span></pre>
<p>Now, we are ready to deploy the database. Open your web console and click on the <span class="packt_screen">Add to the Project</span> button. We will search for the PostgreSQL project:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f2ceef6b-9893-4b4b-ab22-1f573cafa24b.png" style=""/></div>
<p>The search results in a number of options; we need to choose the data store option:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d58deab6-0a05-4bd8-a3b0-6ccd8af2cba4.png" style=""/></div>
<p>When you click on the <span class="packt_screen">Select</span> button, the following form opens:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/54bfbd1c-40d8-4d80-bc33-06d001db2812.png" style=""/></div>
<p>We changed the name of the database server and the name of the database instance to <kbd>catalogdb</kbd>. For convenience purposes, we have set both the user and password to catalog.</p>
<p>We will also override <span class="packt_screen">Labels</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/40376223-9280-47bd-b433-ce535e617d5c.png" style=""/></div>
<p>We will use a bunch of database containers for our different services. As a result, we can't use standard application and template labels. We change them to <span class="packt_screen">catalogdb-template</span> and <kbd>catalogdb</kbd>.</p>
<p>After we have done that, we are ready to create an application; let's click on the <span class="packt_screen">Create</span> button at the bottom of the page.</p>
<p>We have to wait for the moment till the pod has been started. Let's click on the <span class="packt_screen">Overview page</span> button and further on <span class="packt_screen">postgresql</span> deployment; we have to wait till there is one replica active:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/95a98108-243e-4fc1-af2a-53cbcfd261da.png" style=""/></div>
<p class="mce-root">The application is running. Let's fill our database with a number of pets so that we can test our service behavior. To do that we need to get access to the console of the container on which the database run. In order to achieve that we have to go to applications/pods menu, choose the pod on which PostgreSQL runs, and the terminal button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61f80c88-b737-4606-ad97-0f92769c288c.png" style=""/></div>
<p class="mce-root">Let's fill the database now. Let's log into the user directory and create the SQL script there:</p>
<pre class="mce-root">cd<br/>vi items.sql</pre>
<p class="mce-root"><br/>
The script is very similar to the load scripts that we created in previous applications:</p>
<pre><span>DROP TABLE </span>IF <span>EXISTS </span>ITEM;<br/><br/><span>CREATE TABLE </span>ITEM (id serial <span>PRIMARY KEY</span>, item_id <span>varchar</span>, name <span>varchar</span>, description <span>varchar</span>, quantity <span>smallint</span>);<br/><br/><span>INSERT INTO </span>ITEM(item_id, name, description, quantity) <span>VALUES </span>(<span>'dbf67f4d-f1c9-4fd4-96a8-65ee1a22b9ff'</span>,  <span>'turtle'</span>, <span>'Slow friendly reptile. Let your busy self see how it spends 100 years of his life laying on sand and swimming.'</span>, <span>5</span>);<br/><span>INSERT INTO </span>ITEM(item_id, name, description, quantity) <span>VALUES </span>(<span>'fc7ee3ea-8f82-4144-bcc8-9a71f4d871bd'</span>, <span>'hamster'</span>, <span>'Energetic rodent - great as a first pet. Will be your only inmate that takes his fitness training serviously.'</span>, <span>10</span>);<br/><span>INSERT INTO </span>ITEM(item_id, name, description, quantity) <span>VALUES </span>(<span>'725dfad2-0b4d-455c-9385-b46c9f356e9b'</span>,<span>'goldfish'</span>, <span>'With its beauty it will be the decoration of you aquarium. Likes gourmet fish feed and postmodern poetry.'</span>, <span>3</span>);<br/><span>INSERT INTO </span>ITEM(item_id, name, description, quantity) <span>VALUES </span>(<span>'a2aa1ca7-add8-4aae-b361-b7f92d82c3f5'</span>, <span>'lion'</span>, <span>'Loves playing the tag and cuddling with other animals and people.'</span>, <span>9</span>);</pre>
<p class="mce-root"><span>Please note, that we have changed the convention here. Instead of using names as item identifiers, we start using UIDs we will be the</span> consistent <span>ID for pets in the whole application.</span><br/>
Finally, we are going to execute the script:</p>
<pre class="mce-root">psql -U catalog catalogdb &lt; catalog.sql</pre>
<p class="mce-root">The command above run PostgreSQL command line client. The <kbd>-U</kbd> parameter specifies the user (catalog in our example) and the <kbd>catalogdb</kbd> parameter specifies the schema on which the client must operate.</p>
<p class="mce-root">Our database is ready now and the question that comes to your mind may be: where are my persistent volumes? And the answer is: again OpenShift has done everything for you. Let's inspect it a little bit further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inspecting the volumes</h1>
                </header>
            
            <article>
                
<p>In order to take a look at how the database is configured, let's use <kbd>cli</kbd>:</p>
<pre><span>oc describe dc/catalogdb<br/></span></pre>
<p>You will be able to see that this deployment configuration has defined a volume of the <kbd>PersistentVolumeClaim</kbd> type:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/25f673f5-c9fa-48ce-b72b-1bbe6d49e433.png"/></div>
<p>Going further, let's analyze the <kbd>catalogdb</kbd> persistent volume claim:</p>
<pre><span>oc describe pvc/catalogdb<br/></span></pre>
<p>We will be able to see that the claim has been created according to the database type that we provided and that it has been already bound:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fae0a7c9-2216-4142-997d-cbe035f6334c.png" style=""/></div>
<p>As you see in the preceding screenshot, OpenShift has created a <kbd>PersitentVolumeClaim</kbd> based on information that you provided when an application was created from the template. The claim has been bound to one of the <kbd>PersitentVolumes</kbd> on the cluster. Since we are using Minishift now, the <kbd>PersitentVolumes</kbd> are implemented using disks inside the virtual machine. But we want to emphasize again that your application config wouldn't change an iota if you decided to deploy your application on any other OpenShift cluster.</p>
<p>Let's return to our example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating catalog-service</h1>
                </header>
            
            <article>
                
<p>We have to reconfigure our <span class="packt_screen">catalog-service</span> again so that it works with the PostgreSQL database.</p>
<div class="packt_infobox">Examples refrence: <kbd>chapter7/catalog-service<strong>-</strong>openshift<strong>-</strong>postgresql</kbd>.</div>
<p>Let's start with the <kbd>pom.xml</kbd> changes—we have to add Postgres dependency to it:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/></span><span>        (...)</span><span><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jpa<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/><strong>        &lt;!-- 1 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;<br/>            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.postgresql}&lt;/version&gt;<br/>        &lt;/dependency&gt;<br/></strong><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>(...)</span></pre>
<p>We have changed the database driver from <kbd>h2</kbd> to <kbd>PostgreSQL</kbd> (1).</p>
<p>Let's change the datasource configuration:</p>
<pre><span>swarm:<br/></span><span>  datasources:<br/></span><span>    data-sources:<br/></span><span>      CatalogDS:<br/></span><span>       driver-name: </span>postgresql<br/>       <span>connection-url: </span>jdbc:postgresql://catalogdb.petstore.svc/catalogdb<br/>       <span>user-name: </span>catalog<br/>      <span>password: </span>catalog<br/>    <span>jdbc-drivers:<br/></span><span>      postgresql:<br/></span><span>        driver-class-name: </span>org.postgresql.Driver<br/>        <span>xa-datasource-name: </span>org.postgresql.xa.PGXADataSource<br/>        <span>driver-module-name: </span>org.postgresql.jdbc</pre>
<p>We have to reconfigure the JDBC driver to user <kbd>postgresql</kbd> classes and reconfigure the datasource, so that it contains the data of our application. The meaning of catalogdb.petstore.svc address will be explained in the next chapter.</p>
<p>As in the previous database examples, we have to provide the <kbd>persistence</kbd> file:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;<br/></span><span>&lt;persistence<br/></span><span>        </span><span>xmlns:</span><span>xsi</span><span>=</span><span>"http://www.w3.org/2001/XMLSchema-instance"<br/></span><span>        </span><span>version=</span><span>"2.1"<br/></span><span>        </span><span>xmlns=</span><span>"http://xmlns.jcp.org/xml/ns/persistence"<br/></span><span>        </span><span>xsi</span><span>:schemaLocation=</span><span>"http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"</span><span>&gt;<br/></span><span>    &lt;persistence-unit </span><span>name=</span><span>"CatalogPU" </span><span>transaction-type=</span><span>"JTA"</span><span>&gt;<br/></span><span>        &lt;jta-data-source&gt;</span>java:jboss/datasources/CatalogDS<span>&lt;/jta-data-source&gt;<br/></span><span>    &lt;/persistence-unit&gt;<br/></span><span>&lt;/persistence&gt;</span></pre>
<p>Finally, we have to add the <kbd>postgreSQL</kbd> JDBC module to the application...</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fe71f5cd-a059-4447-9f43-2e6cc2b3e7bf.png" style=""/></div>
<p>With the following contents:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"UTF-8"</span><span>?&gt;</span><span><br/></span><span>&lt;module </span><span>xmlns=</span><span>"urn:jboss:module:1.5" </span><span>name=</span><span>"org.postgresql.jdbc"</span><span>&gt;<br/></span><span><br/></span><span>  &lt;resources&gt;</span><span><br/></span><span>    </span><span>&lt;artifact </span><span>name=</span><span>"org.postgresql:postgresql:${version.postgresql}"</span><span>/&gt;<br/></span><span>  &lt;/resources&gt;</span><span><br/></span><span>  </span><span>&lt;dependencies&gt;<br/></span><span>    &lt;module </span><span>name=</span><span>"javax.api"</span><span>/&gt;<br/></span><span>    &lt;module </span><span>name=</span><span>"javax.transaction.api"</span><span>/&gt;<br/></span><span>  &lt;/dependencies&gt;<br/></span><span>&lt;/module&gt;</span></pre>
<p>OK, now that we have reconfigured our <span class="packt_screen">catalog-service</span>, it is time for interesting stuff. Let's deploy our application to OpenShift.</p>
<p>We will use the source-to-image build again as we did in the last chapter:</p>
<pre><span>oc new-app wildflyswarm-10-centos7~https://github.com/PacktPublishing/Hands-On-Cloud-Development-with-WildFly.git --context-dir=chapter7/catalog-service-openshift-postgresql/ --name=catalog-service<br/></span></pre>
<p>We have to wait till our fat-JAR has started. To verify that, we may take a look at the log of the pod on which the application was started:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ff92ae62-f574-4270-b600-093719a2445b.png" style=""/></div>
<p>As in the preceding example, we have to create a route. After doing that, let's find out the address of <span class="packt_screen">catalog-service</span> visible from outside the cluster:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/85c23ccc-45d2-47fe-a606-94cc6552f4b7.png" style=""/></div>
<p>Let's copy the route name and use <kbd>curl</kbd> to check whether we can get pet information using <span class="packt_screen">catalog-service</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/20becbce-beeb-4eac-abff-7c126e3c94d1.png" style=""/></div>
<p>It works. Let's extend our service now so that it is able to persist data to the database.</p>
<p>Let's extend our <kbd>CatalogService</kbd>:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>javax.persistence.EntityManager<span>;<br/></span><span>import </span>javax.persistence.<span>PersistenceContext</span><span>;<br/></span><span>import </span>javax.transaction.<span>Transactional</span><span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span>import </span>java.util.UUID<span>;<br/></span><span><br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>CatalogService {<br/><br/>    <span>@PersistenceContext</span>(<span>unitName </span>= <span>"CatalogPU"</span>)<br/>    <span>private </span>EntityManager <span>em</span><span>;<br/></span><span><br/></span><span>    public </span>Item <span>searchById</span>(String itemId) {<br/>        <span>return </span><span>em</span>.createNamedQuery(<span>"Item.findById"</span><span>, </span>Item.<span>class</span>).setParameter(<span>"itemId"</span><span>, </span>itemId).getSingleResult();<span><br/></span><span>    </span>}<br/><br/><strong>    //1</strong><br/><strong>    @Transactional<br/>    public void add(Item item){<br/>        //2</strong><br/><strong>        item.setItemId(UUID.randomUUID().toString());<br/>        em.persist(item);<br/>    }</strong><br/><br/><strong>    //3</strong><br/><strong>    public List&lt;Item&gt; getAll() {</strong><br/><strong>        return em.createNamedQuery("Item.findAll", Item.class).getResultList();<br/>    }</strong><br/><br/>}</pre>
<p>We have extended the service with the <kbd>add</kbd> method (1). Note that the method is transactional and generates UUID for the items in the store (2). We have also added a method that lists all the items in the store (3). Note that we would need also to add NamedQuery for that:</p>
<pre><span>(...)<br/><br/>@Entity<br/></span><span>@Table</span>(<span>name </span>= <span>"item"</span>)<br/><span>@NamedQueries</span>({<br/>        <span>@NamedQuery</span>(<span>name</span>=<span>"Item.findById"</span><span>,<br/></span><span>                </span><span>query</span>=<span>"SELECT i FROM Item i WHERE i.itemId = :itemId"</span>)<span>,<br/></span><strong>        @NamedQuery(name="Item.findAll",<br/>                query="SELECT i FROM Item i")</strong><br/>})<br/><span>public class </span>Item {<br/>(...)</pre>
<p>We also have to add the <kbd>POST</kbd> method to the <kbd>CatalogResource</kbd>:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Consumes</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>GET</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>POST</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Path</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>PathParam</span><span>;<br/></span><span>import </span>javax.ws.rs.<span>Produces</span><span>;<br/></span><span>import </span>javax.ws.rs.core.MediaType<span>;<br/></span><span>import </span>javax.ws.rs.core.Response<span>;<br/></span><span>import </span>java.util.List<span>;<br/></span><span><br/></span><span>@Path</span>(<span>"/"</span>)<br/><span>public class </span>CatalogResource {<br/><br/>    <span>@Inject<br/></span><span>    </span><span>private </span>CatalogService <span>catalogService</span><span>;<br/></span><span><br/></span><span>    </span><span>@GET<br/></span><span>    @Path</span>(<span>"item/{itemId}"</span>)<br/>    <span>@Produces</span>(MediaType.<span>APPLICATION_JSON</span>)<br/>    <span>public </span>Response <span>searchById</span>(<span>@PathParam</span>(<span>"itemId"</span>) String itemId) {<br/>        <span>try </span>{<br/>            Item item = <span>catalogService</span>.searchById(itemId)<span>;<br/></span><span>            return </span>Response.<span>ok</span>(item).build()<span>;<br/></span><span>        </span>} <span>catch </span>(Exception e) {<br/>            e.printStackTrace()<span>;<br/></span><span>            return </span>Response.<span>status</span>(Response.Status.<span>BAD_REQUEST</span>).entity(e.getMessage()).build()<span>;<br/></span><span>        </span>}<br/>    }<br/><br/><strong>    //1</strong><br/><strong>    @POST<br/>    @Path("item")<br/>    //2</strong><br/><strong>    @Produces(MediaType.APPLICATION_JSON)<br/>    //3</strong><br/><strong>    @Consumes(MediaType.APPLICATION_JSON)</strong><br/><strong>    public Response addNew(Item item) {</strong><br/><strong>        try {</strong><br/><strong>            catalogService.add(item);<br/>            return Response.ok(item).build();<br/>        } catch (Exception e) {</strong><br/><strong>            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();<br/>        }</strong><br/><strong>    }</strong><br/><br/><strong>    //2</strong><br/><strong>    @GET<br/>    @Path("item")</strong><br/><strong>    @Produces(MediaType.APPLICATION_JSON)</strong><br/><strong>    @Consumes(MediaType.APPLICATION_JSON)</strong><br/><strong>    public Response getAll() {</strong><br/><strong>        try {</strong><br/><strong>            List&lt;Item&gt; item = catalogService.getAll();<br/>            return Response.ok(item).build();<br/>        } catch (Exception e) {</strong><br/><strong>            return Response.status(Response.Status.BAD_REQUEST).entity(e.getMessage()).build();<br/>        }</strong><br/><strong>    }</strong><br/><br/>}</pre>
<p>We have implemented the <kbd>addNew</kbd> method, which uses the <kbd>CatalogService</kbd> instance to add an <kbd><span><span>Item</span></span></kbd> object(1) to the database. As you will have noticed in the preceding code, both the <kbd>Request</kbd> parameter and <kbd>Response</kbd> are JSON objects. They are parsed automatically by a server; the only thing that we must do is annotate the method with the <kbd>@Produces</kbd> (2) and <kbd>@Consumes</kbd> (3) annotations. In the method, we use the <kbd>catalogService</kbd> to store a given <span><span>Item</span></span> object. Finally, we return either the <kbd>ok</kbd> response (5) or an error response (6) based on the result of the store operation.</p>
<p>We have also implemented <kbd>getAll</kbd> method which will allow us to request information about all the pets in the store (2).</p>
<p>After the application is ready, you have to commit the changed files and push them to GitHub. When you do this, you can enter the web console and trigger the build of the updated service. In order to do it, you have to click on <span class="packt_screen">Build<span><span> | </span></span></span><span class="packt_screen">Build in the Webconsole</span>, select the <span class="packt_screen">catalog-service</span>, and click on the <span class="packt_screen">Start Build</span> button in the top-right corner:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/663eda07-e9f5-4e52-adf8-570303ba0a6b.png" style=""/></div>
<p>After the application starts, we have to wait till it has been deployed in the cloud. Let's use <kbd>curl</kbd> to <kbd>POST</kbd> new <span><span>Item</span></span> in our store:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fe1bf0c4-269c-4f17-bf7b-eb9f27f2ceca.png"/></div>
<p>Everything seems fine, so let's check what items are available in the store using the request that we have just implemented:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4aea7c58-3c7d-4dff-b67c-be6d2145dab1.png" style=""/></div>
<p>There are three rabbits in our database. Our service is working correctly inside the OpenShift cluster.</p>
<p>We may now check that the storage is indeed persistent. Let's get into the web console and terminate both catalog-service and database pods. In order to do that, enter web console, click <span class="packt_screen">Applications |</span> <span class="packt_screen">Pods</span> and choose the <span class="packt_screen">database</span> pod. Later click on <span class="packt_screen">Actions</span> in the right, upper corner and choose <span class="packt_screen">Delete</span>. Repeat those actions for <span class="packt_screen">catalog-service</span> pod. After both pods have been restarted (you can monitor that in <span class="packt_screen">Applications<span><span> | </span></span></span><span class="packt_screen">Pods</span> view), you can again list all items. You should be able to see extract the same result as on the preceding screenshot.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to configure persistence for the services deployed in OpenShift.</p>
<p>This chapter started with theoretical knowledge, giving you more details on volumes and their different types. Later, you learned a particularly useful type of the volume the <kbd>PersistentVolumeClaim</kbd>. You also learned why it is necessary, how it is related to the <kbd>PersistentVolume</kbd>, and how to use it.</p>
<p>Finally, we extended your <kbd>catalogService</kbd> so that it uses the <kbd>postgresql</kbd> database as the storage.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>