<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">RESTful Web Services with JAX-RS</h1>
                </header>
            
            <article>
                
<p><strong>Representational State Transfer</strong> (<strong>REST</strong>) is an architectural style in which web services are viewed as resources and can be identified by <strong>Uniform Resource Identifiers</strong> (<strong>URIs</strong>).</p>
<p>Web services developed using this styles are known as RESTful web services.</p>
<p>JAX-RS became part of Java EE in version 6 of the Java EE specification, although it had been available as a standalone API before then. In this chapter, we will cover how to develop RESTful web services through the JAX-RS API.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>An introduction to RESTful web services and JAX-RS</li>
<li>Developing a simple RESTful web service</li>
<li>Developing a RESTful web service client</li>
<li>Path parameters</li>
<li>Query parameters</li>
<li>Server-Sent events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to RESTful web services and JAX-RS</h1>
                </header>
            
            <article>
                
<p>RESTful web services are very flexible. They can consume several types of different MIME types, although they are typically written to consume and/or produce XML or <strong>JSON</strong> (<strong>JavaScript Object Notation</strong>).</p>
<p>Web services must support one or more of the following four HTTP methods:</p>
<ul>
<li><strong>GET</strong> - By convention, a <kbd>GET</kbd> request is used to retrieve an existing resource</li>
<li><strong>POST</strong> - By convention, a <kbd>POST</kbd> request is used to update an existing resource</li>
<li><strong>PUT</strong> - By convention, a <kbd>PUT</kbd> request is used to create a new resource</li>
<li><strong>DELETE</strong> - By convention, a <kbd>DELETE</kbd> request is used to delete an existing resource</li>
</ul>
<p>We develop a RESTful web service with JAX-RS by creating a class with annotated methods that are invoked when our web service receives one of the above HTTP requests. Once we have developed and deployed our RESTful web service, we need to develop a client that will send requests to our service. JAX-RS includes a standard client-side API that we can use to develop RESTful web service clients.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a simple RESTful web service</h1>
                </header>
            
            <article>
                
<p>In this section, we will develop a simple web service to illustrate how we can make methods in our service respond to different HTTP request methods.</p>
<p>Developing a RESTful web service using JAX-RS is simple and straightforward. Each of our RESTful web services needs to be invoked via its <strong>Unique Resource Identifier</strong> (<strong>URI</strong>). This URI is specified by the <kbd>@Path</kbd> annotation, which we need to use to decorate our RESTful web service resource class.</p>
<p>When developing RESTful web services, we need to develop methods that will be invoked when our web service receives an HTTP request. We need to implement methods to handle one or more of the four types of request that RESTful web services handle: <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and/or <kbd>DELETE</kbd>.</p>
<p>The JAX-RS API provides four annotations that we can use to decorate methods in our web service. These annotations are appropriately named <kbd>@GET</kbd>, <kbd>@POST</kbd>, <kbd>@PUT</kbd>, and <kbd>@DELETE</kbd>. Decorating a method in our web service with one of these annotations will make it respond to the corresponding HTTP method.</p>
<p>Additionally, each method in our service must produce and/or consume a specific MIME type. The MIME type to be produced needs to be specified with the <kbd>@Produces</kbd> annotation. Similarly, the MIME type to be consumed must be specified with the <kbd>@Consumes</kbd> annotation.</p>
<p>The following example illustrates the concepts we have just explained:</p>
<div class="packt_infobox">Please note that this example does not <em>really</em> do anything; the purpose of the example is to illustrate how to make different methods in our RESTful web service resource class respond to different HTTP methods.</div>
<pre style="padding-left: 60px">package com.ensode.javaee8book.jaxrsintro.service; 
 
import javax.ws.rs.Consumes; 
import javax.ws.rs.DELETE; 
import javax.ws.rs.GET; 
import javax.ws.rs.POST; 
import javax.ws.rs.PUT; 
import javax.ws.rs.Path; 
import javax.ws.rs.Produces; 
import javax.ws.rs.core.MediaType; 
 
<strong>@Path("customer")</strong> 
public class CustomerResource { 
 
<strong>  @GET</strong><strong>  @Produces("text/xml")</strong> 
  public String getCustomer() { 
    //in a "real" RESTful service, we would retrieve data from a database 
    //then return an XML representation of the data. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".getCustomer() invoked"); 
 
    return "&lt;customer&gt;\n" 
        + "&lt;id&gt;123&lt;/id&gt;\n" 
        + "&lt;firstName&gt;Joseph&lt;/firstName&gt;\n" 
        + "&lt;middleName&gt;William&lt;/middleName&gt;\n" 
        + "&lt;lastName&gt;Graystone&lt;/lastName&gt;\n" 
        + "&lt;/customer&gt;\n"; 
  } 
 
  /** 
   * Create a new customer 
   * @param customer XML representation of the customer to create 
   */ 
<strong>  @PUT</strong><strong>  @Consumes("text/xml")</strong> 
  public void createCustomer(String customerXML) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then insert 
    //a new row into the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".createCustomer() invoked"); 
 
    System.out.println("customerXML = " + customerXML); 
  } 
 
<strong>  @POST</strong><strong>  @Consumes(MediaType.TEXT_XML)</strong> 
  public void updateCustomer(String customerXML) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then update 
    //a row in the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".updateCustomer() invoked"); 
 
    System.out.println("customerXML = " + customerXML); 
  } 
 
<strong>  @DELETE</strong><strong>  @Consumes("text/xml")</strong> 
  public void deleteCustomer(String customerXML) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then delete 
    //a row in the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".deleteCustomer() invoked"); 
 
    System.out.println("customerXML = " + customerXML); 
  } 
} </pre>
<p>Notice that this class is annotated with the <kbd>@Path</kbd> annotation. This annotation designates the Uniform Resource Identifier (URI) for our RESTful web service. The complete URI for our service will include the protocol, server name, port, context root, the REST resources path (see the next subsection), and the value passed to this annotation.</p>
<p>Assuming that our web service was deployed to a server called <span class="URLPACKT">example.com</span> using the HTTP protocol on port 8080, has a context root of <kbd>jaxrsintro</kbd>, and a REST resources path of <kbd>"resources"</kbd>, then the complete URI for our service would be:</p>
<p><a href="http://example.com:8080/jaxrsintro/resources/customer"><span class="URLPACKT">http://example.com:8080/jaxrsintro/resources/customer</span></a></p>
<p>Since web browsers generate a <kbd>GET</kbd> request when pointed to a URL, we can test the GET method of our service simply by pointing the browser to our service's URI.</p>
<p>Notice that each of the methods in our class is annotated with one of the <kbd>@GET</kbd>, <kbd>@POST</kbd>, <kbd>@PUT</kbd>, or <kbd>@DELETE</kbd> annotations. These annotations make our methods respond to the corresponding HTTP method.</p>
<p>Additionally, if our method returns data to the client, we declare the MIME type of the data to be returned in the <kbd>@Produces</kbd> annotation. In our example, only the <kbd>getCustomer()</kbd> method returns data to the client. We wish to return data in XML format, therefore we set the value of the <kbd>@Produces</kbd> annotation to the JAX-RS provided constant <kbd>MediaType.TEXT_XML</kbd>, which has a value of <kbd>"text/xml"</kbd>. Similarly, if our method needs to consume data from the client, we need to specify the MIME type of the data to be consumed. This is done via the <kbd>@Consumes</kbd> annotation. All methods except <kbd>getCustomer()</kbd> in our service consume data. In all cases, we expect the data to be in XML format, therefore, we again specify <kbd>MediaType.TEXT_XML</kbd> as the MIME type to be consumed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the REST resources path for our application</h1>
                </header>
            
            <article>
                
<p>As briefly mentioned in the previous section, before successfully deploying a RESTful web service developed using JAX-RS, we need to configure the REST resources path for our application. We can do this by developing a class that extends <kbd>javax.ws.rs.core.Application</kbd> and decorating it with the <kbd>@ApplicationPath</kbd>, annotation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring via the @ApplicationPath annotation</h1>
                </header>
            
            <article>
                
<p>When developing applications against modern versions of Java EE, in many cases, it isn't necessary to write a <kbd>web.xml</kbd> deployment descriptor; JAX-RS is no different. We can configure the REST resources path in Java code via an annotation.</p>
<p>To configure our REST resources path without having to rely on a <kbd>web.xml</kbd> deployment descriptor, all we need to do is write a class that extends <kbd>javax.ws.ApplicationPath</kbd>, and decorate it with the <kbd>@ApplicationPath</kbd> annotation. The value passed to this annotation is the REST resources <kbd>path</kbd> for our services.</p>
<p>The following code sample illustrates this process:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book..jaxrsintro.service.config; 
 
import javax.ws.rs.ApplicationPath; 
import javax.ws.rs.core.Application; 
 
<strong>@ApplicationPath("resources")</strong> 
public class JaxRsConfig extends Application { 
} </pre>
<p>Notice that the class does not have to implement any methods; it simply needs to extend <kbd>javax.ws.rs.Application</kbd> and be decorated with the <kbd>@ApplicationPath</kbd> annotation. The class must be public, may have any name, and may be placed in any package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing our web service</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier, web browsers send a <kbd>GET</kbd> request to any URLs we point them to. Therefore, the easiest way to test <kbd>GET</kbd> requests to our service is to simply point the browser to our service's URI:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/f4476141-c883-415b-8b84-e561692feee1.png" style="width:23.42em;height:18.75em;"/></div>
<p>Web browsers only support <kbd>GET</kbd> and <kbd>POST</kbd> requests. To test a <kbd>POST</kbd> request through the browser, we would have to write a web application containing an HTML form having an action attribute value of our service's URI. Although trivial for a single service, it can become cumbersome to do this for every RESTful web service we develop.</p>
<p>Thankfully, there is an open source command-line utility called curl we can use to test our web services. curl is included with most Linux distributions, and can be easily downloaded for Windows, mac OS X, and several other platforms, at <a href="http://curl.haxx.se/"><span class="URLPACKT">http://curl.haxx.se/</span></a>.</p>
<p>curl can send all four request method types (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>) to our service. Our server's response will simply be displayed on the command-line console. Curl takes an <kbd>-X</kbd> command-line option, which allows us to specify which request method to send. To send a <kbd>GET</kbd> request, we simply need to type the following into the command line:</p>
<pre><strong>curl -XGET 
<span class="InternetLink0">http://localhost:8080/jaxrsintro/resources/customer</span></strong></pre>
<p>Which results in the following output:</p>
<pre style="padding-left: 30px"><strong>&lt;customer&gt; 
&lt;id&gt;123&lt;/id&gt; 
&lt;firstName&gt;Joseph&lt;/firstName&gt; 
&lt;middleName&gt;William&lt;/middleName&gt; 
&lt;lastName&gt;Graystone&lt;/lastName&gt; 
&lt;/customer&gt; </strong></pre>
<p>Which, unsurprisingly, is the same output we saw when we pointed our browser to the service's URI.</p>
<p>The default request method for curl is <kbd>GET</kbd>, therefore, the <kbd>-X</kbd> parameter in our example above is redundant; we could have achieved the same result by invoking the following command from the command line:</p>
<pre><strong>curl <span class="InternetLink0">http://localhost:8080/jaxrsintro/resources/customer</span></strong></pre>
<p>After submitting either of the above two commands and examining the application server log, we should see the output of the <kbd>System.out.println()</kbd> statements we added to the <kbd>getCustomer()</kbd> method:</p>
<pre><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.getCustomer() invoked</strong></pre>
<p>For all other request method types, we need to send some data to our service. This can be accomplished with the <kbd>--data</kbd> command-line argument to <kbd>curl</kbd>:</p>
<pre><strong>curl -XPUT -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Zoe&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;" <span class="InternetLink0">http://localhost:8080/jaxrsintro/resources/customer</span></strong></pre>
<p>As can be seen in the preceding example, we need to specify the MIME type via curl's <kbd>-H</kbd> command-line argument using the format seen in the preceding example.</p>
<p>We can verify that the preceding command worked as expected by inspecting the application server log:</p>
<pre><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.createCustomer() invoked</strong>
<strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Zoe&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></pre>
<p>We can test other <kbd>request</kbd> method types just as easily:</p>
<pre><strong>curl -XPOST -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;" <span class="InternetLink0">http://localhost:8080/jaxrsintro/resources/customer</span></strong></pre>
<p>Which results in the following output in the application server log:</p>
<pre><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.updateCustomer() invoked</strong>
<strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></pre>
<p>We can test the <kbd>delete</kbd> method by executing the following command:</p>
<pre class="mce-root"><strong>curl -XDELETE -HContent-type:text/xml --data "&lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;"</strong> <strong>http://localhost:8080/jaxrsintro/resources/customer</strong></pre>
<p>Resulting in the following output in the application server log:</p>
<pre><strong>INFO: --- com.ensode.jaxrsintro.service.CustomerResource.deleteCustomer() invoked</strong>
<strong>INFO: customerXML = &lt;customer&gt;&lt;id&gt;321&lt;/id&gt;&lt;firstName&gt;Amanda&lt;/firstName&gt;&lt;middleName&gt;Tamara&lt;/middleName&gt;&lt;lastName&gt;Adams&lt;/lastName&gt;&lt;/customer&gt;</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting data between Java and XML with JAXB</h1>
                </header>
            
            <article>
                
<p>In our previous example, we were processing "raw" XML received as a parameter, as well as returning "raw" XML to our client. In a real application, we would more than likely parse the XML received from the client and use it to populate a Java object. Additionally, any XML that we need to return to the client would have to be constructed from a Java object.</p>
<p>Converting data from Java to XML and back is such a common use case that the Java EE specification provides an API to do it. This API is the <strong>Java API for XML Binding</strong> (<strong>JAXB</strong>).</p>
<p>JAXB makes converting data from Java to XML transparent and trivial; all we need to do is decorate the class we wish to convert to XML with the <kbd>@XmlRootElement</kbd> annotation. The following code example illustrates how to do this:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.jaxrstest.entity; 
 
import java.io.Serializable; 
import javax.xml.bind.annotation.XmlRootElement; 
 
<strong>@XmlRootElement</strong> 
public class Customer implements Serializable { 
 
  private Long id; 
  private String firstName; 
  private String middleName; 
  private String lastName; 
 
  public Customer() { 
  } 
 
  public Customer(Long id, String firstName, 
      String middleInitial, String lastName) { 
    this.id = id; 
    this.firstName = firstName; 
    this.middleName = middleInitial; 
    this.lastName = lastName; 
  } 
 
  //getters and setters omitted for brevity 

  @Override 
  public String toString() { 
    return "id = " + getId() + "\nfirstName = " + getFirstName() 
        + "\nmiddleName = " + getMiddleName() + "\nlastName = " 
        + getLastName(); 
  } 
} </pre>
<p>As we can see, other than the <kbd>@XmlRootElement</kbd> annotation at the class level, there is nothing unusual about the above Java class.</p>
<p>Once we have a class that we have decorated with the <kbd>@XmlRootElement</kbd> annotation, we need to change the parameter type of our web service from <kbd>String</kbd> to our custom class:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.jaxbxmlconversion.service; 
 
import com.ensode.jaxbxmlconversion.entity.Customer; 
import javax.ws.rs.Consumes; 
import javax.ws.rs.DELETE; 
import javax.ws.rs.GET; 
import javax.ws.rs.POST; 
import javax.ws.rs.PUT; 
import javax.ws.rs.Path; 
import javax.ws.rs.Produces; 
 
@Path("customer") 
public class CustomerResource { 
 
  private Customer customer; 
 
  public CustomerResource() { 
    //"fake" the data, in a real application the data 
    //would come from a database. 
    customer = new Customer(1L, "David", 
        "Raymond", "Heffelfinger"); 
  } 
 
  @GET 
  @Produces("text/xml") 
  <strong>public Customer getCustomer()</strong> { 
    //in a "real" RESTful service, we would retrieve data from a   <br/>     database 
    //then return an XML representation of the data. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".getCustomer() invoked"); 
 
    return customer; 
  } 
 
  @POST 
  @Consumes("text/xml") 
 <strong> public void updateCustomer(Customer customer)</strong> { 
    //in a "real" RESTful service, JAXB would parse the XML 
    //received in the customer XML parameter, then update 
    //a row in the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".updateCustomer() invoked"); 
 
 
    System.out.println("---- got the following customer: " 
        + customer); 
  } 
 
  @PUT 
  @Consumes("text/xml") 
<strong>  public void createCustomer(Customer customer)</strong> { 
    //in a "real" RESTful service, we would insert 
    //a new row into the database with the data in the 
    //customer parameter 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".createCustomer() invoked"); 
 
    System.out.println("customer = " + customer); 
 
  } 
 
  @DELETE 
  @Consumes("text/xml") 
<strong>  public void deleteCustomer(Customer customer)</strong> { 
    //in a "real" RESTful service, we would delete a row 
    //from the database corresponding to the customer parameter 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".deleteCustomer() invoked"); 
 
    System.out.println("customer = " + customer); 
  } 
} </pre>
<p>As we can see, the difference between this version of our RESTful web service and the previous one is that all parameter types and return values have been changed from <kbd>String</kbd> to <kbd>Customer</kbd>. JAXB takes care of converting our parameters and return types to and from XML as appropriate. When using JAXB, an object of our custom class is automatically populated with data from the XML data sent from the client, similarly, return values are transparently converted to XML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a RESTful web service client</h1>
                </header>
            
            <article>
                
<p>Although curl allows us to quickly test our RESTful web services and it is a developer-friendly tool, it is not exactly user-friendly; we shouldn't expect to have our user enter curl commands in their command line to use our web service. For this reason, we need to develop a client for our services. JAX-RS includes a standard client-side API that we can use to easily develop RESTful web service clients.</p>
<p>The following example illustrates how to use the JAX-RS client API:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.jaxrsintroclient; 
 
import com.ensode.jaxbxmlconversion.entity.Customer; 
import javax.ws.rs.client.Client; 
import javax.ws.rs.client.ClientBuilder; 
import javax.ws.rs.client.Entity; 
 
public class App { 
 
    public static void main(String[] args) { 
        App app = new App(); 
        app.insertCustomer(); 
    } 
 
    public void insertCustomer() { 
        Customer customer = new Customer(234L, "Tamara", "A", 
                "Graystone"); 
<strong>        Client client = ClientBuilder.newClient();        </strong><strong>         <br/>        client.target(</strong><strong>                 <br/>        "http://localhost:8080/jaxbxmlconversion/resources/customer").</strong><strong>                 <br/>          request().put(</strong><strong>                        <br/>          Entity.entity(customer, "text/xml"),</strong><strong>                           <br/>          Customer.class);</strong> 
    } 
} </pre>
<p><span class="NormalPACKTChar">The first thing we need to do is create an instance of</span> <kbd>javax.ws.rs.client.Client</kbd> <span class="NormalPACKTChar">by invoking the static</span> <kbd>newClient()</kbd> <span class="NormalPACKTChar">method on the</span> <kbd>javax.ws.rs.client.ClientBuilder</kbd> <span class="NormalPACKTChar">class.</span></p>
<p><span class="NormalPACKTChar">We then invoke the</span> <kbd>target()</kbd> <span class="NormalPACKTChar">method on our</span> <kbd>Client</kbd> <span class="NormalPACKTChar">instance, passing the URI of our RESTful web service as a parameter. The</span> <kbd>target()</kbd> <span class="NormalPACKTChar">method returns an instance of a class implementing the</span> <kbd>javax.ws.rs.client.WebTarget</kbd> <span class="NormalPACKTChar">interface.</span></p>
<p><span class="NormalPACKTChar">At this point, we invoke the</span> <kbd>request()</kbd> <span class="NormalPACKTChar">method on our</span> <kbd>WebTarget</kbd> <span class="NormalPACKTChar">instance. This method returns an implementation of the</span> <kbd>javax.ws.rs.client.Invocation.Builder</kbd> <span class="NormalPACKTChar">interface.</span></p>
<p><span class="NormalPACKTChar">In this particular example, we are sending an HTTP</span> <kbd>PUT</kbd> <span class="NormalPACKTChar">request to our RESTful web service, therefore, at this point, we invoke the</span> <kbd>put()</kbd> <span class="NormalPACKTChar">method of our</span> <kbd>Invocation.Builder</kbd> <span class="NormalPACKTChar">implementation. The first parameter of the</span> <kbd>put()</kbd> <span class="NormalPACKTChar">method is an instance of</span> <kbd>javax.ws.rs.client.Entity</kbd> <span class="NormalPACKTChar">. We can create one on the fly by invoking the static</span> <kbd>entity()</kbd> <span class="NormalPACKTChar">method on the</span> <kbd>Entity</kbd> <span class="NormalPACKTChar">class. The first parameter for this method is the object we wish to pass to our RESTful web service, and the second parameter is the string representation of the MIME type of the data we will be passing to the RESTful web service. The second parameter of the</span> <kbd>put()</kbd> <span class="NormalPACKTChar">method is the type of response the client expects from the service. After we invoke the</span> <kbd>put()</kbd> <span class="NormalPACKTChar">method, an HTTP <kbd>PUT</kbd> request is sent to our RESTful web service and the method we decorated with the</span> <kbd>@Put</kbd> <span class="NormalPACKTChar">annotation (</span> <kbd>createCustomer()</kbd>, <span class="NormalPACKTChar">in our example) is invoked. There are similar</span> <kbd>get()</kbd>, <kbd>post()</kbd>, <span class="NormalPACKTChar">and</span> <kbd>delete()</kbd> <span class="NormalPACKTChar">methods which we can invoke to send the corresponding HTTP requests to our RESTful web service.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Query and path parameters</h1>
                </header>
            
            <article>
                
<p>In our previous examples, we were working with a RESTful web service to manage a single customer object. In real life, this would obviously not be very helpful. A common case is to develop a RESTful web service to handle a collection of objects (customers, in our example). To determine which specific object in the collection we are working with, we can pass parameters to our RESTful web services. There are two types of parameters we can use, <strong>Query</strong> and <strong>Path</strong> parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Query parameters</h1>
                </header>
            
            <article>
                
<p>We can add parameters to methods that will handle HTTP requests in our web service. Parameters decorated with the <kbd>@QueryParam</kbd> annotation will be retrieved from the request URL.</p>
<p>The following example illustrates how to use query parameters in our JAX-RS RESTful web services:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.queryparams.service; 
 
import com.ensode.queryparams.entity.Customer; 
import javax.ws.rs.Consumes; 
import javax.ws.rs.DELETE; 
import javax.ws.rs.GET; 
import javax.ws.rs.POST; 
import javax.ws.rs.PUT; 
import javax.ws.rs.Path; 
import javax.ws.rs.Produces; 
import javax.ws.rs.QueryParam; 
 
@Path("customer") 
public class CustomerResource { 
 
  private Customer customer; 
 
  public CustomerResource() { 
    customer = new Customer(1L, "Samuel", 
        "Joseph", "Willow"); 
  } 
 
  @GET 
  @Produces("text/xml") 
<strong>  public Customer getCustomer(@QueryParam("id") Long id) {</strong> 
    //in a "real" RESTful service, we would retrieve data from a  <br/>    database 
    //using the supplied id. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".getCustomer() invoked, id = " + id); 
 
    return customer; 
  } 
 
  /** 
   * Create a new customer 
   * @param customer XML representation of the customer to create 
   */ 
  @PUT 
  @Consumes("text/xml") 
  public void createCustomer(Customer customer) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then insert 
    //a new row into the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".createCustomer() invoked"); 
 
    System.out.println("customer = " + customer); 
 
  } 
 
  @POST 
  @Consumes("text/xml") 
  public void updateCustomer(Customer customer) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then update 
    //a row in the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".updateCustomer() invoked"); 
 
    System.out.println("customer = " + customer); 
 
    System.out.println("customer= " + customer); 
  } 
 
  @DELETE 
  @Consumes("text/xml") 
<strong>  public void deleteCustomer(@QueryParam("id") Long id) {</strong> 
    //in a "real" RESTful service, we would invoke 
    //a DAO and delete the row in the database with the 
    //primary key passed as the "id" parameter. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".deleteCustomer() invoked, id = " + id); 
 
    System.out.println("customer = " + customer); 
  } 
} </pre>
<p>Notice that all we had to do was decorate the parameters with the <kbd>@QueryParam</kbd> annotation. This annotation allows JAX-RS to retrieve any query parameters matching the value of the annotation and assign its value to the parameter variable.</p>
<p>We can add a parameter to the web service's URL, just as we pass parameters to any URL:</p>
<pre><strong>curl -XGET -HContent-type:text/xml <span class="InternetLink0">http://localhost:8080/queryparams/resources/customer?id=1</span></strong> </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending query parameters via the JAX-RS client API</h1>
                </header>
            
            <article>
                
<p>The JAX-RS client API provides an easy and straightforward way of sending query parameters to RESTful web services. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.queryparamsclient; 
 
import com.ensode.javaee8book.queryparamsclient.entity.Customer; 
import javax.ws.rs.client.Client; 
import javax.ws.rs.client.ClientBuilder; 
 
public class App { 
 
    public static void main(String[] args) { 
        App app = new App(); 
        app.getCustomer(); 
    } 
 
    public void getCustomer() { 
        Client client = ClientBuilder.newClient(); 
        Customer customer = client.target( 
                "http://localhost:8080/queryparams/resources/customer"). 
<strong>                queryParam("id", 1L).</strong> 
                request().get(Customer.class); 
 
        System.out.println("Received the following customer  <br/>        information:"); 
        System.out.println("Id: " + customer.getId()); 
        System.out.println("First Name: " +  <br/>        customer.getFirstName()); 
        System.out.println("Middle Name: " +  <br/>        customer.getMiddleName()); 
        System.out.println("Last Name: " + customer.getLastName()); 
    } 
} </pre>
<p>As we can see, all we need to do to pass a parameter is to invoke the <kbd>queryParam()</kbd> method on the instance of <kbd>javax.ws.rs.client.WebTarget</kbd> returned by the <kbd>target()</kbd> method invocation on our <kbd>Client</kbd> instance<a>.</a> The first argument to this method is the parameter name and must match the value of the <kbd>@QueryParam</kbd> annotation on the web service. The second parameter is the value that we need to pass to the web service. If our web service accepts multiple parameters, we can chain <kbd>queryParam()</kbd> method invocations, using one for each parameter our RESTful web service expects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Path parameters</h1>
                </header>
            
            <article>
                
<p>Another way we can pass parameters to our RESTful web services is via <kbd>path</kbd> parameters. The following example illustrates how to develop a JAX-RS RESTful web service that accepts <kbd>path</kbd> parameters:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book.pathparams.service; 
 
import com.ensode.pathparams.entity.Customer; 
import javax.ws.rs.Consumes; 
import javax.ws.rs.DELETE; 
import javax.ws.rs.GET; 
import javax.ws.rs.POST; 
import javax.ws.rs.PUT; 
import javax.ws.rs.Path; 
import javax.ws.rs.PathParam; 
import javax.ws.rs.Produces; 
 
@Path("/customer/") 
public class CustomerResource { 
 
  private Customer customer; 
 
  public CustomerResource() { 
    customer = new Customer(1L, "William", 
        "Daniel", "Graystone"); 
  } 
 
  @GET 
  @Produces("text/xml") 
<strong>  @Path("{id}/")</strong><strong> <br/> public Customer getCustomer(@PathParam("id") Long id) {</strong> 
    //in a "real" RESTful service, we would retrieve data from a database 
    //using the supplied id. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".getCustomer() invoked, id = " + id); 
 
    return customer; 
  } 
 
  @PUT 
  @Consumes("text/xml") 
  public void createCustomer(Customer customer) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then insert 
    //a new row into the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".createCustomer() invoked"); 
    System.out.println("customer = " + customer); 
 
  } 
 
  @POST 
  @Consumes("text/xml") 
  public void updateCustomer(Customer customer) { 
    //in a "real" RESTful service, we would parse the XML 
    //received in the customer XML parameter, then update 
    //a row in the database. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".updateCustomer() invoked"); 
 
    System.out.println("customer = " + customer); 
     System.out.println("customer= " + customer); 
  } 
 
  @DELETE 
  @Consumes("text/xml") 
<strong>  @Path("{id}/")<br/></strong><strong>  public void deleteCustomer(@PathParam("id") Long id) {</strong> 
    //in a "real" RESTful service, we would invoke 
    //a DAO and delete the row in the database with the 
    //primary key passed as the "id" parameter. 
 
    System.out.println("--- " + this.getClass().getCanonicalName() 
        + ".deleteCustomer() invoked, id = " + id); 
 
    System.out.println("customer = " + customer); 
  } 
} </pre>
<p>Any method that accepts a <kbd>path</kbd> parameter must be decorated with the <kbd>@Path</kbd> annotation. The value attribute of this annotation must be formatted as <kbd>"{paramName}/"</kbd>, where <kbd>paramName</kbd> is the parameter the method expects to receive. Additionally, method parameters must be decorated with the <kbd>@PathParam</kbd> annotation. The value of this annotation must match the parameter name declared in the <kbd>@Path</kbd> annotation for the method.</p>
<p>We can pass <kbd>path</kbd> parameters from the command line by adjusting our web service's URI as appropriate. For example, to pass an <kbd>"id"</kbd> parameter of <kbd>1</kbd> to the <kbd>getCustomer()</kbd> method above (which handles HTTP <kbd>GET</kbd> requests), we could do so from the command line, as follows:</p>
<pre><strong>curl -XGET -HContent-type:text/xml <span class="InternetLink0">http://localhost:8080/pathparams/resources/customer/1</span></strong></pre>
<p>Which returns the expected output of an XML representation of the <kbd>Customer</kbd> object returned by the <kbd>getCustomer()</kbd> method:</p>
<pre><strong>&lt;?xml version="1.0" encoding="UTF-8"<br/>standalone="yes"?&gt;&lt;customer&gt;&lt;firstName&gt;William&lt;/firstName&gt;&lt;id&gt;1&lt;/id&gt;&lt;lastName&gt;Graystone&lt;/lastName&gt;&lt;middleName&gt;Daniel&lt;/middleName&gt;&lt;/customer&gt;</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sending path parameters via the JAX-RS client API</h1>
                </header>
            
            <article>
                
<p>Sending path parameters to a web service via the JAX-RS client API is easy and straightforward; all we need to do is add a couple of method invocations to specify the path parameter and its value. The following example illustrates how to do this:</p>
<pre style="padding-left: 60px">package com.ensode.javaee8book..pathparamsclient; 
 
import com.ensode.javaee8book.pathparamsclient.entity.Customer; 
import javax.ws.rs.client.Client; 
import javax.ws.rs.client.ClientBuilder; 
 
public class App { 
 
    public static void main(String[] args) { 
        App app = new App(); 
        app.getCustomer(); 
    } 
 
    public void getCustomer() { 
        Client client = ClientBuilder.newClient(); 
        Customer customer = client.target( 
                "http://localhost:8080/pathparams/resources/customer"). 
<strong>                path("{id}").</strong><strong>            <br/>                resolveTemplate("id", 1L).</strong> 
                request().get(Customer.class); 
 
        System.out.println("Received the following customer  <br/>        information:"); 
        System.out.println("Id: " + customer.getId()); 
        System.out.println("First Name: " + <br/>        customer.getFirstName()); 
        System.out.println("Middle Name: " + <br/>        customer.getMiddleName()); 
        System.out.println("Last Name: " + customer.getLastName()); 
    } 
} </pre>
<p>In this example, we invoke the <kbd>path()</kbd> method on the instance of <kbd>WebTarget</kbd> returned by <kbd>client.target()</kbd>. This method appends the specified <kbd>path</kbd> to our <kbd>WebTarget</kbd> instance. The value of this method must match the value of the <kbd>@Path</kbd> annotation in our RESTful web service.</p>
<p>After invoking the <kbd>path()</kbd> method on our <kbd>WebTarget</kbd> instance, we then need to invoke <kbd>resolveTemplate()</kbd>. The first parameter for this method is the name of the parameter (without the curly braces), and the second parameter is the value we wish to pass as a parameter to our RESTful web service.</p>
<p>If we need to pass more than one parameter to one of our web services, we simply need to use the following format for the <kbd>@Path</kbd> parameter at the method level:</p>
<pre style="padding-left: 60px">@Path("/{paramName1}/{paramName2}/") </pre>
<p>Then, annotate the corresponding method arguments with the <kbd>@PathParam</kbd> annotation:</p>
<pre style="padding-left: 60px">public String someMethod(@PathParam("paramName1") String param1, 
@PathParam("paramName2") String param2) </pre>
<p>The web service can then be invoked by modifying the web service's URI to pass the parameters in the order specified in the <kbd>@Path</kbd> annotation. For example, the following URI would pass the values <kbd>1</kbd> and <kbd>2</kbd> for <kbd>paramName1</kbd> and <kbd>paramName2</kbd>:</p>
<p><kbd><span class="InternetLink0">http://localhost:8080/contextroot/resources/customer/1/2</span></kbd></p>
<p><span class="NormalPACKTChar">The above URI will work both from the command line or through a web service client we develop with the JAX-RS client API.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-sent events</h1>
                </header>
            
            <article>
                
<p>Typically, every interaction between a web service and its client is initiated by the client; the client sends a request (<kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, or <kbd>DELETE</kbd>), then receives a response from the server. Server-sent events technology allows RESTful web services to "take the initiative" to send messages to a client, that is, to send data that is not a response to a client request. Server-sent events are useful for sending data continuously to a client, for applications such as stock tickers, news feeds, sports scores, and so on.</p>
<p>JAX-RS 2.1 introduces server-sent event support. The following example illustrates how to implement this functionality into our JAX-RS RESTful web services:</p>
<pre style="padding-left: 60px">package net.ensode.javaee8book.jaxrs21sse; 
 
import java.util.List; 
import java.util.concurrent.Executor; 
import java.util.concurrent.Executors; 
import java.util.concurrent.TimeUnit; 
import java.util.stream.Collectors; 
import java.util.stream.Stream; 
import javax.ws.rs.GET; 
import javax.ws.rs.Path; 
import javax.ws.rs.Produces; 
import javax.ws.rs.core.Context; 
import javax.ws.rs.core.MediaType; 
import javax.ws.rs.sse.OutboundSseEvent; 
import javax.ws.rs.sse.Sse; 
import javax.ws.rs.sse.SseEventSink; 
 
@Path("serversentevents") 
public class SseResource { 
 
    List&lt;Float&gt; stockTickerValues = null; 
    Executor executor = Executors.newSingleThreadExecutor(); 
 
    @GET 
    @Produces(MediaType.SERVER_SENT_EVENTS) 
<strong>    public void sendEvents(@Context SseEventSink sseEventSink, </strong><strong>       <br/>      @Context Sse sse) {</strong> 
        initializeStockTickerValues(); 
        executor.execute(() -&gt; { 
            stockTickerValues.forEach(value -&gt; { 
                try { 
                    TimeUnit.SECONDS.sleep(5); 
                    System.out.println(String.format( 
                      "Sending the following value: %.2f", value)); 
<strong>                     final OutboundSseEvent outboundSseEvent =</strong><strong>                             <br/>                      sse.newEventBuilder()</strong><strong>                           <br/>                     .name("ENSD stock ticker value")</strong><strong>                                 <br/>                     .data(String.class,     <br/>                      String.format("%.2f", value))</strong><strong>                            <br/>                     .build();</strong><strong>                       <br/>                      sseEventSink.send(outboundSseEvent);</strong> 
                } catch (InterruptedException ex) { 
                    ex.printStackTrace(); 
                } 
 
            }); 
 
        }); 
    } 
 
    private void initializeStockTickerValues() { 
        stockTickerValues = Stream.of(50.3f, 55.5f, 62.3f,  <br/>         70.7f, 10.1f, 5.1f).collect(Collectors.toList()); 
    } 
} </pre>
<p>The preceding example simulates sending stock prices for a fictitious company to the client. To send server-sent events to the client, we need to utilize instances of the <kbd>SseEventSink</kbd> and <kbd>Sse</kbd> classes, as illustrated in our example. Both of these classes are injected into our RESTful web service via the <kbd>@Context</kbd> annotation.</p>
<p>To send an event, we first need to build an instance of <kbd>OutboundSseEvent</kbd> via the <kbd>newEventBuilder()</kbd> method of our <kbd>Sse</kbd> instance. This method creates an instance of <a><kbd>OutboundSseEvent.Builder</kbd></a>, which is then used to create the necessary <kbd>OutboundSseEvent</kbd> instance.</p>
<p>We give our event a name by invoking the <kbd>name()</kbd> method on our <kbd>OutboundSseEvent.Builder</kbd> instance, then set the data to <span>be sent</span> to the client via its <kbd>data()</kbd> method. The <kbd>data()</kbd> method takes two arguments: the first one is the type of data we are sending to the client (<kbd>String</kbd>, in our case), and the second one is the actual data we send to the client.</p>
<p>Once we have set our event's name and data via the corresponding method, we build an instance of <kbd>OutboundSseEvent</kbd> by invoking the <kbd>build()</kbd> method on <kbd>OutboundSseEvent.Builder</kbd>.</p>
<p>Once we have built our instance of <kbd>OutboundSseEvent</kbd>, we send it to the client by passing it as a parameter to the <kbd>send()</kbd> method of <kbd>SseEventSink</kbd>. In our example, we loop through the simulated stock prices and send it to the client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript Server-sent events client</h1>
                </header>
            
            <article>
                
<p>So far, all of our client examples have either used the curl command-line utility or the JAX-RS RESTful web server client API. It is very common to use JavaScript code running on a browser as a RESTful web service client, therefore, in this section, we will take that approach. The following example illustrates an HTML/JavaScript client receiving server-sent events:</p>
<pre style="padding-left: 60px">&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
    &lt;head&gt; 
        &lt;title&gt;Stock Ticker Monitor&lt;/title&gt; 
        &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 
    &lt;/head&gt; 
    &lt;body onload="getStockTickerValues()"&gt; 
        &lt;h2&gt;Super fancy stock ticker monitor&lt;/h2&gt; 
        &lt;table cellspacing="0" cellpadding="0"&gt; 
            &lt;tr&gt; 
                &lt;td&gt;ENSD Stock Ticker Value: &lt;/td&gt; 
                &lt;td&gt; &lt;span id="stickerVal"&gt;&lt;/span&gt;&lt;/td&gt; 
            &lt;/tr&gt; 
            &lt;tr&gt; 
                &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;button&gt;Buy!&lt;/button&gt;&lt;/td&gt; 
            &lt;/tr&gt; 
        &lt;/table&gt; 
        &lt;script&gt; 
<strong>            function getStockTickerValues() {</strong><strong>         <br/>              var source = new  </strong><strong>                   <br/>                 EventSource("webresources/serversentevents/");</strong><strong>                 <br/>                source.addEventListener('ENSD stock ticker value',</strong><strong>                    <br/>                function (event) {</strong><strong>                     <br/>                document.getElementById("stickerVal").<br/>                      innerHTML = event.data;</strong><strong>               <br/>                    }, false);</strong><strong>         <br/>            }</strong> 
        &lt;/script&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p>The <kbd>getStockTickerValues()</kbd> JavaScript function creates an <kbd>EventSource</kbd> object. This constructor takes a <kbd>String</kbd> representing the URL of the server sending the events as a parameter. In our case, we used a relative URL, since the preceding HTML/JavaScript code is hosted on the same server as the server code. If this wasn't the case, we would have needed to use a full URL.</p>
<p>We implement the functionality to be executed when the client receives an event by adding an event listener to our <kbd>EventSource</kbd> instance via its <kbd>addEventListener()</kbd> function. This function takes the event name (notice that the value matches the name we sent in the Java code for our RESTful web service), and a function to be executed when an event is received. In our example, we simply update the contents of a <kbd>&lt;span&gt;</kbd> tag with the data of the received message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed how to easily develop RESTful web services using JAX-RS, a new addition to the Java EE specification.</p>
<p>We covered how to develop a RESTful web service by adding a few simple annotations to our code. We also explained how to automatically convert data between Java and XML by taking advantage of the <strong>Java API for XML Binding</strong> (<strong>JAXB</strong>).</p>
<p>Additionally, we covered how to pass parameters to our RESTful web services via the <kbd>@PathParam</kbd> and <kbd>@QueryParam</kbd> annotations.</p>
<p>Finally, we discussed how to develop web services that are able to send server-sent events to all of their clients, utilizing the new JAX-RS 2.1 Server-Sent event support.</p>


            </article>

            
        </section>
    </body></html>