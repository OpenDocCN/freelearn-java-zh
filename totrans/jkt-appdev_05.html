<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.2.1">Microservices Development with Jakarta EE</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Microservices is an architectural style in which code is deployed in small, granular modules. </span><span class="koboSpan" id="kobo.3.2">The microservices architecture reduces coupling and increases cohesion. </span><span class="koboSpan" id="kobo.3.3">Typically, microservices are implemented as RESTful web services, using JSON to pass data to one another, by invoking HTTP methods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">GET</span></strong><span class="koboSpan" id="kobo.5.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">POST</span></strong><span class="koboSpan" id="kobo.7.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">PUT</span></strong><span class="koboSpan" id="kobo.9.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">DELETE</span></strong><span class="koboSpan" id="kobo.11.1">) on each other. </span><span class="koboSpan" id="kobo.11.2">Since communication between microservices is done via HTTP methods, microservices written in different programming languages can interact with each other. </span><span class="koboSpan" id="kobo.11.3">In this chapter, we will cover how we can use Jakarta EE to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">implement microservices.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">An introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">to microservices</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Microservices and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Jakarta EE</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Developing microservices using </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Jakarta EE</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.21.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.22.1">Example source code for this chapter can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">at </span></span><a href="https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src"><span class="No-Break"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/Jakarta-EE-Application-Development/tree/main/ch05_src</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.25.1">.</span></span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.26.1">An introduction to microservices</span></h1>
<p><span class="koboSpan" id="kobo.27.1">Architecting applications as a series of microservices offers some advantages over traditionally designed applications, as well </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.28.1">as some disadvantages. </span><span class="koboSpan" id="kobo.28.2">When considering a microservices architecture for our applications, we must carefully weigh the advantages and disadvantages before we make </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">our decision.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.30.1">The advantages of a microservices architecture</span></h2>
<p><span class="koboSpan" id="kobo.31.1">Developing an </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.32.1">application as a series of microservices offers several advantages over traditionally designed applications, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Smaller code bases</span></strong><span class="koboSpan" id="kobo.35.1">: Since each microservice is a small, standalone unit, code bases for microservices tend to be smaller and easier to manage than traditionally </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">designed applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Microservices encourage good coding practices</span></strong><span class="koboSpan" id="kobo.38.1">: A microservices architecture encourages loose coupling and </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">high cohesion.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">Greater resilience</span></strong><span class="koboSpan" id="kobo.41.1">: Traditionally designed applications act as a single point of failure; if any </span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.42.1">component of an application is down or unavailable, the whole application is unavailable. </span><span class="koboSpan" id="kobo.42.2">Since microservices are independent modules, one component (i.e., one microservice) being down does not necessarily make the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">application unavailable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Scalability</span></strong><span class="koboSpan" id="kobo.45.1">: Since applications developed as a series of microservices are composed of a number of different modules, scalability becomes easier. </span><span class="koboSpan" id="kobo.45.2">We can focus only on those services that may need scaling, without having to waste effort on parts of an application that do not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">be scaled.</span></span></li>
</ul>
<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.47.1">The disadvantages of a microservices architecture</span></h2>
<p><span class="koboSpan" id="kobo.48.1">Developing </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.49.1">and deploying applications adhering to microservices architecture comes with its own set of challenges, regardless of what programming language or application framework is used to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">an application:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Additional operational and tooling overhead</span></strong><span class="koboSpan" id="kobo.52.1">: Each microservice implementation would require its own (possibly automated) deployment, monitoring systems, and </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Debugging microservices may be more involved than debugging traditional enterprise applications</span></strong><span class="koboSpan" id="kobo.55.1">: If an end user reports a problem with their application and the application utilizes multiple microservices internally, it is not always clear which of the microservices may be the culprit. </span><span class="koboSpan" id="kobo.55.2">This may be especially difficult if the microservices involved are developed by different teams with </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">different priorities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Distributed transactions may be a challenge</span></strong><span class="koboSpan" id="kobo.58.1">: Rolling back a transaction involving several microservices may be hard. </span><span class="koboSpan" id="kobo.58.2">A common approach to work around this is to isolate microservices as much as possible, treat them as single units, and then have local transaction management for each microservice. </span><span class="koboSpan" id="kobo.58.3">For example, if microservice A invokes microservice B and there is a problem with the latter, a local transaction in microservice B would roll back. </span><span class="koboSpan" id="kobo.58.4">Then, it would return a 500 HTTP status code (server error) to microservice A. </span><span class="koboSpan" id="kobo.58.5">It could then use this HTTP status code as a signal to initiate a compensating transaction, restoring the system to its </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">initial state.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Network latency</span></strong><span class="koboSpan" id="kobo.61.1">: Since microservices rely on HTTP method calls for communication, performance may suffer due to </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">network latency.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.63.1">The potential for complex interdependencies</span></strong><span class="koboSpan" id="kobo.64.1">: While independent microservices tend to be simple, they are dependent on each other. </span><span class="koboSpan" id="kobo.64.2">A microservices architecture can potentially </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.65.1">create a complex dependency graph. </span><span class="koboSpan" id="kobo.65.2">This situation can be worrisome if some of our services depend on microservices developed by other teams that may have conflicting priorities (i.e., we find a bug in their microservice, but fixing the bug may not be a priority for the </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">other team).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.67.1">Susceptibility to the fallacies of distributed computing</span></strong><span class="koboSpan" id="kobo.68.1">: Applications developed following a microservices architecture may make some incorrect assumptions, such as network reliability, zero latency, and </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">infinite bandwidth.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.70.1">Now that we’ve talked about microservices in general, we’ll focus our attention on how Jakarta EE can be leveraged to develop applications adhering to a </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">microservices architecture.</span></span></p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.72.1">Microservices and Jakarta EE</span></h1>
<p><span class="koboSpan" id="kobo.73.1">Some may think that Jakarta EE is “too heavyweight” for microservices development. </span><span class="koboSpan" id="kobo.73.2">This is simply not the case. </span><span class="koboSpan" id="kobo.73.3">Because of this misconception, some may also think that Jakarta EE may not be suitable </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.74.1">for a microservices architecture when, in reality, Jakarta EE fits microservices development well. </span><span class="koboSpan" id="kobo.74.2">Some time ago, Java EE applications were deployed to a “heavyweight” application server. </span><span class="koboSpan" id="kobo.74.3">Nowadays, most Jakarta EE application server vendors offer lightweight application </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.75.1">servers that use very little memory or disk space. </span><span class="koboSpan" id="kobo.75.2">Some examples of these Jakarta EE-compliant lightweight application servers include IBM’s Open Liberty, Red Hat’s WildFly Swarm, Apache TomEE, and Payara Micro. </span><span class="koboSpan" id="kobo.75.3">Jakarta EE 10 introduced the core profile, which is ideal for microservices development using </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Jakarta EE.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">Developing microservices with the Jakarta EE core profile involves writing standard Jakarta EE applications, while limiting yourself to the subset of Jakarta EE APIs supported by the core profile, namely Jakarta REST, JSON-P, JSON-B, and CDI. </span><span class="koboSpan" id="kobo.77.2">If interacting with a relational database, we may need transaction support and likely would like an object-relational mapping API, such as Jakarta Persistence. </span><span class="koboSpan" id="kobo.77.3">To interact with a relational database, we would need the Jakarta EE web profile, as the core profile does not include Jakarta Persistence or transaction support. </span><span class="koboSpan" id="kobo.77.4">Only microservices needing to directly interact with a relational database would need the web profile; other microservices can be developed against the </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">core profile.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Jakarta EE developers can leverage their existing expertise when developing microservices. </span><span class="koboSpan" id="kobo.79.2">When developing microservices, the main requirement is the development of RESTful web services, which can be easily implemented using Jakarta REST. </span><span class="koboSpan" id="kobo.79.3">These RESTful web services would be packaged in a WAR file and deployed to a lightweight Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">EE runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">When using modern, embeddable Jakarta EE implementations, usually only one application is deployed to each instance of the application server, and, in some cases, the “tables are turned” so to speak, by making the Jakarta EE implementation just a library that the application uses as a dependency. </span><span class="koboSpan" id="kobo.81.2">With these </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.82.1">modern Jakarta EE implementations, several instances of the Jakarta EE runtime are often deployed to a server, making modern Jakarta EE very suitable for microservices development. </span><span class="koboSpan" id="kobo.82.2">Many modern, lightweight Jakarta EE application servers are embeddable, allowing the </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.83.1">creation of an “uber jar,” which includes both the application code and the application server libraries. </span><span class="koboSpan" id="kobo.83.2">This “uber jar” is then transferred to the server and run as a standalone application. </span><span class="koboSpan" id="kobo.83.3">In addition to “uber jars,” modern application servers can be added to a container image (such as Docker). </span><span class="koboSpan" id="kobo.83.4">Then, our application can be deployed as a thin WAR, typically only a few kilobytes in size; this approach has the advantage of very fast deployments, usually under </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">two seconds.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">By deploying to a contemporary, Jakarta EE core profile-compliant application server (or, as explained in the previous paragraph, creating an “uber jar”), Jakarta EE developers can certainly leverage their existing expertise to develop applications adhering to a </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">microservices architecture.</span></span></p>
<h1 id="_idParaDest-66"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.87.1">Developing microservices using Jakarta EE</span></h1>
<p><span class="koboSpan" id="kobo.88.1">Now that we have briefly introduced you to microservices, we are ready to show an example of a microservices </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.89.1">application written using Jakarta EE. </span><span class="koboSpan" id="kobo.89.2">Our example </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.90.1">application should be very familiar to most Jakarta EE developers. </span><span class="koboSpan" id="kobo.90.2">It is a simple </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">CRUD</span></strong><span class="koboSpan" id="kobo.92.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Create, Read, Update, Delete</span></strong><span class="koboSpan" id="kobo.94.1">) application </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.95.1">developed as a series of microservices. </span><span class="koboSpan" id="kobo.95.2">The application will follow the familiar MVC design pattern, with the “View” and “Controller” developed </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.96.1">as microservices. </span><span class="koboSpan" id="kobo.96.2">The application will also utilize the very common </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Data Access Object</span></strong><span class="koboSpan" id="kobo.98.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.99.1">DAO</span></strong><span class="koboSpan" id="kobo.100.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">pattern</span></strong><span class="koboSpan" id="kobo.102.1">, with our DAO developed as a microservice </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">as well.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.104.1">DAO Pattern</span></p>
<p class="callout"><span class="koboSpan" id="kobo.105.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">DAO </span></strong><span class="koboSpan" id="kobo.107.1">design pattern is one that allows us to separate data access code from the rest of our application. </span><span class="koboSpan" id="kobo.107.2">Allowing us to switch the implementation of the data access code without impacting the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Our application will be developed as three modules – first, a microservices client, followed by a microservices implementation of a controller in the MVC design pattern, and then an implementation of the DAO design pattern implemented as </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">a microservice.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.111.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.112.1">The example code is not a full CRUD application. </span><span class="koboSpan" id="kobo.112.2">For simplicity, we only implemented the “create” part of our </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">CRUD application.</span></span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.114.1">Developing microservices client code</span></h2>
<p><span class="koboSpan" id="kobo.115.1">Before delving into developing our services, we will first develop a microservices client using plain HTML </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.116.1">and JavaScript. </span><span class="koboSpan" id="kobo.116.2">The JavaScript code will invoke the controller microservice, passing a JSON representation of user-entered data. </span><span class="koboSpan" id="kobo.116.3">The controller service will then invoke the persistence service and save the data to a database. </span><span class="koboSpan" id="kobo.116.4">Each microservice will return an HTTP code indicating success or </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">error condition.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">The most relevant parts of our client code are the HTML form and the JavaScript code to submit it to our </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">Controller microservice.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">The form in our HTML page contains the following </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">input fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
&lt;form id="customerForm"&gt;
  &lt;!-- layout markup omitted for brevity --&gt;
  &lt;label for="salutation"&gt;Salutation&lt;/label&gt;
  &lt;select id="salutation" name="salutation" &gt;
    &lt;option value=""&gt; &lt;/option&gt;
    &lt;option value="Mr"&gt;Mr&lt;/option&gt;
    &lt;option value="Mrs"&gt;Mrs&lt;/option&gt;
    &lt;option value="Miss"&gt;Miss&lt;/option&gt;
    &lt;option value="Ms"&gt;Ms&lt;/option&gt;
    &lt;option value="Dr"&gt;Dr&lt;/option&gt;
  &lt;/select&gt;
  &lt;label for="firstName"&gt;First Name&lt;/label&gt;
  &lt;input type="text" maxlength="10" id="firstName"
    name="firstName" placeholder="First Name"&gt;
  &lt;label for="middleName"&gt;Middle Name&lt;/label&gt;
  &lt;input type="text" maxlength="10"  id="middleName"
    name="middleName" placeholder="Middle Name"&gt;
  &lt;label for="lastName"&gt;Last Name&lt;/label&gt;
  &lt;input type="text" maxlength="20"  id="lastName"
    name="lastName" placeholder="Last Name"&gt;
  &lt;button type="submit" id="submitBtn" &gt;Submit&lt;/button&gt;
&lt;/form&gt;</span></pre> <p><span class="koboSpan" id="kobo.123.1">Our web client form contains a number of input fields to collect data from the user. </span><span class="koboSpan" id="kobo.123.2">It is implemented using </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.124.1">plain HTML, with no additional CSS or JavaScript libraries. </span><span class="koboSpan" id="kobo.124.2">Our page also has a script to send form data to the controller microservice using JavaScript, as illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">code block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
&lt;script&gt;
  async function createCustomer(json) {
    try {
      </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">const response = await fetch(  '</span></strong><span class="koboSpan" id="kobo.128.1">http://localhost:8080/
</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">        </span></strong><span class="koboSpan" id="kobo.130.1">CrudController/resources/customercontroller/'</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">, {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.132.1">        method: 'POST',</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.133.1">        body: json,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.134.1">        headers: {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.135.1">          'Content-Type': 'application/json'</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.136.1">        </span></strong><strong class="bold"><span class="koboSpan" id="kobo.137.1">}</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.138.1">      });</span></strong><span class="koboSpan" id="kobo.139.1">
      document.querySelector("#msg").innerHTML =
        "Customer saved successfully."
</span><span class="koboSpan" id="kobo.139.2">    } catch (error) {
      document.querySelector("#msg").innerHTML =
        "There was an error saving customer data.";
    }
  }
  function handleSubmit(event) {
    event.preventDefault();
    console.log("form submitted");
    const formData = new FormData(event.target);
    var formDataObject = {};
    formData.forEach(function (value, key) {
      formDataObject[key] = value;
    });
    var json = JSON.stringify(formDataObject);
    createCustomer(json);
  }
  const form = document.querySelector('#customerForm');
  form.addEventListener('submit', handleSubmit);
&lt;/script&gt;</span></pre> <p><span class="koboSpan" id="kobo.140.1">When the form </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.141.1">is submitted, our script generates a JSON-formatted representation of the user-entered data and then sends an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">POST</span></strong><span class="koboSpan" id="kobo.143.1"> request to our controller service, using the JavaScript fetch API. </span><span class="koboSpan" id="kobo.143.2">In our example, our controller service is deployed to a Jakarta EE runtime on our local workstation, listening on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">8080</span></strong><span class="koboSpan" id="kobo.145.1">; therefore, our client code sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">POST</span></strong><span class="koboSpan" id="kobo.147.1"> request </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">to </span></span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">http://localhost:8080/CrudController/resources/customercontroller/</span></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">We can now point our browser to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">CrudView</span></strong><span class="koboSpan" id="kobo.153.1"> application URL (http://localhost:8080/CrudView in our example). </span><span class="koboSpan" id="kobo.153.2">After entering some data, the page will look as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">following screenshot.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 5.1 – The HTML/JavaScript RESTful web service client" src="image/B21231_5_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 5.1 – The HTML/JavaScript RESTful web service client</span></p>
<p><span class="koboSpan" id="kobo.157.1">When the </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.158.1">user clicks on the </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">Submit</span></strong><span class="koboSpan" id="kobo.160.1"> button, the client passes a JSON representation of user-entered data to the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">controller service.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.162.1">The controller service</span></h2>
<p><span class="koboSpan" id="kobo.163.1">The controller service is a standard RESTful web service implementation of a controller in the MVC design </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.164.1">pattern, implemented using </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">Jakarta REST:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
package com.ensode.jakartaeebook.microservices.crudcontroller.service;
//imports omitted for brevity
@Path("/customercontroller")
public class CustomerControllerService {
  @OPTIONS
  public Response options() {
    LOG.log(Level.INFO, "CustomerControllerService.options() 
</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">      </span></strong><span class="koboSpan" id="kobo.168.1">invoked");
    return Response.ok("")
      .</span><strong class="bold"><span class="koboSpan" id="kobo.169.1">header("Access-Control-Allow-Origin",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.170.1">        "</span></strong><span class="koboSpan" id="kobo.171.1">http://localhost:8080"</span><strong class="bold"><span class="koboSpan" id="kobo.172.1">)</span></strong><span class="koboSpan" id="kobo.173.1">
      </span><strong class="bold"><span class="koboSpan" id="kobo.174.1">.header("Access-Control-Allow-Headers",</span></strong><span class="koboSpan" id="kobo.175.1">
        "origin, content-type, accept, authorization")
      .header("Access-Control-Allow-Credentials", "true")
      .header("Access-Control-Allow-Methods",
        "GET, POST, PUT, DELETE, OPTIONS, HEAD")
      .header("Access-Control-Max-Age", "1209600")
        .build();
  }
  @POST
  @Consumes(MediaType.APPLICATION_JSON)
  public Response addCustomer(Customer customer) {
    Response response;
    Response persistenceServiceResponse;
    CustomerPersistenceClient client = new 
      CustomerPersistenceClient();
    </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">persistenceServiceResponse = client.create(customer);</span></strong><span class="koboSpan" id="kobo.177.1">
    client.close();
    </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">if (persistenceServiceResponse.getStatus() == 201) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.179.1">      response = Response.ok("{}").</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.180.1">        header("Access-Control-Allow-Origin",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.181.1">        "http://localhost:8080").build();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.182.1">    } else {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.183.1">      response = Response.serverError().</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.184.1">        header("Access-Control-Allow-Origin",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.185.1">        "http://localhost:8080").build();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.186.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.187.1">    return response;</span></strong><span class="koboSpan" id="kobo.188.1">
  }
}</span></pre> <p><span class="koboSpan" id="kobo.189.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">options()</span></strong><span class="koboSpan" id="kobo.191.1"> method, annotated with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">jakarta.ws.rs.OPTIONS</span></strong><span class="koboSpan" id="kobo.193.1"> annotation is necessary, since the </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.194.1">browser automatically calls it, before invoking the </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.195.1">actual request containing the main logic of our server. </span><span class="koboSpan" id="kobo.195.2">In this method, we set some header values to allow </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">CORS</span></strong><span class="koboSpan" id="kobo.197.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.198.1">Cross-Origin Resource Sharing</span></strong><span class="koboSpan" id="kobo.199.1">), which in simple terms means we allow our service to be invoked from a different server than the one where our service is running. </span><span class="koboSpan" id="kobo.199.2">Note that we explicitly allow requests from </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">http://localhost:8080</span></strong><span class="koboSpan" id="kobo.201.1">, which is the host and port where our client code </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">is deployed.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">The main logic of our controller service is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">addCustomer()</span></strong><span class="koboSpan" id="kobo.205.1"> method. </span><span class="koboSpan" id="kobo.205.2">This method receives an instance of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">Customer</span></strong><span class="koboSpan" id="kobo.207.1"> class as a parameter; Jakarta REST automatically populates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Customer</span></strong><span class="koboSpan" id="kobo.209.1"> parameter with the JSON-formatted data sent by </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">the client.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.211.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.212.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Customer</span></strong><span class="koboSpan" id="kobo.214.1"> class is a simple </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Data Transfer Object</span></strong><span class="koboSpan" id="kobo.216.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.217.1">DTO</span></strong><span class="koboSpan" id="kobo.218.1">), containing a few properties matching the </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.219.1">input fields in the form in the client, plus the corresponding getters and setters. </span><span class="koboSpan" id="kobo.219.2">Since the class is quite simple, we decided not to </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">show it.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">addCustomer()</span></strong><span class="koboSpan" id="kobo.223.1"> method, we create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">CustomerPersistenceClient()</span></strong><span class="koboSpan" id="kobo.225.1">, which is a client for the persistence service, implemented using the Jakarta REST </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">client API.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Then, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">addCustomer()</span></strong><span class="koboSpan" id="kobo.229.1"> method invokes the persistence service by invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">create()</span></strong><span class="koboSpan" id="kobo.231.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">CustomerPersistenceClient</span></strong><span class="koboSpan" id="kobo.233.1">, checks the HTTP status code returned by the </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.234.1">persistence service, and then sends an appropriate response to </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">Now, let’s take a look at the implementation of our Jakarta REST </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">client code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.238.1">
package com.ensode.jakartaeebook.microservices.crudcontroller.restclient;
//imports omitted
public class CustomerPersistenceClient {
  private final WebTarget webTarget;
  private final Client client;
  </span><strong class="bold"><span class="koboSpan" id="kobo.239.1">private static final String BASE_URI =</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.240.1">   "http://localhost:8080/CrudPersistence/resources";</span></strong><span class="koboSpan" id="kobo.241.1">
  public CustomerPersistenceClient() {
    </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">client = ClientBuilder.newClient();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.243.1">    webTarget = client.target(BASE_URI).path(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.244.1">      "customerpersistence");</span></strong><span class="koboSpan" id="kobo.245.1">
  }
  public Response create(Customer customer)
    throws ClientErrorException {
    </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">return webTarget.request(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.247.1">      MediaType.APPLICATION_JSON).post(</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.248.1">      Entity.entity(customer,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.249.1">      MediaType.APPLICATION_JSON), Response.class);</span></strong><span class="koboSpan" id="kobo.250.1">
  }
  public void close() {
    client.close();
  }
}</span></pre> <p><span class="koboSpan" id="kobo.251.1">As we can see, our client code is a fairly simple class that makes use of the Jakarta REST client API. </span><span class="koboSpan" id="kobo.251.2">We declare </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.252.1">a constant containing the base URI of the service we are invoking (our persistence service). </span><span class="koboSpan" id="kobo.252.2">In its constructor, we create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">jakarta.ws.rs.client.ClientBuilder</span></strong><span class="koboSpan" id="kobo.254.1">. </span><span class="koboSpan" id="kobo.254.2">We then set its base URI and path, matching the appropriate values for our persistence service. </span><span class="koboSpan" id="kobo.254.3">Our client class has a single method, which submits an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">POST</span></strong><span class="koboSpan" id="kobo.256.1"> request to the persistence service and then returns the response sent back </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">from it.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">Now that we have successfully developed our controller service, we are ready to explore the final component of our application – the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">persistence service.</span></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.260.1">The persistence service</span></h2>
<p><span class="koboSpan" id="kobo.261.1">Our persistence </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.262.1">service is implemented as a simple RESTful </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.263.1">web service using Jakarta REST. </span><span class="koboSpan" id="kobo.263.2">Its </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">create()</span></strong><span class="koboSpan" id="kobo.265.1"> method is invoked when the service receives an HTTP </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
package com.ensode.jakartaeebook.microservices.crudpersistence.service;
//imports omitted for brevity
@ApplicationScoped
@Path("customerpersistence")
public class CustomerPersistenceService {
  private static final Logger LOG =
    Logger.getLogger(
      CustomerPersistenceService.class.getName());
  @Context
  private UriInfo uriInfo;
  @Inject
  private CrudDao customerDao;
  </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">@POST</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.270.1">  @Consumes(MediaType.APPLICATION_JSON)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.271.1">  public Response create(Customer customer) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.272.1">    try {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.273.1">      customerDao.create(customer);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.274.1">    } catch (Exception e) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.275.1">      LOG.log(Level.SEVERE, "Exception caught", e);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.276.1">      return Response.serverError().build();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.277.1">    }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.278.1">    return Response.created(uriInfo.getAbsolutePath()).build();</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.279.1">  }</span></strong><span class="koboSpan" id="kobo.280.1">
}</span></pre> <p><span class="koboSpan" id="kobo.281.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">create()</span></strong><span class="koboSpan" id="kobo.283.1"> method is invoked when the controller service sends an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">POST</span></strong><span class="koboSpan" id="kobo.285.1"> request to the persistence service. </span><span class="koboSpan" id="kobo.285.2">This method simply invokes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">create()</span></strong><span class="koboSpan" id="kobo.287.1"> method on a class implementing the DAO </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.288.1">design pattern. </span><span class="koboSpan" id="kobo.288.2">Our persistence service returns an HTTP response, </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">201</span></strong><span class="koboSpan" id="kobo.290.1"> (Created). </span><span class="koboSpan" id="kobo.290.2">If everything goes well and the DAO’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">create()</span></strong><span class="koboSpan" id="kobo.292.1"> method throws an exception, then our </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.293.1">service returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">500</span></strong><span class="koboSpan" id="kobo.295.1"> HTTP error (Internal </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">Server Error).</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Our DAO is implemented as a CDI-managed bean, using JPA to insert data into </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
package com.ensode.jakartaeebook.microservices.crudpersistence.dao;
//imports omitted for brevity
@ApplicationScoped
@DataSourceDefinition(name = 
    "java:app/jdbc/microservicesCrudDatasource",
        className = "org.h2.jdbcx.JdbcDataSource",
        url = "jdbc:h2:tcp://127.0.1.1:9092/mem:microservicescrud",
        user = "sa",
        password = "")
public class CrudDao {
  @PersistenceContext(unitName = "CustomerPersistenceUnit")
  private EntityManager em;
  @H2DatabaseWrapper
  public void create(Customer customer) {
    em.persist(customer);
  }
}</span></pre> <p><span class="koboSpan" id="kobo.300.1">Our DAO couldn’t </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.301.1">be much simpler; it implements a single method that invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">persist()</span></strong><span class="koboSpan" id="kobo.303.1"> method on an injected instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">EntityManager</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">Note that </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.306.1">we took advantage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">@DataSourceDefinition</span></strong><span class="koboSpan" id="kobo.308.1"> annotation to create a data source pointing to our database. </span><span class="koboSpan" id="kobo.308.2">This annotation is a standard Jakarta EE annotation that allows us to define data sources in an </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">implementation-independent way.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.310.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.311.1">In our persistence service project, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">Customer</span></strong><span class="koboSpan" id="kobo.313.1"> class is a trivial </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">JPA entity.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">Now that we have developed all three components of our application, we are ready to see it </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">in action.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Once a user enters some data and clicks the submit button, we should see a “success” message at the top of our page (see </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.318.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.319.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.321.1"><img alt="Figure 5.2 – User-entered data" src="image/B21231_5_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.322.1">Figure 5.2 – User-entered data</span></p>
<p><span class="koboSpan" id="kobo.323.1">If we look </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.324.1">at the database, we should see that the user-entered data persisted </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.325.1">successfully, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.326.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.327.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.329.1"><img alt="Figure 5.3 – Data inserted into the database" src="image/B21231_5_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.330.1">Figure 5.3 – Data inserted into the database</span></p>
<p><span class="koboSpan" id="kobo.331.1">As shown by our example code, developing applications following microservices architecture in Jakarta EE is </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.332.1">very simple. </span><span class="koboSpan" id="kobo.332.2">It doesn’t require any special knowledge. </span><span class="koboSpan" id="kobo.332.3">Microservices </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.333.1">are developed using standard Jakarta EE APIs and deployed to a lightweight Jakarta </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">EE runtime.</span></span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.335.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.336.1">As seen in this chapter, Jakarta EE is quite suitable for </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">microservices development.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">In this chapter, we covered the </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.340.1">We introduced you to microservices, listing the advantages and disadvantages of a </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">microservices architecture</span></span></li>
<li><span class="koboSpan" id="kobo.342.1">We explained how to develop microservices using standard Jakarta EE technologies, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">Jakarta REST</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.344.1">Jakarta EE developers can leverage their existing knowledge to develop microservices architecture – deploying modern, lightweight application servers. </span><span class="koboSpan" id="kobo.344.2">Traditional Jakarta EE applications can interact with microservices quite well, and they can also be refactored iteratively into a microservices architecture when it makes sense. </span><span class="koboSpan" id="kobo.344.3">Whether developing new applications following a microservices architecture, refactoring an existing application to microservices, or modifying existing applications to interact with microservices, Jakarta EE developers can leverage their existing skills for the task </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">at hand.</span></span></p>
</div>
</body></html>