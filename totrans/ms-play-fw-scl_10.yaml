- en: Chapter 10. Debugging and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 调试和日志记录
- en: Debugging and logging are the tools that a developer can use to identify the
    root cause of bugs or unexpected behavior of applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和日志记录是开发者可以使用以识别bug或应用程序意外行为的根本原因的工具。
- en: 'The aim of debugging is to find a defect or pain point in our code, which is
    responsible for a problem. Logging gives us information about an application''s
    state and the various stages of processing it. In this chapter, we will cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的目的是找到我们代码中的缺陷或痛点，这是导致问题的原因。日志记录为我们提供了关于应用程序状态及其处理各个阶段的信息。在本章中，我们将涵盖以下主题：
- en: Debugging a Play application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Play应用程序
- en: Configuring logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置日志记录
- en: Experimenting in a Scala console
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scala控制台中实验
- en: Debugging a Play application
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Play应用程序
- en: 'Play applications can be debugged using a **Java Platform Debugger Architecture**
    (**JPDA**) transport. According to the Oracle documentation (refer to [http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html)):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**Java平台调试架构**（**JPDA**）传输来调试应用程序。根据Oracle文档（参考[http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html)）：
- en: '*A JPDA Transport is a method of communication between a debugger and the virtual
    machine that is being debugged (hereafter the target VM). The communication is
    connection oriented - one side acts as a server, listening for a connection. The
    other side acts as a client and connects to the server. JPDA allows either the
    debugger application or the target VM to act as the server.*'
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*JPDA传输是调试器与被调试的虚拟机（以下简称目标VM）之间通信的方法。通信是面向连接的 - 一方作为服务器，监听连接。另一方作为客户端并连接到服务器。JPDA允许调试器应用程序或目标VM充当服务器。*'
- en: 'We can start a console in debug mode with any one of the following commands:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下任意一个命令以调试模式启动控制台：
- en: 'By using `play`:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`play`：
- en: '[PRE0]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By using `activator`:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`activator`：
- en: '[PRE1]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By using `sbt`:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`sbt`：
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'All these commands are just wrappers used to start the target VM in debug mode
    through the invocation options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些命令只是用于通过调用选项启动目标VM的调试模式的包装器：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `play` command uses the `JPDA_PORT` or `9999` environment variable for the
    port variable. After setting `JPDA_PORT` to the desired port, the target VM will
    listen to that port.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`play`命令使用`JPDA_PORT`或环境变量`9999`作为端口号。在将`JPDA_PORT`设置为所需的端口号后，目标虚拟机将监听该端口。'
- en: Configuring an IDE for debugging
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置IDE进行调试
- en: Once we start the console in debug mode, we can connect our IDE and debug the
    application when it's running. If you are familiar with how this can be done,
    you can skip this section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们以调试模式启动控制台，我们就可以在应用程序运行时连接我们的IDE并对其进行调试。如果你熟悉如何进行此操作，你可以跳过本节。
- en: 'The process of configuring the IDE will be similar to the one used in all the
    IDEs. Let''s see how it''s done in **IntelliJ Idea** through the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 配置IDE的过程将与所有IDE中使用的过程类似。让我们通过以下步骤看看如何在**IntelliJ Idea**中完成它：
- en: Select **Edit Configurations…** from the the **Run** menu. A dialog will pop
    up. It will be similar to the following screenshot:![Configuring an IDE for debugging](img/3803OS_10_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**运行**菜单中选择**编辑配置…**，将弹出一个对话框。它将类似于以下截图：![配置IDE进行调试](img/3803OS_10_01.jpg)
- en: Click on **+** and a menu similar to this screenshot will be visible:![Configuring
    an IDE for debugging](img/3803OS_10_02.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**+**，将显示一个类似于以下截图的菜单：![配置IDE进行调试](img/3803OS_10_02.jpg)
- en: Select **Remote** and update the **Name** and **Port** fields:![Configuring
    an IDE for debugging](img/3803OS_10_03.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**远程**并更新**名称**和**端口**字段：![配置IDE进行调试](img/3803OS_10_03.jpg)
- en: After this, click on the green bug, which is now visible at the top-right corner
    of the IDE, and we are ready to start debugging the application:![Configuring
    an IDE for debugging](img/3803OS_10_04.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击IDE右上角现在可见的绿色虫子图标，我们就可以开始调试应用程序了：![配置IDE进行调试](img/3803OS_10_04.jpg)
- en: Experimenting in a Scala console
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Scala控制台中实验
- en: 'A Scala console is very handy when you''re working on a Scala project. The
    same console is available in our Play application''s console as well. All that
    we need to do to get the Scala console is execute the `console` command in our
    application console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Scala项目中工作时，Scala控制台非常方便。同样的控制台也适用于我们的Play应用程序的控制台。我们只需要在我们的应用程序控制台中执行`console`命令即可获得Scala控制台：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, we can only call methods from **models** or **utils**. If classes or
    objects within these packages utilize `Play.application.configuration` or attempt
    to fetch data from the DB or some other Play utils, we will not be able to instantiate
    them. This is because most of the Play components require access to an instance
    of the currently running Play application. Importing `play.api.Play.current` makes
    this possible but not entirely; we still need a running application, which will
    be marked as the current application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们只能从**模型**或**工具**中调用方法。如果这些包内的类或对象使用`Play.application.configuration`或尝试从数据库或其他Play工具获取数据，我们将无法实例化它们。这是因为大多数Play组件都需要访问当前运行的Play应用程序的实例。导入`play.api.Play.current`使得这成为可能，但并不完全；我们仍然需要一个正在运行的应用程序，这将标记为当前应用程序。
- en: 'Let''s create an application and start it from the Scala console, and then
    import `play.api.Play.current`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Scala控制台创建一个应用程序并启动它，然后导入`play.api.Play.current`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we exit paste mode, the code will be interpreted and the application will
    be started. We can see this from this output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们退出粘贴模式，代码将被解释，应用程序将被启动。我们可以从以下输出中看到这一点：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can view the configuration, view or modify data, and so on. For example,
    let''s try to get the application''s configuration:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以查看配置，查看或修改数据，等等。例如，让我们尝试获取应用程序的配置：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nice, isn''t it? Yet, this is not enough if we want to call actions and check
    results for different inputs. For such cases, we shouldn''t use the `console`
    command, but instead, the `test:console` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，不是吗？然而，如果我们想要为不同的输入调用动作并检查结果，这还不够。在这种情况下，我们不应该使用`console`命令，而应该使用`test:console`命令：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, from this Scala console, we can view the configuration, modify data, as
    well as call an action:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从这个Scala控制台，我们可以查看配置、修改数据，以及调用一个动作：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use `test:console` instead of `console`; you need not switch when you decide
    to check an action.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`test:console`而不是`console`；当你决定检查一个动作时，你不需要切换。
- en: Logging
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging is the act of recording data about when and why an event occurred for
    an application. Logs are extremely useful if they've been handled correctly; otherwise,
    they are just noise. By reviewing the log output, there is a good chance that
    you can determine the cause of an event.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是记录应用程序中事件发生的时间和原因的行为。如果处理得当，日志非常有用；否则，它们只是噪音。通过审查日志输出，你有可能确定事件的原因。
- en: Logs are useful not just to handle application errors, but also to protect an
    application from misuse and malicious attacks as well as understand different
    aspects of a business.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 日志不仅有助于处理应用程序错误，还可以保护应用程序免受误用和恶意攻击，以及了解业务的不同方面。
- en: Play's logging API
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play的日志API
- en: 'Play exposes the logging API through `play.api.Logger`. Let''s have a look
    at the class and object definition of it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Play通过`play.api.Logger`公开日志API。让我们看看它的类和对象定义：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `LoggerLike` trait is just a wrapper over `Slf4jLogger`. By default, all
    application logs are mapped to `Logger` with the application name and the Play-related
    logs are mapped to `Logger` with the Play name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoggerLike`特质只是`Slf4jLogger`的一个包装。默认情况下，所有应用程序日志都映射到带有应用程序名称的`Logger`，而与Play相关的日志则映射到带有Play名称的`Logger`。'
- en: 'After importing `play.api.Logger`, we can use the default logger or define
    a custom one in these ways:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`play.api.Logger`之后，我们可以使用默认的日志记录器或以这种方式定义一个自定义的日志记录器：
- en: 'By using a default logger:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用默认的日志记录器：
- en: '[PRE11]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By using a logger with its class name:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用具有其类名的日志记录器：
- en: '[PRE12]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By using a logger with its custom name:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用具有自定义名称的日志记录器：
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The methods supported by `Logger` are documented in the API at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`支持的方法在API中进行了文档说明，请参阅[https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger)。'
- en: Log configuration in Play
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play的日志配置
- en: 'The Play Framework uses `Logback` as the logging engine. The default configuration
    is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架使用`Logback`作为日志引擎。默认配置如下：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This configuration writes logs in `projectHome/logs/application.log`. Due to
    this, one huge file is generated. We could modify this configuration by providing
    a custom `logger.xml`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将日志写入`projectHome/logs/application.log`。因此，会生成一个巨大的文件。我们可以通过提供自定义的`logger.xml`来修改此配置。
- en: 'The custom log file configuration can be set in two ways:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义日志文件配置可以以两种方式设置：
- en: By saving the configuration in `conf/application-logger.xml` or `conf/logger.xml`.
    Although using any one of the filenames, such as `application-logger.xml` or `logger.xml`,
    works when both are present, the settings of `logger.xml` are not applied.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将配置保存到`conf/application-logger.xml`或`conf/logger.xml`。尽管当两者都存在时，使用任一文件名，如`application-logger.xml`或`logger.xml`都有效，但`logger.xml`的设置不会被应用。
- en: By specifying the file via a system property. This method has a higher precedence
    over the other option.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定系统属性来指定文件。此方法比其他选项具有更高的优先级。
- en: 'There are three properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个属性：
- en: '`logger.resource`: This property sets a file within the class path'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.resource`: 此属性设置类路径内的文件'
- en: '`logger.file`: This property sets a file through its absolute path'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.file`: 此属性通过绝对路径设置文件'
- en: '`logger.url`: This property sets a file using a URL in this way:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.url`: 此属性通过以下方式使用URL设置文件：'
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another important aspect of configuring logging is by setting the desired log
    level. We will discuss this in the next section.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 配置日志的另一个重要方面是通过设置所需的日志级别。我们将在下一节中讨论这一点。
- en: Log levels
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志级别
- en: 'Log levels can be set in `conf/application.conf`. The default values are as
    follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 日志级别可以在`conf/application.conf`中设置。默认值如下：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also set the log levels for the classes belonging to specific packages
    and third-party libraries in this way:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以这样设置属于特定包和第三方库的类的日志级别：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The supported log levels in the decreasing order of severity are as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的日志级别按严重程度递减的顺序如下：
- en: '`ERROR`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ERROR`'
- en: '`WARN`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARN`'
- en: '`INFO`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INFO`'
- en: '`DEBUG`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`'
- en: '`TRACE`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`'
- en: If we wish to turn off logging for some classes or packages, we can set the
    log level as `OFF`. This will disable logging for a particular logger.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望关闭某些类或包的日志记录，可以将日志级别设置为`OFF`。这将禁用特定记录器的日志记录。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some libraries have transitive dependencies on logging libraries. It is best
    to exclude these logging packages when defining a dependency. It can be done as
    follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库对日志库有传递性依赖。在定义依赖时最好排除这些日志包。可以按照以下方式操作：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed how to configure the debugging of a Play application
    in the IDE. We also covered how to start a Play application in a Scala console.
    This chapter also covered the logging API provided by the Play Framework and customizing
    the log format.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何在IDE中配置Play应用的调试。我们还介绍了如何在Scala控制台中启动Play应用。本章还涵盖了Play框架提供的日志API以及自定义日志格式。
- en: A lot of web applications make use of the third-party APIs either to avoid rewriting
    the existing code or to make it easy for users to adopt their applications. In
    the next chapter, we will be checking out how developers can use existing external
    APIs in a Play application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用利用第三方API，要么是为了避免重写现有代码，要么是为了使用户更容易采用他们的应用。在下一章中，我们将探讨开发者如何在Play应用中使用现有的外部API。
