- en: Chapter 10. Debugging and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and logging are the tools that a developer can use to identify the
    root cause of bugs or unexpected behavior of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of debugging is to find a defect or pain point in our code, which is
    responsible for a problem. Logging gives us information about an application''s
    state and the various stages of processing it. In this chapter, we will cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Play application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimenting in a Scala console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a Play application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play applications can be debugged using a **Java Platform Debugger Architecture**
    (**JPDA**) transport. According to the Oracle documentation (refer to [http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/conninv.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*A JPDA Transport is a method of communication between a debugger and the virtual
    machine that is being debugged (hereafter the target VM). The communication is
    connection oriented - one side acts as a server, listening for a connection. The
    other side acts as a client and connects to the server. JPDA allows either the
    debugger application or the target VM to act as the server.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can start a console in debug mode with any one of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `play`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By using `activator`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By using `sbt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All these commands are just wrappers used to start the target VM in debug mode
    through the invocation options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `play` command uses the `JPDA_PORT` or `9999` environment variable for the
    port variable. After setting `JPDA_PORT` to the desired port, the target VM will
    listen to that port.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an IDE for debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we start the console in debug mode, we can connect our IDE and debug the
    application when it's running. If you are familiar with how this can be done,
    you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of configuring the IDE will be similar to the one used in all the
    IDEs. Let''s see how it''s done in **IntelliJ Idea** through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Edit Configurations…** from the the **Run** menu. A dialog will pop
    up. It will be similar to the following screenshot:![Configuring an IDE for debugging](img/3803OS_10_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **+** and a menu similar to this screenshot will be visible:![Configuring
    an IDE for debugging](img/3803OS_10_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Remote** and update the **Name** and **Port** fields:![Configuring
    an IDE for debugging](img/3803OS_10_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, click on the green bug, which is now visible at the top-right corner
    of the IDE, and we are ready to start debugging the application:![Configuring
    an IDE for debugging](img/3803OS_10_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experimenting in a Scala console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Scala console is very handy when you''re working on a Scala project. The
    same console is available in our Play application''s console as well. All that
    we need to do to get the Scala console is execute the `console` command in our
    application console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, we can only call methods from **models** or **utils**. If classes or
    objects within these packages utilize `Play.application.configuration` or attempt
    to fetch data from the DB or some other Play utils, we will not be able to instantiate
    them. This is because most of the Play components require access to an instance
    of the currently running Play application. Importing `play.api.Play.current` makes
    this possible but not entirely; we still need a running application, which will
    be marked as the current application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an application and start it from the Scala console, and then
    import `play.api.Play.current`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we exit paste mode, the code will be interpreted and the application will
    be started. We can see this from this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can view the configuration, view or modify data, and so on. For example,
    let''s try to get the application''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice, isn''t it? Yet, this is not enough if we want to call actions and check
    results for different inputs. For such cases, we shouldn''t use the `console`
    command, but instead, the `test:console` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from this Scala console, we can view the configuration, modify data, as
    well as call an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `test:console` instead of `console`; you need not switch when you decide
    to check an action.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging is the act of recording data about when and why an event occurred for
    an application. Logs are extremely useful if they've been handled correctly; otherwise,
    they are just noise. By reviewing the log output, there is a good chance that
    you can determine the cause of an event.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are useful not just to handle application errors, but also to protect an
    application from misuse and malicious attacks as well as understand different
    aspects of a business.
  prefs: []
  type: TYPE_NORMAL
- en: Play's logging API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Play exposes the logging API through `play.api.Logger`. Let''s have a look
    at the class and object definition of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `LoggerLike` trait is just a wrapper over `Slf4jLogger`. By default, all
    application logs are mapped to `Logger` with the application name and the Play-related
    logs are mapped to `Logger` with the Play name.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing `play.api.Logger`, we can use the default logger or define
    a custom one in these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using a default logger:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By using a logger with its class name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By using a logger with its custom name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The methods supported by `Logger` are documented in the API at [https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger](https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.Logger).
  prefs: []
  type: TYPE_NORMAL
- en: Log configuration in Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play Framework uses `Logback` as the logging engine. The default configuration
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This configuration writes logs in `projectHome/logs/application.log`. Due to
    this, one huge file is generated. We could modify this configuration by providing
    a custom `logger.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The custom log file configuration can be set in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By saving the configuration in `conf/application-logger.xml` or `conf/logger.xml`.
    Although using any one of the filenames, such as `application-logger.xml` or `logger.xml`,
    works when both are present, the settings of `logger.xml` are not applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By specifying the file via a system property. This method has a higher precedence
    over the other option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`logger.resource`: This property sets a file within the class path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger.file`: This property sets a file through its absolute path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger.url`: This property sets a file using a URL in this way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another important aspect of configuring logging is by setting the desired log
    level. We will discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Log levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Log levels can be set in `conf/application.conf`. The default values are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set the log levels for the classes belonging to specific packages
    and third-party libraries in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported log levels in the decreasing order of severity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERROR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WARN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DEBUG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we wish to turn off logging for some classes or packages, we can set the
    log level as `OFF`. This will disable logging for a particular logger.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some libraries have transitive dependencies on logging libraries. It is best
    to exclude these logging packages when defining a dependency. It can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to configure the debugging of a Play application
    in the IDE. We also covered how to start a Play application in a Scala console.
    This chapter also covered the logging API provided by the Play Framework and customizing
    the log format.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of web applications make use of the third-party APIs either to avoid rewriting
    the existing code or to make it easy for users to adopt their applications. In
    the next chapter, we will be checking out how developers can use existing external
    APIs in a Play application.
  prefs: []
  type: TYPE_NORMAL
