<html><head></head><body>
<div id="_idContainer042">
<h1 class="chapter-number" id="_idParaDest-156"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-157"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.2.1">Static and Dynamic Analysis</span></h1>
<p><span class="koboSpan" id="kobo.3.1">On our way to clean, robust, and maintainable code, we’ll often need to “take a look” at how our software works and how it’s written. </span><span class="koboSpan" id="kobo.3.2">After identifying the code smells and doing some refactoring steps (in fact, we should never stop doing this!), it can be useful to scan our code for design flaws, security vulnerabilities, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This analysis can be carried out directly on the code – that is, static analysis – or on the running program – that is, (without involving too much imagination) </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">dynamic analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Static and dynamic analysis tools scrutinize code to identify issues and inefficiencies. </span><span class="koboSpan" id="kobo.7.2">Their insights provide the foundation for improvements, and this is where refactoring comes </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">into play.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to talk about the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">static analysis?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Why do we need </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">static analysis?</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Some static </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">analysis tools</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">dynamic analysis?</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Some dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">analysis techniques</span></span></li>
</ul>
<h1 id="_idParaDest-158"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.21.1">What is static analysis?</span></h1>
<p><span class="koboSpan" id="kobo.22.1">As the name may suggest, </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">static analysis</span></strong><span class="koboSpan" id="kobo.24.1"> in the context of Java (or any programming language, actually) refers to </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.25.1">the process of analyzing source code without running it. </span><span class="koboSpan" id="kobo.25.2">It is a technique that’s used to find issues, potential bugs, security vulnerabilities, and other issues in the code before it is run or compiled. </span><span class="koboSpan" id="kobo.25.3">Static analysis tools are used for this purpose (we’ll jump into </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">that shortly).</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">There are lots of reasons to perform static analysis; let’s see some </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">of them.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.29.1">Code errors or bad practices</span></h2>
<p><span class="koboSpan" id="kobo.30.1">The first one we will show you may seem trivial, but it is the main reason we scan our code in search of problems – that is, problems in the code! </span><span class="koboSpan" id="kobo.30.2">Which problems? </span><span class="koboSpan" id="kobo.30.3">We’ll put them under </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.31.1">the generic term of coding errors – that is, mistakes made by programmers when writing code (yes, it turns out that even programmers make mistakes – no matter how much experience they have, programmers still make mistakes. </span><span class="koboSpan" id="kobo.31.2">But, as they gain more experience, they’re more likely to own up to their errors!). </span><span class="koboSpan" id="kobo.31.3">These errors can lead to a variety of problems, including crashes, unexpected behavior, and </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">security vulnerabilities:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.33.1">You could have </span><strong class="bold"><span class="koboSpan" id="kobo.34.1">null pointer dereferences</span></strong><span class="koboSpan" id="kobo.35.1"> when a program tries to access a memory </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.36.1">location that has not been initialized, as shown here. </span><span class="koboSpan" id="kobo.36.2">This </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.37.1">can lead to crashes and other </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">unexpected behavior:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.39.1">
String text = null;
int length = text.length();</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.40.1">In this example, we have a null reference (</span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">text</span></strong><span class="koboSpan" id="kobo.42.1">) to a string, and attempting to access its </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">length()</span></strong><span class="koboSpan" id="kobo.44.1"> method leads to </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">NullPointerException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Unreachable code</span></strong><span class="koboSpan" id="kobo.49.1"> is code </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.50.1">that can never be executed. </span><span class="koboSpan" id="kobo.50.2">This can happen when there is a mistake in a conditional statement, such as </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.51.1">an infinite loop or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">if</span></strong><span class="koboSpan" id="kobo.53.1"> statement that is always false. </span><span class="koboSpan" id="kobo.53.2">Unreachable code is not harmful, but it can make code more difficult to read and maintain. </span><span class="koboSpan" id="kobo.53.3">In general, it is useless, and we do not like useless code (unless your pay increases with the number of code lines you write, but we don’t believe that’s the case). </span><span class="koboSpan" id="kobo.53.4">Here’s an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the same:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.55.1">
public void unreachableCodeExample() {
    boolean condition = someBooleanMethod();
    if (condition) {
        System.out.println("Condition is true.");
        return;
    }
    System.out.println("This line of code is unreachable.");
}
private static boolean someBooleanMethod() {
    return true;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.56.1">In this </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.57.1">example, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">someBooleanMethod</span></strong><span class="koboSpan" id="kobo.59.1">, which always returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">true</span></strong><span class="koboSpan" id="kobo.61.1"> (imagine some logic implemented by some unreadable code, not just this simple statement). </span><span class="koboSpan" id="kobo.61.2">This code </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.62.1">snippet will compile, but the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">System.out</span></strong><span class="koboSpan" id="kobo.64.1"> will never be executed. </span><span class="koboSpan" id="kobo.64.2">So, you have to refactor your code: you could fix the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">boolean</span></strong><span class="koboSpan" id="kobo.66.1"> method if that’s the case or just drop it and delete the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">if</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1"> condition.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Class cast exceptions</span></strong><span class="koboSpan" id="kobo.70.1">, on the other hand, are runtime exceptions in Java that occur </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.71.1">when you try to cast an object to </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.72.1">a type that is not compatible with the object’s actual type. </span><span class="koboSpan" id="kobo.72.2">In other words, you’re trying to convert an object into a type that it is not, resulting in </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">an exception:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.74.1">
public void classMismatchExample(){
    Object i = 6;
    String s = (String) i; //this will throw an exception
    System.out.println(s);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.75.1">This is a very simple problem that is usually detected by your IDE while you’re writing code, but still, that is an example of </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">static analysis.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.77.1">Some static analysis tools can also detect some bad practices; one of the most common is a class implementing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">compareTo</span></strong><span class="koboSpan" id="kobo.79.1"> method but then you’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">equals</span></strong><span class="koboSpan" id="kobo.81.1">. </span><span class="koboSpan" id="kobo.81.2">When you implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">compareTo()</span></strong><span class="koboSpan" id="kobo.83.1"> method, it’s important to ensure that </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.84.1">you also override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">equals()</span></strong><span class="koboSpan" id="kobo.86.1"> method. </span><span class="koboSpan" id="kobo.86.2">This </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.87.1">ensures consistency in how objects of the class are compared for ordering </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">and equality:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.89.1">Person person = new Person();
Person anotherPerson = new Person();
if(person.equals(anotherPerson)) {
    System.out.println("They're equal");
} else {
    System.out.println("They're not equal");
}
if(person.compareTo(anotherPerson) == 0) {
    System.out.println("They're equal");
} else {
    System.out.println("They're not equal");
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.90.1">The result of this method is probably not what </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">we wanted:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.92.1">They're not equal</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.93.1">They're equal</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.94.1">That’s because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">equals</span></strong><span class="koboSpan" id="kobo.96.1"> method is not correctly implemented in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Person</span></strong><span class="koboSpan" id="kobo.98.1"> class, and we’re using the one coming from </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Object</span></strong><span class="koboSpan" id="kobo.100.1">. </span><span class="koboSpan" id="kobo.100.2">If our class implements </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Comparable</span></strong><span class="koboSpan" id="kobo.102.1">, then it’s not a good thing to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">equals</span></strong><span class="koboSpan" id="kobo.104.1"> on it. </span><span class="koboSpan" id="kobo.104.2">To avoid any misbehavior, you could just override </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">equals</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.106.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">compareTo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.109.1">@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    return this.compareTo(o) == 0;
}</span></pre></li> <li><span class="koboSpan" id="kobo.110.1">Finally, a good </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.111.1">static analysis of your code can detect </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">duplicated code</span></strong><span class="koboSpan" id="kobo.113.1">, which </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.114.1">in my opinion is the most common smell I’ve come across; static analysis tools can recognize code fragments that are repeated and flag them for developers’ attention (often, this step can be done directly by your </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">favorite IDE).</span></span></li>
</ul>
<h2 id="_idParaDest-160"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.116.1">Security</span></h2>
<p><span class="koboSpan" id="kobo.117.1">Static analysis </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.118.1">of code is essential for security as it plays a pivotal role in identifying and mitigating security vulnerabilities. </span><span class="koboSpan" id="kobo.118.2">By thoroughly examining the source code of an application or system before it is executed, static analysis helps to enhance the overall security posture of software. </span><span class="koboSpan" id="kobo.118.3">One of the significant benefits of </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.119.1">static code analysis is its ability to reduce security vulnerabilities, such as </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">cross-site scripting</span></strong><span class="koboSpan" id="kobo.121.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.122.1">XSS</span></strong><span class="koboSpan" id="kobo.123.1">) and injection attacks, which are common and potentially devastating threats to the integrity and confidentiality of data and the smooth operation of applications. </span><span class="koboSpan" id="kobo.123.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">more benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.125.1">Detection of XSS vulnerabilities</span></strong><span class="koboSpan" id="kobo.126.1">: Static code analysis scans the source code for </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.127.1">any instances where user inputs, such as form fields or URL parameters, are not properly validated or sanitized. </span><span class="koboSpan" id="kobo.127.2">This meticulous examination helps identify potential entry points for malicious code injection. </span><span class="koboSpan" id="kobo.127.3">For example, in the context of a web application, static analysis can pinpoint locations where user-supplied data might be directly included in HTML or JavaScript code. </span><span class="koboSpan" id="kobo.127.4">This information is invaluable in fixing these issues </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.128.1">as it adds proper input validation and output encoding, thereby thwarting </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">XSS attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.130.1">Mitigation of injection attacks</span></strong><span class="koboSpan" id="kobo.131.1">: Static analysis is highly effective in detecting vulnerabilities that can lead to injection attacks, including SQL injection, which can </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.132.1">compromise the database and sensitive data. </span><span class="koboSpan" id="kobo.132.2">By analyzing the code, it can flag any instances where user inputs are used directly in SQL queries, without proper parameterization or escaping. </span><span class="koboSpan" id="kobo.132.3">Developers can then modify the code so that it uses prepared statements or stored procedures, effectively preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">injection attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.134.1">Library and component vulnerability scanning</span></strong><span class="koboSpan" id="kobo.135.1">: We can extend the analysis </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.136.1">to dynamically linked libraries and third-party components. </span><span class="koboSpan" id="kobo.136.2">We should regularly scan for known vulnerabilities in libraries and dependencies used by the application. </span><span class="koboSpan" id="kobo.136.3">Automated tools can help identify outdated or susceptible components, ensuring that the software relies on secure and </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">up-to-date code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.138.1">Early detection and prevention</span></strong><span class="koboSpan" id="kobo.139.1">: One of the key advantages of static code analysis </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.140.1">is its ability to detect vulnerabilities at an early stage of the development process. </span><span class="koboSpan" id="kobo.140.2">This early detection is crucial because addressing security issues at later stages, such as during testing or in production, can be considerably more expensive and disruptive. </span><span class="koboSpan" id="kobo.140.3">Static analysis empowers development teams to address vulnerabilities as they write the code, reducing the likelihood of security issues making their way into the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">final product.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.142.1">By addressing these vulnerabilities at their root, organizations can minimize the potential for security breaches and the associated risks </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">and costs.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.144.1">Cyclomatic complexity</span></h2>
<p><span class="koboSpan" id="kobo.145.1">Static analysis of code can also be used to calculate and keep the cyclomatic complexity of the </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.146.1">code itself under control. </span><span class="koboSpan" id="kobo.146.2">Let’s try to understand what it is. </span><span class="koboSpan" id="kobo.146.3">Simply put, </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">cyclomatic complexity</span></strong><span class="koboSpan" id="kobo.148.1"> is like counting the different ways you can walk through a piece of code. </span><span class="koboSpan" id="kobo.148.2">If there are fewer routes and they’re not too complicated, the cyclomatic complexity is lower, and the code becomes easier to read </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">and get.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">To reduce </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.151.1">cyclomatic complexity, you “just” have to write clean code, but apply all the advice we gave in the previous chapters and remove all the code smells that you get. </span><span class="koboSpan" id="kobo.151.2">Static analysis can help you, for example, in detecting methods or functions that are too long, duplicated code, or dead code (that is, code that is never used at runtime); it can also help you reduce the number of decision structures (that’s a big deal: try to avoid as many </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">if</span></strong><span class="koboSpan" id="kobo.153.1"> statements as possible in your code to reduce the complexity) and help you avoid flag arguments </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">in methods.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">We’re not going to look at this in too much detail here, but we think it’s generally interesting to understand how to calculate cyclomatic complexity for a simple method. </span><span class="koboSpan" id="kobo.155.2">Let’s suppose you have the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
public int calculateSum(int a, int b) {
    if (a &gt; 0) {
        return a + b;
    } else {
        return a - b;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.158.1">You can calculate cyclomatic complexity for functions, modules, methods, or classes in a software program using control flow graphs. </span><span class="koboSpan" id="kobo.158.2">It should be easier to draw the control flow graph for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">calculateSum</span></strong><span class="koboSpan" id="kobo.160.1"> method than to explain what a control flow graph is. </span><span class="koboSpan" id="kobo.160.2">It represents all the possible paths of execution of your program and it looks something </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.162.1"><img alt="Figure 7.1 – The control flow graph for the calculateSum method" src="image/B20912_07_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.163.1">Figure 7.1 – The control flow graph for the calculateSum method</span></p>
<p><span class="koboSpan" id="kobo.164.1">The previous </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.165.1">diagram represents the control flow graph for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">calculateSum</span></strong><span class="koboSpan" id="kobo.167.1"> method. </span><span class="koboSpan" id="kobo.167.2">We can see a </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">START</span></strong><span class="koboSpan" id="kobo.169.1"> node, from which starts an edge that goes into a conditional node; depending on the condition (</span><strong class="bold"><span class="koboSpan" id="kobo.170.1">TRUE</span></strong><span class="koboSpan" id="kobo.171.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">FALSE</span></strong><span class="koboSpan" id="kobo.173.1">), the flow </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.174.1">goes through one edge or another (</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">a+b</span></strong><span class="koboSpan" id="kobo.176.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">a-b</span></strong><span class="koboSpan" id="kobo.178.1">). </span><span class="koboSpan" id="kobo.178.2">They both end at the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.179.1">END</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.180.1"> node.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">To calculate the cyclomatic complexity, there’s a simple formula: </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">M = E – N + 2</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">Here, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.185.1">M</span></strong><span class="koboSpan" id="kobo.186.1"> represents the </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">cyclomatic complexity</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.188.1">E</span></strong><span class="koboSpan" id="kobo.189.1"> is the number of edges in the control </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">flow graph</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">N</span></strong><span class="koboSpan" id="kobo.192.1"> is the number of nodes in the control </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">flow graph</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.194.1">In our case, it would be </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">M = 5 – 5 + 2 = </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.196.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">In general, a piece of code with a cyclomatic complexity value exceeding 11 is considered overly complex and brings challenges for testing </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">and maintenance.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">The following are some common cyclomatic complexity values that are used by static </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">analysis tools</span><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.202.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.203.1">1-4</span></strong><span class="koboSpan" id="kobo.204.1">: Low complexity – relatively easy </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">to test</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.206.1">5-7</span></strong><span class="koboSpan" id="kobo.207.1">: Moderate complexity – </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">manageable</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.209.1">8-10</span></strong><span class="koboSpan" id="kobo.210.1">: High complexity – suggests the need for refactoring to </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">improve te</span><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.212.1">stability</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.213.1">11 and above</span></strong><span class="koboSpan" id="kobo.214.1">: Very high complexity – extremely challenging </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">to test</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.216.1">The code’s </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.217.1">complexity level also impacts its testability. </span><span class="koboSpan" id="kobo.217.2">The higher </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.218.1">the cyclomatic complexity, the more difficult it is to create comprehensive tests. </span><span class="koboSpan" id="kobo.218.2">The cyclomatic complexity value indicates the number of test cases required to achieve 100% </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">branch coverage.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor169"/><span class="koboSpan" id="kobo.220.1">Exception (mis)handling</span></h2>
<p><span class="koboSpan" id="kobo.221.1">Exceptions in Java programs are not always treated as they deserve; defects coming from their </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.222.1">mishandling are common and often underestimated. </span><span class="koboSpan" id="kobo.222.2">Handling exceptions correctly in Java is vital to preventing program crashes, maintaining </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.223.1">data integrity, providing a better user experience, enhancing debugging, improving security, and maintaining code quality. </span><span class="koboSpan" id="kobo.223.2">Properly handled exceptions help your software recover gracefully from errors and meet regulatory requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">when necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Static analysis tools can help us detect some common exception mishandling; we’re going to see some of </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">them here.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
Person person = null;
try {
    String name = person.getName(); //throws NPE
} finally {
    throw new IOException();
}</span></pre> <p><span class="koboSpan" id="kobo.230.1">As you can see, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">IOException</span></strong><span class="koboSpan" id="kobo.232.1"> is thrown in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">finally</span></strong><span class="koboSpan" id="kobo.234.1"> block; in general, throwing exceptions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">finally</span></strong><span class="koboSpan" id="kobo.236.1"> block is considered a smell since it could hide some other exception being thrown in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">try</span></strong><span class="koboSpan" id="kobo.238.1"> block. </span><span class="koboSpan" id="kobo.238.2">In this case, the expected output would be </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">NullPointerException</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Also, employing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">return</span></strong><span class="koboSpan" id="kobo.244.1"> statement within a </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">finally</span></strong><span class="koboSpan" id="kobo.246.1"> block can introduce confusion. </span><span class="koboSpan" id="kobo.246.2">This rule’s </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.247.1">significance lies in the fact that when the code </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.248.1">throws an exception, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">return</span></strong><span class="koboSpan" id="kobo.250.1"> statement can discard it. </span><span class="koboSpan" id="kobo.250.2">Let’s see how by changing a bit of the previous </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
Person person = null;
try {
    String name = person.getName(); //throws NPE
} finally {
    return;
}</span></pre> <p><span class="koboSpan" id="kobo.253.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">NullPointerException</span></strong><span class="koboSpan" id="kobo.255.1"> is thrown, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">finally</span></strong><span class="koboSpan" id="kobo.257.1"> block containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">return</span></strong><span class="koboSpan" id="kobo.259.1"> statement is just swept under the carpet. </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Nothing happens.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">The last smell in exception handling we’re going to see is when we close a stream into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">finally</span></strong><span class="koboSpan" id="kobo.263.1"> block and something fails. </span><span class="koboSpan" id="kobo.263.2">What happens if </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">close()</span></strong><span class="koboSpan" id="kobo.265.1">, when invoked on a stream, fails and there are other instructions to be executed after it? </span><span class="koboSpan" id="kobo.265.2">Those instructions are simply </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">not executed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
public static void copyFiles(String sourceFileName, String destFileName) {
    InputStream inputStream = null;
    OutputStream outputStream = null;
    try {
        inputStream = Files.newInputStream(Paths.get(sourceFileName));
        outputStream = Files.newOutputStream(Paths.get(destFileName));
        copy(inputStream, outputStream);
    } catch (IOException e) {
        // handling exception
    } finally {
        try {
            inputStream.close();
            outputStream.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.268.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">copyFiles</span></strong><span class="koboSpan" id="kobo.270.1"> method copies one file to another (we’re omitting the internal copy method for conciseness), opening two streams (</span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">inputStream</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">outputStream</span></strong><span class="koboSpan" id="kobo.274.1">). </span><span class="koboSpan" id="kobo.274.2">As you can see, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">finally</span></strong><span class="koboSpan" id="kobo.276.1"> block, the two streams are closed in the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">try</span></strong><span class="koboSpan" id="kobo.278.1"> block: if the first one fails, the other one will </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">stay open.</span></span></p>
<p><span class="koboSpan" id="kobo.280.1">Now that </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.281.1">we’ve seen what we’re looking for when we perform </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.282.1">static code analysis, let’s get to know some tools that can help us. </span><span class="koboSpan" id="kobo.282.2">As usual, consider the next few sections as suggestions to deepen your knowledge so that you can improve the quality of your code day </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">by day.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor170"/><span class="koboSpan" id="kobo.284.1">Automated static analysis tools</span></h2>
<p><span class="koboSpan" id="kobo.285.1">Automated static analysis tools, such as SonarQube, Checkstyle, FindBugs, and PMD, play a crucial </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.286.1">role in the software development process </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.287.1">by helping developers maintain code quality, identify potential issues, and adhere to coding standards. </span><span class="koboSpan" id="kobo.287.2">These tools are instrumental in ensuring that software projects are not only functionally correct but also maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">and robust.</span></span></p>
<h3><span class="koboSpan" id="kobo.289.1">SonarQube and SonarLint</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.290.1">SonarQube</span></strong><span class="koboSpan" id="kobo.291.1"> is a </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.292.1">comprehensive tool that’s designed for continuous code inspection. </span><span class="koboSpan" id="kobo.292.2">Its primary function is to analyze code bases automatically, pinpointing potential </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.293.1">issues such as bugs, security vulnerabilities, and code smells. </span><span class="koboSpan" id="kobo.293.2">By integrating seamlessly into the </span><strong class="bold"><span class="koboSpan" id="kobo.294.1">continuous integration and continuous deployment</span></strong><span class="koboSpan" id="kobo.295.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.296.1">CI/CD</span></strong><span class="koboSpan" id="kobo.297.1">) pipelines, SonarQube ensures that </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.298.1">each build undergoes a deep examination for code quality. </span><span class="koboSpan" id="kobo.298.2">This process includes identifying and reporting on areas that may require improvement </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">or attention.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">One of the notable features of SonarQube is its ability to perform security vulnerability detection, which is crucial in today’s software development landscape where security is a top priority. </span><span class="koboSpan" id="kobo.300.2">This tool offers a holistic view of the code base, helping development teams maintain a high standard of code quality throughout the entire development life cycle. </span><span class="koboSpan" id="kobo.300.3">Additionally, SonarQube provides historical analysis, allowing developers to track changes in code quality over time. </span><span class="koboSpan" id="kobo.300.4">This historical perspective proves invaluable in assessing the effectiveness of code improvements or identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">potential regressions.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">SonarQube and </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">SonarLint</span></strong><span class="koboSpan" id="kobo.304.1"> often go </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.305.1">together, like </span><em class="italic"><span class="koboSpan" id="kobo.306.1">Batman</span></em><span class="koboSpan" id="kobo.307.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.308.1">Robin</span></em><span class="koboSpan" id="kobo.309.1">. </span><span class="koboSpan" id="kobo.309.2">SonarLint is a lightweight IDE extension and serves as a valuable companion to SonarQube, offering developers a means to address code quality issues directly within their IDEs. </span><span class="koboSpan" id="kobo.309.3">SonarLint operates in real-time, providing instant feedback as developers write code. </span><span class="koboSpan" id="kobo.309.4">By integrating with popular IDEs such as Eclipse, IntelliJ IDEA, and Visual Studio, SonarLint seamlessly becomes a part of the local </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">development environment.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">One of SonarLint’s strengths lies in its language support, which covers a variety of programming languages. </span><span class="koboSpan" id="kobo.311.2">This versatility allows developers to apply consistent code quality </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.312.1">standards across different projects and code bases. </span><span class="koboSpan" id="kobo.312.2">Importantly, SonarLint can be configured to synchronize with SonarQube, ensuring that developers adhere to the same rule sets locally as those enforced by the centralized analysis performed </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">by SonarQube.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">In essence, SonarQube and SonarLint work hand-in-hand to create a robust system for maintaining and enhancing code quality. </span><span class="koboSpan" id="kobo.314.2">SonarQube provides centralized, comprehensive analysis, while SonarLint brings that analysis directly into the developers’ local environments, enabling them to proactively address issues during the coding process. </span><span class="koboSpan" id="kobo.314.3">Together, these tools contribute significantly to the overall goal of producing high-quality, secure, and </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">maintainable code.</span></span></p>
<h3><span class="koboSpan" id="kobo.316.1">Checkstyle</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.317.1">Checkstyle</span></strong><span class="koboSpan" id="kobo.318.1"> is an open source tool that enforces coding standards and conventions for Java code. </span><span class="koboSpan" id="kobo.318.2">It checks </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.319.1">the source code against a set </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.320.1">of predefined rules and reports violations. </span><span class="koboSpan" id="kobo.320.2">Checkstyle is highly configurable, allowing development teams to customize and enforce their own coding standards. </span><span class="koboSpan" id="kobo.320.3">Some of the key features of Checkstyle are </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.322.1">Customizable rules</span></strong><span class="koboSpan" id="kobo.323.1">: Checkstyle allows you to define your own coding rules or use </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.324.1">predefined rule sets based on established coding standards such as Sun Code Conventions, Google Java Style, and more. </span><span class="koboSpan" id="kobo.324.2">You can define rules about indentation, line length, variable naming, import order, and </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.326.1">Integration</span></strong><span class="koboSpan" id="kobo.327.1">: Checkstyle can be integrated into popular IDEs and build systems, making </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.328.1">it seamless for developers to incorporate code checks into their </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">development workflows</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.330.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.331.1">: It is </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.332.1">often integrated into </span><strong class="bold"><span class="koboSpan" id="kobo.333.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.334.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.335.1">CI</span></strong><span class="koboSpan" id="kobo.336.1">) pipelines, ensuring that code quality checks are performed automatically whenever code changes </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">are committed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Report generation</span></strong><span class="koboSpan" id="kobo.339.1">: Checkstyle </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.340.1">generates detailed reports, making it easy for developers to identify and fix </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">code violations</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.342.1">FindBugs</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.343.1">FindBugs</span></strong><span class="koboSpan" id="kobo.344.1"> is a static </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.345.1">analysis tool for identifying </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.346.1">bugs and potential security vulnerabilities in Java code. </span><span class="koboSpan" id="kobo.346.2">It uses static analysis to detect issues in bytecode, making it particularly valuable for finding problems that might not be apparent from the source code alone. </span><span class="koboSpan" id="kobo.346.3">Here are some of the key features </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">of FindBugs:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.348.1">Bug detection</span></strong><span class="koboSpan" id="kobo.349.1">: It is </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.350.1">designed to find a wide range of bugs, including null pointer dereferences, thread synchronization problems, and </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">performance bottlenecks</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.352.1">Integration</span></strong><span class="koboSpan" id="kobo.353.1">: Like Checkstyle, FindBugs </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.354.1">can be integrated into various development environments and </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">CI/CD pipelines</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.356.1">User-defined checks</span></strong><span class="koboSpan" id="kobo.357.1">: Developers </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.358.1">can create custom bug detectors for </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">project-specific issues</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.360.1">Community support</span></strong><span class="koboSpan" id="kobo.361.1">: FindBugs has </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.362.1">an active community that maintains and updates the tool, ensuring it remains relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">and effective</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.364.1">FindBugs reviews </span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.365.1">your code by looking at its bytecode – that is, without needing to </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.366.1">access the original source code. </span><span class="koboSpan" id="kobo.366.2">But because its analysis isn’t always perfect, FindBugs can sometimes raise warnings that aren’t real issues. </span><span class="koboSpan" id="kobo.366.3">The rate of these false warnings reported by FindBugs is less </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">than 50%.</span></span></p>
<h3><span class="koboSpan" id="kobo.368.1">PMD</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.369.1">PMD</span></strong><span class="koboSpan" id="kobo.370.1"> is a </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.371.1">static source code analyzer for various </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.372.1">programming languages, including Java. </span><span class="koboSpan" id="kobo.372.2">It focuses on code quality and identifies potential issues, redundancies, and complex code patterns. </span><span class="koboSpan" id="kobo.372.3">PMD offers the following </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">key features:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.374.1">Multiple languages</span></strong><span class="koboSpan" id="kobo.375.1">: It </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.376.1">supports multiple languages, not just Java, making it versatile for projects with diverse </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">code bases</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.378.1">Rule-based analysis</span></strong><span class="koboSpan" id="kobo.379.1">: It </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.380.1">analyzes source code against a set of predefined rules that can be customized based on </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">project requirements</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.382.1">Code duplication detection</span></strong><span class="koboSpan" id="kobo.383.1">: PMD </span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.384.1">can detect duplicate code fragments, helping developers maintain cleaner and more </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">maintainable code</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.386.1">Integration</span></strong><span class="koboSpan" id="kobo.387.1">: PMD can </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.388.1">be integrated into different IDEs and build systems (PMD offers an extension for Visual Studio Code, making it convenient for developers working in this </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">popular IDE)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">Using tools that check code for mistakes is important in both the place where we write code (IDEs) and in the system that keeps an eye on our code as we work (CI pipelines). </span><span class="koboSpan" id="kobo.390.2">These tools help us find mistakes early, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">very helpful.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">In our code writing environment (IDE), these tools help us spot problems as we write the code, making it less likely for errors to show </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">up later.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">In our code monitoring system (CI pipeline), these tools make sure the code we write follows the rules and standards we set. </span><span class="koboSpan" id="kobo.394.2">This keeps the quality of our code high and makes sure we don’t accidentally break things that used </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">One of the </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.397.1">great things about these tools is that they </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.398.1">make sure everyone on the team follows the same rules. </span><span class="koboSpan" id="kobo.398.2">This helps our code be more organized, easier to understand, and generally better. </span><span class="koboSpan" id="kobo.398.3">These tools also save us time and money. </span><span class="koboSpan" id="kobo.398.4">They help us find and fix problems early, which is cheaper and faster than waiting until later when problems can be much harder </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">At the end of the day, using these tools makes our code better, helps us work together more easily, and keeps our code secure and safe </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">from mistakes.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">With that, we’ve taken a quick look at static analysis, focusing on what to look for and how to look for it. </span><span class="koboSpan" id="kobo.402.2">Unfortunately, static analysis alone is not enough. </span><span class="koboSpan" id="kobo.402.3">Clean code is one thing – efficient code is another. </span><span class="koboSpan" id="kobo.402.4">It is strictly necessary to analyze the code while it </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">is running.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor171"/><span class="koboSpan" id="kobo.404.1">What is dynamic analysis?</span></h1>
<p><span class="koboSpan" id="kobo.405.1">While static analysis is done on the code, its complementary version, </span><strong class="bold"><span class="koboSpan" id="kobo.406.1">dynamic analysis</span></strong><span class="koboSpan" id="kobo.407.1">, is done on </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.408.1">the program while it is running. </span><span class="koboSpan" id="kobo.408.2">This approach involves analyzing the code during execution, rather than just inspecting the source code, or performing static analysis, which examines code without executing it. </span><span class="koboSpan" id="kobo.408.3">Dynamic analysis provides insights into how a program behaves in real-world scenarios and helps identify issues that might not be apparent through static </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">analysis alone.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">If you have ever done some unit testing or some debugging, well, you did some kind of dynamic analysis. </span><span class="koboSpan" id="kobo.410.2">But there is much more to this. </span><span class="koboSpan" id="kobo.410.3">Dynamic program analysis involves collecting diverse insights about a program’s behavior, which includes understanding variables’ value assignments, the sequence and timing of function calls, data structure manipulations and modifications, memory allocation and usage, utilization of system resources, and the detection of encountered errors. </span><span class="koboSpan" id="kobo.410.4">This information is essential for purposes such as bug and security vulnerability identification, program performance enhancement, verification of program adherence to its requirements, and gaining a deeper understanding of the program’s </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">operational principles.</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">There are many examples of dynamic program analysis; let the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">journey begin.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.414.1">Debugging</span></h2>
<p><span class="koboSpan" id="kobo.415.1">As trivial </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.416.1">as it may seem, </span><strong class="bold"><span class="koboSpan" id="kobo.417.1">debugging</span></strong><span class="koboSpan" id="kobo.418.1"> is the most widely used </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.419.1">technique for dynamic program analysis; maybe it’s the single activity we do the most in our industry – yes, certainly much more than writing the code or designing the architectures. </span><span class="koboSpan" id="kobo.419.2">And yes, we know that by implementing some good habits </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.420.1">in respect of testing (such as </span><strong class="bold"><span class="koboSpan" id="kobo.421.1">test-driven development</span></strong><span class="koboSpan" id="kobo.422.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.423.1">TDD</span></strong><span class="koboSpan" id="kobo.424.1">)) the need for debugging should be minimal, ideally zero, but in the real world, it isn’t always possible to </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">Since it’s such a popular activity, we won’t dwell too much on debugging. </span><span class="koboSpan" id="kobo.426.2">However, I would like to draw attention to some aspects that some people might underestimate, especially at the beginning of their </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">professional careers.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">For effective debugging, try to reproduce the bug first; from experience, this can be a difficult phase, sometimes much more difficult than the resolution itself. </span><span class="koboSpan" id="kobo.428.2">It involves having it</span><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.429.1"> explained to you what was done to produce that bug (in case you haven’t noticed it yourself) and reproducing the same input that generated the problem or at least an input of the same type. </span><span class="koboSpan" id="kobo.429.2">It is not even gr</span><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.430.1">anted that you can use a debugger, actually: for example, if you can’t reproduce the problem in an environmen</span><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.431.1">t where you can use the debugger (for example, your local host), you’ll need to use some other technique, such as logging. </span><span class="koboSpan" id="kobo.431.2">By logging the program’s state at key points, you can track down the source of the error more easily. </span><span class="koboSpan" id="kobo.431.3">As we already know – and it’s the key target of this whole book – refactoring can help you debug. </span><span class="koboSpan" id="kobo.431.4">Sometimes, it could just look like a game, but refactoring your code and making it cleaner will likely help you understand </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">what’s happening.</span></span></p>
<p><span class="koboSpan" id="kobo.433.1">Although it is widely used as a technique, I must point out that crying and banging your head on the keyboard does not work to fix bugs; on the other hand, do not hesitate to ask for help. </span><span class="koboSpan" id="kobo.433.2">This can also be an exceedingly </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">difficult thing.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.435.1">Profiling</span></h2>
<p><span class="koboSpan" id="kobo.436.1">Even the </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.437.1">most skilled development teams may find that a few lines </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.438.1">of code don’t achieve peak performance right from the start. </span><span class="koboSpan" id="kobo.438.2">To uncover the most efficient methods for improving code speed, it must undergo evaluation, debugging, </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">and review.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Software engineers (and quality assurance professionals) must take some steps to guarantee that their code is as swift, smooth, and flawless </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">as possible.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.442.1">Profiling</span></strong><span class="koboSpan" id="kobo.443.1"> is the process </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.444.1">of measuring and analyzing the runtime behavior and performance characteristics of a program. </span><span class="koboSpan" id="kobo.444.2">The primary goal of profiling is to identify bottlenecks, performance issues, and areas for optimization in the code. </span><span class="koboSpan" id="kobo.444.3">This is crucial for </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.445.1">improving the efficiency and speed of a program. </span><span class="koboSpan" id="kobo.445.2">Profiling can be applied to various types of software, including desktop applications, web applications, and </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">server-side software.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">There are many different profiling tools available, and they can be used to collect several </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.448.1">types of data, as </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">shown here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.450.1">CPU usage</span></strong><span class="koboSpan" id="kobo.451.1">: This data shows how much CPU time the program </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">is using</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.453.1">Memory usage</span></strong><span class="koboSpan" id="kobo.454.1">: This data shows how much memory the program </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">is using</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.456.1">Function call frequency</span></strong><span class="koboSpan" id="kobo.457.1">: This data shows how often each function in the program is </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">being called</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.459.1">Function execution time</span></strong><span class="koboSpan" id="kobo.460.1">: This data shows how long each function in the program is taking </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">to execute</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Resource usage</span></strong><span class="koboSpan" id="kobo.463.1">: This data shows how many various system resources, such as disk I/O and network bandwidth, the program </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">is using</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.465.1">Once the profiling data has been collected, it can be analyzed to identify bottlenecks. </span><span class="koboSpan" id="kobo.465.2">A bottleneck is a part of the program that is slowing it down. </span><span class="koboSpan" id="kobo.465.3">For example, a function that is called very often and takes a long time to execute may be a bottleneck. </span><span class="koboSpan" id="kobo.465.4">Once the bottlenecks have been identified, they can be fixed by optimizing the code. </span><span class="koboSpan" id="kobo.465.5">For example, the bottleneck function may be rewritten to make it more efficient. </span><span class="koboSpan" id="kobo.465.6">Profiling is a valuable tool for improving the performance of software. </span><span class="koboSpan" id="kobo.465.7">It can be used to identify and fix bottlenecks, and to make sure that the program is using system </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">resources efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Profiling has practical applications in various fields. </span><span class="koboSpan" id="kobo.467.2">For instance, web application developers can employ profilers to identify performance bottlenecks in their applications, allowing them to optimize the code for quicker loading. </span><span class="koboSpan" id="kobo.467.3">Similarly, game developers use profilers to improve frame rates by identifying and optimizing problematic sections of their games. </span><span class="koboSpan" id="kobo.467.4">Server administrators also make use of profilers to pinpoint resource-intensive processes, enabling them to reduce the server’s </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">resource burden.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Lots of tools are used to profile running Java applications. </span><span class="koboSpan" id="kobo.469.2">Sometimes, they are included in your IDEs in their plugin/extensions, such as NetBeans or Eclipse. </span><span class="koboSpan" id="kobo.469.3">One of the most used and common </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.470.1">tools is VisualVM, a visual tool integrated into the </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Java Development Kit</span></strong><span class="koboSpan" id="kobo.472.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">JDK</span></strong><span class="koboSpan" id="kobo.474.1">) that provides a wide range of profiling, monitoring, and diagnostic </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.475.1">capabilities, including CPU profiling, memory profiling, and </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">thread analysis.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.477.1">VisualVM</span></strong><span class="koboSpan" id="kobo.478.1"> provides a </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.479.1">user-friendly graphical interface for monitoring and analyzing Java applications. </span><span class="koboSpan" id="kobo.479.2">It offers a wealth of visual data and performance metrics, making it easier to identify and address performance issues. </span><span class="koboSpan" id="kobo.479.3">One of VisualVM’s key features is its Java profiling capabilities. </span><span class="koboSpan" id="kobo.479.4">It allows developers to profile their applications to identify bottlenecks, memory leaks, and other performance-related problems. </span><span class="koboSpan" id="kobo.479.5">You can perform CPU profiling, thread analysis, and memory profiling, which are essential for improving the efficiency and reliability of </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">Java applications.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">When your </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.482.1">application starts freaking out and you don’t know exactly what is happening (for example, everything starts slowing down), one of the </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.483.1">best chances (and one of the most desperate, at the same time) is to make a so-called “heap dump” or “memory dump.” </span><span class="koboSpan" id="kobo.483.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">memory dump</span></strong><span class="koboSpan" id="kobo.485.1"> is essentially a snapshot of the contents </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.486.1">of a computer’s memory (RAM) or a specific process’s memory at a given point in time. </span><span class="koboSpan" id="kobo.486.2">This snapshot captures the state of the system or application at the moment it was created. </span><span class="koboSpan" id="kobo.486.3">Memory dumps serve various important purposes, including debugging software errors and crashes, analyzing security incidents and malware infections, investigating system crashes, and optimizing memory usage in applications. </span><span class="koboSpan" id="kobo.486.4">They come in different types, such as complete memory dumps (for hardware-related issues), kernel memory dumps (for operating system issues), process memory dumps (for application-specific debugging), and mini dumps (for smaller and more manageable data). </span><span class="koboSpan" id="kobo.486.5">Memory dump analysis is crucial for gaining insights into system and software behavior and is an essential tool in resolving a wide range of </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">computing issues.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">VisualVM (like other profiling tools) allows you to capture heap dumps and thread dumps, which are essential for diagnosing memory-related issues and analyzing thread behavior in your </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">Java application.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.490.1">Fuzzing</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.491.1">Fuzzing</span></strong><span class="koboSpan" id="kobo.492.1">, also </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.493.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.494.1">fuzz testing</span></strong><span class="koboSpan" id="kobo.495.1">, is </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.496.1">an automated software testing approach </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.497.1">where unconventional, often random, and invalid data is provided as input to a computer program. </span><span class="koboSpan" id="kobo.497.2">The program’s responses are closely monitored for anomalies such as crashes, violations of built-in code rules, or potential memory issues. </span><span class="koboSpan" id="kobo.497.3">Fuzzers are typically employed to assess software programs that rely on structured inputs, such as file formats or protocols that distinguish between valid and </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">invalid data.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">A good fuzzer generates partially valid inputs that are “valid enough” to avoid immediate rejection </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.500.1">by the input parser but are “invalid enough” to uncover </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.501.1">unanticipated program behaviors, especially in corner cases that may not have been </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">adequately addressed.</span></span></p>
<p><span class="koboSpan" id="kobo.503.1">In a security context, the most valuable input to fuzz is often data that traverses a trust boundary. </span><span class="koboSpan" id="kobo.503.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">trust boundary</span></strong><span class="koboSpan" id="kobo.505.1"> is a point </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.506.1">where data or program execution transitions between different trust levels or where data and commands are exchanged between entities with varying privileges. </span><span class="koboSpan" id="kobo.506.2">Trust boundaries can be found at distinct locations in a system where all subsystems and their data have equal trust. </span><span class="koboSpan" id="kobo.506.3">For instance, an execution trust boundary occurs when an application gains elevated privileges, such as root access. </span><span class="koboSpan" id="kobo.506.4">A data trust boundary occurs when data originates from an untrusted source, such as user input or a network socket. </span><span class="koboSpan" id="kobo.506.5">For instance, it’s more critical to fuzz code that’s responsible for handling file uploads from any user, as it crosses a trust boundary, than code dealing with a configuration file accessible only to </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">privileged users.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Every fuzzer can be put into one of </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">two categories:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.510.1">Mutation-based fuzzers</span></strong><span class="koboSpan" id="kobo.511.1">: These fuzzers start with existing data samples and make changes </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.512.1">to them to create new test cases. </span><span class="koboSpan" id="kobo.512.2">They </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.513.1">take an original input or test case and then modify it in various ways, such as changing random bits or values, to see if these modifications trigger unexpected behavior or vulnerabilities in the software being tested. </span><span class="koboSpan" id="kobo.513.2">Mutation-based fuzzers are good at finding certain types of bugs or vulnerabilities, especially when you have an initial set of valid inputs to </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">work with.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.515.1">Generation-based fuzzers</span></strong><span class="koboSpan" id="kobo.516.1">: These fuzzers build test cases by understanding the structure </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.517.1">and rules of the target protocol </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.518.1">or file format. </span><span class="koboSpan" id="kobo.518.2">Instead of modifying existing data samples, they generate new data that follows the specific format and logic required for testing. </span><span class="koboSpan" id="kobo.518.3">These fuzzers are good at exploring different aspects of a program or system because they can create a wide range of test cases based on their knowledge of the protocol or </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">file format.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.520.1">Now, we’ll delve into subcategories within these two groups. </span><span class="koboSpan" id="kobo.520.2">There’s no universally agreed-upon list of fuzzing categories, but I liked the approaches described in the book </span><em class="italic"><span class="koboSpan" id="kobo.521.1">Fuzzing: Brute Force Vulnerability Discovery</span></em><span class="koboSpan" id="kobo.522.1"> (see </span><em class="italic"><span class="koboSpan" id="kobo.523.1">Further reading</span></em><span class="koboSpan" id="kobo.524.1">), so I’ll try to </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">resume them.</span></span></p>
<h3><span class="koboSpan" id="kobo.526.1">Pre-generated test cases</span></h3>
<p><span class="koboSpan" id="kobo.527.1">As mentioned </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.528.1">earlier, the </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">pre-generated test cases</span></strong><span class="koboSpan" id="kobo.530.1"> method, exemplified by the PROTOS framework, starts by studying a specific specification. </span><span class="koboSpan" id="kobo.530.2">It involves </span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.531.1">understanding supported data structures and acceptable value ranges. </span><span class="koboSpan" id="kobo.531.2">Test cases are then crafted as hard-coded packets or files, designed to test boundary conditions or challenge the specification itself. </span><span class="koboSpan" id="kobo.531.3">These test cases prove valuable for assessing how accurately the specification has been implemented on various systems. </span><span class="koboSpan" id="kobo.531.4">While this method requires substantial upfront effort in test case creation, its advantage lies in its reusability across multiple implementations of the same protocol or file format. </span><span class="koboSpan" id="kobo.531.5">A limitation, however, is that fuzz testing is finite as there’s no random element; once the list of test cases is exhausted, </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">fuzzing concludes.</span></span></p>
<h3><span class="koboSpan" id="kobo.533.1">Random</span></h3>
<p><span class="koboSpan" id="kobo.534.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">random approach</span></strong><span class="koboSpan" id="kobo.536.1"> is the simplest yet least effective method. </span><span class="koboSpan" id="kobo.536.2">It involves hurling pseudo-random </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.537.1">data at the target while hoping for the best (or worst, depending on your perspective). </span><span class="koboSpan" id="kobo.537.2">Surprisingly, vulnerabilities in critical software </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.538.1">have been uncovered using this technique. </span><span class="koboSpan" id="kobo.538.2">The challenging part is identifying the cause of an exception or a server crash resulting from tons of random bytes. </span><span class="koboSpan" id="kobo.538.3">Capturing the traffic with a sniffer is essential to facilitate debugging, often requiring extensive time in a debugger and disassembler. </span><span class="koboSpan" id="kobo.538.4">Debugging stack smashing can be especially troublesome as the call stack </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">becomes corrupted.</span></span></p>
<h3><span class="koboSpan" id="kobo.540.1">Manual protocol mutation testing</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.541.1">Manual protocol mutation testing</span></strong><span class="koboSpan" id="kobo.542.1"> is even </span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.543.1">less sophisticated </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.544.1">than random fuzzing. </span><span class="koboSpan" id="kobo.544.2">It doesn’t involve an automated fuzzer; instead, the tester becomes the fuzzer. </span><span class="koboSpan" id="kobo.544.3">By entering inappropriate data into the target application, the goal is to crash the server or provoke undesired behavior. </span><span class="koboSpan" id="kobo.544.4">It’s a straightforward, cost-effective approach that’s often applied to web applications, allowing the analyst to rely on experience and intuition during </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the audit.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">We think </span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.547.1">that this approach is sometimes referred </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.548.1">to as </span><strong class="bold"><span class="koboSpan" id="kobo.549.1">hallway usability testing</span></strong><span class="koboSpan" id="kobo.550.1">, even though </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.551.1">a usability test is something different than testing the program’s correctness. </span><span class="koboSpan" id="kobo.551.2">If you’re interested in what hallway usability testing is, take a look at the </span><em class="italic"><span class="koboSpan" id="kobo.552.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.553.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1"> section.</span></span></p>
<h3><span class="koboSpan" id="kobo.555.1">Mutation or brute-force testing</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.556.1">Brute-force testing</span></strong><span class="koboSpan" id="kobo.557.1"> involves taking a valid sample of a protocol or data format and continuously </span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.558.1">modifying every byte, word, or string within that data packet or file. </span><span class="koboSpan" id="kobo.558.2">While this approach requires minimal upfront research and is relatively </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.559.1">easy to implement, it’s somewhat inefficient because it may waste CPU cycles on data that cannot be interpreted. </span><span class="koboSpan" id="kobo.559.2">Nevertheless, it can be fully automated, and it relies on a collection of known good packets or files for testing. </span><span class="koboSpan" id="kobo.559.3">Examples of brute-force file format fuzzers include FileFuzz for Windows and notSPIKEfile </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">for Linux.</span></span></p>
<h3><span class="koboSpan" id="kobo.561.1">Automatic protocol generation testing</span></h3>
<p><span class="koboSpan" id="kobo.562.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">automatic protocol generation testing</span></strong><span class="koboSpan" id="kobo.564.1">, the tester initially studies and understands </span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.565.1">the protocol specification or file definition. </span><span class="koboSpan" id="kobo.565.2">Instead of creating hard-coded test cases, a grammar is developed </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.566.1">to describe the protocol’s operation. </span><span class="koboSpan" id="kobo.566.2">Static and fuzzable variables are identified within the packet or file. </span><span class="koboSpan" id="kobo.566.3">The fuzzer works by looking at templates, creating fuzzy data, and then sending the changed data to the target. </span><span class="koboSpan" id="kobo.566.4">How well this works depends on the tester’s skills in finding the parts of the specification that are likely to cause problems during the parsing process. </span><span class="koboSpan" id="kobo.566.5">Notable examples are SPIKE and SPIKEfile. </span><span class="koboSpan" id="kobo.566.6">However, this method demands time to create the grammar or </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">definition upfront.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">We just wanted to give you a general smattering of concepts that we have often seen put in place without a real “structurization” of what was being done. </span><span class="koboSpan" id="kobo.568.2">As usual, we do not pretend to be exhaustive but simply wish to spark some curiosity in you regarding </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">this subject.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.570.1">Symbolic execution</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.571.1">Symbolic execution</span></strong><span class="koboSpan" id="kobo.572.1"> stands as </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.573.1">a program analysis method in which programs </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.574.1">are run with symbolic inputs rather than concrete ones. </span><span class="koboSpan" id="kobo.574.2">Simultaneously, it preserves a path condition (see the </span><em class="italic"><span class="koboSpan" id="kobo.575.1">Cyclomatic complexity</span></em><span class="koboSpan" id="kobo.576.1"> section to learn what a </span><em class="italic"><span class="koboSpan" id="kobo.577.1">path</span></em><span class="koboSpan" id="kobo.578.1"> is) that evolves each time a branch instruction is encountered, encapsulating the constraints on the inputs that lead to that specific point within the program. </span><span class="koboSpan" id="kobo.578.2">In other words, it works by replacing real data with symbolic values as input and describing program variable values as symbolic expressions. </span><span class="koboSpan" id="kobo.578.3">This way, the program’s results are expressed as functions of these </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">symbolic inputs.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">To create tests, this method relies on solving the gathered constraints using a constraint solver. </span><span class="koboSpan" id="kobo.580.2">Symbolic execution is also handy for finding bugs since it inspects the program as it runs for errors or assertion violations and creates test inputs that can trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">these issues.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">It is also </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.583.1">seen as a sort of </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">white-box fuzzing</span></strong><span class="koboSpan" id="kobo.585.1"> because you are fuzzing (see the previous section) but you have the knowledge of how the program works (yes, also of the code – it’s also something in between static and </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">dynamic analysis).</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">Consider this very trivial </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">Java method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.589.1">
void doSomething() {
    int x = getInput();
    int z = x + 2;
    if (z &gt; 20) {
        throw new RuntimeException();
    } else {
        System.out.println("OK");
    }
}</span></pre> <p><span class="koboSpan" id="kobo.590.1">This method does indeed do something, so its name does not lie, but it doesn’t do anything meaningful. </span><span class="koboSpan" id="kobo.590.2">It’s just a means to explain how symbolic execution would work </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">In a regular execution (often called “concrete” execution), the program operates as follows: it reads a specific input value (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">10</span></strong><span class="koboSpan" id="kobo.594.1">) and assigns this value to the variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">x</span></strong><span class="koboSpan" id="kobo.596.1">. </span><span class="koboSpan" id="kobo.596.2">Subsequently, the program executes the addition (</span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">z = x + 2</span></strong><span class="koboSpan" id="kobo.598.1">) and the conditional branch, which, in this case, results in a false evaluation and </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">OK</span></strong><span class="koboSpan" id="kobo.600.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.602.1">During symbolic execution, the program operates differently. </span><span class="koboSpan" id="kobo.602.2">It reads a symbolic value, represented </span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.603.1">by a symbol such as λ, and assigns this symbol to the variable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">x</span></strong><span class="koboSpan" id="kobo.605.1">. </span><span class="koboSpan" id="kobo.605.2">The program then continues with the addition, setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">z</span></strong><span class="koboSpan" id="kobo.607.1"> to λ + 2. </span><span class="koboSpan" id="kobo.607.2">When it </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.608.1">encounters the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">if</span></strong><span class="koboSpan" id="kobo.610.1"> statement, it evaluates the condition as λ + 2 &gt; 20. </span><span class="koboSpan" id="kobo.610.2">At this stage, the symbol λ can take on any value, and symbolic execution splits into two distinct paths by «forking.» Each path retains a copy of the program state at the branching point along with a </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">path condition.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">In this example, one path is associated with the λ + 2 &gt; 20 path condition, leading to the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">if</span></strong><span class="koboSpan" id="kobo.614.1"> branch, while the other path is tied to the λ + 2 &lt;= 20 path condition, resulting in the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">else</span></strong><span class="koboSpan" id="kobo.616.1"> branch. </span><span class="koboSpan" id="kobo.616.2">Both paths can be independently </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">symbolically executed.</span></span></p>
<p><span class="koboSpan" id="kobo.618.1">As the paths reach their conclusion, which might happen due to an exception (for example, throwing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">RuntimeException</span></strong><span class="koboSpan" id="kobo.620.1">) or program termination, symbolic execution figures out a specific value for λ by solving the path constraints for each path it explores. </span><span class="koboSpan" id="kobo.620.2">These specific values can be thought of as real-world test cases, which can be instrumental for tasks such as bug reproduction. </span><span class="koboSpan" id="kobo.620.3">In this particular case, the constraint solver would establish that to throw the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">RuntimeException</span></strong><span class="koboSpan" id="kobo.622.1">, λ needs to be greater than or equal </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">to 18.</span></span></p>
<p><span class="koboSpan" id="kobo.624.1">We must admit that this technique is not used much and presents several downsides. </span><span class="koboSpan" id="kobo.624.2">For example, as you can easily guess, the greater the cyclomatic complexity of the program, the greater the complexity of the symbolic execution; this technique does not scale at all as the complexity of the program increases. </span><span class="koboSpan" id="kobo.624.3">In addition, the efficiency of this analysis technique depends largely on the efficiency of the program itself. </span><span class="koboSpan" id="kobo.624.4">There are other contradictions that I invite you to observe in the </span><em class="italic"><span class="koboSpan" id="kobo.625.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.626.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1"> section.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.628.1">Taint tracking</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.629.1">Taint tracking</span></strong><span class="koboSpan" id="kobo.630.1">, often referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.631.1">information flow tracking</span></strong><span class="koboSpan" id="kobo.632.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.633.1">data flow tracking</span></strong><span class="koboSpan" id="kobo.634.1">, is a technique that’s used in computer security and software analysis to monitor the flow </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.635.1">of data within a program or system to identify potential security vulnerabilities. </span><span class="koboSpan" id="kobo.635.2">Taint tracking works by marking data as </span><em class="italic"><span class="koboSpan" id="kobo.636.1">tainted</span></em><span class="koboSpan" id="kobo.637.1"> if it comes from </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.638.1">an untrusted source, such as user input or a file from the internet. </span><span class="koboSpan" id="kobo.638.2">The taint tracker then tracks the flow of this tainted data through the </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.639.1">program to identify any operations that could potentially lead to a security vulnerability. </span><span class="koboSpan" id="kobo.639.2">Tainted data can include things such as passwords, personal </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.640.1">information, or any data that should not be exposed or manipulated by </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">unauthorized users.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">Here’s how taint tracking </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">typically works:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.644.1">Data labeling</span></strong><span class="koboSpan" id="kobo.645.1">: Taint </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.646.1">tracking systems label certain data as “tainted” or “untrusted” when it originates from external sources, such as </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.647.1">user inputs. </span><span class="koboSpan" id="kobo.647.2">For example, if a user provides a password as input, that password data is labeled </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">as tainted.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.649.1">Data flow monitoring</span></strong><span class="koboSpan" id="kobo.650.1">: The system then monitors how this tainted data flows through </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.651.1">the program. </span><span class="koboSpan" id="kobo.651.2">It keeps track of which </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.652.1">variables, functions, and components the tainted data </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">interacts with.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.654.1">Violations detection</span></strong><span class="koboSpan" id="kobo.655.1">: Taint tracking mechanisms continuously check if tainted data is </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.656.1">used in a way that could compromise security. </span><span class="koboSpan" id="kobo.656.2">For example, if tainted data is used in a database query, sent over </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.657.1">a network, or included in a response, the taint tracking system can flag this as a potential </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">security risk.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.659.1">Alerts generation</span></strong><span class="koboSpan" id="kobo.660.1">: When a </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.661.1">potential security </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.662.1">violation is detected, the system can generate alerts, log the event, or take some other predefined action to mitigate the risk. </span><span class="koboSpan" id="kobo.662.2">This helps in identifying and fixing </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">security vulnerabilities:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.664.1"><img alt="Figure 7.2 – One of the possible inputs is marked as tainted (because it comes from an untrusted source) and its flow through the program is tracked until its possible outputs" src="image/B20912_07_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.665.1">Figure 7.2 – One of the possible inputs is marked as tainted (because it comes from an untrusted source) and its flow through the program is tracked until its possible outputs</span></p>
<p><span class="koboSpan" id="kobo.666.1">For example, a taint tracker could be used to identify SQL injection vulnerabilities in web applications. </span><span class="koboSpan" id="kobo.666.2">SQL injection vulnerabilities occur when an attacker can inject malicious SQL code into </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.667.1">a web application’s database queries. </span><span class="koboSpan" id="kobo.667.2">This can allow the attacker to read or modify data in the database, or even execute arbitrary code on the web server. </span><span class="koboSpan" id="kobo.667.3">A taint tracker </span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.668.1">could be used to identify SQL injection vulnerabilities by marking all user input as tainted. </span><span class="koboSpan" id="kobo.668.2">The taint tracker would then track the flow of this tainted data through the web application’s code to identify any operations that could potentially lead to a SQL injection vulnerability. </span><span class="koboSpan" id="kobo.668.3">For example, if the tainted data is used in a database query without being properly sanitized, the taint tracker would flag this as a </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">potential vulnerability.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.670.1">A small digression – what is SQL injection?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.671.1">Even if it is </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.672.1">not strictly related to taint tracking, we think it is worth knowing what </span><strong class="bold"><span class="koboSpan" id="kobo.673.1">SQL </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.674.1">injection</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.675.1"> is.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.676.1">SQL injection is a common and dangerous type of cyber-attack where an attacker can manipulate a web application’s SQL query by injecting malicious SQL code. </span><span class="koboSpan" id="kobo.676.2">This can potentially lead to unauthorized access, data theft, or even data manipulation. </span><span class="koboSpan" id="kobo.676.3">But how can this happen? </span><span class="koboSpan" id="kobo.676.4">Suppose you have a web application that takes user input to search for a specific user in a database using the following </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">SQL query:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">SELECT * FROM user WHERE username = '</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">input';</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.680.1">Here, the input is taken directly from </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">user</span></strong><span class="koboSpan" id="kobo.682.1"> input, and the application does not properly validate or sanitize </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">this </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">input</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.686.1">An attacker can exploit this vulnerability by inputting the following as </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">their username:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">' </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">OR '1'='1</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.690.1">The SQL query </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.691.1">would then look </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">like this:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">SELECT * FROM users WHERE username = '' </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">OR '1'='1';</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.695.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">'1'='1'</span></strong><span class="koboSpan" id="kobo.697.1"> condition is always true, so the query effectively selects all rows in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">users</span></strong><span class="koboSpan" id="kobo.699.1"> table, allowing the attacker to bypass any authentication and access all </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">user data.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.701.1">To prevent </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.702.1">SQL injection, you should use parameterized queries or prepared statements provided by Java’s </span><strong class="bold"><span class="koboSpan" id="kobo.703.1">Java Database Connectivity</span></strong><span class="koboSpan" id="kobo.704.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.705.1">JDBC</span></strong><span class="koboSpan" id="kobo.706.1">) API or some other popular frameworks, such as Hibernate. </span><span class="koboSpan" id="kobo.706.2">Here’s how you can rewrite the vulnerable code so that it </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">becomes secure:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">String userInput = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">getUserInput();</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">String sqlQuery = "SELECT * FROM users WHERE username = ?";</span></strong></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">PreparedStatement preparedStatement = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">connection.prepareStatement(sqlQuery);</span></strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">preparedStatement.setString(1, userInput);</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">ResultSet resultSet = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">preparedStatement.executeQuery();</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.716.1">In this example, a parameterized SQL query is created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">PreparedStatement</span></strong><span class="koboSpan" id="kobo.718.1">, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">?</span></strong><span class="koboSpan" id="kobo.720.1"> is a placeholder for the user input. </span><span class="koboSpan" id="kobo.720.2">The user input is then safely set as a parameter using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">setString</span></strong><span class="koboSpan" id="kobo.722.1"> method (note that no quotes and no string concatenation are involved). </span><span class="koboSpan" id="kobo.722.2">The query is executed, and the results are </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">processed securely.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.724.1">By using parameterized queries like this, you can prevent SQL injection attacks because the JDBC driver handles the input as data rather than executable SQL code. </span><span class="koboSpan" id="kobo.724.2">This ensures the user input is treated safely and doesn’t interfere with the </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">query’s structure.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">Taint tracking can be used to identify a variety of other security vulnerabilities, such as XSS, command injection, and insecure path traversal. </span><span class="koboSpan" id="kobo.726.2">It can also be used to track the flow of sensitive data, such as credit card numbers and social </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">security numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.728.1">Using taint tracking offers various advantages, including the ability to uncover security vulnerabilities in </span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.729.1">software that would be difficult or even impossible to identify through alternative testing methods. </span><span class="koboSpan" id="kobo.729.2">This approach also allows you to monitor </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.730.1">sensitive data flow, helping to mitigate the risk of data breaches. </span><span class="koboSpan" id="kobo.730.2">Moreover, it provides a means to establish security sandboxes, effectively isolating untrusted code from </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">trusted components.</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Nonetheless, taint tracking presents several challenges. </span><span class="koboSpan" id="kobo.732.2">Its implementation can be intricate, requiring expertise in software security and taint tracking. </span><span class="koboSpan" id="kobo.732.3">It may introduce a performance impact on the monitored program, and it can result in a significant number of false positives, which can be time-consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">to investigate.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">It is worth noticing that some programming languages, such as Perl, Ruby, or Ballerina, natively support </span><em class="italic"><span class="koboSpan" id="kobo.735.1">taint checking</span></em><span class="koboSpan" id="kobo.736.1">, a feature that proceeds variable by variable, forming a list of variables that are potentially influenced by outside input. </span><span class="koboSpan" id="kobo.736.2">More information can be found in the </span><em class="italic"><span class="koboSpan" id="kobo.737.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.738.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1"> section.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.740.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.741.1">In this chapter, we added another tool to our toolbox for writing and maintaining clean code and efficient software: code analysis. </span><span class="koboSpan" id="kobo.741.2">We learned that we can do it in two ways: by checking the code before it’s even run (statically) and by watching the code as it runs (dynamically). </span><span class="koboSpan" id="kobo.741.3">We tried to figure out what kind of problems we should look out for in each of these analyses, and we also found some tools and techniques that </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">can help.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">Just like the other stuff we’ve covered, this chapter is meant to give you ideas for going deeper. </span><span class="koboSpan" id="kobo.743.2">Code analysis is often seen as something extra, like an optional step, but it’s a crucial part of making a project efficient and easy to maintain. </span><span class="koboSpan" id="kobo.743.3">So, don’t underestimate </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">its importance!</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">Besides the times when you do analysis and improve your work, it’s crucial to keep a certain level of quality in your everyday tasks. </span><span class="koboSpan" id="kobo.745.2">You can make a significant difference with minimal, targeted effort by using some simple but effective methods. </span><span class="koboSpan" id="kobo.745.3">In the next chapter, we’ll explore some of </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">these methods.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.747.1">Further reading</span></h1>
<ul>
<li><span class="koboSpan" id="kobo.748.1">Cyclomatic </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">complexity: </span></span><a href="https://www.geeksforgeeks.org/cyclomatic-complexity/"><span class="No-Break"><span class="koboSpan" id="kobo.750.1">https://www.geeksforgeeks.org/cyclomatic-complexity/</span></span></a></li>
<li><span class="koboSpan" id="kobo.751.1">SonarQube </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">documentation: </span></span><a href="https://docs.sonarsource.com/sonarqube/latest/"><span class="No-Break"><span class="koboSpan" id="kobo.753.1">https://docs.sonarsource.com/sonarqube/latest/</span></span></a></li>
<li><span class="koboSpan" id="kobo.754.1">PMD </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">documentation: </span></span><a href="https://pmd.github.io/pmd/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.756.1">https://pmd.github.io/pmd/index.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.757.1">FindBugs </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">manual: </span></span><a href="https://findbugs.sourceforge.net/manual/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.759.1">https://findbugs.sourceforge.net/manual/index.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.760.1">An introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">CheckStyle: </span></span><a href="https://www.baeldung.com/checkstyle-java"><span class="No-Break"><span class="koboSpan" id="kobo.762.1">https://www.baeldung.com/checkstyle-java</span></span></a></li>
<li><span class="koboSpan" id="kobo.763.1">Getting started with </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">VisualVM: </span></span><a href="https://visualvm.github.io/gettingstarted.html"><span class="No-Break"><span class="koboSpan" id="kobo.765.1">https://visualvm.github.io/gettingstarted.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.766.1">M. </span><span class="koboSpan" id="kobo.766.2">Sutton, A. </span><span class="koboSpan" id="kobo.766.3">Greene, and P. </span><span class="koboSpan" id="kobo.766.4">Amini, </span><em class="italic"><span class="koboSpan" id="kobo.767.1">Fuzzing: Brute Force Vulnerability Discovery</span></em><span class="koboSpan" id="kobo.768.1">, by </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">Addison-Wesley Professional</span></span></li>
<li><span class="koboSpan" id="kobo.770.1">Hallway usability </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">testing: </span></span><a href="https://www.techopedia.com/definition/30678/hallway-usability-testing"><span class="No-Break"><span class="koboSpan" id="kobo.772.1">https://www.techopedia.com/definition/30678/hallway-usability-testing</span></span></a></li>
<li><span class="koboSpan" id="kobo.773.1">Limitations of symbolic </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">execution: </span></span><a href="https://en.wikipedia.org/wiki/Symbolic_execution#Limitations"><span class="No-Break"><span class="koboSpan" id="kobo.775.1">https://en.wikipedia.org/wiki/Symbolic_execution#Limitations</span></span></a></li>
<li><span class="koboSpan" id="kobo.776.1">Taint checking in programming </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">languages: </span></span><a href="https://en.wikipedia.org/wiki/Taint_checking"><span class="No-Break"><span class="koboSpan" id="kobo.778.1">https://en.wikipedia.org/wiki/Taint_checking</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer043">
<h1 id="_idParaDest-172" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.1.1">Part 3: Further Learning</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Apart from the actual act of refactoring, it’s crucial to keep up a certain level of quality in your everyday work. </span><span class="koboSpan" id="kobo.2.2">There are small but powerful ways to achieve this goal, making a big impact with minimal, focused effort. </span><span class="koboSpan" id="kobo.2.3">We’ll discuss things like how you format your code, manage versions of your code, and work together with others through techniques like </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">pair programming.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">After we’ve covered everything about fixing up classes and packages, let’s zoom out and look at the big picture: architecture. </span><span class="koboSpan" id="kobo.4.2">Even if your code is good, things can go wrong if the way different parts interact is not well-managed. </span><span class="koboSpan" id="kobo.4.3">We’ll talk about signs to watch out for and what to do instead to keep everything </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">running smoothly.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">following chapters:</span></span></p>
<ul>
<li><a href="B20912_08.xhtml#_idTextAnchor183"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.9.1">, </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Crafting Quality Every Day</span></em></li>
<li><a href="B20912_09.xhtml#_idTextAnchor217"><em class="italic"><span class="koboSpan" id="kobo.11.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.12.1">, </span><em class="italic"><span class="koboSpan" id="kobo.13.1">Beyond Code – Mastering Software Architecture</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer044">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer045">
</div>
</div>
</body></html>