- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '23'
- en: Native-Complied Java Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原生编译的Java微服务
- en: In this chapter, we will learn how to compile the Java source code in our microservices
    into binary executable files, known as **Native Images**. A Native Image starts
    up significantly faster compared to using a Java VM and is also expected to consume
    less memory. We will be introduced to the **Spring AOT** engineintroduced in Spring
    Framework 6 and the **GraalVM** project and its **Native Image compiler**, learning
    how to use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将我们的微服务中的Java源代码编译成二进制可执行文件，称为**原生镜像**。与使用Java VM相比，原生镜像启动速度显著更快，并且预计还会消耗更少的内存。我们将介绍Spring
    Framework 6中引入的**Spring AOT**引擎以及**GraalVM**项目和它的**原生镜像编译器**，学习如何使用它们。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: When to natively compile Java source code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时原生编译Java源代码
- en: Introducing the GraalVM project and Spring’s AOT engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍GraalVM项目和Spring的AOT引擎
- en: Handling problems with native compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理原生编译中的问题
- en: Testing and compiling Native Images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和编译原生镜像
- en: Testing with Docker Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行测试
- en: Testing with Kubernetes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行测试
- en: Even though Spring Framework 6 and Spring Boot 3 come with **General Availability**
    (**GA**) support for building native executables of Spring Boot applications,
    it must be considered as being in an early stage. At the time of writing this
    chapter, a lot of pitfalls were discovered while natively compiling the microservices
    in this book. Since natively compiling the microservices is not required for the
    rest of the material in this book, this chapter is placed at the end of the book
    as an extra chapter, describing an exciting but not yet fully mature technology.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring Framework 6和Spring Boot 3提供了对构建Spring Boot应用程序原生可执行文件的支持，即**通用可用性**（**GA**），但这仍处于早期阶段。在撰写本章时，在原生编译本书中的微服务时发现了许多陷阱。由于原生编译微服务对于本书其余部分的内容不是必需的，因此本章被放置在书的末尾，作为额外的一章，描述了一个令人兴奋但尚未完全成熟的技术。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第21章*，*macOS安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第22章*，*使用WSL 2和Ubuntu的Microsoft Windows安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter23`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码示例均来自`$BOOK_HOME/Chapter23`的源代码。
- en: If you want to view the changes applied to the source code in this chapter so
    you can natively compile the microservices, you can compare it with the source
    code for *Chapter 20*, *Monitoring Microservices*. You can use your favorite `diff`
    tool and compare the two folders `$BOOK_HOME/Chapter20` and `$BOOK_HOME/Chapter23`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想查看本章源代码中应用的变化，以便你可以原生编译微服务，你可以将其与*第20章*，*监控微服务*的源代码进行比较。你可以使用你喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter20`和`$BOOK_HOME/Chapter23`。
- en: When to native-compile Java source code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时原生编译Java源代码
- en: Java has always been known for its **build-once-run-anywhere** capability, providing
    excellent cross-platform support. The Java source code is compiled once into bytecode.
    At runtime, a Java VM transforms the bytecode into executable code for the target
    platform using a **Just in Time** compiler, also known as **JIT** compilation.
    This takes some time, slowing down the startup of Java programs. Before the era
    of microservices, Java components typically ran on an application server, like
    a Java EE server. After being deployed, the Java component ran for a long time,
    making the longer startup time less of a problem.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java一直以其**一次构建，到处运行**的能力而闻名，提供了出色的跨平台支持。Java源代码编译成一次的字节码。在运行时，Java VM使用**即时**编译器（也称为JIT编译）将字节码转换为针对目标平台的可执行代码。这需要一些时间，会减慢Java程序的启动速度。在微服务时代之前，Java组件通常运行在应用程序服务器上，如Java
    EE服务器。部署后，Java组件会长时间运行，使得较长的启动时间不再是问题。
- en: With the introduction of microservices, this perspective changed. With microservices,
    there comes the expectation of being able to upgrade them more frequently and
    quickly scale instances for a microservice up and down based on its usage. Another
    expectation is to be able to **scale to zero**, meaning that when a microservice
    is not used, it should not run any instances at all. An unused microservice should
    not allocate any hardware resources and, even more importantly, should not create
    any runtime cost, for example, in a cloud deployment. To be able to meet these
    expectations, it is important that a microservice instance can be started swiftly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的引入，这种观点发生了变化。使用微服务，人们期望能够更频繁、更快速地升级它们，并根据其使用情况对微服务的实例进行上下调整。另一个期望是能够**扩展到零**，这意味着当微服务不被使用时，它不应运行任何实例。未使用的微服务不应分配任何硬件资源，更重要的是，不应产生任何运行时成本，例如在云部署中。为了能够满足这些期望，微服务实例能够迅速启动是非常重要的。
- en: Also, with the use of containers, the importance of cross-platform support built
    into the application itself has faded. Instead, Docker can be used to build Docker
    images that contain support for multiple platforms, for example, Linux on both
    `arm64` and `amd64` (also known as `x86_64`), or Docker images that can be run
    on Windows and Linux. For more information, see [https://docs.docker.com/build/building/multi-platform/](https://docs.docker.com/build/building/multi-platform/).
    For an example of a Docker image that contains multi-platform support, see the
    OpenJDK Docker image used in this book, [https://hub.docker.com/_/eclipse-temurin/tags](https://hub.docker.com/_/eclipse-temurin/tags).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着容器技术的应用，应用程序本身内置的跨平台支持的重要性已经降低。相反，可以使用Docker构建包含对多个平台支持的Docker镜像，例如，同时支持`arm64`和`amd64`（也称为`x86_64`）的Linux，或者可以在Windows和Linux上运行的Docker镜像。更多信息，请参阅[https://docs.docker.com/build/building/multi-platform/](https://docs.docker.com/build/building/multi-platform/)。关于包含多平台支持的Docker镜像的示例，请参阅本书中使用的OpenJDK
    Docker镜像，[https://hub.docker.com/_/eclipse-temurin/tags](https://hub.docker.com/_/eclipse-temurin/tags)。
- en: Given that the startup time for Java programs can be significantly reduced,
    other use cases also come to mind; for example, developing Java-based **Function-as-a-Service**
    (**FaaS**) solutions using AWS Lambda, Azure Functions, or Google Cloud Functions,
    to mention some of the major platforms. Also, developing CLI tools in Java becomes
    a feasible option.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java程序的启动时间可以显著减少，其他用例也浮现在脑海中；例如，使用AWS Lambda、Azure Functions或Google Cloud
    Functions等主要平台开发基于Java的**函数即服务**（**FaaS**）解决方案，仅举一些例子。此外，在Java中开发CLI工具也成为了一种可行的选择。
- en: Together, these lead to a situation where faster startup becomes a more critical
    requirement than cross-platform support. This requirement can be achieved by compiling
    the Java source code into the target platform’s binary format at build time, in
    the same way as C or Go programs are compiled. This is known as **Ahead of Time**
    compilation or **AOT** compilation. The GraalVM Native Image compiler will be
    used to perform the AOT compilation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些共同导致了一种情况，即更快的启动速度比跨平台支持成为一个更关键的要求。这个要求可以通过在构建时将Java源代码编译成目标平台的二进制格式来实现，就像C或Go程序被编译一样。这被称为**即时编译**或**AOT**编译。GraalVM
    Native Image编译器将用于执行AOT编译。
- en: As we will see in the next section, the GraalVM Native Image compiler comes
    with a few restrictions, for example, relating to the use of reflection and dynamic
    proxies. It also takes quite some time to compile Java code into a binary Native
    Image. This technology has its strengths and weaknesses.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节中看到的，GraalVM Native Image编译器带来了一些限制，例如与反射和动态代理的使用相关。将Java代码编译成二进制原生镜像也需要相当长的时间。这项技术有其优点和缺点。
- en: 'With a better understanding of when it might be of interest to natively compile
    Java source code, let’s learn about the tooling: first, the GraalVM project, and
    then, the Spring AOT engine.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在更好地理解何时可能需要原生编译Java源代码之后，让我们了解相关的工具：首先，GraalVM项目，然后是Spring AOT引擎。
- en: Introducing the GraalVM project
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GraalVM项目
- en: 'Oracle has worked for several years on a high-performance Java VM and associated
    tools, known together as the **GraalVM** project ([https://www.graalvm.org](https://www.graalvm.org)).
    It was launched back in April 2018 ([https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917](https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917)),
    but work can be traced back to, for example, a research paper from Oracle Labs
    in 2013 on the subject: *Maxine: An approachable virtual machine for, and in,
    java*; see [https://dl.acm.org/doi/10.1145/2400682.2400689](https://dl.acm.org/doi/10.1145/2400682.2400689).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle多年来一直在开发高性能Java VM和相关工具，这些工具统称为**GraalVM**项目([https://www.graalvm.org](https://www.graalvm.org))。该项目于2018年4月启动([https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917](https://medium.com/graalvm/graalvm-in-2018-b5fa7ff3b917))，但其工作可以追溯到例如Oracle
    Labs在2013年关于该主题的研究论文：*Maxine：一个易于接近的Java虚拟机，用于Java中*；请参阅[https://dl.acm.org/doi/10.1145/2400682.2400689](https://dl.acm.org/doi/10.1145/2400682.2400689)。
- en: '**Fun Fact**: The Maxine VM is known as a **metacircular** Java VM implementation,
    meaning that it is, itself, written in Java.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**有趣的事实**：Maxine VM被称为**元循环**Java VM实现，这意味着它本身是用Java编写的。'
- en: GraalVM’s VM is polyglot, supporting not only traditional Java VM languages
    such as Java, Kotlin, and Scala but also languages such as JavaScript, C, C++,
    Ruby, Python, and even programs compiled into a WebAssembly. The part of GraalVM
    that we will focus on is its **Native Image** compiler, which can be used to compile
    Java bytecode into a Native Image containing binary executable code for a specific
    **operating system** (**OS**) and HW platform, for example, macOS on Apple silicon
    (`arm64`) or Linux on Intel (`amd64`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM的VM是多语言的，不仅支持传统的Java VM语言，如Java、Kotlin和Scala，还支持JavaScript、C、C++、Ruby、Python，甚至编译成WebAssembly的程序。我们将关注的GraalVM部分是其**本地图像**编译器，它可以用来将Java字节码编译成包含特定**操作系统**（**OS**）和HW平台二进制可执行代码的本地图像，例如，在苹果硅上的macOS（`arm64`）或在Intel上的Linux（`amd64`）。
- en: The Native Image can run without a Java VM, including binary compiled application
    classes and other classes required from the application’s dependencies. It also
    includes a runtime system called **Substrate VM**, which handles garbage collection,
    thread scheduling, and more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本地图像可以在没有Java VM的情况下运行，包括二进制编译的应用程序类以及其他来自应用程序依赖项所需的类。它还包括一个名为**Substrate VM**的运行时系统，该系统处理垃圾回收、线程调度等。
- en: To be able to build a Native Image, the native compiler runs static code analysis
    based on a closed-world assumption, meaning that all bytecode that can be called
    at runtime must be reachable during build time. Therefore, it is not possible
    to load or create classes on the fly in runtime that was not available during
    the AOT compilation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建本地图像，本地编译器基于封闭世界假设执行静态代码分析，这意味着在运行时可以调用的所有字节码必须在构建时可达。因此，在AOT编译期间不可用的运行时动态加载或创建类是不可能的。
- en: To overcome these restrictions, the GraalVM project provides configuration options
    for the native compiler where we can provide **reachability metadata**. With this
    configuration, we can describe the use of dynamic features like reflection and
    the generation of proxy classes at runtime. For more information, see [https://www.graalvm.org/22.3/reference-manual/Native
    Image/metadata/](https://www.graalvm.org/22.3/reference-manual/native-image/metadata/).
    We will learn later in this chapter various ways to create the required reachability
    metadata.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些限制，GraalVM项目为本地编译器提供了配置选项，我们可以提供**可达性元数据**。使用此配置，我们可以描述动态特性（如反射）的使用和运行时生成代理类。有关更多信息，请参阅[https://www.graalvm.org/22.3/reference-manual/Native%20Image/metadata/](https://www.graalvm.org/22.3/reference-manual/native-image/metadata/)。在本章的后面，我们将学习创建所需可达性元数据的各种方法。
- en: The GraalVM Native Image compiler can be launched using a CLI command, `Native
    Image`, or as part of a Maven or Gradle build. GraalVM provides a plugin for both
    Maven and Gradle. In this chapter, the Gradle plugin will be used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用CLI命令`Native Image`或作为Maven或Gradle构建的一部分来启动GraalVM本地图像编译器。GraalVM为Maven和Gradle都提供了插件。在本章中，我们将使用Gradle插件。
- en: With GraalVM introduced, it is time to learn about Spring’s AOT engine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GraalVM引入后，是时候学习Spring的AOT引擎了。
- en: Introducing the Spring’s AOT engine
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Spring的AOT引擎
- en: The Spring team has also worked on supporting the native compilation of Spring
    applications for some time. In March 2021, after 18 months of work, the experimental
    **Spring Native** project launched a beta release; see [https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta).
    Based on the experiences from the Spring Native Project, official support for
    building Native Images was added in Spring Framework 6 and Spring Boot 3; see
    [https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3](https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3).
    To perform the actual native compilation, Spring uses GraalVM’s Native Image compiler
    under the hood.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 团队也一直在努力支持 Spring 应用的原生编译。2021 年 3 月，经过 18 个月的工作，实验性的 **Spring Native**
    项目发布了 beta 版本；请参阅 [https://spring.io/blog/2021/03/11/announcing-spring-native-beta](https://spring.io/blog/2021/03/11/announcing-spring-native-beta)。基于
    Spring Native 项目的经验，Spring 框架 6 和 Spring Boot 3 中增加了构建 Native Image 的官方支持；请参阅
    [https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3](https://spring.io/blog/2023/02/23/from-spring-native-to-spring-boot-3)。实际上进行原生编译时，Spring
    在底层使用 GraalVM 的 Native Image 编译器。
- en: The most important feature is Spring’s new **AOT engine**, which analyzes the
    Spring Boot application at build time and generates initialization source code
    and reachability metadata required by the GraalVM Native Image compiler. The generated
    initialization source code, also known as **AOT-generated code**, replaces the
    reflection-based initialization performed when using a Java VM, eliminating most
    of the requirements of dynamic features like reflection and the generation of
    proxy classes at runtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的特性是 Spring 的新 **AOT 引擎**，该引擎在构建时分析 Spring Boot 应用程序，并生成 GraalVM Native Image
    编译器所需的初始化源代码和可达性元数据。生成的初始化源代码，也称为 **AOT 生成的代码**，替换了使用 Java VM 时执行的基于反射的初始化，消除了大多数动态特性（如反射和运行时生成代理类）的需求。
- en: When this AOT processing is performed, a closed-world assumption is made in
    the same way as for the GraalVM Native Image compiler. This means that only Spring
    beans and classes reachable at build time will be represented in the AOT-generated
    code and reachability metadata. Special attention must be given to Spring beans
    that only are created if some profiles are set or if some conditions are met,
    using `@Profile` or `@ConditionalOnProperty` annotations. These profiles and conditions
    must be set at build time; otherwise, these Spring beans will not be represented
    in the Native Image.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此 AOT 处理时，会像 GraalVM Native Image 编译器一样做出封闭世界假设。这意味着只有构建时可达的 Spring bean
    和类将表示在 AOT 生成的代码和可达性元数据中。必须特别注意那些仅在设置某些配置文件或满足某些条件时才创建的 Spring bean，使用 `@Profile`
    或 `@ConditionalOnProperty` 注解。这些配置文件和条件必须在构建时设置；否则，这些 Spring bean 将不会在 Native
    Image 中表示。
- en: To perform the analysis, the AOT engine creates bean definitions for all Spring
    beans it can find by scanning the source code of the application. But instead
    of instantiating the Spring beans, meaning starting the application, it generates
    the corresponding initialization code that will instantiate the Spring beans when
    executed. For all uses of the dynamic features, it will also generate the required
    reachability metadata.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行分析，AOT 引擎通过扫描应用程序的源代码为所有可找到的 Spring bean 创建 bean 定义。但不是实例化 Spring bean，即启动应用程序，而是生成在执行时将实例化
    Spring bean 的相应初始化代码。对于所有动态特性的使用，它还将生成所需的可达性元数据。
- en: 'The process of creating a Native Image from the source code of a Spring Boot
    application is summarized by the following data flow diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Spring Boot 应用程序的源代码创建 Native Image 的过程由以下数据流图总结：
- en: '![A picture containing text, screenshot, diagram, line  Description automatically
    generated](img/B19825_23_01.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、图表的图片，自动生成行描述](img/B19825_23_01.png)'
- en: 'Figure 23.1: Data flow diagram explaining the creation of a Native Image'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.1：解释创建 Native Image 的数据流图
- en: 'The creation of a Native Image goes through the following steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Native Image 的步骤如下：
- en: The application’s source code is compiled into bytecode by the Java compiler.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的源代码由 Java 编译器编译成字节码。
- en: Spring’s AOT engine analyzes the code under a closed-world assumption and generates
    AOT source code and reachability metadata.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring 的 AOT 引擎在封闭世界假设下分析代码，并生成 AOT 源代码和可达性元数据。
- en: The AOT-generated code is compiled into bytecode using the Java compiler.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AOT 生成的代码使用 Java 编译器编译成字节码。
- en: The application’s bytecode, together with the reachability metadata and bytecode
    created by the AOT engine, is sent to GraalVM’s Native Image compiler, which creates
    the Native Image.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序的字节码，连同可达性元数据和AOT引擎创建的字节码，被发送到GraalVM的原生镜像编译器，该编译器创建原生镜像。
- en: For more information on how the creation of GraalVM Native Images is supported
    in Spring Boot 3, see [https://docs.spring.io/spring-boot/docs/current/reference/html/Native
    Image.html](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在Spring Boot 3中支持创建GraalVM原生镜像的更多信息，请参阅[https://docs.spring.io/spring-boot/docs/current/reference/html/Native
    Image.html](https://docs.spring.io/spring-boot/docs/current/reference/html/native-image.html)。
- en: 'Building a Native Image can be done in two ways:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原生镜像可以通过两种方式完成：
- en: 'Creating a Native Image for the current OS:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前操作系统创建原生镜像：
- en: The first option uses Gradle’s `nativeImage` task. It will use the installed
    GraalVM’s Native Image compiler to create an executable file for the current OS
    and hardware architecture. The nativeImage task is available given that GraalVM’s
    Gradle-plugin is declared in the build file.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一种选择使用Gradle的`nativeImage`任务。它将使用已安装的GraalVM原生镜像编译器为当前操作系统和硬件架构创建一个可执行文件。当在构建文件中声明GraalVM的Gradle-plugin时，nativeImage任务可用。
- en: Creating a Native Image as a Docker image
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原生镜像作为Docker镜像创建
- en: The second option is to use the existing Gradle task, `bootBuildImage`, to create
    a Docker image. Given that GraalVM’s Gradle plugin is declared in the build file,
    the bootBuildImage task will create a Docker image that contains the Native Image
    instead of a Java VM with the application’s JAR file that is used otherwise. The
    Native Image will be built in a Docker container so that it will be built for
    Linux. This also means that the GraalVM’s Native Image compiler does not need
    to be installed when the bootBuildImage task is used. Under the hood, this task
    uses **buildpacks**, instead of a Dockerfile, to create the Docker image.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二种选择是使用现有的Gradle任务`bootBuildImage`来创建Docker镜像。鉴于GraalVM的Gradle插件已在构建文件中声明，`bootBuildImage`任务将创建一个包含原生镜像的Docker镜像，而不是包含应用程序JAR文件的Java
    VM。原生镜像将在Docker容器中构建，因此它将为Linux构建。这也意味着当使用`bootBuildImage`任务时，不需要安装GraalVM的原生镜像编译器。在底层，此任务使用**buildpacks**而不是Dockerfile来创建Docker镜像。
- en: The concept of buildpacks was introduced by Heroku back in 2011\. In 2018, the
    **Cloud Native Buildpacks** project ([https://buildpacks.io](https://buildpacks.io))
    was created by Pivotal and Heroku, and later that year, it joined CNCF.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: buildpacks的概念是由Heroku在2011年引入的。2018年，由Pivotal和Heroku创建的**Cloud Native Buildpacks**项目([https://buildpacks.io](https://buildpacks.io))，并在同年加入了CNCF。
- en: 'To be a bit more formal, a buildpack creates an **OCI image**, according to
    the OCI Image Format Specification: [https://github.com/opencontainers/image-spec/blob/master/spec.md](https://github.com/opencontainers/image-spec/blob/master/spec.md).
    Since the OCI specification is based on Docker’s image format, the formats are
    very similar and are both supported by container engines.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加正式一点，buildpack根据OCI Image Format规范创建一个**OCI镜像**：[https://github.com/opencontainers/image-spec/blob/master/spec.md](https://github.com/opencontainers/image-spec/blob/master/spec.md)。由于OCI规范基于Docker的镜像格式，格式非常相似，并且都由容器引擎支持。
- en: 'To create the OCI images, Spring Boot uses buildpacks from the **Paketo** project;
    for more information, see [https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks](https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks)
    and [https://paketo.io/docs/builders](https://paketo.io/docs/builders). Unfortunately,
    Paketo’s buildpacks did not support `arm64`, including Apple silicon, at the time
    of writing this chapter. The `amd64` (Intel)-based buildpacks technically works
    on a MacBook with Apple silicon but runs painfully slowly. As suggested here,
    [https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/](https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/),
    unofficial Docker images for `arm64` can be used as a temporary workaround. They
    are available here: [https://hub.docker.com/r/dashaun/builder-arm](https://hub.docker.com/r/dashaun/builder-arm).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建OCI镜像，Spring Boot使用来自**Paketo**项目的buildpack；有关更多信息，请参阅[https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks](https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/container-images.html#container-images.buildpacks)和[https://paketo.io/docs/builders](https://paketo.io/docs/builders)。遗憾的是，在撰写本章时，Paketo的buildpacks不支持`arm64`，包括苹果硅。基于`amd64`（英特尔）的buildpack在技术上可以在苹果硅的MacBook上运行，但运行速度非常慢。正如这里所建议的[https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/](https://www.cloudfoundry.org/blog/arm64-paketo-buildpacks/)，可以使用非官方的`arm64`Docker镜像作为临时的解决方案。它们在此处可用：[https://hub.docker.com/r/dashaun/builder-arm](https://hub.docker.com/r/dashaun/builder-arm)。
- en: Creating Native Images with the `nativeImage` task for the local OS is faster
    than creating Docker images. Therefore, the `nativeImage` task can be used for
    a quick feedback loop when initially trying to build a Native Image successfully.
    But once that has been worked out, creating Docker images containing the Native
    Image is the most useful alternative for testing natively compiled microservices,
    together with either Docker Compose or Kubernetes. In this chapter, we will use
    the unofficial Docker images mentioned above, named `dashaun/builder:tiny`. Docker
    images for both `arm64` and `amd64` are provided.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地OS的`nativeImage`任务创建本地镜像比创建Docker镜像更快。因此，`nativeImage`任务可以在最初尝试成功构建本地镜像时用于快速反馈循环。但是，一旦解决这个问题，创建包含本地镜像的Docker镜像是测试本地编译的微服务最有用的替代方案，无论是使用Docker
    Compose还是Kubernetes。在本章中，我们将使用前面提到的非官方Docker镜像，名为`dashaun/builder:tiny`。提供了`arm64`和`amd64`的Docker镜像。
- en: Several tools and projects are available to help eliminate challenges with native
    compilation. The next section will give an overview of them, and in the *Testing
    and compiling Native Images* section, we will learn how to use them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个工具和项目可以帮助消除本地编译的挑战。下一节将概述它们，在*测试和编译本地镜像*部分，我们将学习如何使用它们。
- en: Handling problems with native compilation
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理本地编译问题
- en: Natively compiling Spring Boot applications is, as already mentioned, not yet
    mainstream. Therefore, you will probably run into problems when trying it out
    on your own applications. This section will go through a few projects and tools
    that can be used to handle these problems. Examples of how to use these tools
    will be provided in the sections below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，使用本地编译Spring Boot应用程序还不是主流。因此，当你在自己的应用程序上尝试时，可能会遇到问题。本节将介绍一些可以用来处理这些问题的项目和工具。以下章节将提供如何使用这些工具的示例。
- en: 'The following project and tools can be used to handle problems with native
    compilation of Spring Boot applications:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目和工具可用于处理Spring Boot应用程序的本地编译问题：
- en: 'Spring AOT smoke tests:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring AOT烟雾测试：
- en: 'This project contains a suite of tests verifying that the various Spring projects
    work when natively compiled. Whenever you encounter issues with natively compiling
    a Spring feature, you should start looking into this project for a working solution.
    Also, if you want to report a problem with natively compiling a Spring project,
    you can use tests from this project as a boilerplate to demonstrate the problem
    in a reproducible way. The project is available at [https://github.com/spring-projects/spring-aot-smoke-tests](https://github.com/spring-projects/spring-aot-smoke-tests).
    Test results can be found in Spring’s CI environment. For example, the tests of
    the various Spring Cloud projects can be found here: [https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests](https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests).'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此项目包含一系列测试，用于验证各种Spring项目在本地编译时是否正常工作。每当您遇到与本地编译Spring功能相关的问题时，您应该开始查找此项目以找到可行的解决方案。此外，如果您想报告关于本地编译Spring项目的任何问题，您可以使用此项目的测试作为模板，以可重复的方式展示问题。该项目可在[https://github.com/spring-projects/spring-aot-smoke-tests](https://github.com/spring-projects/spring-aot-smoke-tests)找到。测试结果可在Spring的CI环境中找到。例如，各种Spring
    Cloud项目的测试可以在这里找到：[https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests](https://ci.spring.io/teams/spring-aot-smoke-tests/pipelines/spring-aot-smoke-tests-3.0.x?group=cloud-app-tests)。
- en: 'GraalVM reachability metadata repository:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraalVM可达性元数据仓库：
- en: This project contains reachability metadata for various open-source projects
    that do not yet support native compilation themselves. The GraalVM community can
    submit reachability metadata, which is approved after a review by the project’s
    team. GraalVM’s Gradle plugin automatically looks up reachability metadata from
    this project and adds it when natively compiling. For more information, see [https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support](https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support).
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此项目包含各种尚未支持本地编译的开放源代码项目的可达性元数据。GraalVM社区可以提交可达性元数据，这些数据在项目团队审查后获得批准。GraalVM的Gradle插件会自动从该项目查找可达性元数据，并在本地编译时添加它。有关更多信息，请参阅[https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support](https://graalvm.github.io/native-build-tools/0.9.18/gradle-plugin.html#metadata-support)。
- en: 'Testing AOT-generated code with the Java VM:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java VM测试AOT生成的代码：
- en: Since natively compiling a Spring Boot application takes a few minutes, an interesting
    alternative can be to try out the initialization code generated by the Spring
    AOT engine on the Java VM. Normally the AOT-generated code is ignored when using
    a Java VM, but this can be changed by setting the system property `spring.aot.enabled`
    to `true`. This means that the normal reflection-based initialization of the application
    is replaced by executing the generated initialization code. This can be used as
    a quick verification that the generated initialization code works as expected.
    Another positive effect is that the application starts slightly faster.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于本地编译Spring Boot应用程序需要几分钟，一个有趣的替代方案是尝试在Java VM上运行Spring AOT引擎生成的初始化代码。通常，在使用Java
    VM时，会忽略AOT生成的代码，但可以通过将系统属性`spring.aot.enabled`设置为`true`来改变这一点。这意味着应用程序的正常基于反射的初始化被替换为执行生成的初始化代码。这可以用作快速验证生成的初始化代码是否按预期工作。另一个积极的影响是应用程序启动速度略有提高。
- en: 'Providing custom hints:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供自定义提示：
- en: If an application requires custom reachability metadata for the GraalVM Native
    Image compiler to create a Native Image, they can be provided as JSON files as
    described in the *Introducing the GraalVM project* section. Spring provides an
    alternative to the JSON files by either using an annotation named `@RegisterReflectionForBinding`
    or implementing the `RuntimeHintsRegistrar` interface in a class, which can be
    activated by using the `@ImportRuntimeHints` annotation. The `RegisterReflectionForBinding`
    annotation is easier to use, but implementing the `RuntimeHintsRegistrar` interface
    gives full control of the hints specified.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果应用程序需要为GraalVM Native Image编译器创建原生图像而自定义可达性元数据，它们可以按照*介绍GraalVM项目*部分中所述的JSON文件提供。Spring通过使用名为`@RegisterReflectionForBinding`的注解或在类中实现`RuntimeHintsRegistrar`接口来提供JSON文件的替代方案，该接口可以通过使用`@ImportRuntimeHints`注解激活。`RegisterReflectionForBinding`注解更容易使用，但实现`RuntimeHintsRegistrar`接口提供了对指定的提示的完全控制。
- en: One important benefit of using Spring’s custom hints over using GraalVM JSON
    files is that the custom hints are type-safe and checked by the compiler. If an
    entity referred to in a GraalVM JSON file is renamed, but the JSON file is not
    updated, that metadata is lost. This will result in the GraalVM Native Image compiler
    failing to create a Native Image.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Spring的自定义提示而非GraalVM JSON文件的一个重要好处是，自定义提示是类型安全的，并且由编译器进行检查。如果GraalVM JSON文件中引用的实体被重命名，但JSON文件未更新，那么该元数据将丢失。这将导致GraalVM
    Native Image编译器无法创建原生镜像。
- en: When using custom hints, the source code will not even compile; typically, the
    IDE will complain as soon as the entity is renamed that the custom hint is no
    longer valid.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用自定义提示时，源代码甚至无法编译；通常，当实体被重命名时，IDE会抱怨自定义提示不再有效。
- en: 'Running native tests:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行原生测试：
- en: 'Even though testing AOT-generated code with the Java VM can give a quick indication
    of whether the native compilation will work, we still need to create the Native
    Image of the application to test it fully. A feedback loop based on creating a
    Native Image, starting the application, and finally running some tests by hand
    is very slow and error-prone. A compelling alternative to this process is to run
    **native tests**, where Spring’s Gradle plugin automatically will create a Native
    Image and then run JUnit tests defined in the application’s project using the
    Native Image. This still will take time due to the native compilation, but the
    process is fully automated and repeatable. After ensuring the native tests run
    as expected, they can be placed in a CI build pipeline for automated execution.
    Native tests can be started using Gradle with this command:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管使用Java VM测试AOT生成的代码可以快速指示原生编译是否可行，但我们仍然需要创建应用程序的原生镜像以进行全面测试。基于创建原生镜像、启动应用程序以及最后手动运行一些测试的反馈循环非常慢且容易出错。与此过程相比的一个有吸引力的替代方案是运行**原生测试**，其中Spring的Gradle插件将自动创建原生镜像，然后使用原生镜像运行应用程序项目中定义的JUnit测试。这仍然会因为原生编译而花费时间，但整个过程是全自动且可重复的。在确保原生测试按预期运行后，它们可以被放入CI构建管道以进行自动化执行。可以使用以下命令使用Gradle启动原生测试：
- en: '[PRE0]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using GraalVM’s tracing agent:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GraalVM的跟踪代理：
- en: If it turns out to be hard to determine what reachability metadata and/or custom
    hints are required to create a working Native Image for an application, GraalVM’s
    tracing agent can help out. If the tracing agent is enabled when running the application
    in the Java VM, it can gather the required reachability metadata based on how
    the application uses reflection, resources, and proxies. This is specifically
    useful if run together with JUnit tests since gathering the required reachability
    metadata will be automated and repeatable.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果确定需要创建一个可工作的原生镜像所需的可达性元数据和/或自定义提示很困难，GraalVM的跟踪代理可以帮助。如果在Java VM中运行应用程序时启用了跟踪代理，它可以根据应用程序如何使用反射、资源和代理来收集所需的可达性元数据。如果与JUnit测试一起运行，这特别有用，因为收集所需的可达性元数据将自动化且可重复。
- en: With the tooling introduced and explained for how to handle the main expected
    challenges, let’s see what changes are required in the source code to be able
    to natively compile the microservices.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在介绍了如何处理主要预期挑战的工具和解释之后，让我们看看为了能够原生编译微服务，源代码需要做出哪些更改。
- en: Changes in the source code
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码的更改
- en: 'Before compiling the Java source code in the microservices into native executable
    images, the source code needs to be updated a bit. To be able to natively compile
    the microservices, the following changes have been applied to the source code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在将微服务的Java源代码编译成原生可执行镜像之前，需要更新源代码。为了能够原生编译微服务，以下更改已应用于源代码：
- en: The Gradle build files, `build.gradle`, have been updated by adding the GraalVM
    plugin, adjusting some dependencies, and configuring the `bootBuildImage` command.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加GraalVM插件、调整一些依赖项和配置`bootBuildImage`命令，已更新Gradle构建文件`build.gradle`。
- en: Required reachability metadata and custom hints have been added.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加所需的可达性元数据和自定义提示。
- en: Build time property files have been added to ensure that required Spring beans
    are reachable during the AOT processing at build time.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加构建时间属性文件，以确保在构建时AOT处理期间所需的Spring bean是可达的。
- en: Some properties used at runtime have been added to the `config-repo` to make
    the natively compiled microservices operate successfully.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已将一些在运行时使用的属性添加到`config-repo`中，以便原生编译的微服务能够成功运行。
- en: The configuration to be able to run the GraalVM Native Image tracing agent has
    been added.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加配置以能够运行 GraalVM 原生镜像跟踪代理。
- en: The verification script, `test-em-all.bash`, has been updated since the Docker
    images no longer include the `curl` command.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Docker 镜像不再包含 `curl` 命令，验证脚本 `test-em-all.bash` 已被更新。
- en: Native tests have been disabled using the annotation `@DisabledInNativeImage`
    at the class level as described in the *Running native tests* section.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 *运行原生测试* 部分所述，使用 `@DisabledInNativeImage` 注解在类级别禁用了原生测试。
- en: Two new Docker Compose files for using the Docker images containing the Native
    Images have been added.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了两个新的 Docker Compose 文件，用于使用包含原生镜像的 Docker 镜像。
- en: 'A system property has been added to the microservices’ `Dockerfile` to simplify
    toggling AOT mode. The `ENVIRONMENT` command has been updated to disable AOT mode
    when run with the Java VM. It looks like this:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已在微服务的 `Dockerfile` 中添加一个系统属性，以简化切换 AOT 模式。`ENVIRONMENT` 命令已更新，当与 Java VM 一起运行时将禁用
    AOT 模式。它看起来像这样：
- en: '[PRE1]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that it doesn’t work to specify `spring.aot.enabled` as an environment
    variable or in a property file; it has to be set as a system property on the `java`
    command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将 `spring.aot.enabled` 指定为一个环境变量或在属性文件中是不起作用的；它必须作为 `java` 命令上的系统属性来设置。
- en: Let’s go through the changes one by one and start with changes applied to the
    build files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些更改，并从应用于构建文件的更改开始。
- en: Updates to the Gradle build files
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gradle 构建文件的更新
- en: The changes described in this section have been applied to the `build.gradle`
    files in each microservice project unless stated otherwise.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的更改已应用于每个微服务项目的 `build.gradle` 文件，除非另有说明。
- en: 'The following updates have been applied:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些已应用的更新：
- en: 'To enable Spring AOT tasks, the GraalVM plugin has been added:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了启用 Spring AOT 任务，已添加 GraalVM 插件：
- en: '[PRE2]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `bootBuildImage` task is configured to specify the name of the Docker image
    that is created. The same naming conventions are used as in earlier chapters,
    but the name of the image is prefixed with `native-` to separate it from the existing
    Docker images. Also, a Docker image for the builder that supports `arm64`, `dashaun/builder:tiny`,
    is specified. For the `product` microservice, the configuration looks like this:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootBuildImage` 任务被配置为指定创建的 Docker 镜像的名称。与早期章节中使用的命名约定相同，但镜像名称前缀为 `native-`
    以区分现有的 Docker 镜像。此外，还指定了一个支持 `arm64`、`dashaun/builder:tiny` 的构建器 Docker 镜像。对于
    `product` 微服务，配置如下：'
- en: '[PRE3]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To get around some problems with native compilation, Spring Boot has been upgraded
    from v3.0.4, as used in the other chapters, to v3.0.5\. For the same reason, `springdoc-openapi`
    has been upgraded from v2.0.2 to v2.1.0.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了解决原生编译中的一些问题，Spring Boot 已从其他章节中使用的 v3.0.4 升级到 v3.0.5。出于相同的原因，`springdoc-openapi`
    已从 v2.0.2 升级到 v2.1.0。
- en: Due to the issue described at [https://github.com/spring-projects/spring-boot/issues/33238](https://github.com/spring-projects/spring-boot/issues/33238),
    the `jar` task is no longer disabled.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 [https://github.com/spring-projects/spring-boot/issues/33238](https://github.com/spring-projects/spring-boot/issues/33238)
    中描述的问题，`jar` 任务不再被禁用。
- en: To recap why the `jar` task was disabled, see the *Implementing our API* section
    in *Chapter 3*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要回顾为什么禁用了 `jar` 任务，请参阅 *第 3 章* 中的 *实现我们的 API* 部分。
- en: These are all the changes required for the build files. In the next section,
    we will learn about how we need to help the native compiler to compile our source
    code in some cases.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是构建文件所需的所有更改。在下一节中，我们将了解在某些情况下我们需要如何帮助原生编译器编译我们的源代码。
- en: Providing reachability metadata and custom hints
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供可达性元数据和自定义提示
- en: There are a few cases in the source code where the GraalVM native compiler needs
    help to be able to compile the source code correctly. The first case is the JSON-based
    APIs and messages that the microservices use. The JSON parser, Jackson, must be
    able to create Java objects based on the JSON documents that the microservices
    receive. Jackson uses reflection to perform this work, and we need to tell the
    native compiler about the classes to which Jackson will apply reflection.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在源代码中，有几个地方 GraalVM 原生编译器需要帮助才能正确编译源代码。第一个情况是微服务使用的基于 JSON 的 API 和消息。JSON 解析器
    Jackson 必须能够根据微服务接收的 JSON 文档创建 Java 对象。Jackson 使用反射来完成这项工作，我们需要告诉原生编译器 Jackson
    将应用反射的类。
- en: 'For example, a native hint for the `Product` class looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Product` 类的原生提示如下所示：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All necessary custom hint annotations have been added to each microservice’s
    main class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有必要的自定义提示注解都已添加到每个微服务的主类中。
- en: 'When this chapter was written, the Resilience4J annotations did not work properly
    when natively compiled. In issue `#1882`, a solution for this problem is proposed
    by providing an implementation of the `RuntimeHintsRegistrar` interface. For details,
    see [https://github.com/resilience4j/resilience4j/issues/1882](https://github.com/resilience4j/resilience4j/issues/1882).
    This solution has been applied to the `NativeHintsConfiguration` class in the
    `product-service` project. The most central parts of the class look like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写本章时，Resilience4J注解在原生编译时无法正常工作。在问题`#1882`中，通过提供一个`RuntimeHintsRegistrar`接口的实现来提出了解决这个问题的方案。有关详细信息，请参阅[https://github.com/resilience4j/resilience4j/issues/1882](https://github.com/resilience4j/resilience4j/issues/1882)。此方案已应用于`product-service`项目中的`NativeHintsConfiguration`类。该类最核心的部分如下：
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the source code above, we can see that hints are registered for the three
    annotations used in the `product-composite` microservice, the circuit breaker,
    retry, and time limiter. The class also provides the necessary configuration by
    importing itself using the `ImportRuntimeHints` annotation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的源代码中，我们可以看到为`product-composite`微服务中使用的三个注解注册了提示，即断路器、重试和时间限制器。该类还通过使用`ImportRuntimeHints`注解导入自身来提供必要的配置。
- en: 'A final corner case is that we must provide reachability metadata for Resilience4J’s
    use of reflection in the declaration of the `retry` mechanism. The configuration
    looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最终的角落案例是我们必须为Resilience4J在`retry`机制声明中使用反射提供可达性元数据。配置看起来是这样的：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This configuration will enable the `retry` mechanism to retry errors of type
    `InternalServerError`. To let the GraalVM Native Image compiler know that reflection
    must be enabled for this class, the third way of supplying reachability metadata
    has been used: by providing a GraalVM config file. See `src/main/resources/META-INF/Native
    Image/reflect-config.json` in the `product-composite` project.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将启用`retry`机制重试类型为`InternalServerError`的错误。为了让GraalVM Native Image编译器知道必须为此类启用反射，已经使用了提供可达性元数据的第三种方式：通过提供GraalVM配置文件。请参阅`product-composite`项目中的`src/main/resources/META-INF/Native
    Image/reflect-config.json`。
- en: We now know how to provide metadata and custom hints for our own source code.
    Next, we will learn how we can ensure that Spring beans required at runtime also
    exist at build time so that the AOT processing can introspect them and generate
    proper AOT code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何为我们自己的源代码提供元数据和自定义提示。接下来，我们将学习如何确保在构建时也存在的运行时所需的Spring beans，以便AOT处理可以内省它们并生成适当的AOT代码。
- en: Enabling Spring beans at build time in application.yml files
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`application.yml`文件中启用构建时的Spring beans
- en: As mentioned above, due to the closed-world assumption that the static analysis
    uses at build time, all Spring beans required at runtime must be reachable at
    build time. Otherwise, they cannot be activated at runtime. Given that they are
    reachable at build time, they can be configured at runtime. To summarize, this
    means that if you are using Spring beans that are only created if some profiles
    are set or if some conditions are met (using the `@Profile` or `@ConditionalOnProperty`
    annotations), you must ensure that these profiles and conditions are met at build
    time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，由于静态分析在构建时使用的封闭世界假设，所有运行时所需的Spring beans必须在构建时可达。否则，它们不能在运行时激活。鉴于它们在构建时可达，它们可以在运行时进行配置。总结来说，这意味着如果你正在使用仅在设置某些配置文件或满足某些条件（使用`@Profile`或`@ConditionalOnProperty`注解）时创建的Spring
    beans，你必须确保这些配置文件和条件在构建时得到满足。
- en: 'For example, the possibility to specify a separate management port at runtime
    when using a natively compiled microservice is only possible if the management
    port was set to a random port (different from the standard port) at build time.
    Therefore, each microservice has an `application.yml` file in its `src/main/resources`
    folder that specifies:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用原生编译的微服务时，在运行时指定单独的管理端口的可能性仅当在构建时将管理端口设置为随机端口（不同于标准端口）时才可行。因此，每个微服务在其`src/main/resources`文件夹中都有一个`application.yml`文件，该文件指定：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this specified at build time, when the Native Image is created, the management
    port can be set to any value at runtime using property files in the `config-repo`
    folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时指定此配置后，当创建Native Image时，可以在运行时使用`config-repo`文件夹中的属性文件将管理端口设置为任何值。
- en: 'Below is a list of all properties set at build time in the `application.yml`
    files to avoid these types of problems for various Spring beans used by the four
    microservices:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有在 `application.yml` 文件中设置的构建时属性列表，以避免各种 Spring 微服务使用时出现这些问题：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As reported in issue `#2255`, the Swagger UI does not display the **Authorize**
    button when natively compiled. See [https://github.com/springdoc/springdoc-openapi/issues/2255](https://github.com/springdoc/springdoc-openapi/issues/2255).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 `#2255` 号问题所述，当原生编译时，Swagger UI 不显示 **授权** 按钮。请参阅 [https://github.com/springdoc/springdoc-openapi/issues/2255](https://github.com/springdoc/springdoc-openapi/issues/2255)。
- en: There can also exist cases where natively compiled microservices also require
    slightly different configurations at runtime; this will be covered in the next
    section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在原生编译的微服务在运行时也需要略微不同的配置的情况；这将在下一节中介绍。
- en: Updated runtime properties
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新的运行时属性
- en: 'In one case, a runtime property also needs to be updated when using natively
    compiled images. That is the connection string for the MySQL database used by
    the `review` microservice. Since not all character sets are represented in the
    Native Image by default, we must specify one as available in the Native Image.
    We will use the UTF-8 character set. This is done for all MySQL connection properties
    in the review config file `config-repo/review.yml`. It looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在一种情况下，当使用原生编译的图像时，还需要更新运行时属性。这是 `review` 微服务使用的 MySQL 数据库的连接字符串。由于默认情况下 Native
    Image 并不表示所有字符集，我们必须指定一个在 Native Image 中可用的字符集。我们将使用 UTF-8 字符集。这是在 `review` 配置文件
    `config-repo/review.yml` 中所有 MySQL 连接属性中完成的。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the required changes of properties both at build time and runtime covered,
    let’s learn how to configure the GraalVM Native Image tracing agent.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时间和运行时对所需的属性更改都覆盖后，让我们学习如何配置 GraalVM 原生图像跟踪代理。
- en: Configuration of the GraalVM Native Image tracing agent
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraalVM 原生图像跟踪代理的配置
- en: In cases where it is hard to determine what reachability metadata and/or custom
    hints are required, we can use the GraalVM Native Image tracing agent. As previously
    mentioned, it can, at runtime, detect the usage of reflection, resources, and
    proxies and create the required reachability metadata based on that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在难以确定所需的可达性元数据和/或自定义提示的情况下，我们可以使用 GraalVM 原生图像跟踪代理。如前所述，它可以在运行时检测反射、资源和代理的使用，并根据这些信息创建所需的可达性元数据。
- en: 'To enable the tracing agent to observe the execution of JUnit tests, the following
    `jvmArgs` can be added to the `build.gradle` file in the `test` section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用跟踪代理以观察 JUnit 测试的执行，可以将以下 `jvmArgs` 添加到 `test` 部分的 `build.gradle` 文件中：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the tracing agent is not required to make native compilation work for
    the microservices in this book, this configuration is commented out in the build
    files.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于跟踪代理对于本书中的微服务来说不是必需的，因此该配置在构建文件中被注释掉了。
- en: The parameter `Native Image-agent=access-filter-file` specifies a file listing
    Java packages and classes that the tracing agent should exclude, typically test-related
    classes that we have no use for at runtime.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `Native Image-agent=access-filter-file` 指定了一个文件，列出了跟踪代理应排除的 Java 包和类，通常是我们在运行时没有用到的与测试相关的类。
- en: 'For example, for the `product` microservice, the file `src/test/resources/access-filter.json`
    looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 `product` 微服务，文件 `src/test/resources/access-filter.json` 看起来是这样的：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The folder specified by the `config-output-dir` parameter will contain the generated
    configuration files. The specified folder, `src/main/resources/META-INF/Native
    Image`, is where the GraalVM native compiler looks for reachability metadata.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `config-output-dir` 参数指定的文件夹将包含生成的配置文件。指定的文件夹，`src/main/resources/META-INF/Native
    Image`，是 GraalVM 原生编译器查找可达性元数据的地方。
- en: Finally, let’s learn how the verification script has been adopted to be able
    to test the Native Images.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们学习验证脚本是如何被采用以便能够测试原生图像的。
- en: Updates to the test-em-all.bash verification script
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`test-em-all.bash` 验证脚本的更新'
- en: In the previous chapters, `eclipse-temurin` was used as the base image for the
    Docker images. The verification script, `test-em-all.bash`, uses the `curl` command
    that comes with that base image for running circuit breaker tests inside the `product-composite`
    container.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，`eclipse-temurin` 被用作 Docker 镜像的基础镜像。验证脚本 `test-em-all.bash` 使用该基础镜像中包含的
    `curl` 命令在 `product-composite` 容器内运行断路器测试。
- en: The verification script runs the `curl` command inside the `product-composite`
    container since the endpoints used to verify the functionality of the circuit
    breaker are not exposed outside of the internal network in Docker.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 验证脚本在`product-composite`容器内运行`curl`命令，因为用于验证断路器功能的应用程序端点在Docker内部网络之外没有暴露。
- en: With natively compiled microservices, the Docker image will no longer contain
    utility tools like the `curl` command. To overcome this problem, the `curl` commands
    are executed from the `auth-server`'s container, whose Docker image still is based
    on `eclipse-temurin` and therefore contains the required `curl` command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原生编译的微服务，Docker图像将不再包含像`curl`命令这样的实用工具。为了克服这个问题，`curl`命令是从`auth-server`的容器中执行的，其Docker图像仍然基于`eclipse-temurin`，因此包含所需的`curl`命令。
- en: Since the tests of the circuit breaker are executed from the `auth-server`,
    the hostname, `localhost`, is replaced with `product-composite`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断路器的测试是从`auth-server`执行的，因此主机名`localhost`被替换为`product-composite`。
- en: For details, see the verification script `test-em-all.bash`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅验证脚本`test-em-all.bash`。
- en: With the required changes in the source code explained, let’s learn how to use
    the various tools mentioned in the previous sections to test and create Native
    Images for the microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释了源代码中所需更改后，让我们学习如何使用上一节中提到的各种工具来测试和为微服务创建原生图像。
- en: Testing and compiling Native Images
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和编译原生图像
- en: Now, it is time to try out the tools for testing and building Native Images!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候尝试测试和构建原生图像的工具了！
- en: 'The following tools will be covered in this section:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下工具：
- en: Running the tracing agent
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行跟踪代理
- en: Executing native tests
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行原生测试
- en: Creating a Native Image for the current OS
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前操作系统创建原生图像
- en: Creating a Native Image as a Docker image
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原生图像作为Docker图像创建
- en: Since the first three tools require that the GraalVM and its `Native Image`
    compiler are installed locally, we must install them first. Next, we will go through
    the tools one by one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前三个工具要求本地安装GraalVM及其`Native Image`编译器，我们必须首先安装它们。接下来，我们将逐一介绍这些工具。
- en: Installing GraalVM and its Native Image compiler
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装GraalVM及其原生图像编译器
- en: If you want to try out native tests, the tracing agent, or the native compiler
    without using Docker, you must first install the GraalVM JDK together with the
    Native Image compiler.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在不使用Docker的情况下尝试原生测试、跟踪代理或原生编译器，你必须首先安装GraalVM JDK及其原生图像编译器。
- en: 'It can be done by the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下步骤完成：
- en: 'To install GraalVM, **SDKman** ([https://sdkman.io](https://sdkman.io)) will
    be used. If not already installed, it can be installed with the following commands:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装GraalVM，将使用**SDKman** ([https://sdkman.io](https://sdkman.io))。如果尚未安装，可以使用以下命令安装：
- en: '[PRE12]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Verify that SDKman was installed correctly with the following command:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令验证SDKman是否正确安装：
- en: '[PRE13]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Expect it to return something like this:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期它会返回类似以下内容：
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On Linux, GraalVM’s Native Image compiler requires GCC to be installed. If
    you are running an Ubuntu instance under WSL 2 on Windows, you can install GCC
    with the required dependencies with the following command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux上，GraalVM的原生图像编译器需要安装GCC。如果你在Windows的WSL 2上运行Ubuntu实例，你可以使用以下命令安装GCC及其所需依赖项：
- en: '[PRE15]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now GraalVM can be installed. Version 22.3.1 for Java 17 is used in this book.
    It can be installed and set to the default Java version with the following commands:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以安装GraalVM了。本书使用Java 17的22.3.1版本。可以使用以下命令安装并设置为默认Java版本：
- en: '[PRE16]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, the Native Image compiler can be installed with the following command:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以使用以下命令安装原生图像编译器：
- en: '[PRE17]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To verify the installation, run the following commands:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证安装，请运行以下命令：
- en: '[PRE18]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Expect a response from the `java -version` command like:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期`java -version`命令的响应如下：
- en: '[PRE19]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the `gu list` command, expect:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`gu list`命令，预期：
- en: '[PRE20]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we are ready to try out the tools; let’s start with the tracing agent!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好尝试这些工具了；让我们从跟踪代理开始！
- en: Running the tracing agent
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行跟踪代理
- en: 'For the microservices in this book, the tracing agent is not required. But
    it can be of interest to see how to use it for other cases: if, for example, one
    of your own microservices will require help from the tracing agent to generate
    the required reachability metadata.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中的微服务，跟踪代理不是必需的。但了解如何在其他情况下使用它可能很有趣：例如，如果你的某个微服务需要跟踪代理的帮助来生成所需的可达性元数据。
- en: 'If you want to try out the tracing agent, you can do so with the following
    steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试跟踪代理，你可以按照以下步骤进行：
- en: Activate the `jvmArgs` parameter in the section of the `build.gradle` file for
    the selected microservice by removing the preceding comment characters `//`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所选微服务的`build.gradle`文件部分激活`jvmArgs`参数，通过移除前面的注释字符`//`。
- en: 'Run a `gradle test` command, in this case for the `product` service:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`gradle test`命令，在这种情况下为`product`服务：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a normal `gradle test` command, but to avoid running out of memory,
    we disable the use of the Gradle daemon. By default, the daemon is limited to
    using 512 MB for its heap, which is insufficient for the tracing agent in most
    cases.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个正常的`gradle test`命令，但为了避免内存不足，我们禁用了Gradle守护进程的使用。默认情况下，守护进程的堆大小限制为512 MB，这对于大多数情况中的跟踪代理来说是不够的。
- en: 'After the tests are complete, you should find the following files in the `microservices/product-service/src/main/resources/META-INF/Native
    Image` folder:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试完成后，你应该在`microservices/product-service/src/main/resources/META-INF/Native
    Image`文件夹中找到以下文件：
- en: '[PRE22]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After browsing through the generated files, wrap up by adding back the comment
    before the `jvmArgs` parameter in the build file to disable the tracing agent
    and remove the created files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览完生成的文件后，通过在构建文件中`jvmArgs`参数之前添加回注释来禁用跟踪代理并删除创建的文件。
- en: Next, we move on to how to use native tests!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续介绍如何使用原生测试！
- en: Running native tests
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行原生测试
- en: 'Running native tests can, as described earlier, be very useful for automating
    the process of finding issues with creating Native Images. Unfortunately, a couple
    of problems currently prevent us from using native tests with the microservices
    in this book:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，运行原生测试对于自动化查找创建原生图像的问题过程非常有用。不幸的是，目前有几个问题阻止我们在这本书的微服务中使用原生测试：
- en: Tests that use Testcontainers can’t be used with native tests.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Testcontainers的测试无法与原生测试一起使用。
- en: For details, see [https://github.com/spring-projects/spring-boot/issues/35663](https://github.com/spring-projects/spring-boot/issues/35663).
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅[https://github.com/spring-projects/spring-boot/issues/35663](https://github.com/spring-projects/spring-boot/issues/35663)。
- en: Tests that use Mockito cannot be used with native tests either.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mockito的测试也无法与原生测试一起使用。
- en: For details, see [https://github.com/spring-projects/spring-boot/issues/32195](https://github.com/spring-projects/spring-boot/issues/32195)
    and [https://github.com/mockito/mockito/issues/2435](https://github.com/mockito/mockito/issues/2435).
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅[https://github.com/spring-projects/spring-boot/issues/32195](https://github.com/spring-projects/spring-boot/issues/32195)和[https://github.com/mockito/mockito/issues/2435](https://github.com/mockito/mockito/issues/2435)。
- en: Therefore, all tests have been disabled using native tests using the annotation
    `@DisabledInNativeImage` at the class level. This means that we still can run
    the native test command; all Native Images will be created but no tests will currently
    be executed in the Native Images. As these problems are resolved, the `@DisabledInNativeImage`
    annotation can be removed step by step and more and more tests will be run by
    the native test command.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有测试都已被禁用，使用原生测试在类级别使用`@DisabledInNativeImage`注解。这意味着我们仍然可以运行原生测试命令；所有原生图像都将被创建，但在原生图像中目前不会执行任何测试。随着这些问题的解决，`@DisabledInNativeImage`注解可以逐步移除，并且越来越多的测试将由原生测试命令运行。
- en: 'To run the native tests on all four microservices, run the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要在所有四个微服务上运行原生测试，请运行以下命令：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To test a specific microservice, run a command like:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试特定的微服务，请运行类似以下命令的命令：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After each test of a microservice, the native testing tool creates a test report
    that looks like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个微服务的测试之后，原生测试工具会创建一个看起来像以下报告的测试报告：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As can be seen in the report above, currently all tests are skipped.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如上报告所示，目前所有测试都被跳过了。
- en: After covering the test agent and native tests, let’s see how we can create
    Native Images.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了测试代理和原生测试之后，让我们看看我们如何创建原生图像。
- en: Creating a Native Image for the current OS
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为当前操作系统创建原生图像
- en: The first option for creating a Native Image is to use Gradle’s `nativeImage`
    command. It will use the installed GraalVM `Native Image` compiler to create an
    executable file for the current OS and hardware architecture.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建原生图像的第一个选项是使用Gradle的`nativeImage`命令。它将使用已安装的GraalVM `Native Image`编译器为当前操作系统和硬件架构创建可执行文件。
- en: 'Since we will only test our microservices using Docker and Kubernetes, we will
    not use Native Images created by this command. But to try it out on the `product-composite`
    microservice, run the following commands:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只使用Docker和Kubernetes来测试我们的微服务，因此我们不会使用此命令创建的原生镜像。但为了在`product-composite`微服务上尝试它，请运行以下命令：
- en: 'Create the Native Image with the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建原生镜像：
- en: '[PRE26]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The executable file will be created in the `build/native/nativeCompile` folder
    with the name `product-composite-service`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可执行文件将创建在`build/native/nativeCompile`文件夹中，文件名为`product-composite-service`。
- en: 'The executable file can be inspected using the `file` command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可执行文件可以使用`file`命令进行检查：
- en: '[PRE27]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It will respond with something like:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将响应如下：
- en: '[PRE28]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `Mach-O` indicates that the file is compiled for macOS, and `arm64` indicates
    it is compiled for Apple silicon.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`Mach-O`表示文件是为macOS编译的，而`arm64`表示它是为Apple硅编译的。
- en: 'To try it out, we need to start up the resources it needs manually. In this
    case, it is only RabbitMQ that is required to make it start up successfully. Start
    it up with the following command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了尝试它，我们需要手动启动它所需的资源。在这种情况下，只需要RabbitMQ才能成功启动。使用以下命令启动它：
- en: '[PRE29]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Native Image can now be started in the terminal by specifying the same
    environment variables that are supplied in the `docker-compose` files:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以在终端中通过指定与`docker-compose`文件中提供的相同环境变量来启动原生镜像：
- en: '[PRE30]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It should start up quickly and print something like the following in the log
    output:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应该启动得很快，并在日志输出中打印如下内容：
- en: '[PRE31]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Try it out by calling its liveness probe:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用其存活探测来尝试它：
- en: '[PRE32]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Expect it to answer with:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期它会这样回答：
- en: '[PRE33]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Stop the execution by pressing *Ctrl* + *C* and stop the RabbitMQ container
    with the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *C*停止执行，并使用以下命令停止RabbitMQ容器：
- en: '[PRE34]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even though this is the fastest way to create a Native Image, it is not very
    useful for the scope of this book. Instead, it needs to be built for Linux and
    placed in a Docker container. Let’s jump into the next section and learn how to
    do that.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是创建原生镜像最快的方法，但它对本书的范围来说并不很有用。相反，它需要为Linux构建并放置在Docker容器中。让我们跳到下一节，学习如何做到这一点。
- en: Creating a Native Image as a Docker image
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将原生镜像作为Docker镜像创建
- en: 'Now, it is time to build Docker images containing Native Images of our microservices.
    Go through the following steps:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建包含我们微服务原生镜像的Docker镜像了。按照以下步骤进行：
- en: This is a very resource-demanding process. Therefore, first, ensure that Docker
    Desktop is allowed to consume at least 10 GB of memory to avoid out-of-memory
    faults.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个非常资源密集的过程。因此，首先，请确保Docker Desktop被允许至少消耗10 GB的内存，以避免内存不足错误。
- en: If a build fails with an error message that looks like `<container-name> exited
    with code 137`, you have run out of memory in Docker.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建失败，并显示类似`<container-name> exited with code 137`的错误消息，那么你在Docker中已经耗尽了内存。
- en: 'If your computer has less than 32 GB of memory, it could be a good idea to
    stop the `minikube` instance at this time to avoid running out of memory in the
    computer. Use the following command:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的计算机内存少于32 GB，此时停止`minikube`实例可能是个好主意，以避免在计算机中耗尽内存。使用以下命令：
- en: '[PRE35]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Ensure that the Docker client talks to Docker Desktop and not to the `minikube`
    instance:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Docker客户端与Docker Desktop通信，而不是与`minikube`实例通信：
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the following command to compile the `product` service:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来编译`product`服务：
- en: '[PRE37]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Expect it to take some time. The command will start a Docker container to perform
    the native compilation. The first time it runs, it will also download the GraalVM
    native compiler to be used in Docker, making the compilation time even longer.
    On my MacBook, the first compilation takes a few minutes, mainly depending on
    my network’s capacity; after that, it takes just around a minute or two.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期这个过程会花费一些时间。该命令将启动一个Docker容器以执行原生编译。第一次运行时，它还会下载用于Docker的GraalVM原生编译器，这使得编译时间更长。在我的MacBook上，第一次编译需要几分钟，主要取决于我的网络容量；之后，只需要大约一分钟左右。
- en: 'Expect a lot of output during the compilation, including all sorts of warning
    and error messages. A successful compilation ends with a log output like this:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编译过程中，预期会有大量的输出，包括各种警告和错误消息。成功的编译将以如下日志输出结束：
- en: '[PRE38]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Natively compile the three remaining microservices with the following commands:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使用原生编译剩余的三个微服务：
- en: '[PRE39]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To verify that the Docker images were successfully built, run the following
    command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证Docker镜像是否成功构建，请运行以下命令：
- en: '[PRE40]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Expect output like this:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_23_02.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成文本描述](img/B19825_23_02.png)'
- en: 'Figure 23.2: Docker images containing the natively compiled executables'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.2：包含本机编译可执行文件的Docker镜像
- en: Now that we’ve created the Docker images containing the natively compiled executables,
    we are ready to try them out! We will start with Docker Compose and, after that,
    try them out with Kubernetes.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已创建了包含本机编译可执行文件的Docker镜像，我们准备尝试它们！我们将从Docker Compose开始，然后尝试使用Kubernetes。
- en: Testing with Docker Compose
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行测试
- en: We are ready to try out the natively compiled microservices. To use the Docker
    images that contain the natively compiled microservices, two new Docker Compose
    files have been created, `docker-compose-native.yml` and `docker-compose-partitions-native.yml`.
    They are copies of `docker-compose.yml`, and `docker-compose-partitions.yml`,
    where the `build` option has been removed from the definitions of the microservices.
    Also, the names of the Docker images to use have been changed, so the ones we
    created in the previous section are used, with names that start with `native-`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备尝试使用本机编译的微服务。为了使用包含本机编译微服务的Docker镜像，已创建了两个新的Docker Compose文件，`docker-compose-native.yml`和`docker-compose-partitions-native.yml`。它们是`docker-compose.yml`和`docker-compose-partitions.yml`的副本，其中已从微服务的定义中移除了`build`选项。此外，已更改要使用的Docker镜像的名称，因此我们之前创建的镜像使用，名称以`native-`开头。
- en: In this chapter, we will only use `docker-compose-native.yml`.; feel free to
    try out `docker-compose-partitions-native.yml` on your own.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅使用`docker-compose-native.yml`；请随意尝试使用`docker-compose-partitions-native.yml`。
- en: 'We’ll first get a benchmark using the Java VM-based microservices to compare
    the startup times and initial memory consumption. We will run the following tests:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将使用基于Java VM的微服务获取基准，以比较启动时间和初始内存消耗。我们将运行以下测试：
- en: Use the Java VM-based microservices with AOT mode disabled.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已禁用AOT模式的基于Java VM的微服务。
- en: Use the Java VM-based microservices with AOT mode enabled.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已启用AOT模式的基于Java VM的微服务。
- en: Use the Docker images that contain the natively compiled microservices.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包含本机编译微服务的Docker镜像。
- en: 'To avoid port collisions, we first must stop the `minikube` instance with the
    following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免端口冲突，我们首先必须使用以下命令停止`minikube`实例：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Testing Java VM-based microservices with AOT mode disabled
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用AOT模式测试Java VM-based微服务
- en: 'We will start the tests by ignoring the AOT-generated code, starting the Java
    VM-based microservices as we did in the previous chapters. Run through the following
    commands to test the Java VM-based microservices:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过忽略AOT生成的代码，以与之前章节中相同的方式启动基于Java VM的微服务来开始测试。运行以下命令以测试基于Java VM的微服务：
- en: 'Start by compiling the source code and building the Java VM-based Docker images
    in Docker Desktop:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Docker Desktop中编译源代码并构建基于Java VM的Docker镜像：
- en: '[PRE42]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the default Docker Compose file for the Java VM-based microservices:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于Java VM的微服务的默认Docker Compose文件：
- en: '[PRE43]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Start all containers, except the microservices’ containers:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动所有容器，除了微服务的容器：
- en: '[PRE44]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Wait for the containers to start up until the CPU load goes down.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待容器启动，直到CPU负载下降。
- en: 'Start up the microservices using the Java VM:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Java VM启动微服务：
- en: '[PRE45]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Wait for the microservices to start up, again monitoring the CPU load.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待微服务启动，再次监控CPU负载。
- en: 'To find out how long time it took to start the microservices, we can look for
    a log output containing `: Started`. Run the following command:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要找出启动微服务所需的时间，我们可以查找包含`: Started`的日志输出。运行以下命令：'
- en: '[PRE46]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Expect an output like this:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B19825_23_03.png)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机屏幕截图，中等置信度自动生成描述](img/B19825_23_03.png)'
- en: 'Figure 23.3: Startup times for Java VM-based microservices'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图23.3：基于Java VM的微服务的启动时间
- en: In the output, we can see startup times varying from 5.5 to 7 seconds. Remember
    that all four microservice instances were started simultaneously, resulting in
    longer startup times compared to if they were started up one by one.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到启动时间从5.5秒到7秒不等。请记住，所有四个微服务实例是同时启动的，因此与逐个启动相比，启动时间更长。
- en: 'Run through the tests to verify that the system landscape works as expected:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以验证系统景观按预期工作：
- en: '[PRE47]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Expect the output we have seen in previous chapters from the tests:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期测试结果与之前章节中看到的结果相同：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B19825_23_04.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B19825_23_04.png)'
- en: 'Figure 23.4: Output from the test script'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 23.4：测试脚本的输出
- en: 'Finally, to find out how much memory is used after starting up and running
    the tests, run the following command:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了找出启动和运行测试后使用的内存量，运行以下命令：
- en: '[PRE48]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Expect a response like this:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期响应如下：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B19825_23_05.png)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机程序屏幕截图  描述自动生成，置信度中等](img/B19825_23_05.png)'
- en: 'Figure 23.5: Memory usage for Java VM-based microservices'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 23.5：基于 Java 虚拟机的微服务的内存使用情况
- en: From the preceding output, we can see that the microservices consume around
    240-310 MB.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到微服务消耗了大约 240-310 MB。
- en: 'Bring down the system landscape:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭系统景观：
- en: '[PRE49]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now we know how long the microservices take to start up without using the AOT-generated
    code; let’s test them in AOT mode.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在不使用 AOT 生成的代码的情况下微服务启动所需的时间；让我们在 AOT 模式下测试它们。
- en: Testing Java VM-based microservices with AOT mode enabled
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在启用 AOT 模式下测试基于 Java 虚拟机的微服务
- en: 'Now we will enable AOT mode, using the AOT-generated code to start the Java
    VM-based microservices. We expect them to start a bit faster in AOT mode. Run
    through the following commands:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将启用 AOT 模式，使用 AOT 生成的代码启动基于 Java 虚拟机的微服务。我们预计它们在 AOT 模式下启动会更快。运行以下命令：
- en: 'Start all containers, except the microservices’ containers:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动所有容器，除了微服务的容器：
- en: '[PRE50]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enable AOT mode by editing each microservice’s Dockerfile and set “`-Dspring.aot.enabled=true`"
    in the `ENVIRONMENT` command so it looks like this:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编辑每个微服务的 Dockerfile 启用 AOT 模式，并在 `ENVIRONMENT` 命令中设置“`-Dspring.aot.enabled=true`"，使其看起来像这样：
- en: '[PRE51]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Rebuild the microservices:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建微服务：
- en: '[PRE52]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Start the microservices:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动微服务：
- en: '[PRE53]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Check AOT mode:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 AOT 模式：
- en: '[PRE54]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Expect four lines containing “`Starting AOT-processed`".
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期包含“`Starting AOT-processed`"的四行输出。
- en: 'Check the startup times:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查启动时间：
- en: '[PRE55]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Expect the same type of output as when running without AOT mode in the section
    above but with slightly shorter startup times. In my case, the startup times vary
    from 4.5 to 5.5 seconds. Compared to the normal Java VM startup times, this is
    1 to 1.5 seconds faster.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出与上面未启用 AOT 模式时的输出相同，但启动时间略短。在我的情况下，启动时间从 4.5 秒到 5.5 秒不等。与正常 Java 虚拟机启动时间相比，这快了
    1 到 1.5 秒。
- en: 'Run `test-em-all.bash`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '运行 `test-em-all.bash`:'
- en: '[PRE56]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Expect an output like when running without AOT mode in the section above.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出与上面未启用 AOT 模式时的输出相同。
- en: Revert the changes in the Dockerfiles and perform a rebuild of the Docker images
    to disable AOT mode.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中撤销更改并重新构建 Docker 镜像以禁用 AOT 模式。
- en: 'Bring down the system landscape:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭系统景观：
- en: '[PRE57]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this test, we verified that Java VM-based microservices start up a bit faster
    using the AOT-generated code. Now it’s time to try out the natively compiled microservices.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们验证了使用 AOT 生成的代码，基于 Java 虚拟机的微服务启动速度略有提升。现在，是时候尝试原生编译的微服务了。
- en: Testing natively compiled microservices
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试原生编译的微服务
- en: 'Now, we are ready to repeat the same procedure, but this time using the Docker
    images with the natively compiled microservices:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备重复相同的程序，但这次使用带有原生编译微服务的 Docker 镜像：
- en: 'Change to the new Docker Compose file:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到新的 Docker Compose 文件：
- en: '[PRE58]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Start all containers, except for the microservices’ containers:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动所有容器，除了微服务的容器：
- en: '[PRE59]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Wait for the containers to start up until the CPU load goes down.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待容器启动，直到 CPU 负载下降。
- en: 'Start up the microservices using the Java VM:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Java 虚拟机启动微服务：
- en: '[PRE60]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Wait for the microservices to start up, again monitoring the CPU load.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等待微服务启动，再次监控 CPU 负载。
- en: 'To find out how long time it took to start the natively compiled microservices,
    run the same command we ran previously:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找出原生编译的微服务启动所需的时间，运行之前运行的相同命令：
- en: '[PRE61]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Expect output like this:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![A screen shot of a computer  Description automatically generated with medium
    confidence](img/B19825_23_06.png)'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机屏幕截图  描述自动生成，置信度中等](img/B19825_23_06.png)'
- en: 'Figure 23.6: Startup times for natively compiled microservices'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 23.6：原生编译微服务的启动时间
- en: In the above output, we can see startup times varying from 0.2-0.5 seconds.
    Considering that all microservices instances were started up at the same time,
    these are rather impressive figures compared to the 5.5 to 7 seconds it took for
    the Java VM-based tests!
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到启动时间从 0.2-0.5 秒不等。考虑到所有微服务实例都是同时启动的，与基于 Java VM 的测试需要 5.5 到 7 秒相比，这些数字相当令人印象深刻！
- en: 'Run through the tests to verify that the system landscape works as expected:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以验证系统景观按预期工作：
- en: '[PRE62]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Expect the same output as from the test above using the Java VM-based Docker
    images.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期与上述测试相同的输出，使用基于 Java VM 的 Docker 镜像。
- en: 'Finally, to find out how much memory is used after starting up and running
    the tests, run the following command:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了了解启动和运行测试后使用的内存量，请运行以下命令：
- en: '[PRE63]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Expect a response like this:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期如下响应：
- en: '![A screenshot of a computer program  Description automatically generated with
    medium confidence](img/B19825_23_07.png)'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机程序截图，描述自动生成，置信度中等](img/B19825_23_07.png)'
- en: 'Figure 23.7: Memory usage for natively compiled microservices'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 23.7：原生编译微服务的内存使用情况
- en: From the preceding output, we can see that the microservices consume around
    80-130 MB. Again, this is a noticeable reduction compared to the 240-310 MB that
    the Java VM containers used!
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到微服务消耗了大约 80-130 MB。再次强调，这与 Java VM 容器使用的 240-310 MB 相比，这是一个明显的减少！
- en: 'Bring down the system landscape:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭系统景观：
- en: '[PRE64]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: To get a better understanding of both the memory and CPU consumption of the
    natively compiled microservices, a more realistic load test needs to be performed,
    but that is beyond the scope of this book.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解原生编译微服务的内存和 CPU 消耗，需要进行更真实的负载测试，但这超出了本书的范围。
- en: After seeing how much faster and less memory-consuming the natively compiled
    microservices are when starting up compared to Java VM-based alternatives, let’s
    see how we can run them using Kubernetes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到原生编译的微服务在启动时比基于 Java VM 的替代方案更快、内存消耗更少之后，让我们看看如何使用 Kubernetes 运行它们。
- en: Testing with Kubernetes
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 进行测试
- en: 'To be able to deploy the natively compiled microservices in Kubernetes, a new
    environment Helm chart has been added, which has been configured to use the Docker
    images that contain the natively compiled microservices. The Helm charts can be
    found in the following folders:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在 Kubernetes 上部署原生编译的微服务，已添加了一个新的环境 Helm 图表，该图表已配置为使用包含原生编译微服务的 Docker 镜像。Helm
    图表可以在以下文件夹中找到：
- en: '[PRE65]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Another thing we need to consider before deploying the natively compiled microservices
    to Kubernetes is how to provision the Docker images. We don’t want to run the
    lengthy native compilation commands again to get new Docker images created in
    the `minikube` instance. If we used a Docker registry in this book, we could have
    pushed the images to the registry, but we haven’t. Instead, we will extract the
    Docker images from Docker Desktop and import them into the `minikube` instance,
    as a workaround for not using a Docker registry.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在将原生编译的微服务部署到 Kubernetes 之前，我们需要考虑的另一件事是如何提供 Docker 镜像。我们不希望再次运行耗时的原生编译命令来在
    `minikube` 实例中创建新的 Docker 镜像。如果我们在这本书中使用 Docker 仓库，我们可以将镜像推送到仓库，但我们没有。相反，我们将从
    Docker Desktop 中提取 Docker 镜像并将它们导入到 `minikube` 实例中，作为不使用 Docker 仓库的替代方案。
- en: 'Move the Docker images from Docker Desktop to the `minikube` instance with
    the following commands:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将 Docker 镜像从 Docker Desktop 移动到 `minikube` 实例：
- en: 'Export the Docker images from Docker Desktop:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Docker Desktop 导出 Docker 镜像：
- en: '[PRE66]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Start up the `minikube` instance again:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动 `minikube` 实例：
- en: '[PRE67]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In a separate terminal, start the `minikube tunnel` command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端中，启动 `minikube tunnel` 命令：
- en: '[PRE68]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that this command requires that your user has `sudo` privileges and that
    you enter your password during startup. It can take a couple of seconds before
    the command asks for the password, so it is easy to miss!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此命令需要您的用户具有 `sudo` 权限，并且在启动时需要输入您的密码。在命令请求密码之前可能需要几秒钟，所以很容易错过！
- en: 'Import the Docker images into the `minikube` instance:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Docker 镜像导入到 `minikube` 实例：
- en: '[PRE69]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, delete the exported `.tar` files:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，删除导出的 `.tar` 文件：
- en: '[PRE70]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Building, deploying, and verifying the deployment on Kubernetes is done in
    the same way as in the previous chapters. Run the following commands:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上构建、部署和验证部署的方式与前面的章节相同。运行以下命令：
- en: 'Build the Docker image for the `auth-server` with the following command:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建 `auth-server` 的 Docker 镜像：
- en: '[PRE71]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Recreate the namespace, `hands-on`, and set it as the default Namespace:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建命名空间`hands-on`并将其设置为默认命名空间：
- en: '[PRE72]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Resolve the Helm chart dependencies with the following commands.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令解决Helm图表的依赖项。
- en: 'First, we update the dependencies in the `components` folder:'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们更新`components`文件夹中的依赖项：
- en: '[PRE73]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we update the dependencies in the `environments` folder:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们更新`environments`文件夹中的依赖项：
- en: '[PRE74]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We are now ready to deploy the system landscape using Helm. Run the following
    command and wait for all the deployments to complete:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已准备好使用Helm部署系统景观。运行以下命令并等待所有部署完成：
- en: '[PRE75]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the previous chapters, we used the `helm install` command. The `helm upgrade
    -install` command used here is a better alternative for scripting since it performs
    an `insert` if the chart is not installed, but an `upgrade` if the chart is already
    installed. It’s a bit like an `upsert` command in the relational database world.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了`helm install`命令。这里使用的`helm upgrade -install`命令是一个更好的脚本选择，因为它在图表未安装时执行`insert`操作，但如果图表已经安装，则执行`upgrade`操作。这在关系数据库世界中有点类似于`upsert`命令。
- en: 'Run the normal tests to verify the deployment with the following command:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行正常测试以验证部署：
- en: '[PRE76]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Expect the output to be like what we’ve already seen in the previous tests.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出将与我们在之前的测试中看到的内容相似。
- en: 'Check the startup time for one of the Pods. To measure the actual startup time
    for a specific microservice, let’s delete it and then measure the time it takes
    to start up once Kubernetes recreates it:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查一个Pod的启动时间。为了测量特定微服务的实际启动时间，让我们删除它，然后测量Kubernetes重新创建它所需的启动时间：
- en: '[PRE77]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Expect a response like this:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期会收到如下响应：
- en: '![](img/B19825_23_08.png)'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片 B19825_23_08.png](img/B19825_23_08.png)'
- en: 'Figure 23.8: Startup time when running as a Pod in Kubernetes'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图23.8：在Kubernetes中以Pod运行时的启动时间
- en: Expect a startup time around what we noticed when using Docker Compose, 0.4
    seconds in the example above. Since we also start an Istio proxy as a sidecar,
    there might be some extra delay.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预计启动时间将与我们在使用Docker Compose时观察到的时间相近，例如上面的示例中的0.4秒。由于我们还在启动一个作为sidecar的Istio代理，可能会有一些额外的延迟。
- en: 'Check the Docker images used with the following command:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查使用的Docker镜像：
- en: '[PRE78]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Expect the following response:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期会收到以下响应：
- en: '![A screenshot of a computer program  Description automatically generated with
    low confidence](img/B19825_23_09.png)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![计算机程序截图  描述由低置信度自动生成](img/B19825_23_09.png)'
- en: 'Figure 23.9: Docker images with natively compiled code'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图23.9：具有本地编译代码的Docker镜像
- en: From the output, we can see that all containers, except the `auth-server`, use
    Docker images with the same prefix `native`, meaning we are running natively compiled
    executables inside the Docker containers.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到除了`auth-server`之外的所有容器都使用了具有相同前缀`native`的Docker镜像，这意味着我们在Docker容器内运行的是本地编译的可执行文件。
- en: This completes this chapter on using Spring’s AOT engine and the GraalVM project
    to create natively compiled executables for our microservices.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这完成了本章关于使用Spring的AOT引擎和GraalVM项目为我们的微服务创建本地编译的可执行文件的内容。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the new *Spring AOT engine* and underlying
    *GraalVM* project, along with its Native Image compiler. After declaring GraalVM’s
    plugin in the build file and providing the Native Image compiler with some reachability
    metadata and custom hints, it can be used to create Native Images. Spring Boot’s
    Gradle task `buildBootImage` packages these standalone executable files into ready-to-use
    Docker images.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了新的*Spring AOT引擎*及其底层的*GraalVM*项目，以及其Native Image编译器。在构建文件中声明GraalVM的插件，并为Native
    Image编译器提供一些可达性元数据和自定义提示后，它可以用来创建Native Image。Spring Boot的Gradle任务`buildBootImage`将这些独立的可执行文件打包成可用的Docker镜像。
- en: The main benefit of compiling Java-based source code into Native Images is significantly
    faster startup time and less memory usage. In a test where we started up the microservice
    instances at the same time, we observed 0.2-0.5 seconds startup times for the
    natively compiled microservices, compared with the 5.5 to 7 seconds required for
    the Java VM-based microservices for the same test. Also, the natively compiled
    microservices required less than half of the memory compared to the Java VM-based
    microservices after running through the verifications in the script, `test-em-all.bash`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 将基于Java的源代码编译成原生图像的主要好处是显著更快的启动时间和更少的内存使用。在一个同时启动微服务实例的测试中，我们观察到原生编译的微服务启动时间为0.2-0.5秒，而基于Java
    VM的微服务需要5.5到7秒才能完成相同的测试。此外，在通过脚本`test-em-all.bash`进行验证后，原生编译的微服务所需的内存比基于Java VM的微服务少一半。
- en: Most libraries and frameworks in this book already support GraalVM’s `Native
    Image` compiler. For those that don’t, *GraalVM Reachability Metadata Repository*
    can help out by providing reachability metadata from the community. GraalVM’s
    build plugin can automatically detect and download reachability metadata from
    this repository. As a last resort, the GraalVM Native Image *tracing agent* can
    be used to create reachability metadata to help the native compiler. The tracing
    agent is configured to run together with the existing JUnit tests, creating reachability
    metadata based on the execution of the tests.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数库和框架已经支持GraalVM的`Native Image`编译器。对于那些不支持的情况，*GraalVM Reachability Metadata
    Repository*可以通过提供社区中的可达性元数据来提供帮助。GraalVM的构建插件可以自动检测并从该存储库下载可达性元数据。作为最后的手段，可以使用GraalVM
    Native Image的*跟踪代理*来创建可达性元数据，以帮助原生编译器。跟踪代理被配置为与现有的JUnit测试一起运行，根据测试的执行创建可达性元数据。
- en: If we find it problematic to get the Native Image creation to work properly
    for a specific Spring feature, we can reach out to the *Spring AOT Smoke Tests*
    project for working examples per Spring feature. To verify that the microservices
    will work once natively compiled, we can run the unit tests in a Native Image
    using Spring Boot’s Gradle task `nativeTest`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现对于特定的Spring功能来说，使原生图像创建正常工作存在问题，我们可以联系*Spring AOT Smoke Tests*项目，以获取每个Spring功能的示例。为了验证一旦原生编译，微服务将能够正常工作，我们可以使用Spring
    Boot的Gradle任务`nativeTest`运行单元测试。
- en: For the time being, the `nativeTest` task is not very useful with the source
    code in this book due to the described problems that existed when this chapter
    was written.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于在编写本章时存在的一些问题，`nativeTest`任务与本书中的源代码结合并不十分有用。
- en: We have also seen how easy it is to replace the Docker images running a Java
    VM with Docker images containing the natively compiled images. By running the
    Java VM Docker images in *AOT mode*, the startup times can be reduced a bit and,
    at the same time, we ensure that the generated AOT code works as expected. Finally,
    we tested the natively compiled images, both using Docker Compose and Kubernetes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何轻松地用包含原生编译图像的Docker镜像替换运行Java VM的Docker镜像。通过以*AOT模式*运行Java VM Docker镜像，可以稍微减少启动时间，同时确保生成的AOT代码按预期工作。最后，我们使用Docker
    Compose和Kubernetes测试了原生编译的镜像。
- en: With this, we have reached the end of the book. I hope it has helped you learn
    how to develop microservices using all the amazing features of Spring Boot, Spring
    Cloud, Kubernetes, and Istio and that you feel encouraged to try them out!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经到达了本书的结尾。我希望它已经帮助您学习如何使用Spring Boot、Spring Cloud、Kubernetes和Istio的所有惊人功能来开发微服务，并且您感到鼓励去尝试它们！
- en: Questions
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are the Spring’s AOT engine and the GraalVM projects related to each other?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring的AOT引擎和GraalVM项目之间有什么关系？
- en: How is the tracing agent used?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用跟踪代理？
- en: What is the difference between JIT and AOT compilation?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT编译和AOT编译之间的区别是什么？
- en: What is AOT mode, and how can it be beneficial to use?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AOT模式是什么，它如何有益于使用？
- en: What is a native custom hint?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是原生自定义提示？
- en: What is a native test, and why is it useful?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原生测试是什么，为什么它有用？
- en: How are initial memory usage and startup times affected by natively compiling
    Java code?
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地编译Java代码如何影响初始内存使用和启动时间？
- en: Join our community on Discord
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1849216352344398875.png)'
