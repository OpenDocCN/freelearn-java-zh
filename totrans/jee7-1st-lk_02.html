<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;New Specifications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. New Specifications</h1></div></div></div><p>This chapter will only talk about new specifications that have been added in Java EE 7. In concrete terms, we will present and show how to use the following APIs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Concurrency Utilities for Java EE 1.0</li><li class="listitem" style="list-style-type: disc">Batch Applications for Java Platform 1.0</li><li class="listitem" style="list-style-type: disc">Java API for JSON Processing 1.0</li><li class="listitem" style="list-style-type: disc">Java API for WebSocket 1.0</li></ul></div><div class="section" title="Concurrency Utilities for Java EE 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Concurrency Utilities for Java EE 1.0</h1></div></div></div><p>Concurrency Utilities for Java EE 1.0 was developed under JSR 236. This section gives you only an overview of the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html</a>.</p><div class="section" title="Why concurrency?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Why concurrency?</h2></div></div></div><p>In computer science, <span class="strong"><strong>concurrency</strong></span> is the <a id="id41" class="indexterm"/>ability of an application or a system to execute many tasks in parallel. Before the advent of multitasking system, computers could only run one process at a time. At that time, the programs were not only difficult to design, but they were also executed sequentially from beginning to end and when the machine was running a program that had access to a peripheral device, the running program was first interrupted to allow the reading of the peripheral.</p><div class="section" title="Benefits of concurrency"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Benefits of concurrency</h3></div></div></div><p>The development of multitasking <a id="id42" class="indexterm"/>operating systems enabled the simultaneous execution of many processes (instances of running programs) within a machine and many threads (also called lightweight processes; they are subsets of a process that can be run concurrently with each other) within a process. Due to this progress, it has become possible to run multiple applications at the same time, for example, listening to music and downloading a document while writing a text document.</p><p>In enterprise applications, concurrency can increase the interactivity of your program by running heavy processing asynchronously in a thread. It can also be used to improve the response time of an application by dividing a big <a id="id43" class="indexterm"/>task into smaller units that will be executed simultaneously by many threads.</p></div><div class="section" title="Risks of concurrency"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Risks of concurrency</h3></div></div></div><p>Although each thread has its proper <a id="id44" class="indexterm"/>stack of execution, it is very common to have multiple threads that share the same resources or depend on each other. In such cases, the absence of good synchronization makes threading behavior unpredictable and can degrade system performance. For example, the lack of coordination of interrelated threads can result in deadlocks and indefinitely interrupt processing.</p></div></div><div class="section" title="Concurrency and Java EE"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Concurrency and Java EE</h2></div></div></div><p>As we have seen previously, the misuse of <a id="id45" class="indexterm"/>threads can have catastrophic consequences on an application. In the case of a container, it could not only compromise its integrity, but also poorly exploit the resources provided to other components. This is one of the reasons why <a id="id46" class="indexterm"/>developers were not allowed to create threads in a container.</p><p>To enable implementation of concurrency within Java EE components, the Java EE 7 platform has integrated Concurrency Utilities. Using this API, a Java EE server can become aware of the resources that are used by threads and provide them with good execution context. Furthermore, it allows the server to manage the pool and lifecycle of threads.</p></div><div class="section" title="Java EE Concurrency API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Java EE Concurrency API</h2></div></div></div><p>Concurrency Utilities for Java EE 1.0 <a id="id47" class="indexterm"/>was developed with the followings goals in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To provide a simple and flexible concurrency API to the Java EE platform without compromising the container</li><li class="listitem" style="list-style-type: disc">To facilitate migration from Java SE to Java EE by providing consistency between the concurrency programming models</li><li class="listitem" style="list-style-type: disc">To allow the implementation of common and advanced concurrency patterns</li></ul></div><p>Concurrency Utilities was built over the Concurrency Utilities API developed under JSR-166 for Java SE (which facilitates the migration from Java SE to Java EE). It offers four main programming interfaces whose instances must be made available to application components as container-managed objects. The offered interfaces are: <code class="literal">ContextService</code>, <code class="literal">ManagedExecutorService</code>, <code class="literal">ManagedScheduledExecutorService</code>, and <code class="literal">ManagedThreadFactory</code>. All these interfaces are contained in the <code class="literal">javax.enterprise.concurrent</code> package.</p><p>These four interfaces can be <a id="id48" class="indexterm"/>explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed executor service</strong></span>: <a id="id49" class="indexterm"/>The <code class="literal">ManagedExecutorService</code> interface extends the <code class="literal">java.util.concurrent.ExecutorService</code> interface. It allows us to submit an asynchronous <a id="id50" class="indexterm"/>task that will be run on a separate thread created and managed by the container. By default, any Java EE 7-compliant server must provide a <code class="literal">ManagedScheduledExecutorService</code> that can be accessed by application components under the <span class="strong"><strong>JNDI</strong></span> name <code class="literal">java:comp/DefaultManagedScheduledExecutorService</code>. But, if you want to create your own, you must first declare the <code class="literal">ManagedExecutorService</code> resource environment reference in the <code class="literal">web.xml</code> file for a web application or <code class="literal">ejb-jar.xml</code> for an EJB module. The specification recommends that all <code class="literal">ManagedExecutorService</code> resource environment references be organized in the <code class="literal">java:comp/env/concurrent</code> subcontext.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The following configuration is an example declaration of a <code class="literal">ManagedExecutorService</code> <a id="id51" class="indexterm"/>resource environment reference:<div class="informalexample"><pre class="programlisting">	&lt;resource-env-ref&gt;
	  &lt;resource-env-ref-name&gt;
	    concurrent/ReportGenerator
	  &lt;/resource-env-ref-name&gt;
	  &lt;resource-env-ref-type&gt;
	    javax.enterprise.concurrent.ManagedExecutorService
	  &lt;/resource-env-ref-type&gt;
	&lt;/resource-env-ref&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></li><li class="listitem" style="list-style-type: disc">After declaring the JNDI reference, you can then inject it by using the <code class="literal">@Resource</code> <a id="id52" class="indexterm"/>annotation as shown in the following code:<div class="informalexample"><pre class="programlisting">	@Resource(name="concurrent/ReportGenerator")
	ManagedExecutorService reportGenerator;</pre></div></li><li class="listitem" style="list-style-type: disc">The task to submit to the container must either implement the <code class="literal">java.lang.Runnable</code> or <code class="literal">java.util.concurrent.Callable</code> interface. The differences between these interfaces are presented in the following table:<div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Runnable</p>
</th><th style="text-align: left" valign="bottom">
<p>Callable</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Since JDK 1.0.</p>
</td><td style="text-align: left" valign="top">
<p>Since JDK 5.0.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>It has <code class="literal">run()</code> method to define task.</p>
</td><td style="text-align: left" valign="top">
<p>It has the <code class="literal">call()</code> method to define task.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>It is not generic and the <code class="literal">run()</code> method does not return any value.</p>
</td><td style="text-align: left" valign="top">
<p>It is generic and the <code class="literal">call()</code> method of a <code class="literal">Callable&lt;V&gt;</code> instance returns a value of type <code class="literal">V</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The <code class="literal">run()</code> method cannot throw checked exception.</p>
</td><td style="text-align: left" valign="top">
<p>The <code class="literal">call()</code> method can throw checked exception.</p>
</td></tr></tbody></table></div></li><li class="listitem" style="list-style-type: disc">The following code demonstrates how to define a task that will run reports asynchronously:<div class="informalexample"><pre class="programlisting">	public class ReportGeneratorTask implements Callable&lt;String&gt;{
	
	  @Override
	  public String call() throws Exception {
	    //generate report
	    return "The report was generated successfully";
	  }   
	}</pre></div></li><li class="listitem" style="list-style-type: disc">The following code shows us <a id="id53" class="indexterm"/>how to submit a task. We can see that the <code class="literal">submit()</code> method of the <code class="literal">ManagedExecutorService</code> instance returns an object of type <code class="literal">Future</code> that will get back the result of the running task when it becomes available:<div class="informalexample"><pre class="programlisting">	Future&lt;String&gt; monitor = reportGenerator
	.submit(new ReportGeneratorTask());
	String result = monitor.get();         </pre></div></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed scheduled executor service: </strong></span>The <code class="literal">ManagedScheduledExecutorService</code> interface extends the <code class="literal">ManagedExecutorService</code> <a id="id54" class="indexterm"/>and <code class="literal">java.util.concurrent.ScheduledExecutorService</code> interfaces in order to execute a task at a specific time.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Instances of this interface are defined in the same way as that of the <code class="literal">ManagedExecutorService</code> <a id="id55" class="indexterm"/>interface. The following code demonstrates how to execute a task ten seconds after its submission:<div class="informalexample"><pre class="programlisting">	Future&lt;String&gt; monitor = reportGenerator
	  .schedule(new ReportGeneratorTask(), 10,TimeUnit.SECONDS);</pre></div></li></ul></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed thread factory: </strong></span>The <code class="literal">ManagedThreadFactory</code> interface provides method to create managed <a id="id56" class="indexterm"/>thread instances in a container. The task must implement the <code class="literal">java.lang.Runnable</code> interface. The following code demonstrates how to create and run a container-managed thread.<div class="informalexample"><pre class="programlisting">Thread myThread = threadFactory.newThread(new ReportManagedThread()); 
myThread.start();</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Context service: </strong></span>This interface allows the creation of contextual objects without using <code class="literal">ManagedExecutorService</code> or <code class="literal">ManagedScheduledExecutorService</code> interfaces, as we did in the previous cases, with the aim of allowing <a id="id57" class="indexterm"/>the extension of the capabilities of a Java EE platform for concurrency. Concretely, with this interface, you can create a workflow system or use customized Java SE platform <code class="literal">ExecutorService</code> implementations within a container. For example, if you desire to use the pool management mechanism provided by the class <code class="literal">java.util.concurrent.ThreadPoolExecutor</code> of Java SE to manage your threads in the context of a Java EE component, you will just need to combine <code class="literal">ManagedThreadFactory</code>, <code class="literal">ExecutorService</code>, and <code class="literal">ContextService</code> objects. The result is as shown in the following code:<div class="informalexample"><pre class="programlisting">public class ReportCustomizedThread implements Runnable {

  public void run() {
    //Report processing ...
  }
}

@Resource(name=»concurrent/ReportManagedThreadGenerator»)
ManagedThreadFactory threadFactory;
    
@Resource(name=»concurrent/ReportContextServiceGenerator»)
ContextService contextService; 

ReportCustomizedThread reportThread = new ReportCustomizedThread();
Runnable proxy =contextService.createContextualProxy(reportThread,Runnable.class);
ExecutorService executorService =Executors.newFixedThreadPool(20, threadFactory);
Future result = executorService.submit(proxy);
//...</pre></div></li></ul></div><p>This is probably a simple example of the use you can make of this feature. For more advanced examples, please consult the specification document in the <span class="emphasis"><em>Context service</em></span> section.</p><p>The following diagram provides <a id="id58" class="indexterm"/>an overview of relationships between Concurrency Utilities and other Java EE platform elements:</p><div class="mediaobject"><img src="graphics/9235OT_02_01.jpg" alt="Java EE Concurrency API"/></div><p>Besides, it is possible to refine the configurations of different resources for better performance (for details, see the specification document), and the Concurrency Utilities for Java EE 1.0 provide many other interfaces like <code class="literal">ManagedTaskListener</code> that can be used to monitor the state of a task's <code class="literal">Future</code> object.</p></div></div></div>
<div class="section" title="Batch Applications for Java Platform 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Batch Applications for Java Platform 1.0</h1></div></div></div><p>The Batch Applications API for the <a id="id59" class="indexterm"/>Java Platform 1.0 was developed under JSR 352. This section just gives you an overview of the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html</a>.</p><div class="section" title="What is batch processing?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>What is batch processing?</h2></div></div></div><p>According to the Cambridge Advanced <a id="id60" class="indexterm"/>Learner's Dictionary, a batch is a group of things or people dealt with at the same time or considered similar in type. And a process is a series of actions that you take in order to achieve a result. Based on these two definitions, we can say that <span class="strong"><strong>batch processing</strong></span> is a series of repetitive actions on a large amount of data in order to achieve a result. Given the large amounts of data that it has to deal with, batch processing is often used for end of day, month, period, and year processing.</p><p>The following is a short list of domains where you can use batch processing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data import/export from/to XML or CSV files</li><li class="listitem" style="list-style-type: disc">Accounting processing such as consolidations</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ETL</strong></span> (<span class="strong"><strong>extract-transform-load</strong></span>) <a id="id61" class="indexterm"/>in a data warehouse</li><li class="listitem" style="list-style-type: disc">Digital files processing (downloading, processing, or saving)</li><li class="listitem" style="list-style-type: disc">Notification of a service's subscribers (such as forum, group, and so on)</li></ul></div></div><div class="section" title="Why a dedicated API for batch processing?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Why a dedicated API for batch processing?</h2></div></div></div><p>After having an idea about batch <a id="id62" class="indexterm"/>processing, some people might ask themselves: Why not just set a <code class="literal">foreach</code> loop that launches many threads? First of all, you have to know that batch processing is not only concerned with the execution speed. Indeed, the processing of large amounts of data is often affected by many exceptions, which could generate a number of preoccupations: What action should be taken in case of exceptions? Should we cancel the whole process for any exception? If not, what action should be canceled? For which type of exception? If you only need to cancel a certain number of transactions, how do you recognize them? And at the end of a batch processing, it is always important to know how many treatments have been canceled. How many have been registered successfully? How many have been ignored?</p><p>As you can see, we have not finished identifying questions that batch processing can raise, but we discover that this is already a great deal. Trying to build such a tool on your own may not only complicate your application but also introduce new bugs.</p></div><div class="section" title="Understanding the Batch API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Understanding the Batch API</h2></div></div></div><p>The Batch Applications API for the <a id="id63" class="indexterm"/>Java Platform 1.0 was developed to provide a solution to the different needs listed in the earlier bullet items. It targets both Java SE and Java EE applications and requires at least the 6th Version of JVM.</p><p>The features offered by this API <a id="id64" class="indexterm"/>can be summarized as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It offers the <span class="strong"><strong>Reader-Processor-Writer</strong></span> <a id="id65" class="indexterm"/>pattern natively and gives you the ability to implement your own batch pattern. This allows you to choose the best pattern depending on the case.</li><li class="listitem" style="list-style-type: disc">It gives the possibility of defining the behavior (skip, retry, rollback, and so on) of the batch processing for each type of error.</li><li class="listitem" style="list-style-type: disc">It supports many step-level metrics such as: <code class="literal">rollbackCount</code>, <code class="literal">readSkipCount</code>, <code class="literal">writeSkipCount</code>, and so on for monitoring.</li><li class="listitem" style="list-style-type: disc">It can be configured to run some processes in parallel and offer the possibility to use JTA or <code class="literal">RESOURCE_LOCAL</code> transaction mode.</li></ul></div><p>To do this, the Batch Applications API for the Java Platform 1.0 is based on a solid architecture that can be outlined by the following diagram. <a id="id66" class="indexterm"/>A <span class="strong"><strong>Job</strong></span> is managed by a <code class="literal">JobOperator</code> and has one or many steps, which can be either <span class="strong"><strong>chunk</strong></span> or <span class="strong"><strong>batchlet</strong></span>. <a id="id67" class="indexterm"/>During <a id="id68" class="indexterm"/>its lifecycle, information (metadata) about a job is stored in <code class="literal">JobRepository</code>, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/9235OT_02_02.jpg" alt="Understanding the Batch API"/></div><div class="section" title="JobRepository"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>JobRepository</h3></div></div></div><p>As we said earlier, <code class="literal">JobRepository</code> stores <a id="id69" class="indexterm"/>metadata about current and past running jobs. <a id="id70" class="indexterm"/>It can be accessed through <code class="literal">JobOperator</code>.</p></div><div class="section" title="Job"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Job</h3></div></div></div><p>A <span class="strong"><strong>Job</strong></span> can be seen as an entity to encapsulate a <a id="id71" class="indexterm"/>unit of batch processing. It is made up of one or many steps, <a id="id72" class="indexterm"/>which must be configured within an XML file called a <span class="strong"><strong>Job configuration file</strong></span> or <span class="strong"><strong>Job XML</strong></span>. This file will contain job identification information and different steps that compose the job. The code that follows shows the skeleton of a Job XML file.</p><div class="informalexample"><pre class="programlisting">&lt;job id="inscription-validator-Job" version="1.0"&gt;  
  
  &lt;step id="step1" &gt;        
    ... 
  &lt;/step&gt;    
  &lt;step id="step2" &gt;        
    ...   
  &lt;/step&gt;
&lt;/job&gt;</pre></div><p>The Job XML file is named with the convention <code class="literal">&lt;name&gt;.xml</code> (for example, <code class="literal">inscriptionJob.xml</code>) and should be stored under the <code class="literal">META-INF/batch-jobs</code> directory for portable application.</p></div><div class="section" title="Step"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Step</h3></div></div></div><p>A <span class="strong"><strong>Step</strong></span> is an autonomous phase of a <a id="id73" class="indexterm"/>batch. It contains all the necessary information to define and <a id="id74" class="indexterm"/>control a piece of batch processing. A batch step is either a chunk or a batchlet (the two are mutually exclusive). The step of the following code is a chunk type step:</p><div class="informalexample"><pre class="programlisting">&lt;job id="inscription-validator-Job" version="1.0"&gt;
  &lt;step id="validate-notify" &gt;        
    &lt;chunk&gt;
       &lt;reader ref="InscriptionReader" /&gt;
       &lt;processor ref="InscriptionProcessor" /&gt;
       &lt;writer ref="StudentNotifier" /&gt;
    &lt;/chunk&gt;     
  &lt;/step&gt;    
&lt;/job&gt;</pre></div></div><div class="section" title="Chunk"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Chunk</h3></div></div></div><p>A <span class="strong"><strong>chunk</strong></span> is a type of step <a id="id75" class="indexterm"/>that <a id="id76" class="indexterm"/>implements the Reader-Processor-Writer pattern. It runs in the scope of a configurable transaction and can receive many configuration values. The following code is a more enhanced version of the <span class="strong"><strong>inscription-validator-Job</strong></span> shown in the preceding code. In this listing, we have added a configuration to define the unit element that will be used in order to manage the commit behavior of the chunk (<code class="literal">checkpoint-policy="item"</code>), and a configuration to define the number of items (unit elements) to process before commit (<code class="literal">item-count="15"</code>). We have also specified the number of exceptions a step will skip if any configured exceptions that can be skipped are thrown by the chunk (<code class="literal">skip-limit="30"</code>).</p><p>The following code is an example of a chunk type step with some configuration:</p><div class="informalexample"><pre class="programlisting">&lt;job id="inscription-validator-Job" version="1.0" 
  &gt;   
  &lt;step id="validate-notify" &gt;        
    &lt;chunk item-count="15" checkpoint-policy="item" 
      skip-limit="30"&gt;
      &lt;reader ref="InscriptionReader" /&gt;
      &lt;processor ref="InscriptionProcessor" /&gt;
      &lt;writer ref="StudentNotifier" /&gt;
    &lt;/chunk&gt;     
  &lt;/step&gt;    
&lt;/job&gt;</pre></div><p>The following code shows us what chunk batch artifact implementation looks like. The <code class="literal">InscriptionCheckpoint</code> allows <a id="id77" class="indexterm"/>you to know the line that is being processed. The source code of this section is a validation program that sends a message to the candidates to let them know if they have been accepted or not. At the end, it displays monitoring information in a web page. The processing is launched by the <code class="literal">ChunkStepBatchProcessing.java</code> Servlet.</p><p>The following code is a skeleton of chunk batch artifact implementations:</p><div class="informalexample"><pre class="programlisting">public class InscriptionReader extends AbstractItemReader {
  @Override
  public Object readItem() throws Exception {
    //Read data and return the item
  }
}

public class InscriptionProcessor implements ItemProcessor{
  @Override
  public Object processItem(Object o) throws Exception {
    //Receive item from the reader, process and return the result
  }    
}

public class StudentNotifier extends AbstractItemWriter {
  @Override
  public void writeItems(List&lt;Object&gt; items) throws Exception {
    //Receive items from the processor then write it out
  }
}
public class InscriptionCheckpoint implements Serializable {
  private int lineNumber;
  
  public void incrementLineNumber(){
    lineNumber++;
  }

  public int getLineNumber() {
    return lineNumber;
  }        
}</pre></div></div><div class="section" title="Batchlet"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Batchlet</h3></div></div></div><p>A <span class="strong"><strong>batchlet</strong></span> is a type of step to <a id="id78" class="indexterm"/>implement your own batch pattern. Unlike a chunk that performs <a id="id79" class="indexterm"/>tasks in three phases (reading, processing, and writing), a batchlet step is invoked once and returns an exit status at the end of processing. The following code shows us what a batchlet batch artifact implementation looks like. The source code of this section sends an information message to all students and displays some important information about the batch. The processing is launched by the <code class="literal">BatchletStepBatchProcessing.java</code> Servlet.</p><p>The following code is a skeleton of batchlet batch artifact implementation:</p><div class="informalexample"><pre class="programlisting">public class StudentInformation extends AbstractBatchlet{
  
  @Override
  public String process() throws Exception {
    // process 
    return "COMPLETED";
  }    
}</pre></div></div></div><div class="section" title="The batch.xml configuration file"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>The batch.xml configuration file</h2></div></div></div><p>The <code class="literal">batch.xml</code> file is an XML <a id="id80" class="indexterm"/>file <a id="id81" class="indexterm"/>that contains the batch artifacts of the batch application. It establishes a correspondence between the batch artifact implementation and the reference name that is used in the Job XML file. The <code class="literal">batch.xml</code> file must be stored in the <code class="literal">META-INF</code> directory for a portable application. The following code gives us the contents of the <code class="literal">batch.xml</code> file for the <code class="literal">inscription-validator-Job</code> Job shown in the preceding code.</p><p>The following <a id="id82" class="indexterm"/>code is an <a id="id83" class="indexterm"/>example of <code class="literal">batch.xml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;batch-artifacts &gt; 
  &lt;ref id="InscriptionReader" 
  class="com.packt.ch02.batchprocessing.chunk.InscriptionReader" /&gt; 
  &lt;ref id="StudentNotifier" 
  class="com.packt.ch02.batchprocessing.chunk.StudentNotifier" /&gt; 
  &lt;ref id="InscriptionProcessor" 
  class="com.packt.ch02.batchprocessing.chunk.InscriptionProcessor" /&gt; 
&lt;/batch-artifacts&gt;</pre></div></div><div class="section" title="JobOperator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>JobOperator</h2></div></div></div><p>The <code class="literal">JobOperator</code> instance is <a id="id84" class="indexterm"/>accessible through the <code class="literal">getJobOperator()</code> <a id="id85" class="indexterm"/>method of the <code class="literal">BatchRuntime</code> <a id="id86" class="indexterm"/>class. It provides a set of operations to manage (<code class="literal">start</code>, <code class="literal">stop</code>, <code class="literal">restart</code> and so on) a job and access <code class="literal">JobRepository</code> (<code class="literal">getJobNames</code>, <code class="literal">getJobInstances</code>, <code class="literal">getStepExecutions</code>, and so on). The following code shows how to start the <code class="literal">inscription-validator-Job</code> Job shown earlier without any specific property. It is important to note that the <code class="literal">inscriptionJob</code> value that is specified in the <code class="literal">JobOperator.start</code> command is the name of the Job XML file (not the ID of the job). In the Servlet <code class="literal">ChunkStepBatchProcessing</code>, you will see how to retrieve the status and how to monitor information about batch processing from the <code class="literal">JobOperator</code> instance.</p><p>The following code is an example of code to start a Job:</p><div class="informalexample"><pre class="programlisting">JobOperator jobOperator = BatchRuntime.getJobOperator();
if(jobOperator != null)
  jobOperator.start("inscriptionJob", null);</pre></div></div></div>
<div class="section" title="Java API for JSON Processing 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Java API for JSON Processing 1.0</h1></div></div></div><p>The Java API for JSON Processing <a id="id87" class="indexterm"/>1.0 was developed under JSR 353. This section gives you only an overview of the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html</a>.</p><div class="section" title="What is JSON?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>What is JSON?</h2></div></div></div><p><span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>) is <a id="id88" class="indexterm"/>a lightweight data-interchange text format. It is based on a subset of JavaScript, but it is completely language independent. JSON format is often used for data exchanges between web client and web server or web service. But, it can be used whenever you need to store or transmit relatively small amounts of data that can easily be represented as a combination of name-value pairs.</p><p>JSON is built on two structures, which are: a collection of name-value pairs and an ordered list of values. These structures are made from three data types: <code class="literal">object</code>, <code class="literal">array</code>, and <code class="literal">value</code>.</p><div class="section" title="Object"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Object</h3></div></div></div><p>An <span class="strong"><strong>object</strong></span> is an unordered set of <code class="literal">name:value</code> <a id="id89" class="indexterm"/>pairs within braces (<code class="literal">{}</code>). After each name, there is a colon (<code class="literal">:</code>) and the name-value pairs are separated by a comma (<code class="literal">,</code>). The name is <code class="literal">string</code> type <a id="id90" class="indexterm"/>while the type of the value can be <code class="literal">string</code>, <code class="literal">object</code> and so on The following text gives an example of a JSON object, which contains some information about a student:</p><div class="informalexample"><pre class="programlisting">{"name":"Malinda","gender":"F","birthday":"14/03/1976","weight":78.5}</pre></div></div><div class="section" title="Array"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Array</h3></div></div></div><p>An <span class="strong"><strong>array</strong></span> is an ordered collection of values <a id="id91" class="indexterm"/>separated by a comma (<code class="literal">,</code>) within brackets (<code class="literal">[]</code>). The following text <a id="id92" class="indexterm"/>gives an example of a JSON array, which contains a list of students with their score in alphabetical order.</p><div class="informalexample"><pre class="programlisting">[{"name":"Amanda","score"=12.9},{"name":"Paolo","score"=14},{"name":"Zambo","score"=12.3}]</pre></div><div class="section" title="Value"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>Value</h4></div></div></div><p>A JSON <span class="strong"><strong>value</strong></span> can be a <a id="id93" class="indexterm"/>
<code class="literal">string</code> <a id="id94" class="indexterm"/>in double quotes, a <code class="literal">boolean</code> true or false, an <code class="literal">object</code>, an <code class="literal">array</code> or <code class="literal">null</code>.</p></div></div><div class="section" title="Why JSON?"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Why JSON?</h3></div></div></div><p>The <span class="strong"><strong>XML</strong></span> (<span class="strong"><strong>Extensible Markup </strong></span><a id="id95" class="indexterm"/>
<span class="strong"><strong>Language</strong></span>) was <a id="id96" class="indexterm"/>released after the <span class="strong"><strong>SGML</strong></span> (<span class="strong"><strong>Standardised Generalised Markup Language</strong></span>, which was powerful and extensible but complex) and the <span class="strong"><strong>HTML</strong></span> (<span class="strong"><strong>HyperText Markup </strong></span><a id="id97" class="indexterm"/>
<span class="strong"><strong>Language</strong></span>, a simple version of SGML focused on data presentation) to overcome the shortcomings of both languages. Its power, flexibility, and simplicity have favored its use in many applications for configuration management, storage, data transfer, and so on. With the advent of <span class="strong"><strong>AJAX</strong></span> technologies, the use of XML was widespread in exchanges between browsers and web servers. But, it presented some limitations: XML documents are heavy in nature because of the duplication of information, loading, and handling of data can be complex and processing XML documents sometimes is browser dependent.</p><p>To provide a solution to these problems, the JSON format was developed as an alternative to XML. In fact, despite its portability and flexibility, JSON does not support namespaces, data access requires a knowledge of the document and until now, there is no<span class="strong"><strong> XSD</strong></span> or <span class="strong"><strong>DTD</strong></span> to validate the document's structure.</p><p>A simple comparison between XML and JSON data presentation is shown in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>XML data <a id="id98" class="indexterm"/>presentation</p>
</th><th style="text-align: left" valign="bottom">
<p>JSON data <a id="id99" class="indexterm"/>presentation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">&lt;student&gt;
  &lt;id&gt;854963&lt;/id&gt;
  &lt;name&gt;LouisPoyer&lt;/name&gt;
  &lt;weight&gt;78.6&lt;/weight&gt;
  &lt;gender&gt;M&lt;/gender&gt;
  &lt;contact&gt;
    &lt;address&gt;Rue9632&lt;/address&gt;
    &lt;phone&gt;985-761-0&lt;/phone&gt;
  &lt;/contact&gt;   
&lt;/student&gt;</pre></div>
</td><td style="text-align: left" valign="top">
<div class="informalexample"><pre class="programlisting">{"student": {
  "id":"854963", 
  "name":"LouisPoyer", 
  "weight":78.6,
  "gender":"M",
  "contact":[
    {"address":"Rue632"},
    {"phone":"985-761-0"} ]
  }  
}</pre></div>
</td></tr></tbody></table></div></div><div class="section" title="Java API for JSON processing"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Java API for JSON processing</h3></div></div></div><p>The Java API for JSON processing <a id="id100" class="indexterm"/>defines an API to process (<code class="literal">parse</code>, <code class="literal">generate</code>, <code class="literal">transform</code>, and <code class="literal">query</code>) JSON documents by using either the streaming API or the object model API.</p><div class="section" title="The streaming API"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>The streaming API</h4></div></div></div><p>The <span class="strong"><strong>streaming API</strong></span> is for <a id="id101" class="indexterm"/>JSON as <a id="id102" class="indexterm"/>
<span class="strong"><strong>StAX API</strong></span> <a id="id103" class="indexterm"/>is for XML. In other words, the streaming API is an event-based JSON parsing. It parses a JSON file sequentially and fires an event whenever a it encounters a new tag in the stream (new value String, new start of objet, end of objet, new start of an array …). The example that follows shows us how to get contact information within the JSON data presented on the previous page.</p><p>Example of JSON processing using the streaming API:</p><div class="informalexample"><pre class="programlisting">public String getStudentContact(String jsonData) {
  JsonParser parser = Json.createParser(new StringReader(jsonData));
  Event event = null;
  boolean found = false;
  String information = "";
  
  //Advance to the contact key
  while (parser.hasNext()) {
    event = parser.next();            
    if ((event == Event.KEY_NAME) &amp;&amp; 
      "contact".equals(parser.getString())) {
        found = true;
        event = parser.next();              
        break;
      }
    }

    if (!found) {
      return "contact information does not exist";
    }

    //get contact information 
    while (event != Event.END_ARRAY) {         
    switch (event) {
      case KEY_NAME:
        information += parser.getString() + " = ";
        break;
      case START_ARRAY: break;
      case END_ARRAY: break;
      case VALUE_FALSE: break;
      case VALUE_NULL: break;
      case VALUE_NUMBER:
        if (parser.isIntegralNumber()) {
          information += parser.getLong()+", ";
        } else {
          information += parser.getBigDecimal()+", ";
        }
        break;
      case VALUE_STRING:
        information += parser.getString()+", ";
        break;
      case VALUE_TRUE:
        information += " TRUE, ";
        break;
    }
    event = parser.next();
  }
  return information;
}</pre></div><p>The streaming API consists of five interfaces, one <code class="literal">enum</code> class, and two exceptions. All of them are contained in the <code class="literal">javax.json.stream</code> package. Among these interfaces, we have the <code class="literal">JsonParser</code> interface, which contains <a id="id104" class="indexterm"/>methods for step-by-step read-only access to JSON data, and the <code class="literal">JsonGenerator</code> interface, which provides methods to generate (write out) JSON step-by-step. Instances of these interfaces can be created respectively with <code class="literal">JsonParserFactory</code> and <code class="literal">JsonGeneratorFactory</code> factories. All events triggered by the streaming API are contained in the <code class="literal">JsonParser.Event</code> <code class="literal">enum</code> class.</p><p>It's recommended to <a id="id105" class="indexterm"/>use the streaming API to parse large JSON files because, unlike the object model API, it does not require loading the whole file before processing. This ensures good memory management.</p></div><div class="section" title="The object model API"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>The object model API</h4></div></div></div><p>The object model API is for JSON as <a id="id106" class="indexterm"/>
<span class="strong"><strong>DOM API</strong></span> is for XML. <a id="id107" class="indexterm"/>This means that it <a id="id108" class="indexterm"/>represents a JSON document as a tree structure in memory before giving the possibility to navigate in or query the document. This API provides the most flexible way to parse a JSON document by giving a random access to any data it contains. But in return, it requires more memory. That is why it is not suitable for large documents.</p><p>The object model API consists of thirteen interfaces, one class, one enum class and one exception. All of them are packages in <code class="literal">javax.json</code>. Among interfaces, we have: <code class="literal">JsonArrayBuilder</code> and <code class="literal">JsonObjectBuilder</code> to build JSON arrays and JSON objects respectively from scratch; <code class="literal">JsonArray</code> to access the ordered values of a JSON array as a list and <code class="literal">JsonObject</code> to access the values of a JSON object as a Map and <code class="literal">JsonBuilderFactory</code> to create <code class="literal">JsonObjectBuilder</code> or <code class="literal">JsonArrayBuilder</code> instances; <code class="literal">JsonReader</code> to read JSON from an input source and <code class="literal">JsonReaderFactory</code> to create <code class="literal">JsonReader</code> instances; <code class="literal">JsonWriter</code> to write JSON to an output source, and <code class="literal">JsonWriterFactory</code> to create <code class="literal">JsonWriter</code> instances. The following code demonstrates how to create an object model from scratch and access data within it.</p><p>The following code is an example of JSON processing using the object model API:</p><div class="informalexample"><pre class="programlisting">JsonObject objModel = Json.createObjectBuilder()
.add("student",Json.createObjectBuilder()
  .add("id", "854963")
  .add("name", "Louis Poyer")
  .add("weight", 78.6)
  .add("gender","M")
  .add("contact",Json.createArrayBuilder()
    .add(Json.createObjectBuilder()
    .add("address","Rue 632"))
    .add(Json.createObjectBuilder()
    .add("phone","985-761-0")))                        
).build();
      
JsonObject student = objModel.getJsonObject("student");
String name = student.getString("name");
JsonArray contact = student.getJsonArray("contact");
String address = contact.getJsonObject(0).getString("address");
String phone = contact.getJsonObject(1).getString("phone"));</pre></div></div></div></div></div>
<div class="section" title="Java API for WebSocket 1.0"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Java API for WebSocket 1.0</h1></div></div></div><p>The Java API for WebSocket 1.0 was <a id="id109" class="indexterm"/>developed under JSR 356. This section just gives you an overview of the API. The complete document specification (for more information) can be downloaded from <a class="ulink" href="http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html">http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html</a>.</p><div class="section" title="What is WebSocket?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>What is WebSocket?</h2></div></div></div><p>Originally called <span class="strong"><strong>TCPConnection</strong></span> in <a id="id110" class="indexterm"/>previous versions of the HTML5 specification, <span class="strong"><strong>WebSocket</strong></span> is an <a id="id111" class="indexterm"/>independent protocol built over the <span class="strong"><strong>TCP</strong></span> (<span class="strong"><strong>Transmission Control Protocol</strong></span>), which enables bidirectional and full-duplex communication between a client and a server.</p><p>To open a WebSocket connection in web application , the web client uses an HTTP request to ask the server to upgrade the connection to a WebSocket connection. If the server supports and accepts the WebSocket protocol connection request, it will still return a response through HTTP. From that moment, the communication is established and both parties can send and receive data by using only the WebSocket protocol.</p></div><div class="section" title="Why WebSocket?"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Why WebSocket?</h2></div></div></div><p>Today, many web applications (instant <a id="id112" class="indexterm"/>messaging, trading platforms, some e-commerce platforms, online gaming, and so on) require a real-time communication between a client (browser) and a server. If you do not know, the HTTP protocol is a stateless half-duplex protocol. This means that, to access new information and update a web page, the client must always open a connection to the server, send a request, wait for the server response, and then close the connection. Thus, in a real-time context, the client will frequently send requests to the server in order to detect the presence of new data and many request-responses will be made even when there is no new information.</p><p>To get around this problem, many solutions have been proposed. The most efficient was certainly long polling, which can be described like this: the client makes a request to the server; if there is data available, the server responds. Otherwise, it waits until there is new information before responding. After receiving the response, the client sends another request and so on. Although it seems good, this technique requires proprietary solutions (comet) and when data are frequently updated, the loop connection-request-response-disconnection may negatively impact the network.</p><p>WebSocket is not an HTTP-based technique, it is a protocol that provides a new and better way to overcome the shortcomings of the HTTP protocol in real-time communication between web client and web server/service.</p></div><div class="section" title="The WebSocket API"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>The WebSocket API</h2></div></div></div><p>The Java API for WebSocket 1.0 defines <a id="id113" class="indexterm"/>a standard API to build WebSocket-driven applications in the Java EE platform.</p><p>A WebSocket application consists of two types of components called endpoints: a client endpoint and a server endpoint. A client endpoint is the component that initiates a WebSocket connection, while a server endpoint is waiting for connections. With the Java API for WebSocket 1.0, both component types can be created either programmatically or declaratively by using annotations. In this <a id="id114" class="indexterm"/>chapter we will only see annotated endpoints in a small student chat room application.</p><div class="section" title="Server endpoint"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Server endpoint</h3></div></div></div><p>The following code demonstrates <a id="id115" class="indexterm"/>how to create a WebSocket endpoint that is <a id="id116" class="indexterm"/>able to accept client connections and send messages:</p><div class="informalexample"><pre class="programlisting">@ServerEndpoint("/chatserver")
public class ChatServerEndPoint {    
  @OnOpen
  public void openConnection(Session session) throws Exception {
    //...
  }

  @OnMessage
  public void onMessage(Session session, String msg)throws Exception {
    //...
  }

  @OnClose
  public void closeConnection(Session session) throws Exception {
    //...
  }
}</pre></div><p>The <code class="literal">@ServerEndpoint</code> <a id="id117" class="indexterm"/>annotation defines a server type endpoint and the path where it will be deployed. You will also notice that the API offers annotations to describe the method to be executed in each step of the endpoint lifecycle. The following table gives the list and the role of WebSocket endpoint lifecycle <a id="id118" class="indexterm"/>annotations.</p><p>The following table lists the WebSocket endpoint lifecycle annotations:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Role</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">@OnOpen</code></p>
</td><td style="text-align: left" valign="top">
<p>Designates <a id="id119" class="indexterm"/>the method to be executed at the opening of a connection</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@OnMessage</code></p>
</td><td style="text-align: left" valign="top">
<p>Designates the <a id="id120" class="indexterm"/>method to be executed when a message is received</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@OnError</code></p>
</td><td style="text-align: left" valign="top">
<p>Designates the <a id="id121" class="indexterm"/>method to be executed in case of a connection error</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">@OnClose</code></p>
</td><td style="text-align: left" valign="top">
<p>Designates the <a id="id122" class="indexterm"/>method to be executed when the connection is closed</p>
</td></tr></tbody></table></div><p>Any message sent by a WebSocket client is intercepted by the <code class="literal">onMessage()</code> method, which takes the client session and the message as parameters (for other parameters that can be taken, please see the specification). Messages can be sent synchronously with the method <code class="literal">Session.getBasicRemote()</code> or asynchronously with the method <code class="literal">Session.getAsyncRemote()</code>. Each of these methods is used to send messages of type: <code class="literal">text</code>, <code class="literal">binary</code>, <code class="literal">object</code>, <code class="literal">ping</code>, and pong frames. The following code<span class="emphasis"><em> </em></span>demonstrates how to send a text message to all connected clients:</p><div class="informalexample"><pre class="programlisting">static Set&lt;Session&gt; users = Collections.synchronizedSet(new HashSet());

  @OnOpen
  public void openConnection(Session session) throws Exception {
    users.add(session);        
  }

  @OnMessage
  public void onMessage(Session session, String msg)throws Exception {
    for (Session s : users) {
      s.getBasicRemote().sendText(msg);
    }
  }</pre></div><p>The session object contains a variable to store some user-specific information. The code that follows demonstrates how to communicate <a id="id123" class="indexterm"/>with many customers by giving the name of the person who sent the message each time:</p><div class="informalexample"><pre class="programlisting">//...
static Set&lt;String&gt; usersId = Collections.synchronizedSet(new HashSet());
//...

@OnMessage
  public void onMessage(Session session, String msg)throws Exception {
    if (msg.startsWith("ID")) {//if it is a connection message
      String id = msg.split("-")[1];
      session.getUserProperties().put("id", id);
      //save the ID of the user
      usersId.add(id);
      //add the ID in the list of connected users
      Object[] obj1 = new Object[]{"wel","Welcome to the chat room "+id +"!"};
      String jsonString = getJsonObject(obj1);
      //json message transformation
      //send a welcome message to the new user
      session.getBasicRemote().sendText(jsonString);
      //send the list of connected users to all users
      Object[] obj2 = new Object[]{"users",usersId};
      jsonString = getJsonObject(obj2);
      for (Session s : users) {
        s.getBasicRemote().sendText(jsonString);
      }
    } else { //if it is a message to the chat room
      //get ID of the user who sends message
      String id = (String) session.getUserProperties().get("id");
      Object[] obj = new Object[]{"msg",id + "&gt;&gt;" + msg.split("-")[1]};
      String jsonString = getJsonObject(obj);//json transformation
      //sends the message to all connected users
      for (Session s : users) {
        s.getBasicRemote().sendText(jsonString);
      }
    }
  }</pre></div></div><div class="section" title="Client endpoint"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Client endpoint</h3></div></div></div><p>Our client WebSocket endpoint is a <code class="literal">.jsp</code> web page (<code class="literal">websocketChatClient.jsp</code>) which is based on JavaScript code. As you <a id="id124" class="indexterm"/>can see, the client side has the same lifecycle <a id="id125" class="indexterm"/>methods and through the power of JSON, we can easily access and display messages sent by the server.</p><p>The following code is an example of a web client WebSocket endpoint:</p><div class="informalexample"><pre class="programlisting">//complete URI of the chat server endpoint
var clientUri = "ws://"+document.location.host+"/chapter02NewSpecifications/chatserver";
var wsocket;

//connection request when loading the web page
window.addEventListener("load", connect, false);

//Connection method
function connect() {
  wsocket = new WebSocket(clientUri);
  //binding of the websocket lifecycle methods
  wsocket.onmessage = onMessage;
  wsocket.onerror = onError;
}

function joinChatRoom() {//method to join the chat room
    wsocket.send("ID-" + txtMessage.value);
}

function sendMessage() {//method to send a message to the chat room
    wsocket.send("M-" + txtMessage.value);
}

function onMessage(event) {//method to perform incoming messages
  var parsedJSON = eval('(' + event.data + ')');
  if (parsedJSON.wel != null) {//if welcome message
    userState.innerHTML = parsedJSON.wel;
  }
  if (parsedJSON.msg != null) {//if chat room message
    userMessage.innerHTML += "\n"+parsedJSON.msg;
  }
  if (parsedJSON.users.length &gt; 0) {//if new new connection user
    userId.innerHTML = "";
    for (i = 0; i &lt; parsedJSON.users.length; i++) {
      userId.innerHTML += i + "-" + parsedJSON.users[i] + "\n";
    }
  }
}</pre></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>In this chapter we have tried to present the usefulness and implementation of the new specifications of Java EE 7. In the coming chapters, we will analyze the improvements that have been made to the specifications inherited from Java EE 6 and use the opportunity to show how to integrate new specifications with existing ones.</p></div></body></html>