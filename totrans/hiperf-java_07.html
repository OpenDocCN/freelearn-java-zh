<html><head></head><body>
		<div id="_idContainer019">
			<h1 class="chapter-number" id="_idParaDest-128"><a id="_idTextAnchor127"/>7</h1>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>String Objects</h1>
			<p>In an effort to analyze every aspect of our Java applications to ensure that they perform at a highly efficient rate, we need to consider string objects. Strings are a big part of Java applications and are used for limitless purposes from a simple list of names to complex data storage needs, such as with a bank’s databases. The creation, manipulation, and management of these objects should be a <span class="No-Break">primary concern.</span></p>
			<p>This chapter focuses on the efficient use of string objects in our Java applications. The first concept is proper string pooling. We will examine this concept and explore best practices for using string pooling for high performance. The chapter also introduces the concept of lazy initialization, examines its benefits, and illustrates implementation with sample code. Lastly, we will look at additional string operation strategies, to include advanced string <span class="No-Break">manipulation techniques.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Proper <span class="No-Break">string pooling</span></li>
				<li><span class="No-Break">Lazy initialization</span></li>
				<li>Additional string <span class="No-Break">operation strategies</span></li>
			</ul>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, please refer back to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter07</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Proper string pooling</h1>
			<p>Our overarching concern<a id="_idIndexMarker330"/> is to ensure that our Java applications perform at a high level. To that end, memory management is a critical concern. It is important that we design, test, and implement techniques for optimizing memory usage. <strong class="bold">String pooling</strong> is one such technique, whose focus is to enable the reuse of string objects for greater application efficiency. The efficiency gains stem from reducing <span class="No-Break">memory overhead.</span></p>
			<p>String pooling is an important concept that is anchored to the sharing of string values as an alternative to creating new string instances. If your application uses string literals frequently, then you should find string pooling <span class="No-Break">especially useful.</span></p>
			<p class="callout-heading">String literal</p>
			<p class="callout">A string literal is a fixed value<a id="_idIndexMarker331"/> bookended by double quotes. For example, the <strong class="source-inline">"Read more books."</strong> component of the following statement is a <span class="No-Break">string literal:</span></p>
			<p class="callout"><strong class="source-inline">System.out.println("Read </strong><span class="No-Break"><strong class="source-inline">more books.");</strong></span></p>
			<p>To examine string pooling, we <a id="_idIndexMarker332"/>will start with the concept of <strong class="bold">string interning</strong>, then review best practices, and complete our discovery with code examples using Java. To take this concept one step further, we will look at string pooling for <span class="No-Break">database queries.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>String interning</h2>
			<p>String interning is an interesting<a id="_idIndexMarker333"/> concept. It is a memory reduction technique that allows more than one string to use the same memory location. As you might expect, the contents of those strings must be identical for this to work. Memory reduction is possible because we can eliminate duplicate objects. String interning relies on string pooling for this to work. As we covered in <a href="B21942_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, pooling uses a special heap area to store the <span class="No-Break">string literals.</span></p>
			<p>Let’s try to think like the <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>) does. When a string<a id="_idIndexMarker334"/> literal is encountered by the JVM, it first checks to see whether it is in the string pool. If it is not found, then the JVM creates the new string object and stores it on the heap. If the string literal is already on the heap, the JVM simply returns a reference to the existing object. In Java, we use the <strong class="source-inline">intern()</strong> method, part of the <strong class="source-inline">String</strong> class, to accomplish this. We will look at an example later in the <em class="italic">Code examples</em> section<a id="_idIndexMarker335"/> of <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Best practices</h2>
			<p>In general, it is considered<a id="_idIndexMarker336"/> a good idea to employ string interning in our applications. When implementing string interning, there are two important considerations to be aware of. First, we should not overuse string interning. The performance and memory usage benefits are clear, but if our applications use interning on very large strings, then we might consume more memory than we <span class="No-Break">want to.</span></p>
			<p>Another best practice<a id="_idIndexMarker337"/> to consider is avoiding <strong class="bold">implicit interning</strong>. As we learned from our JVM discussion earlier, string literals are automatically interned by the JVM when they are hardcoded. Dynamically created strings, on the other hand, are usually not automatically interned. When we want to be explicit in our interning, we need to use the <strong class="source-inline">intern()</strong> method. This way, we can ensure consistent behavior in <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Code examples</h2>
			<p>Let’s look at a simple<a id="_idIndexMarker338"/> example to demonstrate string interning. The following code starts by defining two string literals, <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>. Both strings have the same values. A third string, <strong class="source-inline">s3</strong>, is created using the <strong class="source-inline">intern()</strong> method. The final two statements are used to <span class="No-Break">compare references:</span></p>
			<pre class="source-code">
public class CorgiStringIntern {
    public static void main(String[] args) {
        String s1 = "corgi";
        String s2 = "corgi";
        String s3 = new String("corgi").intern();
        System.out.println("Are s1 and s2 the same object? " + (s1 == 
        s2));
        System.out.println("Are s1 and s3 the same object? " + (s1 == 
        s3));
    }
}</pre>			<p>As you can see from our application’s output, both <a id="_idIndexMarker339"/>reference comparisons are evaluated <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Are s1 and s2 the same object? true
Are s1 and s3 the same object? true</pre>			<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/>String pooling for database queries</h2>
			<p>SQL and other database queries<a id="_idIndexMarker340"/> are often created dynamically <a id="_idIndexMarker341"/>in our code and can become quite complex. As with other large strings, we can use string pooling to help ensure that our application does not unnecessarily create string objects. Our goal is to reuse any commonly used database queries instead of recreating them multiple times <span class="No-Break">at runtime.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Lazy initialization</h1>
			<p>The decision to not instantiate<a id="_idIndexMarker342"/> an object until it is needed is called <strong class="bold">lazy initialization</strong>. The word <em class="italic">lazy</em> normally has a negative connotation; however, in the context of software development, lazy initialization is a performance optimization approach with the goal of managing an application’s overhead. This design pattern is especially useful when detailing very <span class="No-Break">large objects.</span></p>
			<p class="callout-heading">Should I implement lazy initialization?</p>
			<p class="callout">If you have string objects that are large or complex and require significant overhead at initialization time, then you should consider <span class="No-Break">lazy initialization.</span></p>
			<p>Lazy initialization does not reduce the number of string objects created; rather, it delays the initialization until it is required by your application for processing. This delaying technique can help you with memory optimization. Let us look at a narrative example before we examine the <span class="No-Break">source code.</span></p>
			<p>Imagine you have a legacy application that uses very sophisticated string objects. When your application opens, a loading screen is displayed and, behind the scenes, the application creates several string objects to support the application’s normal operations. Users have complained that the application “takes forever to load” and that the computer often locks up when trying to launch the application. After reviewing the source code, you realize that many of the string objects created when the application is launched are only used by the application<a id="_idIndexMarker343"/> when the user selects certain functions. Your solution is to implement lazy initialization, so these string objects are only created when and if they <span class="No-Break">are needed.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Code examples</h2>
			<p>Now, let us look at how<a id="_idIndexMarker344"/> we can implement the lazy initialization design pattern in Java. We will start by importing <strong class="source-inline">java.util.function.Supplier</strong>. It is an interface that provides a single <strong class="source-inline">get()</strong> method, which we will use to retrieve <span class="No-Break">a value:</span></p>
			<pre class="source-code">
import java.util.function.Supplier;</pre>			<p>Next, we declare our class and use <strong class="source-inline">StringBuilder</strong> to generate a complex string using the <strong class="source-inline">append()</strong> method <span class="No-Break">multiple times:</span></p>
			<pre class="source-code">
public class LazyInitializationExample {
  private Supplier&lt;String&gt; lazyString = () -&gt; {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Java is an incredibly ");
    stringBuilder.append("flexible programming language ");
    stringBuilder.append("that is used in a wide range of 
    applications. ");
    stringBuilder.append("This is a complex string ");
    stringBuilder.append("that was lazily initialized.");
    return stringBuilder.toString();
};</pre>			<p>Staying inside the <strong class="source-inline">LazyInitializationExample</strong> class, we make a call to the <strong class="source-inline">getLazyString()</strong> method. This method is used to create or retrieve the complex string only when it is needed – <span class="No-Break">not before:</span></p>
			<pre class="source-code">
public String getLazyString() {
  return lazyString.get();
}</pre>			<p>The last part of our code<a id="_idIndexMarker345"/> is the <strong class="source-inline">main()</strong> method. When this method is run, we access the lazily <span class="No-Break">initialized string:</span></p>
			<pre class="source-code">
  public static void main(String[] args) {
    LazyInitializationExample example = new 
    LazyInitializationExample();
    String lazyString = example.getLazyString();
    System.out.println("Lazily initialized string: " + lazyString);
  }
}</pre>			<p>The output of the program is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Lazy-initialized string: Java is an incredibly flexible programming language that is used in a wide range of applications. This is a complex string that was lazily initialized.</pre>			<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Best practices</h2>
			<p>The concept of lazy initialization<a id="_idIndexMarker346"/> is straightforward and the decision to implement it is easy. If you have large string objects, then you should try this approach. There are two best practices to consider with lazy initialization. First, we should implement synchronization when we are working in a multiple-thread environment. This is to help<a id="_idIndexMarker347"/> promote thread safety. Another best practice is to avoid overuse. When we overuse lazy initialization, our code might become difficult to read <span class="No-Break">and maintain.</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>Additional string operation strategies</h1>
			<p>String pooling and lazy initialization<a id="_idIndexMarker348"/> are excellent optimization strategies that can help improve the overall performance of our Java applications. In addition to these strategies, we can ensure that our string concatenation operations are efficient, that we properly leverage regular expressions, and that we efficiently handle large text files. This section reviews techniques in each of <span class="No-Break">those areas.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor139"/>Concatenation</h2>
			<p>String concatenation – the joining<a id="_idIndexMarker349"/> of two or more strings into one – using the plus (<strong class="source-inline">+</strong>) operator often results in inefficient code. This concatenation creates a new string object, which we want to avoid. Let’s look at two alternatives that offer <span class="No-Break">better performance.</span></p>
			<p>This first alternative uses <strong class="source-inline">StringBuilder</strong>. In the following example, we create a <strong class="source-inline">StringBuilder</strong> object, append five string literals to it, convert the <strong class="source-inline">StringBuilder</strong> object to <strong class="source-inline">String</strong>, and then output <span class="No-Break">the results:</span></p>
			<pre class="source-code">
public class ConcatenationAlternativeOne {
  public static void main(String[] args) {
    StringBuilder myStringBuilder = new StringBuilder();
    myStringBuilder.append("Java");
    myStringBuilder.append(" is");
    myStringBuilder.append(" my");
    myStringBuilder.append(" dog's");
    myStringBuilder.append(" name.");
    String result = myStringBuilder.toString();
    System.out.println(result);
  }
}</pre>			<p>Another alternative is to use <strong class="source-inline">StringBuffer</strong>. The following program is similar to our <strong class="source-inline">StringBuilder</strong> example<a id="_idIndexMarker350"/> but uses <strong class="source-inline">StringBuffer</strong> instead. As you can see, both methods are implemented in the <span class="No-Break">same manner:</span></p>
			<pre class="source-code">
public class ConcatenationAlternativeTwo {
  public static void main(String[] args) {
    StringBuffer myStringBuffer = new StringBuffer();
    myStringBuffer.append("Java");
    myStringBuffer.append(" is");
    myStringBuffer.append(" my");
    myStringBuffer.append(" dog's");
    myStringBuffer.append(" name.");
    String result = myStringBuffer.toString();
    System.out.println(result);
  }
}</pre>			<p>The difference between the <strong class="source-inline">StringBuilder</strong> and <strong class="source-inline">StringBuffer</strong> alternatives to string concatenation is that <strong class="source-inline">StringBuffer</strong> offers us thread safety, so it should be used in multiple-thread environments; otherwise, <strong class="source-inline">StringBuilder</strong> is an alternative to using the plus (<strong class="source-inline">+</strong>) operator for <span class="No-Break">string</span><span class="No-Break"><a id="_idIndexMarker351"/></span><span class="No-Break"> concatenation.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Regular expressions</h2>
			<p><strong class="bold">Regular expressions</strong> provide us with an excellent<a id="_idIndexMarker352"/> method of pattern matching<a id="_idIndexMarker353"/> as well as string manipulation. Because these expressions can be processor- and memory-intensive, it is important to learn how to use them efficiently. We can optimize the use of regular expressions by compiling our patterns only once and reusing them <span class="No-Break">as needed.</span></p>
			<p>Let’s look at an example. In the first part of our application, we import the <strong class="source-inline">Matcher</strong> and <span class="No-Break"><strong class="source-inline">Pattern</strong></span><span class="No-Break"> classes:</span></p>
			<pre class="source-code">
import java.util.regex.Matcher;
import java.util.regex.Pattern;</pre>			<p>Next, we establish our email <span class="No-Break">pattern regex:</span></p>
			<pre class="source-code">
public class GoodRegExExample {
  public static void main(String[] args) {
    String emailRegex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]
    {2,}$";</pre>			<p>This next section of code creates a list of sample email addresses. We will later check these <span class="No-Break">for validity:</span></p>
			<pre class="source-code">
String[] emails = {
  "java@example.com",
  "muzz.acruise@gmail.com",
  "invalid-email",
  "bougie@.com",
  "@example.com",
  "brenda@domain.",
  "edward@domain.co",
  "user@example"
};</pre>			<p>The next statement compiles the <span class="No-Break">regex pattern:</span></p>
			<pre class="source-code">
Pattern pattern = Pattern.compile(emailRegex);</pre>			<p>This last section of code iterates<a id="_idIndexMarker354"/> through each email<a id="_idIndexMarker355"/> address in <span class="No-Break">our list:</span></p>
			<pre class="source-code">
    for (String email : emails) {
      Matcher matcher = pattern.matcher(email);
      if (matcher.matches()) {
        System.out.println(email + " is a valid email address.");
      } else {
        System.out.println(email + " is an invalid email address.");
      }
    }
  }
}</pre>			<p>This simple implementation of regular expression checks for email address formatting and demonstrates how to compile the regex pattern once and use it elsewhere in the application as an efficient alternative to compiling the pattern each time we need to perform the email address <span class="No-Break">validation operation.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Large text files</h2>
			<p>Some Java applications<a id="_idIndexMarker356"/> can process very large text files, even book-length files. It is not advisable to load the file’s complete content at one time. Our applications can quickly run out of available memory and cause undesirable runtime results. An alternative is to use a buffered approach to read the text files <span class="No-Break">in segments.</span></p>
			<p>The following example assumes that there is a text file in the local directory. We read each line <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">BufferedReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
public class LargeTextFileHandlingExample {
  public static void main(String[] args) {
    String filePath = "advanced_guide_to_java.txt";
    try (BufferedReader reader = new BufferedReader(new 
    FileReader(filePath))) {
      String line;
      int lineCount = 0;
      while ((line = reader.readLine()) != null) {
        System.out.println("Line " + (++lineCount) + ": " + line);
      }
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}</pre>			<p>This approach can help us<a id="_idIndexMarker357"/> manage our memory and improve the overall performance of <span class="No-Break">our applications.</span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Summary</h1>
			<p>This chapter focused on how to create, manipulate, and manage strings to contribute to the overall performance of your Java applications. You should now understand string pooling and have the confidence to use it effectively based on best practices. Lazy initialization should now be a strategy you consider implementing in your future applications when dealing with the extensive use of strings and you are concerned about thread safety. The chapter also introduced advanced string operation strategies to help give you choices when designing your Java applications for <span class="No-Break">high performance.</span></p>
			<p>In the next chapter, <em class="italic">Memory Leaks</em>, we will look at what memory leaks are, how they are created, and what effects they have on our applications. We will look at strategies for avoiding memory leaks to improve the performance of our <span class="No-Break">Java applications.</span></p>
		</div>
	</body></html>