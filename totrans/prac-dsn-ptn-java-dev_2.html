<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-38" class="chapter-number"><a id="_idTextAnchor037"/>2</h1>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Discovering the Java Platform for Design Patterns</h1>
			<p>Many years ago, motivated by the lack of a suitable <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) design, something extraordinary began to happen. In the early days of using the <strong class="bold">World Wide Web</strong> (<strong class="bold">WWW</strong>), the direction of application development was a bit shrouded in fog. In one direction, there was a strong need in the industry to process a large number of database transactions or develop specific proprietary hardware and software. On the other hand, it was not clear what kind of applications might be needed to move the demand forward and how such an application should <span class="No-Break">be maintained.</span></p>
			<p>In this chapter, we will prepare the ground for understanding the value of design patterns from a memory utilization perspective. We will do so by covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>The rise of Java and brief <span class="No-Break">historical facts</span></li>
				<li>How the Java platform works under <span class="No-Break">the hood</span></li>
				<li>Exploring Java memory area allocation <span class="No-Break">and management</span></li>
				<li>How allocated heap is maintained with <span class="No-Break">garbage collection</span></li>
				<li>Running the first program on <span class="No-Break">the platform</span></li>
				<li>The threading nature of the <span class="No-Break">Java platform</span></li>
				<li>Examining the core Java APIs and their values for <span class="No-Break">software design</span></li>
				<li>Exploring the importance of the Java Platform <span class="No-Break">Module System</span></li>
				<li>Discovering new helpful <span class="No-Break">platform enhancements</span></li>
				<li>Introducing <span class="No-Break">Java concurrency</span></li>
			</ul>
			<p>By the end of the chapter, you will have a good understanding of memory allocation on the Java platform, platform guarantees, core APIs, and more. Together with the content of the previous chapter, these topics will form a well-prepared foundation so that you can start with design patterns with full awareness of <span class="No-Break">their benefits.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Technical requirements</h1>
			<p>The code files for this chapter are available on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter02</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Knocking on Java’s door</h1>
			<p>In the early 1990s, a<a id="_idIndexMarker054"/> small team at Sun Microsystems was formed in order to discover new horizons. The team started with the consideration of extending the C++ features available in those days. One of the goals was to introduce a new generation of software for a small smart device. The introduction of software reusability was a part of this. Small smart devices such as set-top boxes did not have much memory and had to use their resources wisely. The memory, among other things, such as its complexity, error-prone programs, and probably James Gosling’s language extension attempt, later led to the rejection of the C++ idea. Instead of struggling with C++, a new <a id="_idIndexMarker055"/>language called <strong class="bold">Oak</strong> was created in lieu. Due to the trademark issue, the newly created language Oak was <span class="No-Break">renamed Java.</span></p>
			<p>The first public Java version 1.0a.2, together with HotJava Browser, was announced at the SunWorld conference in 1995 by John Gage, the director of science at Sun Microsystems. He was involved in re-directing the Java language from being a language for small hardware devices to being a platform for WWW applications. In these early days, Java was used as part of a website using a technology known as an applet. Java applets were small sandboxes, defined by the frame with limited access and the capability to execute Java bytecode <a id="_idIndexMarker056"/>on the local <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>). Applets resided on a web browser or as a standalone application; they were a very powerful tool that supported one of the basic Java <a id="_idIndexMarker057"/>principles, <strong class="bold">Write Once, Run Anywhere</strong> (<strong class="bold">WORA</strong>). However, due to many issues (such as security and stability), the applet technology was marked for removal (Java <span class="No-Break">SE 17).</span></p>
			<p>The Java platform consists of three main parts (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18884_02_01.jpg" alt="Figure 2.1 ﻿– Java Development Kit architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Java Development Kit architecture</p>
			<p>These <a id="_idIndexMarker058"/>parts are <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">A JVM</span></li>
				<li>The <strong class="bold">Java SE (Standard Edition) Runtime </strong><span class="No-Break"><strong class="bold">Environment</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JRE</strong></span><span class="No-Break">)</span></li>
				<li>The <strong class="bold">Java SE Development </strong><span class="No-Break"><strong class="bold">Kit</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JDK</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Let us start an <a id="_idIndexMarker059"/>exciting<a id="_idIndexMarker060"/> journey through the platform itself and <span class="No-Break">each part.</span></p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Exploring the model and functionality of the Java platform</h1>
			<p>History has shown<a id="_idIndexMarker061"/> us that the intended direction can evolve or change: Java is a nice example and is no exception. From its original purpose, it has moved from a platform for smart devices to a platform for entire web solutions, but its development did not stop there. Over the years, Java has become one of the most widely used languages for application development. This can be taken as a side effect of basic hardware independence. It dramatically developed an available set of tools and received a very positive response from a <span class="No-Break">vibrant community.</span></p>
			<p>Let us review <a id="_idIndexMarker062"/>each part of the platform (from <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em>) individually as it will boost our understanding of <span class="No-Break">writing code.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>The JDK</h2>
			<p>The JDK is a <a id="_idIndexMarker063"/>software development environment that<a id="_idIndexMarker064"/> provides the tools and libraries needed to develop and analyze Java applications. The JDK provides a collection of basic libraries, functions, and programs needed to compile written code into bytecode. The JDK contains the JRE required to run the application. The JDK also provides some very useful tools, such as the <span class="No-Break">following examples:</span></p>
			<ul>
				<li><strong class="source-inline">jlink</strong>: This helps generate a <span class="No-Break">custom JRE</span></li>
				<li><strong class="source-inline">jshell</strong>: This is <a id="_idIndexMarker065"/>a handy <strong class="bold">Read-Evaluate-Print-Loop</strong> (<strong class="bold">REPL</strong>) tool to try the <span class="No-Break">Java language</span></li>
				<li><strong class="source-inline">jcmd</strong>: This is a utility to send a diagnostic command to the <span class="No-Break">active JVM</span></li>
				<li><strong class="source-inline">javac</strong>: This is the Java compiler, which reads an input file with the <strong class="source-inline">.java</strong> suffix and produces a Java class file with the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">class</strong></span><span class="No-Break"> suffix</span></li>
				<li><strong class="source-inline">java</strong>: This executes <span class="No-Break">a JRE</span></li>
				<li>Others: Located in the JDK <span class="No-Break"><strong class="source-inline">bin</strong></span><span class="No-Break"> directory</span></li>
			</ul>
			<p>The code is written (<em class="italic">Example 2.1</em>) and stored in a <strong class="source-inline">.java</strong> file and compiled using the <span class="No-Break"><strong class="source-inline">javac</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
public class Program {
    public s<a id="_idTextAnchor043"/>tatic void main(String... args){
        System.out.println("Hello Program!");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.1 – Simple Java program as an executable class that can also be run directly without a compilation step since Java SE 11 (<em class="italic">Reference 26</em>)</p>
			<p>Next, it is possible to create and compile a class with bytecode inside (<em class="italic">Example 2.2</em>). Run the file <a id="_idIndexMarker066"/>using the <strong class="source-inline">java</strong> command to <a id="_idIndexMarker067"/>run <span class="No-Break">the JRE:</span></p>
			<pre class="console">
...
public static void main(java.lang.String...);
descriptor: ([Ljava/lang/String;)V
flags: (0x0089) ACC_PUBLIC, ACC_STATIC, ACC_VARARGS
Code:
stack=2, locals=1, args_size=1
        0: getstatic     #7      // Field java/lang/
            System.out:Ljava/io/PrintStream;
        3: ldc           #13       // String Hello Program!
...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.2 – Bytecode example from a compiled program displayed by the Java program</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>The JRE</h2>
			<p>The JRE is <a id="_idIndexMarker068"/>part of the JDK, or it can be distributed<a id="_idIndexMarker069"/> as a standalone program for the target operating system. To run a file with a <strong class="source-inline">.class</strong> extension<a id="_idIndexMarker070"/> or a <strong class="bold">Java Archive</strong> (<strong class="bold">JAR</strong>) file, the target system is required to contain the appropriate version of the JRE. Unlike the JDK, the JRE only contains a minimal collection of components needed to run the program, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Core libraries and property files: for example, <strong class="source-inline">rt.jar</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">charset.jar</strong></span></li>
				<li>Java extension files: Additional libraries that may reside in the <span class="No-Break"><strong class="source-inline">lib</strong></span><span class="No-Break"> folder</span></li>
				<li>Security-related files: Certificates, policies, and <span class="No-Break">so on</span></li>
				<li><span class="No-Break">Font files</span></li>
				<li>Operating <span class="No-Break">system-specific tools</span></li>
			</ul>
			<p>The JRE<a id="_idIndexMarker071"/> includes a JVM and precisely two types <span class="No-Break">of compilers:</span></p>
			<ul>
				<li><strong class="bold">Client Compiler</strong>: Fast <a id="_idIndexMarker072"/>loading<a id="_idIndexMarker073"/> without optimization. It is designed to run the instructions to obtain a result very quickly. Commonly used for <span class="No-Break">standalone programs.</span></li>
				<li><strong class="bold">Server Compiler</strong>: Loaded <a id="_idIndexMarker074"/>code goes through additional checks to ensure code stability. There is also an effort to produce highly optimized machine code to deliver better performance. It supports better statistics in order <a id="_idIndexMarker075"/>to run machine code optimization executed by the <strong class="bold">Just-in-Time</strong> (<strong class="bold">JIT</strong>) compiler (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></li>
			</ul>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>The JVM</h2>
			<p>Both the JDK<a id="_idIndexMarker076"/> and the JRE contain the JVM (<em class="italic">Reference 6</em>). The<a id="_idIndexMarker077"/> JVM is platform-dependent. This means that every system platform requires the use of a dedicated version. Fine, but what does the JVM really do, <span class="No-Break">and how?</span></p>
			<p>Although there are multiple versions of the JVM, even from multiple vendors, the JVM itself is defined by a specification that must be followed. The reference implementation is represented by OpenJDK. In fact, OpenJDK is a collection of several smaller open source projects that may even have different development dynamics, but the OpenJDK release contains planned versions <span class="No-Break">of each.</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B18884_02_02.jpg" alt="Figure 2.2 – Key parts of the JVM"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Key parts of the JVM</p>
			<p>The OpenJDK JVM<a id="_idIndexMarker078"/> implementation (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>) includes <a id="_idIndexMarker079"/>a JIT compiler<a id="_idIndexMarker080"/> called <strong class="bold">HotSpot</strong> (<em class="italic">Reference 7</em>). HotSpot is part of the JVM and its responsibility is runtime compilation. In other words, the JIT compiler translates or compiles the provided bytecode into a native system instruction at runtime. This process is sometimes<a id="_idIndexMarker081"/> called <strong class="bold">dynamic translation</strong>. Due to these JVM dynamic translation capabilities, Java applications are sometimes referred to as system platform-independent and the WORA acronym is used. This statement needs to be abstracted slightly because a JVM system implementation is required to translate the bytecode into a <span class="No-Break">native instruction.</span></p>
			<p>In addition to the JVM JIT compiler, it includes a garbage collector with various algorithms, a class loader, a Java memory implementation model, and a <strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>) with<a id="_idIndexMarker082"/> libraries (as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
			<p>Every JVM provider must follow the specifications. This guarantees that the bytecode will not only be created accordingly but also executed and correctly converted into machine instructions. This means that different vendors may provide different JVM implementations with slightly different metrics or optimizations, such as garbage collector dynamics. These vendors include IBM, Azul, Oracle, and so on. The diversity of vendors can be considered one of the main moving factors for the Java platform's evolution. New features <a id="_idIndexMarker083"/>are extended or modified <a id="_idIndexMarker084"/>through the <strong class="bold">JDK Enhancement Proposal</strong> (<strong class="bold">JEP</strong>), where <a id="_idIndexMarker085"/>each vendor can contribute or get a very <span class="No-Break">detailed overview.</span></p>
			<p>To summarize, the<a id="_idIndexMarker086"/> JVM’s responsibilities to remember are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Loading linking</span></li>
				<li>Initiating classes <span class="No-Break">and interfaces</span></li>
				<li>Program <span class="No-Break">instruction execution</span></li>
			</ul>
			<p>The JVM defines several different areas used by each program (<em class="italic">Example 2.2</em>). Let’s look at each of them one by one, area by area (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). This can boost our understanding of the value of design patterns and their approaches, such as the Builder or <span class="No-Break">Singleton pattern.</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B18884_02_03.jpg" alt="Figure 2.3 – Simplified schema of program compilation and execution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Simplified schema of program compilation and execution</p>
			<p>It all starts with written text, representing a program stored in a <strong class="source-inline">.java</strong> file. The file will be <a id="_idIndexMarker087"/>compiled (<em class="italic">Figures 2.3</em>) and run (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>) and <a id="_idIndexMarker088"/>threads are started. Startup starts the system process in which the JRE is running and the JVM is running as part of <span class="No-Break">the JRE.</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B18884_02_04.jpg" alt="Figure 2.4 – Threads﻿ that started behind the scene event for a Program.java execution example (Java Flight Recorder)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Threads that started behind the scene event for a Program.java execution example (Java Flight Recorder)</p>
			<p>With a general idea of the flow, let’s start by loading classes <span class="No-Break">into memory.</span></p>
			<h3>The class-loader loader area</h3>
			<p>The class <a id="_idIndexMarker089"/>loader<a id="_idIndexMarker090"/> subsystem is located in <strong class="bold">Random-Access Memory</strong> (<strong class="bold">RAM</strong>) and is responsible for loading classes into memory. The<a id="_idIndexMarker091"/> load step consists of the sub-line steps and the first run of the class at runtime. Linking is the process of preparing a class or interface for a runtime environment, which may include internal dependencies, for example. The platform provides internal functions or customized ones; to manage all these capabilities, the platform provides dedicated <span class="No-Break">class loaders:</span></p>
			<ul>
				<li><strong class="bold">Bootstrap class loader</strong>: Responsible <a id="_idIndexMarker092"/>for loading the default platform classes. It is provided by JVM and loads classes from the <span class="No-Break"><strong class="source-inline">BOOTPATH</strong></span><span class="No-Break"> (property).</span></li>
				<li><strong class="bold">Extension class loader</strong>: Loads the <a id="_idIndexMarker093"/>additional libraries from the <strong class="source-inline">lib/ext</strong> directory, which is a part of the <span class="No-Break">JRE installation.</span></li>
				<li><strong class="bold">System class loader</strong>: The <a id="_idIndexMarker094"/>default application class loader that refers to the <strong class="source-inline">main</strong> method and runs the classes from the served class or <span class="No-Break">module path.</span></li>
				<li><strong class="bold">User-defined class loaders</strong>: These <a id="_idIndexMarker095"/>are instances of <strong class="source-inline">ClassLoader</strong> and may be used to define custom classes dynamically loading processes to the JVM. It is possible to use a user-defined class destination. Classes can reside on the network, be encrypted inside files, or be downloaded across the network and generated on <span class="No-Break">the fly.</span></li>
			</ul>
			<p>Class loaders work in sequence. The sequence is represented by a hierarchy. This means that every child must refer to its parents. This automatically defines the search order of the <span class="No-Break">binary classes.</span></p>
			<p>When a class is present in RAM, the Java platform takes action to make the class available to the runtime environment. The Java platform runs several processes behind the scenes to move relevant class data to other areas, such as the stack, heap, and so on. Let’s look at the stack <span class="No-Break">area next.</span></p>
			<h3>The stack area</h3>
			<p>The stack<a id="_idIndexMarker096"/> area (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>) is reserved for each thread<a id="_idIndexMarker097"/> at runtime. This is a small area for storing method references. When a thread executes a method, one entry for that method is created and moved to the top of the stack. This kind of item is called a stack frame, which has a reference to a field of local variables, a stack of operands, and a constant pool to identify the appropriate method. The stack frame is removed when the method is executed normally – that is, without causing any exceptions. This means that local primitive variables such as <strong class="source-inline">boolean</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">double</strong> are also stored here, so they are not visible to the second thread. Each thread can pass a copy, but this does not share <span class="No-Break">the origin.</span></p>
			<h3>The heap area</h3>
			<p>The heap is the<a id="_idIndexMarker098"/> allocated memory where all instances <a id="_idIndexMarker099"/>of the class and array are located. The heap is allocated at startup and is shared among all JVM-initiated threads. Allocated memory is automatically recovered by the automated management system process, also known as <strong class="bold">Garbage Collection</strong> (<strong class="bold">GC</strong>). A local<a id="_idIndexMarker100"/> variable can contain a reference to objects. The referenced object is located in <span class="No-Break">a heap.</span></p>
			<h3>The method area</h3>
			<p>The method <a id="_idIndexMarker101"/>area is shared across all JVM-initiated<a id="_idIndexMarker102"/> threads. The area is allocated during the JVM startup time. It contains runtime data for each class, such as a constant pool, field and method data, the code for constructors, and methods. Probably the most unfamiliar term mentioned is the constant pool. The constant pool is created during the process of loading the class into the method area. It contains the initial values of string and primitive constants, the names of the reference classes and other data needed to properly execute the loaded class, the constants known at compile time, and field references that must be resolved <span class="No-Break">at runtime.</span></p>
			<h3>Program counter</h3>
			<p>The <strong class="bold">Program Counter</strong> (<strong class="bold">PC</strong>) register <a id="_idIndexMarker103"/>is another<a id="_idIndexMarker104"/> important reserved area in memory. It contains a list of created program counters. A PC record is created at the beginning of each thread and contains the address of the currently executed instruction by a specific thread. The address points back to the method area. The only exception is the native method, which leaves <a id="_idIndexMarker105"/>the <span class="No-Break">address </span><span class="No-Break"><a id="_idIndexMarker106"/></span><span class="No-Break">undefined.</span></p>
			<h3>The native method stack</h3>
			<p>A native method<a id="_idIndexMarker107"/> stack record is initiated for <a id="_idIndexMarker108"/>each individual thread. Its function is to provide access to native methods through the JNI. The JNI operates with the underlying system resources. Improper usage may turn into two <span class="No-Break">exceptional states:</span></p>
			<ul>
				<li>The first exception appears when a thread requires more stack space. In this case, a <strong class="source-inline">StackOverflowError</strong> error is thrown and the program crashes, executed with a state higher <span class="No-Break">than 1.</span></li>
				<li>The second case represents an attempt to add more entries to the stack. The program results in an <strong class="source-inline">OutOfMemoryError</strong> error. It is caused by an attempt to dynamically expand already fully allocated memory space. The memory is insufficient and it is not possible to allocate a new stack for the newly <span class="No-Break">intended thread.</span></li>
			</ul>
			<p>We have examined all the areas required to load and execute a program and we will get acquainted with the areas where the data is located and how they are interconnected. It is slowly becoming clear that in order to achieve stability and maintainability of the program at runtime, it is necessary to design the software in a way that reflects the potential limitations, as the reserved areas correspond to the <span class="No-Break">individual areas.</span></p>
			<p>Let’s take a closer look at how the Java platform provides available memory space for each newly <span class="No-Break">created object.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor046"/>Reviewing GC and the Java memory model</h1>
			<p>We mentioned<a id="_idIndexMarker109"/> the<a id="_idIndexMarker110"/> JIT compiler as part of the JVM earlier (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). Just to refresh on the JIT compiler, it is responsible for translating the bytecode into system-specific native instructions. These instructions deal with the basic memory and I/O resources available to the program. To properly organize these instructions, the Java platform requires a set of rules that guarantee the program, called bytecode, which must be translated by the JIT compiler at runtime to the same end. Because the Java platform does not use physical memory directly, but rather virtual and cached views, it is very important that the memory management is transparent. The model must provide the required <a id="_idIndexMarker111"/>guarantees <a id="_idIndexMarker112"/>and is known as the <strong class="bold">Java Memory </strong><span class="No-Break"><strong class="bold">Model</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JMM</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>The JMM</h2>
			<p>The JMM <a id="_idIndexMarker113"/>describes how threads interact with each other through access to allocated memory – the heap (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). The execution of a single-threaded program may seem obvious because the instructions are processed in a certain order without external influence and the thread is in isolation. In the case of a single thread (see the <strong class="source-inline">main</strong> method in <em class="italic">Example 2.2</em> and the <strong class="source-inline">main</strong> thread in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>), the run areas are modified each time the instruction is executed; there is no surprise. The situation changes when the program starts multiple threads. The JMM enforces its guarantees of reliable Java program execution. The JMM defines a set of rules for possible instruction order changes and execution restrictions caused by sharing objects in memory between different threads. The fact that the JMM strictly follows these rules forces JIT optimization without fear of code instability (maintaining a <span class="No-Break">consistent state).</span></p>
			<p>The rules can easily be reformulated and each action can be changed as long as the execution of the thread does not violate the program order. Basically, this means that the program remains in a <span class="No-Break">consistent state.</span></p>
			<p>Object locks or releases are governed by the order of the program and each thread shares a corresponding memory view of the modified data. The memory view represents the portion of allocated physical memory represented by the heap because each object created is located inside <span class="No-Break">the heap.</span></p>
			<p>One of the important guarantees of the JMM is known as happens-before. It states that one action always happens before another in order to maintain the order of the program. To better understand this rule, it is necessary to describe how system memory works and briefly introduce the general types of memory and how the CPU fits into the process of reading values and executing <span class="No-Break">machine instructions.</span></p>
			<p>Let us start with the CPU. Each CPU contains its own instruction register. The machine code compiled by the JIT compiler has a reference to an available set of instructions. The CPU contains an internal cache used to store a copy of data from the main RAM. The CPU communicates with the reserved RAM. One CPU can run multiple platform threads (depending on the type of CPU) at the same time. The result of this embodiment modifies the state of the RAM in the thread stack or heap. The dedicated RAM for the running Java application is then copied to the CPU cache and used by the CPU registry (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B18884_02_05.jpg" alt="Figure 2.5 – CPU and memory interaction"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – CPU and memory interaction</p>
			<p>Those who<a id="_idIndexMarker114"/> are attentive may have already noticed that due to memory differentiation, the program can face unpredictable difficulties caused by looking at the program’s memory. When multiple threads try to update or read specific values of variables without careful handling, this can result in one of the <span class="No-Break">following problems:</span></p>
			<ul>
				<li><strong class="bold">A racing condition</strong>: This occurs when two threads attempt to access the same value in an <span class="No-Break">unsynchronized manner.</span></li>
				<li><strong class="bold">Value update visibility</strong>: A variable update that is shared between multiple threads has not been propagated to the main memory, so other threads get the <span class="No-Break">old value.</span></li>
			</ul>
			<p>To address these challenges, let’s analyze a real access to variables. What is already known is that each value is located within the allocated RAM heap. It seems obvious that updating the status of each variable may cause some penalties, as each instruction has to take a whole journey (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.5</em>). In most cases, this is also not necessary. A good example is the implementation of an isolated method (<em class="italic">Example 2.2</em>). However, there are cases where the actual value of a variable is required from memory, for which the Java platform has introduced the <strong class="source-inline">volatile</strong> keyword. Using the <strong class="source-inline">volatile</strong> keyword before a variable gives the variable a guarantee that when another thread requests a value, it checks its current value in the main memory. This means that using the <strong class="source-inline">volatile</strong> keyword provides a guarantee of happens-before and each thread sees its true value. It is fair to note that because using <strong class="source-inline">volatile</strong> provides a certain level of memory synchronization, it should be used wisely. Its use is associated with performance limitations caused by main <span class="No-Break">memory access.</span></p>
			<p>Another approach to sharing variable values across multiple threads is to use the <strong class="source-inline">synchronized</strong> keyword. Its use gives the method or variable a guarantee that each participant, the thread, will be informed about the approaches. Obviously, the main disadvantage of using <strong class="source-inline">synchronized</strong> is that all threads will be informed about access to the method or variables, which in turn, will cause a decrease in performance due to memory synchronization. As with <strong class="source-inline">volatile</strong>, <strong class="source-inline">synchronized</strong> <span class="No-Break">guarantees happens-before.</span></p>
			<p>The JMM is bright and fresh; we stated that each new object is located in the heap (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). We are familiar with the big picture of the JRE architecture, and we know that most Java <a id="_idIndexMarker115"/>programs seem to be multi-threaded – there is a set of rules that the Java platform follows so that the process forces the correct order of programs to <span class="No-Break">achieve consistency.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor048"/>GC and automatic memory management</h2>
			<p>Although<a id="_idIndexMarker116"/> the Java <a id="_idIndexMarker117"/>platform may give the impression that the underlying memory is unlimited, this is not true and we will examine it next. So far, we have looked at how variable visibility works across multiple threads and how values are referenced in physical memory. The JMM is just one part of the whole story – let’s continue <span class="No-Break">the investigation.</span></p>
			<p>We already know that the Java platform uses an automatic memory management process to maintain the allocated memory for the heap. Part of the process is a program that runs in the background of the daemon thread. It is called the garbage collector (<em class="italic">Reference 5</em>) and runs silently behind the scenes, reclaiming and compacting unused memory. This is one of the advantages of the dynamic allocation of objects in the heap. Another perhaps less obvious advantage is the ability to work with recursive data structures, such as lists <span class="No-Break">or maps.</span></p>
			<p>GC was invented around 1959 by John McCarthy. The goal was to simplify manual memory management in Lisp. Since then, GC has undergone massive development and various GC techniques have been invented (<em class="italic">Reference 1</em>). Even after the development of various GC approaches, the security rule remains the most important. The GC should never regain a repository of live objects that contain <span class="No-Break">active references.</span></p>
			<p>Although the developer does not have to bother with memory reclamation, it can be very useful to understand the underlying process to avoid unexpected application failures because system memory is limited in one way or another. The reason remains that even if the GC is in place, it is possible to create code that never loads the object, which means that the application may crash with an <span class="No-Break"><strong class="source-inline">OutOfMemoryError</strong></span><span class="No-Break"> error.</span></p>
			<p>The goal of the GC process is to keep the heap nice and shiny, ready to allocate a new object. The<a id="_idIndexMarker118"/> heap <a id="_idIndexMarker119"/>area is divided into smaller segments as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18884_02_06.jpg" alt="Figure 2.6 – Simplified heap structure divided into promotion segments"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Simplified heap structure divided into promotion segments</p>
			<p>It is a known fact that most objects will be allocated and placed in Eden’s memory and will not survive the second round of cleanup. After performing Minor GC, all surviving objects are moved to one of the surviving spaces (denoted by <strong class="bold">S0</strong> and <strong class="bold">S1</strong>). The secondary GC round also checks the <strong class="bold">S0</strong> and <strong class="bold">S1</strong> fields and spreads them among the others at a time when one of the survival sites may be empty. The object survived; many Minor GCs have been moved to the <strong class="bold">Old generation</strong>. The heap also contains a permanent section. The permanent section contains the metadata required by the JVM to describe classes, static methods, and private variables, and is populated at runtime. This area was formerly<a id="_idIndexMarker120"/> known as the <strong class="bold">Permanent generation</strong> (<strong class="bold">Permgen</strong>). It was separated from the main heap memory, was not loaded, and had to be configured. This disadvantage often led to application instability due to insufficient memory requirements. Java SE 8 introduced MetaSpace, which replaced the Permgen concept. MetaSpace has solved the problem of space configuration because it can grow automatically and in addition, garbage can <span class="No-Break">be collected.</span></p>
			<p>GC works essentially in two steps, described as Minor and Major GC. These steps are a proposal for building on the basis of durability – that is, <span class="No-Break">long-term references:</span></p>
			<ul>
				<li><strong class="bold">Minor GC</strong>: This<a id="_idIndexMarker121"/> happens when there is no reference to the object, the object is marked as unreachable, the Young generation area is reclaimed, and the memory can <span class="No-Break">be compacted.</span></li>
				<li><strong class="bold">Major/Full GC</strong>: An object that has survived several Minor GCs and has been moved to an Old generation heap area. After a long time, it does not refer to any other object, no other object refers to it, and it is ready to be deleted. Full GC is less common than Minor GC and there is a long <span class="No-Break">pause (stop-the-world).</span></li>
			</ul>
			<p>The GC process can <a id="_idIndexMarker122"/>be <a id="_idIndexMarker123"/>simplified with <span class="No-Break">three steps:</span></p>
			<ol>
				<li>In the first step, GC marks unreachable objects (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></li>
			</ol>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B18884_02_07.jpg" alt="Figure 2.7 – The first collection marking step identifies unused objects in the heap"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – The first collection marking step identifies unused objects in the heap</p>
			<ol>
				<li value="2">In the second step, the links are removed and the space is left free as it was (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18884_02_08.jpg" alt="Figure 2.8 – Freeing memory by deleting marked objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Freeing memory by deleting marked objects</p>
			<ol>
				<li value="3">The third step is called compacting (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.9</em>). It reorganizes the memory into larger parts, so when a program tries to allocate a larger object, space is ready for it. This makes memory allocation for all objects much faster not only due to the free space but also eliminates the need to scan a free <span class="No-Break">memory frame:</span></li>
			</ol>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B18884_02_09.jpg" alt="Figure 2.9 – Compacting freed memory to be able to allocate bigger objects in frames"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Compacting freed memory to be able to allocate bigger objects in frames</p>
			<p>With a fresh <a id="_idIndexMarker124"/>awareness <a id="_idIndexMarker125"/>of the tasks of the JMM and GC, there is another important concept related to both. The concept of reference types is a way to tell the platform how to handle a specific allocated part of the heap space – more specifically, how to help the platform’s internal analytical processes. Reference types have been added to help GC to evaluate the purpose of variables. This means speeding up the decision of whether to collect the variable or not. The concept of a reference type is a neat tool, along with a design pattern, and previously renewed themes make even more sense. The goal of every program is to run as fast as possible. This means that even the waste collection process causes pauses, so it must be as fast as possible. Hence, internal platform processes must also be as fast as possible. So, regardless of the GC algorithm used, when the dataset is small, the process will be much faster. There’s also a place for reference types to help keep the allocated memory fresh and clean. The platform offers the following types, sorted by their resilience <span class="No-Break">to GC:</span></p>
			<ul>
				<li><strong class="bold">Strong references</strong>: The most<a id="_idIndexMarker126"/> common type of reference – not required to <span class="No-Break">be specified.</span></li>
				<li><strong class="bold">Weak references</strong>: References need to<a id="_idIndexMarker127"/> be specified manually – <strong class="source-inline">var obj = new WeakReference&lt;Object&gt;();</strong> – and it’s a signal to the GC algorithm to reclaim memory during the next GC cycle. This is mostly used during a program initiation phase <span class="No-Break">or caching.</span></li>
				<li><strong class="bold">Soft references</strong>: These<a id="_idIndexMarker128"/> references are reclaimed only when the application is running out of memory. As long as there is no critical need for space, the object stays. The Java platform guarantees that all soft references are cleared before the <span class="No-Break"><strong class="source-inline">OutOfMemoryError</strong></span><span class="No-Break"> error.</span></li>
				<li><strong class="bold">Phantom reference</strong>: This represents<a id="_idIndexMarker129"/> the weakest type of reference. This team is collected as soon as possible, which means there is no further analysis or promotion to another level. A variable of this type is reclaimed immediately when the GC <span class="No-Break">cycle runs.</span></li>
			</ul>
			<p>Before embarking on the Java API journey, let’s quickly summarize our newly <span class="No-Break">acquired knowledge.</span></p>
			<p>References play an important role in the GC process. They tell garbage collectors how to handle a particular variable. The <a id="_idIndexMarker130"/>Java memory model provides the required<a id="_idIndexMarker131"/> guarantees as to how the value of a variable is read, updated, or deleted. We examined how values are stored in allocated memory, memory segmentation, and their relationship to the underlying system. All this new information helps us with better software design and <span class="No-Break">API usage.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor049"/>Examining the core Java APIs</h1>
			<p>The JDK provides <a id="_idIndexMarker132"/>a set of tools for creating, compiling, and running the required Java program. We learned how this program uses basic resources to provide the desired result. We have also examined a number of limitations that we must take into account when designing this kind of program. The JDK provides tools for software designers by making an internal collection of classes grouped into APIs available. The previous section explored how the JDK can be extended with external APIs that can be added on demand (discussed earlier in <em class="italic">The </em><span class="No-Break"><em class="italic">JRE</em></span><span class="No-Break"> section).</span></p>
			<p>In this section, we will discuss the most important basic APIs we use for design patterns <span class="No-Break">in detail.</span></p>
			<p>Java is an object-oriented language with many other features and extensions. The official basic <a id="_idIndexMarker133"/>Java API can be found in the <strong class="source-inline">java. *</strong> package (as listed in <span class="No-Break"><em class="italic">Table 2.1</em></span><span class="No-Break">).</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Sub-package</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.io.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Related to system I/O through data streams, serialization, <span class="No-Break">and filesystems</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.lang.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Automatically imported fundamental classes for the <span class="No-Break">Java language</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.math.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Classes related to the arbitrary precision arithmetic for integers (<strong class="source-inline">BigInteger</strong>) and <span class="No-Break">decimals (</span><span class="No-Break"><strong class="source-inline">BigDecimal</strong></span><span class="No-Break">)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.net.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>APIs related to network protocols <span class="No-Break">and communication</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.nio.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>An overview of buffer definitions as data containers and other <span class="No-Break">non-blocking packages</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.security.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Classes and interfaces for the Java <span class="No-Break">security framework</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.text.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides classes for handling formatted messages with texts, numbers, <span class="No-Break">and dates</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.time.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>APIs for calendars, dates, times, instants, <span class="No-Break">and durations</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">java.util.*</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Serves as a collection framework, string parsing, scanning classes, random number generator, Base64 encoders and decoders, and some miscellaneous utilities, among <span class="No-Break">other things</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – java.* packages available in Java 17 SE</p>
			<p>Every newly created class can automatically access public classes and interfaces that reside in the <strong class="source-inline">java.lang.*</strong> package from the <strong class="source-inline">java.base</strong> module. As everything is an object, it <a id="_idIndexMarker134"/>implies that each class has an <span class="No-Break"><strong class="source-inline">Object</strong></span><span class="No-Break"> instance.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>Primitive data types and wrappers</h2>
			<p>Java also <a id="_idIndexMarker135"/>provides a<a id="_idIndexMarker136"/> set of primitive types (<em class="italic">Reference 4</em>) called literals (<em class="italic">Table 2.2</em>). One difference between a literal and an <strong class="source-inline">Object</strong> instance is that each literal has a well-defined size in memory. In contrast, the size of the <strong class="source-inline">Object</strong> instance may vary depending on demand. The literal type of Java is signed, which is quite useful to remember if you are dealing with data <span class="No-Break">buffering operations.</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Size </strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Literal name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Range</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">bit (*)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">boolean</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">1 byte</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">byte</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>-128 <span class="No-Break">to 127</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">2 bytes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">short</strong> </p>
						</td>
						<td class="No-Table-Style">
							<p>-32,768 <span class="No-Break">to 32,767</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">2 bytes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">char</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>\u0000 <span class="No-Break">to \uffff</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">4 bytes</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>-2^31 <span class="No-Break">to 2^31-1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>4 bytes </p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>-3.4e38 <span class="No-Break">to 3.4e38</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>8 bytes </p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">long</strong> </p>
						</td>
						<td class="No-Table-Style">
							<p>-2^63 <span class="No-Break">to 2^63-1</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>8 bytes </p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>-1.7e308 <span class="No-Break">to 1.7e308</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.2 – Primitive types with their sizes; (*) boolean size is not precisely defined</p>
			<p>The primitive types reside in the stack area (refer to <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>) and each literal contains a wrapper object (<span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.10</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B18884_02_10.jpg" alt="Figure 2.10 – Data type wrapper inheritance﻿ with the literals with String type associations"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Data type wrapper inheritance with the literals with String type associations</p>
			<p>The envelope is initiated around literal values. This means that the literal is stored in the stack area<a id="_idIndexMarker137"/> and <a id="_idIndexMarker138"/>the wrapper object is located inside the heap. The cover provides additional features. Take the <strong class="source-inline">Integer</strong> class as an example, which provides the following methods: <strong class="source-inline">byteValue</strong>, <strong class="source-inline">doubleValue</strong>, and <strong class="source-inline">toString</strong>. These methods can be called within a specific design pattern to achieve the desired goal and avoid unnecessary memory contamination. This is in comparison to literals that only provide a native implementation of <span class="No-Break">a value.</span></p>
			<p>The Java platform automatically addresses the literal to the appropriate wrapper class and the like. This fact not only has a bright side but also has a dark side, known as an autoboxing issue (<em class="italic">Example 2.3</em>). This happens exactly when the primitive type is cast to a wrapper type. This can lead to very frequent waste collection, which can mean an enormous number of <span class="No-Break">stop-the-world events:</span></p>
			<pre class="source-code">
Int valueIntLiteral = 42;
Integer valueIntWrapper = valueIntLiteral;</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.3 – Auto-casting example where a new Integer wrapper is created under the hood</p>
			<p>When working with literal numbers, it is useful to keep in mind that a literal with a smaller byte size (<em class="italic">Table 2.2</em>) can be automatically assigned to a literal with a larger size (<em class="italic">Example 2.4</em>). The other way around, it causes a compilation error due to the precisely allocated byte size in the memory <span class="No-Break">stack area:</span></p>
			<pre class="source-code">
byte byteNumber = 1;
short shortNumber = byteNumber;
int intNumber = shortNumber;</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.4 – Literal automatic casting</p>
			<p>We have checked the numbering and how automatic submission works on the Java platform. A Boolean literal is <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> and is represented in memory as <span class="No-Break">1 bit.</span></p>
			<p>The last of<a id="_idIndexMarker139"/> the<a id="_idIndexMarker140"/> specific literals not yet mentioned is <strong class="source-inline">char</strong> and its cover character. Let’s take a closer look because it’s also related to the essential <span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break"> object.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor051"/>Working with the String API</h2>
			<p>The <strong class="source-inline">String</strong> instance<a id="_idIndexMarker141"/> is not literal. A string is represented as an<a id="_idIndexMarker142"/> object in Java. It is defined by a sequence of characters. It is almost impossible to avoid using a string to write any program. In addition to the fact that a Java executable requires a <strong class="source-inline">String</strong> field as input to the <strong class="source-inline">main</strong> method, variable names are also represented as a string. The string is immutable in Java. This means that any operation, such as concatenation, on its value will create a new string. More precisely, it is not possible to change its current value. A string is the base class of the <span class="No-Break">Java platform.</span></p>
			<p>A common way to store a string value is to use a String Pool. The String Pool only stores intrinsic values (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.11</em>). This means that it is only possible to have one different constant value present. This approach makes the pool more efficient in terms of memory, including time-consuming <span class="No-Break">string operations.</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B18884_02_11.jpg" alt="Figure 2.11 – The String Pool is a part of the heap memory and a String object resides in the heap ﻿like other objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – The String Pool is a part of the heap memory and a String object resides in the heap like other objects</p>
			<p>You can also store strings directly in the heap using the <strong class="source-inline">String</strong> constructor – for example, <strong class="source-inline">new String</strong>. In this case, the link is not to an equivalent value that is already present <a id="_idIndexMarker143"/>in the String Pool (represented by <strong class="source-inline">t3</strong> in <em class="italic">Example 2.5</em>) because<a id="_idIndexMarker144"/> it is located in a different heap memory space. If you force a search in pool strings, you can use the <strong class="source-inline">intern</strong> method (<strong class="source-inline">t4</strong> in <span class="No-Break"><em class="italic">Example 2.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
String t1="text1";
String t2="text1";
String t3= new String("text1");
String <a id="_idTextAnchor052"/>t4 = t3.intern();</pre>
			<p><span class="No-Break">Output:</span></p>
			<pre class="console">
1 == t2 =&gt; true
t1 == t3 =&gt; false
t3 == t4 =&gt; false
t1 == t4 =&gt; true</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.5 – Comparing different ways of assigning String values</p>
			<p>Using the <strong class="source-inline">+</strong> operator on String classes can turn into a very inefficient use of concatenation or program maintainability. To prevent String contamination, the Java platform provides the <strong class="source-inline">StringBuilder</strong> class as part of its APIs. <strong class="source-inline">StringBuilder</strong> prevents temporary values from being stored and only stores the result created by executing its internal <strong class="source-inline">toString</strong> method, which creates a new <strong class="source-inline">String</strong> object in the heap space (<em class="italic">Example 2.6</em>). <strong class="source-inline">StringBuilder</strong> also introduces the implementation and use of the creational design pattern within the <span class="No-Break">Java SDK:</span></p>
			<pre class="source-code">
String t5 = new StringBuilder()
        .append("value")
        .append(42)
        .toString();
String t6 = "value42";</pre>
			<p>Output: </p>
			<pre class="console">
t5 == t6 =&gt; false</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.6 – StringBuilder creates a new String object by default in the heap space</p>
			<p>We found out how String objects are created and in which heap memory they are stored. This newly acquired information can strengthen us in making decisions by choosing a<a id="_idIndexMarker145"/> suitable<a id="_idIndexMarker146"/> design pattern or a combination of them to avoid misuse of memory. Because the string is under the hood of an array of characters, primitive type <strong class="source-inline">char[]</strong>, the array is not primitive – in fact, it is an object. Let’s examine this concept a little more closely because it is also essential for the Java language <span class="No-Break">and platform.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Introducing arrays</h2>
			<p>To understand <a id="_idIndexMarker147"/>the Java collections framework better, first, we will look at an <a id="_idIndexMarker148"/>important concept, arrays. In Java, an array is represented by a sequence of the same type of positional index elements. Fields are index-based. Any attempt at runtime to get an element from a non-existent position results in <strong class="source-inline">ArrayIndexOutOfBoundsException</strong>. The array field is allocated as an object and stored in heap space. This means that in the case of insufficient space, an <strong class="source-inline">OutOfMemoryError</strong> exception is thrown. Each array requires a defined size due to memory allocation. Simple field allocation with literals is relatively memory-efficient (<span class="No-Break"><em class="italic">Exam<a id="_idTextAnchor054"/>ple 2.8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
int[]     array1<a id="_idTextAnchor055"/>;    <a id="_idTextAnchor056"/>  <a id="_idTextAnchor057"/>  
byte[][]  array2;<a id="_idTextAnchor058"/>        
Object[]  array3;        
Co<a id="_idTextAnchor059"/>llection&lt;?&gt;[] array4;</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.8 – Multiple array allocation approaches</p>
			<p>Arrays allow us to store elements that implement interface classes or a range of abstract classes. The <a id="_idIndexMarker149"/>field <a id="_idIndexMarker150"/>variable declaration does not create or assign a new field; the variable contains a field reference (<span class="No-Break"><em class="italic">Ex<a id="_idTextAnchor060"/>ample 2.9</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
int[] a1 = {1,2,3,4<a id="_idTextAnchor061"/>};
a1[0] = a1.length;
int e1<a id="_idTextAnchor062"/> = a1[0];
a1.length == 4 =&gt; TRUE 
a1 instanceof Object =&gt; TRUE</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.9 – Array initiation, assignment, and verification</p>
			<p>The use of the field is often neglected due to its potentially precise requirements and limited auxiliary methods. However, it can help enforce the open-closed principle, which assumes <span class="No-Break">code maintainability.</span></p>
			<p>The field is more often replaced by collection or map structures, which provide additional helper methods. Let us explore the topic <span class="No-Break">more closely.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor063"/>Discovering a collection framework</h2>
			<p>Unlike fields, advanced<a id="_idIndexMarker151"/> collections provide an <a id="_idIndexMarker152"/>automatic resizing feature. This means that the required base representation will be copied and the previous version will become eligible for GC. The Java collections framework includes <strong class="source-inline">List</strong> (<em class="italic">Table 2.3</em>), <strong class="source-inline">Set</strong> (<em class="italic">Table 2.4</em>), <strong class="source-inline">Queue</strong> (<em class="italic">Table 2.5</em>), and <strong class="source-inline">Map</strong> interfaces with several implementations (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.12</em>). Implementations may vary by vendor, but all must conform to <span class="No-Break">basic specifications.</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B18884_02_12.jpg" alt="Figure 2.12 – Dependencies between Java collection﻿s framework interfaces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Dependencies between Java collections framework interfaces</p>
			<p>The implications of the collection are located in the <strong class="source-inline">java.base</strong> module and its <strong class="source-inline">java.util</strong> package. The package contains the most common implementation, with the known behavior of time complexity. Space complexity is not very relevant, as the framework comes with automatic resizing features. Time complexity can play a more important role in selection when it comes to design patterns, as this can significantly penalize the response of the proposed program. To assess the time complexity of O-notation, O-notation is used to highlight the upper limit and the worst-case program must be used to <span class="No-Break">obtain it.</span></p>
			<p>To evaluate the impact of time complexity, we can go through some nice examples, such as the importance of choosing the right data structure. Let us start with the list structures (<em class="italic">Table 2.3</em>), which allow access to each element using <span class="No-Break">an index.</span></p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Contains</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Add</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Get</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Remove</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data structure</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ArrayList</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Array</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LinkedList</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Linked List</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.3 – Selected List interface implementations with their time complexities sorted by the actions offered</p>
			<p>An algorithm sometimes requires you to verify the presence of an element in the data structure and add or remove a new one. For these cases, let us look at the implementation of the <strong class="source-inline">Set</strong> interface (<span class="No-Break"><em class="italic">Table 2.4</em></span><span class="No-Break">).</span></p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Contains</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Add</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Remove</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data structure</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HashSet</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Hash Table</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">TreeSet</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(log n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(log n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(log n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Red-Black tree</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.4 – Selected Set interface implementation sorted by their offered actions and time complexity</p>
			<p>The last<a id="_idIndexMarker153"/> interface<a id="_idIndexMarker154"/> provided by the collection group is <strong class="source-inline">Queue</strong> (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.12</em>). This data structure is very useful when you only need to work with the first or last element (<span class="No-Break"><em class="italic">Table 2.5</em></span><span class="No-Break">).</span></p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Peak</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Offer</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Poll</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Size</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data structure</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">PriorityQueue</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(log n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(log n)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Priority Heap</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ArrayDequeue</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Array</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.5 – Selected Queue interface implementations with the actions offered and their time complexities</p>
			<p>When it comes to implementing a <strong class="source-inline">Map</strong> interface, it is important to remember what kind of map implementation type is considered. A map represents the structure of a key-value pair. Both the key and the values are descendants of the <strong class="source-inline">Object</strong> class. Apart from the fact that no literals can be used in the definition or initiation of the map, the correct implementation of the <strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong> object methods is required. This requirement is based on the need to identify the correct bucket to resolve potential map collisions. This kind of collision can lead to unexpected time complexity that deviates from our expectations (<span class="No-Break"><em class="italic">Table 2.6</em></span><span class="No-Break">):</span></p>
			<table id="table006" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Contains Key</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Get </strong><span class="No-Break"><strong class="bold">by Key</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Remove </strong><span class="No-Break"><strong class="bold">by Key</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data structure</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">HashMap</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Hash table</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">LinkedHashMap</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">O(1)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Hash table, <span class="No-Break">linked list</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.6 – Selected Map interface implementations with time complexities by the actions provided </p>
			<p>The<a id="_idIndexMarker155"/> collections <a id="_idIndexMarker156"/>framework uses a heavily behavioral iterator design pattern to traverse through the considered elements. Those who have a keen eye must have already noticed that none of these functions of a collection framework would be possible without a proper mathematical basis. One of the main reasons for using design patterns is to map or create the right structures used by business logic. Let us take a brief look at some basic <span class="No-Break">math features.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor064"/>Math APIs</h2>
			<p>Java reveals<a id="_idIndexMarker157"/> basic<a id="_idIndexMarker158"/> mathematical functions by providing a static implementation of the final <strong class="source-inline">Math</strong> class. Final means that this class cannot be extended, which includes reluctant changes or replacements of basic functions. The <strong class="source-inline">Math</strong> class (<em class="italic">Example 2.10</em>) is located in the <strong class="source-inline">java.lang</strong> package, which means that it is directly available without the need to <span class="No-Break">import it:</span></p>
			<pre class="source-code">
Double sin = Math.sin(90);
double abs = Math.abs(-10);
double sqrt = Math.sqrt(2);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.10 – Using common math functions provided by the Math class</p>
			<p>Although the <strong class="source-inline">Math</strong> class uses the <strong class="source-inline">random</strong> method, it only gets a <strong class="source-inline">double</strong> result. The <strong class="source-inline">Random</strong> class is in the <strong class="source-inline">java.util</strong> package and provides more customizable capabilities not only for types but also for the required ranges (<span class="No-Break"><em class="italic">Example 2.11</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
Random randomNumberWithRange = new Random();
int upperBound = 10;
int randomIntInRange = randomNumberWithRange.
nextInt(upperBound);
double randomDoubleInRange = randomNumberWithRange.
nextDouble(upperBound);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.11 – Generating a random number in a range (0 – upper bound)</p>
			<p>The Java <strong class="source-inline">Math</strong> class is also used here, similar to virtually any required calculation that is beyond the<a id="_idIndexMarker159"/> capabilities <a id="_idIndexMarker160"/>of standard mathematical operators. Using the <strong class="source-inline">Math</strong> class methods can be helpful when functional programming approaches are <span class="No-Break">being followed.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor065"/>Functional programming and Java</h1>
			<p>In the previous<a id="_idIndexMarker161"/> chapter, we <a id="_idIndexMarker162"/>learned about and demonstrated the key principles (APIE) of <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>). In<a id="_idIndexMarker163"/> recent decades, the Java platform has evolved with the demands of the business and development community. The platform has responded to this challenge by implementing an API that uses the composition of tree functions to provide the desired result. This is in contrast to the traditional loop approach with a collection of imperative commands. This approach caused the larger code base to meet the <span class="No-Break">desired goal.</span></p>
			<p>From Java SE 8 onward, the platform provides an API for streaming (<em class="italic">Reference 15</em>). It is in the <strong class="source-inline">java.util.stream</strong> package and has nothing to do with Java data streams represented by input and errors (<strong class="source-inline">System.out</strong>, <strong class="source-inline">System.in</strong>, and <strong class="source-inline">System.err</strong>). The Stream API introduces the ability to apply operations to a sequence of elements. There are two types of intermediate operations that can edit or check data, as well as terminal operations. The terminal operation may provide a single result or void. Intermediate operations can be concatenated, but terminal operations terminate the stream. The sequence of elements is lazily evaluated and can also be performed in parallel. By default, performing a parallel stream <a id="_idIndexMarker164"/>uses the common <strong class="bold">Fork/Join Framework</strong> executor service. The fork-join model can be considered a parallel design pattern that was formulated in the early 1960s (<span class="No-Break"><em class="italic">Reference 17</em></span><span class="No-Break">).</span></p>
			<p>Although the platform allows you to program functional types, OOP concepts remain, followed by strong type requirements. This provides the Stream API with the security that the original element type remains or must be enforced correctly by an intermediate or terminal operation – otherwise, the platform will cause a compilation error. As a reminder, none of these functions would be possible without the introduction of generic types in Java SE 5. Generics (<em class="italic">Reference 4</em>) allow us to parameterize a class or interface by a type flag to keep compilation safe (<em class="italic">Reference 2</em>). </p>
			<p>Intermediate <a id="_idIndexMarker165"/>or <a id="_idIndexMarker166"/>terminal operations are implementations of anonymous functions or functional interfaces. They represent a small block of code, formally called a lambda. Let’s explain the concept of lambda a little <span class="No-Break">more closely.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor066"/>Introducing lambdas and functional interfaces</h2>
			<p>The lambda<a id="_idIndexMarker167"/> concept <a id="_idIndexMarker168"/>was introduced to enable element operations. Lambdas basically treat data as a code or function as a method. Lambdas rely on the concept of anonymous classes – that is, a class with only one method that performs an action. Java contains a collection of already implemented functional interfaces or ready-to-use functions. Classes are annotated with the <strong class="source-inline">@FunctionalInterface</strong> annotation, which is a tag available from Java SE 8. It tells the platform that a particular interface contains only one abstract method that can be used to instantiate anonymous classes, as shown in <em class="italic">Table 2.7</em>. This also means that the interface may contain some default or static functions that belong to <span class="No-Break">the class.</span></p>
			<table id="table007" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Input </strong><span class="No-Break"><strong class="bold">argument</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Return </strong><span class="No-Break"><strong class="bold">type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Abstract </strong><span class="No-Break"><strong class="bold">method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Supplier&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>-</p>
						</td>
						<td class="No-Table-Style">
							<p>T</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">get</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Returns a value of <span class="No-Break">type &lt;T&gt;</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Consumer&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>T</p>
						</td>
						<td class="No-Table-Style">
							<p>-</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">accept</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Consumes a value of type &lt;T&gt; </p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Function&lt;T, R&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>T</p>
						</td>
						<td class="No-Table-Style">
							<p>R</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">apply</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Consumes a value of type &lt;T&gt; and applies a transformation with return <span class="No-Break">type &lt;R&gt;</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Predicate&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>T</p>
						</td>
						<td class="No-Table-Style">
							<p>Boolean </p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">test</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Consumes an input of type &lt;T&gt; and returns a <span class="No-Break">Boolean result</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.7 – Basic functional interfaces available in the JDK since Java SE 8</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor067"/>Using functional interfaces in lambda expressions</h2>
			<p>We have<a id="_idIndexMarker169"/> discovered that each lambda<a id="_idIndexMarker170"/> expression is lazily loaded, which means the code is evaluated on demand, not at compile time, and may be closed by the terminal operation (<span class="No-Break"><em class="italic">Example 2.12</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
List&lt;String&gt; list = Arrays.asList("one", "two", 
    "forty_two");
list.forEach(System.out::println);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.12 – Converting elements of the List interface to the stream and applying a terminal operation for each Consumer type instance</p>
			<p>We can chain the different intermediate functions together (<em class="italic">Example 2.13</em>) and close the stream with a terminal operation or pass the stream to another method <span class="No-Break">or object:</span></p>
			<pre class="source-code">
Predicate&lt;Integer&gt; numberTest = new Predicate&lt;Integ<a id="_idTextAnchor068"/>er&gt;() {
    @Override
    public boolea<a id="_idTextAnchor069"/>n test(Integer e) {
        return e &gt; 2;
    }
};
String result = Stream.of(1,2,3, 42)
        //.filter(e -&gt; e &gt; 2) //Anonymous class example
      <a id="_idTextAnchor070"/>  .filter(numberTest)
      <a id="_idTextAnchor071"/>  .map(e -&gt; "element" + e)
      <a id="_idTextAnchor072"/>  .collect(Collectors.joining(","));
System.out.println("result: " + result);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.13 – Advanced composition of named and anonymous functional interfaces</p>
			<p>The lambda expression stream API plays an important role in the composition of the code. It can be imagined as a process line into which the input object enters and, thanks to a collection <a id="_idIndexMarker171"/>of <a id="_idIndexMarker172"/>adjustments, the expected result is returned or the action ends. Since the lambdas are evaluated lazily, this means that the process line has a switch. In other words, the Stream API can be considered one of the most important breakthroughs <span class="No-Break">in syntax.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor073"/>Getting to grips with the Java Module System</h1>
			<p>One of the main<a id="_idIndexMarker173"/> purposes of using a higher-order programming language such as Java is code reusability. A basic building block of the language is the concept of classes according to the principles of APIE. Java can localize these classes into groups defined by specific package names. The package concept encapsulates a group of classes. Classes can provide different levels of visibility to their internal fields and methods. Java specifies the following levels of visibility: <strong class="source-inline">public</strong>, default, <strong class="source-inline">private</strong>, and <strong class="source-inline">protected</strong>. Keywords are used to reduce visibility across different packages to manage their interactions. The way to share a package across an application domain is to keep it public – that is, visible <span class="No-Break">to everyone.</span></p>
			<p>Java has been using the concept of class paths for many years. The class path is a special place where the Class Loader loads its classes. The loaded classes are then used at runtime (denoted as <a id="_idIndexMarker174"/>the <strong class="bold">Class Loaders Subsystem</strong> in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
			<p>However, this concept does not provide any guarantee for the stored package or class. This concept has been considered bad, fragile, and error-prone for many years. A good example is trying to package a JAR executable that contains different versions of libraries with similar package structures and class names. The class path does not differ and the class can be overwritten by <span class="No-Break">different versions.</span></p>
			<p>The breakthrough<a id="_idIndexMarker175"/> came with the release of Java SE 9. JSR-376, formerly the core of the Jigsaw project (<em class="italic">Reference 3</em>), became a common part of the <a id="_idIndexMarker176"/>platform. JSR-376 implements the <strong class="bold">Java Platform Module System</strong> (<strong class="bold">JPMS</strong>) (<span class="No-Break"><em class="italic">Example 2.14</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
$ java –list-modules          
java.base@<a id="_idTextAnchor074"/>17     
java.compiler@17 
java.datatransfer@17
&lt;more&gt;</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.14 – Listing the available JDK modules for a specific version</p>
			<p>Additionally, the platform has been migrated in accordance with the modules (<span class="No-Break"><em class="italic">Example 2.15</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
$ java –describe-module java.logging
java.logging@17
exports java.util.logging
requires java.base mandated
provides jdk.internal.logger.DefaultLoggerFinder with 
    sun.util.logging.internal.LoggingProviderImpl
&lt;more&gt; </pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.15 – Describing a java.logging module. The java.base module is automatically present, as it contains the core platform and language functionalities.</p>
			<p>The JMPS provides a strong package encapsulation concept that defines application interactions at the package level (<em class="italic">Example 2.16</em>). The application can be divided into modules that can only detect APIs or services. The JMPS supports package-level dependency building and increases the maintainability, reliability, and security of the application <span class="No-Break">being developed:</span></p>
			<pre class="source-code">
Module java.logging {
    exports java.util.logging;
    provides jdk.internal.logger.DefaultLoggerFinder with
        sun.util.logging.internal.LoggingProviderImpl;
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.16 – Example of the module-info.class descriptor exposing a package for external usage</p>
			<p>The use of the<a id="_idIndexMarker177"/> JPMS is not mandatory. The Java platform uses the JMPS, but if the application is not ready, unnamed modules can be used. In this case, all packages or classes will belong to this kind of unnamed module. In principle, an unnamed module reads each readable module or class from the class path without reflecting any package-level restrictions required by the JPMS. In this way, compatibility with previously developed applications is achieved and the software designer has no doubts about the malfunction of the code base – that is, the JPMS <span class="No-Break">is disabled.</span></p>
			<p>Although the JPMS has incredible potential for application sustainability, security, and reusability, it is often not used because it creates indirect pressure to properly configure the underlying JPMS and use a design pattern that enforces <span class="No-Break">SOLID principles.</span></p>
			<p>When using the JMPS, the platform ensures that the developed application does not contain any cyclic dependencies. Behind the scenes, the JPMS creates an acyclic module graph (not a class <span class="No-Break">path case).</span></p>
			<p>By creating a module descriptor file, the platform provides a set of directives that can be used to expose certain parts of the module to the <span class="No-Break">outside world.</span></p>
			<p>Let’s create a simple example of a module to remove any doubt about the use of the JPMS (<em class="italic">Example 2.17</em>). Our discussion so far can overcome the <span class="No-Break">initial difficulties:</span></p>
			<pre class="source-code">
module-example
├── example
│   └── ExampleMain.java
└── module-info.java</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.17 – Folder structure of module example developed with OpenJDK 17</p>
			<p>We create an<a id="_idIndexMarker178"/> appropriate executable class, <strong class="source-inline">ExampleMain.java</strong>, and a module descriptor, <strong class="source-inline">module-info.java</strong> (<em class="italic">Example 2.18</em>). In this way, we tell the platform to use <span class="No-Break">the JPMS:</span></p>
			<pre class="source-code">
// file module-info.java
module module.example {
    exports example;
}
// file ExampleMain.java
package example;
public class ExampleMain {
    public static void main(String[] args) {
        System.out.println("Welcome to JMPS!");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.18 – Simple module example introduced by the file structure in Example 2.17</p>
			<p>The example shows how the project could be separated into modules that contain their own descriptors, <strong class="source-inline">module-info.java</strong> files (<em class="italic">Example 2.17</em>). This descriptor defines an interaction with other modules through dependencies or exposures of module internals. The JPMS <a id="_idIndexMarker179"/>ensures that the restrictions, including visibility, <span class="No-Break">are maintained:</span></p>
			<pre class="source-code">
$ javac -d ./out ./module-example/module-info.java 
    ./module-example/example/ExampleMain.java
$ jar –create -file module-example.jar -C ./out .
$ java –module-path ./module-example.jar –module 
    module.example/example.ExampleMain</pre>
			<p>Output: </p>
			<pre class="console">
   Welcome to JMPS!
        
$ java –module-path ./module-example.jar –describe-module 
    module.example</pre>
			<p>Output: </p>
			<pre class="console">
module.example
exports example
requires java.base mandated</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.19 – Steps to compile Example 2.17 with outputs, together with the module descriptor check (Example 2.18) after the compiled result</p>
			<p>The JPMS is a big change to the platform and although it opens a new horizon for software designers by providing the ability to define clarity in the package structure, it is not always well received or understood. This may be due to additional requirements that need to be taken into account when designing the system, which essentially relate to the knowledge of APIE or <span class="No-Break">SOLID principles.</span></p>
			<p>The JPMS together with the Stream API, as well as lambdas, may be considered significant changes addressed by the Java SE 11 release – Java SE 11 being the next <strong class="bold">Long-Time Support </strong>(<strong class="bold">LST</strong>) release<a id="_idIndexMarker180"/> after version 8. Let us<a id="_idIndexMarker181"/> dive a bit further into some of the changes from Java SE 11 to the next LST version presented by <span class="No-Break">release 17.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor075"/>A quick review of Java features from 11 to 17+</h1>
			<p>This version update<a id="_idIndexMarker182"/> presents performance and optimization improvements. In this section, we will examine those that are very useful for the specific use of a design pattern and its structure. This equates to platform enhancements that improve code readability, platform usage, or <span class="No-Break">syntax enhancements.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor076"/>The local variable syntax for lambda parameters (Java SE 11, JEP-323)</h2>
			<p>Java has <a id="_idIndexMarker183"/>often been criticized for the amount of standard code in the use of a variable; Java SE 10 introduced a new keyword, <strong class="source-inline">var</strong>. The derivation of a local type variable lies behind this keyword. It essentially requires that the value type is taken from the newly created reference instance (<em class="italic">Example 2.20</em>). Using the stream <strong class="source-inline">boxed</strong> function shows a decorator pattern that wraps the stream value with the <span class="No-Break">desired type:</span></p>
			<pre class="source-code">
Consumer&lt;Integer&gt; consumer = (var number) -&gt; {
    var result = number + 1;
    System.out.println("result:" + result);
};
IntStream.of(1, 2, 3).boxed().forEach(consumer);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.20 – Use of local type inference in a lambda expression and stream shows the reduction of boilerplate code</p>
			<p>Although a lambda already allowed an implicit type definition, for example, the use of annotation<a id="_idIndexMarker184"/> was <span class="No-Break">not possible.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor077"/>Switch expressions (Java SE 14, JEP-361)</h2>
			<p>Software<a id="_idIndexMarker185"/> designers have long complained about several inconsistencies in the use of switch commands, such as a control flow problem. Although this enhancement is fully compatible with all controls, it introduces a new form of switch label, <strong class="source-inline">case CONSTANT-&gt;</strong>. The extension also allows more constants to be used, making the entire switch expression more compact. The last improvement is the ability of the switch expression to return its computed value (<em class="italic">Example 2.21</em>). This has a very positive impact on the implementation of the design pattern, because, for example, behavior types require a precise control flow (<span class="No-Break"><em class="italic">Reference 8</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
Var inputNumber = 42;
String textNumber = switch (inputNumber){
    case 22,42 -&gt; String.valueOf(inputNumber);
    default -&gt; throw new RuntimeException("not allowed");
};
System.out.printf("""
        number:'%s'
        %n""", textNumber);</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.21 – Compact switch expression usage with a return control flow with a simple text block</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor078"/>Text blocks (Java SE 15, JEP-378)</h2>
			<p>Many times, you <a id="_idIndexMarker186"/>need to create multiple lines with a specific format. Previous use of multiple escape sequences and characters was not as practical, as it could be unpredictable. Text block extension introduces a literal that allows you to represent a string in a predictable way (see the <strong class="source-inline">System.out.printf</strong> method in <em class="italic">Example 2.21</em>, as well as <span class="No-Break"><em class="italic">Reference 9</em></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor079"/>Pattern matching for instanceof (Java SE 16, JEP-394)</h2>
			<p>Previously, it <a id="_idIndexMarker187"/>was necessary to retype a value type that had already been verified as positive for its type. This increased the code base and sometimes had a negative effect on the stability of the code, even when designing a pattern. This platform extension eliminates the need for a rear cast and the variable can be used directly with the correct type (<em class="italic">Example 2.22</em>, <span class="No-Break"><em class="italic">Reference 10</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
Object obj = "text";
if(obj instanceof String s){
    System.out.println(s.toUpperCase());
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.22 – Using instanceof with direct type methods</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor080"/>Records (Java SE 16, JEP-395)</h2>
			<p>The <strong class="source-inline">record</strong> class <a id="_idIndexMarker188"/>type is very useful because its declaration is very simple and can carry all the data needed for the program’s business logic. Records carry immutable data. They provide an already implemented <strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong>. This means that the designed software does not have to provide additional code (<em class="italic">Example 2.23</em>, <span class="No-Break"><em class="italic">Reference 11</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
private record Example(int number, String text){
    private String getTogether(){
        return number + text;
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.23 – New record class type may have a very positive impact on code reduction, as it provides generated methods</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor081"/>Sealed classes (Java SE 17, JEP-409)</h2>
			<p>These are <a id="_idIndexMarker189"/>very elegant enhancements to gain control over classes and interfaces, or class extensions and interface implementations (<em class="italic">Reference 12</em>). Closed classes give software designers wide access to the superclass without the need to extend it. They overcome the limitations of the widely used package access modifier, which previously required the full implementation of abstract methods. The example shows how to define an open class for an extension, the <strong class="source-inline">non-sealed</strong> keyword (<span class="No-Break"><em class="italic">Example 2.24</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public sealed interface Vehicle permits Car, Bus {
    void start();
    void stop();
}
public non-sealed class Car extends NormalEngine implements 
    Vehicle {
    public String toString(){
        return "Car{running="+ super.running +'}';
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.24 – The implementation of the interface methods is provided by the abstract class, NormalEngine</p>
			<p>Sealed classes force control over possible extensions (<em class="italic">Example 2.25</em>) because they provide software with potential security against unwanted software <span class="No-Break">design changes:</span></p>
			<pre class="source-code">
Public class Motorbike implements Vehicle{
    public void start() {}
    public void stop() {}
}</pre>
			<p>Here’s the <span class="No-Break">compilation output:</span></p>
			<pre class="console">
Motorbike.java:2: error: class is not allowed to extend 
sealed class: Vehicle (as it is not listed in its permits 
clause)</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.25 – Sealed classes enforce control over the enhancements</p>
			<p>Sealed classes also present some potential problems because the software designer must decide how the newly created classes will be used, indicating whether class extension is allowed, the keyword is unsealed (<em class="italic">Example 2.25</em>), or the final keyword (<em class="italic">Example 2.26</em>) <span class="No-Break">is locked:</span></p>
			<pre class="source-code">
Public final class Bus extends SlowEngine implements 
    Vehicle {}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.26 – It’s required to decide the class behavior and the Bus class example is locked for any extension</p>
			<p>Although this may seem like a possible disadvantage, it provides greater clarity in software<a id="_idIndexMarker190"/> development in terms of maintainability and design patterns. This reduces potential unwanted interface or <span class="No-Break">class errors.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor082"/>UTF-8 by default (Java SE 18, JEP-400)</h2>
			<p>For many <a id="_idIndexMarker191"/>years, unclear encoding has caused issues. Encoding problems were not easy to detect and appeared unpredictably on different system platforms. This enhancement has unified everything and forced UTF-8 as the default encoding (<span class="No-Break"><em class="italic">Reference 13</em></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor083"/>Pattern matching for switch (Java SE 18, Second Preview, JEP-420)</h2>
			<p>Improvements<a id="_idIndexMarker192"/> to <strong class="source-inline">instanceof</strong> fields (JEP-394) and switch case expressions (JEP-361) have made it even better to compress the code base and remove previously unnecessary if-else constructs by using <strong class="source-inline">instanceof</strong> on a very compact, command-oriented controlled command statement: type-served (E<em class="italic">xample 2.27</em>, <span class="No-Break"><em class="italic">Reference 14</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
Object variable = 42;
String text = switch (variable){
    case Integer i -&gt; "number"+i;
    default -&gt; "text";
};</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.27 – Compact switch statement with an implicit type match</p>
			<p>After reviewing the most important syntactic improvements, we can safely start to delve deeper into one <a id="_idIndexMarker193"/>of the main advantages of the platform. Yes, it is the <span class="No-Break">concurrency framework.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor084"/>Understanding Java concurrency</h1>
			<p>At the beginning of <a id="_idIndexMarker194"/>this chapter, it was shown that even running a simple program (<em class="italic">Example 2.2</em> and <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.3</em>) will cause multiple concretizations of threads (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.4</em>). This means that a program thread created by executing the <strong class="source-inline">main</strong> method did not create any other thread that belonged to that program. The Java platform is well-known and valuable for its ability to perform concurrent or <span class="No-Break">parallel tasks.</span></p>
			<p>We found out how and where initiated threads store their variables and why synchronizing objects located in the heap can lead to unwanted or unexpected program behavior. In this section, we will look at the possibilities of the main threads using the <span class="No-Break">available CPUs.</span></p>
			<p>The motivation for software designers to consider using any concurrent design patterns may be the growing need for better application responsiveness <span class="No-Break">or throughput.</span></p>
			<p>Although the platform already includes the <strong class="source-inline">Thread</strong> class and the <strong class="source-inline">java.lang</strong> package, Java concurrency features <a id="_idIndexMarker195"/>such as <strong class="bold">executors</strong> have become available to developers since the release of Java SE 5 and can be found in the <strong class="source-inline">java.util.concurrent</strong> package, which is part of the <span class="No-Break"><strong class="source-inline">java.base</strong></span><span class="No-Break"> module.</span></p>
			<p>Let us look a <span class="No-Break">bit closer.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor085"/>From a basic thread to executors</h2>
			<p>The basic build<a id="_idIndexMarker196"/> element of the platform is the thread. A thread is represented by an instance of the <strong class="source-inline">Thread</strong> class. The object initiated by the <strong class="source-inline">new</strong> keyword still does not create a platform thread. The object provides a method named <strong class="source-inline">start</strong> that requires explicit use (<span class="No-Break"><em class="italic">Example 2.28</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public class Multithreaded Program {
    public static void main(String[] args) {
        var t = new Thread(() -&gt; {
            while(true){System.out.println("Welcome 
                Thread!");}
        });
        t.setDaemon(true);
        t.start();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.28 – A simple program with a daemon thread that ends immediately after the JVM stops</p>
			<p>Although it may appear that the platform can create an unrestricted <strong class="source-inline">Thread</strong> instance, this kind of statement is not valid. Each newly created thread instance not only takes up heap space or allocates a stack but is also connected to basic system threads (processing cycles) through Java runtime partitions (<span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em>). This means that uncontrolled thread startup can cause a system error exception due to unavailable resources, insufficient memory, and so on. </p>
			<p>The maximum number of system threads created by the Java platform may vary, as it depends on the hardware as well as the JVM configuration. The Java <strong class="source-inline">Thread</strong> class might consider a wrapper for the <strong class="source-inline">Runnable</strong> interface, and the thread accepts its implementation. The <strong class="source-inline">Runnable</strong> interface is another functional interface and requires the implementation of a run method. Starting with the Java SE 8 <strong class="source-inline">Runnable</strong> interface, the instance can be passed to the executor service as an anonymous function. </p>
			<p>The Java platform allows you to run a thread that can even survive the termination of the main program, which in many cases, is a reluctant condition and should be considered wisely, as it may block other core resources or <span class="No-Break">stay running.</span></p>
			<p>It is important to remember that the JVM only terminates when all running threads are daemon ones (<span class="No-Break"><em class="italic">Example 2.28</em></span><span class="No-Break">).</span></p>
			<p>Because each thread newly created by the main program is non-daemon, by default, when the sample program is run without an explicit daemon flag, the JVM remains an active process until the base system <span class="No-Break">destroys it.</span></p>
			<p>It allows you to manage uncontrolled thread creation and gives the software designer control over the program’s resources and behavior. Java SE 5 introduced the <strong class="source-inline">ExecutorService</strong> and <strong class="source-inline">ThreadFactory</strong> interfaces, where multiple implementations show using a similarly named creational design pattern factory. The <strong class="source-inline">ThreadFactory</strong> interface contains only one <strong class="source-inline">newThread</strong> method, which returns a <strong class="source-inline">Thread</strong> instance. This method logic can accommodate the creation of a new thread and set the group, thread priority, and daemon flag. It also eliminates the number of new thread calls. <strong class="source-inline">ThreadFactory</strong> can be serviced by <strong class="source-inline">ExecutorService</strong> (<span class="No-Break"><em class="italic">Example 2.30</em></span><span class="No-Break">).</span></p>
			<p>Some of the most used executor static method names are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">newSingleThreadExecutor()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">newSingleThreadExecutor(ThreadFactory threadFactory)</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">newCachedThreadPool()</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">newCachedThreadPool(ThreadFactory threadFactory)</strong></span></li>
			</ul>
			<p>Java SE 5 came up with a <a id="_idIndexMarker197"/>concept for the future, a <strong class="source-inline">Future</strong> interface with a generic type of <strong class="source-inline">&lt;T&gt;</strong>. The <strong class="source-inline">Future</strong> interface can be considered an asynchronous calculation that provides a result. </p>
			<p>The Java platform provides two different interfaces that can carry thread logic. </p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor086"/>Executing tasks</h2>
			<p>The Java platform <a id="_idIndexMarker198"/>provides a thread concept from the beginning represented by the <strong class="source-inline">Runnable</strong> interface and the <strong class="source-inline">Thread</strong> class (<span class="No-Break"><em class="italic">Example 2.29</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
ExecutorService executorService = 
    Executors.newSingleThreadE<a id="_idTextAnchor087"/>xecutor();
var runnable = new Runnable(){
<a id="_idTextAnchor088"/>    @Override
    public void run() {
        System.out.println("Welcome Runnable");
    }
};
executorService.execute(runnable);
executorService.execute(() -&gt; System.out.println("Welcome 
    Runnable"));</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.29 – Different approaches to providing the Runnable interface implementation to the executor service, implementation, and anonymous class</p>
			<p>Business requirements, along with community expectations, have created a platform for reactive programming or the ability to perform multiple asynchronous payback tasks. As of Java SE 5, the platform provides a <strong class="source-inline">Callable</strong> interface. The <strong class="source-inline">Callable</strong> interface is considered a functional interface. It contains only one abstract method call with a required return type of <strong class="source-inline">&lt;T&gt;</strong>. Because the computation is uncertain, it can cause an exception that must be handled correctly. The <strong class="source-inline">Callable</strong> implementation can be sent to the executor and the started calculation is packed into a <span class="No-Break">future result.</span></p>
			<p>The <strong class="source-inline">Future</strong> instance<a id="_idIndexMarker199"/> is the computational work that the base system performs in the background. The interface provides a <strong class="source-inline">get</strong> method (<em class="italic">Example 2.30</em>) that can be used to retrieve the result. Using this method pauses the current thread and waits until a result is available. Due to the current thread suspension, this method should be used wisely, as it can cause <span class="No-Break">performance penalties:</span></p>
			<pre class="source-code">
var futureCallable = executorService.submit(callable);
Future&lt;String&gt; futureCallableAnonymous = executor.submit(() 
    -&gt; "Welcome to Future");
System.out.println("""
        futureCallable:'%s',
        futureCallableAnonymous:'%s'
        """.formatted(futureCallable.get(), 
            futureCallableAnonymous.get()));</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2.30 – Different approaches to provide a Callable instance to the executor service as a realization or an anonymous class</p>
			<p>This contrasts with the <strong class="source-inline">Runnable</strong> interface because the <strong class="source-inline">Callable</strong> interface provides a <strong class="source-inline">Future</strong> instance as a temporary result. The <strong class="source-inline">Callable</strong> exception handling request is also <a id="_idIndexMarker200"/>relevant because it can cause logic to be executed or the worker thread can be interrupted. In this case, it is necessary to transfer this to the interim result represented by the <span class="No-Break"><strong class="source-inline">Future</strong></span><span class="No-Break"> interface.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor089"/>Summary</h1>
			<p>In this chapter, we have built a good knowledge base for understanding the internal Java platform. We learned about the differences between statically allocated arrays or methods compared to object instances. We examined the need for proper data synchronization and how Java memory management works and what guarantees the platform provides. We now understand the importance of heap memory, segmentation, and maintenance. We have also already discovered a few frequently used design patterns, which means that when we start implementing any design pattern or collection, we will be aware of <span class="No-Break">the following:</span></p>
			<ul>
				<li>How fields or variables are handled by <span class="No-Break">the platform</span></li>
				<li>The importance of <span class="No-Break">memory management</span></li>
				<li>Specific program error exit states and the reasons <span class="No-Break">for them</span></li>
				<li>The core APIs provided by the <span class="No-Break">Java platform</span></li>
				<li>How to utilize functional <span class="No-Break">programming features</span></li>
				<li>What new enhancements the Java platform provides to make employing design <span class="No-Break">patterns easier</span></li>
				<li>How to approach Java <span class="No-Break">concurrency challenges</span></li>
			</ul>
			<p>We have built a solid knowledge base over the first two chapters. We will now begin to present pattern by pattern. The next chapter will take us on a journey through creational design patterns. Creational design patterns intensify our awareness of the code structure and how to create sustainable solutions. Let <span class="No-Break">us roll.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor090"/>Questions</h1>
			<ol>
				<li value="1">Which elements make up the <span class="No-Break">Java platform?</span></li>
				<li>What does statically typed <span class="No-Break">language mean?</span></li>
				<li>What are the Java <span class="No-Break">language literals?</span></li>
				<li>What is responsible for memory reclamation in the Java memory <span class="No-Break">management concept?</span></li>
				<li>What are the collections in the Java <span class="No-Break">collections framework?</span></li>
				<li>What kind of elements <span class="No-Break">store </span><span class="No-Break"><strong class="source-inline">Map</strong></span><span class="No-Break">?</span></li>
				<li>What is the time complexity of retrieving an element <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Set</strong></span><span class="No-Break">?</span></li>
				<li>What is the time complexity of verifying an element’s existence <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break">?</span></li>
				<li>What functional interface is used in the <strong class="source-inline">filter</strong> method of the Stream API? </li>
				<li>How are elements evaluated in the <span class="No-Break">Stream API?</span></li>
			</ol>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor091"/>Further reading</h1>
			<ul>
				<li><em class="italic">The Garbage Collection Handbook: The Art of Automatic Memory Management</em>, Anthony Hosking, Eliot B. Moss, and Richard Jones, CRC Press, ISBN-13: 978-1420082791, ISBN-10: <span class="No-Break">9781420082791, 1996</span></li>
				<li>Java <span class="No-Break">Generics: </span><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html"><span class="No-Break">https://docs.oracle.com/javase/tutorial/java/generics/index.html</span></a></li>
				<li>The JPMS (JSR <span class="No-Break">376): </span><a href="https://openjdk.java.net/projects/jigsaw/spec/"><span class="No-Break">https://openjdk.java.net/projects/jigsaw/spec/</span></a></li>
				<li>The Java <span class="No-Break">tutorials: </span><a href="https://docs.oracle.com/javase/tutorial/java"><span class="No-Break">https://docs.oracle.com/javase/tutorial/java</span></a></li>
				<li>Java GC <span class="No-Break">basics: </span><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html"><span class="No-Break">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html</span></a></li>
				<li>The JVM specification, Java SE 17 <span class="No-Break">Edition: </span><a href="https://docs.oracle.com/javase/specs/jvms/se17/html/index.html"><span class="No-Break">https://docs.oracle.com/javase/specs/jvms/se17/html/index.html</span></a></li>
				<li>OpenJDK, HotSpot runtime <span class="No-Break">overview: </span><a href="https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html"><span class="No-Break">https://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html</span></a></li>
				<li>JEP 361: Switch <span class="No-Break">Expression: </span><a href="https://openjdk.java.net/jeps/361"><span class="No-Break">https://openjdk.java.net/jeps/361</span></a></li>
				<li>JEP 378: Text <span class="No-Break">Blocks: </span><a href="https://openjdk.java.net/jeps/378"><span class="No-Break">https://openjdk.java.net/jeps/378</span></a></li>
				<li>JEP 394: Pattern matching for <span class="No-Break"><strong class="source-inline">instanceof</strong></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/394"><span class="No-Break">https://openjdk.java.net/jeps/394</span></a></li>
				<li><em class="italic">JEP 395: </em><span class="No-Break"><em class="italic">Records</em></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/395"><span class="No-Break">https://openjdk.java.net/jeps/395</span></a></li>
				<li><em class="italic">JEP 409: Sealed </em><span class="No-Break"><em class="italic">Classes</em></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/409"><span class="No-Break">https://openjdk.java.net/jeps/409</span></a></li>
				<li><em class="italic">JEP 400: UTF-8 by </em><span class="No-Break"><em class="italic">Default</em></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/400"><span class="No-Break">https://openjdk.java.net/jeps/400</span></a></li>
				<li><em class="italic">JEP 420: Pattern Matching for switch (Second </em><span class="No-Break"><em class="italic">Preview)</em></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/420"><span class="No-Break">https://openjdk.java.net/jeps/420</span></a></li>
				<li>The <strong class="source-inline">java.util.stream</strong> <span class="No-Break">package: </span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html"><span class="No-Break">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</span></a></li>
				<li><em class="italic">JEP 300: Launch Single-File Source-Code </em><span class="No-Break"><em class="italic">Programs</em></span><span class="No-Break">: </span><a href="https://openjdk.java.net/jeps/330"><span class="No-Break">https://openjdk.java.net/jeps/330</span></a></li>
				<li><em class="italic">A multiprocessor system design</em>. Fall Join Computer Conference, Melvin E. Conway (1963). pp. <span class="No-Break">139 -146.</span></li>
			</ul>
		</div>
	

		<div id="_idContainer034" class="Content">
			<h1 id="_idParaDest-74"><a id="_idTextAnchor092"/>Part 2: Implementing Standard Design Patterns Using Java Programming</h1>
			<p>Design patterns are often classified into three well-known categories: creational, behavioral, and structural. This part will explore and demonstrate design patterns from each of these categories. It will show the types of challenges addressed by each design pattern with practical <span class="No-Break">real-world examples.</span></p>
			<p>This part contains the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18884_03.xhtml#_idTextAnchor093"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Creational Design Patterns</em></li>
				<li><a href="B18884_04.xhtml#_idTextAnchor172"><em class="italic">Chapter 4</em></a>, <em class="italic">Applying Structural Design Patterns</em></li>
				<li><a href="B18884_05.xhtml#_idTextAnchor255"><em class="italic">Chapter 5</em></a>, <em class="italic">Behavioral Design Patterns</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer035">
			</div>
		</div>
		<div>
			<div id="_idContainer036">
			</div>
		</div>
	</body></html>