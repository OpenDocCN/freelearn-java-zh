- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foreign (Function) Memory API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter includes 28 problems covering the Foreign Memory API and Foreign
    Linker API. We’ll start with the classical approaches for calling foreign functions
    relying on the JNI API and the open-source JNA/JNR libraries. Next, we’ll introduce
    the new approach delivered under the code name Project Panama (third review in
    JDK 21 and final release in JDK 22 as JEP 454). We’ll dissect the most relevant
    APIs, such as `Arena`, `MemorySegment`, `MemoryLayout`, and so on. Finally, we’ll
    focus on the Foreign Linker API and the Jextract tool for calling foreign functions
    with different types of signatures, including callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be skilled in putting JNI, JNA, JNR, and,
    of course, Project Panama to work and you’ll be able to confidently answer any
    interview questions with this topic on the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the following problems to test your programming prowess in manipulating
    off-heap memory and calling native foreign functions from Java. I strongly encourage
    you to give each problem a try before you turn to the solutions and download the
    example programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Introducing Java Native Interface (JNI)**: Write a Java application that
    calls a C/C++ native foreign function via the JNI API (for instance, implement
    in C a function with the following signature: `long sumTwoInt(int x, int y)`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing Java Native Access (JNA)**: Write a Java application that calls
    a C/C++ native foreign function via the JNA API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing Java Native Runtime (JNR)**: Write a Java application that calls
    a C/C++ native foreign function via the JNR API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Motivating and introducing Project Panama**: Provide a theoretical and meaningful
    transition from classical approaches of manipulating off-heap memory and foreign
    functions to the new Project Panama.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing Panama’s architecture and terminology**: Provide a brief description
    of Project Panama, including architecture, terminology, and the main API components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing Arena and MemorySegment**: Explain and exemplify via snippets
    of code the `Arena` and `MemorySegment` APIs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Allocating arrays into memory segments**: Write several approaches for allocating
    arrays into memory segments (via `Arena` and `MemorySegment`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Understanding addresses (pointers)**: Exemplify the usage of memory addresses
    (pointers) in Java (`ValueLayout.ADDRESS`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the sequence layout**: Explain and exemplify the usage of the
    sequence layout. Moreover, introduce the `PathElement` and `VarHandle` APIs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shaping C-like structs into memory segments**: Exemplify the approach of
    shaping C-like structs via Java memory layouts (`StructLayout`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shaping C-like unions into memory segments**: Exemplify the approach of shaping
    C-like unions via Java memory layouts (`UnionLayout`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing PaddingLayout**: Provide a detailed explanation and meaningful
    examples for explaining padding layout (introduce *size*, *alignment*, *stride*,
    *padding*, and *order* of bytes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copying and slicing memory segments**: Exemplify different approaches for
    copying and slicing parts of a memory segment, including `asOverlappingSlice()`
    and `segmentOffset()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling the slicing allocator**: Exemplify the usage of the slicing allocator
    (`SegmentAllocator`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the slice handle**: Explain and exemplify the usage of `sliceHandle()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing layout flattening**: Consider a hierarchical memory layout (for
    instance, two nested sequence layouts). Explain and exemplify how to flatten this
    model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing layout reshaping**: Provide an example that reshapes a hierarchical
    sequence layout.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the layout spreader**: Provide a brief explanation and a simple
    example of using the layout spreader (`asSpreader()`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the memory segment view VarHandle**: Exemplify the usage of `MethodHandles.memorySegmentViewVarHandle(ValueLayout
    layout)` for creating a `VarHandle` that can be used to access a memory segment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Streaming memory segments**: Write several snippets of code for combining
    memory segments with the Java Stream API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tackling mapped memory segments**: Provide a brief introduction of mapped
    memory segments and exemplify them in Java code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing the Foreign Linker API**: Provide a brief description of the
    Foreign Linker API, including `Linker`, `SymbolLookup`, *downcall*, and *upcall*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calling the sumTwoInt() foreign function**: Write a Java application that
    calls the `sumTwoInt()` method (the `long sumTwoInt(int x, int y)` implemented
    in *Problem 144*) via the Foreign Linker API.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calling the modf() foreign function**: Use the Foreign Linker API to call
    the `modf()` foreign function – this function is part of the C standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calling the strcat() foreign function**: Use the Foreign Linker API to call
    the `strcat()` foreign function – this function is part of the C standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calling the bsearch() foreign function**: Use the Foreign Linker API to call
    the `bsearch()` foreign function – this function is part of the C standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Introducing Jextract**: Provide a brief description of the Jextract tool,
    including the main options.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generating native binding for modf()**: Exemplify the combination of Jextract
    and the Foreign Linker API to call the `modf()` foreign function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following sections describe solutions to the preceding problems. Remember
    that there usually isn’t a single correct way to solve a particular problem. Also,
    remember that the explanations shown here include only the most interesting and
    important details needed to solve the problems. Download the example solutions
    to see additional details and to experiment with the programs at [https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07](https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: 144\. Introducing Java Native Interface (JNI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Native Interface** (**JNI**) was the first Java API meant to act as
    a bridge between JVM bytecode and native code written in another programming language
    (typically C/C++).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose that we plan to call via JNI a C function on a Windows 10, 64-bit
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s consider that we have a C function for summing two integers
    called `sumTwoInt(int x, int y)`. This function is defined in a C shared library
    named `math.dll`. Calling such functions from Java (generally speaking, functions
    implemented by native shared libraries) starts with loading the proper shared
    native library via `System.loadLibrary(String library)`. Next, we declare the
    C function in Java via the `native` keyword. Finally, we call it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we focus on C implementation. We need the header file (the `.h` file)
    and the source file that implements this method (the `.cpp` file).
  prefs: []
  type: TYPE_NORMAL
- en: Generating the header (.h) file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The header file (definition of the method) can be obtained by running `javac`
    with the `–h` option against our `Main.java` source, as in the following figure
    (before JDK 9, use `javah`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1.png](img/B19665_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Running javac –h to compile source code and generate the .h file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command compiles our code (`Main.java`) and places the resulting class
    in the `target/classes` folder. In addition, this command generates the C header
    `modern_challenge_Main.h` in `jni/cpp`. The important code of this file is listed
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The function name was generated as `Java_modern_challenge_Main_sumTwoInt`.
    Moreover, we have here the following artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JNIEXPORT` – the function is marked as exportable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JNICALL` – sustains `JNIEXPORT` to guarantee that the function can be found
    by JNI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JNIEnv` – represents a pointer to the JNI environment for accessing JNI functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jobject` – represents a reference to this Java object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the modern_challenge_Main.cpp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we provide the C implementation in `src/main/java/modern/challenge/cpp`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Compiling the C source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have the C source code (the `.cpp` file) and the generated header
    (`.h`). Next, we have to compile the C source code, and for this, we need a C
    compiler. There are many options, like Cygwin, MinGW, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We decided to install MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    for 64-bit platforms and use the G++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having G++ in our hands, we have to trigger a specific command for compiling
    the C code, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2.png](img/B19665_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Compiling the C source code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have to pack everything in `math.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the native shared library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to create the native shared library, `math.dll`. For this, we use
    G++ again, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3.png](img/B19665_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Creating the math.dll'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have used the `–static` option. This option instructs G++ to
    add in `math.dll` all dependencies. If you dislike this approach, then you may
    need to manually add the dependencies in order to avoid `java.lang.UnsatisfiedLinkError`
    errors. To find out the missing dependencies, you can use a DLL dependency walker
    such as this one: [https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, run the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can run the code. Keep your fingers crossed and execute the command
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4.png](img/B19665_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Executing the Java code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we should set the library path; otherwise, Java will not be able
    to load `math.dll`. If everything worked fine, then you should see the output
    from this figure.
  prefs: []
  type: TYPE_NORMAL
- en: Well, as you can easily conclude, JNI is not easy to use. Imagine doing all
    this work for an entire C library like TensorFlow, which has 200+ functions. Besides
    being hard to use, JNI also faces a lot of shortcomings, for example, it is error-prone,
    hard to maintain, and brittle, it has poor exception support, JNI errors can crash
    the JVM, it has a maximum off-heap of 2 GB allocated via `ByteBuffer` that cannot
    be directly free (we have to wait for the garbage collector to do it), and many
    more. Despite all this, it is still worth learning this technique because, as
    you’ll surely know, management is often not quick to adopt new ways of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, the community came up with other approaches that we will
    discuss in the next problems.
  prefs: []
  type: TYPE_NORMAL
- en: 145\. Introducing Java Native Access (JNA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Native Access** (**JNA**) is a brave open-source attempt to address
    JNI complexity via a more intuitive and easy-to-use API. Being a third-party library,
    JNA must be added as a dependency in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s try to call the same `sumTwoInt()` method from *Problem 144*. This
    function is defined in a C native shared library named `math.dll` and stored in
    our project in the `jna/cpp` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by writing a Java interface that extends JNA’s `Library` interface.
    This interface contains declarations of methods and types that we plan to call
    from Java and are defined in native code. We write the `SimpleMath` interface
    containing the `sumTwoInt()` declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to instruct JNA to load the `math.dll` library and generate a
    concrete implementation of this interface so we can call its methods. For this,
    we need the `jna.library.path` system property and JNA’s `Native` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we instruct JNA to load `math.dll` from `jna/cpp` via `System.setProperty()`,
    but you can also do it from a terminal via `–Djna.library.path=jna/cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call `Native.load()`, which takes two arguments. First, it takes the
    native library name, which in our case is `math` (without the `.dll` extension).
    Second, it takes the Java interface containing the declaration of the methods,
    which in our case is `SimpleMath.class`. The `load()` method returns a concrete
    implementation of `SimpleMath` that we use to call the `sumTwoInt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The JNA `Platform` helper allows us to provide the name of the native library
    specific to the current operating system. We have only `math.dll` for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the .cpp and .h files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time, there is no naming convention from the `.cpp` and `.h` files, so
    let’s name them `Arithmetic.cpp` and `Arithmetic.h` (the header file is optional).
    The source code of `Artihmetic.cpp` is basically plain C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, with JNA, there is no need to patch our code with the JNI-specific
    bridge code. It is only plain C code. The `Arithmetic.h` is optional and we can
    write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can compile our code.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the C source code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compiling the C source code is done via the G++ compiler with the command from
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5.png](img/B19665_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Compiling the C++ code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can generate the proper native library.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the native shared library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to create the native shared library, `math.dll`. For this, we use
    G++ again as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6.png](img/B19665_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Generating math.dll'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should have `math.dll` in the `jna/cpp` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, run the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we can run the code. If everything worked fine, then you’re done.
    Otherwise, if you get an exception such as `java.lang.UnsatisfiedLinkError:` *Error
    looking up function ''sumTwoInt'': The specified procedure could not be found*,
    then you have to fix it.'
  prefs: []
  type: TYPE_NORMAL
- en: But what happened? Most probably, the G++ compiler has applied a technique referred
    to as *name mangling* (or, *name decoration*) – [https://en.wikipedia.org/wiki/Name_mangling](https://en.wikipedia.org/wiki/Name_mangling).
    In other words, the G++ compiler has renamed the `sumTwoInt()` method to something
    else that is not known to JNA.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving this issue can be done in two steps. First, we need to inspect `math.dll`
    with a DLL dependency walker such as this one, [https://github.com/lucasg/Dependencies](https://github.com/lucasg/Dependencies).
    As you can see in the following figure, G++ has renamed `sumTwoInt` to `_Z9sumTwoIntii`
    (of course, on your computer, it could be another name):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7.png](img/B19665_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: G++ has renamed sumToInt to _Z9sumTwoIntii'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, we have to tell JNA about this name (`_Z9sumTwoIntii`). Basically,
    we need to define a `Map` containing the corresponding mapping of names and pass
    this map to a flavor of `Native.load()` that takes this map as the last argument.
    The code is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, you should obtain the result of 3+9\. Feel free to explore JNA further,
    and attempt to use C/C++ structures, unions, and pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 146\. Introducing Java Native Runtime (JNR)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Native Runtime** (**JNR**) is another open-source attempt to address
    JNI’s complexity. It is a serious competitor for JNA, having a more intuitive
    and powerful API than JNI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add it as a dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s assume that we have the exact same C method (`sumTwoInt()`) and the native
    shared library (`math.dll`) from *Problem 145*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by writing a Java interface containing the declarations of methods
    and types that we plan to call from Java and are defined in native code. We write
    the `SimpleMath` interface containing the `sumTwoInt()` declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `@IgnoreError` annotation instructs JNR to not save the *errno value* ([https://www.geeksforgeeks.org/errno-constant-in-c/](https://www.geeksforgeeks.org/errno-constant-in-c/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to instruct JNR to load the `math.dll` library and generate a
    concrete implementation of this interface so we can call its methods. For this,
    we need the `LibraryLoader` and the following intuitive code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Via the `LibraryLoader` API, we prepare the playground. We instruct JNR that
    our library is located in `jnr/cpp` via the `search()` method. Moreover, we provide
    the proper mapping of the method’s names via the `map()` method (remember from
    *Problem 145* that G++ renames the method via *name mangling* (or, *name decoration*)
    from `sumTwoInt` to `_Z9sumTwoIntii`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we load the library via the `load()` method and call the `sumTwoInt()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: JNR provides many other features that you can exploit starting from [https://github.com/jnr](https://github.com/jnr).
    You may also be interested in JavaCPP, which is another alternative to JNI ([https://github.com/bytedeco/javacpp](https://github.com/bytedeco/javacpp)).
  prefs: []
  type: TYPE_NORMAL
- en: 147\. Motivating and introducing Project Panama
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Panama, or the Foreign Function & Memory (FFM) API, is an elegant way
    of saying goodbye to JNI. This project started in JDK 17 as JEP 412 (first incubator).
    It continued in JDK 18 as JEP 419 (second incubator), JDK 19 as JEP 424 (first
    preview), JDK 20 as JEP 434 (second preview), and JDK 21 as JEP 442 (third preview).
    This is where things are at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the goals of this project, we have to talk about accessing **off-heap**
    memory from Java applications. By off-heap memory, we mean the memory that is
    outside the JVM heap and is not managed by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surfing off-heap is the job of JNI, JNA, and JNR. In one way or another, these
    APIs can work in off-heap land to handle different tasks. Among these tasks, we
    can enumerate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use native libraries (for instance, some common libraries are Open CL/GL, CUDA,
    TensorFlow, Vulkan, OpenSSL, V8, BLAS, cuDNN, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share memory across different processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialize/deserialize memory content to the so-called *mmaps*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Java *de facto* API for accomplishing these kinds of tasks is `ByteBuffer`,
    or better, the so-called *allocated direct buffers*, which are more efficient
    in accessing off-heap memory. Alternatively, we can use JNI, or as you saw, third-party
    libraries such as JNA and JNR.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `ByteBuffer` and JNI have a lot of shortcomings that make them useful
    only in a limited number of scenarios. A few of their drawbacks are listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ByteBuffer`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brittle and error-prone
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstable memory addresses
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Backed by an array that can be manipulated by the garbage collector
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocated direct buffers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot scale when used as a general off-heap API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Works well only if used by power users who deeply understand its use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No solution for deallocation/free memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JNI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you saw in *Problem 144*, JNI is hard to use (even for simple cases)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is brittle and error-prone
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is difficult/expensive to maintain
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There is poor error checking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can crash the JVM
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These shortcomings and much more are behind the reason for the creation of
    Project Panama. The goal of this project is to become the new *de facto* API for
    interoperating with foreign data, functions, and memory in Java. To accomplish
    this goal, Project Panama has two main features:'
  prefs: []
  type: TYPE_NORMAL
- en: A future-proof API (low-level, efficient, robust, and safe) to replace the old-school
    API based on byte buffers – this is referred to as the memory access API and is
    capable of accessing on-heap and off-heap memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brand-new paradigm replaces the JNI concepts and mechanisms, so now we have
    an intuitive, easy-to-use, and robust solution for creating Java bindings for
    native libraries. This is referred to as the Foreign Linker API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next problems, we will dive deeper into this project.
  prefs: []
  type: TYPE_NORMAL
- en: 148\. Introducing Panama’s architecture and terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we talk about architecture, it helps to present a meaningful diagram,
    so here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8.png](img/B19665_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Project Panama architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram reveals the interoperability of Panama’s components. The climax
    of this diagram is the Jextract tool. As you’ll see in this chapter, Jextract
    is a very handy tool capable of consuming the headers of native libraries and
    producing low-level Java native bindings. These bindings are the unit of work
    for two major APIs of Project Panama:'
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Memory API – used to allocate/deallocate off-heap/on-heap memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreign Linker API – used to call foreign functions directly from Java and vice
    versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process described so far is entirely mechanical. When these APIs and the
    low-level Java native bindings are not enough for our tasks, then we can take
    things a step further and create a set of higher-level Java bindings. Of course,
    this is not a task for novices, but it is very powerful. For instance, you may
    have an existing automation tool for generating JNI bindings and now you want
    to modernize your tool to generate a higher level of pure Java bindings in Panama’s
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the abstractions used by Project Panama, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang.foreign.MemorySegment`: This API shapes a heap or native memory
    segment. A heap segment accesses on-heap memory, while a native segment accesses
    off-heap memory. In both cases, we’re talking about a contiguous region of memory
    that has a lifespan bounded by space and time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.foreign.Arena` (or `MemorySession` in JDK versions earlier than
    20): This API can control the memory segment’s lifespan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.foreign.MemorySegment.Scope`: This API represents the scope of a
    memory segment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.foreign.MemoryLayout`: This API describes the content of memory
    segments as *memory layouts*. For instance, among the available memory layouts,
    in the context of basic Java data types (`int`, `double`, `long`, and so on),
    we have *memory value layouts* (`java.lang.foreign.ValueLayout`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, next to these three pillars, we have many other classes and helpers.
    In the next problems, we will cover several scenarios meant to get us familiar
    with the major aspects of using Project Panama’s APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 149\. Introducing Arena and MemorySegment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `MemorySegment` shapes a heap or native memory segment. A heap segment accesses
    on-heap memory, while a native segment accesses off-heap memory. In both cases,
    we talk about a contiguous region of memory that has a lifespan bounded by space
    and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among its characteristics, a memory segment has a *size* in bytes, an *alignment*
    of bytes, and a *scope*. The scope is shaped via the `java.lang.foreign.MemorySegment.Scope`
    sealed interface and represents the lifespan of the memory segment. A native memory
    segment lifespan is controlled by a `java.lang.foreign.Arena` instance. An `Arena`
    has a scope that can be:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *arena global scope* (or *global arena*): The memory segments with the
    arena global scope are always accessible. In other words, the regions of memory
    allocated to these segments are never deallocated and their global scope remains
    alive forever.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to close (`close()`) this scope will result in `UnsupportedOperationException`.
    Here is an example of creating a native memory segment of 8 bytes in the arena
    global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The *arena auto scope*: The memory segments with the arena automatic scope
    are managed by the garbage collector. In other words, the garbage collector determines
    when the regions of memory backing these segments can be safely deallocated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempting to close (`close()`) this scope will result in an `UnsupportedOperationException`.
    Here is an example of creating a native memory segment of 8 bytes in the auto
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The *arena confined scope* (or, *confined arena*): Strict control of the memory
    segment’s lifespan (allocation/deallocation and lifetime) can be obtained via
    a confined arena. Typically, this scope lives in a `try-with-resources` block.
    When the `Arena` is closed (by explicitly calling `close()`, or by simply leaving
    the arena’s `try-with-resources` block), its scope is closed, all memory segments
    associated with this scope are destroyed, and memory is deallocated automatically.
    A confined arena is opened via `ofConfined()` and is owned by the current thread
    – the memory segments associated with the scope of a confined arena can only be
    accessed by the thread that created the arena.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code lines, a confined arena can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The *arena shared scope* (or, *shared arena*): A shared arena is typically
    opened in a `try-with-resources` block via `ofShared()` and can be shared by multiple
    threads – the memory segments associated with the scope of the shared arena can
    be accessed by any thread (for instance, this can be useful for performing parallel
    computations on memory segments). When the `Arena` is closed (by explicitly calling
    `close()`, or by simply leaving the arena’s `try-with-resources` block), its scope
    is closed, all memory segments associated with this scope are destroyed, and memory
    is deallocated automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code lines, a confined arena can be created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By calling `arena.scope()`, we obtain the `MemorySegment.Scope` of the arena,
    and by calling `arena.scope().isAlive()`, we can find out if the current scope
    is alive or not. A memory segment is accessible only if its scope is alive, so
    as long as the arena’s scope is alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a memory segment of 8 bytes in the arena scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Summarizing the main characteristics of arena scopes in a table can be done
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure a0.png](img/B19665_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Summarizing the main characteristics of arena scopes'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to monitor the allocated native memory, then this article will
    help you to do so: [https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/](https://www.morling.dev/blog/tracking-java-native-memory-with-jdk-flight-recorder/).
    Before going further, let’s briefly introduce *memory layouts*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing memory layouts (ValueLayout)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Memory layouts* are shaped by the `java.lang.foreign.MemoryLayout` interface
    and their goal is to describe the content of memory segments.'
  prefs: []
  type: TYPE_NORMAL
- en: We have *simple memory layouts*, including `ValueLayout` and `PaddingLayout`,
    but we also have *complex memory layouts* for describing complex memory segments
    such as `SequenceLayout`, `StructLayout`, `UnionLayout`, and `GroupLayout`. The
    complex layouts are useful to model hierarchical user-defined data types such
    as C-like sequences, structures, unions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating memory segments of value layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For now, we are interested in `ValueLayout`. This is a simple memory layout
    that is useful to represent basic Java data types such as `int`, `float`, `double`,
    `char`, `byte`, and so on. In an API-specific example, a `ValueLayout.JAVA_LONG`
    is a layout whose *carrier* is `long.class`, a `ValueLayout.JAVA_DOUBLE` is a
    layout whose *carrier* is `double.class`, and so on. The *carrier* of a value
    layout can be obtained via the `carrier()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s assume that we have a confined `arena` and need a memory
    segment for storing a single `int` value. We know that a Java `int` needs 4 bytes,
    so our segment can be allocated as follows (the first argument of `allocate()`
    is the `int` *byte size*, and the second argument is the `int` *byte alignment*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can achieve the same thing via `ValueLayout` as follows (here, we use
    `allocate(MemoryLayout layout)` and `allocate(long byteSize, long byteAlignment)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, without specifying the *byte alignment*, via `allocate(long byteSize)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example of allocating a memory segment for storing a Java `double`
    using the *byte alignment* specific to `ValueLayout.JAVA_DOUBLE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, allocating a memory segment for storing a Java `char` can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to allocate a memory segment to different data types, let’s
    see how we can set/get some values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting/getting the content of a memory segment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Arena` API provides a set of `allocate()` methods inherited from `SegmentAllocator`
    that can be used to allocate a memory segment and set its content in the same
    line of code (in the previous section, we used only the `allocate()` flavors that
    allocate memory segments but don’t set their content). For instance, calling `allocate(OfInt
    layout, int value)` allocates a memory segment for storing an `int` and sets that
    `int` to the given `value` (`OfInt` is an interface that extends `ValueLayout`).
    Here, we consider the `int` as being `Integer.MAX_VALUE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here we allocate a memory segment for a `char` and set that `char` to `a`
    (`allocate(OfChar layout, char value)`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: But if we want to set the content of a memory segment later (not at the same
    time as the allocation), then we can use the `MemorySegment.set()` or `setAtIndex()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can set the `Integer.MAX_VALUE` via `set(OfInt layout, long
    offset, int value)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument is the `offset` (0, 4, 8, 12, …), which in this case must
    be 0\. Alternatively, we can use `setAtIndex(OfInt layout, long index, int value)`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second argument represents an index exactly as in an array (0, 1,
    2, 3…). In this case, it must be 0 since we have a single integer stored in the
    memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting content from a certain offset can be done via `get()` and from a certain
    index via `getAtIndex()` methods. For instance, getting the `int` stored at a
    certain offset can be done via `get(OfInt layout, long offset)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the `int` stored at a certain index via `getAtIndex(OfInt layout, long
    index)`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the next problems, you’ll see more examples of using these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Java strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Allocating a memory segment for storing a Java `String` is a special case.
    If we have an `Arena` instance, then we can allocate a memory segment and set
    its content as a Java `String` via `allocateUtf8String(String str)` as follows
    (here, the Java string is `abcd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `allocateUtf8String(String str)` converts a Java `String` into a C-like
    string that is UTF-8-encoded and `null`-terminated. The size of the memory segment
    is obtained as `str.length` + 1.This means that we can allocate a segment for
    the `abcd` string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more expressive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Having the allocated memory segment, we can set the string via `setUtf8String(long
    offset, String str)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the string stored in a memory segment can be done via `MemorySegment.getUtf8String(long
    offset)`, so we can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 150\. Allocating arrays into memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to create memory segments for storing single values, let’s
    take it a step further and try to store an array of integers. For instance, let’s
    define a memory segment for storing the following array: [11, 21, 12, 7, 33, 1,
    3, 6].'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Java `int` needs 4 bytes (32 bits) and we have 8 integers, so we need a memory
    segment of 4 bytes x 8 = 32 bytes = 256 bits. If we try to represent this memory
    segment, then we can do it as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9.png](img/B19665_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: A memory segment of 8 integers'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code lines, we can allocate this memory segment via any of the following
    approaches (`arena` is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `set(OfInt layout, long offset, int value)` method to
    populate the memory segment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use the `setAtIndex(OfInt layout, long index, int value)` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We already know that we can access any of these integers via `get()` using
    the offset or via `getAtIndex()` using the index. This time, let’s try to use
    this memory segment to populate an `IntVector` (introduced in *Chapter 5*). The
    code should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So, the Vector API exposes the `fromMemorySegment()` method, especially to populate
    a vector from a memory segment. The `ByteOrder` can be `nativeOrder()`, which
    means the platform’s native order of bytes, `BIG_ENDIAN` (big-endian byte order),
    or `LITTLE_ORDER` (little-endian byte order).
  prefs: []
  type: TYPE_NORMAL
- en: 'A more convenient approach for populating the memory segment relies on a suite
    of `Arena.allocateArray()` methods inherited from `SegmentAllocator`. These methods
    create and populate the memory segment in a single line of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here it is a `char[]` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'All these examples allocate an off-heap memory segment. If we need an on-heap
    memory segment, then we can rely on `MemorySegment.ofArray()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For complete examples, please consider the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 151\. Understanding addresses (pointers)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A memory segment has a memory address (*pointer*) expressed as a `long` number.
    An off-heap memory segment has a *physical address* that points out the memory
    region that backs the segment (*base address*). Each memory layout stored in this
    segment has its own memory address as well. For instance, here is an example of
    querying the *base address* of a memory segment via the `address()` method (`arena`
    is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, an on-heap memory segment has a *non-physical stable virtualized*
    address typically representing an offset within the memory region of that segment
    (the client sees a stable address while the garbage collector can reallocate the
    region of memory inside the heap). For instance, an on-heap segment created via
    one of the `ofArray()` factory methods has an address of 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s focus only on off-heap memory segments. Let’s consider the following
    three memory segments containing integer values (`arena` is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these segments has a memory address. Next, let’s create a segment containing
    their addresses (like a segment of pointers). First, we allocate such a segment
    via `ValueLayout.ADDRESS` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Since each address is a `long` value, the size of `addrs` is 24 bytes. We can
    use the `set()` method and the offsets 0, 8, and 16 to set the addresses of `i1`,
    `i2`, and `i3`, or we can use the `setAtIndex()` and refer to offsets as indexes
    0, 1, and 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can represent this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11.png](img/B19665_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Storing i1, i2, and i3 addresses in an array of addresses'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we set the address of `i1` at offset 0 in `addrs`, the address
    of `i2` at offset 8, and the address of `i3` at offset 16\. The `addrs` segment
    doesn’t hold the data of `i1`, `i2`, and `i3`. It is just a segment of pointers
    that points to the memory addresses of `i1`, `i2`, and `i3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we call `get()`/`getAtIndex()`, we will get an address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can represent this in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 - Copy.png](img/B19665_07_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Getting addresses from the array of addresses'
  prefs: []
  type: TYPE_NORMAL
- en: 'But check out the return type. It is not a `long` value! It is a `MemorySegment`.
    The returned native memory segments (`addr1`, `addr2`, and `addr3`) are automatically
    associated with the *global scope*. They have the size 0 (*limit: 0*) and each
    of them wraps the returned address of the given offset/index (the `long` value
    is available via `addr1`/`2`/`3.address()`). However, in the case of an *unbounded*
    address layout, the size is expected to be `Long.MAX_VALUE` (9223372036854775807).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we shouldn’t do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This causes an `IndexOutOfBoundsException` since `addr1` has a size of 0 bytes
    – this is known as a *zero-length memory segment*. Getting the integer value associated
    with an address can be done via the `ofAddress()` and a flavor of the `reinterpret()`
    methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we call `ofAddress()` and pass the `addr1` address. This will create
    a native memory segment with the size 0\. Next, we call the `reinterpret()` method
    and pass the size of the `int` type. This will return a new memory segment (a
    reinterpreted memory segment) with the same address and scope as this segment,
    but with the given size (4 bytes). Finally, we read the integer value stored at
    this address at offset 0\. The same thing can be done for `addr2` and `addr3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before using the `reinterpret()` or `withTargetLayout()` methods, please consider
    the following note:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Important note**'
  prefs: []
  type: TYPE_NORMAL
- en: The `reinterpret()` method (and all other methods for working with zero-length
    memory segments) is considered a *restricted* method. It should be used with caution
    since any mistake can lead to a VM crash when trying to access the memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check whether two long addresses are equal via the `==` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, via `equals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have that `i1`=1, `i2`=3, and `i3`=2\. Let’s manipulate only
    the addresses to obtain `i1`=1, `i2`=2, and `i3`=3\. So, we want to switch the
    integer values of `i2` and `i3` by switching the addresses, not the values. First,
    we store the `i2` address as a `long`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set the `i2` address as the `i3` address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we set the address of `i3` as the address of `i2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, `i1`=1, `i2`=2, and `i3`=3\. I hope you found this exercise useful
    for understanding how to manipulate values, offsets, and memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 152\. Introducing the sequence layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Problem 149*, we already covered the `ValueLayout` for basic data types.
    Next, let’s talk about the *sequence layout* (`java.lang.foreign.SequenceLayout`).
  prefs: []
  type: TYPE_NORMAL
- en: 'But before introducing the sequence layout, let’s take a moment to analyze
    the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a native memory segment for storing 10 `double` values.
    Next, we rely on `setAtIndex()` to set these `double` values. Finally, we print
    them.
  prefs: []
  type: TYPE_NORMAL
- en: So, basically, we repeat the `ValueLayout.JAVA_DOUBLE` 10 times. When an *element
    layout* is repeated *n* times (a finite number of times), we can express the code
    via a sequence layout (`java.lang.foreign.SequenceLayout`). In other words, a
    sequence layout represents a repetition/sequence of a given *element layout* for
    a finite number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses `SequenceLayout` to shape the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The number of repetitions (*element count*) is 10, and the repeated *element
    layout* is `ValueLayout.JAVA_DOUBLE`.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we set the values of a sequence layout? There are at least two approaches,
    and one of them relies on a combination of the `java.lang.invoke.VarHandle` API
    and the `java.lang.foreign.MemoryLayout.PathElement` API.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing PathElement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, the `PathElement` API exposes a friendly approach for navigating
    a hierarchal memory layout via the so-called *layout path*. By chaining path elements
    in a layout path, we can locate an element layout, which can be a sequence layout
    (located via sequence path elements) or, as you’ll see in other problems, a group
    layout (which can be a struct layout or a union layout located via group path
    elements). Sequence layouts are traversed via `PathElement.sequenceElement()`,
    while group layouts via `PathElement.groupElement()`. Each element layout has
    a number of elements referred to as the *element count* (obtained via a method
    named `elementCount()`).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing VarHandle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`VarHandle` is not new to town. It was introduced in JDK 9\. A `VarHandle`
    is a dynamic, immutable, non-visible-state, strongly typed reference to a variable
    that cannot be subclassed. Its goal is to provide read/write access to the handled
    variables under certain circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `VarHandle` is characterized by two aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of variables represented by this `VarHandle` as a generic type (`T`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of Coordinate Types (denoted CT) used to locate variables referenced
    by this `VarHandle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CT list may be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a `VarHandle` method gets a variable number of `Object` arguments.
    Argument(s) checking is accomplished at runtime (static argument(s) checking is
    disabled). Different methods of `VarHandle` expect to have a variable number of
    arguments of different types.
  prefs: []
  type: TYPE_NORMAL
- en: Putting PathElement and VarHandle together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The path elements (layout path) are arguments of the `MemoryLayout.varHandle()`
    method, which is capable of returning a `VarHandle` that can be used to access
    a memory segment at the layout located via this layout path. The path is considered
    rooted in this layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our simple case, we can obtain a `VarHandle` for `seq` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Our path layout is just a simple navigation via `PathElement.sequenceElement()`.
    The returned `VarHandle` represents variables of the type `double` and contains
    a CT of (`MemorySegment` and `long`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MemorySegment` represents the memory segment from this sequence layout
    and the `long` value represents the index in this memory segment. This means that
    we can set 10 `double` values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting these 10 `double` values can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A `VarHandle` can be created via `arrayElementVarHandle(int... shape)` as well.
    This method creates a `VarHandle` for accessing a memory segment as a multi-dimensional
    array (this is known as a *strided var handler)*. The `varargs` argument, `shape`,
    represents the size of each nested array dimension. You can find this example
    in the bundle code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s complicate things a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Working with nested sequence layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the following sequence layout of 400 bytes (5 * 10 * 8 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here we have 5 sequence layouts of 10 `ValueLayout.JAVA_DOUBLE` each. Navigating
    to the `ValueLayout.JAVA_DOUBLE` requires a layout path obtained by chaining two
    calls of `sequenceLayout()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the memory segment, the `VarHandle` accepts two `long` values. The
    first `long` corresponds to the outer sequence layout, and the second `long` corresponds
    to the inner sequence layout. The number of elements (element count) for the outer
    sequence is 5, and it can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The element count of the inner sequence is 10, and it can be obtained via the
    `select()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `outer` fits the first `long` argument in the coordinate’s types of `nphandle`,
    while `inner` fits the second `long` argument. So, we can get/set the `double`
    values of our sequence as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see an example relying on `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(5,
    10)` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 153\. Shaping C-like structs into memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the C-like struct from the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16.png](img/B19665_07_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: A C-like structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in *Figure 7.13*, we have a C-like struct named `point` to shape an (*x*,
    *y*) pair of `double` values. Moreover, we have 5 such pairs declared under the
    name `pointarr`. We can try to shape a memory segment to fit this model as follows
    (`arena` is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we should set (*x*, *y*) pairs into this segment. For this, we can visualize
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17.png](img/B19665_07_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Memory segment to store (x, y) pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: But another approach consists of using the `StructLayout`, which is more suitable
    for this scenario since it provides a wrapping structure around the data.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing StructLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `StructLayout` is a group layout. In this layout, the members (other memory
    layouts) are laid out one after the other exactly as in a C struct. This means
    that we can shape our C-like struct by laying out two `ValueLayout.JAVA_DOUBLE`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'But we have 5 pairs of (*x*, *y*), so we need to nest this `StructLayout` in
    a `SequenceLayout` containing 5 `StructLayout`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as we already know from *Problem 152*, we need to define the proper layout
    paths via `PathElement` and get back the `VarHandle`. We need a `VarHandle` for
    *x* and one for *y*. Notice in the following code how we point them out via their
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `VarHandle` and the element count for setting the data,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the data is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Challenge yourself to implement this example via `ValueLayout.JAVA_DOUBLE.arrayElementVarHandle(int...
    shape)`.
  prefs: []
  type: TYPE_NORMAL
- en: 154\. Shaping C-like unions into memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the C-like union from the following figure (the members of a
    C union share the same memory location (the member’s largest data type dictates
    the size of the memory location), so only one of the members has a value at any
    moment in time):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18.png](img/B19665_07_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: A C-like union'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7.15*, we have a C-like union named `product` to shape two members,
    `price` (`double`) and `sku` (`int`), while only one can have a value at any moment
    in time. We can shape a memory segment to fit this model as follows (`arena` is
    an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Because `double` needs 8 bytes and `int` needs only 4 bytes, we choose `ValueLayout.JAVA_DOUBLE`
    to shape the size of the memory segment. This way, the segment can accommodate
    a `double` and an `int` at the same offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can set the `price` or the `sku` and use it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: When we set the `sku` (`int`), the value of `price` (`double`) became a *garbage
    value* and vice versa. For more details, check out the bundled code. Next, let’s
    see an alternative to this implementation based on `UnionLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing UnionLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `UnionLayout` is a group layout. In this layout, the members (other memory
    layouts) are laid out at the same starting offset exactly as in a C union. This
    means that we can shape our C-like union by laying out the `price` (`double`)
    and the `sku` (`int`) members as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, as we already know from *Problem 152*, we need to define the proper layout
    paths via `PathElement` and get back the `VarHandle`. We need a `VarHandle` for
    `price` and one for `sku`. Notice in the following code how we point them out
    via their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `VarHandle` to set `price` or `sku`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: When we set the `sku` (`int`), the value of `price` (`double`) became a *garbage
    value* and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 155\. Introducing PaddingLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data types are typically characterized by several properties: *size*, *alignment*,
    *stride*, *padding*, and *order* of bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*The padding layout* (`java.lang.foreign.PaddingLayout`) allows us to specify
    the *padding*. In other words, `PaddingLayout` allows us to add at certain offsets
    some extra space that is usually ignored by the applications but is needed to
    align the member layouts of a memory segment.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let’s consider the following two memory segments (the left-hand
    side is a memory segment without padding, while the right-hand side is a memory
    segment with two paddings of 4 bytes each).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19.png](img/B19665_07_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Memory segments with (right-hand side)/without (left-hand side)
    padding'
  prefs: []
  type: TYPE_NORMAL
- en: 'In code lines, the padding-free memory segment can be shaped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the size of `JAVA_INT` is 4 bytes, we can set *x* and *y* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This code writes the value 23 at offset 0, and 54 at offset 4\. No surprises,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we write the two `int` values (23 and 54) again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: This time, the padding zones are skipped, and 23 is written to offset 4, while
    54 is written to offset 12\. Reading *x* and *y* should be done from offset 4
    and offset 12, respectively. From 0 to 3, and from 8 to 11, we have extra space
    added via `paddingLayout()` that is ignored by the application. Attempting to
    read an `int` from these zones results in values of 0 (default values).
  prefs: []
  type: TYPE_NORMAL
- en: These examples have nicely and smoothly introduced the *padding* notion but
    they are not that useful in real scenarios. Remember that we said earlier that
    padding is useful for aligning the members of a memory segment. In order to understand
    this, let’s briefly hook a few more players.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking size, alignment, stride, and padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before continuing to work with padding, we need to cover some notions that are
    closely related to each other and work hand in hand with padding.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By *size*, we mean the amount of memory (in bytes/bits) occupied by a memory
    layout (data type, C-like struct, C-like union, sequence layout, and so on). We
    know that a Java `int` consumes 4 bytes, a Java `byte` consumes 1 byte, a C-like
    struct consumes a number of bytes calculated as the sum of each property’s size,
    a C-like union consumes a number of bytes equal to the bigger property’s size,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily query the size via `byteSize()`/`bitSize()`. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `npStruct` and `wpStruct` were introduced earlier in this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know that each member layout starts in a memory segment at a specific address.
    We say that this address is *k*-byte-aligned if this address is a multiple of
    *k* (where *k* is any power of 2) or if this address is evenly divisible by *k*.
    Commonly, *k* is 1, 2, 4, or 8\. Alignment is useful for sustaining CPU performance,
    which reads data in chunks of *k* bytes instead of reading byte by byte. If the
    CPU attempts to access a member layout that is not correctly aligned, then we’ll
    get an `IllegalArgumentException:` *Misaligned access at address …*.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of basic data types (`int`, `double`, `float`, `byte`, `char`, and
    so on), the alignment value is equal to their size. For instance, an 8-bit (1-byte)
    Java `byte` has a size of 1 byte and needs to be aligned to 1 byte. A 32-bit (4
    bytes) Java `int` has a size of 4 bytes and needs to be aligned to 4 bytes. In
    the case of a C-like struct/union, the alignment is the maximum alignment of all
    its member layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily query the alignment via `byteAlignment()`/`bitAlignment()`. Here
    are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: So, in a nutshell, a member layout should start with an address that must be
    at a multiple of its alignment. This applies to any kind of member layout (basic
    data type, C-like struct, C-like union, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Hooking stride
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The minimum byte distance between two member layouts is called a *stride*. The
    stride can be greater than or equal to the size. When we don’t face any alignment
    issues, the stride is equal to the size. Otherwise, the stride is computed by
    rounding up the size to the next multiple of the alignment. When the stride is
    greater than the size, it means that we also have some padding. If we have a C-like
    struct/union named `foo`, then the stride is the minimum byte distance between
    two `foo` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking padding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, padding is the amount of extra space that we need to add in order to preserve
    a valid alignment of the member layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you are a little bit confused about all these statements. We
    will clarify everything via a bunch of examples.
  prefs: []
  type: TYPE_NORMAL
- en: Adding implicit extra space (implicit padding) to validate alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a memory segment of 12 bytes and we have set an `int` of 4 bytes at
    offset 0 and a `char` of 2 bytes at offset 4 (immediately after the `int`). So,
    we still have 6 free bytes. Let’s assume that we want to set one more `int` of
    4 bytes after the `char`, `a`. What should the offset be? Our first thought may
    be that the proper offset is 6 since the `char` consumed 2 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we do this, then the result is `java.lang.IllegalArgumentException:`
    *Misaligned access at the address: …*. We have a misaligned member layout (the
    2000 `int` value) because 6 is not evenly divisible by 4, which is the byte alignment
    of `int`. Check out the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20.png](img/B19665_07_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: Fixing the misaligned issue'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what should we do? We know that the current offset is 6 and 6 is not evenly
    divisible by 4 (the `int` alignment). So, we are looking for the next offset that
    is evenly divisible by 4 and is the closest and greater than 6\. Obviously, this
    is 8\. So, before we set the 2000 `int` value, we need a padding of 2 bytes (16
    bits). This padding will be automatically added if we simply specify the offset
    8 instead of 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Since our memory segment has a size of 12 bytes, we fit this `int` exactly on
    bytes 8, 9, 10, and 11\. A smaller size of the segment leads to an `IndexOutOfBoundsException:`
    *Out of bound access on segment MemorySegment*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding explicit extra space (explicit padding) to validate alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the following C-like struct (let’s denote this as *Case 1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `product` size returned via `byteSize()` is 7 bytes (4 + 2 + 1). The `product`
    alignment returned via `byteAlignment()` is 4 (the greater alignment of 4, 2,
    and 1). The byte offset of each member layout returned by `byteOffset()` is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we represent this via a diagram, we obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21.png](img/B19665_07_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: The representation of the struct'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything looks fine, so we can go further. Now, let’s use the same struct,
    but we arrange the member layouts as follows (let’s denote this as *Case 2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: First, we place the `energy` (`char`) at offset 0\. Since `energy` (`char`)
    consumes 2 bytes, it is followed by `sku` (`int`) at offset 2\. Since `sku` (`int`)
    consumes 4 bytes, it is followed by `weight` (`byte`). But is this the correct
    logic? As you can see in the following figure (left-hand side), this logic is
    incorrect, because we have an invalid alignment error at offset 2 for the `sku`
    (`int`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22.png](img/B19665_07_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Incorrect/correct padding'
  prefs: []
  type: TYPE_NORMAL
- en: The alignment of `energy` (`char`) is 2, so it can start only on 0, 2, 4, ….
    Since `energy` (`char`) is the first, we start with it on offset 0\. Next, the
    alignment of `sku` (`int`) is 4, so it can start only on 0, 4, 8, …. That is why
    the start address of `sku` is at 4 and not at 2\. Finally, the alignment of `weight`
    (`byte`) is 1, so it can go after `sku` (`int`) at offset 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, by following the alignment rules, we conclude that the size of `product`
    is 9, not 7\. At this point, we know that to align `sku` (`int`), we should add
    a padding of 2 bytes (16 bits) at offset 2, so let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s assume that we want to repeat this C-like struct 2 times (or *n*
    times). For this, we nest the struct in a sequence layout as follows (let’s denote
    this as *Case 3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the code fails with an exception as `IllegalArgumentException:`
    *Element layout size is not multiple of alignment*. What’s happening now? Well,
    the first struct instance lies out from offset 0 to offset 8, and, conforming
    to our code, the second struct lies out from offset 9 to offset 18, as in the
    following figure (top diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23.png](img/B19665_07_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Calculating stride'
  prefs: []
  type: TYPE_NORMAL
- en: But this is not correct, because the second instance of the struct (and the
    third, fourth, and so on) doesn’t follow the alignment rules. The alignment of
    the struct is 4, so an instance of the struct should be at 0, 4, 8, 12, 16, …,
    but not at 9\. This means that we need to calculate the *stride*, which gives
    us the minimum byte distance between two member layouts – here, two instances
    of our struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have that the size of the struct instance is 9 and its alignment is 4\.
    So, we need to find the offset evenly divisible by 4 that is greater and closest
    to 9\. This is 12\. Since the *stride* is 12, it means that the second instance
    of the struct starts at offset 12\. We need to add a padding of 3 (12-9) bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Done! As you can see, the order of member layouts counts a lot. By being aware
    of the size, alignment, stride, and padding, we can optimize the memory allocation
    by simply arranging the member layouts in a proper order that requires 0 or minimum
    padding.
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code, you can find more examples of permutating the member layout
    of our struct.
  prefs: []
  type: TYPE_NORMAL
- en: 156\. Copying and slicing memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the following memory segment (`arena` is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can copy the content of this segment.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make a copy of this memory segment via `copyFrom(MemorySegment src)`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily see if the data was copied as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This is a bulk operation that creates a full copy of the given memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a part of the segment into another segment (1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s suppose that we want to copy only a part of `srcSegment` into another
    segment (`dstSegment`). For instance, if we wanted to copy the last 8 elements
    ([22, 33, -1, -1, -1, -1, -1, 4]) from `srcSegment` to `dstSegment`, we’d start
    by allocating the `dstSegment` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `copy(MemorySegment srcSegment, long srcOffset, MemorySegment
    dstSegment, long dstOffset, long bytes)` method as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 - Copy.png](img/B19665_07_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Copying a part of a segment into another segment (1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we specify the source segment as `srcSsegment`, the source offset as 32
    (skip the first 8 elements), the destination segment as `dstSegment`, the destination
    offset as 0, and the number of bytes to be copied as 32 (the last 8 elements are
    copied):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Practically, we copied half of the `srcSegment` to `dstSegment`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a segment into an on-heap array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s suppose that we want to copy only a part of `srcSegment` into an on-heap
    Java regular array (`dstArray`). For instance, if we wanted to copy the last 8
    elements ([22, 33, -1, -1, -1, -1, -1, 4]) from `srcSegment` to `dstArray`, we’d
    start by creating the `dstArray` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’d call `copy(MemorySegment srcSegment, ValueLayout srcLayout, long
    srcOffset, Object dstArray, int dstIndex, int elementCount)`, as in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 - Copy - Copy.png](img/B19665_07_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Copying a segment into an on-heap array'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we specify the source segment as `srcSegment`, the source layout as `JAVA_INT`,
    the source offset as 32 (skip the first 8 elements), the destination array as
    `dstArray`, the destination array index as 0, and the number of elements to be
    copied as 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Practically, we copied half of the off-heap `srcSegment` to the on-heap `dstArray`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying an on-heap array into a segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s suppose that we want to copy an on-heap array (or a part of it) into
    a segment. The given on-heap array is `srcArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The destination segment can hold 16 integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to overwrite the last 8 elements from `dstSegment` with the elements
    from `srcArray`, while the first elements remain 0\. For this, we call `copy(Object
    srcArray, int srcIndex, MemorySegment dstSegment, ValueLayout dstLayout, long
    dstOffset, int elementCount)`, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 - Copy - Copy - Copy.png](img/B19665_07_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Copying an on-heap array into a segment'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we specify the source array as `srcArray`, the source index as 0, the destination
    segment as `dstSegment`, the destination layout as `JAVA_INT`, the destination
    offset as 32 (skip the first 8 elements), and the number of elements to be copied
    as 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Practically, we copied the on-heap `srcArray` as the second half of the off-heap
    `destSegment`.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a part of the segment into another segment (2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s consider the `srcSegment` (1, 2, 3, 4, -1, -1, -1, 52, 22, 33, -1, -1,
    -1, -1, -1, 4) and the `dstSegment` (0, 0, 0, 0, 0, 0, 0, 0, 10, 44, 2, 6, 55,
    65, 7, 89) from the previous sections. We want to copy the last 8 elements from
    `srcSegment` as the first 8 elements from `dstSegment` (22, 33, -1, -1, -1, -1,
    -1, 4, 10, 44, 2, 6, 55, 65, 7, 89). We know that this can be done via `copy(MemorySegment
    srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `copy(MemorySegment srcSegment, ValueLayout srcElementLayout,
    long srcOffset, MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,
    long elementCount)`, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 - Copy - Copy (2).png](img/B19665_07_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: Copying a part of a segment into another segment (2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we specify the source segment as `srcSegment`, the source layout as `JAVA_INT`,
    the source offset as 32 (skip the first 8 elements), the destination segment as
    `dstSegment`, the destination layout as `JAVA_INT`, the destination offset as
    0, and the number of elements to be copied as 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to test this method with different value layouts. Next, let’s talk
    about slicing.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing a segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s suppose that we want to slice the segment containing (1, 2, 3,
    4, -1, -1, -1, 52, 22, 33, -1, -1, -1, -1, -1, 4) into three separate `IntVector`
    instances the values that are not -1 without using the `copy()` methods. So, `v1`
    should contain [1, 2, 3, 4], `v2` should contain [52, 22, 33, 0], and `v3` should
    contain [4, 0, 0, 0]. Since an `int` needs 4 bytes, and we have a maximum of 4
    `int` values, we go for `SPECIES_128` (4 `int` values x 4 bytes = 16 bytes x 8
    bits = 128 bits):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to slice the memory segment in order to eliminate the values
    of -1\. This can be accomplished via the `asSlice(long offset)` and `asSlice(long
    offset, long newSize)` methods. The first argument represents the starting offset.
    The second argument represents the size of the new memory segment. The following
    figure helps us to clear this up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24.png](img/B19665_07_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Slicing a memory segment'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first memory segment starts at offset 0 and ends at offset 16, so it contains
    4 `int` values of 4 bytes (`asSlice(0, 16)`). The second memory segment starts
    at offset 28 and ends at offset 40, so it contains 3 `int` values of 4 bytes (`asSlice(28,
    12)`). Finally, the third memory segment starts at offset 60 and ends at the end
    of the segment, so it contains a single `int` value of 4 bytes (`asSlice(60)`
    or `asSlice(60, 4)`). The resulting code is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Of course, we can slice a memory segment in regular Java arrays as well.
    Here you go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The `toArray()` method returns a Java regular array (here, `int[]`) from the
    sliced memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: Using asOverlappingSlice()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `asOverlappingSlice(MemorySegment other)` method returns a slice of this
    segment that overlaps the given segment as an `Optional<MemorySegment>`. Consider
    the following segment (`arena` is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we slice it at offset 12, so at value 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call `asOverlappingSlice()` to see where the overlapping occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The resulting array is [4, 6, 8, 4, 5, 3].
  prefs: []
  type: TYPE_NORMAL
- en: Using segmentOffset()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `segmentOffset(MemorySegment other)` returns the offset of the given segment
    (`other`) relative to this segment. Consider the following segment (`arena` is
    an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we slice it at offset 16, so at value 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call `segmentOffset()` to find out at what offset in `segment` we
    have `subsegment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: You can practice all these examples in the bundled code. Challenge yourself
    to explore `MemorySegment.mismatch()` further.
  prefs: []
  type: TYPE_NORMAL
- en: 157\. Tackling the slicing allocator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the following three Java regular `int` arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to allocate a memory segment to each of these arrays. A straightforward
    approach relies on `Arena.allocateArray()` introduced in *Problem 150*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This approach allocates enough memory to accommodate each of the given arrays.
    But, sometimes, we want to allocate only a certain amount of memory. If this fixed
    amount is not enough, then we want to tackle the problem differently. For this,
    we can rely on a `java.lang.foreign.SegmentAllocator`. Of course, there are many
    other scenarios when `SegmentAllocator` is useful, but for now, let’s tackle the
    following one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we allow allocating a fixed size of 10 * 4 = 40 bytes. This
    is a bulk amount of memory that should be sliced between our three arrays. First,
    we allocate these 40 bytes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the `allocator` to allocate a slice from these 40 bytes to each
    array. The first array (`arr1`) has 6 values, so the memory segment gets 6 * 4
    = 24 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The segment allocator has available 40 – 24 = 16 more bytes. The second array
    (`arr2`) has 3 values, so the memory segment gets 3 * 4 = 12 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The segment allocator has available 16 – 12 = 4 more bytes. The third array
    (`arr3`) has 5 values, so it needs a memory segment of 5 * 4 = 20 bytes, but only
    4 are available. This causes an `IndexOutOfBoundsException` and gives us the control
    to handle this corner case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible approach to avoid this `IndexOutOfBoundsException` may consist of
    giving more memory to the segment allocator. In this case, we need to give it
    16 more bytes, so we can express it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you don’t have to write 10 * 4 + 4 * 4\. You can say 14 * 4, or just
    56\. Basically, our three arrays have 14 elements of 4 bytes each, and initially,
    we covered only 10 of them. Next, we increased the memory to cover the remaining
    4 as well.
  prefs: []
  type: TYPE_NORMAL
- en: 158\. Introducing the slice handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following nested model (10 sequences of 5 `double`
    values each):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `VarHandle` via `PathElement` and we populate this model
    accordingly with some random data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, you should be familiar with this code, so nothing new so far. Next, we
    plan to extract from this model the third sequence from 10 containing 5 sequences
    of `double` values. We can accomplish this via the `sliceHandle(PathElement...
    elements)` method, which returns a `java.lang.invoke.MethodHandle`. This `MethodHandle`
    takes a memory segment and returns a slice of it corresponding to the selected
    memory layout. Here is the code for our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, you know how to slice out a certain memory layout from the given
    memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: 159\. Introducing layout flattening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data in a memory segment named `segment` (you can see the code
    listed in *Problem 158*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to take this nested model and obtain a flat model. So, instead
    of having 10 sequences of 5 `double` values each, we want one sequence of 50 `double`
    values. This can be achieved via the `flatten()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `PathElement`, which traverses a single sequence. This is the sequence
    that resulted after the flatten operation. We can go further and allocate another
    memory segment for this sequence and set new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s see how we can reshape a memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: 160\. Introducing layout reshaping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data (you can see the code listed in *Problem 158*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to reshape this model to look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'So, instead of having 10 sequences of 5 `double` values each, we want 25 sequences
    of 2 `double` values each. In order to accomplish this reshaping goal, we can
    rely on the `reshape(long... elementCounts)` method. This method takes the elements
    of this sequence layout and re-arranges them into a multi-dimensional sequence
    layout conforming to the given list of element counts per sequence. So, in our
    case, we do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: You can see the complete example in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 161\. Introducing the layout spreader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s suppose that we have the following nested model (the exact same model
    as in *Problem 158*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a `VarHandle` via `PathElement` and we populate this model accordingly
    with some random data in a memory segment named `segment` (you can see the code
    listed in *Problem 158*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s assume that we want to extract the third `double` value from the
    seventh sequence (count starts from 0). Among the approaches, we can rely on `sliceHandle()`
    introduced in *Problem 158,* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach consists of using an *array-spreading* method handle. In other
    words, by calling the `asSpreader(Class<?> arrayType, int arrayLength)` method,
    we can obtain a *spreader-array* that contains the positional arguments that we
    want to pass over and has a length equal to the given `arrayLength`. Since we
    have two pass-over `long` arguments (7L and 3L), we need a `long[]` array of length
    2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You may also be interested in `asCollector(Class<?> arrayType, int arrayLength)`,
    which is basically the opposite of `asSpreader()`. You give a list of arguments
    and this method collects them in an *array-collecting*.
  prefs: []
  type: TYPE_NORMAL
- en: 162\. Introducing the memory segment view VarHandle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider the following simple memory segment for storing an int (`arena`
    is an instance of `Arena`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that we can create a `VarHandle` via `PathElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, via `arrayElementVarHandle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MethodHandles.memorySegmentViewVarHandle(ValueLayout layout)` is another
    approach for creating a `VarHandle` that can be used to access a memory segment.
    The returned `VarHandle` perceives/views the content of the memory segment as
    a sequence of the given `ValueLayout`. In our case, the code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can rely on `insertCoordinates(VarHandle target, int pos, Object...
    values)` to specify the set of *bound coordinates* before the `VarHandle` is actually
    invoked. In other words, the returned `VarHandle` will expose fewer Coordinate
    Types (CTs) than the given `target`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the `target` argument (invoked after inserting the set of *bound
    coordinates*) is `viewhandle`. The position of the first coordinate is 1, and
    we have a single *bound coordinate* representing the offset 0 of type `long`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we call the popular `VarHandle.set/get(Object...)` on the returned
    `VarHandler`, the incoming coordinate values are automatically joined with the
    given *bound coordinate* values. The result is passed to the target `VarHandle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now, you know three ways to create a `VarHandle` for dereferencing a memory
    segment.
  prefs: []
  type: TYPE_NORMAL
- en: 163\. Streaming memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combining the Java Stream API with memory segments can be achieved via the `elements(MemoryLayout
    elementLayout)` method. This method gets an element layout and returns a `Stream<MemorySegment>`,
    which is a sequential stream over disjointed slices in this segment. The stream
    size matches the size of the specified layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following memory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare two `VarHandle` and set some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume that we want to sum up all data. For this, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can simply pass the proper layout and even empower parallel processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Both approaches return 28 = 5 + 9 + 6 + 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about summing only the values from the first (*x*, *y*) pair? For this,
    we have to slice the layout corresponding to the first (*x*, *y*) pair via `sliceHandle()`
    – we introduced this method in *Problem 151*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we slice the segment of the first (*x*, *y*) pair (if we replace 0 with
    1, then we obtain the segment of the second (*x*, *y*) pair):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we use it to calculate the needed sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The result is clear, 14 = 5 + 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about summing *y* from the first pair with the second pair (*x*, *y*)?
    For this, we can slice the proper segment via `asSlice()` – we introduced this
    method in *Problem 156*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The `asSlice(4)` simply skips the first *x* since this is stored at offset 0
    and consumes 4 bytes. From offset 4 to the end, we have the first *y*, and the
    second pair (*x*, *y*). So, the result is 23 = 9 + 6 + 8.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, this time, we have used a shared arena (`Arena.ofShared()`). This
    is needed for parallel computations since the segment should be shared between
    multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: Done! Feel free to challenge yourself to solve more such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 164\. Tackling mapped memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that a computer has limited physical memory, referred to as RAM. Common
    sense, though, tells us that we cannot allocate a memory segment larger than the
    available RAM (this should lead to an out-of-memory error). But this is not quite
    true! Here is where *mapped memory segments* come into the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The mapped memory segment represents virtual memory and can be huge (gigabytes,
    terabytes, or whatever you may think of). This virtual memory is actually memory
    mapped by files or shortly *memory-mapped files* (a file can be from a regular
    file to any other kind of file descriptor).
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, at any time, only a part of the virtual memory lives in the real
    memory. This is why we can allocate terabytes of virtual memory on a laptop with
    much less real RAM. Practically, a portion of missing mapped memory is loaded
    on demand in the real RAM. While loading, the process operating on this memory
    is temporarily suspended.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of mapped memory files is to drastically reduce the I/O operations.
    The standard read/write operations rely on copying data into buffers, while mapped
    files put the file data directly into the process address space. This is much
    faster and sharable across processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we can set a mapped memory file via the `java.nio.channels.FileChannel`
    API, more precisely, via the `map(MapMode mode, long offset, long size, Arena
    arena)` method. Here is an example of setting a mapped memory file of 1 MB and
    writing/reading some text into it (feel free to try it on your machine for a file
    that is 1 GB (1,073,741,824 bytes) or larger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: When a file contains a significant number of empty bytes (so-called holes, `\x00`)
    it becomes a good candidate to become a *sparse* file. In a sparse file, these
    holes are no longer kept on the storage device, so they no longer consume physical
    memory. This is an attempt at using memory more efficiently and stops consuming
    physical memory with zero-byte blocks. Each operating system has its own way of
    handling sparse files, but generally speaking, the zero-byte blocks are simply
    reduced to some meaningful metadata useful for dynamically generating them. For
    more details and a useful diagram, consider this Wikipedia article ([https://en.wikipedia.org/wiki/Sparse_file](https://en.wikipedia.org/wiki/Sparse_file)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we can create a sparse file by adding the `java.nio.file.StandardOpenOption.SPARSE`
    option to the list of options next to `CREATE_NEW`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your operating system (machine), you should use dedicated tools
    to inspect these files in detail and get a deeper insight into how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find yourself using mapped memory files quite often, then you may prefer
    to extend the `Arena` interface and provide your own implementation starting from
    a simple skeleton, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `MappedArena` is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can improve/modify this code to obtain other configurations.
    Maybe you want a confined arena (here, we have a shared arena), maybe you want
    to delete the files after the arena is closed (here, the files remain on disk,
    so you can inspect them), maybe you don’t need sparse files (here, we use sparse
    files), maybe you prefer another file name (here, we concatenate the given name
    with `System.currentTimeMillis()` and the `.txt` extension), or maybe you need
    to take into account byte alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 165\. Introducing the Foreign Linker API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of the Foreign Linker API is to provide a robust and easy-to-use
    API (no need to write C/C++ code) for sustaining interoperability between the
    Java code and C/C++ foreign functions of native shared libraries (in the future,
    other programming languages will be supported via this API).
  prefs: []
  type: TYPE_NORMAL
- en: 'The journey of calling foreign code starts with the `java.lang.foreign.SymbolLookup`
    functional interface. This interface represents the entry point and consists of
    looking up the address of a given symbol in a loaded native shared library. There
    are three ways of doing this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Linker.defaultLookup()` – as its name suggests, `defaultLookup()` represents
    a *default lookup* that scans and locates all the symbols of the commonly used
    native shared libraries depending on the current operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '`SymbolLookup.loaderLookup()` – represents a *loader lookup* that scans and
    locates all the symbols in all the native shared libraries loaded in the current
    class loader (via `System.loadLibrary()` and `System.load()` based on `java.library.path`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '`SymbolLookup.libraryLookup(String name, Arena arena)` – represents a *library
    lookup* capable of scanning and loading in the arena scope a native shared library
    with the given name. It also creates a symbol lookup for all symbols in that native
    shared library. Alternatively, we can specify a `Path` via `SymbolLookup.libraryLookup(Path
    path, Arena arena)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: If this step is successfully accomplished, then we can choose the symbol(s)
    corresponding to the foreign function(s) that we want to call. Finding a foreign
    function can be done by its name via the `SymbolLookup.find(String name)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the pointed method exists among the located symbols, then `find()` returns
    a zero-length memory segment wrapped in an `Optional (Optional<MemorySegment>)`.
    The *base address* of this segment points to the foreign function’s entry point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have located the native shared library and found one of its methods
    (`fooFunc`). Next, we have to link Java code to this foreign function. This is
    accomplished via the `Linker` API, which is based on two concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*downcall* – call the native code from Java code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*upcall –* call the Java code from the native code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two concepts are materialized by the `Linker` interface. *downcall* is
    mapped in two methods with the following signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Typically, the `default` method is used via the `MemorySegment` obtained earlier
    via the `find()` method, a function descriptor that describes the signature of
    the foreign function, and an optional set of linker options. The returned `MethodHandle`
    is used later to invoke the foreign function via `invoke()`, `invokeExact()`,
    and so on. Via `invoke()` or `invokeExact()`, we pass arguments to the foreign
    function and access the returned result of running the foreign function (if any).
  prefs: []
  type: TYPE_NORMAL
- en: '*upcall* is mapped by the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Typically, the `target` argument refers to a Java method, the `function` argument
    describes the Java method signature, and the `arena` argument represents the arena
    associated with the returned `MemorySegment`. This `MemorySegment` is passed later
    as an argument of the Java code that invokes (`invoke()`/`invokeExact()`) a *downcall*
    method handle. As a consequence, this `MemorySegment` acts as a function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we glue this knowledge together, then we can write a classical example of
    calling the `getpid()` method (on Windows 10, `_getpid()` – [https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/getpid))
    as follows (consider reading the meaningful comments to get insight on each step):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: This code was tested on Windows 10\. If you run a different operating system,
    then consider informing yourself about this foreign function to adjust the code
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 166\. Calling the sumTwoInt() foreign function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember the `sumTwoInt()` function? We have defined this C function
    in a native shared library named `math.dll` (check *Problems 144*, *145*, and
    *146*). Let’s assume that we have placed the `math.dll` library in the project
    folder under the `lib/cpp` path.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this foreign function in almost the same manner as we’ve called
    `_getpid()`. Since `math.dll` is a user-defined library that is not commonly used,
    it cannot be loaded via `defaultLookup()`. The solution is to explicitly load
    the library from the `lib/cpp` path, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to find in `math.dll` the foreign function by name. If your C
    compiler (for instance, G++) has applied the *mangling* (or *name decoration*)
    technique, then `sumTwoInt` will have been renamed in the library to something
    else (here, `_Z9sumTwoIntii`) and that name should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `MethodHandle` for this *downcall*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can invoke the foreign function and get the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The result should be 12\. Check out the complete code in the bundled code.
  prefs: []
  type: TYPE_NORMAL
- en: 167\. Calling the modf() foreign function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider that we want to call the `modf()` foreign function. This function
    is part of the C standard library with the following syntax ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/modf-modff-modfl)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: This method gets a `double x` and returns the signed fractional part of `x`.
    The `intptr` is a pointer argument used to point to the memory address where the
    integer part should be stored as a `double` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this method is part of UCRT, it can be found via `defaultLookup()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing new so far! Next, we need to define the proper `MethodHandle`. Because
    the second argument of `modf()` is a pointer, we need to specify a value layout
    of type `ADDRESS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'If we could invoke the foreign function at this point, we could collect the
    fractional part of the given `x`, but we cannot obtain the integer part. We have
    to create a memory segment and pass this memory segment to the foreign function
    at invocation time. The foreign function will write the integer part in this memory
    segment, which should be capable of storing a `double` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The fractional part is returned by the foreign key. The integer part is read
    from the memory segment at offset 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'If `x` = 89.76655, then the output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Challenge yourself to adapt this code to call `modff()` and `modfl()` foreign
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 168\. Calling the strcat() foreign function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `strcat()` foreign function is part of the C standard library and has the
    following signature ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/strcat-wcscat-mbscat)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'This function appends the `strSource` at the end of the `strDestination`. The
    function doesn’t get these strings. It gets two pointers to these strings (so,
    two `ADDRESS`) and doesn’t return a value, so we rely on `FunctionDescriptor.ofVoid()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the arguments of `strcat()` are two pointers (`ADDRESS`), we have to
    create two memory segments and set the strings accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the size of `segmentStrDestination`. Since `strcat()` appends the source
    string (`strSource`) at the end of the destination string (`strDestination`),
    we have to prepare the size of `segmentStrDestination` to fit the source string
    as well, so its size is `strSource.length() + 1 + strDestination.length() + 1`.
    Next, we can invoke the foreign function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we read the result from `segmentStrDestination`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: So, the `World` string was appended at the end of `Hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 169\. Calling the bsearch() foreign function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `bsearch()` foreign function is part of the C standard library and has
    the following signature ([https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch](https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/bsearch)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: In a nutshell, this method gets pointers to a key, a sorted array (`base`),
    and a comparator. Its goal is to use the given comparator to perform a binary
    search of the given `key` in the given array. More precisely, `bsearch()` gets
    a pointer to the `key`, a pointer to the array, the number of elements in the
    array (`num`), the size of an element in bytes (`width`), and the comparator as
    a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function gets a pointer to `key` and a pointer to the current element
    of the array to be compared with `key`. It returns the result of comparing these
    two elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `bsearch()` function returns a pointer in the array pointing to the occurrence
    of the key. If the given key is not found, then `bsearch()` returns `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start by coding the comparator callback function as a Java method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The `i1` memory segment is the pointer to `key`, and the `i2` memory segment
    is the pointer to the current element of the array to be compared with `key`.
    This method will be called by the foreign function (native code calls Java code),
    so an *upcall stub* should be prepared. First, we need a method handle pointing
    to this comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we create the *upcall stub*. For this, we need the `Linker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'And we are ready to use the confined arena:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the `withTargetLayout()` method to create an *unbounded*
    address. The *unbounded* `ADDRESS` means addresses for which we don’t know the
    size, so it is better to ensure that enough space will be available by setting
    them as *unbounded*. Practically, by creating a target sequence layout without
    an explicit size, we obtain a native memory segment with maximal size. Next, we
    find the `bsearch()` method and define its method handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we prepare the `key` and the `array` arguments as `MemorySegment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'We have all the needed arguments, so we can invoke `bsearch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that `bsearch()` returns a pointer in the `array` pointing to
    the first occurrence of the `key`, or it returns `NULL` if the given `key` is
    not found in the given `array`. If `bsearch()` returned `NULL`, then the result
    should match `MemorySegment.NULL`, which is a zero-length native segment representing
    a `NULL` address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we know that the result represents a pointer in the given `array`.
    So, we can rely on the `segmentOffset()` method (introduced in *Problem 149*)
    to find the offset of the result relative to `array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: For our `key` (14) and `array`, the returned offset is 24.
  prefs: []
  type: TYPE_NORMAL
- en: 170\. Introducing Jextract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jextract ([https://github.com/openjdk/jextract](https://github.com/openjdk/jextract))
    is a very handy tool capable of consuming the headers of native libraries (`*.h`
    files) and producing low-level Java native bindings. Via this tool, we can save
    a lot of time since we can focus only on calling native code without caring about
    the mechanical steps of loading libraries, writing method handles, or *downcall*
    and *upcall stubs*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jextract is a command-line tool that can be downloaded from [https://jdk.java.net/jextract](https://jdk.java.net/jextract).
    The main options of this tool are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--source`: When we write `jextract --source`, we instruct Jextract to generate
    from the given header file the corresponding source files without classes. When
    this option is omitted, Jextract will generate classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-- output path`: By default, the generated files are placed in the current
    folder. Via this option, we can point out the path where these files should be
    placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t <package>`: By default, Jextract uses the unnamed package name. Via this
    option, we can specify the package name for the generated classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-I <dir>`: Specify one or more paths that should be appended to the existing
    search paths. The given order is respected during the search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dump-includes <String>`: This option allows you to filter the symbols. First,
    use this option to extract all symbols in a file. Next, edit the file to keep
    only the needed symbols. Finally, pass this file to Jextract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete list of options is available at [https://github.com/openjdk/jextract](https://github.com/openjdk/jextract).
  prefs: []
  type: TYPE_NORMAL
- en: 171\. Generating native binding for modf()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Problem 160*, we located, prepared, and called the `modf()` foreign function
    via the Foreign Linker API. Now, let’s use Jextract to generate the native binding
    needed to call `modf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, the `modf()` foreign function is described in the `math.h` header
    file. If you have installed MinGW ([https://sourceforge.net/projects/mingw-w64/](https://sourceforge.net/projects/mingw-w64/))
    for 64-bit, then this header file is available in the `mingw64\x86_64-w64-mingw32\include`
    folder. If we want to generate the native bindings for `math.h`, we can do it
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25.png](img/B19665_07_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: Generating the native bindings from math.h'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: So, we generated the source files (`--sources`) in the `src\main\java` subfolder
    of the current project (`--output`), in the package `c.lib.math` (`-t`). The `math.h`
    is loaded from `mingw64\x86_64-w64-mingw32\include`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this command, you’ll find in `c.lib.math` the native bindings
    for all the symbols found in `math.h`. Most probably, this is not what we want,
    since we’re calling only the `modf()` foreign function. Filtering symbols is a
    two-step process. First, we generate a *dump* of all symbols, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26.png](img/B19665_07_27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Creating a dump file containing all symbols from math.h'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will write in the project root a file named `includes.txt` containing
    all symbols found in `math.h`. The second step consists of editing this file.
    For instance, we have kept only the symbol for `modf()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27.png](img/B19665_07_28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.28: Editing the includes.txt to keep only the needed symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we pass the edited `includes.txt` to Jextract, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28.png](img/B19665_07_29.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.29: Run Jextract with the filtered includes.txt'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, in `c.lib.math`, you’ll find the native bindings only for the `modf()`
    foreign function. Take your time to inspect each of these files and see how they
    interact at the code level. Since we generate only the sources, we have to compile
    the project to obtain the classes. If you prefer to generate the classes directly
    via Jextract, then you can use the following command (now, the sources will not
    be generated, only the classes):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29.png](img/B19665_07_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: Generating the classes of native bindings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, as plain text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the generated bindings in a Java application to call the `modf()`
    function. The code is straightforward (we don’t need to write the method handle
    and there is no need to explicitly use `invoke()`/`invokeExact()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: The `modf()` function is imported from the `c.lib.math.math_h` package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered 28 problems. Most of them were focused on the new Foreign
    (Function) Memory APIs, or Project Panama. As you saw, this API is much more intuitive
    and powerful than the classical approaches of using JNI, JNA, and JNR. Moreover,
    the Jextract tool is very handy for generating native bindings from the headers
    of native shared libraries and saves us a lot of mechanical work.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/8mgytp5DGQ](https://discord.gg/8mgytp5DGQ )'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1139613064111216156.png)'
  prefs: []
  type: TYPE_IMG
