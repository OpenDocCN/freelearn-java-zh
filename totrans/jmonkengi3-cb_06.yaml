- en: Chapter 6. GUI with Nifty GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, what is **Nifty GUI**? It's not the only GUI available in jMonkeyEngine,
    but it is the one that is officially supported. It is not developed by the jMonkeyEngine
    team but is an independent open source effort that has implementations in other
    engines as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Nifty and managing an options menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an RPG dialog screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a game console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a game message queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an inventory screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the input and settings page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using offscreen rendering for a minimap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nifty GUI is operated using screens. A screen could be, for example, an in-game
    (**HUD)** **heads-up display** or the same game's main menu. Screens are built
    using XML and Nifty's own set of tags. On each screen, there can be layers that
    are drawn on top of each other according to their order.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a screen, objects cascade similarly as on a web page, that is, from top
    to bottom or left to right, depending on the settings. The following code is an
    example of what a simple screen might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each screen has a `Controller` class tied to it. This is the link between the
    XML and Java that allows Nifty to control functions in the code and the other
    way around.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept is `Controls` (not to be confused with `Controller`
    classes or jMonkeyEngine's Control interface). Using `Controls` is a very convenient
    way to make screen files smaller and create reusable components. Anyone familiar
    with, for example, components in JSF will see the similarities. It's highly recommended
    that you become accustomed to using these early on, or screen files will quickly
    become unmanageable.
  prefs: []
  type: TYPE_NORMAL
- en: A UI's implementation is often very specific to the game in question. This chapter
    will try to show and explain the different functions and effects available in
    Nifty GUI. Even if the title of a recipe does not appeal to you, it could still
    be worth to glance through the content to see whether it covers some features
    that could be suitable for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Nifty and managing an options menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start things off, let's begin with a simple recipe that will provide us with
    the basics of setting up the application to use Nifty GUI and tell us how to manage
    the options menu. An options menu is usually found in games; it acts as a link
    between different screens. For this reason, it's suitable to create it using the
    control pattern so it can be easily handled across screens.
  prefs: []
  type: TYPE_NORMAL
- en: We'll initialize Nifty GUI inside `AppState` to offset it from the main application
    code and then access the application from Nifty and control Nifty through code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at how to initialize Nifty in an application. We start off by defining
    a new `AppState` to handle our Nifty functions. We can call it `NiftyAppState`
    and have it extend `AbstractAppState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `initialize` method, we need to create the Nifty display with the following
    line of code, giving Nifty access to various functionalities within the application
    and telling it to render `o` in the GUI view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also store the Nifty instance in the class for use later, using `niftyDisplay.getNifty()`.
    With this done, we need to add `niftyDisplay` as a processor to the same view
    we just specified, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The last thing that needs to be done before Nifty could show anything is to
    tell it what to draw. We do this with `nifty.fromXml` and pass the XML file to
    be used as well as the name of the screen (if several screens are stored in the
    same XML).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by defining the XML files for our options menu and the screen that
    will contain it. Perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should create a new file called `optionsMenu.xml`. It should
    reside in the `Interface`/`Controls` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first tag we need to have is a `<nifty-controls>` tag to let Nifty know
    that the elements inside should be parsed as controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add `<controlDefinition name="options">`, which is the actual options
    menu instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is where the actual layout starts, and it does so with a `<panel>` element,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top, we'll have `<panel>` that will include `<control name="label"> element
    with text="Options"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To the right of this panel, there should be a small button with the familiar
    **x** to close the menu and an interact element to call a method in the `Controller`
    class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, we can have as many `<control name="button">` elements we want for
    our options menu to work. There should at least be one that calls `quit()` in
    the `Controller` class to stop the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can define a screen to contain our options menu. If we right-click on
    the **Projects** window and select **New/Empty Nifty GUI file**, we will get a
    basic setup for a screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean out everything between the `<layer>` tags, and change the controller of
    the `<screen>` element to `gui.controls.NiftyController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to define what styles to include using the `<useStyles>` tag,
    which should appear before the `<screen>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `<useControls filename="nifty-default-controls.xml" />` to include access
    to basic nifty controls such as buttons, and we should add another `<useControls>`
    tag for our options menu. These should also be added before the `<screen>` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can start looking at the `Controller` code for this. Perform the following
    five steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: We should define a class that implements the `ScreenController` interface, which
    will become the link between the GUI and the code. We can make it abstract and
    call it `NiftyController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have two protected fields, namely, `Nifty nifty` and `Screen screen`,
    which will be set from the values provided in the `bind` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a Boolean field called `optionsMenuVisible`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add methods for each of the methods specified in the `optionsMenu.xml`
    file, and `toggleOptionsMenu()` should either show or hide the menu depending
    on whether `optionsMenuVisible` is true or not. A handy way to get hold of an
    element is by using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we can call either `hide()` or `show()` on the element to control visibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Normally, the application is shut down when *Esc* is pressed. Let''s make the
    options menu handle this instead; this consists of the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by deleting the related mapping by adding the following line to the `NiftyAppState`
    initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add our own mapping for the Esc key, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `NiftyAppState` method also needs to implement `ActionListener` and handle
    the key press:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the normal shut down routine removed, we need to add functionality inside
    `NiftyController` to handle this instead. Since this class will be shared by the
    screens, we provide the application with static access and a setter method. The
    `quit` method just has to call `app.stop()` to shut it down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nifty was initialized inside `AppState` to offset the code from the main application
    and make it more modular. This also made it easier to add some more general functionalities
    related to controlling the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Every nifty `Controller` class must implement the `ScreenController` interface
    for Nifty to be able to find it. Since some functions will be shared across the
    screens, we created an abstract class called `NiftyController` to avoid duplicating
    the code. Apart from handling the generic Options menu, it was also given access
    to the application itself.
  prefs: []
  type: TYPE_NORMAL
- en: The link between the XML file and the `Controller` class doesn't need to be
    specified beyond providing the qualified name of the controller in the screen.
    Likewise, Nifty will find methods automatically using the name provided in the
    `interact` tag of `ButtonControl`.
  prefs: []
  type: TYPE_NORMAL
- en: The `<panel>` elements are versatile objects that can be used for many parts
    of the layout and can contain most other types of layout items.
  prefs: []
  type: TYPE_NORMAL
- en: It's OK to contain several `<controlDefinition>` elements within a `<nifty-controls>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s very easy to use a `properties` file to back a Nifty file for localization
    purposes, as given in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, the following tag needs to be present to link the properties
    file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can be called, for example, from a `label` control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Loading the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll develop a loading screen along with a controller for the
    game. It'll cover the most important aspects of the loading screen, such as showing
    a text and image for what it's loading and an indicator that shows the system
    is working.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting this, it's recommended that you have a basic understanding of
    how to set up Nifty in an application and how to create screens and controllers.
    Have a look at the previous recipe, *Initializing Nifty managing an options menu*,
    if you are unsure about this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating the XML for the loading screen. Perform the following
    nine steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `loadingScreen.xml` and load `Nifty-default-styles`
    and `Nifty-default-controls`. Optionally, we can also include `optionsMenu` from
    the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first element we need is a `<screen>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, we define a `<layer>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this `<layer>` element, we define `<panel>` that will contain our layout.
    Note that we set `visible` to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we want a smooth transition to the screen, we''ll add a fade effect to
    this panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To add a movie-style and non-interactive feel to it, we will have three `<panel>`
    elements inside this file. At the top and bottom, there will be two black bars
    captioning the loading image, which will appear in the central panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `topPanel` element, we define `<control name="label">` that will
    contain the name of the scene that is being loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `bottomPanel` element will have an animated indicator that will show the
    system hasn''t frozen. We will define another panel inside this, aligned to the
    right of the screen. We will use an `imageSizePulsate` effect to animate this
    and have it fade in as well, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optionally, we can also add another `<layer>` tag beside the previous one that
    will contain the `options` control from the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have a complete XML. Let''s have a look at the controller for this.
    We will create it by performing the following seven steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a new class called `LoadingScreenController` that extends
    the `NiftyController` class we created in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define two strings, `loadingText` and `loadingScreen`, and setters for these
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we override the `onStartScreen()` method and add the following three
    lines to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The controller is now done. However, there are some more things we need to do
    before we can look at it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add the screen to Nifty. If we have the `NiftyAppState` method
    from the previous recipe, we should add the following line just after the `nifty.fromXml`
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also add a `convenience` class to access `nifty.gotoScreen()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, before calling `gotoScreen("loadingScreen")` from our main class, we can
    add the following lines to set `lodingText` and `loadingImage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the work in this recipe consists of getting the XML layout right. It's
    a good idea to sketch it on paper first and visualize the flow of the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The reason the fade effect is shorter is because by the time it fades out, the
    game is ready to be played and the player doesn't need to wait longer than necessary.
    When the loading screen is first shown, the player has to wait for the game to
    load.
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason why we set `loadingPanel` to `visible="false"` at the beginning
    and used `onShow` rather than `onScreenStart` effects. The `onStartScreen` method
    in the controller is called after the screen has been started and `onScreenStart`
    effects have been fired (and completed). This means that any fading will occur
    before we set the images, and they would pop into existence after some time has
    passed. Since the `onShow` effects are called once the element becomes visible,
    we get around that problem this way.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible gotcha here, especially if we use a test case to show the screen,
    is that we can't call `nifty.gotoScreen` just after initializing `NiftyAppState`.
    Since the `AppState` initialization method is called in a thread-safe way, it
    doesn't run until the next update cycle. This means that if we try to change the
    screens on the next line, we will get `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RPG dialog screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the title implies, we'll explore a method to create a dialog screen, similar
    to those found in many RPGs. It'll display an image of the character being talked
    to, but this could be replaced by using some clever camera work to zoom in on
    a character instead.
  prefs: []
  type: TYPE_NORMAL
- en: It will use a Nifty `ListBox` to display the player's available dialog options
    and a listener to find out the result of the player's choice.
  prefs: []
  type: TYPE_NORMAL
- en: There most likely has to be some dialog tree system that backs the implementation.
    For this example, we'll use a template class called `DialogNode`. This will have
    information about a character's name, image, and what it says. It also contains
    the player's options as a string array, as shown in the following screenshot.
    What's missing from it is the callbacks for each option. It will, however, be
    possible to call it from the controller's listener method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an RPG dialog screen](img/6478OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we work on the screen, we should define a new reusable Nifty control
    to contain the character information of the character the player is talking to;
    perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `characterDialogControls.xml` with the `<nifty-controls>`
    tag, and inside it, create a new `<controlDefinition name="characterControl">`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout for this is fairly simple; it needs one `<panel>` element that contains
    another `<panel>` for the character image and a `<control name="label">` element
    for the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s build the dialog screen. We do this by performing the following
    nine steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `dialogScreen.xml` and load `nifty-default-styles`
    and `nifty-default-controls`. It should also load the `characterDialogControls.xml`
    file. We can also include `optionsMenu` from the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first element we need is a `<screen>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, we define a `<layer>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `<layer>` element, we define `<panel>`, which will contain the rest
    of our layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll add a short fade effect to this panel as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The dialog panel will have four `<panel>` elements inside it. At the top and
    bottom, we should add two thin panels with black background to give it a cinematic
    feel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The upper part of the two central panels will contain the `characterControl`
    we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The lower one will have a listbox that contains the player''s dialog options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we also want support for the options menu, it should go in a separate layer
    to make it show on top of the rest of the GUI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The controller code for it can be created by performing the following 12 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Begin by defining a new class called `DialogScreenController` that extends `NiftyController`
    or implements `ScreenController` if an abstract `Controller` class is not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we add two fields: one for the current `DialogNode`, `dialogNode`, and
    a reference to `ListBox` in the XML called `dialogOptions`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `onStartScreen()` method should be overridden; here, it should set `dialogOptions`
    by calling `screen.findNiftyControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, `onStartScreen` should also call `onDialogNodeChanged()` if `dialogNode`
    is set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to define the method called `onDialogNodeChanged` that will apply
    the dialog information to the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should begin this by setting the name of the character; again, we will use
    `screen.findNiftyControl` to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Likewise, the dialog text is set in the same manner.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To set the image, we need to create `NiftyImage` and pass it on to `ImageRenderer`
    of an element using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we clear `dialogOptions` and use `dialogOptions.addItem` to apply the
    values available in `DialogNode`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call `dialogOptions.refresh()` and `screen.layoutLayers()` and set
    the `dialogPanel` element to be visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find out which item is pressed in `dialogOptions`, we add a listener method
    to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add an annotation to let it know which element to listen to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using `event.getSelectionIndices()`, we can find out which item the player has
    pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting the layout exactly as we want can be tricky sometimes, but in general,
    it's important to know that Nifty really likes the width and height to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ListBox here gives us a lot for free since it handles a dynamic number
    of options, and callbacks to the code are easily handled with the `listener` method.
    By default, it has scrollbars and handles multiple selection, which is why we
    explicitly defined it to be `selection="Single"` and used `vertical="off"` and
    `horizontal="off"` to turn off the scrollbars. It also supports item selection
    by using the up, down, and *Enter* keys.
  prefs: []
  type: TYPE_NORMAL
- en: The listener method in the controller can be referred to as anything; what Nifty
    looks for is the annotation and the method's parameters. From here, we can call
    the next `DialogNode` or other code based on the player's choices.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a game console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A console can be a very powerful tool that allows a player to have control over
    game functions that might either not have a functional UI yet, or where setting
    up a UI is simply not be feasible due to its complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will implement a console in the main screen from the first recipe
    in this chapter and also use the `Move` effect to slide it in and out of view.
    Moreover, it will describe how to use console commands to let the player control
    the game functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as before, we begin by defining a control that will host the console.
    It can be done by performing the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `<nifty-controls>` tags, we add a new `<controlDefinition name="consoleControl">`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a small console, aligning it with the bottom of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To spice up the simple console, we give it a `Move` effect when it''s being
    shown or hidden:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `mainScreen.xml`, we add `controlDefinition` inside a new layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it for XML hacking. Now, we can turn our attention to the `NiftyController`
    class from the *Initializing Nifty and managing an options menu* recipe and add
    a console to handle to it. This can be done by performing the following 10 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a new field, `Console console`, and bind it using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we add a method about the output text to the console from external sources.
    We call it `outputToConsole`, and it takes a string as an input. It then calls
    `console.output` to display the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another new method is `toggleConsole()`. It should check whether `console.getElement()`
    is visible or not and then hide or show it accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a `subscriber` method that will receive anything entered in the
    console. It needs the `@NiftyEventSubscriber` annotation with the console as its
    ID. It also needs a method declaration that looks like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define a new class called `HideCommand` that implements `ConsoleCommand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a field `NiftyController` controller together with a setter method to the
    `HideCommand` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implemented `execute` method, we call `controller.toggleConsole()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going back to `NiftyController`, we instantiate a new `HideCommand` method and
    set the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `ConsoleCommands` instance and call `registerCommand`;
    thereafter, we supply/hide the instance and call `commandText`, and `HideCommand`
    as `ConsoleCommand`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call `enableCommandCompletion(true)` in the `ConsoleCommands` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we implemented two ways of handling the input in the console.
    The most straightforward way is the `onConsoleCommand` method where we get the
    raw input and can do whatever we want with it.
  prefs: []
  type: TYPE_NORMAL
- en: The more intricate way of doing this is using `ConsoleCommands`. With this,
    we get a nice layered pattern to handle the input. Once the console is shown or
    hidden, it will quickly slide in or out of the screen with the move effect. It
    will move the `offsetY` distance, and based on the mode, it will either move to
    that offset or from it. The `inherit="true"` value ensures that child elements
    move together with the component in question.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a game message queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to relay most game-related information to the player using a
    console. However, it's a very basic form of communication. Modern players often
    expect more graphical ways of receiving information. In this recipe, we'll explore
    one way of doing this using Nifty. We'll create a dynamic message queue with messages
    moving in from the right of the screen and fading out once clicked.
  prefs: []
  type: TYPE_NORMAL
- en: It actually doesn't require that many lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XML for this recipe can be completed by performing the following five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a new `<controlDefinition name="gameMessage">`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we should add a `panel` element, and inside this `panel` element,
    add two `<control name="label">` elements with the ID `#title` and other contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The panel should also have two effects, one `onShow` trigger and one `onHide`
    trigger with move and fade effects respectively, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to the `gameMessage` control, we can define another control to be
    our `messageQueue` element. It just needs a horizontally aligned panel, spanning
    the whole screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make them align with each other, the `messageQueue` control is added to the
    `mainScreen.xml` file inside the same layer as the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `MainScreenController`, we need to do the following changes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, add a new `int` field called `messageIndex`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need two methods. One of these is called `addMessage` that should take
    a string as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `addMessage` method, we define a `ControlBuilder` method called
    `messageBuilder`. This will create `gameMessage` controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After calling the `build` method on this and supplying the `messageQueue` element
    as the parent, we can call `element.findNiftyControl` to set the title and the
    text on the labels inside the `gameMessage` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call `element.show()` and increase `messageIndex` for the next message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method we create is `removeMessage`. It takes a string called `id`
    as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we use `screen.findElementByName` to find the message, and call
    `hide`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While doing this, we supply a new `EndNotify` object, which in its `perform`
    message should call `markForRemoval()` on the message and also `layoutElements()`
    on the parent `messageQueue` control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the `addMessage` method is called in the `Controller` class, `ControlBuilder`
    creates a new `gameMessage` instance. The `interactOnClick` element tells `gameMessage`
    to call `removeMessage` when clicked, supplying its index as `id`.
  prefs: []
  type: TYPE_NORMAL
- en: After its built and added to `messageQueue`, we populate the title and content
    elements of the message. Using `#` in the ID of these elements is preferred by
    Nifty for non-unique IDs.
  prefs: []
  type: TYPE_NORMAL
- en: The `gameMessage` instance is not visible upon creation, and we call `show()`
    to make it play the `onShow` effect we defined.
  prefs: []
  type: TYPE_NORMAL
- en: The `Move` effect is set up to have `offsetX`, which is outside of the screen.
    If it's too low, there will be a pop effect as it comes into existence. It's set
    to reach the target position in 100 ms. Messages will stack up nicely without
    any additional work when they are added.
  prefs: []
  type: TYPE_NORMAL
- en: The messages are set to disappear when clicked, as defined in the builder, through
    the `interactOnClick` method. Instead of just removing them, we want to play a
    short fade effect to make the transition smoother. Simply hiding them won't be
    enough in this case either. Since they still occupy a position in the `messageQueue`
    panel, the remaining messages won't align properly.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we want to call `markForRemoval` on the `gameMessage` element. Doing
    this instantly, however, would remove it before our hide effect is played. This
    why we supply an `EndNotify` object that is handled once the hide effect is done
    with playing; then, we add the `markForRemoval` call in here instead.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we would like to be able to show messages in a window, either when
    clicking the message in the queue, or any time. In that case, we can use Nifty's
    window control.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a new `controlDefinition` in our `gameMessageControls.xml` file
    and call it `messageWindow`. Inside this, we'll add `<control name="window">`,
    inside which we can add any content we'd like. For now, we can settle with `<control
    name="label">` for text content and a short fade effect when showing or hiding
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can copy the `addMessage` method to `MainScreenController`, and instead
    of having `ControlBuilder` make `gameMessage`, we can tell it to build a `messageWindow`
    window instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need an `interactOnClick` element, as the window can be closed by
    default. Instead, we can use it to set the title of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Windows are also draggable by default, but the parent element must have `childLayout="absolute"`
    for it to work, as it lets the element decide its position itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an inventory screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create an inventory screen, which is very common, mostly
    in RPGs. To do this, we'll use the `Droppable` and `Draggable` components in Nifty
    and create an `InventoryItem` class to help us differentiate different the types
    of items (and hence, where they can be attached). This time, we'll use both XML
    to create the static components and the Java Builder interface to build the inventory
    (or backpack) slots. The reason is that in many games, the amount of inventory
    a character has varies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating the controls, which are the key components of this method.
    This can be done by performing the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new controls file, `inventoryControls.xml`, with the `<nifty-controls>`
    tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this, we first define `<controlDefinition name="itemSlot">` with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then similarly, we create a draggable control to be the item, and name it `<controlDefinition
    name="item" >`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This item contains both the draggable component and a label with the item''s
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can turn our attention to the screen itself. It can be created by
    performing the following five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure that the styles we want to use are loaded, and add our `inventoryControls.xml`
    file is loaded with `<useControls>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a `<screen>` element with a link to our controller file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this, we need a `<layer>` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `<layer>` element, we need a `<panel>` element that will contain
    the rest of our layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next element is a panel that will keep our dynamically created `itemSlots`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows us the dynamically created item slots:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_06_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: After this, we create a simple representation of a humanoid with two hands and
    feet, using the `itemSlot` control. We use `align` and `childLayout` to make the
    components appear where we want them to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, add a panel to contain the components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the head using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add one left and right hand using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have one `itemSlot` for the legs/feet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the XML elements done, we can turn to the Java code. The following nine
    steps are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class called `InventoryItem`. This has an enum (enumeration) for
    different body parts: head, hand, foot, and a name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create the `Controller` class, `InventoryScreenController`, and
    have it extend `NiftyController`; also, implement `DroppableDropFilter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add a map to contain our `InventoryItems`, with the name as the key.
    It can be called `itemMap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `bind` method should be overridden, and in here, we should find different
    `DropControls` in the `InventoryScreen` and add this class as a filter using the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can generate the item slots in the inventory in a 5 x 5 grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define two builders: `ControlBuilder` for the itemSlot controls and `PanelBuilder`
    to make columns that will contain five itemSlots each.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use a `for` loop to iterate five times over the following block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While still inside this `for` loop, we run another `for` loop, generating the
    five item slots for that column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each of the item slots, we also need to add the following class as a DropFilter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implemented method that is accepted needs some logic. Once an item has
    been dropped on an `itemSlot`, we should check whether it''s allowed, and we can
    do it with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the item slots done, we can generate some items for testing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First we use a `for` loop to create 10 `InventoryItems` with different types
    and names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each of these, we create a Nifty control using `ControlBuilder` and the
    item control we defined earlier, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we put each of the inventory items in the itemMap with the ID of the control
    as the key. This ensures we can easily find out the link to the inventory item
    where a nifty item has been dragged or dropped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java Builder interface we use to create item slots takes a while to get
    used to, but it's a really powerful tool when we have the need to create nifty
    elements dynamically. In this case, we still use a predefined control. This saves
    us a couple of lines of code and allows someone else than a coder to edit the
    layout and style of the component since it's exposed in the XML file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a `Droppable` control will always accept the `Draggable` control
    that is being dropped. The `accept` method in `DroppableDropFilter` enables us
    to define what should be accepted or not. It's illustrated in this recipe by only
    accepting `InventoryItems` of a certain type. The method parameters for the accept
    method can be described, as the first `Droppable` is the control that the `draggable`
    control is being picked up from. The `Draggable` control is the item that is being
    moved. The second `Droppable` control is the target where `Draggable` has been
    dropped.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this, the first `Droppable` control tends to be null
    the first time a `Draggable` control is being moved.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the input and settings page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just about every modern game lets the player customize the input according to
    their own preferences. This recipe will rely on jMonkeyEngine to do the work for
    us, and we will use Nifty GUI as a visual aid. We'll use `RawInputListener` to
    work out which keys have been pressed and divide them between key codes and characters
    using the `Keyboard` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe will depend on there being some bindings in `InputManager`. If you
    already have a game, this would not be a problem. If not, it will describe how
    to add a couple of bindings for the example to work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the pattern from previous recipes, we''ll start defining the controls,
    then move on to the screen, and finally work on the controller. Adding the controls
    and screen will consist of the following eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `<nifty-control>` tag, we define a new `<controlDefinition name="keyBindingControl">`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we''ll add a horizontal spanning panel with some margin to the edges
    of its container and enough height to contain text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This panel will have three elements. The first is a label control that contains
    the text for the key binding, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, it will have a button to change the binding, displaying the current key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In between them, it will have a simple panel with `width="*"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can define another `<controlDefinition name="settingsControl">` that
    will contain a number of our `keyBindingControls`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will contain a panel, and inside this, four `keyBindingControls` for each
    moving direction. The IDs of these controls should be representative of the direction
    and end with a key as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following points are needed for the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ID should be settings, and controller should be `gui.controller.SettingsController`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `settingsControl` class we just created should be added inside a layer element
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s all with regards to XML. To create the `Controller` class, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we create a new class that extends `NiftyController`. We call it `SettingsController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll have `Element` fields for each of the key bindings we would like to track
    and one `Element` field for the current `selectedElement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we should add `Map<Integer, String>` called `mappings` where we
    can keep the relations between key inputs and input bindings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we should call a `bindElements` method, which we'll define as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we'll add the current key bindings to the `mappings` map using
    the key code as key and the actual binding as the value. This can usually be found
    in the class that handles the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, for each of the keys we would like to handle, we find the reference in
    the settings screen and populate their values accordingly. For example, for the
    forward key use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we define a new inner class called `KeyEventListener` that implements
    `RawInputListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `onKeyEvent`, add an `if` statement for if the incoming `KeyInputEvent` is
    pressed and `selectedElement` is not null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we add a reference to the yet-to-be-created `changeMapping` method and
    add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we should set `selectedElement` to `null`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can turn our attention to the `changeMapping` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method has the pressed key code as an input parameter, and we use this
    to see whether we already have a binding in our `mappings` map. If `inputManager`
    of the application also has this, we should delete the old binding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to iterate through all the values in our `mappings` map and check
    whether any of the bindings match the one that the selected element is handling.
    If you find a match, it should be deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we create a new `KeyTrigger` class using `keyCode` and add it to `inputManager`
    using `addMapping`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to do in this class is add an event subscriber to the
    buttons in `keyBindingControls`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define a new method, `keyClicked(String id, ButtonClickedEvent event)`,
    and give it the following annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the button is clicked, the corresponding element should be selected, so
    we use `event.getButton().getElement().getParent()` to find out which one that
    is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe explains that when a button that represents a key binding is clicked,
    the corresponding element is selected. By using a pattern in the annotation for
    the `keyClicked` method, rather than an ID, we can capture all the keys using
    the wildcard`.*`. This is also why the naming of the elements is important.
  prefs: []
  type: TYPE_NORMAL
- en: Once an element is selected, `KeyEventListener` will start to listen for a key
    to be pressed on the keyboard. We set the text of the button to be the text representation
    of the key. In many cases, we can use the `getKeyChar` method of `KeyInputEvent`
    for this; however, not all the methods have a character like representation, hence
    the use of the `Keyboard` class and `getKeyName` method instead. This method tends
    to output a string representation instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `changeMapping` method first sees whether there is a current binding for
    the key pressed and deletes it if that is the case. This is not enough, however,
    since we also need to delete any previous bindings for that input. This is why
    we also iterate over the current mappings to see whether any of them match the
    binding that this key press was for; if yes, it deletes them too.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a static representation of the different input bindings. This
    would most likely be fine for many games, but modern first person shooters for
    example, can have 20 and more key bindings; adding all of these manually to the
    XML can be cumbersome and not good from a maintenance perspective. In this case,
    it might be better to use the Java Builder interface described in the *Creating
    an inventory screen* recipe to let Java do the repetitious work.
  prefs: []
  type: TYPE_NORMAL
- en: Using offscreen rendering for a minimap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are generally two ways of creating minimaps. One way is to let an artist
    draw a representation of the map, as shown in the following screenshot. This usually
    ends up beautifully as it gives considerable freedom to the artist when it comes
    to style. The method is not that viable during development when scenes might be
    changing a lot, or for games with procedural content where the end result is not
    known beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using offscreen rendering for a minimap](img/6478OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Minimap with unit marker
  prefs: []
  type: TYPE_NORMAL
- en: In those cases, taking a snapshot of the actual scene can be very helpful. The
    resulting image can then be run through various filters (or shaders during rendering)
    to get a less raw look.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll achieve this by creating a new `ViewPort` port, and `FrameBuffer`
    to store a snapshot of a camera. Finally, we'll create `NiftyImage` out of it
    and display it as a GUI element.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to start by creating a `Util` class to handle the rendering of
    our minimap. This will consist of the following 15 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new class called `MinimapUtil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will only have one static method, `createMiniMap`, with the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do is create a new camera called `offScreenCamera` with the
    same width and height that were supplied to the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The camera should have the parallel projection set to true, and a frustrum
    that spans between `1` and `1000` in depth, `-width` to `width`, and `-height`
    to `height`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should be located at some distance above the scene and rotated downwards,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we create a new `ViewPort` by calling the application''s `RenderManager`
    and its `createPreView` method using `offScreenCamera`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need a `Texture2D` class to store the data in, so we create a class
    called `offScreenTexture` with the same width and height as before and set `MinFilter`
    to `Trilinear`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `FrameBuffer` class is needed as a medium for the data, so we create one
    with the same width and height, and `1` sample, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We set `DepthBuffer` to be `Image.Format.Depth` and `offScreenTexture` to be
    `ColorTexture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we set `outPutFrameBuffer` of `offScreenView` to be `offScreenBuffer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unless the scene we supplied already has some lights, we should add at least
    one `Light` class to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we attach the scene to `offScreenView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To store the texture, we can add it to `AssetManager` with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can do the actual rendering by calling the application''s `renderManager`
    and `renderViewPort` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we''re done and can call `removePreview` to discard `offScreeenView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the `Util` class done, we can create a screen `Controller` class. Perform
    the following additional six steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `GameScreenController` that extends `NiftyController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, it only needs one public method called `createMinimap` that takes a
    scene as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing the `createMinimap` method should do is call `MiniMapUtil.createMinimap`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the scene rendered, we can create `NiftyImage` with the `nifty.createImage`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can apply the image to our minimap element in the Nifty screen with
    the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, all we need to do is add a panel element called `minimap` to a screen that
    uses `GameScreenController` as the controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Offscreen rendering is just what it sounds like. We render something in a view
    that is not related to the main view that the player sees. To do this, we set
    up a new viewport and camera. It's not possible to render something directly to
    a texture, which is why `FrameBuffer` is used as the medium.
  prefs: []
  type: TYPE_NORMAL
- en: Once the texture object is created and added to the asset manager, it's possible
    to keep changing it if we would like to at a later stage. It's even possible to
    have a live view of the scene in the minimap, although this would probably cost
    unnecessary resources. In this case, we remove the view as soon as we've rendered
    it once.
  prefs: []
  type: TYPE_NORMAL
- en: The example is limited in some sense, like it expects that there is a correlation
    between the size of the scene and the size of the minimap.
  prefs: []
  type: TYPE_NORMAL
- en: Nifty uses its own image format, `NiftyImage`, so we need to convert the image
    we saved; however, Nifty's `createImage` will automatically find the texture in
    the asset manager based on the name (key).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, on a minimap, players will want some kind of indication about their
    (and others) whereabouts. Let''s implement that in the minimap we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to change the `minimap` element in our screen a bit. We
    set `childLayout` to `absolute` and add another panel inside it called `playerIcon`
    with a small width and height.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add a new `Element` field called `playerIcon` to the `GameScreenController`
    and use `findElementByName` in the `bind` method to set it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add another method called `updatePlayerPosition` with two integers,
    `x` and `y`, as the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method should use `setConstraintX` and `setConstraintY` on the `playerIcon`
    element to set the position. Those methods take `SizeValue` as the input, and
    we supply the `x` and `y` values with the `"px"` definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the same method, we need to call `layoutElements()` on the `minimap`
    element to make it update its child elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For other things, such as visible enemies, we can use the builder interface
    to create them as and when we need them and then use `markForRemoval` to remove
    them when they're not needed anymore. An example of this process can be seen in
    the *Handling a game message queue* recipe.
  prefs: []
  type: TYPE_NORMAL
