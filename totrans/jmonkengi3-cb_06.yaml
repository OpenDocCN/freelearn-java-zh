- en: Chapter 6. GUI with Nifty GUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 使用Nifty GUI的GUI
- en: First of all, what is **Nifty GUI**? It's not the only GUI available in jMonkeyEngine,
    but it is the one that is officially supported. It is not developed by the jMonkeyEngine
    team but is an independent open source effort that has implementations in other
    engines as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是**Nifty GUI**？它不是jMonkeyEngine中可用的唯一GUI，但它是官方支持的。它不是由jMonkeyEngine团队开发的，而是一个独立的开源项目，在其他引擎中也有实现。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Initializing Nifty and managing an options menu
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化Nifty和管理选项菜单
- en: Loading the screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载屏幕
- en: Creating an RPG dialog screen
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个RPG对话框屏幕
- en: Implementing a game console
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个游戏控制台
- en: Handling a game message queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理游戏消息队列
- en: Creating an inventory screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个库存屏幕
- en: Customizing the input and settings page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义输入和设置页面
- en: Using offscreen rendering for a minimap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离屏渲染实现小地图
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Nifty GUI is operated using screens. A screen could be, for example, an in-game
    (**HUD)** **heads-up display** or the same game's main menu. Screens are built
    using XML and Nifty's own set of tags. On each screen, there can be layers that
    are drawn on top of each other according to their order.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Nifty GUI是通过屏幕操作的。屏幕可以是，例如，游戏中的(**HUD**) **抬头显示**或同一游戏的主菜单。屏幕是用XML和Nifty自己的标签集构建的。在每一个屏幕上，可以有层叠的层，这些层根据它们的顺序绘制。
- en: 'On a screen, objects cascade similarly as on a web page, that is, from top
    to bottom or left to right, depending on the settings. The following code is an
    example of what a simple screen might look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上，对象像网页上一样级联，即从上到下或从左到右，具体取决于设置。以下代码是一个简单屏幕可能看起来像的示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each screen has a `Controller` class tied to it. This is the link between the
    XML and Java that allows Nifty to control functions in the code and the other
    way around.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个屏幕都与一个`Controller`类相关联。这是XML和Java之间的链接，允许Nifty控制代码中的功能，反之亦然。
- en: Another important concept is `Controls` (not to be confused with `Controller`
    classes or jMonkeyEngine's Control interface). Using `Controls` is a very convenient
    way to make screen files smaller and create reusable components. Anyone familiar
    with, for example, components in JSF will see the similarities. It's highly recommended
    that you become accustomed to using these early on, or screen files will quickly
    become unmanageable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是`Controls`（不要与`Controller`类或jMonkeyEngine的Control接口混淆）。使用`Controls`是一种非常方便的方法来使屏幕文件更小并创建可重用组件。任何熟悉，例如，JSF组件的人都会看到相似之处。强烈建议您尽早熟悉使用这些，否则屏幕文件将很快变得难以管理。
- en: A UI's implementation is often very specific to the game in question. This chapter
    will try to show and explain the different functions and effects available in
    Nifty GUI. Even if the title of a recipe does not appeal to you, it could still
    be worth to glance through the content to see whether it covers some features
    that could be suitable for your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个UI的实现通常非常特定于所讨论的游戏。本章将尝试展示和解释Nifty GUI中可用的不同功能和效果。即使配方标题对你没有吸引力，仍然值得浏览内容，看看它是否涵盖了适合你项目的某些功能。
- en: Initializing Nifty and managing an options menu
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Nifty和管理选项菜单
- en: To start things off, let's begin with a simple recipe that will provide us with
    the basics of setting up the application to use Nifty GUI and tell us how to manage
    the options menu. An options menu is usually found in games; it acts as a link
    between different screens. For this reason, it's suitable to create it using the
    control pattern so it can be easily handled across screens.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一个简单的配方开始，这个配方将为我们提供设置应用程序使用Nifty GUI的基本知识，并告诉我们如何管理选项菜单。选项菜单通常在游戏中找到；它充当不同屏幕之间的链接。因此，使用控制模式创建它是合适的，这样就可以轻松地在屏幕之间处理。
- en: We'll initialize Nifty GUI inside `AppState` to offset it from the main application
    code and then access the application from Nifty and control Nifty through code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`AppState`内部初始化Nifty GUI，以将其与主应用程序代码隔离开来，然后从Nifty访问应用程序并通过代码控制Nifty。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at how to initialize Nifty in an application. We start off by defining
    a new `AppState` to handle our Nifty functions. We can call it `NiftyAppState`
    and have it extend `AbstractAppState`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在应用程序中初始化Nifty。我们首先定义一个新的`AppState`来处理我们的Nifty功能。我们可以称它为`NiftyAppState`，并让它扩展`AbstractAppState`。
- en: 'In the `initialize` method, we need to create the Nifty display with the following
    line of code, giving Nifty access to various functionalities within the application
    and telling it to render `o` in the GUI view:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We should also store the Nifty instance in the class for use later, using `niftyDisplay.getNifty()`.
    With this done, we need to add `niftyDisplay` as a processor to the same view
    we just specified, using the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The last thing that needs to be done before Nifty could show anything is to
    tell it what to draw. We do this with `nifty.fromXml` and pass the XML file to
    be used as well as the name of the screen (if several screens are stored in the
    same XML).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by defining the XML files for our options menu and the screen that
    will contain it. Perform the following steps to do this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should create a new file called `optionsMenu.xml`. It should
    reside in the `Interface`/`Controls` folder.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first tag we need to have is a `<nifty-controls>` tag to let Nifty know
    that the elements inside should be parsed as controls.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add `<controlDefinition name="options">`, which is the actual options
    menu instance.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is where the actual layout starts, and it does so with a `<panel>` element,
    as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the top, we'll have `<panel>` that will include `<control name="label"> element
    with text="Options"`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To the right of this panel, there should be a small button with the familiar
    **x** to close the menu and an interact element to call a method in the `Controller`
    class, as shown in the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After this, we can have as many `<control name="button">` elements we want for
    our options menu to work. There should at least be one that calls `quit()` in
    the `Controller` class to stop the application.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can define a screen to contain our options menu. If we right-click on
    the **Projects** window and select **New/Empty Nifty GUI file**, we will get a
    basic setup for a screen.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean out everything between the `<layer>` tags, and change the controller of
    the `<screen>` element to `gui.controls.NiftyController`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to define what styles to include using the `<useStyles>` tag,
    which should appear before the `<screen>` element.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add `<useControls filename="nifty-default-controls.xml" />` to include access
    to basic nifty controls such as buttons, and we should add another `<useControls>`
    tag for our options menu. These should also be added before the `<screen>` element.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can start looking at the `Controller` code for this. Perform the following
    five steps to do this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We should define a class that implements the `ScreenController` interface, which
    will become the link between the GUI and the code. We can make it abstract and
    call it `NiftyController`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should have two protected fields, namely, `Nifty nifty` and `Screen screen`,
    which will be set from the values provided in the `bind` method.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a Boolean field called `optionsMenuVisible`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add methods for each of the methods specified in the `optionsMenu.xml`
    file, and `toggleOptionsMenu()` should either show or hide the menu depending
    on whether `optionsMenuVisible` is true or not. A handy way to get hold of an
    element is by using the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为`optionsMenu.xml`文件中指定的每个方法添加方法，并且`toggleOptionsMenu()`应该根据`optionsMenuVisible`是否为真来显示或隐藏菜单。获取元素的一个方便方法是使用以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, we can call either `hide()` or `show()` on the element to control visibility.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以在元素上调用`hide()`或`show()`来控制其可见性。
- en: 'Normally, the application is shut down when *Esc* is pressed. Let''s make the
    options menu handle this instead; this consists of the following four steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当按下*Esc*键时，应用程序会关闭。让我们让选项菜单来处理这个操作；这包括以下四个步骤：
- en: 'Start by deleting the related mapping by adding the following line to the `NiftyAppState`
    initialization method:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`NiftyAppState`初始化方法中添加以下行来删除相关的映射：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we need to add our own mapping for the Esc key, as shown in the following
    code:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加自己的Esc键映射，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `NiftyAppState` method also needs to implement `ActionListener` and handle
    the key press:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NiftyAppState`方法还需要实现`ActionListener`并处理按键：'
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the normal shut down routine removed, we need to add functionality inside
    `NiftyController` to handle this instead. Since this class will be shared by the
    screens, we provide the application with static access and a setter method. The
    `quit` method just has to call `app.stop()` to shut it down.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除正常关闭程序后，我们需要在`NiftyController`内部添加功能来处理这种情况。由于此类将由屏幕共享，我们为应用程序提供了静态访问和设置方法。`quit`方法只需调用`app.stop()`来关闭它。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nifty was initialized inside `AppState` to offset the code from the main application
    and make it more modular. This also made it easier to add some more general functionalities
    related to controlling the GUI.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Nifty是在`AppState`内部初始化的，这样可以将代码从主应用程序中分离出来，使其更加模块化。这也使得添加一些与控制GUI相关的更通用的功能变得更加容易。
- en: Every nifty `Controller` class must implement the `ScreenController` interface
    for Nifty to be able to find it. Since some functions will be shared across the
    screens, we created an abstract class called `NiftyController` to avoid duplicating
    the code. Apart from handling the generic Options menu, it was also given access
    to the application itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个nifty `Controller`类都必须实现`ScreenController`接口，以便Nifty能够找到它。由于一些功能将在屏幕之间共享，我们创建了一个名为`NiftyController`的抽象类来避免代码重复。除了处理通用的选项菜单外，它还被赋予了访问应用程序本身的权限。
- en: The link between the XML file and the `Controller` class doesn't need to be
    specified beyond providing the qualified name of the controller in the screen.
    Likewise, Nifty will find methods automatically using the name provided in the
    `interact` tag of `ButtonControl`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: XML文件和`Controller`类之间的链接不需要指定，只需在屏幕中提供控制器的限定名称。同样，Nifty会自动使用`ButtonControl`的`interact`标签中提供的名称来查找方法。
- en: The `<panel>` elements are versatile objects that can be used for many parts
    of the layout and can contain most other types of layout items.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`<panel>`元素是多功能对象，可以用于布局的许多部分，并且可以包含大多数其他类型的布局项。'
- en: It's OK to contain several `<controlDefinition>` elements within a `<nifty-controls>`
    tag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<nifty-controls>`标签内包含多个`<controlDefinition>`元素是可以的。
- en: There's more…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'It''s very easy to use a `properties` file to back a Nifty file for localization
    purposes, as given in the following points:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性文件作为Nifty文件的后备以进行本地化非常容易，如下所述：
- en: 'First of all, the following tag needs to be present to link the properties
    file:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，需要存在以下标签来链接属性文件：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It can be called, for example, from a `label` control:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以从`label`控件中调用，例如：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Loading the screen
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载屏幕
- en: In this recipe, we'll develop a loading screen along with a controller for the
    game. It'll cover the most important aspects of the loading screen, such as showing
    a text and image for what it's loading and an indicator that shows the system
    is working.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将开发一个加载屏幕以及游戏控制器。它将涵盖加载屏幕的最重要方面，例如显示正在加载的文本和图像以及显示系统正在工作的指示器。
- en: Before starting this, it's recommended that you have a basic understanding of
    how to set up Nifty in an application and how to create screens and controllers.
    Have a look at the previous recipe, *Initializing Nifty managing an options menu*,
    if you are unsure about this.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating the XML for the loading screen. Perform the following
    nine steps to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `loadingScreen.xml` and load `Nifty-default-styles`
    and `Nifty-default-controls`. Optionally, we can also include `optionsMenu` from
    the previous recipe.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first element we need is a `<screen>` element:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside this, we define a `<layer>` element:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside this `<layer>` element, we define `<panel>` that will contain our layout.
    Note that we set `visible` to `false`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since we want a smooth transition to the screen, we''ll add a fade effect to
    this panel:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add a movie-style and non-interactive feel to it, we will have three `<panel>`
    elements inside this file. At the top and bottom, there will be two black bars
    captioning the loading image, which will appear in the central panel.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `topPanel` element, we define `<control name="label">` that will
    contain the name of the scene that is being loaded.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `bottomPanel` element will have an animated indicator that will show the
    system hasn''t frozen. We will define another panel inside this, aligned to the
    right of the screen. We will use an `imageSizePulsate` effect to animate this
    and have it fade in as well, as shown in the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Optionally, we can also add another `<layer>` tag beside the previous one that
    will contain the `options` control from the previous recipe.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we have a complete XML. Let''s have a look at the controller for this.
    We will create it by performing the following seven steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating a new class called `LoadingScreenController` that extends
    the `NiftyController` class we created in the previous recipe.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define two strings, `loadingText` and `loadingScreen`, and setters for these
    as well.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we override the `onStartScreen()` method and add the following three
    lines to it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The controller is now done. However, there are some more things we need to do
    before we can look at it.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to add the screen to Nifty. If we have the `NiftyAppState` method
    from the previous recipe, we should add the following line just after the `nifty.fromXml`
    call:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can also add a `convenience` class to access `nifty.gotoScreen()`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, before calling `gotoScreen("loadingScreen")` from our main class, we can
    add the following lines to set `lodingText` and `loadingImage`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the work in this recipe consists of getting the XML layout right. It's
    a good idea to sketch it on paper first and visualize the flow of the elements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The reason the fade effect is shorter is because by the time it fades out, the
    game is ready to be played and the player doesn't need to wait longer than necessary.
    When the loading screen is first shown, the player has to wait for the game to
    load.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: There is a reason why we set `loadingPanel` to `visible="false"` at the beginning
    and used `onShow` rather than `onScreenStart` effects. The `onStartScreen` method
    in the controller is called after the screen has been started and `onScreenStart`
    effects have been fired (and completed). This means that any fading will occur
    before we set the images, and they would pop into existence after some time has
    passed. Since the `onShow` effects are called once the element becomes visible,
    we get around that problem this way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Another possible gotcha here, especially if we use a test case to show the screen,
    is that we can't call `nifty.gotoScreen` just after initializing `NiftyAppState`.
    Since the `AppState` initialization method is called in a thread-safe way, it
    doesn't run until the next update cycle. This means that if we try to change the
    screens on the next line, we will get `NullPointerException`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RPG dialog screen
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the title implies, we'll explore a method to create a dialog screen, similar
    to those found in many RPGs. It'll display an image of the character being talked
    to, but this could be replaced by using some clever camera work to zoom in on
    a character instead.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: It will use a Nifty `ListBox` to display the player's available dialog options
    and a listener to find out the result of the player's choice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There most likely has to be some dialog tree system that backs the implementation.
    For this example, we'll use a template class called `DialogNode`. This will have
    information about a character's name, image, and what it says. It also contains
    the player's options as a string array, as shown in the following screenshot.
    What's missing from it is the callbacks for each option. It will, however, be
    possible to call it from the controller's listener method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an RPG dialog screen](img/6478OS_06_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we work on the screen, we should define a new reusable Nifty control
    to contain the character information of the character the player is talking to;
    perform the following steps to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `characterDialogControls.xml` with the `<nifty-controls>`
    tag, and inside it, create a new `<controlDefinition name="characterControl">`
    class.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout for this is fairly simple; it needs one `<panel>` element that contains
    another `<panel>` for the character image and a `<control name="label">` element
    for the name.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s build the dialog screen. We do this by performing the following
    nine steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `dialogScreen.xml` and load `nifty-default-styles`
    and `nifty-default-controls`. It should also load the `characterDialogControls.xml`
    file. We can also include `optionsMenu` from the previous recipe.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first element we need is a `<screen>` element:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside this, we define a `<layer>` element:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Inside the `<layer>` element, we define `<panel>`, which will contain the rest
    of our layout:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll add a short fade effect to this panel as well:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The dialog panel will have four `<panel>` elements inside it. At the top and
    bottom, we should add two thin panels with black background to give it a cinematic
    feel.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The upper part of the two central panels will contain the `characterControl`
    we just created:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The lower one will have a listbox that contains the player''s dialog options:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we also want support for the options menu, it should go in a separate layer
    to make it show on top of the rest of the GUI.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The controller code for it can be created by performing the following 12 steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Begin by defining a new class called `DialogScreenController` that extends `NiftyController`
    or implements `ScreenController` if an abstract `Controller` class is not available.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we add two fields: one for the current `DialogNode`, `dialogNode`, and
    a reference to `ListBox` in the XML called `dialogOptions`.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `onStartScreen()` method should be overridden; here, it should set `dialogOptions`
    by calling `screen.findNiftyControl`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, `onStartScreen` should also call `onDialogNodeChanged()` if `dialogNode`
    is set.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to define the method called `onDialogNodeChanged` that will apply
    the dialog information to the layout.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We should begin this by setting the name of the character; again, we will use
    `screen.findNiftyControl` to do this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Likewise, the dialog text is set in the same manner.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To set the image, we need to create `NiftyImage` and pass it on to `ImageRenderer`
    of an element using the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we clear `dialogOptions` and use `dialogOptions.addItem` to apply the
    values available in `DialogNode`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call `dialogOptions.refresh()` and `screen.layoutLayers()` and set
    the `dialogPanel` element to be visible.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find out which item is pressed in `dialogOptions`, we add a listener method
    to the class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we add an annotation to let it know which element to listen to:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using `event.getSelectionIndices()`, we can find out which item the player has
    pressed.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Getting the layout exactly as we want can be tricky sometimes, but in general,
    it's important to know that Nifty really likes the width and height to be defined.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Using the ListBox here gives us a lot for free since it handles a dynamic number
    of options, and callbacks to the code are easily handled with the `listener` method.
    By default, it has scrollbars and handles multiple selection, which is why we
    explicitly defined it to be `selection="Single"` and used `vertical="off"` and
    `horizontal="off"` to turn off the scrollbars. It also supports item selection
    by using the up, down, and *Enter* keys.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The listener method in the controller can be referred to as anything; what Nifty
    looks for is the annotation and the method's parameters. From here, we can call
    the next `DialogNode` or other code based on the player's choices.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a game console
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A console can be a very powerful tool that allows a player to have control over
    game functions that might either not have a functional UI yet, or where setting
    up a UI is simply not be feasible due to its complexity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will implement a console in the main screen from the first recipe
    in this chapter and also use the `Move` effect to slide it in and out of view.
    Moreover, it will describe how to use console commands to let the player control
    the game functions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as before, we begin by defining a control that will host the console.
    It can be done by performing the following four steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `<nifty-controls>` tags, we add a new `<controlDefinition name="consoleControl">`
    class.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a small console, aligning it with the bottom of the screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To spice up the simple console, we give it a `Move` effect when it''s being
    shown or hidden:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In `mainScreen.xml`, we add `controlDefinition` inside a new layer:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That''s it for XML hacking. Now, we can turn our attention to the `NiftyController`
    class from the *Initializing Nifty and managing an options menu* recipe and add
    a console to handle to it. This can be done by performing the following 10 steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a new field, `Console console`, and bind it using the following
    code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we add a method about the output text to the console from external sources.
    We call it `outputToConsole`, and it takes a string as an input. It then calls
    `console.output` to display the message.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another new method is `toggleConsole()`. It should check whether `console.getElement()`
    is visible or not and then hide or show it accordingly.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a `subscriber` method that will receive anything entered in the
    console. It needs the `@NiftyEventSubscriber` annotation with the console as its
    ID. It also needs a method declaration that looks like the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Define a new class called `HideCommand` that implements `ConsoleCommand`.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a field `NiftyController` controller together with a setter method to the
    `HideCommand` class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the implemented `execute` method, we call `controller.toggleConsole()`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going back to `NiftyController`, we instantiate a new `HideCommand` method and
    set the controller.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a new `ConsoleCommands` instance and call `registerCommand`;
    thereafter, we supply/hide the instance and call `commandText`, and `HideCommand`
    as `ConsoleCommand`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we call `enableCommandCompletion(true)` in the `ConsoleCommands` instance.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we implemented two ways of handling the input in the console.
    The most straightforward way is the `onConsoleCommand` method where we get the
    raw input and can do whatever we want with it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The more intricate way of doing this is using `ConsoleCommands`. With this,
    we get a nice layered pattern to handle the input. Once the console is shown or
    hidden, it will quickly slide in or out of the screen with the move effect. It
    will move the `offsetY` distance, and based on the mode, it will either move to
    that offset or from it. The `inherit="true"` value ensures that child elements
    move together with the component in question.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Handling a game message queue
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to relay most game-related information to the player using a
    console. However, it's a very basic form of communication. Modern players often
    expect more graphical ways of receiving information. In this recipe, we'll explore
    one way of doing this using Nifty. We'll create a dynamic message queue with messages
    moving in from the right of the screen and fading out once clicked.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: It actually doesn't require that many lines of code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The XML for this recipe can be completed by performing the following five steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining a new `<controlDefinition name="gameMessage">`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we should add a `panel` element, and inside this `panel` element,
    add two `<control name="label">` elements with the ID `#title` and other contents.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The panel should also have two effects, one `onShow` trigger and one `onHide`
    trigger with move and fade effects respectively, as shown in the following code:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In addition to the `gameMessage` control, we can define another control to be
    our `messageQueue` element. It just needs a horizontally aligned panel, spanning
    the whole screen.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make them align with each other, the `messageQueue` control is added to the
    `mainScreen.xml` file inside the same layer as the console.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside `MainScreenController`, we need to do the following changes:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, add a new `int` field called `messageIndex`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we need two methods. One of these is called `addMessage` that should take
    a string as an input.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `addMessage` method, we define a `ControlBuilder` method called
    `messageBuilder`. This will create `gameMessage` controls:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After calling the `build` method on this and supplying the `messageQueue` element
    as the parent, we can call `element.findNiftyControl` to set the title and the
    text on the labels inside the `gameMessage` control.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call `element.show()` and increase `messageIndex` for the next message.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second method we create is `removeMessage`. It takes a string called `id`
    as the input.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we use `screen.findElementByName` to find the message, and call
    `hide`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While doing this, we supply a new `EndNotify` object, which in its `perform`
    message should call `markForRemoval()` on the message and also `layoutElements()`
    on the parent `messageQueue` control.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the `addMessage` method is called in the `Controller` class, `ControlBuilder`
    creates a new `gameMessage` instance. The `interactOnClick` element tells `gameMessage`
    to call `removeMessage` when clicked, supplying its index as `id`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: After its built and added to `messageQueue`, we populate the title and content
    elements of the message. Using `#` in the ID of these elements is preferred by
    Nifty for non-unique IDs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `gameMessage` instance is not visible upon creation, and we call `show()`
    to make it play the `onShow` effect we defined.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The `Move` effect is set up to have `offsetX`, which is outside of the screen.
    If it's too low, there will be a pop effect as it comes into existence. It's set
    to reach the target position in 100 ms. Messages will stack up nicely without
    any additional work when they are added.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The messages are set to disappear when clicked, as defined in the builder, through
    the `interactOnClick` method. Instead of just removing them, we want to play a
    short fade effect to make the transition smoother. Simply hiding them won't be
    enough in this case either. Since they still occupy a position in the `messageQueue`
    panel, the remaining messages won't align properly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we want to call `markForRemoval` on the `gameMessage` element. Doing
    this instantly, however, would remove it before our hide effect is played. This
    why we supply an `EndNotify` object that is handled once the hide effect is done
    with playing; then, we add the `markForRemoval` call in here instead.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we would like to be able to show messages in a window, either when
    clicking the message in the queue, or any time. In that case, we can use Nifty's
    window control.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: We can define a new `controlDefinition` in our `gameMessageControls.xml` file
    and call it `messageWindow`. Inside this, we'll add `<control name="window">`,
    inside which we can add any content we'd like. For now, we can settle with `<control
    name="label">` for text content and a short fade effect when showing or hiding
    the window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can copy the `addMessage` method to `MainScreenController`, and instead
    of having `ControlBuilder` make `gameMessage`, we can tell it to build a `messageWindow`
    window instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need an `interactOnClick` element, as the window can be closed by
    default. Instead, we can use it to set the title of the window:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Windows are also draggable by default, but the parent element must have `childLayout="absolute"`
    for it to work, as it lets the element decide its position itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Creating an inventory screen
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create an inventory screen, which is very common, mostly
    in RPGs. To do this, we'll use the `Droppable` and `Draggable` components in Nifty
    and create an `InventoryItem` class to help us differentiate different the types
    of items (and hence, where they can be attached). This time, we'll use both XML
    to create the static components and the Java Builder interface to build the inventory
    (or backpack) slots. The reason is that in many games, the amount of inventory
    a character has varies.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin by creating the controls, which are the key components of this method.
    This can be done by performing the following four steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a new controls file, `inventoryControls.xml`, with the `<nifty-controls>`
    tag.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this, we first define `<controlDefinition name="itemSlot">` with the
    following content:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then similarly, we create a draggable control to be the item, and name it `<controlDefinition
    name="item" >`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This item contains both the draggable component and a label with the item''s
    name:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we can turn our attention to the screen itself. It can be created by
    performing the following five steps:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: First, we make sure that the styles we want to use are loaded, and add our `inventoryControls.xml`
    file is loaded with `<useControls>`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add a `<screen>` element with a link to our controller file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside this, we need a `<layer>` element:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `<layer>` element, we need a `<panel>` element that will contain
    the rest of our layout:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next element is a panel that will keep our dynamically created `itemSlots`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following screenshot shows us the dynamically created item slots:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/6478OS_06_02.jpg)'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: After this, we create a simple representation of a humanoid with two hands and
    feet, using the `itemSlot` control. We use `align` and `childLayout` to make the
    components appear where we want them to.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, add a panel to contain the components:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, add the head using the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add one left and right hand using the following command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we have one `itemSlot` for the legs/feet:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With the XML elements done, we can turn to the Java code. The following nine
    steps are necessary:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a class called `InventoryItem`. This has an enum (enumeration) for
    different body parts: head, hand, foot, and a name.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we'll create the `Controller` class, `InventoryScreenController`, and
    have it extend `NiftyController`; also, implement `DroppableDropFilter`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add a map to contain our `InventoryItems`, with the name as the key.
    It can be called `itemMap`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `bind` method should be overridden, and in here, we should find different
    `DropControls` in the `InventoryScreen` and add this class as a filter using the
    following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, we can generate the item slots in the inventory in a 5 x 5 grid.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define two builders: `ControlBuilder` for the itemSlot controls and `PanelBuilder`
    to make columns that will contain five itemSlots each.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use a `for` loop to iterate five times over the following block:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While still inside this `for` loop, we run another `for` loop, generating the
    five item slots for that column:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For each of the item slots, we also need to add the following class as a DropFilter:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The implemented method that is accepted needs some logic. Once an item has
    been dropped on an `itemSlot`, we should check whether it''s allowed, and we can
    do it with the following lines of code:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: With the item slots done, we can generate some items for testing.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First we use a `for` loop to create 10 `InventoryItems` with different types
    and names.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each of these, we create a Nifty control using `ControlBuilder` and the
    item control we defined earlier, as shown in the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Then, we put each of the inventory items in the itemMap with the ID of the control
    as the key. This ensures we can easily find out the link to the inventory item
    where a nifty item has been dragged or dropped.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java Builder interface we use to create item slots takes a while to get
    used to, but it's a really powerful tool when we have the need to create nifty
    elements dynamically. In this case, we still use a predefined control. This saves
    us a couple of lines of code and allows someone else than a coder to edit the
    layout and style of the component since it's exposed in the XML file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: By default, a `Droppable` control will always accept the `Draggable` control
    that is being dropped. The `accept` method in `DroppableDropFilter` enables us
    to define what should be accepted or not. It's illustrated in this recipe by only
    accepting `InventoryItems` of a certain type. The method parameters for the accept
    method can be described, as the first `Droppable` is the control that the `draggable`
    control is being picked up from. The `Draggable` control is the item that is being
    moved. The second `Droppable` control is the target where `Draggable` has been
    dropped.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this, the first `Droppable` control tends to be null
    the first time a `Draggable` control is being moved.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the input and settings page
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just about every modern game lets the player customize the input according to
    their own preferences. This recipe will rely on jMonkeyEngine to do the work for
    us, and we will use Nifty GUI as a visual aid. We'll use `RawInputListener` to
    work out which keys have been pressed and divide them between key codes and characters
    using the `Keyboard` class.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe will depend on there being some bindings in `InputManager`. If you
    already have a game, this would not be a problem. If not, it will describe how
    to add a couple of bindings for the example to work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the pattern from previous recipes, we''ll start defining the controls,
    then move on to the screen, and finally work on the controller. Adding the controls
    and screen will consist of the following eight steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `<nifty-control>` tag, we define a new `<controlDefinition name="keyBindingControl">`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we''ll add a horizontal spanning panel with some margin to the edges
    of its container and enough height to contain text:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This panel will have three elements. The first is a label control that contains
    the text for the key binding, as shown in the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, it will have a button to change the binding, displaying the current key:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In between them, it will have a simple panel with `width="*"`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can define another `<controlDefinition name="settingsControl">` that
    will contain a number of our `keyBindingControls`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will contain a panel, and inside this, four `keyBindingControls` for each
    moving direction. The IDs of these controls should be representative of the direction
    and end with a key as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The following points are needed for the screen:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ID should be settings, and controller should be `gui.controller.SettingsController`
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `settingsControl` class we just created should be added inside a layer element
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s all with regards to XML. To create the `Controller` class, perform
    the following steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we create a new class that extends `NiftyController`. We call it `SettingsController`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll have `Element` fields for each of the key bindings we would like to track
    and one `Element` field for the current `selectedElement`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we should add `Map<Integer, String>` called `mappings` where we
    can keep the relations between key inputs and input bindings.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, we should call a `bindElements` method, which we'll define as well.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this, we'll add the current key bindings to the `mappings` map using
    the key code as key and the actual binding as the value. This can usually be found
    in the class that handles the input.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, for each of the keys we would like to handle, we find the reference in
    the settings screen and populate their values accordingly. For example, for the
    forward key use the following code:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Next, we define a new inner class called `KeyEventListener` that implements
    `RawInputListener`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `onKeyEvent`, add an `if` statement for if the incoming `KeyInputEvent` is
    pressed and `selectedElement` is not null.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we add a reference to the yet-to-be-created `changeMapping` method and
    add the following line:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, we should set `selectedElement` to `null`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can turn our attention to the `changeMapping` method.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method has the pressed key code as an input parameter, and we use this
    to see whether we already have a binding in our `mappings` map. If `inputManager`
    of the application also has this, we should delete the old binding.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to iterate through all the values in our `mappings` map and check
    whether any of the bindings match the one that the selected element is handling.
    If you find a match, it should be deleted.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we create a new `KeyTrigger` class using `keyCode` and add it to `inputManager`
    using `addMapping`.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing we need to do in this class is add an event subscriber to the
    buttons in `keyBindingControls`.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We define a new method, `keyClicked(String id, ButtonClickedEvent event)`,
    and give it the following annotation:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When the button is clicked, the corresponding element should be selected, so
    we use `event.getButton().getElement().getParent()` to find out which one that
    is.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe explains that when a button that represents a key binding is clicked,
    the corresponding element is selected. By using a pattern in the annotation for
    the `keyClicked` method, rather than an ID, we can capture all the keys using
    the wildcard`.*`. This is also why the naming of the elements is important.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Once an element is selected, `KeyEventListener` will start to listen for a key
    to be pressed on the keyboard. We set the text of the button to be the text representation
    of the key. In many cases, we can use the `getKeyChar` method of `KeyInputEvent`
    for this; however, not all the methods have a character like representation, hence
    the use of the `Keyboard` class and `getKeyName` method instead. This method tends
    to output a string representation instead.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: The `changeMapping` method first sees whether there is a current binding for
    the key pressed and deletes it if that is the case. This is not enough, however,
    since we also need to delete any previous bindings for that input. This is why
    we also iterate over the current mappings to see whether any of them match the
    binding that this key press was for; if yes, it deletes them too.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses a static representation of the different input bindings. This
    would most likely be fine for many games, but modern first person shooters for
    example, can have 20 and more key bindings; adding all of these manually to the
    XML can be cumbersome and not good from a maintenance perspective. In this case,
    it might be better to use the Java Builder interface described in the *Creating
    an inventory screen* recipe to let Java do the repetitious work.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Using offscreen rendering for a minimap
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are generally two ways of creating minimaps. One way is to let an artist
    draw a representation of the map, as shown in the following screenshot. This usually
    ends up beautifully as it gives considerable freedom to the artist when it comes
    to style. The method is not that viable during development when scenes might be
    changing a lot, or for games with procedural content where the end result is not
    known beforehand.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Using offscreen rendering for a minimap](img/6478OS_06_03.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: Minimap with unit marker
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: In those cases, taking a snapshot of the actual scene can be very helpful. The
    resulting image can then be run through various filters (or shaders during rendering)
    to get a less raw look.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll achieve this by creating a new `ViewPort` port, and `FrameBuffer`
    to store a snapshot of a camera. Finally, we'll create `NiftyImage` out of it
    and display it as a GUI element.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re going to start by creating a `Util` class to handle the rendering of
    our minimap. This will consist of the following 15 steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Define a new class called `MinimapUtil`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will only have one static method, `createMiniMap`, with the following declaration:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first thing we do is create a new camera called `offScreenCamera` with the
    same width and height that were supplied to the method.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The camera should have the parallel projection set to true, and a frustrum
    that spans between `1` and `1000` in depth, `-width` to `width`, and `-height`
    to `height`, as shown in the following code:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It should be located at some distance above the scene and rotated downwards,
    as shown in the following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we create a new `ViewPort` by calling the application''s `RenderManager`
    and its `createPreView` method using `offScreenCamera`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we need a `Texture2D` class to store the data in, so we create a class
    called `offScreenTexture` with the same width and height as before and set `MinFilter`
    to `Trilinear`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A `FrameBuffer` class is needed as a medium for the data, so we create one
    with the same width and height, and `1` sample, as shown in the following code:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We set `DepthBuffer` to be `Image.Format.Depth` and `offScreenTexture` to be
    `ColorTexture`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we set `outPutFrameBuffer` of `offScreenView` to be `offScreenBuffer`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Unless the scene we supplied already has some lights, we should add at least
    one `Light` class to it.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we attach the scene to `offScreenView`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To store the texture, we can add it to `AssetManager` with the following line:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we can do the actual rendering by calling the application''s `renderManager`
    and `renderViewPort` methods:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After this, we''re done and can call `removePreview` to discard `offScreeenView`:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With the `Util` class done, we can create a screen `Controller` class. Perform
    the following additional six steps to do this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class called `GameScreenController` that extends `NiftyController`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, it only needs one public method called `createMinimap` that takes a
    scene as the input.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing the `createMinimap` method should do is call `MiniMapUtil.createMinimap`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the scene rendered, we can create `NiftyImage` with the `nifty.createImage`
    method.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we can apply the image to our minimap element in the Nifty screen with
    the following line:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now, all we need to do is add a panel element called `minimap` to a screen that
    uses `GameScreenController` as the controller.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Offscreen rendering is just what it sounds like. We render something in a view
    that is not related to the main view that the player sees. To do this, we set
    up a new viewport and camera. It's not possible to render something directly to
    a texture, which is why `FrameBuffer` is used as the medium.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Once the texture object is created and added to the asset manager, it's possible
    to keep changing it if we would like to at a later stage. It's even possible to
    have a live view of the scene in the minimap, although this would probably cost
    unnecessary resources. In this case, we remove the view as soon as we've rendered
    it once.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: The example is limited in some sense, like it expects that there is a correlation
    between the size of the scene and the size of the minimap.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Nifty uses its own image format, `NiftyImage`, so we need to convert the image
    we saved; however, Nifty's `createImage` will automatically find the texture in
    the asset manager based on the name (key).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, on a minimap, players will want some kind of indication about their
    (and others) whereabouts. Let''s implement that in the minimap we just created:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to change the `minimap` element in our screen a bit. We
    set `childLayout` to `absolute` and add another panel inside it called `playerIcon`
    with a small width and height.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we add a new `Element` field called `playerIcon` to the `GameScreenController`
    and use `findElementByName` in the `bind` method to set it.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add another method called `updatePlayerPosition` with two integers,
    `x` and `y`, as the input.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method should use `setConstraintX` and `setConstraintY` on the `playerIcon`
    element to set the position. Those methods take `SizeValue` as the input, and
    we supply the `x` and `y` values with the `"px"` definition.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in the same method, we need to call `layoutElements()` on the `minimap`
    element to make it update its child elements.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For other things, such as visible enemies, we can use the builder interface
    to create them as and when we need them and then use `markForRemoval` to remove
    them when they're not needed anymore. An example of this process can be seen in
    the *Handling a game message queue* recipe.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
