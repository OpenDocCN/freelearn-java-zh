<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><div id="_idContainer042" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor049" class="pcalibre pcalibre2 pcalibre1 calibre6"/>3</h1>
<h1 id="_idParaDest-51" lang="en-GB" class="calibre5"><a id="_idTextAnchor050" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Zooming in on the Heap Space</h1>
<p lang="en-GB" class="calibre4">In <a href="B18762_02.xhtml#_idTextAnchor038" class="pcalibre pcalibre2 pcalibre1 calibre6"><span lang=""><em class="italic" lang="">Chapter 2</em></span></a>, we discussed the differences between references and objects in memory. References and the objects to which they refer are closely related. We discovered that Java’s call-by-value mechanism could lead to a security issue known as <strong class="bold" lang="">escaping references</strong>, in addition to mutable objects. With the aid of sample code and diagrams, we examined the issues and how to resolve them using <span lang="">defensive copying.</span></p>
<p lang="en-GB" class="calibre4">We know that primitives and references can live on both the stack and the heap, whereas objects just live on the heap. Now, we are ready to take a closer look at the heap in preparation for the next chapter, which is on <strong class="bold" lang="">garbage collection</strong> (<strong class="bold" lang="">GC</strong>). In this chapter, we are going to cover the <span lang="">following topics:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Exploring the different generations on <span lang="">the heap</span></li>
<li lang="en-GB" class="calibre11">Learning how the spaces <span lang="">are used</span></li>
</ul>
<h1 id="_idParaDest-52" lang="en-GB" class="calibre5"><a id="_idTextAnchor051" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Exploring the different generations on the heap</h1>
<p lang="en-GB" class="calibre4">The heap space <a id="_idIndexMarker126" class="pcalibre pcalibre2 pcalibre1 calibre6"/>consists of two different <span lang="">memory areas:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Young <span lang="">generation space</span></li>
<li lang="en-GB" class="calibre11">Old generation (<span lang="">tenured) space.</span></li>
</ul>
<p lang="en-GB" class="calibre4">While we will not dive into the <strong class="bold" lang="">GC</strong> process in this chapter, we need to explain what a <em class="italic" lang="">live</em> object is. A<a id="_idIndexMarker127" class="pcalibre pcalibre2 pcalibre1 calibre6"/> live object is one that is reachable from the <span lang="">GC roots.</span></p>
<h2 id="_idParaDest-53" lang="en-GB" class="calibre7"><a id="_idTextAnchor052" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Garbage collection roots</h2>
<p lang="en-GB" class="calibre4">A GC root is a <a id="_idIndexMarker128" class="pcalibre pcalibre2 pcalibre1 calibre6"/>special type of live object and is, therefore, not eligible for GC. All objects reachable from GC roots are also live and are, therefore, not eligible for GC. The GC roots act as starting points in GC, that is, start at these roots and mark all objects reachable as <em class="italic" lang="">live</em>. The most common GC roots are <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Local variables on <span lang="">the stack</span></li>
<li lang="en-GB" class="calibre11">All active <span lang="">Java threads</span></li>
<li lang="en-GB" class="calibre11">Static variables (as these can be referenced by <span lang="">their classes)</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Java Native Interface</strong> (<strong class="bold" lang="">JNI</strong>) references – Objects<a id="_idIndexMarker129" class="pcalibre pcalibre2 pcalibre1 calibre6"/> created by the native code as part <a id="_idIndexMarker130" class="pcalibre pcalibre2 pcalibre1 calibre6"/>of a JNI call. This is a very special case of GC roots because the JVM does not know whether the objects are referenced by the native code <span lang="">or not.</span></li>
</ul>
<p lang="en-GB" class="calibre4">Let us examine how the spaces appear in memory, as shown in <span lang=""><em class="italic" lang="">Figure 3</em></span><span lang=""><em class="italic" lang="">.1</em></span><span lang="">:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer033">
<img alt="Figure 3.1 – The heap generations" src="image/Figure_3.1_B18762.jpg" class="calibre42"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The heap generations</p>
<p lang="en-GB" class="calibre4">At this point, we require brief definitions so that we can discuss how the spaces <span lang="">are used:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Young generation space</strong> – The<a id="_idIndexMarker131" class="pcalibre pcalibre2 pcalibre1 calibre6"/> young generation space, sometimes<a id="_idIndexMarker132" class="pcalibre pcalibre2 pcalibre1 calibre6"/> called<a id="_idIndexMarker133" class="pcalibre pcalibre2 pcalibre1 calibre6"/> the <strong class="bold" lang="">nursery</strong> or <strong class="bold" lang="">new</strong> space, contains two separate areas: the <strong class="bold" lang="">eden</strong> space and the <strong class="bold" lang="">survivor</strong> space. Both serve different functions with the overall goal to increase memory efficiency. We will discuss them <span lang="">in turn:</span><ul class="calibre43"><li lang="en-GB" class="calibre11"><strong class="bold" lang="">Eden space</strong>: <em class="italic" lang="">New</em> objects <a id="_idIndexMarker134" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are allocated in the eden space. When the eden space is full and there is no room for allocating a new object, the young generation (<strong class="bold" lang="">minor</strong>) garbage <span lang="">collector runs.</span></li><li lang="en-GB" class="calibre11"><strong class="bold" lang="">Survivor space</strong>: There <a id="_idIndexMarker135" class="pcalibre pcalibre2 pcalibre1 calibre6"/>are two equally divided survivor spaces, namely S0 and S1. The minor garbage collector uses these regions in an alternate fashion. We will explore this in more <span lang="">detail later.</span></li></ul></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Old generation space</strong> – This<a id="_idIndexMarker136" class="pcalibre pcalibre2 pcalibre1 calibre6"/> is also known as <strong class="bold" lang="">tenured</strong> space. This is where longer-lived objects reside. In other words, the garbage collector moves objects that have survived a certain number of GCs here. When the tenured space becomes full, this triggers a <span lang=""><strong class="bold" lang="">major</strong></span><span lang=""> GC.</span></li>
</ul>
<p lang="en-GB" class="calibre4">Now that we have a brief overview of the spaces, let us examine how they <span lang="">are used.</span></p>
<h1 id="_idParaDest-54" lang="en-GB" class="calibre5"><a id="_idTextAnchor053" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Learning how the spaces are used</h1>
<p lang="en-GB" class="calibre4">To understand how these different spaces are used, we will explain them in two different stages. Initially, we will examine how the spaces are used in the minor GC algorithm. Subsequently, with the aid of an example, we will show the algorithm <span lang="">in action.</span></p>
<h2 id="_idParaDest-55" lang="en-GB" class="calibre7"><a id="_idTextAnchor054" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Understanding the minor garbage collection algorithm</h2>
<p lang="en-GB" class="calibre4">Let us start <a id="_idIndexMarker137" class="pcalibre pcalibre2 pcalibre1 calibre6"/>with the minor GC algorithm. <span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.2</em> is high-level pseudocode of the minor <span lang="">GC process:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer034">
<img alt="Figure 3.2 – Pseudocode of the minor garbage collection algorithm" src="image/Figure_3.2_B18762.jpg" class="calibre44"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Pseudocode of the minor garbage collection algorithm</p>
<p lang="en-GB" class="calibre4">Let us examine the <a id="_idIndexMarker138" class="pcalibre pcalibre2 pcalibre1 calibre6"/>process outlined in the preceding figure using a <span lang=""><em class="italic" lang="">Given-When-Then</em></span><span lang=""> scenario.</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">Given</strong>: <strong class="bold" lang="">S0</strong> as the target survivor and <strong class="bold" lang="">S1</strong> as the source survivor <span lang="">spaces initially.</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">When</strong>: Minor garbage collector runs. In other words, the eden space does not have enough space for an object that the JVM wishes <span lang="">to allocate.</span></li>
<li lang="en-GB" class="calibre11"><span lang=""><strong class="bold" lang="">Then</strong></span><span lang="">:</span><ul class="calibre43"><li lang="en-GB" class="calibre11">All live objects from the eden space are copied to the <strong class="bold" lang="">S0</strong> survivor space. The ages of these objects are set to <strong class="source-inline" lang="">1</strong>, as they have just survived their first <span lang="">GC cycle.</span></li><li lang="en-GB" class="calibre11"><strong class="bold" lang="">S1</strong> is examined and any live objects whose ages meet a given threshold (the <strong class="bold" lang="">tenuring threshold</strong>) are copied to the old generation space, meaning they are tenured. In other words, this is a long-lived object, so copy it to the old generation area where longer-lived objects reside. This makes future minor GC runs more efficient as it ensures these same objects are <span lang="">not re-examined.</span></li><li lang="en-GB" class="calibre11">The remaining live <strong class="bold" lang="">S1</strong> objects (the ones that were not tenured) are copied to <strong class="bold" lang="">S0</strong>, where their ages are incremented by one, as they have just passed another <span lang="">GC cycle.</span></li></ul></li>
</ul>
<p lang="en-GB" class="calibre4">Note that the<a id="_idIndexMarker139" class="pcalibre pcalibre2 pcalibre1 calibre6"/> tenuring threshold is configurable using a JVM argument, <strong class="source-inline" lang="">-XX:MaxTenuringThreshold</strong>. In effect, this flag allows you to customize how many GC cycles an object will stay in the survivor space before it finally gets tenured into the old space. However, care must be exercised with the argument, as a value greater than 15 specifies that objects should never tenure, thereby indefinitely filling up the survivor space with <span lang="">old objects.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.3</em> shows the process <span lang="">just discussed:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer035">
<img alt="Figure 3.3 – Minor garbage collection with S0 as the target space" src="image/Figure_3.3_B18762.jpg" class="calibre45"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Minor garbage collection with S0 as the target space</p>
<p lang="en-GB" class="calibre4">Here is <span lang="">a</span><span lang=""><a id="_idIndexMarker140" class="pcalibre pcalibre2 pcalibre1 calibre6"/></span><span lang=""> summary:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Copy live eden objects to <strong class="bold" lang="">S0</strong> (ages set <span lang="">to </span><span lang=""><strong class="source-inline" lang="">1</strong></span><span lang="">)</span></li>
<li lang="en-GB" class="calibre11">Copy old, live <strong class="bold" lang="">S1</strong> objects to <span lang="">long-generation space</span></li>
<li lang="en-GB" class="calibre11">Copy young, live <strong class="bold" lang="">S1</strong> objects to <strong class="bold" lang="">S0</strong> (<span lang="">ages incremented)</span></li>
</ul>
<p lang="en-GB" class="calibre4">Now that the live objects from eden and <strong class="bold" lang="">S1</strong> have been copied (saved), both eden and <strong class="bold" lang="">S1</strong> can now <span lang="">be reclaimed.</span></p>
<p lang="en-GB" class="calibre4">When the <a id="_idIndexMarker141" class="pcalibre pcalibre2 pcalibre1 calibre6"/>minor collector runs again, given that <strong class="bold" lang="">S0</strong> was the target survivor space the last time, <strong class="bold" lang="">S1</strong> will be the target survivor space this time. Therefore, all live objects from eden are copied into <strong class="bold" lang="">S1</strong> with ages of <strong class="source-inline" lang="">1</strong> set for each object. As <strong class="bold" lang="">S1</strong> is now the target space, <strong class="bold" lang="">S0</strong> becomes the source space. The garbage collector examines <strong class="bold" lang="">S0</strong> and copies long-lived objects into tenured space and short-lived objects into <strong class="bold" lang="">S1</strong>. <span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.4</em> shows <span lang="">this process:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer036">
<img alt="Figure 3.4 – Minor garbage collection with S1 as the target space" src="image/Figure_3.4_B18762.jpg" class="calibre46"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Minor garbage collection with S1 as the target space</p>
<p lang="en-GB" class="calibre4">Here is <span lang="">a summary:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">All live eden objects are copied to <strong class="bold" lang="">S1</strong> (ages set <span lang="">to </span><span lang=""><strong class="source-inline" lang="">1</strong></span><span lang="">)</span></li>
<li lang="en-GB" class="calibre11">Copy old, live <strong class="bold" lang="">S0</strong> objects to <span lang="">long-generation space</span></li>
<li lang="en-GB" class="calibre11">Copy young, live <strong class="bold" lang="">S0</strong> objects to <strong class="bold" lang="">S1</strong> (<span lang="">ages incremented)</span></li>
</ul>
<p lang="en-GB" class="calibre4">Given that the live objects from eden and <strong class="bold" lang="">S0</strong> have been copied, both eden and <strong class="bold" lang="">S0</strong> can <span lang="">be reclaimed.</span></p>
<p lang="en-GB" class="calibre4">Now that we have discussed how the spaces are used, we will enhance our explanation with the aid of <span lang="">an example.</span></p>
<h2 id="_idParaDest-56" lang="en-GB" class="calibre7"><a id="_idTextAnchor055" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Demonstrating the minor garbage collection algorithm in action</h2>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.5</em> shows the<a id="_idIndexMarker142" class="pcalibre pcalibre2 pcalibre1 calibre6"/> situation in memory initially, prior to the first run of the minor <span lang="">garbage collector:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer037">
<img alt="Figure 3.5 – Initial heap state prior to minor garbage collection #1" src="image/Figure_3.5_B18762.jpg" class="calibre47"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Initial heap state prior to minor garbage collection #1</p>
<p lang="en-GB" class="calibre4">In the preceding figure, object <strong class="bold" lang="">H</strong> represents an object that the JVM is trying to allocate memory for in the eden space. The eden space consists of <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11">Red objects have no references to them from the GC roots. They are eligible <span lang="">for GC.</span></li>
<li lang="en-GB" class="calibre11">Green <a id="_idIndexMarker143" class="pcalibre pcalibre2 pcalibre1 calibre6"/>objects are live objects, meaning they are GC roots or can be reached via GC roots. These objects are <em class="italic" lang="">not</em> eligible <span lang="">for GC.</span></li>
<li lang="en-GB" class="calibre11">White spaces are gaps in the eden space. If there is enough contiguous space to allocate the object, then the object is stored in eden, and its reference is returned. If, however, due to memory fragmentation, there is not enough contiguous space to allocate the object, a minor (young generation) GC <span lang="">is triggered.</span></li>
</ul>
<p lang="en-GB" class="calibre4">The survivor space consists of <span lang="">the following:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S0</strong> – Empty initially; we will assume that the JVM is using this as the target survivor <span lang="">space initially</span></li>
<li lang="en-GB" class="calibre11"><strong class="bold" lang="">S1</strong> – Also empty initially; as <strong class="bold" lang="">S0</strong> is the target space, <strong class="bold" lang="">S1</strong> becomes the source space (as there is nothing in <strong class="bold" lang="">S1</strong> initially, this has no effect the first <span lang="">time around)</span></li>
</ul>
<p lang="en-GB" class="calibre4">The tenured (old generation) space consists of long-lived objects. Long-lived objects are objects that have survived a certain predefined number of minor GC. This is a customizable threshold value using the <strong class="source-inline" lang="">-XX:MaxTenuringThreshold</strong> <span lang="">JVM argument.</span></p>
<p lang="en-GB" class="calibre4">As can be seen in <span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.5</em>, the JVM has a requirement to allocate an object <strong class="bold" lang="">H</strong> but as there is not enough room in eden, this triggers a minor (young generation) GC. Objects <strong class="bold" lang="">A</strong>, <strong class="bold" lang="">D</strong>, and <strong class="bold" lang="">G</strong> can be removed from eden, and objects <strong class="bold" lang="">B</strong>, <strong class="bold" lang="">C</strong>, <strong class="bold" lang="">E</strong>, and <strong class="bold" lang="">F</strong> can be moved to <strong class="bold" lang="">S0</strong>. The eden space is reclaimed and object <strong class="bold" lang="">H</strong> <span lang="">is allocated.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.6</em> shows the heap after the first minor GC <span lang="">has finished:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer038">
<img alt="Figure 3.6 – Heap state post minor garbage collection #1" src="image/Figure_3.6_B18762.jpg" class="calibre48"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Heap state post minor garbage collection #1</p>
<p lang="en-GB" class="calibre4">In the<a id="_idIndexMarker144" class="pcalibre pcalibre2 pcalibre1 calibre6"/> preceding figure, object <strong class="bold" lang="">H</strong> is allocated in eden, and objects <strong class="bold" lang="">B</strong>, <strong class="bold" lang="">C</strong>, <strong class="bold" lang="">E</strong>, and <strong class="bold" lang="">F</strong> in <strong class="bold" lang="">S0</strong>. Note that the objects in <strong class="bold" lang="">S0</strong> each have an age of <strong class="bold" lang="">1</strong> as this is their first minor GC <span lang="">to survive.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.7</em> shows the heap prior to the second minor <span lang="">GC run:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer039">
<img alt="Figure 3.7 – Heap state prior to minor garbage collection #2" src="image/Figure_3.7_B18762.jpg" class="calibre49"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Heap state prior to minor garbage collection #2</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.7</em>, the JVM <a id="_idIndexMarker145" class="pcalibre pcalibre2 pcalibre1 calibre6"/>is trying to allocate object <strong class="bold" lang="">N</strong> but there is no space for it in eden. This will trigger the minor garbage collector to run (for the second time). In the eden space, objects <strong class="bold" lang="">H</strong>, <strong class="bold" lang="">L</strong>, and <strong class="bold" lang="">M</strong> are eligible for GC, and objects <strong class="bold" lang="">I</strong>, <strong class="bold" lang="">J</strong>, and <strong class="bold" lang="">K</strong> are live. In the survivor space, <strong class="bold" lang="">S0</strong>, object <strong class="bold" lang="">B</strong> is now eligible for GC, whereas objects <strong class="bold" lang="">C</strong>, <strong class="bold" lang="">E</strong>, and <strong class="bold" lang="">F</strong> <span lang="">are live.</span></p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.8</em> shows the heap after the second minor <span lang="">GC run:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer040">
<img alt="Figure 3.8 – Heap state post minor garbage collection #2" src="image/Figure_3.8_B18762.jpg" class="calibre50"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Heap state post minor garbage collection #2</p>
<p lang="en-GB" class="calibre4">In <span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.8</em>, <strong class="bold" lang="">S1</strong> is <a id="_idIndexMarker146" class="pcalibre pcalibre2 pcalibre1 calibre6"/>now the target survivor space and thus <strong class="bold" lang="">S0</strong> is the source. The garbage collector moves the live objects <strong class="bold" lang="">C</strong>, <strong class="bold" lang="">E</strong>, and <strong class="bold" lang="">F</strong> from <strong class="bold" lang="">S0</strong> to <strong class="bold" lang="">S1</strong>, incrementing their age values from <strong class="bold" lang="">1</strong> to <strong class="bold" lang="">2</strong>. The garbage collector then reclaims the <span lang=""><strong class="bold" lang="">S0</strong></span><span lang=""> space.</span></p>
<p lang="en-GB" class="calibre4">Objects <strong class="bold" lang="">I</strong>, <strong class="bold" lang="">J</strong>, and <strong class="bold" lang="">K</strong> are moved from eden to <strong class="bold" lang="">S1</strong> with age values of <strong class="bold" lang="">1</strong>, as this is their first time surviving a minor GC. The eden space is reclaimed and the object <strong class="bold" lang="">N</strong> <span lang="">is allocated.</span></p>
<p lang="en-GB" class="calibre4">The last thing to show is objects moving to the tenured space. This is what <span lang=""><em class="italic" lang="">Figure </em></span><span lang=""><em class="italic" lang="">3</em></span><span lang=""><em class="italic" lang="">.9</em></span><span lang=""> demonstrates:</span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer041">
<img alt="Figure 3.9 – Objects moving to tenured space" src="image/Figure_3.9_B18762.jpg" class="calibre51"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Objects moving to tenured space</p>
<p lang="en-GB" class="calibre4"><span lang=""><em class="italic" lang="">Figure 3</em></span><em class="italic" lang="">.9</em> represents <a id="_idIndexMarker147" class="pcalibre pcalibre2 pcalibre1 calibre6"/>the heap after 15 minor GC runs. Objects <strong class="bold" lang="">E</strong> and <strong class="bold" lang="">F</strong> move to tenured space because their age values of <strong class="bold" lang="">15</strong> have reached the threshold (the default threshold value is 15). The next time the minor garbage collector runs, both of these objects will not feature, enabling the garbage collector to run <span lang="">more efficiently.</span></p>
<p lang="en-GB" class="calibre4">Object <strong class="bold" lang="">X</strong> was the object that triggered the minor garbage collector and, for this iteration, <strong class="bold" lang="">S1</strong> was the source and <strong class="bold" lang="">S0</strong> the target survivor space. Objects <strong class="bold" lang="">J</strong>, <strong class="bold" lang="">P</strong>, and <strong class="bold" lang="">S</strong> are still live and move from <strong class="bold" lang="">S1</strong> to <strong class="bold" lang="">S0</strong> with age counts of <strong class="bold" lang="">14</strong>, <strong class="bold" lang="">8</strong>, and <span lang=""><strong class="bold" lang="">3</strong></span><span lang="">, respectively.</span></p>
<p lang="en-GB" class="calibre4">Before we conclude this chapter, it is worth mentioning some other relevant <span lang="">JVM flags:</span></p>
<ul class="calibre10">
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-Xms</strong> and <strong class="source-inline" lang="">-Xmx</strong> specify the heap’s minimum and maximum <span lang="">sizes, respectively.</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:NewSize</strong> and <strong class="source-inline" lang="">-XX:MaxNewSize</strong> specify the young generation’s minimum and maximum <span lang="">sizes, respectively.</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:SurvivorRatio</strong> specifies the relative sizes of the two survivor spaces with respect to the eden space. For example, <strong class="source-inline" lang="">-XX: SurvivorRatio=6</strong> sets the ratio between eden and a survivor space to <strong class="source-inline" lang="">1:6</strong>. In other words, each survivor space will be one-sixth the size of eden and therefore, one-eighth the size of the young generation (not one-seventh, as there two <span lang="">survivor spaces).</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:NewRatio</strong> expresses the relative size of the new generation with respect to the old generation. For example, <strong class="source-inline" lang="">-XX:NewRatio=3</strong> sets the ratio between the new generation and old generation to <strong class="source-inline" lang="">1:3</strong>. This means that the new generation (eden plus both survivor spaces) occupies 25% of the heap and the old generation occupies the <span lang="">remaining 75%.</span></li>
<li lang="en-GB" class="calibre11"><strong class="source-inline" lang="">-XX:PretenureSizeThreshold</strong> – If an object’s size is greater than the size specified by this flag, then the object is tenured immediately, meaning the object is allocated straight to the old generation space. The default value is <strong class="source-inline" lang="">0</strong>, which means no object will be directly allocated to the old generation of <span lang="">the heap.</span></li>
</ul>
<p lang="en-GB" class="calibre4">In general, keep the<a id="_idIndexMarker148" class="pcalibre pcalibre2 pcalibre1 calibre6"/> young generation space between 25% and 33% of the total heap size. This ensures that the old-generation space is always larger. This is desirable because full GCs are more expensive than <span lang="">minor ones.</span></p>
<p lang="en-GB" class="calibre4">That wraps up this chapter. Let us recap the <span lang="">major points.</span></p>
<h1 id="_idParaDest-57" lang="en-GB" class="calibre5"><a id="_idTextAnchor056" class="pcalibre pcalibre2 pcalibre1 calibre6"/>Summary</h1>
<p lang="en-GB" class="calibre4">In this chapter, we zoomed in on the heap space. We started by examining the different generations on the heap – namely, the young generation space and the old generation (<span lang="">tenured) space.</span></p>
<p lang="en-GB" class="calibre4">The young generation space is divided into two spaces: the eden and survivor spaces. The eden space is where new objects are allocated. The survivor space consists of two equally sized spaces, namely S0 and S1. The minor (young generation) garbage collector uses these survivor spaces when reclaiming memory. Minor GC is triggered when there is not enough contiguous space to allocate an object in the eden space. Using pseudocode and diagrams, we examined how the minor garbage collector utilizes the generations and spaces. We then used an example that had several use case scenarios to reinforce <span lang="">the concepts.</span></p>
<p lang="en-GB" class="calibre4">The tenured space is where longer-lived objects reside. We saw that if an object survives several GC cycles, the object moves to tenured space to make subsequent minor GC cycles more efficient. Lastly, we looked at relevant <span lang="">JVM flags.</span></p>
<p lang="en-GB" class="calibre4">Now that we understand the heap and have had a high-level overview of the minor garbage collector, we are ready to take a deep dive into GC, which is the topic of the <span lang="">next chapter.</span></p>
</div>
<div class="calibre2">
<div id="_idContainer043" class="calibre2">
</div>
</div>
</div></body></html>