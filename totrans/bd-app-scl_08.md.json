["```java\n    import akka.actor._ \n    case object HelloMessage \n    class HelloWorldActor extends Actor { \n      def receive = { \n        case HelloMessage => sender() ! \"Hello World\" \n        case a:Any => sender() ! \"I don't know: \" + a + \" - Sorry!\" \n      } \n    } \n    object SimpleActorMainApp extends App{  \n      val system = ActorSystem(\"SimpleActorSystem\") \n      val actor = system.actorOf(Props[HelloWorldActor])  \n      import scala.concurrent.duration._ \n      import akka.util.Timeout \n      import akka.pattern.ask \n      import scala.concurrent.Await \n      implicit val timeout = Timeout(20 seconds)  \n      val future = actor ? HelloMessage \n      val result = Await.result(future, \n      timeout.duration).asInstanceOf[String] \n      println(\"Actor says: \" + result )  \n      val future2 = actor ? \"Cobol\" \n      val result2 = Await.result(future2, \n      timeout.duration).asInstanceOf[String] \n      println(\"Actor says: \" + result2 )    \n      system.terminate() \n    } \n\n```", "```java\n$ sbt run \n\n```", "```java\n    import akka.actor._  \n    object Message  \n    class PrinterActor extends Actor { \n      def receive = { \n        case a:Any => \n        println(\"Print: \" + a) \n      } \n    } \n    object FireAndForgetActorMainApp extends App{ \n      val system = ActorSystem(\"SimpleActorSystem\") \n      val actor = system.actorOf(Props[PrinterActor])     \n      val voidReturn = actor ! Message \n      println(\"Actor says: \" + voidReturn ) \n      system.terminate() \n    } \n\n```", "```java\n    import akka.actor._ \n    import akka.routing.RoundRobinPool  \n    class ActorUpperCasePrinter extends Actor { \n      def receive = { \n        case s:Any => \n        println(\"Msg: \" + s.toString().toUpperCase() + \" - \" + \n        self.path) \n      } \n    } \n    object RoutingActorApp extends App {    \n      val system = ActorSystem(\"SimpleActorSystem\") \n      val actor:ActorRef = system.actorOf(   \n        RoundRobinPool(5).props(Props[ActorUpperCasePrinter]),name = \n      \"actor\")  \n      try{ \n        actor ! \"works 1\" \n        actor ! \"works 2\" \n        actor ! \"works 3\" \n        actor ! \"works 4\" \n        actor ! \"works 5\" \n        actor ! \"works 6\"  \n      }catch{ \n        case e:RuntimeException => println(e.getMessage()) \n      }   \n      system.terminate() \n    } \n\n```", "```java\n    import akka.actor._ \n    import akka.persistence._ \n    import scala.concurrent.duration._ \n    class PersistenceActor extends PersistentActor{  \n      override def persistenceId = \"sample-id-1\" \n      var state:String = \"myState\" \n      var count = 0    \n      def receiveCommand: Receive = { \n        case payload: String => \n        println(s\"PersistenceActor received ${payload} (nr = \n        ${count})\") \n        persist(payload + count) { evt => \n          count += 1 \n        } \n      }        \n      def receiveRecover: Receive = { \n        case _: String => \n        println(\"recover...\") \n        count += 1 \n      } \n    }  \n    object PersistentViewsApp extends App { \n      val system = ActorSystem(\"SimpleActorSystem\") \n      val persistentActor = \n      system.actorOf(Props(classOf[PersistenceActor]))     \n      import system.dispatcher \n      system.scheduler.schedule(Duration.Zero, 2.seconds, \n      persistentActor, \"scheduled\") \n    } \n\n```", "```java\n    akka { \n      system = \"SimpleActorSystem\" \n      remote { \n        log-remote-lifecycle-events = off \n        netty.tcp { \n          hostname = \"127.0.0.1\" \n          port = 0 \n        } \n      } \n    } \n    akka.cluster.metrics.enabled=off  \n    akka.persistence.journal.plugin = \n    \"akka.persistence.journal.leveldb\" \n    akka.persistence.snapshot-store.plugin = \n    \"akka.persistence.snapshot-store.local\"  \n    akka.persistence.journal.leveldb.dir = \"target/persistence/journal\" \n    akka.persistence.snapshot-store.local.dir = \n    \"target/persistence/snapshots\"  \n    # DO NOT USE THIS IN PRODUCTION !!! \n    # See also https://github.com/typesafehub/activator/issues/287 \n    akka.persistence.journal.leveldb.native = false \n\n```", "```java\n    // rest of the build.sbt file ...   \n    val akkaVersion = \"2.4.9\"                \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-actor\" % \n    akkaVersion \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-kernel\" % \n    akkaVersion \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-remote\" % \n    akkaVersion \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-cluster\" % \n    akkaVersion \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-contrib\" % \n    akkaVersion \n    libraryDependencies += \"com.typesafe.akka\" %% \"akka-persistence\" % \n    akkaVersion \n    libraryDependencies += \"org.iq80.leveldb\" % \"leveldb\" % \"0.7\" \n    libraryDependencies += \"org.iq80.leveldb\" % \"leveldb-api\" % \"0.7\" \n    libraryDependencies += \"org.fusesource.leveldbjni\" % \"leveldbjni\" % \n    \"1.8\" \n    libraryDependencies += \"org.fusesource.leveldbjni\" % \"leveldbjni-\n    linux64\" % \"1.8\" \n    libraryDependencies += \"org.fusesource\" % \"sigar\" % \"1.6.4\" \n    libraryDependencies += \"org.scalatest\" % \"scalatest_2.11\" % \"2.2.6\" \n\n```", "```java\n    // rest of the build.stb ...  \n    libraryDependencies ++= Seq( \n      \"com.typesafe.akka\" %% \"akka-testkit\" % \"2.4.4\" % Test, \n    // rest of the deps ... \n    )  \n    // rest of the build.stb ... \n\n```", "```java\n    package actors  \n    object ActorHelper {  \n      import play.api.libs.concurrent.\n      Execution.Implicits.defaultContext \n      import scala.concurrent.duration._ \n      import akka.pattern.ask \n      import akka.actor.ActorRef \n      import akka.util.Timeout \n      import scala.concurrent.Future \n      import scala.concurrent.Await    \n      def get(msg:Any,actor:ActorRef):String = { \n        implicit val timeout = Timeout(5 seconds) \n        val result = (actor ? msg).mapTo[String].map { result => \n        result.toString } \n        Await.result(result, 5.seconds) \n      } \n    } \n\n```", "```java\n    package actors  \n    case class ChatMessage(name:String,text: String) \n    case class Stats(users:Set[String])  \n    object JoinChatRoom \n    object Tick \n    object GetStats \n\n```", "```java\n    package actors  \n    import akka.actor.Props \n    import akka.actor.Terminated \n    import akka.actor.ActorLogging \n    import akka.event.LoggingReceive \n    import akka.actor.Actor \n    import akka.actor.ActorRef \n    import play.libs.Akka \n    import akka.actor.ActorSystem  \n    class ChatRoomActor extends Actor with ActorLogging {  \n      var users = Set[ActorRef]()  \n      def receive = LoggingReceive { \n        case msg: ChatMessage => \n        users foreach { _ ! msg } \n        case JoinChatRoom => \n        users += sender \n        context watch sender   \n        case GetStats => \n        val stats:String = \"online users[\" + users.size + \"] - users[\" \n        + users.map( a =>        a.hashCode().mkString(\"|\") + \"]\" \n        sender ! stats \n        case Terminated(user) => \n        users -= user \n      } \n    } \n    object ChatRoomActor { \n      var room:ActorRef = null \n      def apply(system:ActorSystem) = { \n        this.synchronized { \n          if (room==null) room = system.actorOf(Props[ChatRoomActor]) \n          room \n        } \n      } \n    } \n\n```", "```java\n    package actors  \n    import akka.actor.ActorRef \n    import akka.actor.Actor \n    import akka.actor.ActorLogging \n    import akka.event.LoggingReceive \n    import akka.actor.ActorSystem \n    import akka.actor.Props  \n    class ChatUserActor(room:ActorRef, out:ActorRef) extends Actor with \n    ActorLogging { \n      override def preStart() = { \n        room ! JoinChatRoom \n      }  \n      def receive = LoggingReceive { \n        case ChatMessage(name, text) if sender == room => \n        val result:String = name + \":\" + text \n        out ! result \n        case (text:String) => \n        room ! ChatMessage(text.split(\":\")(0), text.split(\":\")(1)) \n        case other => \n        log.error(\"issue - not expected: \" + other) \n      } \n    }  \n    object ChatUserActor { \n      def props(system:ActorSystem)(out:ActorRef) = Props(new       \n      ChatUserActor(ChatRoomActor(system), out)) \n    } \n\n```", "```java\n    package actors  \n    import akka.actor.ActorRef \n    import akka.actor.Actor \n    import akka.actor.ActorLogging \n    import akka.event.LoggingReceive \n    import akka.actor.ActorSystem \n    import akka.actor.Props \n    import scala.concurrent.duration._  \n    class ChatBotAdminActor(system:ActorSystem) extends Actor with \n    ActorLogging { \n      import play.api.libs.concurrent.Execution.\n      Implicits.defaultContext \n      val room:ActorRef = ChatRoomActor(system) \n      val cancellable = system.scheduler.schedule(0 seconds, \n      10 seconds, self , Tick) \n      override def preStart() = { \n        room ! JoinChatRoom \n      }  \n      def receive = LoggingReceive { \n        case ChatMessage(name, text) => Unit \n        case (text:String) => room ! ChatMessage(text.split(\":\")(0), \n        text.split(\":\")(1)) \n        case Tick => \n        val response:String = \"AdminBot:\" + ActorHelper.get\n        (GetStats, room) \n        sender() ! response \n        case other => \n        log.error(\"issue - not expected: \" + other) \n      } \n    } \n    object ChatBotAdminActor { \n      var bot:ActorRef = null \n      def apply(system:ActorSystem) = { \n        this.synchronized { \n          if (bot==null) bot = system.actorOf(Props\n          (new ChatBotAdminActor(system))) \n          bot \n        } \n      } \n    } \n\n```", "```java\n    package controllers  \n    import akka.actor.ActorSystem \n    import akka.stream.Materializer \n    import javax.inject._ \n    import play.api._ \n    import play.api.mvc._ \n    import play.api.libs.streams._ \n    import actors.ChatUserActor \n    import actors.ChatBotAdminActor  \n    @Singleton \n    class ChatController @Inject() (implicit val system: ActorSystem,\n    materializer: Materializer) \n    extends Controller {  \n      import play.api.libs.concurrent.Execution.\n      Implicits.defaultContext \n      ChatBotAdminActor(system)  \n      def index_socket = Action { request => \n        Ok(views.html.chat_index()(Flash(Map()))) \n      } \n      def ws = WebSocket.accept[String, String] { request => \n        ActorFlow.actorRef(out => ChatUserActor.props(system)(out)) \n      }\n    } \n\n```", "```java\n    routes  \n    # \n    # Akka and Websockets  \n    # \n    GET /chat/index_socket   controllers.ChatController.index_socket \n    GET /chat/ws                    controllers.ChatController.ws \n\n```", "```java\n    @()(implicit flash:Flash)  \n    @main(\"Chat\"){  \n    <!DOCTYPE html> \n      <meta charset=\"utf-8\" /> \n      <title>Chat Room</title> \n      <script type=\"text/javascript\"> \n        var output; \n        var websocket = new WebSocket(\"ws://localhost:9000/chat/ws\");     \n        function init(){ \n          output = document.getElementById(\"output\");     \n          websocket.onmessage = function(evt) { \n            writeToScreen('<span style=\"color:blue;\">' + evt.data+ \n            '</span>'); \n          };           \n          websocket.onerror = function(evt) { \n            writeToScreen('<span style=\"color: red;\">ERROR:</span> ' + \n            evt.data); \n          }; \n        }     \n        function doSend(message){ \n          websocket.send(message); \n        }     \n        function writeToScreen(message){ \n          var pre = document.createElement(\"p\"); \n          pre.style.wordWrap = \"break-word\"; \n          pre.innerHTML = message; \n          $('#output').prepend(pre); \n        }     \n        window.addEventListener(\"load\", init, false); \n      </script>  \n      <h3>Messages</h3> \n      <div id=\"output\" style=\"width: 800px; height: 250px; overflow-y: \n      scroll;\" > \n      </div>  \n      <div id=\"contentMessage\">   \n        <BR> \n        user:      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \n        <input type=\"text\" name=\"txtUser\" id=\"txtUser\" /> <BR><BR> \n        message: <input type=\"text\" name=\"txtMessage\" \n        id=\"txtMessage\" /> \n        <BR> \n        <BR>     \n        <a href=\"#\" class=\"btn btn-success\" \n        onclick=\"doSend( document.getElementById('txtUser').value + ':' \n        + document.getElementById('txtMessage').value );\"> \n        <i class=\"icon-plus icon-white\"></i>Send Message</a> \n      </div> \n    } \n\n```", "```java\n    @(message: String)(implicit flash:Flash)  \n    @main(\"Welcome to Reactive Web Store\"){ \n    <div class=\"row-fluid\"> \n      <BR> \n      <div class=\"span12\">           \n        <div class=\"row-fluid\"> \n          <div class=\"span6\"> \n            <a href=\"/product\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/product.png\")\"> Manage \n            Products</a><BR> \n            <a href=\"/review\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/review.png\")\"> Manage \n            Reviews</a><BR> \n            <a href=\"/image\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/image.png\")\"> Manage \n            Images</a><BR> \n          </div> \n          <div class=\"span6\"> \n            <a href=\"/reports\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/reports.png\")\"> Reports </a>\n            <BR> \n            <a href=\"/chat/index_socket\"><img height=\"42\" width=\"42\" \n            src=\"img/@routes.Assets.at(\"images/chat.png\")\"> Chat Room </a>\n              <BR> \n            </div> \n          </div> \n        </div>             \n      </div> \n    } \n\n```", "```java\n    class OutActor extends Actor { \n      def receive = { \n        case a:Any => Unit \n      } \n    }  \n    class ChatUserActorSpec extends PlaySpec {   \n      class Actors extends TestKit(ActorSystem(\"test\"))  \n      \"ChatUserActor\" should { \n        \"joins the chat room and send a message\" in new Actors { \n          val probe1 = new TestProbe(system) \n          val actorOutRef = TestActorRef[OutActor](Props[OutActor]) \n          val actorRef = TestActorRef[ChatUserActor]\n          (ChatUserActor.props(system)(actorOutRef)) \n          val userActor = actorRef.underlyingActor \n          assert(userActor.context != null) \n          val msg = \"testUser:test msg\" \n          probe1.send(actorRef,msg) \n          actorRef.receive(msg) \n          receiveOne(2000 millis) \n        } \n      } \n    } \n\n```", "```java\n    class ChatRoomActorSpec extends PlaySpec {    \n      class Actors extends TestKit(ActorSystem(\"test\"))  \n      \"ChatRoomActor\" should { \n        \"accept joins the chat rooms\" in new Actors { \n          val probe1 = new TestProbe(system) \n          val probe2 = new TestProbe(system) \n          val actorRef = TestActorRef[ChatRoomActor]\n          (Props[ChatRoomActor]) \n          val roomActor = actorRef.underlyingActor \n          assert(roomActor.users.size == 0) \n          probe1.send(actorRef, JoinChatRoom) \n          probe2.send(actorRef, JoinChatRoom) \n          awaitCond(roomActor.users.size == 2, 100 millis) \n          assert(roomActor.users.contains(probe1.ref)) \n          assert(roomActor.users.contains(probe2.ref)) \n        } \n        \"get stats from the chat room\" in new Actors { \n          val probe1 = new TestProbe(system) \n          val actorRef = TestActorRef[ChatRoomActor]\n          (Props[ChatRoomActor]) \n          val roomActor = actorRef.underlyingActor \n          assert(roomActor.users.size == 0) \n          probe1.send(actorRef, JoinChatRoom) \n          awaitCond(roomActor.users.size == 1, 100 millis) \n          assert(roomActor.users.contains(probe1.ref)) \n          probe1.send(actorRef, GetStats) \n          receiveOne(2000 millis) \n        } \n        \"and broadcast messages\" in new Actors { \n          val probe1 = new TestProbe(system) \n          val probe2 = new TestProbe(system) \n          val actorRef = TestActorRef[ChatRoomActor]\n          (Props[ChatRoomActor]) \n          val roomActor = actorRef.underlyingActor \n          probe1.send(actorRef, JoinChatRoom) \n          probe2.send(actorRef, JoinChatRoom) \n          awaitCond(roomActor.users.size == 2, 100 millis) \n          val msg = ChatMessage(\"sender\", \"test message\") \n          actorRef.receive(msg) \n          probe1.expectMsg(msg) \n          probe2.expectMsg(msg) \n        } \n        \"and track users ref and counts\" in new Actors { \n          val probe1 = new TestProbe(system) \n          val probe2 = new TestProbe(system)  \n          val actorRef = TestActorRef[ChatRoomActor]\n          (Props[ChatRoomActor]) \n          val roomActor = actorRef.underlyingActor \n          probe1.send(actorRef, JoinChatRoom) \n          probe2.send(actorRef, JoinChatRoom) \n          awaitCond(roomActor.users.size == 2, 100 millis) \n          probe2.ref ! PoisonPill \n          awaitCond(roomActor.users.size == 1, 100 millis) \n        }\n      }\n    } \n\n```", "```java\n    class ChatBotAdminActorSpec extends TestKit(ActorSystem(\"test\")) \n    with ImplicitSender \n    with WordSpecLike with Matchers with BeforeAndAfterAll {  \n      \"ChatBotAdminActor\" should { \n        \"be able to create Bot Admin in the Chat Room and Tick\" in { \n          val probe1 = new TestProbe(system) \n          val actorRef = TestActorRef[ChatBotAdminActor](Props(new \n          ChatBotAdminActor(system))) \n          val botActor = actorRef.underlyingActor \n          assert(botActor.context != null) \n          awaitCond(botActor.room != null ) \n        } \n      } \n    } \n\n```"]