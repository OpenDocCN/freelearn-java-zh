<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Advanced Functional Programming</h1>
                
            
            <article>
                
<div class="packt_quote">"Like punning, programming is a play on words."</div>
<div class="packt_quote1">– Alan Peris</div>
<p class="calibre2">You're a developer, right? Think of a scenario where you're asked to write some software that has certain entities. Take a look at the following:</p>
<pre class="calibre19">Animal         |      Food </pre>
<p class="calibre2">We have the <kbd class="calibre11">Animal</kbd> and <kbd class="calibre11">Food</kbd> entities. We're working on an automated system that serves food to animals in a zoo. Suppose we're going to write a function which lets two animals share their food. It expects two animal objects, food, and then does the job. The function looks like this:</p>
<pre class="calibre19">def serveSharedMeal(<br class="title-page-name"/>    animalOne: Animal, <br class="title-page-name"/>    animalTwo: Animal, <br class="title-page-name"/>    meal: Food) = ??? <br class="title-page-name"/>//don't care about the implementation </pre>
<p class="calibre2">So far, everything's fine, right? Let's introduce two animals now. We have two animal subclasses named <kbd class="calibre11">Lion</kbd> and <kbd class="calibre11">Deer</kbd>. Our simple function takes two <kbd class="calibre11">animal</kbd> instances and shares the <kbd class="calibre11">meal</kbd> instance among them. Now, you might wonder what happens when we pass instances of <kbd class="calibre11">Lion</kbd> and <kbd class="calibre11">Deer</kbd>; what might be the consequences? Hence, we promote strictly typed programs, which can fail at compile time. This means we can write our programs in such a way that the Scala compiler won't allow us to write such programs. You're able to see how types can save lives. Great, so this is the agenda here.</p>
<p class="calibre2">We'll be talking about types and parameterizing our types. We introduced type parameterization in the previous chapter, so we'll take our journey further and learn more about type parameterization, abstract types, and a lot more. Let's take a look at what's coming:</p>
<ul class="calibre7">
<li class="calibre8">Genericity/type parameterization</li>
<li class="calibre8">Parameterized types</li>
<li class="calibre8">Variance</li>
<li class="calibre8">Abstract types</li>
<li class="calibre8">Bounds</li>
<li class="calibre8">Abstract versus parameterized types</li>
<li class="calibre8">Type classes</li>
</ul>
<p class="calibre2">Let me tell you, this chapter's going to be another interesting one. We'll be using constructs that we've already used to make our code more meaningful. But before we dive in to learn about parameterized types in detail, let's talk about why there's so much hype about types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Why so serious about types?</h1>
                
            
            <article>
                
<p class="calibre2">We've seen that knowing what we're doing can save life. But joking aside, if we really think before writing our applications, it can really help. Our programs consist of two ingredients:</p>
<pre class="calibre19">Data     |            Operations </pre>
<p class="calibre2">We can perform operations on the data available. At the same time, not all operations can be performed on all sorts of data. That's what difference types make. You don't want to perform an addition operation between an Integer and a String literal. That's why the compiler does not allow us to do that. Even if it assumes you're trying to concatenate the string with the literal, it's not going to give you a result that's not meaningful. That's why defining types make sense.</p>
<p class="calibre2">Let's discuss a few terms that we just mentioned. It's really good that Scala is a statically typed language because it provides us compile time type safety. The code that we write is less prone to runtime errors, because we were so smart and we wrote it that way (we'll learn about this in this chapter). Our beloved Scala compiler performs a compile time type check on the program we wrote and throws an error at compile time if we try to be too smart. The following diagram may clear your doubts:</p>
<div class="cdpaligncenter"><img src="../images/00035.jpeg" class="calibre41"/></div>
<p class="calibre2">You see? The preceding picture depicts that if your program is working, that's not enough, eventually you may find some corner cases that will cause them to fail. So, we better choose a language that helps you cover that section more, so that your program lives in a happy world:</p>
<div class="cdpaligncenter"><img src="../images/00036.jpeg" class="calibre42"/></div>
<p class="calibre2">This is essential for us to understand why we're supporting a system where using <em class="calibre18">types</em> is encouraged.</p>
<p class="calibre2">We began to understand the importance of types in programming, and as we approached writing optimized and well structured code, we found something called type genericity. We began to write types which can be specified later on. And this gave rise to the notion of type constructors. Now, we can write types that take parameters. For example, think of a type <kbd class="calibre11">constructorList[T]</kbd><em class="calibre18">.</em> Here, our known <kbd class="calibre11">List[T]</kbd> expects you to provide a type. You can also think of it as a function on a type, you provide a parameter while constructing. In our example, if we choose to provide a string, our list will then be called a <kbd class="calibre11">List[String]</kbd><em class="calibre18">,</em> that's an applied version of <kbd class="calibre11">List[T]</kbd> with the <kbd class="calibre11"><span>String</span></kbd> type. This concept is called <strong class="calibre1">parametric polymorphism</strong> where we say that our <kbd class="calibre11">List[T]</kbd> uses a type parameter <kbd class="calibre11">T</kbd> to abstract over the type of its elements. Let's try out the stuff we talked about in Scala REPL:</p>
<pre class="calibre19">scala&gt; val xs: List = List("ABC") 
&lt;console&gt;:11: error: type List takes type parameters 
       val xs: List = List("ABC") </pre>
<p class="calibre2">In the preceding snippet we got an error. This happened because we tried providing a type constructor <kbd class="calibre11">List</kbd> instead of a concrete type:</p>
<pre class="calibre19">scala&gt; val xs: List[T] = List("ABC") 
&lt;console&gt;:11: error: not found: type T 
       val xs: List[T] = List("ABC") </pre>
<p class="calibre2">The previous snippet also failed with an error because we knew that we should provide a type parameter but we supplied some element that itself isn't a type. So what should we do now? Let's try the following:</p>
<pre class="calibre19">scala&gt; val xs: List[String] = List("ABC") 
xs: List[String] = List(ABC) </pre>
<p class="calibre2">This time it worked for us: we provided a type <kbd class="calibre11">String</kbd> to our type constructor and it worked for us. So I believe we can differentiate between a type constructor and a type. Now that you've insights into why we're doing this, let's dive in and learn about parameterized types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Here comes type parameterization</h1>
                
            
            <article>
                
<p class="calibre2">Think of the same scenario. You were asked to write a program that contains some different entities, for example, humans and animals. Now, both require food to stay alive. Our colleagues are aware of this and have written code that takes care of the way food is served to humans as well as animals.</p>
<p class="calibre2">They have written the code and provided it as a library (we can access those functions by importing the packages they wrote). Our colleagues were ahead of time and wrote a function that looked like the following:</p>
<pre class="calibre19">def servseMeal[A, B](serveTo: A, serveThis: Option[B]) = ??? </pre>
<p class="calibre2">We were told the function will work, we just have to provide who to serve the food to as the first parameter and an optional food item as a meal. The rest will be taken care of by the logic they've put. We tried a couple of ways and wrote a few applications of this as follows:</p>
<pre class="calibre19">serveMeal(Human(Category("MALE")), None) 
serveMeal(Human(Category("FEMALE")), Some(Food())) 
serveMeal(Animal(), None) 
serveMeal(Animal(), Some("NONVEG")) 
 
case class Human(category: Category) 
case class Category(name: String) 
case class Animal() 
case class Food() </pre>
<p class="calibre2">And somehow, it works as expected. But wait, this is really cool, we were exposed to only one function and everything seemed to work as expected. They didn't want us to specifically call <kbd class="calibre11">serveMealToHumans</kbd> or <kbd class="calibre11">serveNonVegMealToAnimals</kbd> functions.</p>
<p class="calibre2">This really helped us write better code at our end. We were both intelligent teams and we separated our concerns. You know, their concern was to take care of the ways of serving food to all, our concern was to ensure each of our entities are getting food they're supposed to get. The job's done. Let's talk about why we chose this example. To understand that, take a look at the function signature they wrote:</p>
<pre class="calibre19">def serveMeal[A, B](serveTo: A, serveThis: Option[B]) = ??? </pre>
<p class="calibre2">We see the <kbd class="calibre11">def</kbd> keyword, then the name of the function, but after that they wrote letters <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd><em class="calibre18">,</em> what are these? To learn more, let's go ahead and read out the whole signature. There's a parameter that we were supposed to serve, the type was named <em class="calibre18">A,</em> and the food option was given a type named <kbd class="calibre11">B</kbd> <em class="calibre18">(</em>option <kbd class="calibre11">B</kbd><em class="calibre18">).</em> Well, these are type parameters. The function itself is an example of <em class="calibre18">parametric polymorphism.</em> We know that it means <em class="calibre18">having multiple forms.</em> The same goes here. Our function can have multiple parameter types. To better understand, take a look at this:</p>
<pre class="calibre19">serveMeal(Human(Category("MALE")): Human, None: Option[Food]) 
serveMeal(Human(Category("FEMALE")): Human, Some(Food()): Option[Food]) 
serveMeal(Animal() : Animal, None: Option[Food]) 
serveMeal(Animal(): Animal, Some(Food()): Option[Food]) </pre>
<p class="calibre2">Here in the function calls, we specified the types of our parameters. From the signature of our function it is clear that we can give whichever type we want and the <kbd class="calibre11">serveMeal</kbd> function takes care of the rest of the logic. So, the take away is that these <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd> <span>parameters </span>are called type parameters. The whole concept can be termed type parameterization. We cannot just write generic methods, but also generic classes and traits<em class="calibre18">.</em> Let's check them out.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Another way around - generic classes and traits</h1>
                
            
            <article>
                
<p class="calibre2">We just saw the effect of <em class="calibre18">genericity</em> and it solved more than one problem, we wrote less code and achieved more. The <kbd class="calibre11">serveMeal</kbd> function was a generic one because it takes type parameters, in our case <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd><em class="calibre18">.</em> It performs the intended logic, great! Let's talk about <em class="calibre18">parameterized types.</em> You know the type <kbd class="calibre11">List</kbd><em class="calibre18">,</em> right? Let's take a look at its declaration in the Scala standard library:</p>
<pre class="calibre19">sealed abstract class List[+A] extends AbstractSeq[A] 
  with LinearSeq[A] 
  with Product 
  with GenericTraversableTemplate[A, List] 
  with LinearSeqOptimized[A, List[A]] 
  with Serializable </pre>
<p class="calibre2">Okay, the declaration seems far too complex, doesn't it? No, wait, we know what sealed means, we know why we used an abstract class, then the name <kbd class="calibre11">List</kbd><em class="calibre18">,</em> and then a few more declarations for showing inheritance relationships. But there's this thing called <kbd class="calibre11">[+A]</kbd> in our declaration. Our job is to find out what this is and why we used it.</p>
<p class="calibre2">From the previous few topics, we gained an idea of this notion of <em class="calibre18">type constructors.</em> So, let's call this <kbd class="calibre11">List[+A]</kbd> a type constructor. We know that if we provide it a concrete type, List will make a meaningful type. We've tried this before so we won't be creating another list of strings. We'll try to learn the significance of this + sign in the next few topics. It shows a <em class="calibre18">variance</em> relationship. Let's look at the previous declaration first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type parameter names</h1>
                
            
            <article>
                
<p class="calibre2">Here, in the declaration of the <kbd class="calibre11">List[+T]</kbd> type constructor (we can use the names parameterized types or type constructors interchangeably), we used the parameter name, <kbd class="calibre11">T</kbd>, it's a convention to use such names in generic programming. The names <em class="calibre18"><kbd class="calibre11">T</kbd>,</em> <kbd class="calibre11">A</kbd><em class="calibre18">,</em> <kbd class="calibre11">B</kbd><em class="calibre18">,</em> or <kbd class="calibre11">C</kbd> have nothing to do with the initializer type you're going to provide when you initiate a list instance. For example, when you give a <kbd class="calibre11">String</kbd> <span>type</span><strong class="calibre1"> </strong>for the previously mentioned type parameter when you instantiate <kbd class="calibre11">List[String]</kbd>, it really doesn't matter if the declaration has <kbd class="calibre11">List[T]</kbd> or <kbd class="calibre11">List[A]</kbd>. What we mean is the following two declarations are equivalent:</p>
<pre class="calibre19">//With type parameter name A 
 
sealed abstract class List[+A] extends AbstractSeq[A]  
 
//With type parameter name T 
 
sealed abstract class List[+T] extends AbstractSeq[T] </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container types</h1>
                
            
            <article>
                
<p class="calibre2">We've seen Scala's class hierarchy, hence we are aware of many collection types such as <kbd class="calibre11">List</kbd>, <kbd class="calibre11">Set</kbd>, and <kbd class="calibre11">Map</kbd>. What's different about these types along with types such as <kbd class="calibre11">Option</kbd> and <kbd class="calibre11">Either</kbd><em class="calibre18">,</em> is that they all expect you to provide a type and then instantiate. We call <kbd class="calibre11">List</kbd> as a container type because it works that way. We use a list to contain elements of a certain data type. Similarly, we can think of an <kbd class="calibre11">Option</kbd> as a binary containerized type, as <kbd class="calibre11">Option</kbd> can be some value or <kbd class="calibre11">None</kbd><em class="calibre18">.</em> The <kbd class="calibre11">Either</kbd> <span>type </span>goes the same way. In Scala, when we create such container types<em class="calibre18">,</em> we tend to use a type parameter to declare and provide a concrete type, such as <kbd class="calibre11">String</kbd><em class="calibre18">,</em> <kbd class="calibre11">Int</kbd><em class="calibre18">,</em> Boolean<em class="calibre18">,</em> and so on when we instantiate. Take a look how <kbd class="calibre11">Option</kbd> is declared in Scala (more on <kbd class="calibre11">Option</kbd> and <kbd class="calibre11">Either</kbd> types in the next chapter):</p>
<pre class="calibre19">sealed abstract class Option[+A] extends Product  
   with Serializable </pre>
<p class="calibre2">It takes a type parameter <kbd class="calibre11">A</kbd><em class="calibre18">.</em> It's possible to provide more than one type parameter if your type expects more than one type to get instantiated. An example of such a type is <kbd class="calibre11">Either</kbd>:</p>
<pre class="calibre19">sealed abstract class Either[+A, +B] extends Product with Serializable </pre>
<p class="calibre2">As shown previously, our <span>type</span><span> </span><kbd class="calibre11">Either</kbd> takes two types, <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd><em class="calibre18">.</em> But when I tried the following snippet it didn't work as expected:</p>
<pre class="calibre19">object TypeErasure extends App { 
  val strings: List[String] = List("First", "Second", "Third") 
  val noStringsAttached: List[Int] = List(1, 2, 3) 
 
  def listOf[A](value: List[A]) = value match { 
    case listOfString: List[String] =&gt; println("Strings Attached!") 
    case listOfNumbers: List[Int] =&gt; println("No Strings Attached!") 
  } 
 
  listOf(strings) 
  listOf(noStringsAttached) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Strings Attached! 
Strings Attached! </pre>
<p class="calibre2">You see? We created two lists, first of strings and the other list of numbers. Then, a function named <kbd class="calibre11">listOf</kbd> that's a generic function simply to take a list and tell the type of list it is. We performed a pattern match to check the type of list passed to the function and print it. But it didn't work out for us (and might not for anyone). Also, it threw a few warnings telling us there was unreachable code for the second case expression. Let's talk about why!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type erasure</h1>
                
            
            <article>
                
<p class="calibre2">When the Scala compiler compiles the previous code, it erases the parameterized type information from the previous code and so it doesn't have the necessary knowledge at runtime; the list we passed does not take any further information about itself. In other words, all type information for generic types is discarded by the time the code compiled. This phenomenon is termed <strong class="calibre1">type erasure</strong><em class="calibre18">.</em> This is the reason our function <kbd class="calibre11">listOf</kbd> didn't work as we expected or, let's say, assumed. That's the same reason you got a warning of unreachable code, because our statically typed language was able to know that the second case will never be executed, and the first case is a kind of catch all in this pattern match. Let's explain this a bit better. Take a look at a few cases where type erasure will be applicable. Imagine you have a trait named <kbd class="calibre11">Tfoo</kbd>:</p>
<pre class="calibre19">trait Tfoo[T]{ 
  val member: T 
} </pre>
<p class="calibre2">After the process of compilation, the generic type gets converted to object and becomes like the following:</p>
<pre class="calibre19">trait Tfoo { 
  val member: Object   //Cause scala files gets converted to *.class files. 
} </pre>
<p class="calibre2">Similarly, conversion takes place if we use any type parameter in a generic method. It's clear the type information gets erased, no matter if it's at class level or method level. Great! So, now we have some idea about parameterized types. Any code snippet, regardless of it being a method or any class/trait, if it contains a <em class="calibre18">type parameter,</em> it's not alien code to us. But, then you ask, what's with the <kbd class="calibre11">+</kbd> sign in <kbd class="calibre11">List[+T]</kbd>? Yes, this shows variance under an inheritance relationship and this <kbd class="calibre11">+</kbd> is called <strong class="calibre1">variance annotation</strong>. Let's go through it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Variance under inheritance</h1>
                
            
            <article>
                
<p class="calibre2">One of the ways we can learn about a concept is to ask questions that lead you to the concept. So let's ask a question ourselves. Given that a <kbd class="calibre11">Cat</kbd> <span>class type </span>extends the <kbd class="calibre11">Animal</kbd><em class="calibre18"> </em><span>class</span>, is it okay to treat a list of <em class="calibre18">cats</em> as a list of <em class="calibre18">animals</em>? Programmatically, see the following:</p>
<pre class="calibre19">abstract class Animal() 
 
class Cat(name: String) extends Animal()               // Inheritance relationship between Cat and Animal 
 
def doSomethingForAnimals(animals: List[Animal]) = ??? //definitely do something for animals. 
 
Is it possible to pass an argument that's a list of Cats? 
val cats = List(new Cat("Mischief"), new Cat("Birdie")) 
doSomethingForAnimals(cats) </pre>
<p class="calibre2">If it's possible, the statement that <kbd class="calibre11">List[Cat]</kbd> is a subtype of <kbd class="calibre11">List[Animal]</kbd> makes sense. Also, the concept is called <strong class="calibre1">covariance</strong>. Hence, we say <kbd class="calibre11">List</kbd> is covariant in its type parameter <kbd class="calibre11">T</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00037.jpeg" class="calibre43"/></div>
<p class="calibre2">If you take a look at the preceding image, the direction of the inheritance relationship between two concrete classes, namely <kbd class="calibre11"><em class="calibre18">Cat</em></kbd> and <kbd class="calibre11">Animal</kbd>, and their parameterized versions, namely <kbd class="calibre11">List[Cat]</kbd> and <kbd class="calibre11">List[Animal]</kbd> types, are the same. But it's not the case every time. There might be cases where you have a container type for which the variance relationship works the opposite way.</p>
<p class="calibre2">Think about it this way: given two types <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd>, where <kbd class="calibre11">A</kbd> is a super type of <kbd class="calibre11">B</kbd>, and some container type <kbd class="calibre11">Foo[T]</kbd><em class="calibre18">,</em> so the relationship where <kbd class="calibre11">Foo[A]</kbd> is a subtype of <kbd class="calibre11">Foo[B]</kbd> is called contravariance in <kbd class="calibre11">T</kbd>, and represented by <kbd class="calibre11">Foo[-T]</kbd><em class="calibre18">.</em> Here the <kbd class="calibre11">-</kbd> sign represents contravariance.</p>
<p class="calibre2">If you're thinking this is too theoretical, some code examples may make the concept clearer. Let's take a look at a scenario. Nowadays, enterprises like to provide all sorts of arrangements for their employees from food and insurance to their travel needs. It's not a big deal if some corporation decides to work with an airline company to provide corporate bookings for their employees. Airline companies, in order to support such bookings, can support schemes where they book seats for corporate passengers, executive passengers, and regular passengers. So, imagine in our program that books seats in an aircraft, we represent each seat as an aircraft seat. Programmatically, we can represent it as a class:</p>
<pre class="calibre19">class AircraftSeat[-T] </pre>
<p class="calibre2">Now, we have a few passengers represented by the <kbd class="calibre11">Passenger</kbd> class. There are a few subtypes of Passenger such as <kbd class="calibre11">CorporatePassenger</kbd>, <kbd class="calibre11">ExecutivePassenger</kbd><em class="calibre18">,</em> and <kbd class="calibre11">RegularPassenger</kbd>.</p>
<p class="calibre2">The relationship between them is as follows:</p>
<div class="cdpaligncenter"><img src="../images/00038.jpeg" class="calibre44"/></div>
<p class="calibre2">As shown, <kbd class="calibre11">CorporatePassengers</kbd> and <kbd class="calibre11">RegularPassengers</kbd> inherit from the <kbd class="calibre11">Passengers</kbd> class, so there's an inheritance relationship between these types. This can be represented by the following:</p>
<pre class="calibre19">abstract class Passengers 
class CorporatePassengers extends Passengers 
class RegularPassengers extends Passengers </pre>
<p class="calibre2">Now, if you have a function that reserves seats for the corporate employees, its signature may look like the following:</p>
<pre class="calibre19">def reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = ??? //Seat booking logic! </pre>
<p class="calibre2">The previous function expects you to provide an <kbd class="calibre11">AircraftSeat[CorporatePassengers]</kbd>, and does its job. If we try writing the whole of this in a Scala application, it'll look like the following:</p>
<pre class="calibre19">object ContraVariance extends App { 
   
  class AircraftSeat[-T] 
 
  def reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = { 
    //Performs some logic regarding the seat reservation! 
    println(s" Seats Confirmed!") 
  } 
 
  abstract class Passengers 
  class CorporatePassengers extends Passengers 
  class RegularPassengers extends Passengers 
 
  reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers]) 
 
  reserveSeatForCorporatePassengers(new AircraftSeat[Passengers]) 
 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Seats Confirmed! 
Seats Confirmed! </pre>
<p class="calibre2">Now, take a moment, and go through the preceding code. We'll talk about a few points and try to play with annotations and inheritance:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">AircraftSeat[-T]</kbd> is a container type in our case that uses contravariance annotation, that is, a <kbd class="calibre11">-</kbd> sign for its type parameter.</li>
<li class="calibre8">The <kbd class="calibre11">reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers])</kbd> function takes <kbd class="calibre11">AircraftSeat</kbd> of type <kbd class="calibre11">CorporatePassengers</kbd> or its super type such as <kbd class="calibre11">Passengers</kbd>, because of the contravariance relationship in its type parameters.</li>
<li class="calibre8">The function call to <kbd class="calibre11">reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers])</kbd> and <kbd class="calibre11">reserveSeatForCorporatePassengers(new AircraftSeat[Passengers])</kbd> works because of contravariance in the parameterized type, <kbd class="calibre11">AircraftSeat</kbd>.</li>
<li class="calibre8">In the previous code, try changing the type constructor <kbd class="calibre11">AircraftSeat[-T]</kbd> to <kbd class="calibre11">AircraftSeat[+T]</kbd>. You'll be greeted with a compilation error saying type mismatch because the parameterized type gets changed to covariant in <kbd class="calibre11">T</kbd>, and because of that the <kbd class="calibre11">Passengers</kbd> super type is no longer valid in place of <kbd class="calibre11">Aircraft[CorporatePassengers]</kbd><em class="calibre18">.</em></li>
<li class="calibre8">Similarly, if we try to make a function call to the <kbd class="calibre11">reserveSeatForCorporatePassengers</kbd> <span>function </span>with <kbd class="calibre11">RegularPassengers</kbd>, it won't work and will throw a compilation error about type mismatch. The reason is the same: our parameterized type being contravariant in <kbd class="calibre11">T</kbd>.</li>
</ul>
<p class="calibre2">The previous example and experiments clear up what covariance and contravariance are and what the differences are between them. See the following image:</p>
<div class="cdpaligncenter"><img src="../images/00039.jpeg" class="calibre45"/></div>
<p class="calibre2">The preceding image explains the inheritance relation between the concrete types <kbd class="calibre11">Passengers</kbd><em class="calibre18">,</em> <kbd class="calibre11">CorporatePassengers</kbd>, and parameterized types <kbd class="calibre11">AircraftSeat[Passengers]</kbd>, and <kbd class="calibre11">AircraftSeat[CorporatePassengers]</kbd><em class="calibre18">.</em> You may have noticed that the inheritance direction for contravariance is in the opposite direction.</p>
<p class="calibre2">With this, we've understood two types of variance relationship within the parameterized types. First is covariance and then contravariance. Now, there's another type of variance relation that's possible and that's called invariant relationship in <kbd class="calibre11">T</kbd>. We don't use any signs to show that invariance relationship. We simply use the container type along with a type parameter name as in <kbd class="calibre11">Foo[T]</kbd>, the type is invariant in <kbd class="calibre11">T</kbd>. Hence, if you want to consume an instance of type <kbd class="calibre11">Foo[T]</kbd>, you must provide an instance of <kbd class="calibre11">Foo[T]</kbd>, any super type or sub type of T will not work for that.</p>
<p class="calibre2">Variance is quite an important concept in functional programming. Hence, you may find many examples of it in Scala. We've already seen examples, such as <kbd class="calibre11">List[+T]</kbd> and <kbd class="calibre11">option[+T]</kbd><em class="calibre18">,</em> which are covariant in T.</p>
<p class="calibre2">Another popular example for such variance relationships is the <kbd class="calibre11">Function</kbd> trait:</p>
<pre class="calibre19">trait Function1[-T1, +R] extends AnyRef {self =&gt; 
  /** Apply the body of this function to the argument. 
    * 
    * @return the result of function application. 
    */ 
  def apply(v1: T1): R 
 
} </pre>
<p class="calibre2">Here, we declare something like the following:</p>
<pre class="calibre19">scala&gt; val func = (i: Int) =&gt; i.toString 
func: Int =&gt; String </pre>
<p class="calibre2">Here, Scala converts it into an instance of these <kbd class="calibre11">Function</kbd> traits and this becomes the following:</p>
<pre class="calibre19">new Function1[Int, String]{ 
  override def apply(v1: Int): String = v1.toString 
} </pre>
<p class="calibre2">Here, this trait as shown in the signature consumes the type <kbd class="calibre11">T</kbd> and produces <kbd class="calibre11">R</kbd>. We've put variance annotations in front of <kbd class="calibre11">T</kbd> and <kbd class="calibre11">R</kbd>, where <kbd class="calibre11">Function1</kbd> is contravariant in <kbd class="calibre11">[-T]</kbd>, the consumable type and covariant in <kbd class="calibre11">[+R]</kbd> the producible type. I hope this clears up the variance relationship. Let's look at when to use covariance and contravariance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">When to use what type of variance relation</h1>
                
            
            <article>
                
<p class="calibre2">It's clear that variance is useful for telling the compiler when it's okay to bind an instance of one parameterized type to a reference of the same parameterized type with a different type parameter. The way we did for <kbd class="calibre11">List[Animal]</kbd> and <kbd class="calibre11">List[Cat]</kbd><em class="calibre18">.</em> But the question arises, whether to use covariance or use contravariance.</p>
<p class="calibre2">In the last example, we saw the <kbd class="calibre11">Function1</kbd> trait from Scala's standard library. The input/consumable type was contravariant and the output/producible type was covariant. It gives us a sense that when we are about to consume some type, it's okay to use contravariance. (Why? We'll get to that shortly.)  When we are about to produce some results we should go for covariance. The idea here is that as a <kbd class="calibre11">consumer</kbd> you can consume a variety of types or, in other words, you're allowed to consume more general (contravariant) stuff, and at the same time as a <kbd class="calibre11">producer</kbd>, you are allowed to produce more specific (covariant) stuff. You get the point, right?</p>
<p class="calibre2">So you remember, we talked about our programs made of two entities: <em class="calibre18">data</em> and <em class="calibre18">operations.</em> We also said not all operations can be performed on all data. Hence, we had the concept of types. Now, our lives are much more exciting because of type parameterization, but we should take care when we declare our parameterized types because there may be some operations that are not defined for all types under T in Foo[T]. For this, we have a thing called <em class="calibre18">Type Bounds.</em> Using type bounds we can specify for which types we want to perform the operations. Well, we'll talk about <em class="calibre18">bounds</em> too, but before that I want to talk about another way of achieving abstraction in our programs and that's through <em class="calibre18">abstract types.</em> Let's go through and try to understand a concept people find difficult when they start using Scala (you won't, we'll make it clear!).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract types</h1>
                
            
            <article>
                
<p class="calibre2">Okay, first things first. We tried to achieve <em class="calibre18">abstraction </em>when we introduced <em class="calibre18">type parameterizing.</em> We will do the same thing using <em class="calibre18">abstract type members.</em> But what's an <em class="calibre18">abstract type member</em>? How do we write them, how can we use them, and why do we even need them when we already have <em class="calibre18">parameterized types?</em> These are a few questions. We'll try answering them. So let's start with the first question. How do we write an abstract type. This is done as follows:</p>
<pre class="calibre19">trait ThinkingInTermsOfT { 
      type T 
} </pre>
<p class="calibre2">Okay, we just wrote a trait named <kbd class="calibre11">ThinkingInTermsOfT</kbd> and it has an abstract type member. So, to declare an abstract type member we use the keyword <kbd class="calibre11">type</kbd> along with the parameter name that in our case is <kbd class="calibre11">T</kbd>. From our elementary Scala introduction or, let's say, from previous chapters, we know how we can instantiate a trait<em class="calibre18">.</em> So when we instantiate our trait, we'll give a type to our abstract member. That's going to be a concrete type:</p>
<pre class="calibre19">val instance = new ThinkingInTermsOfT { 
  type T = Int 
 
  def behaviourX(t: T): T = ??? 
} </pre>
<p class="calibre2">Here, we instantiated the trait with a <kbd class="calibre11">new</kbd> keyword and then, while defining the trait implementation, we gave the <kbd class="calibre11">Int</kbd> <span>type </span>to our abstract type member <kbd class="calibre11">T</kbd>. This allows us to use <kbd class="calibre11">T</kbd> type at the declaration side trait without caring about what the type's going to be. And when we instantiate, we assign a concrete type, just like we did here:</p>
<pre class="calibre19">type T = Int </pre>
<p class="calibre2">You now have some idea of how to perform these kinds of operations and why we used this <em class="calibre18">type T</em> declaration: so that we can write our behavior methods such as <kbd class="calibre11">doX</kbd> and return <kbd class="calibre11">T</kbd>, or <kbd class="calibre11">doY(t: T)</kbd> using type <kbd class="calibre11">T</kbd> and return something. Abstract members give us the flexibility to write code without worrying about the type at the time of writing. Our functions/methods are fine to work with whatever type we define when we instantiate the trait/class.</p>
<p class="calibre2">Let's take an example to compare how and what we achieved using type members:</p>
<pre class="calibre19">object AbstractTypes extends App { 
 
  trait ColumnParameterized[T] { 
       def column() : T 
  } 
 
  trait ColumnAbstract { 
    type T 
 
    def column(): T 
  } 
 
  val aColumnFromParameterized = new ColumnParameterized[String] { 
    override val column = "CITY" 
  } 
 
  val aColumnFromAbstract = new ColumnAbstract { 
    type T = String 
 
    override val column = "HOUSE_NO" 
  } 
 
  println(s"Coloumn from Parameterized: ${aColumnFromParameterized.column}   |  and Column from Abstract: ${aColumnFromAbstract.column} ") 
   
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Column from Parameterized: CITY   |  and Column from Abstract: HOUSE_NO </pre>
<p class="calibre2">This example is easy to understand. We have both our parameterized version and the current one, a trait with an abstract type. So take a look at the parameterized version. We have specified that our <kbd class="calibre11">traitColumnParameterized[T]</kbd> is a parameterized type with parameter <kbd class="calibre11">T</kbd>. We're comfortable with this kind of syntax, right? We've just gone through it, it's simple and easy to understand. Now, the latter declaration, trait <kbd class="calibre11">ColumnAbstract</kbd> has a type member, we declared it using the <kbd class="calibre11">type</kbd><em class="calibre18"> </em>keyword.</p>
<p class="calibre2">Now take a look at the implementation. For parameterized types we knew what we had to do and we instantiated the trait (you know what's happening with these curly braces at the time of instantiation, right?). Similarly, we instantiated the trait with the abstract member and overrode the definition with a <kbd class="calibre11">val</kbd><em class="calibre18">,</em> that's possible, you know that already.</p>
<p class="calibre2">And that's why we were able to call both of these and get the values out of them. Now, if you try to assign the following:</p>
<pre class="calibre19">type T = String </pre>
<p class="calibre2">Here, we use the following:</p>
<pre class="calibre19">override val column = 23 </pre>
<p class="calibre2">Here, we get an error, an error saying incompatible types. We know the reason: because an integer cannot satisfy the signature, the signature expects the type to be <kbd class="calibre11">T</kbd>, and <kbd class="calibre11">T</kbd> is <kbd class="calibre11">String</kbd><em class="calibre18">.</em> So, you're trying to do the wrong thing; the compiler won't let you pass through. I would suggest you try out these two concepts of parameterized types and abstract types. The more you use them and write them, the more comfortable you will get. Remember, these abstract members expect you to provide types and in Scala, a function is also a type. So, you can go deeper by thinking in terms of generating functions dynamically using a trait.</p>
<p class="calibre2">Let's take a moment and think. Suppose you want to form a mechanism for performing an action/operation. The code for such an action generator may look like this:</p>
<pre class="calibre19">trait ActionGenerator[In] { 
  type Out 
 
  def generateAction(): Out 
} </pre>
<p class="calibre2">Now, this looks cool: we've used a parameterized type and also an abstract type member. Also, our type <kbd class="calibre11">Out</kbd> member can be a function type. Think of it as a rule or pattern. It can be as follows:</p>
<pre class="calibre19">type Out = Int =&gt; String </pre>
<p class="calibre2">To get more insight, let's think of a scenario where you want to provide a mechanism to generate a rating between 1 to 5 from a list of comments you received on your blog post. Now, different people have different ways of appreciating (or not appreciating) so some people were good enough to give you a rating of 4 or 5. Some people, out of the blue, wrote, <kbd class="calibre11">Awesome</kbd>, <kbd class="calibre11">Nice</kbd>, or <kbd class="calibre11">Worst ever</kbd>. You have to generate a rating for your blog from all these comments.</p>
<p class="calibre2">Now, from the scenario, it might seem cool to write a rule, which, based on the comments, can generate the rating. Look closely: <em class="calibre18">generate the rating</em> is an action/operation. We'll abstract this and we'll write the generate the rating generator, we mean <kbd class="calibre11">ActionGenerator</kbd>. It could look as follows:</p>
<pre class="calibre19">object RatingApp extends App { 
 
  type Rating = Int 
  type NumericString = String //String that can be converted into Int! 
  type AlphaNumeric = String  //Alphanumeric String 
 
  val simpleRatingGenerator = new ActionGenerator[NumericString] { 
    type Out = NumericString =&gt; Rating 
 
    /* Times when ratings are simple NumericStrings 
     * Rating as 1, 2, 3, 4, 5 
     * We don't care about numbers more than 5 
     */ 
    override def generateAction(): NumericString =&gt; Rating = _.toInt 
  } 
 
  val generateNumericRating = simpleRatingGenerator.generateAction() 
 
  println(generateNumericRating("1")) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">1 </pre>
<p class="calibre2">Here, <kbd class="calibre11">simpleRatingGenerator</kbd> is the <kbd class="calibre11">ActionGenerator</kbd><em class="calibre18">.</em> A few takeaway points from the implementation:</p>
<ul class="calibre7">
<li class="calibre8">Syntax, like <kbd class="calibre11">type Rating = Int</kbd>, is just to make code more readable. It enables the reader to think of <kbd class="calibre11">Rating</kbd> as a type that internally accepts <em class="calibre18">integers.</em> This is merely type declaration.</li>
<li class="calibre8">Our <kbd class="calibre11">simpleRatingGenerator</kbd> specifies from its definition that it can accept a <kbd class="calibre11">NumericString</kbd> and give a function that is of type <kbd class="calibre11">NumericString =&gt; Rating</kbd><em class="calibre18">.</em> We can view it as if <kbd class="calibre11">simpleRatingGenerator</kbd> is an <kbd class="calibre11">ActionGenerator</kbd> that provides a mechanism to generate a rating from <kbd class="calibre11">NumericString</kbd><em class="calibre18">.</em></li>
<li class="calibre8">Now, the way we can use such an action generator is to get the mechanism and pass a numeric string value to it to get the rating. That's how we do it:</li>
</ul>
<pre class="calibre19">val generateNumericRating = simpleRatingGenerator.genrateAction()<br class="title-page-name"/>println(generateNumericRating("1"))</pre>
<p class="calibre2">We can also create another rating generator that takes comments such as <kbd class="calibre11">Awesome</kbd><em class="calibre18">,</em> <kbd class="calibre11">Good</kbd><em class="calibre18">,</em> <kbd class="calibre11">Nice</kbd><em class="calibre18">, </em>and so on<em class="calibre18">.</em> Here is an example of how to create an <kbd class="calibre11">AlphanumericRatingGenerator</kbd> that can provide a mechanism to generate rating from <kbd class="calibre11">AlphanumericString</kbd>:</p>
<pre class="calibre19">val alphanumericRatingGenerator = new ActionGenerator[AlphaNumeric] { 
  type Out = AlphaNumeric =&gt; Rating 
 
 /* Times when ratings are Awesome, Super, Good, something else like Neutral 
  * Rating as 1, 2, 3, 4, 5 
  */ 
  override def generateAction(): AlphaNumeric =&gt; Rating = toRating// Some other mechanism to generate the rating 
} 
 
val toRating: AlphaNumeric =&gt; Rating = _ match { 
  case "Awesome" =&gt; 5 
  case "Cool"    =&gt; 4 
  case "Nice"    =&gt; 3 
  case "Worst Ever" =&gt; 1 
  case _ =&gt; 3 // No Comments then average rating. 
} 
 </pre>
<p class="calibre2">The way we can use this is the same way we used <kbd class="calibre11">simpleRatingGenerator</kbd>:</p>
<pre class="calibre19"> 
val generateAlphanumericRating = alphanumericRatingGenerator.generateAction() 
 
println(generateAlphanumericRating("Awesome")) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">5 </pre>
<p class="calibre2">So these ways can come in handy when we try to provide a simple interface to a consumer of our functionality. For example, if a person wants to see the rating based on the comments, he may not be interested in the complexity and only like to call a particular function.</p>
<p class="calibre2">Why you would want to try out stuff with these concepts such as type parameters and abstract types now makes more sense: to create abstractions such as <kbd class="calibre11">ActionGenerator</kbd><em class="calibre18">.</em> Life's easier when you have a set of rules already defined and you only have to code them. So with this, let's go ahead and try to make rules that are more precise. In other words, let's take a look at how we can define limits for using our parameterized type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type bounds</h1>
                
            
            <article>
                
<p class="calibre2">We've seen an example where we were allowed to create <kbd class="calibre11">AircraftSeat</kbd> for passengers. The example looked like the following:</p>
<pre class="calibre19">class AircraftSeat[-T] </pre>
<p class="calibre2">From what we know so far, <kbd class="calibre11">Aircraft</kbd> is contravariant in its type parameter <kbd class="calibre11">T</kbd>. But the thing is, when it comes to creating instances of <kbd class="calibre11">AircraftSeat</kbd><em class="calibre18">,</em> it can be created for any type of <kbd class="calibre11">T</kbd>. What's expected is that this type parameter can only be of the <kbd class="calibre11">Passengers</kbd> <span>type </span>or it's subtype. So to achieve that we can introduce a type bound, in our case we'll use an upper-type bound. The reason for this is because we want to specify the type that's on the top of the inheritance hierarchy, in our case it's <kbd class="calibre11">Passengers</kbd>.</p>
<p class="calibre2">It'll look as follows:</p>
<pre class="calibre19">  class AircraftSeat[-T &lt;: Passengers] </pre>
<p class="calibre2">Here, the notation <kbd class="calibre11"><em class="calibre18">&lt;:</em></kbd> specifies its <em class="calibre18">upper bound.</em> What does this do? Let's check out an example to understand it better:</p>
<pre class="calibre19">object Bounds extends App { 
 
   /* 
    * AircraftSeats can be consumed only by Passengers. 
    */ 
  class AircraftSeat[-T &lt;: Passengers] 
 
  def reserveSeatForCorporatePassengers(corporateSeats: AircraftSeat[CorporatePassengers]) = { 
    //Performs some logic regarding the seat reservation! 
    println(s"Seats Confirmed!") 
  } 
 
  val corporateSeat = new AircraftSeat[CorporatePassengers]() 
  val passengersSeat = new AircraftSeat[Passengers]() 
 
 
  reserveSeatForCorporatePassengers(new AircraftSeat[CorporatePassengers]()) 
 
  reserveSeatForCorporatePassengers(new AircraftSeat[Passengers]()) 
 
  abstract class Passengers 
  class CorporatePassengers extends Passengers 
  class RegularPassengers extends Passengers 
 
} </pre>
<p class="calibre2">Here, we have the same example we used earlier; the only thing different is that now we can only create <kbd class="calibre11">AircraftSeat</kbd> for the <kbd class="calibre11">Passengers</kbd> type. The code will work fine. But we would like to see the behavior for when we try to create an <kbd class="calibre11">AircraftSeat</kbd> instance with a type that's not a subtype of <kbd class="calibre11">Passengers</kbd><em class="calibre18">.</em> For that, let's create another class and try to create an <kbd class="calibre11">AircraftSeat</kbd> instance out of it:</p>
<pre class="calibre19">class Person(name: String) 
 
val seat: AircraftSeat[Person] = new AircraftSeat[Person]() </pre>
<p class="calibre2">If you try to compile code with this instance, the Scala compiler will throw an error at compile time. It says the following:</p>
<pre class="calibre19">type arguments [chapter10.Bounds.Person] do not conform to class AircraftSeat's type parameter bounds [-T &lt;: chapter10.Bounds.Passengers] 
 
  val seat: AircraftSeat[Person] = new AircraftSeat[Person]() </pre>
<p class="calibre2">From the error shown previously, it's clear that the compiler was able to understand what we specified and is not ready to take anything else other than <kbd class="calibre11">Passengers</kbd>.</p>
<p class="calibre2">Similarly, it's possible to specify a lower bound for our type parameters. We can use the sign <kbd class="calibre11">&gt;:</kbd> to specify lower bounds. It looks as follows:</p>
<pre class="calibre19">class ListLikeStructure[T &gt;: AnyRef] </pre>
<p class="calibre2">Here, we specified a <kbd class="calibre11">ListLikeStructure</kbd> for any reference types. It's special in the sense that it only takes <kbd class="calibre11">Any</kbd>, <kbd class="calibre11">AnyRef</kbd><em class="calibre18">,</em> or equivalent types in hierarchy<em class="calibre18">.</em> So let's try creating an instance of the same for <kbd class="calibre11">Any</kbd> and <kbd class="calibre11">AnyRef</kbd>. The Scala compiler will not complain about the code and will work fine for the following:</p>
<pre class="calibre19">new ListLikeStructure[Any]() 
new ListLikeStructure[AnyRef]() </pre>
<p class="calibre2">When we try to create the same instance with a different type to <kbd class="calibre11">Any</kbd> or <kbd class="calibre11">AnyRef</kbd>, the Scala compiler will give an error as follows:</p>
<pre class="calibre19">new ListLikeStructure[String]() 
Error:(30, 7) type arguments [String] do not conform to class ListLikeStructure's type parameter bounds [T &gt;: AnyRef] 
 
  new ListLikeStructure[String]() </pre>
<p class="calibre2">From this error, it's clear that the signature with a lower bound specified will not let you provide a type that comes lower in the type hierarchy. That's why we got an error for the <kbd class="calibre11">String</kbd> type. These are the ways we can provide lower and upper bounds in Scala. There's another way we can use both the bounds together to specify a specific range of types in the hierarchy.</p>
<p class="calibre2">Think of a class inheritance hierarchy as follows:</p>
<pre class="calibre19">abstract class Zero 
trait One extends Zero 
trait Two extends One 
trait Three extends Two 
trait Four extends Three </pre>
<p class="calibre2">For such a structure, a <kbd class="calibre11">ListLikeStructure</kbd> can be declared in the following way:</p>
<pre class="calibre19">class ListLikeStructure[T &gt;: Four &lt;: Two] </pre>
<p class="calibre2">It specifies you can only provide a type between <kbd class="calibre11">Two</kbd> and <kbd class="calibre11">Four</kbd>, so it's possible to create structures with the following types:</p>
<pre class="calibre19">new ListLikeStructure[Four] 
new ListLikeStructure[Three] 
new ListLikeStructure[Two] </pre>
<p class="calibre2">But once you try passing a type that's not in the bounds, the Scala compiler greets you with a compile time error:</p>
<pre class="calibre19">new ListLikeStructure[One] 
type arguments [chapter10.Bounds.One] do not conform to class ListLikeStructure's type parameter bounds [T &gt;: chapter10.Bounds.Four &lt;: chapter10.Bounds.Two] 
  new ListLikeStructure[One] </pre>
<p class="calibre2">As the error indicates, this instantiation does not satisfy the bounds. So now you are aware of the bounds for type parameters. In the same way, we can put bounds to abstract types as well:</p>
<pre class="calibre19">trait ThinkingInTermsOfT { 
      type T &lt;: Two 
} </pre>
<p class="calibre2">Here, as shown in the previous declaration, our type <kbd class="calibre11">T</kbd> can be instantiated with only types for which <kbd class="calibre11">Two</kbd> is the upper bound.</p>
<p class="calibre2">With the discussion of bounds and variance, the difference and the use cases of both are clear. It's good to point out again, that variance is merely the rules for inheritance relationships between parameterized/container types. Bounds only write a rule that states a certain range of types can be used to instantiate a type that is parameterized or contains an abstract member.</p>
<p class="calibre2">Now that we have an idea about parameterized types, abstract types, and ways to define them, we should also try and find out why we choose abstract types rather than parameterized types or vice versa.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract versus parameterized types</h1>
                
            
            <article>
                
<p class="calibre2">Both are forms of providing polymorphic abstractions in Scala. Mostly, it's a design choice whether you prefer one over the other. Talking about design choices, let's have a closer look. For that we'll take an example where we have two class hierarchies as follows:</p>
<pre class="calibre19">abstract class Food 
class Grass extends Food 
class Meat extends Food 
 
abstract class Animal { 
   type SuitableFood &lt;: Food 
   
   def eatMeal(meal: SuitableFood) 
} </pre>
<p class="calibre2">From the knowledge about abstract types and upper bounds we can say <kbd class="calibre11">Animal</kbd> is an abstract class, which has an abstract type member named <kbd class="calibre11">SuitableFood</kbd>, which expects only the <kbd class="calibre11">Food</kbd> type. If we declare two subtypes of <kbd class="calibre11">Animal</kbd> class namely <kbd class="calibre11">Cow</kbd> and <kbd class="calibre11">Lion</kbd> it could look like a cow can eat <kbd class="calibre11">Grass</kbd> as well as <kbd class="calibre11">Meat</kbd> because both are subclasses of <kbd class="calibre11">Food</kbd>. But this isn't the desired behavior. To resolve the issue, we can declare <kbd class="calibre11">Cow</kbd> like this:</p>
<pre class="calibre19">class Cow extends Animal { 
  type SuitableFood &lt;: Grass 
 
  override def eatMeal(meal: SuitableFood): Unit = println("Cow's eating grass!") 
 
} </pre>
<p class="calibre2">We have put a bound on the abstract type member <kbd class="calibre11">SuitableFood</kbd><em class="calibre18">.</em> Now, for any cow (instance), the type that we provide has to be of type <kbd class="calibre11">Grass</kbd> <em class="calibre18">(</em>and yes, we were allowed to put <em class="calibre18">Grass</em> only because it's a subtype of <kbd class="calibre11">Food</kbd><em class="calibre18">).</em> We can do the same for the <kbd class="calibre11">Lion</kbd> class:</p>
<pre class="calibre19">class Lion extends Animal { 
  type SuitableFood &lt;: Meat 
 
  override def eatMeal(meal: SuitableFood): Unit = println("Lion's eating meat!") 
} </pre>
<p class="calibre2">When we try using these classes, we'll have to provide the intended concrete types. Let's take a look at the app:</p>
<pre class="calibre19">object AbsVsParamTypes extends App { 
 
  abstract class Animal { 
     type SuitableFood &lt;: Food 
 
     def eatMeal(meal: SuitableFood) 
  } 
 
  class Lion extends Animal { 
    type SuitableFood &lt;: Meat 
 
    override def eatMeal(meal: SuitableFood): Unit = println("Lion's eating meat!") 
  } 
 
  class Cow extends Animal { 
    type SuitableFood &lt;: Grass 
 
    override def eatMeal(meal: SuitableFood): Unit = println("Cow's eating grass!") 
  } 
 
  val lion = new Lion(){ 
    type SuitableFood = Meat 
  } 
 
  val cow = new Cow(){ 
    type SuitableFood = Grass 
  } 
 
  cow.eatMeal(new Grass) 
  lion.eatMeal(new Meat) 
 
 
  abstract class Food 
  class Grass extends Food 
  class Meat extends Food 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Cow's eating grass! 
Lion's eating meat! </pre>
<p class="calibre2">So, as shown, we can create a cow instance by providing a type that satisfies the bounds specified. These kinds of requirements are best written using abstract types. When you need to provide a type with a parameter, just for instantiation, examples are <kbd class="calibre11">List[String]</kbd> or similar types. When using the same type to evolve as you write/define members of your class/trait, it's better to consider abstract types.</p>
<p class="calibre2">Now that we've discussed <em class="calibre18">abstract versus parameterized types</em>, let's talk about one more concept that you will encounter often when working with Scala. We'll talk a bit about type-classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type-classes</h1>
                
            
            <article>
                
<p class="calibre2">Why would someone need a concept such as a type-class? To answer this, we'll first have to understand what a type-class exactly is. As they say, "<em class="calibre18">Type-classes allow us to generalize over a set of types in order to define and execute a standard set of features for those types."</em> Let's try to understand this.</p>
<p class="calibre2">I believe you're aware of the notion of encoding and decoding. Let's think of encoding as applying a certain rule to convert A into a specific pattern. Now, after you encode something, it's in that specific pattern. Decoding is the exact opposite of what we just did: it's changing your type A from the pattern we just created to its original shape. For example, <strong class="calibre1">comma-separated values</strong> (<strong class="calibre1">CSV</strong>) can be considered an encoded pattern. Hence, there's a scheme that converts words from a source to CSV format:</p>
<pre class="calibre19">trait CSVEncoder[T] { 
  def encode(t: T): List[String] 
} </pre>
<p class="calibre2">We've written a <em class="calibre18">trait</em> named <kbd class="calibre11">CSVEncoder[T]</kbd>. It's time to rephrase what we said for type-classes. <kbd class="calibre11">CSVEncoder</kbd> allows us to generalize over type <kbd class="calibre11">T</kbd> in order to provide an encoding mechanism for the same type. This means that we can use <kbd class="calibre11">CSVEncoder</kbd> for all the types we want and use them whenever there's a need. This is the implementation of a type-class. We'll go through the overall type-class implementation in the next chapter after the discussion of implicits. For now, it's good to know what a concept such as type-class does.</p>
<p class="calibre2">With the conception of type-classes, it's time to summarize what we have learned in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">From understanding the basic need of types to understanding what a type-class is, we've gone through it all. Along the way, we discussed parametric polymorphism using parametric types and abstract types. With the concept of variance, as well as bounds, we've gone through it all and now it's a bit clearer. For more insights, practice is a must. We can think of scenarios to learn about the concepts. We tried to go through the concepts as they were and look at a few examples, but it'll definitely be fun if you try out some of these on your own. This chapter was the formation or the basis of real Scala programming. Concepts such as type-classes come in very handy when writing effective programs.</p>
<p class="calibre2">In the next chapter, we'll go through concepts such as <em class="calibre18">implicits</em> and the ways we can do exception handling in Scala. And of course, we'll play with type-classes.</p>


            </article>

            
        </section>
    </body></html>