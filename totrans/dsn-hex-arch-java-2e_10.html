<html><head></head><body>
<div id="_idContainer074">
<h1 class="chapter-number" id="_idParaDest-166"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-167"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.2.1">Adding Quarkus to a Modularized Hexagonal Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">This chapter will expand our horizons by exploring the concepts and technologies to turn our hexagonal application into a cloud-native one. </span><span class="koboSpan" id="kobo.3.2">To support us in our journey to the cloud, we have Quarkus as the key technology, which is a prominent Java cloud-native framework. </span><span class="koboSpan" id="kobo.3.3">To understand Quarkus and learn how to leverage its features to enhance a hexagonal system, we need to revisit some fundamental knowledge related to the inner workings of the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Java Virtual Machine</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">JVM</span></strong><span class="koboSpan" id="kobo.7.1">). </span><span class="koboSpan" id="kobo.7.2">By understanding the main JVM characteristics and how they work, we can better understand the problems Quarkus aims </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, we’ll also conduct a brief tour of Quarkus’s main features to get an idea of what we can do with such a fine piece of software. </span><span class="koboSpan" id="kobo.9.2">Once we’re acquainted with Quarkus, we’ll take our first step in transforming our hexagonal system into a cloud-native one. </span><span class="koboSpan" id="kobo.9.3">To accomplish that, we’ll create a brand-new Java module and configure </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Quarkus dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">These are the topics that we’ll cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Revisiting </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">the JVM</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Introducing Quarkus</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Adding Quarkus to a modularized </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">hexagonal application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.18.1">By the end of this chapter, you’ll know how to configure Quarkus to work with a hexagonal application. </span><span class="koboSpan" id="kobo.18.2">That’s the first step in preparing a system to receive all the cloud-native features that Quarkus has </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">to offer.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.20.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.21.1">To compile and run the code examples presented in this chapter, you need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">Java Standard Edition (SE) Development Kit</span></strong><span class="koboSpan" id="kobo.23.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.25.1"> installed on your computer. </span><span class="koboSpan" id="kobo.25.2">They are all available for Linux, Mac, and Windows operating systems. </span><span class="koboSpan" id="kobo.25.3">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.28.1">.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.29.1">Revisiting the JVM</span></h1>
<p><span class="koboSpan" id="kobo.30.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">Virtual Machine</span></strong><span class="koboSpan" id="kobo.32.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.33.1">VM</span></strong><span class="koboSpan" id="kobo.34.1">) concept wasn’t something</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.35.1"> new when Java arrived back in 1995. </span><span class="koboSpan" id="kobo.35.2">Before that time, many other languages used VMs, although they weren’t so popular among developers. </span><span class="koboSpan" id="kobo.35.3">Java architects decided to use VMs because they wanted a mechanism to create platform independence to improve </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">developer productivity.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">Before elaborating on the VM concept, let’s first check what we can run inside a VM for Java. </span><span class="koboSpan" id="kobo.37.2">In languages such as C or C++, we compile source code into native code tailored for a specific operating system and CPU architecture. </span><span class="koboSpan" id="kobo.37.3">When programming in Java, we compile the source code into bytecode. </span><span class="koboSpan" id="kobo.37.4">The JVM understands the instructions contained </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">in bytecode.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">The VM idea comes from the concept of running programs in an intermediate or virtual environment sitting atop a real machine. </span><span class="koboSpan" id="kobo.39.2">In such an arrangement, the program does not need to communicate directly with the underlying operating system – the program deals only with a VM. </span><span class="koboSpan" id="kobo.39.3">The VM then converts bytecode instructions into </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">native-code ones.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">We can express one of the JVM’s advantages with a well-known Java motto – </span><em class="italic"><span class="koboSpan" id="kobo.42.1">write once, run anywhere</span></em><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">Back in the day, and I think even now, it was very appealing to use a language that allowed you to develop software that, without recompilation, could run on different operating systems and CPU architectures. </span><span class="koboSpan" id="kobo.43.3">For other languages such as C++, you’d need to adjust your code for every targeted operating system and CPU architecture, prompting more effort to make your program compatible with </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">different platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In today’s world of cloud computing, we have services such as Docker and Kubernetes that make software units more portable than ever. </span><span class="koboSpan" id="kobo.45.2">To achieve portability in Java, we have the prerogative to execute the same compiled bytecode into different JVMs running on different operating systems and CPU architectures. </span><span class="koboSpan" id="kobo.45.3">Portability is possible because every JVM implementation must comply with the JVM specification, no matter where or how </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">it’s implemented.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">Conversely, we can use container virtualization to achieve portability by packing the compiled software with its runtime environment and dependencies into a container image. </span><span class="koboSpan" id="kobo.47.2">A container engine running on different operating systems and CPU architectures can create containers based on </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">container images.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">The JVM’s appeal in</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.50.1"> making portable software at the expense of converting bytecode into native code is no longer attractive when you have faster and cheaper alternatives. </span><span class="koboSpan" id="kobo.50.2">Today, you can pack your application – without the need for a JVM and also recompilation – into a Docker image and distribute it across different operating systems and CPU architectures. </span><span class="koboSpan" id="kobo.50.3">However, we should not forget how robust and time-tested a piece of software such as the JVM is. </span><span class="koboSpan" id="kobo.50.4">We’ll return to our discussion on Docker and Kubernetes soon, but for now, let’s examine some more interesting </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">JVM characteristics.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Another important JVM aspect is related to memory management. </span><span class="koboSpan" id="kobo.52.2">With Java, a developer doesn’t need to worry about how the program deals with memory release and allocation. </span><span class="koboSpan" id="kobo.52.3">Such responsibility is transferred to the JVM, so the developer can focus more on their program’s functional details than on the technical ones. </span><span class="koboSpan" id="kobo.52.4">Ask any C++ developer how much fun it is to debug memory leaks on </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">large systems.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">The feature responsible for managing memory</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.55.1"> inside the JVM is called a </span><strong class="bold"><span class="koboSpan" id="kobo.56.1">garbage collector</span></strong><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Its purpose is to automatically check when an object is no longer used or referenced so that the program can free the unused memory. </span><span class="koboSpan" id="kobo.57.3">A JVM can use algorithms that trace object references and mark for releasing those that no longer reference any object. </span><span class="koboSpan" id="kobo.57.4">Different </span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.58.1">garbage collector algorithms exist, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Concurrent Mark and Sweep</span></strong><span class="koboSpan" id="kobo.60.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.61.1">CMS</span></strong><span class="koboSpan" id="kobo.62.1">) and the </span><strong class="bold"><span class="koboSpan" id="kobo.63.1">Garbage First Garbage Collector</span></strong><span class="koboSpan" id="kobo.64.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">G1 GC</span></strong><span class="koboSpan" id="kobo.66.1">). </span><span class="koboSpan" id="kobo.66.2">Since the JDK7 Update 4, the G1 GC has superseded the CMS due to its emphasis </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.67.1">on first identifying and releasing the mostly empty Java object heap regions, making more memory available, and doing it faster than the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">CMS approach.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Garbage collectors are not required to exist in every JVM implementation, but as long as memory resources remain a constraint in computation, we’ll often see JVM implementations with </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">garbage collectors.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">JVM is also in charge of the whole life cycle of an application. </span><span class="koboSpan" id="kobo.71.2">It all starts with the loading of a Java class file into the VM. </span><span class="koboSpan" id="kobo.71.3">When we compile a Java source file, the compiler generates a Java class file containing bytecode. </span><span class="koboSpan" id="kobo.71.4">Bytecode is a format recognizable by the JVM. </span><span class="koboSpan" id="kobo.71.5">A VM’s primary goal is to load and process this bytecode through algorithms and data structures that</span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.72.1"> implement and respect a </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">JVM specification.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">The following diagram illustrates what it takes to execute a </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">Java program:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.76.1"><img alt="Figure 10.1 – Java compilation and class loading on JVM" src="image/B19777_10_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.77.1">Figure 10.1 – Java compilation and class loading on JVM</span></p>
<p><span class="koboSpan" id="kobo.78.1">It all starts with the Java source code file that is compiled into a Java class file (bytecode) by the Java compiler. </span><span class="koboSpan" id="kobo.78.2">This bytecode is read by the JVM and translated into instructions that are understood by the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.79.1">native OS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">This bytecode thing has been an object of relentless work for people trying to find faster ways to deal </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">with it.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">As time went on, the JVM received good improvements and enhanced techniques that considerably improved the </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.84.1">bytecode loading performance. </span><span class="koboSpan" id="kobo.84.2">Among these techniques, we </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.85.1">can quote </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">Just-in-Time</span></strong><span class="koboSpan" id="kobo.87.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.88.1">JIT</span></strong><span class="koboSpan" id="kobo.89.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">Ahead-of-Time</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.92.1">AOT</span></strong><span class="koboSpan" id="kobo.93.1">) compilations. </span><span class="koboSpan" id="kobo.93.2">Let’s examine both </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">of them.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.95.1">Speeding up runtime performance with JIT compilation</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.96.1">JIT compilers</span></strong><span class="koboSpan" id="kobo.97.1"> arose from the idea that </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.98.1">certain program instructions can be optimized for better performance while a program is running. </span><span class="koboSpan" id="kobo.98.2">So, to accomplish such optimization, the JIT compiler seeks program instructions with the potential to be optimized. </span><span class="koboSpan" id="kobo.98.3">In general, these instructions</span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.99.1"> are the ones most executed by </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">the program.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Because these instructions are executed so often, they consume a significant amount of computer time and resources. </span><span class="koboSpan" id="kobo.101.2">Remember that these instructions are in the bytecode format. </span><span class="koboSpan" id="kobo.101.3">A traditional compiler would compile all the bytecode into native code before running the program. </span><span class="koboSpan" id="kobo.101.4">With a JIT compiler, things are different, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.103.1"><img alt="Figure 10.2 – How JIT works" src="image/B19777_10_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.104.1">Figure 10.2 – How JIT works</span></p>
<p><span class="koboSpan" id="kobo.105.1">A JIT compiler selects, by using its dynamic optimization algorithms, some parts of the bytecode. </span><span class="koboSpan" id="kobo.105.2">Then, it compiles and applies optimizations to these bytecode parts. </span><span class="koboSpan" id="kobo.105.3">The result is optimized native code that is tweaked to provide better performance for the system. </span><span class="koboSpan" id="kobo.105.4">The term </span><em class="italic"><span class="koboSpan" id="kobo.106.1">JIT</span></em><span class="koboSpan" id="kobo.107.1"> is used because the optimizations are made right before the code </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">is executed.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">However, there is no such thing as a free lunch when using JIT compilers. </span><span class="koboSpan" id="kobo.109.2">One of the most well-known drawbacks</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.110.1"> of JIT compilers is the increased startup time of an application because of the initial optimizations a JIT compiler does before running the program. </span><span class="koboSpan" id="kobo.110.2">In order to overcome this startup problem, there is another technique called AOT compilation. </span><span class="koboSpan" id="kobo.110.3">Various </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.111.1">cloud-native frameworks, including Quarkus, have used this technique. </span><span class="koboSpan" id="kobo.111.2">Let’s see how AOT </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">compilation works.</span></span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.113.1">Improving startup time with AOT compilation</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.114.1">AOT</span></strong><span class="koboSpan" id="kobo.115.1"> is so appealing on the</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.116.1"> Java scene because traditional Java systems – mainly those based on enterprise application servers such as </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">JBoss</span></strong><span class="koboSpan" id="kobo.118.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">WebLogic</span></strong><span class="koboSpan" id="kobo.120.1"> – take too </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.121.1">much time to initiate. </span><span class="koboSpan" id="kobo.121.2">In addition to slower startup times, we</span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.122.1"> have to consider the amount of computer power</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.123.1"> those application servers consume. </span><span class="koboSpan" id="kobo.123.2">These characteristics are a deal-breaker for anyone who wants to migrate Java workloads to the cloud, where instances and Kubernetes Pods are brought up and down frantically. </span><span class="koboSpan" id="kobo.123.3">So, by employing AOT in Java, we give up the cross-platform capability provided by the JVM and its bytecode for a better performance provided by AOT and its native code. </span><span class="koboSpan" id="kobo.123.4">The cross-platform problem is mitigated to some extent with the usage of container technologies such as Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">and Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Here, we have a representation showing how straightforward the AOT compilation process is to transform Java bytecode into </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.126.1">m</span></strong></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.127.1">achine code</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.129.1"><img alt="Figure 10.3 – How AOT works" src="image/B19777_10_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.130.1">Figure 10.3 – How AOT works</span></p>
<p><span class="koboSpan" id="kobo.131.1">Not everything is an advantage with AOT in Java. </span><span class="koboSpan" id="kobo.131.2">An AOT compiler spends more time generating a native binary than a Java compiler needs to create bytecode classes. </span><span class="koboSpan" id="kobo.131.3">So, AOT compilation can have a considerable impact on </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Continuos Integration</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">CI</span></strong><span class="koboSpan" id="kobo.135.1">) pipelines. </span><span class="koboSpan" id="kobo.135.2">Also, the developer needs to do some</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.136.1"> additional work to get things working properly to use reflection. </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">GraalVM</span></strong><span class="koboSpan" id="kobo.138.1"> is the AOT compiler used to provide a native binary</span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.139.1"> for Java and other </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">JVM-based languages.</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">With Quarkus, we have the prerogative to create applications using either JIT or AOT compilation methods. </span><span class="koboSpan" id="kobo.141.2">It’s</span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.142.1"> up to us to decide </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.143.1">which technique suits our </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">needs better.</span></span></p>
<p><span class="koboSpan" id="kobo.145.1">In this section, we gained some background knowledge about the inner workings of the JVM and how it tries to improve bytecode loading with JIT and AOT compilation. </span><span class="koboSpan" id="kobo.145.2">Such knowledge is important to understand how Quarkus works under the hood and achieves considerable </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">performance improvements.</span></span></p>
<p><span class="koboSpan" id="kobo.147.1">Now that we are acquainted with some JVM fundamentals and essential compilation techniques, let’s dive in and learn more about Quarkus’ </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">main features.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.149.1">Introducing Quarkus</span></h1>
<p><span class="koboSpan" id="kobo.150.1">If you develop enterprise Java</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.151.1"> applications, you have already worked with Spring Boot. </span><span class="koboSpan" id="kobo.151.2">Time-tested and widely used in the industry, Spring Boot is a robust piece of software with a vibrant community. </span><span class="koboSpan" id="kobo.151.3">Its libraries increase developed productivity by providing out-of-the-box solutions for security, persistence, APIs, and many more things that a typical enterprise application requires. </span><span class="koboSpan" id="kobo.151.4">You may wonder why this book does not discuss Spring Boot but Quarkus. </span><span class="koboSpan" id="kobo.151.5">There are two reasons. </span><span class="koboSpan" id="kobo.151.6">First, more material is available covering Spring Boot than Quarkus, which is understandable, as Spring Boot has been around longer and has a bigger community. </span><span class="koboSpan" id="kobo.151.7">The second reason is that Quarkus was built with cloud-native development at its core, while Spring Boot has been adapted to it. </span><span class="koboSpan" id="kobo.151.8">And since this book focuses on cloud-native development with hexagonal architecture, Quarkus was chosen because it is a </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">cloud-first framework.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">Focused on performance, Quarkus comes with built-in support for native executables based on GraalVM, making it possible to achieve swift </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">startup times.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">To attract developers, it offers valuable things such as live development, a feature that enhances productivity by avoiding the need to restart an application whenever something changes in </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Targeting cloud-native environments, Quarkus comes equipped with the proper tooling, allowing you to deal with constraints and leverage the benefits that come when developing software to </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.158.1">run on container-based environments, such </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">as Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Borrowing good ideas from enterprise development, Quarkus is built on top of well-established standards</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.161.1"> such as the </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">Contexts and Dependency Injection</span></strong><span class="koboSpan" id="kobo.163.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.164.1">CDI</span></strong><span class="koboSpan" id="kobo.165.1">) framework, the </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">Jakarta Persistence API</span></strong><span class="koboSpan" id="kobo.167.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.168.1">JPA</span></strong><span class="koboSpan" id="kobo.169.1">) specification with Hibernate ORM</span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.170.1"> implementation, and the </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Jakarta RESTful Web Services</span></strong><span class="koboSpan" id="kobo.172.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.173.1">JAX-RS</span></strong><span class="koboSpan" id="kobo.174.1">) specification </span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.175.1">implemented by RESTEasy. </span><span class="koboSpan" id="kobo.175.2">For those immersed in the Java </span><strong class="bold"><span class="koboSpan" id="kobo.176.1">Enterprise Edition</span></strong><span class="koboSpan" id="kobo.177.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.178.1">EE</span></strong><span class="koboSpan" id="kobo.179.1">) world, this means the learning curve to master Quarkus is shallow because much of their already acquired enterprise development knowledge can be reused to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">Quarkus applications.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Created by Red Hat, Quarkus sets itself apart from its competitors by being a software development framework designed from scratch to deal with cloud technologies. </span><span class="koboSpan" id="kobo.181.2">Contrary to other more aged frameworks that bring boilerplate code and features from an older era, Quarkus presents itself as a fresh and modern piece </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">of software.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Built upon other well-established open source projects, Quarkus is the cloud-native framework we’ll use to prepare our hexagonal system for the cloud. </span><span class="koboSpan" id="kobo.183.2">Before that, though, we’ll explore some of the main features this framework provides. </span><span class="koboSpan" id="kobo.183.3">Let’s get started by looking first at how to create REST endpoints </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">with Quarkus.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.185.1">Creating REST endpoints with JAX-RS</span></h2>
<p><span class="koboSpan" id="kobo.186.1">It’s very straightforward to create REST endpoints using Quarkus. </span><span class="koboSpan" id="kobo.186.2">In order to do so, the framework relies </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.187.1">on a JAX-RS implementation called RESTEasy. </span><span class="koboSpan" id="kobo.187.2">This</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.188.1"> implementation is available in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">Maven dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy&lt;/artifactId&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.191.1">Look at the following example, which shows how to use RESTEasy to create </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">REST services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.193.1">
package dev.davivieira.bootstrap.samples;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
@Path("/app")
public class RestExample {
    @GET
    @Path("/simple-rest")
    @Produces(MediaType.TEXT_PLAIN)
    public String simpleRest() {
        return "This REST endpoint is provided by Quarkus";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.194.1">We set the endpoint </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.195.1">address with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">@Path</span></strong><span class="koboSpan" id="kobo.197.1"> annotation. </span><span class="koboSpan" id="kobo.197.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">@GET</span></strong><span class="koboSpan" id="kobo.199.1">, we set the HTTP method supported by that endpoint. </span><span class="koboSpan" id="kobo.199.2">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">@Produces</span></strong><span class="koboSpan" id="kobo.201.1">, we define the</span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.202.1"> return type for </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the request.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In this same </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">RestExample</span></strong><span class="koboSpan" id="kobo.206.1"> class, we can inject dependencies to be used together with the REST endpoints. </span><span class="koboSpan" id="kobo.206.2">Let’s see how to </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">accomplish this.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.208.1">Employing dependency injection with Quarkus DI</span></h2>
<p><span class="koboSpan" id="kobo.209.1">Quarkus has its own dependency injection </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.210.1">mechanism based on </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">Quarkus ArC</span></strong><span class="koboSpan" id="kobo.212.1">, which, in turn, comes from the CDI specification, which has its roots back in </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">Java EE 6</span></strong><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">With CDI, we no</span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.215.1"> longer need to </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.216.1">control the creation and life cycle</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.217.1"> of dependency objects we provide to a system. </span><span class="koboSpan" id="kobo.217.2">Without a dependency injection framework, you have to create objects </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">this way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
BeanExample beanExample = new BeanExample();</span></pre> <p><span class="koboSpan" id="kobo.220.1">When using CDI, you just have to annotate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">class</span></strong><span class="koboSpan" id="kobo.222.1"> attribute with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">@Inject</span></strong><span class="koboSpan" id="kobo.224.1"> annotation, </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">
@Inject
BeanExample beanExample</span></pre> <p><span class="koboSpan" id="kobo.227.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">@Inject</span></strong><span class="koboSpan" id="kobo.229.1"> annotation to work, we first need to declare the dependency as a managed bean. </span><span class="koboSpan" id="kobo.229.2">Take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">example here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
package dev.davivieira.bootstrap.samples;
import javax.enterprise.context.ApplicationScoped;
import javax.validation.Valid;
@ApplicationScoped
public class BeanExample {
    public String simpleBean() {
        return "This is a simple bean";
    }
}</span></pre> <p><span class="koboSpan" id="kobo.232.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">@ApplicationScoped</span></strong><span class="koboSpan" id="kobo.234.1"> annotation states that this bean will be available as long as the application is not terminated. </span><span class="koboSpan" id="kobo.234.2">Also, this bean is accessible from different requests and calls across the entire </span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.235.1">system. </span><span class="koboSpan" id="kobo.235.2">Let’s update our </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">RestExample</span></strong><span class="koboSpan" id="kobo.237.1"> to inject this bean, </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
package dev.davivieira.bootstrap.samples;
import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
@Path("/app")
public class RestExample {
    @Inject
    BeanExample beanExample;
    /** Code omitted **/
    @GET
    @Path("/simple-bean")
    @Produces(MediaType.TEXT_PLAIN)
    public String simpleBean() {
        return beanExample.simpleBean();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.240.1">Right at the top, we</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.241.1"> inject the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">BeanExample</span></strong><span class="koboSpan" id="kobo.243.1"> dependency with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">@Inject</span></strong><span class="koboSpan" id="kobo.245.1"> annotation. </span><span class="koboSpan" id="kobo.245.2">Then, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">simpleBean</span></strong><span class="koboSpan" id="kobo.247.1"> method from the injected </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">BeanExample</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1"> dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">Next, let’s see how to validate</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.251.1"> objects that are created when the system receives an </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">HTTP request.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.253.1">Validating objects</span></h2>
<p><span class="koboSpan" id="kobo.254.1">We learned how to</span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.255.1"> create REST endpoints and also how to inject dependencies in the application. </span><em class="italic"><span class="koboSpan" id="kobo.256.1">But how about object validation?</span></em> <em class="italic"><span class="koboSpan" id="kobo.257.1">How can we ensure that the data provided by a given request is valid?</span></em><span class="koboSpan" id="kobo.258.1"> Quarkus can help us in that matter. </span><span class="koboSpan" id="kobo.258.2">The Quarkus validation mechanism is available in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">Maven dependency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-hibernate-validator&lt;/artifactId&gt;
&lt;/dependency&gt;</span></pre> <p><span class="koboSpan" id="kobo.261.1">The Quarkus validation mechanism is </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.262.1">based on </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.263.1">Hibernate Validator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">To see how it works, let’s first create a sample object containing the fields we expect in a request, </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
package dev.davivieira.bootstrap.samples;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
public class SampleObject {
    @NotBlank(message = "The field cannot be empty")
    public String field;
    @Min(message = "The minimum value is 10", value = 10)
    public int value;
}</span></pre> <p><span class="koboSpan" id="kobo.268.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">@NotBlank</span></strong><span class="koboSpan" id="kobo.270.1"> annotation, we state that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">field</span></strong><span class="koboSpan" id="kobo.272.1"> variable should never be empty. </span><span class="koboSpan" id="kobo.272.2">Then, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">@Min</span></strong><span class="koboSpan" id="kobo.274.1"> annotation, we ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">value</span></strong><span class="koboSpan" id="kobo.276.1"> variable should always contain a number equal to or higher than </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">10</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">Let’s return to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">RestExample</span></strong><span class="koboSpan" id="kobo.280.1"> class and create a new</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.281.1"> REST endpoint to validate the request, </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
@POST
@Path("/request-validation")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result validation(@Valid SampleObject sampleObject) {
    try {
        return new Result("The request data is valid!");
    } catch (ConstraintViolationException e) {
        return new Result(e.getConstraintViolations());
    }
}</span></pre> <p><span class="koboSpan" id="kobo.284.1">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ConstraintViolationException</span></strong><span class="koboSpan" id="kobo.286.1"> is caught, the system returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">HTTP 400 Bad Request</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.288.1">failure response.</span></span></p>
<p><span class="koboSpan" id="kobo.289.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">@Valid</span></strong><span class="koboSpan" id="kobo.291.1"> annotation just before </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">SampleObject</span></strong><span class="koboSpan" id="kobo.293.1">. </span><span class="koboSpan" id="kobo.293.2">By using that annotation, we trigger a validation check whenever a request hits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">/app/request-validation</span></strong><span class="koboSpan" id="kobo.295.1"> endpoint. </span><span class="koboSpan" id="kobo.295.2">Check out the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">following results:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.297.1">
$ curl -H "Content-Type: application/json"  -d '{"field": "", "value": 10}' localhost:8080/app/request-validation | jq
{
  "exception": null,
  "propertyViolations": [],
  "classViolations": [],
  "parameterViolations": [
    {
      "constraintType": "PARAMETER",
      "path": "validation.arg0.field",
      "message": "The field cannot be empty",
      "value": ""
    }
  ],
  "returnValueViolations": []
}</span></pre> <p><span class="koboSpan" id="kobo.298.1">In the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">POST</span></strong><span class="koboSpan" id="kobo.300.1"> request, the</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.301.1"> field is empty, which results in a failure response with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">HTTP 400 Bad </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Request</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> code.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">In the next request, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">value</span></strong><span class="koboSpan" id="kobo.307.1"> to a number less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">10</span></strong><span class="koboSpan" id="kobo.309.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.311.1">
$ curl -s -H "Content-Type: application/json"  -d '{"field": "test", "value": 9}' localhost:8080/app/request-validation | jq
{
  "exception": null,
  "propertyViolations": [],
  "classViolations": [],
  "parameterViolations": [
    {
      "constraintType": "PARAMETER",
      "path": "validation.arg0.value",
      "message": "The minimum value is 10",
      "value": "9"
    }
  ],
  "returnValueViolations": []
}</span></pre> <p><span class="koboSpan" id="kobo.312.1">Again, the constraint was violated, and the result showed that the validation had failed. </span><span class="koboSpan" id="kobo.312.2">The failure was caused because we sent the number </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">9</span></strong><span class="koboSpan" id="kobo.314.1">, and the minimum value accepted </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.318.1">Here is a proper </span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.319.1">request with </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">valid data:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.321.1">
$ curl -s -H "Content-Type: application/json"  -d '{"field": "test", "value": 10}' localhost:8080/app/request-validation | jq
{
  "message": "The request data is valid!",
  "success": true
}</span></pre> <p><span class="koboSpan" id="kobo.322.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">field</span></strong><span class="koboSpan" id="kobo.324.1"> parameter is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">null</span></strong><span class="koboSpan" id="kobo.326.1">, nor is </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">value</span></strong><span class="koboSpan" id="kobo.328.1"> less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">10</span></strong><span class="koboSpan" id="kobo.330.1">. </span><span class="koboSpan" id="kobo.330.2">So, the request returns a </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">valid response.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.332.1">Configuring a data source and using Hibernate ORM</span></h2>
<p><span class="koboSpan" id="kobo.333.1">Quarkus allows you to connect to a data source in two ways. </span><span class="koboSpan" id="kobo.333.2">The first and traditional way is based on a JDBC </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.334.1">connection. </span><span class="koboSpan" id="kobo.334.2">To connect using this method, you need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">agroal</span></strong><span class="koboSpan" id="kobo.336.1"> library and the JDBC driver of the specific database type you want to connect. </span><span class="koboSpan" id="kobo.336.2">The</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.337.1"> second – and reactive – way allows you to treat the database connection like a stream of data. </span><span class="koboSpan" id="kobo.337.2">For that mode, you need </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">Vert.x</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.339.1">reactive drivers.</span></span></p>
<p><span class="koboSpan" id="kobo.340.1">In the following steps, we’ll set up a data source connection using the traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">JDBC method:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.342.1">To get started, we need the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following dependencies:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-agroal&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-jdbc-h2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
  &lt;artifactId&gt;quarkus-hibernate-orm&lt;/artifactId&gt;
&lt;/dependency&gt;</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">quarkus-hibernate-orm</span></strong><span class="koboSpan" id="kobo.346.1"> refers to</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.347.1"> the Hibernate ORM implementation of JPA. </span><span class="koboSpan" id="kobo.347.2">It is this dependency</span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.348.1"> that provides the capability to map Java objects to </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">database entities.</span></span></p></li> <li><span class="koboSpan" id="kobo.350.1">Next, we need to configure the data source settings in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">application.properties</span></strong><span class="koboSpan" id="kobo.352.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.354.1">
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:mem:de
  fault;DB_CLOSE_DELAY=-1
quarkus.hibernate-orm.dialect=org.hibernate.dia
  lect.H2Dialect
quarkus.hibernate-orm.database.generation=drop-and-
  create</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">quarkus.datasource.db-kind</span></strong><span class="koboSpan" id="kobo.356.1"> is optional, but we use that to emphasize that the application uses an H2 in-memory database. </span><span class="koboSpan" id="kobo.356.2">We use </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">quarkus.datasource.jdbc.url</span></strong><span class="koboSpan" id="kobo.358.1"> to inform the connection string. </span><span class="koboSpan" id="kobo.358.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">quarkus.hibernate-orm.dialect</span></strong><span class="koboSpan" id="kobo.360.1"> option sets the dialect used for the data source communication, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">quarkus.hibernate-orm.database.generation=drop-and-create</span></strong><span class="koboSpan" id="kobo.362.1"> forces the creation of a database structure </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">at startup.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.364.1">If there is an </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">import.sql</span></strong><span class="koboSpan" id="kobo.366.1"> file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">classpath</span></strong><span class="koboSpan" id="kobo.368.1">, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">drop-and-create</span></strong><span class="koboSpan" id="kobo.370.1"> option enables the use of that file to load data into the database. </span><span class="koboSpan" id="kobo.370.2">Something very interesting about</span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.371.1"> this </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">drop-and-create</span></strong><span class="koboSpan" id="kobo.373.1"> option is that every change on application entities </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.374.1">or in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">import.sql</span></strong><span class="koboSpan" id="kobo.376.1"> file is picked automatically and applied to the database without restarting the system. </span><span class="koboSpan" id="kobo.376.2">For this to work, a system needs to run in live </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">development mode.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.378.1">Let’s create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">SampleEntity</span></strong><span class="koboSpan" id="kobo.380.1"> class to persist in the database, </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
@Entity
@NamedQuery(name = "SampleEntity.findAll",
        query = "SELECT f FROM SampleEntity f ORDER BY
          f.field",
        hints = @QueryHint(name =
          "org.hibernate.cacheable",
        value = "true") )
public class SampleEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    @Getter
    @Setter
    private String field;
    @Getter
    @Setter
    private int value;
}</span></pre> <p><span class="koboSpan" id="kobo.383.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">SampleEntity</span></strong><span class="koboSpan" id="kobo.385.1"> class corresponds to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">SampleObject</span></strong><span class="koboSpan" id="kobo.387.1"> class we created earlier. </span><span class="koboSpan" id="kobo.387.2">The requirement to use</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.388.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">SampleEntity</span></strong><span class="koboSpan" id="kobo.390.1"> class as a database entity is to annotate it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">@Entity</span></strong><span class="koboSpan" id="kobo.392.1"> annotation. </span><span class="koboSpan" id="kobo.392.2">Following that annotation, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">@NamedQuery</span></strong><span class="koboSpan" id="kobo.394.1">, which we’ll</span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.395.1"> use later to retrieve all entities from the database. </span><span class="koboSpan" id="kobo.395.2">To automatically generate ID values, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">GenerationType.AUTO</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">field</span></strong><span class="koboSpan" id="kobo.399.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">value</span></strong><span class="koboSpan" id="kobo.401.1"> variables from </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">SampleEntity</span></strong><span class="koboSpan" id="kobo.403.1"> are mapped to the same variables that exist in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">SampleObject</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.405.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">Let’s now create a new bean called </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">PersistenceExample</span></strong><span class="koboSpan" id="kobo.408.1"> to assist us in creating and retrieving database entities. </span><span class="koboSpan" id="kobo.408.2">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
package dev.davivieira.bootstrap.samples;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.transaction.Transactional;
import java.util.List;
@ApplicationScoped
public class PersistenceExample {
    @Inject
    EntityManager em;
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.411.1">To interact with the database, the first thing we have to do is to inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">EntityManager</span></strong><span class="koboSpan" id="kobo.413.1">. </span><span class="koboSpan" id="kobo.413.2">Quarkus will take </span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.414.1">care of retrieving an </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">EntityManager</span></strong><span class="koboSpan" id="kobo.416.1"> object with all the database connection </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.417.1">settings we provided in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">application.properties</span></strong><span class="koboSpan" id="kobo.419.1"> file. </span><span class="koboSpan" id="kobo.419.2">Continuing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">PersistenceExample</span></strong><span class="koboSpan" id="kobo.421.1"> implementation, let’s create a method to persist entities, </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
@Transactional
public String createEntity(SampleObject sampleObject) {
    SampleEntity sampleEntity = new SampleEntity();
    sampleEntity.setField(sampleObject.field);
    sampleEntity.setValue(sampleObject.value);
    em.persist(sampleEntity);
    return "Entity with field "+sampleObject.field+"
      created!";
}</span></pre> <p><span class="koboSpan" id="kobo.424.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">createEntity</span></strong><span class="koboSpan" id="kobo.426.1"> method persists an entity in </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">@Transactional</span></strong><span class="koboSpan" id="kobo.430.1"> annotation above the method declaration will make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">EntityManager</span></strong><span class="koboSpan" id="kobo.432.1"> object flush the transaction once the database operation is committed. </span><span class="koboSpan" id="kobo.432.2">This is illustrated in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
@Transactional
public List&lt;SampleEntity&gt; getAllEntities(){
    return em.createNamedQuery(
    "SampleEntity.findAll", SampleEntity.class)
            .getResultList();
}</span></pre> <p><span class="koboSpan" id="kobo.435.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">getAllEntities</span></strong><span class="koboSpan" id="kobo.437.1"> method retrieves all entities from </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.439.1">Now, let’s return to </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">RestExample</span></strong><span class="koboSpan" id="kobo.441.1"> to </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.442.1">create REST endpoints to trigger the creation and retrieval of database</span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.443.1"> entities. </span><span class="koboSpan" id="kobo.443.2">We will start by injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">PersistenceExample</span></strong><span class="koboSpan" id="kobo.445.1"> so that we can use this bean to begin operations on the database. </span><span class="koboSpan" id="kobo.445.2">The code is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
@Inject
PersistenceExample persistenceExample;</span></pre> <p><span class="koboSpan" id="kobo.448.1">Then, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">/create-entity</span></strong><span class="koboSpan" id="kobo.450.1"> endpoint, </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
@POST
@Path("/create-entity")
@Produces(MediaType.TEXT_PLAIN)
@Consumes(MediaType.APPLICATION_JSON)
public String persistData(@Valid SampleObject sampleObject) {
    return persistenceExample.createEntity(sampleObject);
}</span></pre> <p><span class="koboSpan" id="kobo.453.1">We pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">SampleObject</span></strong><span class="koboSpan" id="kobo.455.1"> as the parameter. </span><span class="koboSpan" id="kobo.455.2">This object represents the body of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.457.1"> request.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Finally, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">/get-all-entities</span></strong><span class="koboSpan" id="kobo.460.1"> endpoint to retrieve all entities from the database, </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
@GET
@Path("/get-all-entities")
public List&lt;SampleEntity&gt; retrieveAllEntities() {
    return persistenceExample.getAllEntities();
}</span></pre> <p><span class="koboSpan" id="kobo.463.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">retrieveAllEntities</span></strong><span class="koboSpan" id="kobo.465.1"> method calls on </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">getAllEntities</span></strong><span class="koboSpan" id="kobo.467.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">PersistenceExample</span></strong><span class="koboSpan" id="kobo.469.1"> bean. </span><span class="koboSpan" id="kobo.469.2">The result is a list of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">SampleEntity</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.471.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">Let’s see what we get</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.473.1"> when we hit </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">/create-entity</span></strong><span class="koboSpan" id="kobo.475.1"> to create a new entity. </span><span class="koboSpan" id="kobo.475.2">You can see the </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">output here:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.477.1">
$ curl -s -H "Content-Type: application/json"  -d '{"field": "item-a", "value": 10}' localhost:8080/app/create-entity
Entity with field item-a created!
</span><span class="koboSpan" id="kobo.477.2">$ curl -s -H "Content-Type: application/json"  -d '{"field": "item-b", "value": 20}' localhost:8080/app/create-entity
Entity with field item-b created!</span></pre> <p><span class="koboSpan" id="kobo.478.1">To see the entities</span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.479.1"> we’ve created, we send a request to </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">/get-all-entities</span></strong><span class="koboSpan" id="kobo.481.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.483.1">
$ curl -s localhost:8080/app/get-all-entities | jq
[
  {
    "field": "item-a",
    "value": 10
  },
  {
    "field": "item-b",
    "value": 20
  }
]</span></pre> <p><span class="koboSpan" id="kobo.484.1">As expected, we received all the entities we persisted previously in the database in a </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">JSON format.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Quarkus is a vast and continuously growing framework that’s absorbing more and more capabilities. </span><span class="koboSpan" id="kobo.486.2">The features we have seen cover some of the basic things required to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">modern applications.</span></span></p>
<p><span class="koboSpan" id="kobo.488.1">We’ll be able to use RESTEasy when reimplementing input adapters to support REST on our hexagonal application. </span><span class="koboSpan" id="kobo.488.2">Quarkus DI </span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.489.1">will enable us to better manage the life cycle of objects from the Framework and Application hexagons. </span><span class="koboSpan" id="kobo.489.2">The Quarkus validation mechanisms will contribute to </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.490.1">validating the data entering the hexagonal system. </span><span class="koboSpan" id="kobo.490.2">The data source configuration and Hibernate ORM will support the restructuring of </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">output adapters.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">In this section, we learned how to tweak the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">application.properties</span></strong><span class="koboSpan" id="kobo.494.1"> file to configure a database connection on Quarkus, and we briefly explored Hibernate’s ORM capabilities that help map Java classes to database entities. </span><span class="koboSpan" id="kobo.494.2">We’ll explore this subject further in </span><a href="B19777_13.xhtml#_idTextAnchor263"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.495.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.496.1">, </span><em class="italic"><span class="koboSpan" id="kobo.497.1">Persisting Data with Output Adapters and </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.498.1">Hibernate Reactive</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">Let’s now see how to integrate Quarkus into the </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-177"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.502.1">Adding Quarkus to a modularized hexagonal application</span></h1>
<p><span class="koboSpan" id="kobo.503.1">To recap, we structured the topology </span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.504.1">and inventory system in three</span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.505.1"> modularized hexagons: </span><strong class="bold"><span class="koboSpan" id="kobo.506.1">Domain</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.508.1">Application</span></strong><span class="koboSpan" id="kobo.509.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">Framework</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">A question that may arise is, </span><em class="italic"><span class="koboSpan" id="kobo.512.1">which module should be responsible for starting the Quarkus engine?</span></em><span class="koboSpan" id="kobo.513.1"> Well, to avoid blurring the responsibilities of each module in the topology and inventory system, we’ll create a dedicated module whose sole purpose is to aggregate the other hexagonal system modules and bootstrap the Quarkus engine. </span><span class="koboSpan" id="kobo.513.2">We will name this new module </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">Bootstrap</span></strong><span class="koboSpan" id="kobo.515.1">, as illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.517.1"><img alt="Figure 10.4 – The Bootstrap aggregator module" src="image/B19777_10_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.518.1">Figure 10.4 – The Bootstrap aggregator module</span></p>
<p><span class="koboSpan" id="kobo.519.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">bootstrap</span></strong><span class="koboSpan" id="kobo.521.1"> module is</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.522.1"> an aggregator module that provides, from one side, the dependencies required to initialize Quarkus and, from the other side, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">hexagonal</span></strong><span class="koboSpan" id="kobo.524.1"> module dependencies for use in conjunction </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">with </span></span><span class="No-Break"><a id="_idIndexMarker714"/></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">Quarkus.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Let’s create this new </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">bootstrap</span></strong><span class="koboSpan" id="kobo.529.1"> module in the topology and inventory system, </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.531.1">In the Maven root project of the topology and inventory system, you can execute the following Maven command to create this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">bootstrap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> module:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.534.1">mvn archetype:generate \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.535.1">-DarchetypeGroupId=de.rieckpil.archetypes  \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.536.1">-DarchetypeArtifactId=testing-toolkit \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.537.1">-DarchetypeVersion=1.0.0 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.538.1">-DgroupId=dev.davivieira \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.539.1">-DartifactId=bootstrap \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.540.1">-Dversion=1.0-SNAPSHOT \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.541.1">-Dpackage=dev.davivieira.topologyinventory.bootstrap \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.542.1">-DinteractiveMode=false</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.543.1">This Maven command creates a basic directory structure for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">bootstrap</span></strong><span class="koboSpan" id="kobo.545.1"> module. </span><span class="koboSpan" id="kobo.545.2">We set </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">artifactId</span></strong><span class="koboSpan" id="kobo.547.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">bootstrap</span></strong><span class="koboSpan" id="kobo.549.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">groupId</span></strong><span class="koboSpan" id="kobo.551.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">dev.davivieira</span></strong><span class="koboSpan" id="kobo.553.1">, as this module is part of the same Maven project that holds the modules for other topology and inventory system hexagons. </span><span class="koboSpan" id="kobo.553.2">The final high-level structure should be</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.554.1"> similar to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">shown here:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.556.1"><img alt="Figure 10.5 – The topology and inventory high-level directory structure" src="image/B19777_10_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.557.1">Figure 10.5 – The topology and inventory high-level directory structure</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.558.1">Next, we need to set up Quarkus dependencies in the project’s root </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">pom.xml</span></strong><span class="koboSpan" id="kobo.560.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-universe-bom&lt;/artifactId&gt;
      &lt;version&gt;${quarkus.platform.version}&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencyManagement&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.563.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">quarkus-universe-bom</span></strong><span class="koboSpan" id="kobo.565.1"> dependency makes all the Quarkus </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">extensions available.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.567.1">Because we’re working with a multi-module application, we need to configure Quarkus to discover CDI beans in </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">different modules.</span></span></p></li> <li><span class="koboSpan" id="kobo.569.1">So, we need to </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.570.1">configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">jandex-maven-plugin</span></strong><span class="koboSpan" id="kobo.572.1"> in the</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.573.1"> Maven project’s root </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">pom.xml</span></strong><span class="koboSpan" id="kobo.575.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.577.1">
&lt;plugin&gt;
  &lt;groupId&gt;org.jboss.jandex&lt;/groupId&gt;
  &lt;artifactId&gt;jandex-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;${jandex.version}&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;make-index&lt;/id&gt;
      &lt;goals&gt;
        &lt;goal&gt;jandex&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.578.1">Without the preceding plugin, we’d have a problem setting up and using CDI beans on both the Framework and </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">Application hexagons.</span></span></p></li> <li><span class="koboSpan" id="kobo.580.1">Now comes the most crucial part – the configuration of </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">quarkus-maven-plugin</span></strong><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">To make the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">bootstrap</span></strong><span class="koboSpan" id="kobo.584.1"> module the one that will start the Quarkus engine, we need to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">quarkus-maven-plugin</span></strong><span class="koboSpan" id="kobo.586.1"> in that </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">module properly.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.588.1">Here is how we should </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.589.1">configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">quarkus-maven-plugin</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.591.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">bootstrap/pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.594.1">
&lt;build&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
      &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;${quarkus-plugin.version}&lt;/version&gt;
      &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;goals&gt;
            &lt;goal&gt;build&lt;/goal&gt;
            &lt;goal&gt;generate-code&lt;/goal&gt;
            &lt;goal&gt;generate-code-tests&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.595.1">The important part</span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.596.1"> here is the line containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">&lt;goal&gt;build&lt;/goal&gt;</span></strong><span class="koboSpan" id="kobo.598.1">. </span><span class="koboSpan" id="kobo.598.2">By setting this build goal for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">bootstrap</span></strong><span class="koboSpan" id="kobo.600.1"> module, we make this module responsible for starting the </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">Quarkus engine.</span></span></p></li> <li><span class="koboSpan" id="kobo.602.1">Next, we need to add</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.603.1"> the Maven dependencies from the topology and inventory system’s hexagons. </span><span class="koboSpan" id="kobo.603.2">We</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.604.1"> do that in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">bootstrap/pom.xml</span></strong><span class="koboSpan" id="kobo.606.1"> file, </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.608.1">
&lt;dependency&gt;
  &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
  &lt;artifactId&gt;domain&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
  &lt;artifactId&gt;application&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;dev.davivieira&lt;/groupId&gt;
  &lt;artifactId&gt;framework&lt;/artifactId&gt;
&lt;/dependency&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.609.1">And finally, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">module-info.java</span></strong><span class="koboSpan" id="kobo.611.1"> Java module descriptor with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">requires</span></strong><span class="koboSpan" id="kobo.613.1"> directives for Quarkus and the topology and inventory hexagon modules, </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.615.1">
module dev.davivieira.bootstrap {
    requires quarkus.core;
    requires domain;
    requires application;
    requires framework;
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.616.1">To aggregate the three hexagon modules into one deployment unit, we’ll configure Quarkus to generate an uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">.jar</span></strong><span class="koboSpan" id="kobo.618.1"> file. </span><span class="koboSpan" id="kobo.618.2">This kind of JAR groups up all dependencies required to run an application in one single JAR. </span><span class="koboSpan" id="kobo.618.3">To accomplish that, we need to set the following configuration in the project’s root </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.620.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.621.1">
&lt;quarkus.package.type&gt;uber-jar&lt;/quarkus.package.type&gt;</span></pre> <p><span class="koboSpan" id="kobo.622.1">Then, we’re ready to compile the </span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.623.1">application by running the following </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">Maven command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.625.1">
mvn clean package</span></pre> <p><span class="koboSpan" id="kobo.626.1">This Maven command will compile the entire application and create an uber </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">.jar</span></strong><span class="koboSpan" id="kobo.628.1"> file that we can use to start the application by executing the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.630.1">
java -jar bootstrap/target/bootstrap-1.0-SNAPSHOT-runner.jar</span></pre> <p><span class="koboSpan" id="kobo.631.1">Note that the artifact we use is </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.632.1">generated from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">bootstrap</span></strong><span class="koboSpan" id="kobo.634.1"> module, which aggregates all the other modules. </span><span class="koboSpan" id="kobo.634.2">The following screenshot shows us what a running Quarkus application should </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">look like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.636.1"><img alt="Figure 10.6 – A running Quarkus application" src="image/B19777_10_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.637.1">Figure 10.6 – A running Quarkus application</span></p>
<p><span class="koboSpan" id="kobo.638.1">The application seen in the preceding screenshot is running in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">prod</span></strong><span class="koboSpan" id="kobo.640.1"> profile. </span><span class="koboSpan" id="kobo.640.2">In that profile, some features are deactivated for security purposes. </span><span class="koboSpan" id="kobo.640.3">We can also see the installed features running in the application. </span><span class="koboSpan" id="kobo.640.4">These features are activated when we add Quarkus extension dependencies </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">pom.xml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">bootstrap</span></strong><span class="koboSpan" id="kobo.646.1"> module</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.647.1"> acts as a bridge, allowing us to connect the external development framework to the hexagon modules that comprise the hexagonal system. </span><span class="koboSpan" id="kobo.647.2">For the topology and inventory application, we used Quarkus, but we could also use other development frameworks. </span><span class="koboSpan" id="kobo.647.3">We cannot say that we are totally decoupling the system logic from the development</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.648.1"> framework; after all, there will be some system logic that benefits from framework features. </span><span class="koboSpan" id="kobo.648.2">However, the approach presented in this chapter shows that part of that system can be developed first and the development framework </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">introduced later.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.650.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.651.1">In this chapter, we revisited the fundamentals of JVM, assessing some of its features related to JIT compilation and AOT compilation. </span><span class="koboSpan" id="kobo.651.2">We learned that JIT improves runtime performance, whereas AOT helps boost application startup time, which proves to be an essential feature for frameworks targeting cloud environments, as in this case </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">with Quarkus.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">After getting acquainted with some JVM concepts, we moved on to learn about Quarkus and some important features it offers. </span><span class="koboSpan" id="kobo.653.2">Finally, we integrated Quarkus into our already-developed hexagonal system topology and inventory. </span><span class="koboSpan" id="kobo.653.3">In order to accomplish such an integration, we created a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">bootstrap</span></strong><span class="koboSpan" id="kobo.655.1"> module to act as a bridge between the hexagonal system modules and the development framework. </span><span class="koboSpan" id="kobo.655.2">We now know what it takes to integrate Quarkus into a modularized </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">hexagonal application.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">In the next chapter, we dive deeper into the integration between Quarkus and hexagonal architecture. </span><span class="koboSpan" id="kobo.657.2">We will learn how to refactor use cases and ports from the Application hexagon to leverage Quarkus </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">DI features.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.659.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.660.1">What is the advantage of using the </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">JIT compilation?</span></span></li>
<li><span class="koboSpan" id="kobo.662.1">Which benefit do we get by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">AOT compilation?</span></span></li>
<li><span class="koboSpan" id="kobo.664.1">Quarkus is a development framework specially designed for which kind </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">of environment?</span></span></li>
<li><span class="koboSpan" id="kobo.666.1">What is the role of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">bootstrap</span></strong><span class="koboSpan" id="kobo.668.1"> module in </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">hexagonal architecture?</span></span></li>
</ol>
<h1 id="_idParaDest-180"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.670.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.671.1">JIT improves the runtime performance of </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">an application.</span></span></li>
<li><span class="koboSpan" id="kobo.673.1">AOT boosts the startup time of </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">an application.</span></span></li>
<li><span class="koboSpan" id="kobo.675.1">Quarkus was designed to develop applications for </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">cloud environments.</span></span></li>
<li><span class="koboSpan" id="kobo.677.1">Its role is to integrate the Quarkus framework with the </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">hexagonal system.</span></span></li>
</ol>
</div>
</body></html>