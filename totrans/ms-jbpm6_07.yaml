- en: Chapter 7. Customizing and Extending jBPM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter details the extension points of jBPM. Not every user of jBPM uses
    the entire tool stack. Users will need to customize/extend jBPM to fit it into
    their solution architecture. This chapter will show you how jBPM's features can
    be customized and extended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of topics that will be covered in the chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your custom workitem handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the process designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending variable persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending user management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom process nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*,
    we introduced the jBPM feature that lets you bind specific Java class implementations
    to the execution of a specific process task node type: send/receive tasks, service
    tasks, and ad hoc tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of *extensible* task nodes are often called **custom workitems**,
    and the implementing classes that perform the horse work behind the process curtains
    are called **workitem handlers**. This architecture makes jBPM more flexible when
    it comes to adapting the engine to a particular domain, both in terms of features
    and tools UI. Let's start by reviewing the basics of the jBPM workitem and handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Workitem and handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'jBPM defines a work item as a unit of work that is defined inside the scope
    of a process but can be executed outside the engine; in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a set of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs some action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It optionally returns a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The workitem is just an abstract definition of a work unit and has several
    concrete, practical implementations in jBPM: human tasks, sendMessage tasks, and
    so on. The engine imposes no limitations to the workitem handler apart from enforcing
    the implementation of the `org.kie.api.runtime.process.WorkItemHandler` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The engine runtime is instructed to bind a new handler implementation through
    the `WorkItemManager.registerWorkItemHandler(String workItemName, WorkItemHandler
    handler)` method, where the `workItemName` parameter must match a custom node
    name since it serves as the handler key.
  prefs: []
  type: TYPE_NORMAL
- en: jBPM itself extensively uses WorkItemHandler such as `LocalHTWorkItemHandler`
    (workitem name `Human Task`), `WebServiceWorkItemHandler` (workitem name `WebService`),
    or `RESTWorkItemHandler` (name `Rest`). This feature effectively streamlines the
    engine customization process, letting the user enhane (or replace) jBPM functionalities.
    You can find several jBPM workitem handler classes in the `jpbm-workitems-6.2.0.Final.jar`
    library (see package details in the following class diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![Workitem and handlers](img/9578OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`AsyncWorkItemHandler` (we discussed it in the *Async task* section in [Chapter
    5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*) can be found in
    the `jpbm-executor-6.2.0.Final.jar` library.'
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The workitem state transitions are as follows: `ACTIVE`, `PENDING`, `COMPLETED`,
    and `ABORTED`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The WorkItemHandler call sequence is quite simple (see the following interaction
    diagrams), and when the handler calls complete or abort, the engine takes the
    control again and the process execution continues. The handler must implement
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`executeWorkItem`: The workitem manager invokes the `executeMethod` handler
    and, upon completion (at the end of `executeMethod`), the handler must invoke
    the callback method called `completeWorkItem` on the manager itself (optionally
    passing the output parameters):![Life cycle](img/9578OS_07_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abortWorkItem`: This method gets called as a consequence of a cancel or error
    event. The handler must perform clean-up operations (when needed) and call the
    manager back by the `abortWorkItem` method, which instructs the manager to set
    the workitem in the **ABORTED** state:![Life cycle](img/9578OS_07_02.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheable and closeable interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'jBPM 6.2 introduces a new feature that lets the user hook into the workitem
    handler life cycle by implementing the following interface methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.kie.internal.runtime.Closeable.close()`: Called on WorkItemManager (and
    Session) disposal. Here, you can perform the typical housekeeping duties (freeing
    resources, close connections, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.kie.internal.runtime.Cacheable.close()`: Called when the jBPM internal
    cache manager is closed/disposed. By implementing the `Cacheable` interface, we
    enable our Workitem handler definition to be cached by jBPM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RuntimeManager internally caches several configured object class definitions
    to optimize the initialization and startup times: event listeners, globals, marshalling
    strategies, Workitem handlers, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: For a `Closeable` interface example, please have a look at the PizzaTweet handler
    implementation discussed in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Handlers in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The workitem customization can be seen as a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code implementation and runtime registration**: Make the handler implementation
    available to the runtime engine in order to trigger the handler execution when
    the engine reaches the custom node type'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Designer customization**: Enable the usage of the custom node from the UI
    interface (process designer)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before diving into a detailed example (the `pizzatweet` project), let us look
    at the basics of the workitem architecture and review the three different ways
    in which we can register a handler: by direct registration with the API, by setting
    the `kmodule.xml` file, and by adding a handler configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Direct handler registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The shortest, naïve way of registering a handler implementation with your engine
    session is to make a direct invocation to the Kie session''s WorkItemManager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This gives you a lot of flexibility; you do not need to define extra configuration
    files or properties (more on these in the upcoming section), and you are free
    to initialize your handler with everything you need during the execution. This
    is the preferred way to go when unit testing, particularly when replacing or defining
    a system workitem handler (`human task`, `service`, or `task`) since you do not
    have to tweak the Kie console to add the new node type to the **Service Task**
    menu, which would be mandatory to properly design the process definition.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative kmodule.xml handler configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case your project is a Kie module and you need a declarative, a less hardwired
    way to define the handlers is to add the `<workItemHandlers>` element to the `kmodule.xml`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Handler configuration file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to add new custom node types, the preferred, standard way to
    register your handler implementation is to have it listed in the standard handler
    configuration file: the `CustomWorkItemHandlers.conf` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file must contain the handler implementation class constructors and the
    work item name that will be used to register them; here you have, as an example,
    the default configuration file shipped with jBPM 6.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is written with the MVEL expression language and is loaded by the
    jBPM console runtime from the `jbpm-console.war\WEB-INF\classes\META-INF` folder;
    note that the filename is added to the sibling file called `drools.session.conf`
    whose content is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that from the system default handler definitions (`Web Service` and `Service
    Task`), by defining a constructor that accepts the `ksession` parameter, the KieSession
    will be automatically injected at runtime in your handler instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The very same property called `drools.workItemHandlers` is used to load the
    handler configuration file(s), for instance, during Kie Session initialization
    with `KieSessionConfiguration`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, with the runtime builder classes (see [Chapter 6](ch06.html
    "Chapter 6. Core Architecture"), *Core Architecture*, for details about runtime
    classes), you can have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `.conf` file is searched in the `META-INF/` classpath or in the `user.home`
    system folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The property supports multiple space-separated entries such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Handler definition file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file that defines the WorkItemHandler process definition node properties
    is the workitem definition file (having the `.WID` extension), and it is written
    using the MVEL expression language.
  prefs: []
  type: TYPE_NORMAL
- en: When in the **Project Authoring** mode, the KIE console creates a default `WorkDefinitions.wid`
    file in your project `resources` folder that defines the `email`, `log`, `webservice`,
    and `rest` handlers whose custom nodes can be found under the Service Task menu
    of the process designer palette. Additional resources (custom node icons) are
    created in the `global` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you define your custom node properties and the workitem abstract definitions:
    `name` (used as the key for the handler), its parameters (input), result parameters
    (output), `displayName` (the label used for the node), and node icon resource.
    Let us have a look at our `PizzaTweet` custom node (we will talk about this in
    the example section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `"parameters"` and `"results"` attributes are maps of typed parameters (name-type
    pairs).
  prefs: []
  type: TYPE_NORMAL
- en: '`parameters`: Defines the set of input parameters of the workitem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`results`: Defines the set of output parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The types allowed for the parameters are the ones supported by the Drool core
    type classes: `StringDataType`, `IntegerDataType`, `FloatDataType`, `BooleanDataType`,
    `EnumDataType`, `ObjectDataType`, `ListDataType`, and `UndefinedDataType.ObjectDataType`
    wraps a type, while `ListDataType` wraps `java.util.List`.'
  prefs: []
  type: TYPE_NORMAL
- en: Workitem handler implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your handler must implement the `org.kie.api.runtime.process.WorkItemHandler`
    interface or extend the `AbstractWorkItemHandler` abstract class. This class gives
    you a set of useful helper methods in case your handler needs to get runtime information
    from the process or its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling input parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The handler can read the input parameters with the `WorkItem.getParameter (String
    name)` method. The input parameters are passed by the engine runtime, upon evaluation
    of your node data input set mappings.
  prefs: []
  type: TYPE_NORMAL
- en: Returning results to the process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The handler return object (`"results"`) is defined as a collection of parameters.
    Each attribute name must match a data output parameter in the `DataOutputSet`
    node settings (`"details"` and `"tweetOK"`), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `details` and `tweetOk` keys must match both node data output parameter
    names (see the screenshot in the *Process and task parameter mappings* section)
    and the workitem handler `"results"` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The PizzaTweet example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example guides you through the definition and the installation of a full
    working example project, which features a custom workitem that sends messages
    to Twitter (Twitter API integration not implemented for clarity).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find a Twitter handler implementation in the Red Hat jBPM service repository:
    [http://people.redhat.com/kverlaen/repository/Twitter/](http://people.redhat.com/kverlaen/repository/Twitter/).'
  prefs: []
  type: TYPE_NORMAL
- en: The main project (the `pizzatweet` KIE module) contains the process definition
    and the WID file, and it depends on custom types that are defined in the `pizzamodel`
    project (a plain utility JAR). These types are also used as parameter types by
    the `PizzaTweetHandler` handler (defined in the `pizzahandlers` project, another
    plain JAR).
  prefs: []
  type: TYPE_NORMAL
- en: The main project (the KIE module)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main project depends on the two supplier projects: `pizzamodel` and `pizzahandlers`.
    Since these two projects are not KIE modules and do not need additional processing
    by the KIE runtime (they do not contain jBPM resources), we have set their Maven
    dependency scope to `provided` (see the `pom.xml` PizzaTweet project file). This
    speeds up the Maven build of our main KIE module; `kie-mave-plugin` in fact searches
    for KIE module dependencies only when their Maven scope is `runtime` or `compile`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The KIE plugin for Maven (`kie-maven-plugin`) is the preferred way to build
    a KIE module. It ensures that all module business resources are valid at compile
    time and that the module can be successfully loaded at runtime. Make sure that
    you always have the `kie-maven-plugin` set in the `pom.xml` file of your KIE module
    (see the following `PizzaTweet` `pom.xml` excerpt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Process and task parameter mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After having introduced the `pizzatweet` custom task definition in the previous
    section (the handler definition file), let us now look at how it fits into the
    process definition. The process definition is easy to understand; it has the custom
    tweet task and a script task that acts as a debugging step. The process variables
    (`msg`, `order`, and `tags`) are mapped to the custom task input parameters, while
    the resulting parameters (`tweetOK`, `details`) are mapped back to process variables
    (`success` and `results`). The following screenshot shows the **Assignments**
    properties panel for the `Pizza Tweet` custom node (see the `PizzaTweet` process
    definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Process and task parameter mappings](img/9578OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After the tweet task completes, the script task is executed. As mentioned earlier,
    it simply dumps the updated process variables to the console for you to see. We
    are now going to look at the two dependent projects (handlers and models).
  prefs: []
  type: TYPE_NORMAL
- en: Handler project (pizzahandlers)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project contains the handler implementation (the `PizzaTweetHandler` class)
    only, the one responsible for sending the tweet. In order to deploy the dependent
    `pizzahandlers` handler project, we have to perform a Maven "clean build install."
    The JAR file will then be installed in your system's Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that all the implementation classes and required dependencies are
    also available on the classpath of the application war (in this case, the war
    is our KIE console war), for example, by copying the required JAR files in the
    `/lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Model project (pizzamodel)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model project defines Java types for the process definition variables and
    the handler project parameters. In order to deploy the dependent `pizzamodel`
    project, we have to execute a Maven "clean build install." Thus, the JAR file
    is installed in your system's Maven repository so as to make it available to runtime
    dependency resolving.
  prefs: []
  type: TYPE_NORMAL
- en: IDE customization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to configure the KIE workbench (business process editor) tools and
    being able to use our custom node in the process editor, we have to create a workitem
    handler file. We create the `WEB-INF\classes\META-INF\PACKTworkItemHandlers.conf`
    file (in the `jbpm-console deployment` folder) and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we edit the `WEB-INF\classes\META-INF\drools.session.conf` file by adding
    our custom handler `.conf` filename to the `drools.workItemHandlers` property.
    Thus, the handler definitions from both the files are loaded. Please note that
    the handler configuration file names must be separated by a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `drools.session.conf` file is picked up by the KIE console and read during
    KIE session initialization; see the *Handler configuration file* section for further
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the installed `pizzahandlers-1.0.0-SNAPSHOT.jar` and `pizzamodel-1.0.0-SNAPSHOT.jar`
    files to the jBPM console''s `WEB-INF\lib` folder (for example, `wildfly-8.1.0.Final\standalone\deployments\jbpm-console.war\WEB-INF\lib`).
    This makes both the custom java types and the handler class available to the Kie
    console (a jBoss restart is required). Note that the Pizza Tweet (`name: pizzatweet`)
    custom task node is now displayed in the **Service Tasks** section of the object
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IDE customization](img/9578OS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Console test run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of jBPM 6.2.0 release, the KIE console is not much of a help in letting us
    test our process, since the generated task forms do not support complex type parameters
    automatically (our process takes an input parameter of the `Order` type); we cannot
    easily create our new process instances from here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The jBPM user guide (*Chapter 13*, *Forms*) explains the features shipped with
    the KIE console Form Modeler ([http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html](http://docs.jboss.org/jbpm/v6.2/userguide/chap-formmodeler.html))
    and gives useful instructions on how to create customized human task forms and
    start process forms.
  prefs: []
  type: TYPE_NORMAL
- en: However, before leaving the console, let's check whether the process can successfully
    deploy without issues. Go to the `pizzatweet` project from the **Tools**/**Project
    Details** view and issue **build & deploy**. The process definition is registered
    with the runtime, and we should see it from the **Process Management/Process Definitions**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Console test run](img/9578OS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Standalone test run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get the PizzaTweetTest test class from the `PizzaTwitter` project and run (jUnit)
    the `newTweet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The console prints the following text; first, we have the following handler
    log traces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have the script task log traces, showing the following handler results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After the handler has been locally tested, we can move on and share it with
    the development team; this is where the service repository comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Service repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jBPM gives us the ability to add any handler to a public service repository;
    these are a collection of handler definitions that can be accessed both via HTTP
    or locally (the FILE protocol) so that handlers can be shared with the other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the KIE workbench supported two repositories:
    [http://people.redhat.com/kverlaen/repository](http://people.redhat.com/kverlaen/repository)
    and [http://people.redhat.com/tsurdilo/repository](http://people.redhat.com/tsurdilo/repository).
    Another repository service is available at [http://docs.jboss.org/jbpm/v6.2/repository/](http://docs.jboss.org/jbpm/v6.2/repository/).
    These repositories host several handler definitions; some of them are externally
    defined handlers (which means that the implementing JAR file is physically hosted
    in the repository), while other handlers are already defined in the jBPM runtime
    (for example, Java, REST, and transform handlers), and the repository just publishes
    the extended handler definition (`.WID`) file. The service repository is accessible
    through the **Connect to a service repository** button in the business process
    editor. Here, you have an example repository content dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service repository](img/9578OS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are going to see how to set up an additional custom local service repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For additional details about the service repository, please refer to *Chapter
    21, Domain-specific Processes* of the jBPM 6.2 user guide (*Service Repository*
    paragraph).
  prefs: []
  type: TYPE_NORMAL
- en: Custom service repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A service repository is basically a folder structure containing handlers. The
    folder structure and the content to load are specified by a set of `index.conf`
    files. See the `repo.rar` example included with the book's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder structure for our repository in a local folder (for example,
    `c:/temp/packtservicerepo`) containing the `pizzatweet` handler folder; inside
    the handler folder, we add the enhanced `pizzatweet.wid` file, which is basically
    a standard WID file with the following additional entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependencies path is relative to the handler folder (`/lib`), and there
    we copy the two JAR files: the JAR file containing the handler definition and
    the JAR file defining the Java models.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the details about the pizza handler and model projects in the `PizzaTweet`
    example paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth mentioning that the WID file must have the handler folder name.
    After creating the files, we can open the service repository from the KIE workbench,
    giving the following local filesystem path: `file:///c:/temp/packtservicerepo`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom service repository](img/9578OS_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can use **Install selected item** `:`. This makes the KIE workbench
    copy the assets to the internal KIE repository so that the handler becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: jBPM identity management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Operation Management"), *Operation Management*,
    we saw how the KIE workbench features JAAS-based user authentication and RBAC
    for the UI functionalities by means of the `user.properties` and `roles.properties`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The jBPM engine does not have built-in authentication or fine-grained authorization
    functionalities on process creation or task operations. TaskService and the human
    task management of users and groups with respect to task operations are delegated
    to a custom implementation of the `UserGroupCallback` interface. Here, the developer
    is able to implement his/her own task authorization mechanism by hooking into
    a custom identity management system or an ad hoc implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'jBPM provides a set of ready-to-use, configurable `UserGroupCallback` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBUserGroupCallbackImpl`: Implementation that uses SQL queries to get user
    and group data from a database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDAPUserGroupCallbackImpl`: LDAP system integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MvelUserGroupCallbackImpl`: Default jBPM implementation when no callback is
    specified; the `UserGroupsAssignmentsOne.mvel` file is read and evaluated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JAASUserGroupCallbackImpl`: JAAS-based implementation to be used in a container
    (JBoss AS and Tomcat):![jBPM identity management](img/9578OS_07_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User callback configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UserGroupCallback` implementation is a singleton and can be set on the
    environment used to create `RuntimeEngine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the book''s source code examples use a default custom callback class
    (`MyUserCallback`: you can find it in the `test-common` project). The callback
    is set by the `PacktJUnitBaseTestCase` class from which every test case borrows
    the runtime engine, the session, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The jBPM UserGroupCallback implementations rely on the `jbpm.usergroup.callback.properties`
    system property for the property filename or, alternatively, on the `jbpm.usergroup.callback.properties`
    property file for automatic configuration. The callback class can have a defined
    set of properties; let's review some of them for the classes shipped with jBPM.
  prefs: []
  type: TYPE_NORMAL
- en: The DBUserGroupCallbackImpl class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This callback has the following four properties (let `users` and `groups` be
    the tables defining our users and groups data):'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.ds.jndi.name`: JNDI name of the data source to be used, for example, `jdbc/jbpm-ds`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.user.query`: Query used to verify existence of the user (case-sensitive,
    expects a single parameter on position 1), for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`db.roles.query`: Query user to check group existence (case-sensitive, expects
    single parameter on position 1), for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`db.user.roles.query`: Query used to get groups for a given user (case-sensitive,
    expects single parameter on position 1), for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The LDAPUserGroupCallbackImpl class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This callback relies on several properties (parameter descriptions):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ldap.bind.user` (optional if the LDAP server accepts anonymous access)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.bind.pwd` (optional if the LDAP server accepts anonymous access)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.ctx` (mandatory), for example, `ou\=Staff,dc\=packt,dc\=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.role.ctx` (mandatory), for example, `ou\=Roles,dc\=packt,dc\=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.roles.ctx` (optional; if not given, `ldap.role.ctx` will be used)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.filter` (mandatory), for example, `=(uid\={0})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.role.filter` (mandatory), for example, `(cn\={0})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.roles.filter` (mandatory), for example, `(member\={0})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.attr.id` (optional; if not given, `uid` will be used)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.roles.attr.id` (optional; if not given, `cn` will be used)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.user.id.dn` (optional; is user id a `DN`?; instructs the callback to
    query for a user `DN` before searching for roles; default false)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ldap.search.scope` (optional; if not given, `OBJECT_SCOPE` will be used);
    the possible values are as follows: `OBJECT_SCOPE`, `ONELEVEL_SCOPE`, and `SUBTREE_SCOPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.naming.factory.initial`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.naming.security.authentication`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.naming.security.protocol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.naming.provider.url`, for example, `ldap://localhost:10389`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jBPM serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that the engine features, with enabled persistence, state saving
    of session, process, task, and variable data to the database, and contextually,
    relevant object state data are marshalled and then, persisted on entity saving
    and unmarshaled on entity loading so as to make possible the preservation of the
    engine execution state in the long term, across system restarts. Here, the term
    **marshalling** is used because the jBPM serialization layer utilizes the Google
    Protobuf framework, a protocol, which, in the first instance, was used for RPC.
    Let us have a look at how the default jBPM serialization works and, later on,
    how we can manage to hook our serialization mechanism into jBPM.
  prefs: []
  type: TYPE_NORMAL
- en: Marshalling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CommandService` ([Chapter 6](ch06.html "Chapter 6. Core Architecture"), *Core
    Architecture*) and the related interceptors are invoked to persist entities in
    a transactional way; the internal object marshalling phase takes place inside
    the transaction.'
  prefs: []
  type: TYPE_NORMAL
- en: During the saving (or update) of the session, for example, its instance gets
    marshalled into its `RULEBYTESARRAY` column (`SessionInfo` table) so that the
    `Knowledge Session` instance can be loaded after a restart. The same happens for
    a process instance; its instance (with variables, node definitions, swimlanes,
    and so on.) is marshalled into `PROCESSINSTANCEBYTEARRAY` (the `ProcessInstanceInfo`
    table). The task data is marshalled into the `WORKITEMBYTEARRAY` (`WorkItemInfo`
    table).
  prefs: []
  type: TYPE_NORMAL
- en: The engine classes, which actually perform the marshalling job, are respectively
    `SessionMarshallingHelper` and `ProtobufProcessMarshaller`; these classes are
    internally baked by the `ProtobufMarshaller` class, which manages operations through
    a write handler (`ProtobufOutputMarshaller`) and an input handler (`ProtobufInputMarshaller`).
    The class diagram shown later demonstrates these classes and also how `KieMarshallers`
    (we introduced this in [Chapter 6](ch06.html "Chapter 6. Core Architecture"),
    *Core Architecture*) fits into the picture. It is simply a factory default for
    marshaller and strategy instances. `Strategies` are classes that control the marshalling
    process of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jBPM does not feature off-the-shelf processes and task variable persistence
    toward an ER model, mainly because of performance reasons. The main drawback is
    that you cannot search process instances by the value of a process variable. In
    order to add this kind of feature, you have to provide an implementation for the
    `JPAPlaceholderResolverStrategy` strategy (we are going to discuss it in a moment).
  prefs: []
  type: TYPE_NORMAL
- en: Strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have just seen, the default jBPM marshalling process results into bytes
    written in the database. This could be of limited interest to our application,
    but luckily, jBPM gives us the tools to hook into this mechanism by controlling
    the way variable (at least) marshaling works, by using or adding the so-called
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'During marshalling, in fact, jBPM delegates the serialization of process and
    task variables to strategy classes; jBPM ships with some ready-to-use strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.drools.core.marshalling.impl.SerializablePlaceholderResolverStrategy`:
    Features default Java serialization on objects implementing the `Serializable`
    interface. jBPM adds this strategy by default to the list of enabled strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.drools.persistence.jpa.marshaller.JPAPlaceholderResolverStrategy`: A strategy
    that manages variables as entities to and from a JPA-persistent store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.jbpm.document.marshalling.DocumentMarshallingStrategy`: This strategy
    manages marshalling for parameters of the `org.jbpm.document.Document` type. The
    document parameter type is used as the upload file parameter in the KIE Form modeler.
    These features are available with `jbpm-document-6-2-0.Final.jar`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jBPM supports multiple strategies at once; it invokes them sequentially (a chain
    of responsibility patterns) following the order in which they are given when configuring
    the session (more on this in the following section). Each strategy (`ObjectMarshallingStrategy`)
    must specify the objects that it handles (the `accept` method) and provide the
    `marshal` and `unmarshal` methods (see the class diagram ahead).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at how strategies can be configured using a working example
    which uses the jBPM `JPAPlaceholderResolverStrategy` in order to persist our process
    and task variables to our domain database table. Please refer to the `jbpm-marshalling`
    example project for a working marshalling example.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a marshalling strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `jbpm-marshalling` example features a process definition (`rule_marshall.bpmn`),
    which uses an entity class as both the process variable and the task parameter.
    We want the engine to transparently persist our domain variable (the `OrderEntity`
    class) into a new domain database table (the `ORDERENTITY` table). The OrderEntity
    entity class must be added to our persistence unit (check the `persistence.xml`
    project), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We set the marshalling strategies by passing an array of `ObjectMarshallingStrategy`
    to the environment that is used to create KieSession; in the following example
    (the `MarshallTest` example class), we configure the `JPAPlaceholderResolverStrategy`
    and the `SerializablePlaceholderResolverStrategy` strategies (please refer to
    the *RuntimeManager and the engine* section in [Chapter 6](ch06.html "Chapter 6. Core
    Architecture"), *Core Architecture*, for details).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we provided an extended `CustomJPAPlaceholderResolverStrategy`; this
    class extends and delegates all functionalities to the default `JPAPlaceholderResolverStrategy`
    and adds some logging features by sending the relevant information to the console
    during the marshalling process. Its constructor is given `EntityManagerFactory`,
    which has been created from the same persistence unit that the engine is using.
    This means that our entity table will be in the same engine database schema. The
    `ClassObjectMarshallingStrategyAcceptor` instance (used for `SerializablePlaceholderResolverStrategy`)
    performs the logic of accepting (filtering) object instances. Remember to always
    add the `SerializablePlaceholderResolverStrategy` strategy as the last strategy,
    since it's the one used by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a marshalling strategy](img/9578OS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Persisting variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MarshallTest` class is derived from `RuleTaskTest` (see the *Rule start
    event* section in [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*);
    it sets a global session variable and then, creates the process for passing two
    parameters, namely a plain `Order` instance and an `OrderEntity` instance, which
    are then passed to the user task. Upon the completion of the user task, the business
    rule is triggered and the global session variable is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the example jUnit test, we can see how the `marshall` method for
    our strategy class gets called several times before the human task is triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The order entity is first inserted and then, updated several times; in the database
    table, we can see our record.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persisting variables](img/9578OS_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is the strategy''s responsibility to maintain the entity state consistent
    between these calls. After the task completion, the `unmarshall` method gets called
    twice: first when the workitem is loaded from the database before its completion,
    and second when the process instance is loaded from the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'jBPM is open and configurable software. In this chapter, we reviewed three
    core features of the platform, which are commonly extended when tailoring jBPM
    systems to meet specific application requirements: domain processes and custom
    BPMN nodes, custom persistence for process and task variables, and human authorization
    based on custom implementation or legacy systems. The next chapter will provide
    the user with real-world jBPM solutions.'
  prefs: []
  type: TYPE_NORMAL
