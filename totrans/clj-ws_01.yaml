- en: 1\. Hello REPL!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explain the basics of creating Clojure programs. We start
    by getting you familiar with the **Read Eval Print Loop** (**REPL**), where most
    of the experimentation happens when writing code. The REPL also allows you to
    explore code and documentation by yourself, so it is an excellent place to start.
    After the quick dive in the REPL, we describe in more detail how to read and understand
    simple Lisp and Clojure code, which syntax can sometimes appear unsettling. We
    then explore fundamental operators and functions in Clojure, which enable you
    to write and run simple Clojure programs or scripts.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the REPL and work with functions
    in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever ended up entangled in the "spaghetti code" of an object-oriented
    application? Many experienced programmers would say yes, and at some point in
    their journey or career would reconsider the foundation of their programs. They
    might look for a simpler, better alternative to object-oriented programming, and
    Clojure is an appealing choice. It is a functional, concise, and elegant language
    of the Lisp family. Its core is small, and its syntax minimal. It shines because
    of its simplicity, which takes a trained eye to notice and ultimately understand.
    Employing Clojure's more sophisticated building blocks will allow you to design
    and build sturdier applications.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are a seasoned programmer or a novice, hobbyist or professional,
    C# wizard or Haskell ninja, learning a new programming language is challenging.
    It is, however, a highly rewarding experience that will make you an overall better
    programmer. In this book, you will learn by doing and will ramp up your skills
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure is an excellent choice of programming language to learn today. It will
    allow you to work efficiently using a technology built to last. Clojure can be
    used to program pretty much anything: from full-blown client-server applications
    to simple scripts or big data processing jobs. By the end of this book, you will
    have written a modern web application using Clojure and ClojureScript and will
    have all the cards in your hand to start writing your own!'
  prefs: []
  type: TYPE_NORMAL
- en: REPL Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the Clojure **Read Eval Print Loop** (**REPL**), a command-line interface
    that we can use to interact with a running Clojure program. REPL, in the sense
    that it **reads** the user's input (where the user is you, the programmer), **evaluates**
    the input by instantly compiling and executing the code, and **prints** (that
    is, displays) the result to the user. The read-eval-print three-step process repeats
    over and over again (**loop**) until you exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dynamism provided by the REPL allows you to discover and experiment with
    a tight feedback loop: your code is evaluated instantly, and you can adjust it
    until you get it right. Many other programming languages provide interactive shells
    (notably, other dynamic languages such as Ruby or Python), but in Clojure, the
    REPL plays an exceptional and essential role in the life of the developer. It
    is often integrated with the code editor and the line between editing, browsing,
    and executing code blurs toward a malleable development environment similar to
    Smalltalk. But let''s start with the basics.'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout these exercises, you may notice some mentions of Java (for example,
    in the stack trace in the second exercise). This is because Clojure is implemented
    in Java and runs in the **Java Virtual Machine** (**JVM**). Clojure can, therefore,
    benefit from a mature ecosystem (a battle-tested, widely deployed execution platform
    and a plethora of libraries) while still being a cutting-edge technology. Clojure
    is designed to be a hosted language, and another implementation, called ClojureScript,
    allows you to execute Clojure code on any JavaScript runtime (for example, a web
    browser or Node.js). This hosted-language implementation choice allows for a smaller
    community of functional programmers to strive in an industry dominated by Java,
    .NET Core, and JavaScript technologies. Welcome to the Clojure party, where we're
    all having our cake and eating it too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Your First Dance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will perform some basic operations in the REPL. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal and type `clj`. This will start a Clojure REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line is your version of Clojure, which in this example is `1.10.1`.
    Don't worry if your version is different—the exercises we will go through together
    should be compatible with any version of Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second line displays the namespace we are currently in (`user`) and prompts
    for your input. A namespace is a group of things (such as functions) that belong
    together. Everything you create here will be in the `user` namespace by default.
    The `user` namespace can be considered your playground.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your REPL is ready to **read**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try to evaluate an expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Clojure, *literal* strings are created with double quotes, `""`. A literal
    is a notation for representing a fixed value in source code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we type in multiple strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just evaluated two expressions sequentially, and each result is printed
    onto separate lines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s try a bit of arithmetic, for example, `1 + 2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output is not exactly what we expected. Clojure evaluated the three components,
    that is, `1`, `+`, and `2`, *separately*. Evaluating `+` looks strange because
    the `+` symbol is bound to a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A function is a unit of code that performs a specific task. We don't need to
    know more for now except that functions can be called (or invoked) and can take
    some parameters. A function's argument is a term that's used to design the value
    of a parameter, but those terms are often used interchangeably.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To add those numbers, we need to call the `+` function with the arguments `1`
    and `2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Call the `+` function with the arguments `1` and `2` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will soon discover that many basic operations that are usually part of a
    programming language syntax, such as addition, multiplication, comparison, and
    so on, are just simple functions in Clojure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try a few more examples of basic arithmetic. You can even try to pass
    more than two arguments to the following functions, so adding 1 + 2 + 3 together
    would look like `(+ 1 2 3)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other basic arithmetic operators are used in a similar way. Try and type
    the following expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After typing in the preceding examples, you should try a few more by yourself
    – the REPL is here to be experimented with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should now be familiar enough with the REPL to ask the following question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't take it personally – `nil` was the value that was returned by the `println`
    function. The text that was printed by the function was merely a *side effect*
    of this function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`nil` is the Clojure equivalent of "null," or "nothing"; that is, the absence
    of meaningful value. `print` (without a new line) and `println` (with a new line)
    are used to print objects to the standard output, and they return `nil` once they
    are done.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we can combine those operations and print the result of a simple addition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A value of `3` was printed and the value of `nil` was returned by this expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice how we have nested those *forms* (or *expressions*). This is how we
    chain functions in Clojure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit the REPL by pressing *Ctrl* + *D*. The function to exit is `System/exit`,
    which takes the exit code as a parameter. Therefore, you can also type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we discovered the REPL and called Clojure functions to print
    and perform basic arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Getting around in the REPL'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will introduce a few navigational key bindings and commands
    to help you use and survive the REPL. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by opening the REPL again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how you can navigate the history of what was typed earlier and in previous
    sessions by pressing *Ctrl* + *P* (or the *UP* arrow) and *Ctrl* + *N* (or the
    *DOWN* arrow).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can also search (case-sensitive) through the history of the commands you
    have entered: press *Ctrl* + *R* and then `Hello`, which should bring back the
    `Hello` `Again` expression we typed earlier. If you press *Ctrl* + *R* a second
    time, it will cycle through the matches of the search and bring back the very
    first command: `Hello REPL!`. If you press *Enter*, it will bring the expression
    back to the current prompt. Press *Enter* again and it will evaluate it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, evaluate the following expression, which *increments* (adds 1 to) the
    number 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The returned value is 11, which is indeed 10 + 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`*1` is a special variable that is bound to the result of the last expression
    that was evaluated in the REPL. You can evaluate its value by simply typing it
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, `*2` and `*3` are variables bound to the second and third most recent
    values of that REPL session, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also reuse those special variable values within other expressions.
    See if you can follow and type this sequence of commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the values of `*1` and `*2` change as new expressions are evaluated.
    When the REPL is crowded with text, press *Ctrl* + *L* to clear the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Another useful variable that''s available in the REPL is `*e`, which contains
    the result of the last exception. At the moment, it should be `nil` unless you
    generated an error earlier. Let''s trigger an exception voluntarily by dividing
    by zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Evaluating `*e` should contain details about the exception, including the stack
    trace:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Different Clojure implementations may have a slightly different behavior. For
    example, if you tried to divide by 0 in a ClojureScript REPL, it will not throw
    an exception and instead return the "infinity value":'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`cljs.user=> (/ 1 0)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`##Inf`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is to stay consistent with the host platform: the literal number 0 is
    implemented as an integer in Java (and Clojure) but as a floating-point number
    in JavaScript (and ClojureScript). The IEEE Standard for Floating-Point Arithmetic
    (IEEE 754) specifies that division by 0 should return +/- infinity.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `doc`, `find-doc`, and `apropos` functions are essential REPL tools for
    browsing through documentation. Given that you know the name of the function you
    want to use, you can read its documentation with `doc`. Let''s see how it works
    in practice. Start by typing `(doc str)` to read more about the `str` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`doc` prints the fully qualified name of the function (including the namespace)
    on the first line, the possible sets of parameters (or "arities") on the next
    line, and finally the description.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function's fully qualified name is `clojure.core/str`, which means that
    it is in the `clojure.core` namespace. Things defined in `clojure.core` are available
    to your current namespace by default, without you explicitly having to require
    them. This is because they are fundamental components for building your programs,
    and it would be tedious to have to use their full name every time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try to use the `str` function. As the documentation explains, we can
    pass it multiple arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s inspect the documentation of the `doc` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function is in the `clojure.repl` namespace, which is also available by
    default in your REPL environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also look at the documentation of a namespace. As its documentation
    suggests, your final program would typically not use the helpers in the `clojure.repl`
    namespace (for instance, `doc`, `find-doc`, and `apropos`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you don''t know the name of the function, but you have an idea of what
    the description or name may contain, you can search for it with the `find-doc`
    helper. Let''s try and search for the `modulus` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'No luck, but there''s a catch: `find-doc` is case-sensitive, but the good news
    is that we can use a regular expression with the `i` modifier to ignore the case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You don't need to know more about regular expressions for now – you don't even
    have to use them, but it can be useful to ignore the case when searching for a
    function. You can write them with the `#"(?i)text"` syntax, where `text` is anything
    you want to search for.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function we were looking for was `clojure.core/mod`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s make sure it works according to its documentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `apropos` function to search for functions by name, thereby yielding
    a more succinct output. Say we were looking for a function that transforms the
    case of a given string of characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note that this function is in the `clojure.string` namespace, which is
    not referred to by default. You will need to use its full name until we learn
    how to import and refer symbols from other namespaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 1.01: Performing Basic Operations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will print messages and perform some basic arithmetic operations
    in the Clojure REPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the message "`I am not afraid of parentheses`" to motivate yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to
    the following `infix` notation: (1 + 2 + 3) * (10 - 3). You should obtain the
    following result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Print the message "`Well done`!" to congratulate yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 678.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Evaluation of Clojure Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clojure is a dialect of Lisp, a high-level programming language that was designed
    by John McCarthy and first appeared in 1958\. One of the most distinctive features
    of Lisp and its derivatives, or "dialects," is the use of data structures to write
    the source code of programs. The unusual number of parentheses in our Clojure
    programs is a manifestation of this as parentheses are used to create lists.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will focus on the building blocks of Clojure programs, that is, *forms
    and expressions,* and briefly look at how expressions are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The terms "expression" and "form" are often used interchangeably; however,
    according to the Clojure documentation, an expression is a form type: *"Every
    form not handled specially by a special form or macro is considered by the compiler
    to be an expression, which is evaluated to yield a value."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how literals are valid syntax and evaluate to themselves, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have also learned how to invoke functions by using parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is worth noting at this point that comments can be written with "`;`" at
    the beginning of a line. Any line starting with "`;`" will not be evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions are invoked according to the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Take note of the following from the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: The list, denoted by opening and closing parenthesis, `()`, is evaluated to
    a function call (or invocation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When evaluated, the `*` symbol resolves to the function that implements the
    multiplication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`, `3`, and `4` are evaluated to themselves and passed as arguments to the
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the expression you wrote in *Activity 1.01*, *Performing Basic Operations*:
    `(* (+ 1 2 3) (- 10 3))`. It can also help to visualize the expression as a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating this expression consists of reducing the tree, starting with the
    offshoots (the innermost lists): `(* (+ 1 2 3) (- 10 3))` becomes `(* 6 7)`, which
    becomes `42`.'
  prefs: []
  type: TYPE_NORMAL
- en: The term **s-expression** (or symbolic expression) is often used to designate
    those types of expressions. You may come across it again, so it is good to know
    that an s-expression is a data notation for writing data structures and code with
    lists, as we demonstrated previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only used literal scalar types as operands to our operators,
    which hold one value, such as numbers, strings, Booleans, and so on. We''ve only
    used lists to invoke functions and not to represent data. Let''s try to create
    a list that represents data but not "code":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: An exception was thrown because the first item of the list (the operator) was
    not a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a special syntax to prevent the list from being considered as the
    invocation of a function: the quote. Creating a literal list is done by adding
    a quotation `''`, in front of it, so let''s try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Great! By preventing the evaluation of the form, we can now write a literal
    representation of lists.
  prefs: []
  type: TYPE_NORMAL
- en: This concept will help us get ready for what we are going to cover next. It
    is, however, fascinating to notice at this point that Clojure code is made up
    of data structures, and our programs can generate those same data structures.
    "Code is data" is a famous saying in the Lisp world, and a powerful concept that
    allows your program to generate code (known as **meta-programming**). If you are
    new to this concept, it is worth pausing for a minute to think and admire the
    sheer beauty of it. We will explain meta-programming techniques in detail later
    when explaining *macros* in *Chapter 11*, *Macros*.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Special Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been writing code that complies with the simplest rules of evaluating
    Clojure code, but there are some behaviors that cannot simply be encoded with
    normal functions. For example, arguments that have been passed to a function will
    always be resolved or evaluated, but what if we do not want to evaluate all the
    operands of an operator? That is when special forms come into play. They can have
    different evaluation rules for functions when the source code is read by Clojure.
    For example, the special form `if`, may not evaluate one of its arguments, depending
    on the result of the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other special forms that we will go through in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`when`, which can be used when we are only interested in the case of a condition
    being *truthy* (a value is *truthy* when considered true in the context of a Boolean
    expression).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do`, which can be used to execute a series of expressions and return the value
    of the last expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`def` and `let`, which are special forms that are used to create global and
    local bindings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fn` and `defn`, which are special forms that are used to create functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these special forms have special evaluation rules, all of which we will
    discover by working through the following three exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Working with if, do, and when'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will evaluate expressions using the `if`, `do`, and `when`
    forms. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your REPL and type in the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The special form `if`, evaluates its first argument. If its value is truthful,
    it will evaluate argument `2`, otherwise (`else`), it will evaluate argument 3\.
    It will never evaluate both arguments 2 and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can nest expressions and start doing more interesting things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, the computation of `(+ 3 4)` will not be executed, and only a
    random number (between 0 and 1) will be returned by the `rand` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But what if we wanted to do more than one thing in our branch of the condition?
    We could wrap our operation with `do`. Let''s see how `do` works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the special form, `do` type the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the expressions before the final `(+ 1 1)` expression were evaluated, but
    only the value of the last one is returned. This does not look very useful with
    expressions that don't alter the state of the world, and so it would typically
    be used for side effects such as logging or any other kind of I/O (filesystem
    access, database query, network request, and so on).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You don''t have to take my word for it, so let''s experiment with the side
    effect of printing to the Terminal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can combine the use of `if` and `do` to execute multiple operations
    in a conditional branching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Technically, you could also omit the third argument. Bring back the previous
    expression in the REPL and remove the last expression, that is, `(+ 1 2)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have a better construct available for this case: the `when` operator. Instead
    of combining `if` and `do`, when you are only interested in doing work in one
    branch of the conditional execution, use `when`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following expression to use `when` instead of a combination of `if`
    and `do`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By completing this exercise, we have demonstrated the usage of the special forms
    known as `if`, `do`, and `when`. We can now write expressions that contain multiple
    statements, as well as conditional expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Clojure, we use the term *bindings* rather than *variables* and *assignments*
    because we tend to bind a value to a symbol only once. Under the hood, Clojure
    creates *variables* and so you may encounter this term, but it would be preferable
    if you don't think of them as classic *variables* or values that can change. We
    won't use the term variable anymore in this chapter as it can be confusing. You
    can use `def` to define global bindings and `let` for local bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Using def and let'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate the usage of the `def` and `let` keywords,
    which are used to create bindings. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The special form `def` allows you to bind a value to a symbol. In the REPL,
    type the following expression to bind the value `10` to the `x` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the REPL returns `#'user/x`, it is returning a reference to the var you
    have just created. The user part indicates the namespace where the var is defined.
    The `#'` prefix is a way of quoting the var so that we see the symbol and not
    the value of the symbol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the expression, `x`, which will resolve the `x` symbol to its value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Technically, you can change the binding, which is fine when experimenting in
    the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is, however, not recommended in your programs because it can make it hard
    to read and complicate its maintenance. For now, it would be better if you just
    consider such a binding as a *constant.*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use the `x` symbol within another expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wherever `def` is invoked, it will bind the value to the symbol in the current
    namespace. We could try to define a local binding in a `do` block and see what
    happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The bindings that are created by `def` have an indefinite scope (or dynamic
    scope) and can be considered as "global." They are automatically namespaced, which
    is a useful trait to avoid clashing with existing names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we want to have a binding available only to a local scope or lexical scope,
    we can use the special form `let`. Type the following expression to create a lexical
    binding of the `y` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`let` takes a "vector" as a parameter to create the local bindings, and then
    a series of expressions that will be evaluated like they are in a `do` block.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A vector is similar to a list, in the sense that they both are a sequential
    collection of values. Their underlying data structure is different, and we will
    shed light on this in *Chapter 2*, *Data Types and Immutability*. For now, you
    just need to know that vectors can be created with square brackets, for example,
    `[1 2 3 4]`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the `y` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An error is thrown, that is, `Unable to resolve symbol: y in this context`,
    because we are now outside of the `let` block.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following expression to create a lexical binding of `x` to the value
    `3`, and see how it affects the indefinite (global) binding of `x` that we created
    in *step 4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Printing `x` yields the value `3`, which means that the "global" `x` symbol
    was temporarily overridden or "shadowed" by the lexical context in which `println`
    was invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create multiple local bindings at once with `let` by passing an even
    number of items in the vector. Type the following expression to bind `x` to `10`
    and `y` to `20`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Combine the concepts of this section and write the following expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expression spans over multiple lines to improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Creating Simple Functions with fn and defn'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special form that''s used to define functions is `fn`. Let''s jump right
    into it by creating our first function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following expression in your REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have just created the simplest anonymous function, which takes no parameters
    and does nothing, and we returned an object, which is our function with no name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function that takes a parameter named `x` and return its square value
    (multiply it by itself):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember that, in Clojure, the first item of an expression will be invoked,
    so we can call our anonymous function by wrapping it with parentheses and providing
    an argument as the second item of the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now this is great, but not very convenient. If we wanted our function to be
    reusable or testable, it would be better for it to have a name. We can create
    a symbol in the namespace and bind it to the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `def` to bind the function returned by the special form, `fn`, to the `square`
    symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke your newly created function to make sure that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This pattern of combining `def` and `fn` is so common that a built-in *macro*
    was born out of necessity: `defn`. Recreate the square function with `defn` instead
    of `def` and `fn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Did you notice that the `x` argument was passed in a vector? We have already
    learned that vectors are collections, and so we can add more than one symbol to
    the argument's vector. The values that are passed when calling the function will
    be bound to the symbols provided in the vector during the function's definition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Functions can take multiple arguments, and their bodies can be composed of
    multiple expressions (such as an implicit `do` block). Create a function with
    the name `meditate` that takes two arguments: a string, `s`, and a Boolean, `calm`.
    The function will print an introductory message and return a transformation of
    `s` based on `calm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Editing multiline expressions in the REPL can be cumbersome. As we start creating
    lengthier functions and expressions that span multiple lines, it would be preferable
    to have a window of your favorite editor open next to your REPL window. Keep those
    windows side by side, edit the code in your editor, copy it to your clipboard,
    and paste it into your REPL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function body contains two main expressions, the first of which is a side
    effect with `println` and the second of which is the `if` block, which will determine
    the return value. If `calm` is `true`, it will politely return the string capitalized
    (with the first character converted into uppercase), otherwise it will shout and
    return the string with all its characters to uppercase, ending with an exclamation
    mark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try and make sure that our function works as intended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we call the function with only the first parameter, it will throw an exception.
    This is because the parameters that we have defined are required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One last thing to end our initial tour of these functions is the `doc-string`
    parameter. When provided to `defn`, it will allow you to add a description of
    your function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add documentation to your `square` function by adding a doc-string just before
    the function arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The doc-string is not only useful when browsing a project's source code – it
    also makes it available to the `doc` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look up the documentation of your `square` function with `doc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to remember that the doc-string needs to come before the function
    arguments. If it comes after, the string will be evaluated sequentially as part
    of the function body and won't throw an error. It is valid syntax, but it will
    not be available in the `doc` helper and other development tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is good practice to document the arguments with backticks, `` ` ``, like
    we did with `` `x` ``, so that development tools (such as the IDE) can recognize
    them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will take a deeper dive into functions in *Chapter 3*, *Functions in Depth*,
    but these few basic principles will get you a long way in terms of writing functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carbon dioxide (CO2) is an important heat-trapping (greenhouse) gas, currently
    rising and threatening life as we know it on our planet. We would like to predict
    future levels of CO2 in the atmosphere based on historical data provided by **National
    Oceanic and Atmospheric Administration** (**NOAA**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: CO2 parts per million (ppm) over the years'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: CO2 parts per million (ppm) over the years'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding chart was taken from [https://packt.live/35kUI7L](https://packt.live/35kUI7L)
    and the data was taken from NOAA.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the year 2006 as a starting point with a CO2 level of 382 ppm and
    calculate the estimate using a simplified (and optimistic) linear function, as follows: *Estimate
    = 382 + ((Year - 2006) * 2)*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `co2-estimate` that takes one integer parameter called
    `year` and returns the estimated level of CO2 ppm for that year.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, define two constants, `base-co2` and `base-year`, with the values
    382 and 2006, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, write the code to define the `co2-estimate` function without
    forgetting to document it with the doc-string parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be tempted to write the function body in a single line but nesting a
    lot of function calls decreases the readability of the code. It is also easier
    to reason about each step of the process by decomposing them in a `let` block.
    Write the body of the function using `let` to define the local binding `year-diff`,
    which is the subtraction of 2006 from the `year` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your function by evaluating `(co2-estimate 2050)`. You should get `470`
    as the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the documentation of your function with `doc` and make sure that it
    has been defined correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 679.
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness, nil, and equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have been using conditional expressions intuitively, possibly
    on the basis of how they usually work with other programming languages. In this
    final section, we will review and explain Boolean expressions and the related
    comparison functions in detail, starting with `nil` and truthiness in Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: '`nil` is a value that represents the absence of value. It is also often called
    `NULL` in other programming languages. Representing the absence of value is useful
    because it means that something is missing.'
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, `nil` is "falsey," which means that `nil` behaves like `false` when
    evaluated in a Boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`false` and `nil` are the only values that are treated as *falsey* in Clojure;
    everything else is truthy. This simple rule is a blessing (especially if you are
    coming from a language such as JavaScript) and makes our code more readable and
    less error-prone. Perhaps it''s just that Clojure was not out yet when Oscar Wilde
    wrote, "The truth is rarely pure and never simple."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: The Truth Is Simple'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate how to work with Boolean values in conditional
    expressions. We will also see how to play around with the logical operators in
    conditional expressions. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by verifying that `nil` and `false` are indeed `falsey`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In other programming languages, it is common for more values to resolve to
    `false` in Boolean expressions. But in Clojure, remember that only `nil` and `false`
    are *falsey*. Let''s try a few examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to know whether something is exactly `true` or `false`, and not
    just `truthy` or `falsey`, we can use the `true?` and `false?` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `?` character has no special behavior – it is just a naming convention for
    functions that return a Boolean value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, if we want to know that something is `nil` and not just `falsey`,
    we can use the `nil?` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember that `println` returns `nil`, and so the last piece of output in the
    preceding code is `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boolean expressions become interesting when they are composed together. Clojure
    provides the usual suspects, that is, `and` and `or`. At this point, we are only
    interested in *logical* `and` and *logical* `or`. If you are looking to play around
    with `bitwise` operators, you can easily find them with the `(find-doc "bit-")`
    command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`and` returns the first *falsey* value that it encounters (from left to right)
    and will not evaluate the rest of the expression when that is the case. When all
    the values passed to `and` are *truthy*, `and` will return the last value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with the `and` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s been generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s use `println` and make sure that not all the expressions are evaluated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`and` evaluated the first expression, which printed `Hello` and returned `nil`,
    which is *falsey*. Therefore, the second expression was not evaluated, and `Goodbye`
    was not printed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`or` works in a similar fashion: it will return the first *truthy* value that
    it comes across and it will not evaluate the rest of the expression when that
    is the case. When all the values that are passed to `or` are *falsey*, `or` will
    return the last value.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with the `or` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once again, we can use `println` to make sure that the expressions are not
    all evaluated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`or` evaluated the first expression `true` and returned it. Therefore, the
    second expression was not evaluated, and `Hello` was not printed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Equality and Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most imperative programming languages, the `=` symbol is used for variable
    assignments. As we've seen already, in Clojure, we have `def` and `let` to bind
    names with values. The `=` symbol is a function for equality and will return `true`
    if all its arguments are equal. As you may have guessed by now, the other common
    comparison functions are implemented as functions. `>`, `>=`, `<`, `<=`, and `=`
    are not special syntax and you may have developed the intuition for using them
    already.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Comparing Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this final exercise, we will go through the different ways of comparing
    values in Clojure. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: First, start your REPL if it is not running yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following expressions to compare two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can pass multiple arguments to the `=` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In that case, even though the first three arguments are equal, the last one
    isn't, so the `=` function returns `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `=` operator is not only used to compare numbers, but other types as well.
    Evaluate some of the following expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Java or other object-oriented programming languages, comparing things usually
    checks whether they are the exact same instance of an object stored in memory,
    that is, their identity. However, comparisons in Clojure are made by equality
    rather than identity. Comparing values is generally more useful, and Clojure makes
    it convenient, but if you ever wanted to compare identities, you could do so by
    using the `identical?` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Maybe more surprisingly, but sequences of different types can be considered
    equal as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The list `1` `2` `3` is equivalent to the vector `1` `2` `3` . Collections and
    sequences are powerful Clojure abstractions that will be presented in *Chapter
    2*, *Data Types and Immutability*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the `=` function can also take one argument, in
    which case it will always return `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The other comparison operators, that is, `>`, `>=`, `<`, and `<=`, can only
    be used with numbers. Let's start with `<` and `>`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<` returns `true` if all its arguments are in a strictly increasing order.
    Try to evaluate the following expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that `10` followed by `10` is not strictly increasing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<=` is similar, but adjacent arguments can be equal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`>` and `>=` have a similar behavior and return `true` when their arguments
    are in a decreasing order. `>=` allows adjacent arguments to be equal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `not` operator is a useful function that returns `true` when its
    argument is *falsey* (`nil` or `false`), and `false` otherwise. Let''s try an
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To put things together, let''s consider the following JavaScript code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code snippet prints `Valid` when a number, `x`, is included between 1 and
    100 or if `x` is a multiple of 100\. Otherwise, it prints `Invalid`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to translate this to Clojure code, we would write the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We may have a few more parentheses in the Clojure code, but you could argue
    that Clojure is more readable than the imperative JavaScript code. It contains
    less specific syntax, and we don't need to think about operator precedence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to transform the JavaScript code using an "inline if," we would
    introduce new syntax with `?` and `:`, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Clojure code would become the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that there is no new syntax, and nothing new to learn. You already know
    how to read lists, and that is all you will (almost) ever need.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple example demonstrates the great flexibility of `lists`: the building
    blocks of Clojure and other Lisp languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.03: The meditate Function v2.0'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will improve the `meditate` function we wrote in *Exercise
    1.05*, *Creating Simple Functions with fn and defn*, by replacing the `calm` Boolean
    argument with `calmness-level`. The function will print a transformation of the
    string passed as a second argument based on the calmness level. The specifications
    of the function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`calmness-level` is a number between `1` and `10`, but we will not check the
    input for errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is strictly inferior to `5`, we consider the user to be
    angry. The function should return the `s` string transformed to uppercase concatenated
    with the string "`, I TELL YA!`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is between `5` and `9`, we consider the user to be calm
    and relaxed. The function should return the `s` string with only its first letter
    capitalized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is `10`, the user has reached nirvana, and is being possessed
    by the Clojure gods. In its trance, the user channels the incomprehensible language
    of those divine entities. The function should return the `s` string in reverse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hint
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `str` function to concatenate a string and `clojure.string/reverse`
    to reverse a string. If you are not sure how to use them, you can look up their
    documentation with `doc` (for example, `(doc clojure.string/reverse)`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, define a function with the name `meditate`, taking two arguments,
    `calmness-level` and `s`, without forgetting to write its documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function body, start by writing an expression that prints the string,
    `Clojure Meditate v2.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the specification, write the first condition to test whether the calmness
    level is strictly inferior to `5`. Write the first branch of the conditional expression
    (the `then`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the second condition, which should be nested in the second branch of the
    first condition (the `else`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the third condition, which should be nested in the second branch of the
    second condition. It will check that `calmness-level` is exactly `10` and return
    the reverse of the `s` string when that is the case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your function by passing a string with different levels of calmness. The
    output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have been using the `and` operator to find whether a number was between
    two other numbers, rewrite your function to remove it and only use the `<=` operator.
    Remember that `<=` can take more than two arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the `cond` operator in the documentation and rewrite your function to
    replace the nested conditions with `cond`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 680.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to use the REPL and its helpers. You are
    now able to search and discover new functions and look up their documentation
    interactively in the REPL. We learned how Clojure code is evaluated, as well as
    how to use and create functions, bindings, conditionals, and comparisons. These
    allow you to create simple programs and scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at data types, including collections, and
    the concept of immutability.
  prefs: []
  type: TYPE_NORMAL
