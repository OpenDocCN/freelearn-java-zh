- en: 1\. Hello REPL!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Hello REPL！
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explain the basics of creating Clojure programs. We start
    by getting you familiar with the **Read Eval Print Loop** (**REPL**), where most
    of the experimentation happens when writing code. The REPL also allows you to
    explore code and documentation by yourself, so it is an excellent place to start.
    After the quick dive in the REPL, we describe in more detail how to read and understand
    simple Lisp and Clojure code, which syntax can sometimes appear unsettling. We
    then explore fundamental operators and functions in Clojure, which enable you
    to write and run simple Clojure programs or scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们解释了创建 Clojure 程序的基础。我们首先让你熟悉 **读取求值打印循环**（**REPL**），在编写代码时，大部分实验都是在 REPL
    中进行的。REPL 还允许你自己探索代码和文档，因此它是一个极佳的起点。在快速了解 REPL 之后，我们将更详细地描述如何阅读和理解简单的 Lisp 和 Clojure
    代码，其语法有时可能显得令人不安。然后，我们探索 Clojure 中的基本运算符和函数，这些运算符和函数使你能够编写和运行简单的 Clojure 程序或脚本。
- en: By the end of this chapter, you will be able to use the REPL and work with functions
    in Clojure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够使用 REPL 并在 Clojure 中处理函数。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Have you ever ended up entangled in the "spaghetti code" of an object-oriented
    application? Many experienced programmers would say yes, and at some point in
    their journey or career would reconsider the foundation of their programs. They
    might look for a simpler, better alternative to object-oriented programming, and
    Clojure is an appealing choice. It is a functional, concise, and elegant language
    of the Lisp family. Its core is small, and its syntax minimal. It shines because
    of its simplicity, which takes a trained eye to notice and ultimately understand.
    Employing Clojure's more sophisticated building blocks will allow you to design
    and build sturdier applications.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经陷入面向对象应用程序的“意大利面代码”中？许多经验丰富的程序员会说是的，在他们的人生旅程或职业生涯的某个时刻，他们可能会重新考虑他们程序的基础。他们可能会寻找一个更简单、更好的面向对象编程的替代方案，而
    Clojure 就是一个吸引人的选择。它是 Lisp 家族中的一种功能性强、简洁优雅的语言。它的核心很小，语法也很简单。它因其简单性而闪耀，这种简单性需要经过训练的眼睛才能注意到，最终才能理解。使用
    Clojure 更为复杂的构建块将允许你设计和构建更坚固的应用程序。
- en: Whether you are a seasoned programmer or a novice, hobbyist or professional,
    C# wizard or Haskell ninja, learning a new programming language is challenging.
    It is, however, a highly rewarding experience that will make you an overall better
    programmer. In this book, you will learn by doing and will ramp up your skills
    quickly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是经验丰富的程序员还是新手，爱好者还是专业人士，C# 大师还是 Haskell 高手，学习一门新的编程语言都是一项挑战。然而，这却是一种高度有益的经历，它将使你成为一个更好的程序员。在这本书中，你将通过实践来学习，并且能够快速提升你的技能。
- en: 'Clojure is an excellent choice of programming language to learn today. It will
    allow you to work efficiently using a technology built to last. Clojure can be
    used to program pretty much anything: from full-blown client-server applications
    to simple scripts or big data processing jobs. By the end of this book, you will
    have written a modern web application using Clojure and ClojureScript and will
    have all the cards in your hand to start writing your own!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是今天学习编程语言的一个极佳选择。它将允许你使用一种旨在持久的技术来高效工作。Clojure 可以用来编写几乎任何东西：从完整的客户端-服务器应用程序到简单的脚本或大数据处理任务。到这本书结束时，你将使用
    Clojure 和 ClojureScript 编写了一个现代网络应用程序，并将拥有所有启动你自己的应用程序所需的牌面！
- en: REPL Basics
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL 基础
- en: Welcome to the Clojure **Read Eval Print Loop** (**REPL**), a command-line interface
    that we can use to interact with a running Clojure program. REPL, in the sense
    that it **reads** the user's input (where the user is you, the programmer), **evaluates**
    the input by instantly compiling and executing the code, and **prints** (that
    is, displays) the result to the user. The read-eval-print three-step process repeats
    over and over again (**loop**) until you exit the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 Clojure 的 **读取求值打印循环**（**REPL**），这是一个命令行界面，我们可以用它与运行的 Clojure 程序进行交互。REPL
    在这个意义上是 **读取**用户的输入（用户就是你，程序员），通过即时编译和执行代码来**评估**输入，并将结果**打印**（即显示）给用户。读取-评估-打印的三步过程会不断重复（**循环**），直到你退出程序。
- en: 'The dynamism provided by the REPL allows you to discover and experiment with
    a tight feedback loop: your code is evaluated instantly, and you can adjust it
    until you get it right. Many other programming languages provide interactive shells
    (notably, other dynamic languages such as Ruby or Python), but in Clojure, the
    REPL plays an exceptional and essential role in the life of the developer. It
    is often integrated with the code editor and the line between editing, browsing,
    and executing code blurs toward a malleable development environment similar to
    Smalltalk. But let''s start with the basics.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: REPL 提供的动态性允许你发现和实验一个紧密的反馈循环：你的代码被即时评估，你可以调整它直到正确为止。许多其他编程语言提供了交互式外壳（特别是其他动态语言，如
    Ruby 或 Python），但在 Clojure 中，REPL 在开发者的生活中扮演着非凡和至关重要的角色。它通常与代码编辑器集成，编辑、浏览和执行代码之间的界限模糊，类似于
    Smalltalk 的可塑开发环境。但让我们从基础知识开始。
- en: Throughout these exercises, you may notice some mentions of Java (for example,
    in the stack trace in the second exercise). This is because Clojure is implemented
    in Java and runs in the **Java Virtual Machine** (**JVM**). Clojure can, therefore,
    benefit from a mature ecosystem (a battle-tested, widely deployed execution platform
    and a plethora of libraries) while still being a cutting-edge technology. Clojure
    is designed to be a hosted language, and another implementation, called ClojureScript,
    allows you to execute Clojure code on any JavaScript runtime (for example, a web
    browser or Node.js). This hosted-language implementation choice allows for a smaller
    community of functional programmers to strive in an industry dominated by Java,
    .NET Core, and JavaScript technologies. Welcome to the Clojure party, where we're
    all having our cake and eating it too.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些练习中，你可能会注意到一些关于 Java 的提及（例如，在第二个练习的堆栈跟踪中）。这是因为 Clojure 是用 Java 实现的，并在 **Java
    虚拟机**（**JVM**）上运行。因此，Clojure 可以从成熟的生态系统（经过实战检验、广泛部署的执行平台和大量的库）中受益，同时仍然是一个前沿技术。Clojure
    被设计为托管语言，另一个名为 ClojureScript 的实现允许你在任何 JavaScript 运行时（例如，网页浏览器或 Node.js）上执行 Clojure
    代码。这种托管语言实现的选择允许较小的函数式程序员社区在由 Java、.NET Core 和 JavaScript 技术主导的行业中努力。欢迎来到 Clojure
    舞会，在这里我们都在享受我们的蛋糕并吃掉它。
- en: 'Exercise 1.01: Your First Dance'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：你的第一次舞蹈
- en: 'In this exercise, we will perform some basic operations in the REPL. Let''s
    get started:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在 REPL 中执行一些基本操作。让我们开始吧：
- en: 'Open Terminal and type `clj`. This will start a Clojure REPL:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入 `clj`。这将启动一个 Clojure REPL：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line is your version of Clojure, which in this example is `1.10.1`.
    Don't worry if your version is different—the exercises we will go through together
    should be compatible with any version of Clojure.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一行是 Clojure 的版本，在这个例子中是 `1.10.1`。如果你的版本不同，请不要担心——我们将一起进行的练习应该与任何版本的 Clojure
    兼容。
- en: The second line displays the namespace we are currently in (`user`) and prompts
    for your input. A namespace is a group of things (such as functions) that belong
    together. Everything you create here will be in the `user` namespace by default.
    The `user` namespace can be considered your playground.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二行显示了当前所在的命名空间（`user`）并提示输入。命名空间是一组属于一起的事物（例如函数）。在这里创建的任何内容都将默认位于 `user` 命名空间中。`user`
    命名空间可以被视为你的游乐场。
- en: Your REPL is ready to **read**.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的 REPL 已经准备好**读取**。
- en: 'Let''s try to evaluate an expression:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试评估一个表达式：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as follows:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Clojure, *literal* strings are created with double quotes, `""`. A literal
    is a notation for representing a fixed value in source code.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Clojure 中，*字面量*字符串使用双引号创建，`""`。字面量是在源代码中表示固定值的一种表示法。
- en: 'Let''s see what happens if we type in multiple strings:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如果我们输入多个字符串会发生什么：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have just evaluated two expressions sequentially, and each result is printed
    onto separate lines.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经连续评估了两个表达式，并且每个结果都打印到了单独的行上。
- en: 'Now, let''s try a bit of arithmetic, for example, `1 + 2`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些算术运算，例如 `1 + 2`：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The output is not exactly what we expected. Clojure evaluated the three components,
    that is, `1`, `+`, and `2`, *separately*. Evaluating `+` looks strange because
    the `+` symbol is bound to a function.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出并不完全符合我们的预期。Clojure 对三个组件进行了评估，即 `1`、`+` 和 `2`，*分别* 进行评估。评估 `+` 看起来很奇怪，因为
    `+` 符号绑定了一个函数。
- en: Note
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A function is a unit of code that performs a specific task. We don't need to
    know more for now except that functions can be called (or invoked) and can take
    some parameters. A function's argument is a term that's used to design the value
    of a parameter, but those terms are often used interchangeably.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数是执行特定任务的代码单元。我们现在不需要了解更多，除了函数可以被调用（或调用）并且可以接受一些参数。函数的参数是一个术语，用于设计参数的值，但这些术语通常可以互换使用。
- en: To add those numbers, we need to call the `+` function with the arguments `1`
    and `2`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要添加这些数字，我们需要调用`+`函数，并传入参数`1`和`2`。
- en: 'Call the `+` function with the arguments `1` and `2` as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式调用`+`函数，并传入参数`1`和`2`：
- en: '[PRE8]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will soon discover that many basic operations that are usually part of a
    programming language syntax, such as addition, multiplication, comparison, and
    so on, are just simple functions in Clojure.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你很快就会发现，许多通常是编程语言语法一部分的基本操作，比如加法、乘法、比较等，在Clojure中只是简单的函数。
- en: 'Let''s try a few more examples of basic arithmetic. You can even try to pass
    more than two arguments to the following functions, so adding 1 + 2 + 3 together
    would look like `(+ 1 2 3)`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试更多基本算术的示例。你甚至可以尝试向以下函数传递超过两个参数，所以将1 + 2 + 3相加将看起来像`(+ 1 2 3)`：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The other basic arithmetic operators are used in a similar way. Try and type
    the following expressions:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他基本算术运算符的使用方式类似。尝试输入以下表达式：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After typing in the preceding examples, you should try a few more by yourself
    – the REPL is here to be experimented with.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在输入前面的示例之后，你应该尝试更多自己输入的内容——REPL就是为了实验而存在的。
- en: 'You should now be familiar enough with the REPL to ask the following question:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该足够熟悉REPL，可以提出以下问题：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Don't take it personally – `nil` was the value that was returned by the `println`
    function. The text that was printed by the function was merely a *side effect*
    of this function.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要个人化——`nil`是`println`函数返回的值。该函数打印的文本仅仅是这个函数的*副作用*。
- en: '`nil` is the Clojure equivalent of "null," or "nothing"; that is, the absence
    of meaningful value. `print` (without a new line) and `println` (with a new line)
    are used to print objects to the standard output, and they return `nil` once they
    are done.'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`nil`是Clojure中“null”或“nothing”的等价物；也就是说，没有有意义的价值。`print`（不带换行符）和`println`（带换行符）用于将对象打印到标准输出，并在完成后返回`nil`。'
- en: 'Now, we can combine those operations and print the result of a simple addition:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以组合这些操作并打印简单加法的结果：
- en: '[PRE13]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A value of `3` was printed and the value of `nil` was returned by this expression.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该表达式打印了一个值为`3`，并返回了`nil`值。
- en: 'Notice how we have nested those *forms* (or *expressions*). This is how we
    chain functions in Clojure:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意我们是如何嵌套那些*形式*（或*表达式*）。这就是我们在Clojure中链式调用函数的方式：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Exit the REPL by pressing *Ctrl* + *D*. The function to exit is `System/exit`,
    which takes the exit code as a parameter. Therefore, you can also type the following:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Ctrl* + *D*退出REPL。退出函数是`System/exit`，它接受退出码作为参数。因此，你也可以输入以下内容：
- en: '[PRE15]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this exercise, we discovered the REPL and called Clojure functions to print
    and perform basic arithmetic operations.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们发现了REPL并调用了Clojure函数来打印和执行基本的算术操作。
- en: 'Exercise 1.02: Getting around in the REPL'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：在REPL中导航
- en: 'In this exercise, we will introduce a few navigational key bindings and commands
    to help you use and survive the REPL. Let''s get started:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍一些导航快捷键和命令，帮助你使用并生存于REPL中。让我们开始吧：
- en: Start by opening the REPL again.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先再次打开REPL。
- en: Notice how you can navigate the history of what was typed earlier and in previous
    sessions by pressing *Ctrl* + *P* (or the *UP* arrow) and *Ctrl* + *N* (or the
    *DOWN* arrow).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意你可以通过按*Ctrl* + *P*（或*UP*箭头）和*Ctrl* + *N*（或*DOWN*箭头）来导航之前输入的内容和之前的会话历史。
- en: 'You can also search (case-sensitive) through the history of the commands you
    have entered: press *Ctrl* + *R* and then `Hello`, which should bring back the
    `Hello` `Again` expression we typed earlier. If you press *Ctrl* + *R* a second
    time, it will cycle through the matches of the search and bring back the very
    first command: `Hello REPL!`. If you press *Enter*, it will bring the expression
    back to the current prompt. Press *Enter* again and it will evaluate it.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以搜索（区分大小写）你输入的命令历史：按 *Ctrl* + *R* 然后输入 `Hello`，这应该会带回到我们之前输入的 `Hello Again`
    表达式。如果你再次按 *Ctrl* + *R*，它将遍历搜索的匹配项并带回到第一个命令：`Hello REPL!`。如果你按 *Enter*，它将表达式带回到当前提示符。再次按
    *Enter* 将评估它。
- en: 'Now, evaluate the following expression, which *increments* (adds 1 to) the
    number 10:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，评估以下表达式，该表达式将数字 10 *增加*（加 1）：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The returned value is 11, which is indeed 10 + 1.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回的值是 11，这确实是 10 + 1。
- en: '`*1` is a special variable that is bound to the result of the last expression
    that was evaluated in the REPL. You can evaluate its value by simply typing it
    like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`*1` 是一个特殊变量，它绑定到在 REPL 中评估的最后表达式的结果。你可以通过简单地像这样输入它来评估它的值：'
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Similarly, `*2` and `*3` are variables bound to the second and third most recent
    values of that REPL session, respectively.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，`*2` 和 `*3` 分别绑定到该 REPL 会话中第二和第三最近的价值。
- en: 'You can also reuse those special variable values within other expressions.
    See if you can follow and type this sequence of commands:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在其他表达式中重用这些特殊的变量值。看看你是否能跟随并输入以下命令序列：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the values of `*1` and `*2` change as new expressions are evaluated.
    When the REPL is crowded with text, press *Ctrl* + *L* to clear the screen.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `*1` 和 `*2` 的值是如何随着新表达式的评估而变化的。当 REPL 中文本很多时，按 *Ctrl* + *L* 清屏。
- en: 'Another useful variable that''s available in the REPL is `*e`, which contains
    the result of the last exception. At the moment, it should be `nil` unless you
    generated an error earlier. Let''s trigger an exception voluntarily by dividing
    by zero:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中还可用的一个有用变量是 `*e`，它包含最后一个异常的结果。目前，它应该是 `nil`，除非你之前生成了错误。让我们通过除以零来自愿触发一个异常：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Evaluating `*e` should contain details about the exception, including the stack
    trace:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估 `*e` 应该包含有关异常的详细信息，包括堆栈跟踪：
- en: '[PRE20]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'Different Clojure implementations may have a slightly different behavior. For
    example, if you tried to divide by 0 in a ClojureScript REPL, it will not throw
    an exception and instead return the "infinity value":'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同的 Clojure 实现可能会有略微不同的行为。例如，如果你在一个 ClojureScript REPL 中尝试除以 0，它不会抛出异常，而是返回“无穷大”值：
- en: '`cljs.user=> (/ 1 0)`'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`cljs.user=> (/ 1 0)`'
- en: '`##Inf`'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`##Inf`'
- en: 'This is to stay consistent with the host platform: the literal number 0 is
    implemented as an integer in Java (and Clojure) but as a floating-point number
    in JavaScript (and ClojureScript). The IEEE Standard for Floating-Point Arithmetic
    (IEEE 754) specifies that division by 0 should return +/- infinity.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是为了保持与主机平台的一致性：字面数字 0 在 Java（和 Clojure）中实现为整数，但在 JavaScript（和 ClojureScript）中实现为浮点数。IEEE
    浮点算术标准（IEEE 754）指定除以 0 应该返回 +/- 无穷大。
- en: 'The `doc`, `find-doc`, and `apropos` functions are essential REPL tools for
    browsing through documentation. Given that you know the name of the function you
    want to use, you can read its documentation with `doc`. Let''s see how it works
    in practice. Start by typing `(doc str)` to read more about the `str` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`doc`、`find-doc` 和 `apropos` 函数是浏览文档的必要 REPL 工具。既然你知道你想使用的函数的名称，你可以使用 `doc`
    来阅读它的文档。让我们看看它在实际中的应用。首先，输入 `(doc str)` 来了解更多关于 `str` 函数的信息：'
- en: '[PRE21]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`doc` prints the fully qualified name of the function (including the namespace)
    on the first line, the possible sets of parameters (or "arities") on the next
    line, and finally the description.'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`doc` 在第一行打印函数的完全限定名称（包括命名空间），在下一行打印可能的参数集（或“arity”），最后是描述。'
- en: This function's fully qualified name is `clojure.core/str`, which means that
    it is in the `clojure.core` namespace. Things defined in `clojure.core` are available
    to your current namespace by default, without you explicitly having to require
    them. This is because they are fundamental components for building your programs,
    and it would be tedious to have to use their full name every time.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数的完全限定名称是 `clojure.core/str`，这意味着它在 `clojure.core` 命名空间中。在 `clojure.core`
    中定义的东西默认情况下就可用在你的当前命名空间中，无需你显式地导入它们。这是因为它们是构建程序的基本组件，每次都使用它们的完整名称将会很繁琐。
- en: 'Let''s try to use the `str` function. As the documentation explains, we can
    pass it multiple arguments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `str` 函数。正如文档所解释的，我们可以传递多个参数：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s inspect the documentation of the `doc` function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查 `doc` 函数的文档：
- en: '[PRE23]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is in the `clojure.repl` namespace, which is also available by
    default in your REPL environment.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数位于 `clojure.repl` 命名空间中，它也在你的 REPL 环境中默认可用。
- en: 'You can also look at the documentation of a namespace. As its documentation
    suggests, your final program would typically not use the helpers in the `clojure.repl`
    namespace (for instance, `doc`, `find-doc`, and `apropos`):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以查看命名空间的文档。正如其文档所建议的，你的最终程序通常不会使用 `clojure.repl` 命名空间中的辅助工具（例如，`doc`、`find-doc`
    和 `apropos`）：
- en: '[PRE24]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you don''t know the name of the function, but you have an idea of what
    the description or name may contain, you can search for it with the `find-doc`
    helper. Let''s try and search for the `modulus` operator:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你不知道函数的名称，但你对描述或名称可能包含的内容有一个想法时，你可以使用 `find-doc` 辅助工具来搜索它。让我们尝试搜索 `modulus`
    运算符：
- en: '[PRE25]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'No luck, but there''s a catch: `find-doc` is case-sensitive, but the good news
    is that we can use a regular expression with the `i` modifier to ignore the case:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有成功，但有一个转折：`find-doc` 是区分大小写的，但好消息是我们可以使用带有 `i` 修饰符的正则表达式来忽略大小写：
- en: '[PRE26]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You don't need to know more about regular expressions for now – you don't even
    have to use them, but it can be useful to ignore the case when searching for a
    function. You can write them with the `#"(?i)text"` syntax, where `text` is anything
    you want to search for.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前你不需要了解更多关于正则表达式的知识——你甚至不需要使用它们，但忽略大小写来搜索函数可能很有用。你可以用 `#"(?i)text"` 语法来写它们，其中
    `text` 是你想要搜索的任何内容。
- en: The function we were looking for was `clojure.core/mod`.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们要找的函数是 `clojure.core/mod`。
- en: 'Let''s make sure it works according to its documentation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们确保它按照其文档工作：
- en: '[PRE27]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use the `apropos` function to search for functions by name, thereby yielding
    a more succinct output. Say we were looking for a function that transforms the
    case of a given string of characters:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `apropos` 函数通过名称搜索函数，从而产生更简洁的输出。比如说，我们正在寻找一个转换给定字符字符串的案例的函数：
- en: '[PRE28]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that this function is in the `clojure.string` namespace, which is
    not referred to by default. You will need to use its full name until we learn
    how to import and refer symbols from other namespaces.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，此函数位于 `clojure.string` 命名空间中，默认情况下并未引用。在我们学习如何从其他命名空间导入和引用符号之前，您需要使用其全名。
- en: 'Activity 1.01: Performing Basic Operations'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：执行基本操作
- en: In this activity, we will print messages and perform some basic arithmetic operations
    in the Clojure REPL.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将在 Clojure REPL 中打印消息并执行一些基本的算术运算。
- en: 'These steps will help you complete this activity:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您完成此活动：
- en: Open the REPL.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 REPL。
- en: Print the message "`I am not afraid of parentheses`" to motivate yourself.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息 "`我不怕括号`" 来激励自己。
- en: 'Add 1, 2, and 3 and multiply the result by 10 minus 3, which corresponds to
    the following `infix` notation: (1 + 2 + 3) * (10 - 3). You should obtain the
    following result:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 1、2 和 3 相加，然后将结果乘以 10 减 3，这对应于以下 `中缀` 表示法：(1 + 2 + 3) * (10 - 3)。你应该得到以下结果：
- en: '[PRE29]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Print the message "`Well done`!" to congratulate yourself.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印消息 "`做得好`!" 来祝贺自己。
- en: Exit the REPL.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 REPL。
- en: Note
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 备注
- en: The solution to this activity can be found on page 678.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第 678 页找到。
- en: Evaluation of Clojure Code
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clojure 代码的评估
- en: Clojure is a dialect of Lisp, a high-level programming language that was designed
    by John McCarthy and first appeared in 1958\. One of the most distinctive features
    of Lisp and its derivatives, or "dialects," is the use of data structures to write
    the source code of programs. The unusual number of parentheses in our Clojure
    programs is a manifestation of this as parentheses are used to create lists.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 是 Lisp 的一种方言，一种由 John McCarthy 设计的高级编程语言，首次出现在 1958 年。Lisp 及其衍生品或“方言”的最显著特征之一是使用数据结构来编写程序的源代码。我们
    Clojure 程序中不寻常的括号数量就是这种特征的体现，因为括号用于创建列表。
- en: Here, we will focus on the building blocks of Clojure programs, that is, *forms
    and expressions,* and briefly look at how expressions are evaluated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将关注 Clojure 程序的构建块，即 *形式和表达式*，并简要地看看表达式是如何被评估的。
- en: Note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The terms "expression" and "form" are often used interchangeably; however,
    according to the Clojure documentation, an expression is a form type: *"Every
    form not handled specially by a special form or macro is considered by the compiler
    to be an expression, which is evaluated to yield a value."*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how literals are valid syntax and evaluate to themselves, for
    example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have also learned how to invoke functions by using parentheses:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is worth noting at this point that comments can be written with "`;`" at
    the beginning of a line. Any line starting with "`;`" will not be evaluated:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Functions are invoked according to the following structure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Take note of the following from the preceding example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The list, denoted by opening and closing parenthesis, `()`, is evaluated to
    a function call (or invocation).
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When evaluated, the `*` symbol resolves to the function that implements the
    multiplication.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`, `3`, and `4` are evaluated to themselves and passed as arguments to the
    function.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the expression you wrote in *Activity 1.01*, *Performing Basic Operations*:
    `(* (+ 1 2 3) (- 10 3))`. It can also help to visualize the expression as a tree:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_01_01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Tree representation of the expression, (* (+ 1 2 3) (- 10 3))'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluating this expression consists of reducing the tree, starting with the
    offshoots (the innermost lists): `(* (+ 1 2 3) (- 10 3))` becomes `(* 6 7)`, which
    becomes `42`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The term **s-expression** (or symbolic expression) is often used to designate
    those types of expressions. You may come across it again, so it is good to know
    that an s-expression is a data notation for writing data structures and code with
    lists, as we demonstrated previously.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only used literal scalar types as operands to our operators,
    which hold one value, such as numbers, strings, Booleans, and so on. We''ve only
    used lists to invoke functions and not to represent data. Let''s try to create
    a list that represents data but not "code":'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: An exception was thrown because the first item of the list (the operator) was
    not a function.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a special syntax to prevent the list from being considered as the
    invocation of a function: the quote. Creating a literal list is done by adding
    a quotation `''`, in front of it, so let''s try again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Great! By preventing the evaluation of the form, we can now write a literal
    representation of lists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: This concept will help us get ready for what we are going to cover next. It
    is, however, fascinating to notice at this point that Clojure code is made up
    of data structures, and our programs can generate those same data structures.
    "Code is data" is a famous saying in the Lisp world, and a powerful concept that
    allows your program to generate code (known as **meta-programming**). If you are
    new to this concept, it is worth pausing for a minute to think and admire the
    sheer beauty of it. We will explain meta-programming techniques in detail later
    when explaining *macros* in *Chapter 11*, *Macros*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念将帮助我们为接下来要介绍的内容做好准备。然而，在这个时候注意到 Clojure 代码由数据结构组成，我们的程序可以生成那些相同的数据结构，这是非常迷人的。"代码是数据"
    是 Lisp 世界中的一句名言，这是一个强大的概念，允许你的程序生成代码（称为 **元编程**）。如果你对这个概念还不熟悉，那么花一分钟时间思考和欣赏它的纯粹之美是值得的。我们将在解释
    *第 11 章* 中的 *宏* 时详细解释元编程技术。
- en: Basic Special Forms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本特殊形式
- en: So far, we have been writing code that complies with the simplest rules of evaluating
    Clojure code, but there are some behaviors that cannot simply be encoded with
    normal functions. For example, arguments that have been passed to a function will
    always be resolved or evaluated, but what if we do not want to evaluate all the
    operands of an operator? That is when special forms come into play. They can have
    different evaluation rules for functions when the source code is read by Clojure.
    For example, the special form `if`, may not evaluate one of its arguments, depending
    on the result of the first argument.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在编写符合 Clojure 代码最简单规则的代码，但有一些行为不能简单地用正常函数来编码。例如，传递给函数的参数将始终被解析或评估，但如果我们不想评估运算符的所有操作数呢？这就是特殊形式发挥作用的时候。它们可以在
    Clojure 读取源代码时为函数提供不同的评估规则。例如，特殊形式 `if` 可能不会评估其参数之一，这取决于第一个参数的结果。
- en: 'There are a few other special forms that we will go through in this section:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将介绍几个其他特殊形式：
- en: '`when`, which can be used when we are only interested in the case of a condition
    being *truthy* (a value is *truthy* when considered true in the context of a Boolean
    expression).'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when` 可以在只对条件为 *真值*（在布尔表达式的上下文中，值被认为是 *真值*）的情况感兴趣时使用。'
- en: '`do`, which can be used to execute a series of expressions and return the value
    of the last expression.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`do` 可以用来执行一系列表达式并返回最后一个表达式的值。'
- en: '`def` and `let`, which are special forms that are used to create global and
    local bindings.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def` 和 `let`，这些是用于创建全局和局部绑定的特殊形式。'
- en: '`fn` and `defn`, which are special forms that are used to create functions.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fn` 和 `defn`，这些是用于创建函数的特殊形式。'
- en: All these special forms have special evaluation rules, all of which we will
    discover by working through the following three exercises.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特殊形式都有特殊的评估规则，所有这些规则我们都会通过以下三个练习来发现。
- en: 'Exercise 1.03: Working with if, do, and when'
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03：使用 if、do 和 when
- en: 'In this exercise, we will evaluate expressions using the `if`, `do`, and `when`
    forms. Let''s get started:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `if`、`do` 和 `when` 形式来评估表达式。让我们开始吧：
- en: 'Start your REPL and type in the following expression:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 REPL 并输入以下表达式：
- en: '[PRE36]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The special form `if`, evaluates its first argument. If its value is truthful,
    it will evaluate argument `2`, otherwise (`else`), it will evaluate argument 3\.
    It will never evaluate both arguments 2 and 3.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊形式 `if`，评估其第一个参数。如果其值为真，它将评估参数 2，否则（`else`），它将评估参数 3。它永远不会同时评估参数 2 和 3。
- en: 'We can nest expressions and start doing more interesting things:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以嵌套表达式，并开始做一些更有趣的事情：
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, the computation of `(+ 3 4)` will not be executed, and only a
    random number (between 0 and 1) will be returned by the `rand` function.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，计算 `(+ 3 4)` 将不会执行，`rand` 函数只会返回一个随机数（介于 0 和 1 之间）。
- en: 'But what if we wanted to do more than one thing in our branch of the condition?
    We could wrap our operation with `do`. Let''s see how `do` works:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果我们想在条件的分支中做更多的事情呢？我们可以用 `do` 来包裹我们的操作。让我们看看 `do` 是如何工作的：
- en: '[PRE38]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To use the special form, `do` type the following expression:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用特殊形式，请输入以下表达式：
- en: '[PRE39]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the expressions before the final `(+ 1 1)` expression were evaluated, but
    only the value of the last one is returned. This does not look very useful with
    expressions that don't alter the state of the world, and so it would typically
    be used for side effects such as logging or any other kind of I/O (filesystem
    access, database query, network request, and so on).
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后的`(+ 1 1)`表达式之前的所有表达式都被评估了，但只有最后一个表达式的值被返回。对于不改变世界状态的表达式来说，这看起来并不很有用，因此它通常用于副作用，如日志记录或任何其他类型的I/O（文件系统访问、数据库查询、网络请求等）。
- en: 'You don''t have to take my word for it, so let''s experiment with the side
    effect of printing to the Terminal:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不必相信我的话，所以让我们通过在终端打印副作用来实验：
- en: '[PRE40]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can combine the use of `if` and `do` to execute multiple operations
    in a conditional branching:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以结合使用`if`和`do`来在条件分支中执行多个操作：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Technically, you could also omit the third argument. Bring back the previous
    expression in the REPL and remove the last expression, that is, `(+ 1 2)`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，你也可以省略第三个参数。在REPL中恢复之前的表达式，并移除最后一个表达式，即`(+ 1 2)`：
- en: '[PRE42]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We have a better construct available for this case: the `when` operator. Instead
    of combining `if` and `do`, when you are only interested in doing work in one
    branch of the conditional execution, use `when`.'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这种情况，我们有更好的构造：`when`运算符。当你只对条件执行的一个分支中的工作感兴趣时，使用`when`而不是组合`if`和`do`：
- en: 'Type the following expression to use `when` instead of a combination of `if`
    and `do`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下表达式来使用`when`而不是`if`和`do`的组合：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By completing this exercise, we have demonstrated the usage of the special forms
    known as `if`, `do`, and `when`. We can now write expressions that contain multiple
    statements, as well as conditional expressions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们已经展示了特殊形式`if`、`do`和`when`的用法。现在我们可以编写包含多个语句以及条件表达式的表达式。
- en: Bindings
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定
- en: In Clojure, we use the term *bindings* rather than *variables* and *assignments*
    because we tend to bind a value to a symbol only once. Under the hood, Clojure
    creates *variables* and so you may encounter this term, but it would be preferable
    if you don't think of them as classic *variables* or values that can change. We
    won't use the term variable anymore in this chapter as it can be confusing. You
    can use `def` to define global bindings and `let` for local bindings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，我们使用术语*绑定*而不是*变量*和*赋值*，因为我们倾向于只将一个值绑定到一个符号上。在底层，Clojure创建*变量*，因此你可能会遇到这个术语，但如果你不把它们视为经典的*变量*或可以改变的值，那就更好了。在本章中，我们不再使用术语变量，因为它可能会造成混淆。你可以使用`def`来定义全局绑定，使用`let`来定义局部绑定。
- en: 'Exercise 1.04: Using def and let'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：使用def和let
- en: 'In this exercise, we will demonstrate the usage of the `def` and `let` keywords,
    which are used to create bindings. Let''s get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将展示`def`和`let`关键字的使用，这些关键字用于创建绑定。让我们开始吧：
- en: 'The special form `def` allows you to bind a value to a symbol. In the REPL,
    type the following expression to bind the value `10` to the `x` symbol:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊形式`def`允许你将值绑定到符号。在REPL中，输入以下表达式将值`10`绑定到`x`符号：
- en: '[PRE44]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When the REPL returns `#'user/x`, it is returning a reference to the var you
    have just created. The user part indicates the namespace where the var is defined.
    The `#'` prefix is a way of quoting the var so that we see the symbol and not
    the value of the symbol.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当REPL返回`#'user/x`时，它正在返回你刚刚创建的变量的引用。`user`部分表示变量定义的命名空间。`#'`前缀是一种引用变量的方式，这样我们就能看到符号而不是符号的值。
- en: 'Evaluate the expression, `x`, which will resolve the `x` symbol to its value:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估表达式`x`，这将解析`x`符号到其值：
- en: '[PRE45]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Technically, you can change the binding, which is fine when experimenting in
    the REPL:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 技术上，你可以更改绑定，这在REPL中实验时是可行的：
- en: '[PRE46]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It is, however, not recommended in your programs because it can make it hard
    to read and complicate its maintenance. For now, it would be better if you just
    consider such a binding as a *constant.*
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在你的程序中并不推荐这样做，因为它可能会使代码难以阅读并复杂化其维护。现在，最好是将这样的绑定视为一个*常量*。
- en: 'You can use the `x` symbol within another expression:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在另一个表达式中使用`x`符号：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wherever `def` is invoked, it will bind the value to the symbol in the current
    namespace. We could try to define a local binding in a `do` block and see what
    happens:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论`def`在哪里被调用，它都会将值绑定到当前命名空间中的符号。我们可以在`do`块中尝试定义一个局部绑定，看看会发生什么：
- en: '[PRE48]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The bindings that are created by `def` have an indefinite scope (or dynamic
    scope) and can be considered as "global." They are automatically namespaced, which
    is a useful trait to avoid clashing with existing names.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we want to have a binding available only to a local scope or lexical scope,
    we can use the special form `let`. Type the following expression to create a lexical
    binding of the `y` symbol:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`let` takes a "vector" as a parameter to create the local bindings, and then
    a series of expressions that will be evaluated like they are in a `do` block.'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A vector is similar to a list, in the sense that they both are a sequential
    collection of values. Their underlying data structure is different, and we will
    shed light on this in *Chapter 2*, *Data Types and Immutability*. For now, you
    just need to know that vectors can be created with square brackets, for example,
    `[1 2 3 4]`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Evaluate the `y` symbol:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'An error is thrown, that is, `Unable to resolve symbol: y in this context`,
    because we are now outside of the `let` block.'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following expression to create a lexical binding of `x` to the value
    `3`, and see how it affects the indefinite (global) binding of `x` that we created
    in *step 4*:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Printing `x` yields the value `3`, which means that the "global" `x` symbol
    was temporarily overridden or "shadowed" by the lexical context in which `println`
    was invoked.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can create multiple local bindings at once with `let` by passing an even
    number of items in the vector. Type the following expression to bind `x` to `10`
    and `y` to `20`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Combine the concepts of this section and write the following expressions:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The expression spans over multiple lines to improve readability.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Creating Simple Functions with fn and defn'
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special form that''s used to define functions is `fn`. Let''s jump right
    into it by creating our first function:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following expression in your REPL:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have just created the simplest anonymous function, which takes no parameters
    and does nothing, and we returned an object, which is our function with no name.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a function that takes a parameter named `x` and return its square value
    (multiply it by itself):'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Remember that, in Clojure, the first item of an expression will be invoked,
    so we can call our anonymous function by wrapping it with parentheses and providing
    an argument as the second item of the expression:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now this is great, but not very convenient. If we wanted our function to be
    reusable or testable, it would be better for it to have a name. We can create
    a symbol in the namespace and bind it to the function.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `def` to bind the function returned by the special form, `fn`, to the `square`
    symbol:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Invoke your newly created function to make sure that it works:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This pattern of combining `def` and `fn` is so common that a built-in *macro*
    was born out of necessity: `defn`. Recreate the square function with `defn` instead
    of `def` and `fn`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Did you notice that the `x` argument was passed in a vector? We have already
    learned that vectors are collections, and so we can add more than one symbol to
    the argument's vector. The values that are passed when calling the function will
    be bound to the symbols provided in the vector during the function's definition.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Functions can take multiple arguments, and their bodies can be composed of
    multiple expressions (such as an implicit `do` block). Create a function with
    the name `meditate` that takes two arguments: a string, `s`, and a Boolean, `calm`.
    The function will print an introductory message and return a transformation of
    `s` based on `calm`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Editing multiline expressions in the REPL can be cumbersome. As we start creating
    lengthier functions and expressions that span multiple lines, it would be preferable
    to have a window of your favorite editor open next to your REPL window. Keep those
    windows side by side, edit the code in your editor, copy it to your clipboard,
    and paste it into your REPL.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function body contains two main expressions, the first of which is a side
    effect with `println` and the second of which is the `if` block, which will determine
    the return value. If `calm` is `true`, it will politely return the string capitalized
    (with the first character converted into uppercase), otherwise it will shout and
    return the string with all its characters to uppercase, ending with an exclamation
    mark.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try and make sure that our function works as intended:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we call the function with only the first parameter, it will throw an exception.
    This is because the parameters that we have defined are required:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: One last thing to end our initial tour of these functions is the `doc-string`
    parameter. When provided to `defn`, it will allow you to add a description of
    your function.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add documentation to your `square` function by adding a doc-string just before
    the function arguments:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The doc-string is not only useful when browsing a project's source code – it
    also makes it available to the `doc` function.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Look up the documentation of your `square` function with `doc`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It is important to remember that the doc-string needs to come before the function
    arguments. If it comes after, the string will be evaluated sequentially as part
    of the function body and won't throw an error. It is valid syntax, but it will
    not be available in the `doc` helper and other development tools.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is good practice to document the arguments with backticks, `` ` ``, like
    we did with `` `x` ``, so that development tools (such as the IDE) can recognize
    them.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will take a deeper dive into functions in *Chapter 3*, *Functions in Depth*,
    but these few basic principles will get you a long way in terms of writing functions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.02: Predicting the Atmospheric Carbon Dioxide Level'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Carbon dioxide (CO2) is an important heat-trapping (greenhouse) gas, currently
    rising and threatening life as we know it on our planet. We would like to predict
    future levels of CO2 in the atmosphere based on historical data provided by **National
    Oceanic and Atmospheric Administration** (**NOAA**):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: CO2 parts per million (ppm) over the years'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_01_02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: CO2 parts per million (ppm) over the years'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The preceding chart was taken from [https://packt.live/35kUI7L](https://packt.live/35kUI7L)
    and the data was taken from NOAA.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: We will use the year 2006 as a starting point with a CO2 level of 382 ppm and
    calculate the estimate using a simplified (and optimistic) linear function, as follows: *Estimate
    = 382 + ((Year - 2006) * 2)*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `co2-estimate` that takes one integer parameter called
    `year` and returns the estimated level of CO2 ppm for that year.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, define two constants, `base-co2` and `base-year`, with the values
    382 and 2006, respectively.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, write the code to define the `co2-estimate` function without
    forgetting to document it with the doc-string parameter.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may be tempted to write the function body in a single line but nesting a
    lot of function calls decreases the readability of the code. It is also easier
    to reason about each step of the process by decomposing them in a `let` block.
    Write the body of the function using `let` to define the local binding `year-diff`,
    which is the subtraction of 2006 from the `year` parameter.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your function by evaluating `(co2-estimate 2050)`. You should get `470`
    as the result.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the documentation of your function with `doc` and make sure that it
    has been defined correctly.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 679.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness, nil, and equality
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have been using conditional expressions intuitively, possibly
    on the basis of how they usually work with other programming languages. In this
    final section, we will review and explain Boolean expressions and the related
    comparison functions in detail, starting with `nil` and truthiness in Clojure.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`nil` is a value that represents the absence of value. It is also often called
    `NULL` in other programming languages. Representing the absence of value is useful
    because it means that something is missing.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In Clojure, `nil` is "falsey," which means that `nil` behaves like `false` when
    evaluated in a Boolean expression.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`false` and `nil` are the only values that are treated as *falsey* in Clojure;
    everything else is truthy. This simple rule is a blessing (especially if you are
    coming from a language such as JavaScript) and makes our code more readable and
    less error-prone. Perhaps it''s just that Clojure was not out yet when Oscar Wilde
    wrote, "The truth is rarely pure and never simple."'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: The Truth Is Simple'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will demonstrate how to work with Boolean values in conditional
    expressions. We will also see how to play around with the logical operators in
    conditional expressions. Let''s get started:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by verifying that `nil` and `false` are indeed `falsey`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In other programming languages, it is common for more values to resolve to
    `false` in Boolean expressions. But in Clojure, remember that only `nil` and `false`
    are *falsey*. Let''s try a few examples:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we want to know whether something is exactly `true` or `false`, and not
    just `truthy` or `falsey`, we can use the `true?` and `false?` functions:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `?` character has no special behavior – it is just a naming convention for
    functions that return a Boolean value.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, if we want to know that something is `nil` and not just `falsey`,
    we can use the `nil?` function:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that `println` returns `nil`, and so the last piece of output in the
    preceding code is `true`.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Boolean expressions become interesting when they are composed together. Clojure
    provides the usual suspects, that is, `and` and `or`. At this point, we are only
    interested in *logical* `and` and *logical* `or`. If you are looking to play around
    with `bitwise` operators, you can easily find them with the `(find-doc "bit-")`
    command.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`and` returns the first *falsey* value that it encounters (from left to right)
    and will not evaluate the rest of the expression when that is the case. When all
    the values passed to `and` are *truthy*, `and` will return the last value.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with the `and` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s been generated:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s use `println` and make sure that not all the expressions are evaluated:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`and` evaluated the first expression, which printed `Hello` and returned `nil`,
    which is *falsey*. Therefore, the second expression was not evaluated, and `Goodbye`
    was not printed.'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`or` works in a similar fashion: it will return the first *truthy* value that
    it comes across and it will not evaluate the rest of the expression when that
    is the case. When all the values that are passed to `or` are *falsey*, `or` will
    return the last value.'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Experiment with the `or` function by passing a mix of *truthy* and *falsey*
    values to observe the return value that''s generated:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Once again, we can use `println` to make sure that the expressions are not
    all evaluated:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`or` evaluated the first expression `true` and returned it. Therefore, the
    second expression was not evaluated, and `Hello` was not printed.'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Equality and Comparisons
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most imperative programming languages, the `=` symbol is used for variable
    assignments. As we've seen already, in Clojure, we have `def` and `let` to bind
    names with values. The `=` symbol is a function for equality and will return `true`
    if all its arguments are equal. As you may have guessed by now, the other common
    comparison functions are implemented as functions. `>`, `>=`, `<`, `<=`, and `=`
    are not special syntax and you may have developed the intuition for using them
    already.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Comparing Values'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this final exercise, we will go through the different ways of comparing
    values in Clojure. Let''s get started:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: First, start your REPL if it is not running yet.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following expressions to compare two numbers:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can pass multiple arguments to the `=` operator:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In that case, even though the first three arguments are equal, the last one
    isn't, so the `=` function returns `false`.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `=` operator is not only used to compare numbers, but other types as well.
    Evaluate some of the following expressions:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Java or other object-oriented programming languages, comparing things usually
    checks whether they are the exact same instance of an object stored in memory,
    that is, their identity. However, comparisons in Clojure are made by equality
    rather than identity. Comparing values is generally more useful, and Clojure makes
    it convenient, but if you ever wanted to compare identities, you could do so by
    using the `identical?` function.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Maybe more surprisingly, but sequences of different types can be considered
    equal as well:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The list `1` `2` `3` is equivalent to the vector `1` `2` `3` . Collections and
    sequences are powerful Clojure abstractions that will be presented in *Chapter
    2*, *Data Types and Immutability*.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the `=` function can also take one argument, in
    which case it will always return `true`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The other comparison operators, that is, `>`, `>=`, `<`, and `<=`, can only
    be used with numbers. Let's start with `<` and `>`.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<` returns `true` if all its arguments are in a strictly increasing order.
    Try to evaluate the following expressions:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that `10` followed by `10` is not strictly increasing.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<=` is similar, but adjacent arguments can be equal:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`>` and `>=` have a similar behavior and return `true` when their arguments
    are in a decreasing order. `>=` allows adjacent arguments to be equal:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, the `not` operator is a useful function that returns `true` when its
    argument is *falsey* (`nil` or `false`), and `false` otherwise. Let''s try an
    example:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To put things together, let''s consider the following JavaScript code:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This code snippet prints `Valid` when a number, `x`, is included between 1 and
    100 or if `x` is a multiple of 100\. Otherwise, it prints `Invalid`.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to translate this to Clojure code, we would write the following:'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We may have a few more parentheses in the Clojure code, but you could argue
    that Clojure is more readable than the imperative JavaScript code. It contains
    less specific syntax, and we don't need to think about operator precedence.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we wanted to transform the JavaScript code using an "inline if," we would
    introduce new syntax with `?` and `:`, as follows:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The Clojure code would become the following:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Notice that there is no new syntax, and nothing new to learn. You already know
    how to read lists, and that is all you will (almost) ever need.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple example demonstrates the great flexibility of `lists`: the building
    blocks of Clojure and other Lisp languages.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.03: The meditate Function v2.0'
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will improve the `meditate` function we wrote in *Exercise
    1.05*, *Creating Simple Functions with fn and defn*, by replacing the `calm` Boolean
    argument with `calmness-level`. The function will print a transformation of the
    string passed as a second argument based on the calmness level. The specifications
    of the function are as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '`calmness-level` is a number between `1` and `10`, but we will not check the
    input for errors.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is strictly inferior to `5`, we consider the user to be
    angry. The function should return the `s` string transformed to uppercase concatenated
    with the string "`, I TELL YA!`".
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is between `5` and `9`, we consider the user to be calm
    and relaxed. The function should return the `s` string with only its first letter
    capitalized.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calmness level is `10`, the user has reached nirvana, and is being possessed
    by the Clojure gods. In its trance, the user channels the incomprehensible language
    of those divine entities. The function should return the `s` string in reverse.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hint
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `str` function to concatenate a string and `clojure.string/reverse`
    to reverse a string. If you are not sure how to use them, you can look up their
    documentation with `doc` (for example, `(doc clojure.string/reverse)`).
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Open your favorite editor and a REPL window next to it.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your editor, define a function with the name `meditate`, taking two arguments,
    `calmness-level` and `s`, without forgetting to write its documentation.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function body, start by writing an expression that prints the string,
    `Clojure Meditate v2.0`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the specification, write the first condition to test whether the calmness
    level is strictly inferior to `5`. Write the first branch of the conditional expression
    (the `then`).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the second condition, which should be nested in the second branch of the
    first condition (the `else`).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the third condition, which should be nested in the second branch of the
    second condition. It will check that `calmness-level` is exactly `10` and return
    the reverse of the `s` string when that is the case.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your function by passing a string with different levels of calmness. The
    output should be similar to the following:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If you have been using the `and` operator to find whether a number was between
    two other numbers, rewrite your function to remove it and only use the `<=` operator.
    Remember that `<=` can take more than two arguments.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the `cond` operator in the documentation and rewrite your function to
    replace the nested conditions with `cond`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 680.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered how to use the REPL and its helpers. You are
    now able to search and discover new functions and look up their documentation
    interactively in the REPL. We learned how Clojure code is evaluated, as well as
    how to use and create functions, bindings, conditionals, and comparisons. These
    allow you to create simple programs and scripts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at data types, including collections, and
    the concept of immutability.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
