<html><head></head><body>
		<div id="_idContainer092">
			<h1 id="_idParaDest-146"><em class="italic"><a id="_idTextAnchor146"/>Chapter 8</em>: Deploying Microservices</h1>
			<p>The literal meaning of <em class="italic">deployment</em> is to bring resources into effective action. Therefore, in the microservices context, it means to bring microservices into effective action. Any service deployment is a multi-step process and often involves building the artifacts and then pushing the artifacts to a runtime environment. In the microservices world, an effective strategy for microservices deployment is crucial. Essentially, we need to watch out for the following when planning a deployment process:</p>
			<ul>
				<li>Continue with the pattern of <em class="italic">separation of concern</em> and self-isolate the artifact-building process for each microservice.</li>
				<li>Decouple any connection requirements within microservices and let the service discovery or an implementation close to service discovery handle the microservice bindings.</li>
				<li>Implement a seamless deployment process that can handle instantiating all of the microservice application components in a unified and automated way.</li>
			</ul>
			<p>In this chapter, we will dive into these aforementioned concerns while covering the following topics:</p>
			<ul>
				<li>Building the container artifacts</li>
				<li>Deploying the container artifacts</li>
			</ul>
			<p>By the end of this chapter, you will be well versed in these aspects of microservices deployment. </p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter run on Windows 10 and macOS. The code examples covered in this chapter are available in the book's GitHub repo here:</p>
			<p><a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08 ">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter08</a></p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 13 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">A development IDE</strong>: Based on your preference, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: Instructions to download and install this can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.  </li>
				<li><strong class="bold">PostgreSQL</strong>: Instructions to download and install this can be found at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>.</li>
				<li><strong class="bold">MongoDB</strong>: MongoDB Atlas provides a free online database-as-a-service with up to 512 MB storage. However, if a local database is preferred then instructions to download and install it can be found at <a href="https://docs.mongodb.com/manual/administration/install-community/">https://docs.mongodb.com/manual/administration/install-community/</a>. We used a local installation for writing this chapter.</li>
				<li><strong class="bold">A REST client</strong>: Any HTTP REST client can be used. We used the <strong class="bold">Advanced REST Client</strong> Chrome plugin.</li>
				<li><strong class="bold">Docker</strong>: Instructions to download and install Docker can be found at <a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>.</li>
			</ul>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Building the container artifacts</h1>
			<p>To deploy any<a id="_idIndexMarker619"/> application, the first step is to build all the required artifacts. And building an artifact typically involves checking out the source code and compiling and creating a deployable artifact. In regard to microservices, often, this deployable form is a Docker container image. Docker images have elegantly decoupled the runtime topology requirements. A Docker image is platform agnostic and can be deployed to any host machine that runs Docker. In the next section, we will dive into how to <a id="_idIndexMarker620"/>build Docker images for the microservices in our pet-clinic application. </p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor149"/>Containerizing the Micronaut microservices using Jib</h2>
			<p>Jib is<a id="_idIndexMarker621"/> a containerizing framework<a id="_idIndexMarker622"/> from Google that can seamlessly tie with Java build frameworks such as Maven or Gradle to build container images. Jib has hugely simplified the process to create container (Docker) images. Let's quickly see the workflow without Jib to create a Docker image:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_8.1_B16585_Fixed.jpg" alt="Figure 8.1 – Docker containerization workflow without Jib&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Docker containerization workflow without Jib</p>
			<p>As you can see in the preceding diagram, to build a Docker image without Jib we need to build the <strong class="bold">Source code</strong> and create a <strong class="bold">Docker file</strong>. The <strong class="bold">Docker daemon</strong> then uses the build context to create a <strong class="bold">Container image </strong>and push it to the repository/registry. </p>
			<p>In contrast to the preceding workflow, Jib simplifies the whole process as shown in the following diagram:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_8.2_B16585_Fixed.jpg" alt="Figure 8.2 – Docker containerization with Jib&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Docker containerization with Jib</p>
			<p>Jib takes the configuration from the build file such as project's <strong class="source-inline">pom</strong> file or a Gradle file to build the <a id="_idIndexMarker623"/>container image and uploads it<a id="_idIndexMarker624"/> to the configured repository/registry. </p>
			<p>We will use Jib for containerizing our microservices in the following sections.</p>
			<h3>Containerizing the pet-owner microservice</h3>
			<p>In the pet-owner <a id="_idIndexMarker625"/>microservice, we <a id="_idIndexMarker626"/>will simplify configuration management to use local <strong class="source-inline">application.properties</strong>. We can still use <strong class="source-inline">consul</strong> for configuration management, but to focus on the containerization aspect, we opt to use a local <strong class="source-inline">application.properties</strong> file. Delete or back up the <strong class="source-inline">bootstrap.yml</strong> file and make the following changes to the <strong class="source-inline">application.properties</strong> file:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: pet-owner</p>
			<p class="source-code">  server:</p>
			<p class="source-code">    port: 32581</p>
			<p class="source-code">  router:</p>
			<p class="source-code">    static-resources:</p>
			<p class="source-code">      swagger:</p>
			<p class="source-code">        paths: classpath:META-INF/swagger</p>
			<p class="source-code">        mapping: /swagger/**</p>
			<p class="source-code">datasources:</p>
			<p class="source-code">  default:</p>
			<p class="source-code">    url: "jdbc:postgresql://host.docker.internal:5432/postgres"</p>
			<p class="source-code">    username: postgres</p>
			<p class="source-code">    password: postgres</p>
			<p class="source-code">    driverClassName: org.postgresql.Driver</p>
			<p class="source-code">    </p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    default-zone: "consul:8500"</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">      </p>
			<p class="source-code">jpa:</p>
			<p class="source-code">…</p>
			<p>A <a id="_idIndexMarker627"/>few <a id="_idIndexMarker628"/>things to ponder in these application properties changes are as follows:</p>
			<ul>
				<li><strong class="bold">Datasource URL</strong>: We will be using <strong class="source-inline">host.docker.internal</strong> instead of localhost to point to the Postgres instance installed on the host operating system (outside Docker). </li>
				<li><strong class="bold">Consul default-zone</strong>: In our Docker services, we will configure a <strong class="source-inline">consul</strong> service. To use Dockerized <strong class="source-inline">consul</strong> from a pet-owner Docker container, we will need to specify the service name instead of localhost. </li>
				<li><strong class="bold">Port</strong>: We are specifying a fixed port to run the pet-owner microservice as this will expose this port later in the deployment.</li>
			</ul>
			<p>Essentially, to use anything from the host machine we should use <strong class="source-inline">host.docker.internal</strong>, and to use any Docker service container we must specify the Docker service name.</p>
			<p>After making the previous application configuration changes, we can proceed to containerization. To containerize the pet-owner microservice we will use Jib. Make the following<a id="_idIndexMarker629"/> changes in the project's <strong class="source-inline">pom</strong> file <a id="_idIndexMarker630"/>build settings:</p>
			<p class="source-code">&lt;build&gt;</p>
			<p class="source-code">  &lt;plugins&gt;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    &lt;plugin&gt;</p>
			<p class="source-code">      &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;2.8.0&lt;/version&gt;</p>
			<p class="source-code">      &lt;configuration&gt;</p>
			<p class="source-code">        &lt;from&gt;</p>
			<p class="source-code">          &lt;image&gt;openjdk:13-jdk-slim&lt;/image&gt;</p>
			<p class="source-code">        &lt;/from&gt;</p>
			<p class="source-code">        &lt;to&gt;</p>
			<p class="source-code">          &lt;image&gt;pet-owner-0.1-image&lt;/image&gt;</p>
			<p class="source-code">        &lt;/to&gt;</p>
			<p class="source-code">        &lt;container&gt;</p>
			<p class="source-code">          &lt;creationTime&gt;${maven.build.timestamp}&lt;/creationTime&gt;</p>
			<p class="source-code">        &lt;/container&gt;</p>
			<p class="source-code">      &lt;/configuration&gt;</p>
			<p class="source-code">    &lt;/plugin&gt;</p>
			<p class="source-code">  &lt;/plugins&gt;</p>
			<p class="source-code">&lt;/build&gt;</p>
			<p>In the preceding <strong class="source-inline">pom</strong> changes, we are using <strong class="source-inline">jib-maven-plugin</strong> to build the container image. The <strong class="source-inline">&lt;configuration&gt;</strong> section specifies the Docker configurations such as the <strong class="source-inline">&lt;from&gt;</strong> image (which is pointing to use JDK 13). To name the created image, we use <strong class="source-inline">&lt;to&gt;</strong> along with <strong class="source-inline">&lt;creationTime&gt;</strong> to correctly stamp the time coordinates on the image. </p>
			<p>To build the image, perform the following steps:</p>
			<ol>
				<li>Open the terminal and change directory to the <strong class="source-inline">pet-owner</strong> root directory. </li>
				<li>Type and run the <strong class="source-inline">mvn compile jib:dockerBuild</strong> command in the terminal.</li>
				<li>Wait<a id="_idIndexMarker631"/> for the command<a id="_idIndexMarker632"/> to finish.</li>
			</ol>
			<p>These instructions will create a local Docker image that can be verified using the <strong class="source-inline">docker images | grep pet-owner</strong> command in the terminal:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/Figure_8.3_B16585_Fixed.jpg" alt="Figure 8.3 – Verifying the pet-owner image in the local Docker registry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Verifying the pet-owner image in the local Docker registry</p>
			<p>In the preceding screenshot, we can see the output of <strong class="source-inline">docker images</strong>. A <strong class="source-inline">pet-owner-0.1-image</strong> image is stored in the local Docker registry.</p>
			<h3>Containerizing the pet-clinic microservice</h3>
			<p>To make <a id="_idIndexMarker633"/>the pet-clinic microservice<a id="_idIndexMarker634"/> container ready, make the following changes to the <strong class="source-inline">application.properties</strong> file:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: pet-clinic</p>
			<p class="source-code">  server:</p>
			<p class="source-code">    port: 32582</p>
			<p class="source-code">kafka:</p>
			<p class="source-code">  bootstrap:</p>
			<p class="source-code">    servers: kafka:9092</p>
			<p class="source-code">datasources:</p>
			<p class="source-code">  default:</p>
			<p class="source-code">    url: </p>
			<p class="source-code">     «jdbc:postgresql://host.docker.internal:5432/postgres»</p>
			<p class="source-code">    username: postgres</p>
			<p class="source-code">    password: postgres</p>
			<p class="source-code">    driverClassName: org.postgresql.Driver</p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    default-zone: "consul:8500"</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">…</p>
			<p>The <a id="_idIndexMarker635"/>following<a id="_idIndexMarker636"/> are a few things to ponder in application properties changes:</p>
			<ul>
				<li><strong class="bold">Datasource URL</strong>: We will be using <strong class="source-inline">host.docker.internal</strong> instead of localhost to point to Postgres installed in the host operating system (outside Docker). </li>
				<li><strong class="bold">Consul default-zone</strong>: In our Docker services, we will configure a <strong class="source-inline">consul</strong> service. To use Dockerized <strong class="source-inline">consul</strong> from the pet-clinic Docker container, we will need to specify the service name instead of localhost. </li>
				<li><strong class="bold">Kafka server</strong>: In our Docker services, we will configure a <strong class="bold">Kafka</strong> service. </li>
				<li><strong class="bold">Port</strong>: We are specifying a fixed port to run the pet-clinic microservice as we will expose this port later in the deployment.</li>
			</ul>
			<p>After making the preceding application configuration changes, we can proceed to containerization. To containerize the pet-clinic microservice we will use Jib. Make the following <a id="_idIndexMarker637"/>changes in the project's <strong class="source-inline">pom</strong> file <a id="_idIndexMarker638"/>build settings:</p>
			<p class="source-code">&lt;build&gt;</p>
			<p class="source-code">  &lt;plugins&gt;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    &lt;plugin&gt;</p>
			<p class="source-code">      &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;2.8.0&lt;/version&gt;</p>
			<p class="source-code">      &lt;configuration&gt;</p>
			<p class="source-code">        &lt;from&gt;</p>
			<p class="source-code">          &lt;image&gt;openjdk:13-jdk-slim&lt;/image&gt;</p>
			<p class="source-code">        &lt;/from&gt;</p>
			<p class="source-code">        &lt;to&gt;</p>
			<p class="source-code">          &lt;image&gt;pet-clinic-0.1-image&lt;/image&gt;</p>
			<p class="source-code">        &lt;/to&gt;</p>
			<p class="source-code">        &lt;container&gt;</p>
			<p class="source-code">          &lt;creationTime&gt;${maven.build.timestamp}&lt;/creationTime&gt;</p>
			<p class="source-code">        &lt;/container&gt;</p>
			<p class="source-code">      &lt;/configuration&gt;</p>
			<p class="source-code">    &lt;/plugin&gt;</p>
			<p class="source-code">  &lt;/plugins&gt;</p>
			<p class="source-code">&lt;/build&gt;</p>
			<p>In the preceding <strong class="source-inline">pom</strong> changes, we use <strong class="source-inline">jib-maven-plugin</strong> to build the container image. The <strong class="source-inline">&lt;configuration&gt;</strong> section specifies Docker configurations such as the <strong class="source-inline">&lt;from&gt;</strong> image (which is pointing to use JDK 13). To name the created image we use <strong class="source-inline">&lt;to&gt;</strong> along with <strong class="source-inline">&lt;creationTime&gt;</strong> to correctly stamp the time coordinates on the image. </p>
			<p>To build the<a id="_idIndexMarker639"/> image, we perform the<a id="_idIndexMarker640"/> following steps:</p>
			<ol>
				<li value="1">Open the terminal and change directory to the <strong class="source-inline">pet-clinic</strong> root directory. </li>
				<li>Type and run the <strong class="source-inline">mvn compile jib:dockerBuild</strong> command in the terminal.</li>
				<li>Wait for the command to finish.</li>
			</ol>
			<p>The preceding instructions will create a local Docker image that can be verified using the <strong class="source-inline">docker images | grep pet-clinic</strong> command in the terminal.</p>
			<h3>Containerizing the pet-clinic-reviews microservice</h3>
			<p>To <a id="_idIndexMarker641"/>make <a id="_idIndexMarker642"/>the pet-clinic-reviews microservice container ready, make the following changes to the <strong class="source-inline">application.properties</strong> file:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: pet-clinic-reviews</p>
			<p class="source-code">  server:</p>
			<p class="source-code">    port: 32583</p>
			<p class="source-code">kafka:</p>
			<p class="source-code">  bootstrap:</p>
			<p class="source-code">    servers: kafka:9092</p>
			<p class="source-code">mongodb:</p>
			<p class="source-code">  uri: mongodb://mongodb:mongodb@host.docker.internal:27017/pet-clinic-reviews</p>
			<p class="source-code">  databaseName: pet-clinic-reviews</p>
			<p class="source-code">  collectionName: vet-reviews</p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    default-zone: «consul:8500»</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">…</p>
			<p>The following are a few things to ponder in application properties changes:</p>
			<ul>
				<li><strong class="bold">Mongo database URI</strong>: We will be using <strong class="source-inline">host.docker.internal</strong> instead of localhost to point to the Mongo DB instance installed on the host operating system (outside Docker). </li>
				<li><strong class="bold">Consul default-zone</strong>: In our Docker services, we will configure a <strong class="source-inline">consul</strong> service. To use Dockerized <strong class="source-inline">consul</strong> from the <strong class="source-inline">pet-clinic-reviews</strong> Docker container, we will need to specify the service name instead of localhost. </li>
				<li><strong class="bold">Kafka server</strong>: In our Docker services, we will configure a <strong class="source-inline">kafka</strong> service. To use Dockerized <strong class="source-inline">consul</strong> from the <strong class="source-inline">pet-clinic-reviews</strong> Docker container, we will need to specify the service name instead of localhost. </li>
				<li><strong class="bold">Port</strong>: We are specifying a fixed port to run the pet-clinic-reviews microservice as we will expose this port later in the deployment.</li>
			</ul>
			<p>After making the preceding application configuration changes, we can proceed to containerization. To containerize the <strong class="source-inline">pet-clinic-reviews</strong> microservice we will use Jib. Make the<a id="_idIndexMarker643"/> following changes in the <a id="_idIndexMarker644"/>project's <strong class="source-inline">pom</strong> fie build settings:</p>
			<p class="source-code">&lt;build&gt;</p>
			<p class="source-code">  &lt;plugins&gt;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    &lt;plugin&gt;</p>
			<p class="source-code">      &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;2.8.0&lt;/version&gt;</p>
			<p class="source-code">      &lt;configuration&gt;</p>
			<p class="source-code">        &lt;from&gt;</p>
			<p class="source-code">          &lt;image&gt;openjdk:13-jdk-slim&lt;/image&gt;</p>
			<p class="source-code">        &lt;/from&gt;</p>
			<p class="source-code">        &lt;to&gt;</p>
			<p class="source-code">          &lt;image&gt;pet-clinic-reviews-0.1-image&lt;/image&gt;</p>
			<p class="source-code">        &lt;/to&gt;</p>
			<p class="source-code">        &lt;container&gt;</p>
			<p class="source-code">          &lt;creationTime&gt;${maven.build.timestamp}&lt;/creationTime&gt;</p>
			<p class="source-code">        &lt;/container&gt;</p>
			<p class="source-code">      &lt;/configuration&gt;</p>
			<p class="source-code">    &lt;/plugin&gt;</p>
			<p class="source-code">  &lt;/plugins&gt;</p>
			<p class="source-code">&lt;/build&gt;</p>
			<p>In the preceding <strong class="source-inline">pom</strong> changes, we are using <strong class="source-inline">jib-maven-plugin</strong> to build the container image. The <strong class="source-inline">&lt;configuration&gt;</strong> section specifies Docker configurations such as the <strong class="source-inline">&lt;from&gt;</strong> image (which is pointing to use JDK 13). To name the created image, we use <strong class="source-inline">&lt;to&gt;</strong> along with <strong class="source-inline">&lt;creationTime&gt;</strong> to correctly stamp the time coordinates on the image. </p>
			<p>To build the<a id="_idIndexMarker645"/> image, perform the<a id="_idIndexMarker646"/> following steps:</p>
			<ol>
				<li value="1">Open the terminal and change directory to the <strong class="source-inline">pet-clinic-reviews</strong> root directory. </li>
				<li>Type and run the <strong class="source-inline">mvn compile jib:dockerBuild</strong> command in terminal.</li>
				<li>Wait for the command to finish.</li>
			</ol>
			<p>The preceding instructions will create a local Docker image that can be verified using the <strong class="source-inline">docker images | grep pet-clinic-reviews</strong> command in the terminal.</p>
			<h3>Containerizing the pet-clinic-concierge microservice</h3>
			<p>To make<a id="_idIndexMarker647"/> the pet-clinic-concierge <a id="_idIndexMarker648"/>microservice container ready, make the following changes to the <strong class="source-inline">application.properties</strong> file:</p>
			<p class="source-code">micronaut:</p>
			<p class="source-code">  application:</p>
			<p class="source-code">    name: pet-clinic-concierge</p>
			<p class="source-code">  server:</p>
			<p class="source-code">    port: 32584</p>
			<p class="source-code">  config-client:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">consul:</p>
			<p class="source-code">  client:</p>
			<p class="source-code">    default-zone: "consul:8500"</p>
			<p class="source-code">    registration:</p>
			<p class="source-code">      enabled: true</p>
			<p class="source-code">…</p>
			<p>The<a id="_idIndexMarker649"/> following are a few<a id="_idIndexMarker650"/> things to ponder in application properties changes:</p>
			<ul>
				<li><strong class="bold">Consul default-zone</strong>: In our Docker services, we will configure a <strong class="source-inline">consul</strong> service. To use Dockerized <strong class="source-inline">consul</strong> from the pet-clinic-concierge Docker container we will need to specify the service name instead of localhost. </li>
				<li><strong class="bold">Port</strong>: We are specifying a fixed port to run the <strong class="source-inline">pet-clinic-concierge</strong> microservice as we will expose this port later in the deployment.</li>
			</ul>
			<p>After making the preceding application configuration changes we can proceed to containerization. To containerize the <strong class="source-inline">pet-clinic-concierge</strong> microservice (the API gateway) we<a id="_idIndexMarker651"/> will use <strong class="source-inline">jib</strong>. Make <a id="_idIndexMarker652"/>the following changes in the project's <strong class="source-inline">pom</strong> file build settings:</p>
			<p class="source-code">&lt;build&gt;</p>
			<p class="source-code">  &lt;plugins&gt;</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    &lt;plugin&gt;</p>
			<p class="source-code">      &lt;groupId&gt;com.google.cloud.tools&lt;/groupId&gt;</p>
			<p class="source-code">      &lt;artifactId&gt;jib-maven-plugin&lt;/artifactId&gt;</p>
			<p class="source-code">      &lt;version&gt;2.8.0&lt;/version&gt;</p>
			<p class="source-code">      &lt;configuration&gt;</p>
			<p class="source-code">        &lt;from&gt;</p>
			<p class="source-code">          &lt;image&gt;openjdk:13-jdk-slim&lt;/image&gt;</p>
			<p class="source-code">        &lt;/from&gt;</p>
			<p class="source-code">        &lt;to&gt;</p>
			<p class="source-code">          &lt;image&gt;pet-clinic-concierge-0.1-image&lt;/image&gt;</p>
			<p class="source-code">        &lt;/to&gt;</p>
			<p class="source-code">        &lt;container&gt;</p>
			<p class="source-code">          &lt;creationTime&gt;${maven.build.timestamp}&lt;/creationTime&gt;</p>
			<p class="source-code">        &lt;/container&gt;</p>
			<p class="source-code">      &lt;/configuration&gt;</p>
			<p class="source-code">    &lt;/plugin&gt;</p>
			<p class="source-code">  &lt;/plugins&gt;</p>
			<p class="source-code">&lt;/build&gt;</p>
			<p>In the preceding <strong class="source-inline">pom</strong> changes, we use <strong class="source-inline">jib-maven-plugin</strong> to build the container image. The <strong class="source-inline">&lt;configuration&gt;</strong> section specifies Docker configurations such as the <strong class="source-inline">&lt;from&gt;</strong> image (which is pointing to use JDK 13). To name the created image we use <strong class="source-inline">&lt;to&gt;</strong> along with <strong class="source-inline">&lt;creationTime&gt;</strong> to correctly stamp the time coordinates on the image. </p>
			<p>To build the image, perform the following steps:</p>
			<ol>
				<li value="1">Open the terminal and change directory to the <strong class="source-inline">pet-clinic-concierge</strong> root directory. </li>
				<li>Type and run the <strong class="source-inline">mvn compile jib:dockerBuild</strong> command in terminal.</li>
				<li>Wait <a id="_idIndexMarker653"/>for the command<a id="_idIndexMarker654"/> to finish.</li>
			</ol>
			<p>The preceding instructions will create a local Docker image that can be verified using the <strong class="source-inline">docker images | grep pet-clinic-concierge</strong> command in the terminal.</p>
			<p>Now, we have containerized all the microservices. We can verify these images in the Docker Dashboard as well:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_8.4_B16585_Fixed.jpg" alt="Figure 8.4 – Verifying the Docker images in the Docker UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Verifying the Docker images in the Docker UI</p>
			<p>In the Docker UI, we can simply go to <strong class="bold">Images</strong> and under the <strong class="bold">LOCAL</strong> tab, we can filter all the pet-clinic application images. In the next section, we will use these Docker images in our<a id="_idIndexMarker655"/> pet-clinic<a id="_idIndexMarker656"/> application deployment.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Deploying the container artifacts</h1>
			<p>In the previous <a id="_idIndexMarker657"/>section, we explored how we can use <strong class="source-inline">Jib</strong> to simplify microservice containerization. In this section, we will dive into how we can make the end-to-end deployment seamless and unified using Docker orchestration with <strong class="source-inline">docker-compose</strong>.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/>Using docker-compose to deploy the pet-clinic services</h2>
			<p><strong class="source-inline">docker-compose</strong> is a<a id="_idIndexMarker658"/> tool available<a id="_idIndexMarker659"/> under the Docker ecosystem and is very intuitive in defining and deploying a multi-container application. With a simple YAML-flavored syntax, we can set up all the services and their dependencies and use a single command to deploy the whole application. We will create a <strong class="source-inline">docker-compose</strong> file for the pet-clinic application covering all the necessary services/components, including microservices, service discovery, and the Apache Kafka ecosystem.</p>
			<p>Firstly, let's define the ancillary services in <strong class="source-inline">docker-compose</strong> as follows:</p>
			<p class="source-code">version: '3'</p>
			<p class="source-code">services:</p>
			<p class="source-code">  consul:</p>
			<p class="source-code">    image: bitnami/consul:latest</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - '8500:8500'</p>
			<p class="source-code">  </p>
			<p class="source-code">  zookeeper:</p>
			<p class="source-code">    image: bitnami/zookeeper:3-debian-10</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - 2181:2181</p>
			<p class="source-code">    volumes:</p>
			<p class="source-code">      - zookeeper_data:/pet-clinic-reviews</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - ALLOW_ANONYMOUS_LOGIN=yes  </p>
			<p class="source-code">  kafka:</p>
			<p class="source-code">    image: bitnami/kafka:2-debian-10</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - 9094:9094</p>
			<p class="source-code">    volumes:</p>
			<p class="source-code">      - kafka_data:/pet-clinic-reviews</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - KAFKA_BROKER_ID=1</p>
			<p class="source-code">      - KAFKA_CFG_ZOOKEEPER_CONNECT=zookeeper:2181</p>
			<p class="source-code">      - ALLOW_PLAINTEXT_LISTENER=yes</p>
			<p class="source-code">      - KAFKA_LISTENERS=INTERNAL://kafka:9092,OUTSIDE://</p>
			<p class="source-code">kafka:9094</p>
			<p class="source-code">      - KAFKA_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,OUTSIDE://localhost:9094</p>
			<p class="source-code">      - KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,OUTSIDE:PLAINTEXT</p>
			<p class="source-code">      - KAFKA_INTER_BROKER_LISTENER_NAME=INTERNAL</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">      - zookeeper</p>
			<p class="source-code">  kafdrop:</p>
			<p class="source-code">    image: obsidiandynamics/kafdrop</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - 9100:9000</p>
			<p class="source-code">    environment:</p>
			<p class="source-code">      - KAFKA_BROKERCONNECT=kafka:9092</p>
			<p class="source-code">      - JVM_OPTS=-Xms32M -Xmx64M</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">      - kafka</p>
			<p class="source-code">…</p>
			<p>From<a id="_idIndexMarker660"/> the <a id="_idIndexMarker661"/>previous code, we see the <strong class="source-inline">docker-compose</strong> file. We begin by defining a service for the <strong class="source-inline">consul</strong> service discovery. We will expose <strong class="source-inline">consul</strong> on port <strong class="source-inline">8500</strong>. Furthermore, we will define services for the Apache Kafka ecosystem; that is, Zookeeper, Kafka, and the Kafdrop UI. Once these services are defined in the <strong class="source-inline">docker-compose</strong> file, we can proceed to the pet-clinic microservices. Refer to the following code:</p>
			<p class="source-code">…  </p>
			<p class="source-code">pet-owner:</p>
			<p class="source-code">    image: "pet-owner-0.1-image"</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">        - "32581:32581"</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">        - consul</p>
			<p class="source-code">  </p>
			<p class="source-code">  pet-clinic:</p>
			<p class="source-code">    image: "pet-clinic-0.1-image"</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">        - "32582:32582"</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">        - kafka</p>
			<p class="source-code">        - consul</p>
			<p class="source-code">  </p>
			<p class="source-code">  pet-clinic-reviews:</p>
			<p class="source-code">    image: "pet-clinic-reviews-0.1-image"</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">        - "32583:32583"</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">        - kafka</p>
			<p class="source-code">        - consul</p>
			<p class="source-code">  </p>
			<p class="source-code">  pet-clinic-concierge:</p>
			<p class="source-code">    image: "pet-clinic-concierge-0.1-image"</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">        - "32584:32584"</p>
			<p class="source-code">    depends_on:</p>
			<p class="source-code">        - consul    </p>
			<p class="source-code">…</p>
			<p>While defining the configurations for the <strong class="source-inline">pet-clinic</strong> microservices, we can specify the dependencies using <strong class="source-inline">depends_on</strong>. This will ensure that Docker instantiates the services as per the dependency order. Also, for deploying each service, we will be using the <strong class="source-inline">pet-clinic</strong> microservices Docker images.</p>
			<p>Once the <strong class="source-inline">docker-compose</strong> file is defined for the <strong class="source-inline">pet-clinic</strong> application, refer to the following instructions to deploy the pet-clinic application:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">bash</strong> terminal.</li>
				<li>Change the directory to the location where the <strong class="source-inline">docker-compose</strong> file is stored.</li>
				<li>Type and run the <strong class="source-inline">docker compose up</strong> command.</li>
				<li>Wait for Docker to instantiate the containers as specified in the <strong class="source-inline">docker-compose</strong> file.</li>
			</ol>
			<p>After <a id="_idIndexMarker662"/>the<a id="_idIndexMarker663"/> successful run of the <strong class="source-inline">docker-compose</strong> command, we can verify the <strong class="source-inline">pet-clinic</strong> application in the Docker Dashboard, shown as follows:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_8.5_B16585_Fixed.jpg" alt="Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Verifying the deployment of pet-clinic on the Docker Dashboard</p>
			<p>In the<a id="_idIndexMarker664"/> preceding <a id="_idIndexMarker665"/>screenshot, you can see the status of all the services in the pet-clinic application. You can click on a service and monitor the logs and access the web interface (if any). Furthermore, we can check the <strong class="source-inline">consul</strong> service discovery for the health of the pet-clinic microservices. Refer to the following screenshot:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_8.6_B16585.jpg" alt="Figure 8.6 – Verifying the microservices health in service discovery&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Verifying the microservices health in service discovery</p>
			<p>In the <strong class="source-inline">consul</strong> service discovery, we can observe the health of each instance of a microservice. In the preceding screenshot, we can see all the <strong class="source-inline">pet-clinic</strong> microservices are running normally.</p>
			<p>Microservice<a id="_idIndexMarker666"/> container orchestration<a id="_idIndexMarker667"/> is the bedrock of any deployment strategy. For the scope of this chapter, we covered the local Docker deployment of the pet-clinic application, but the container images built can be deployed anywhere, be it locally or in a cloud environment, using a container orchestration tool such as <strong class="source-inline">docker-compose</strong>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor152"/>Summary</h1>
			<p>In this chapter, we jumpstarted our understanding with a discussion about making Micronaut microservices container ready. Later, we dived into using Jib for creating the container images for each microservice. We saw how to define all the service container configurations using <strong class="source-inline">docker-compose</strong> and seamlessly deploy all the required service components using a single command. </p>
			<p>This chapter enhances the deployment aspects of your Micronaut microservices journey by equipping you with first-hand knowledge on containerization and automated deployment. This skill set is much sought after in microservices application development and maintenance.</p>
			<p>In the next chapter, we will explore various ways to monitor different aspects of the pet-clinic application in Micronaut.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor153"/>Questions</h1>
			<ol>
				<li value="1">What is Jib?</li>
				<li>How can we use Jib to create a Docker container in Micronaut?</li>
				<li>How can we connect to localhost from a Docker container in Micronaut?</li>
				<li>How can we deploy a multi-service application using <strong class="source-inline">docker-compose</strong> in Micronaut?</li>
				<li>How can we perform Docker containerization of a Micronaut microservices application? </li>
			</ol>
		</div>
	</body></html>