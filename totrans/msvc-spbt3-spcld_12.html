<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer287" class="Basic-Text-Frame">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-309" class="chapterTitle">Centralized Configuration</h1>
    <p class="normal">In this chapter, we will learn how to use the <strong class="keyWord">Spring Cloud Config Server</strong> to centralize managing the configuration of our microservices. As already described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Introduction to Microservices</em>, an increased number of microservices typically comes with an increased number of configuration files that need to be managed and updated.</p>
    <p class="normal">With the Spring Cloud Config Server, we can place the configuration files for all our microservices in a central configuration repository, which will make it much easier to handle them. Our microservices will be updated to retrieve their configuration from the configuration server at startup.</p>
    <p class="normal">The following topics will be covered in this chapter:</p>
    <ul>
      <li class="bulletList">Introduction to the Spring Cloud Config Server</li>
      <li class="bulletList">Setting up a config server</li>
      <li class="bulletList">Configuring clients of a config server</li>
      <li class="bulletList">Structuring the configuration repository</li>
      <li class="bulletList">Trying out the Spring Cloud Config Server</li>
    </ul>
    <h1 id="_idParaDest-310" class="heading-1">Technical requirements</h1>
    <p class="normal">For instructions on how to install tools used in this book and how to access the source code for this book, see:</p>
    <ul>
      <li class="bulletList"><em class="chapterRef">Chapter 21</em>, <em class="italic">Installation Instructions for macOS</em></li>
      <li class="bulletList"><em class="chapterRef">Chapter 22</em>, <em class="italic">Installation Instructions for Microsoft Windows with WSL 2 and Ubuntu</em></li>
    </ul>
    <p class="normal">The code examples in this chapter all come from the source code in <code class="inlineCode">$BOOK_HOME/Chapter12</code>.</p>
    <p class="normal">If you want to view the changes applied to the source code in this chapter, that is, see what it took to add a configuration server to the microservice landscape, you can compare it with the source code for <em class="chapterRef">Chapter 11</em>, <em class="italic">Securing Access to APIs</em>. You can use your favorite <code class="inlineCode">diff</code> tool and compare the two folders <code class="inlineCode">$BOOK_HOME/Chapter11</code> and <code class="inlineCode">$BOOK_HOME/Chapter12</code>.</p>
    <h1 id="_idParaDest-311" class="heading-1">Introduction to the Spring Cloud Config Server</h1>
    <p class="normal">The Spring Cloud Config Server (shortened to <strong class="keyWord">Config Server</strong>) will be added<a id="_idIndexMarker832"/> to the existing microservice<a id="_idIndexMarker833"/> landscape behind the edge server, in the same way as for the other microservices:</p>
    <figure class="mediaobject"><img src="../Images/B19825_12_01.png" alt="" role="presentation" width="878" height="406"/></figure>
    <p class="packt_figref">Figure 12.1: Adding a config server to the system landscape</p>
    <p class="normal">When it comes to setting up a config server, there are a number of options to consider:</p>
    <ul>
      <li class="bulletList">Selecting a storage type for the configuration repository</li>
      <li class="bulletList">Deciding on the initial client connection, either to the config server or to the discovery server</li>
      <li class="bulletList">Securing the configuration, both against unauthorized access to the API and by avoiding storing sensitive information in plain text in the configuration repository</li>
    </ul>
    <p class="normal">Letâ€™s go through each option one by one and also introduce the API exposed by the config server.</p>
    <h2 id="_idParaDest-312" class="heading-2">Selecting the storage type of the configuration repository</h2>
    <p class="normal">As already described in <em class="chapterRef">Chapter 8</em>, <em class="italic">Introduction to Spring Cloud</em>, the config server supports<a id="_idIndexMarker834"/> the storing of configuration files in a number of different backends, for example:</p>
    <ul>
      <li class="bulletList">Git repository</li>
      <li class="bulletList">Local filesystem</li>
      <li class="bulletList">HashiCorp Vault</li>
      <li class="bulletList">JDBC database</li>
    </ul>
    <p class="normal">In this chapter, we will use a local filesystem. To use the local filesystem, the config server needs to be launched with the native Spring profile enabled. The location of the configuration repository is specified<a id="_idIndexMarker835"/> using the <code class="inlineCode">spring.cloud.config.server.native.searchLocations</code> property.</p>
    <h2 id="_idParaDest-313" class="heading-2">Deciding on the initial client connection</h2>
    <p class="normal">By default, a client connects<a id="_idIndexMarker836"/> first to the config server to retrieve its configuration. Based on the configuration, it connects to the discovery server, Netflix Eureka in our case, to register itself. It is also possible to do this the other way around, that is, the client first connects to the discovery server to find a config server instance and then connects to the config server to get its configuration. There are pros and cons to both approaches.</p>
    <p class="normal">In this chapter, the clients will first connect to the config server. With this approach, it will be possible to store the configuration of the discovery server in the config server.</p>
    <p class="normal">To learn more<a id="_idIndexMarker837"/> about the other alternative, see <a href="https://docs.spring.io/spring-cloud-config/docs/4.0.1/reference/html/#discovery-first-bootstrap"><span class="url">https://docs.spring.io/spring-cloud-config/docs/4.0.1/reference/html/#discovery-first-bootstrap</span></a>.</p>
    <div class="note">
      <p class="normal">One concern with connecting to the config server first is that the config server can become a single point of failure. If the clients connect first to a discovery server, such as Netflix Eureka, there can be multiple config server instances registered so that a single point of failure can be avoided. When we learn about the <strong class="keyWord">service</strong> concept in Kubernetes later on in this book, starting with <em class="chapterRef">Chapter 15</em>, <em class="italic">Introduction to Kubernetes</em>, we will see how we can avoid a single point of failure by running multiple containers, for example, config servers, behind each Kubernetes service.</p>
    </div>
    <h2 id="_idParaDest-314" class="heading-2">Securing the configuration</h2>
    <p class="normal">Configuration information<a id="_idIndexMarker838"/> will, in general, be handled as sensitive<a id="_idIndexMarker839"/> information. This means that we need to secure the configuration information both in transit and at rest. From a runtime perspective, the config server does not need to be exposed to the outside through the edge server. During development, however, it is useful to be able to access the API of the config server to check the configuration. In production environments, it is recommended to lock down external access to the config server.</p>
    <h3 id="_idParaDest-315" class="heading-3">Securing the configuration in transit</h3>
    <p class="normal">When the configuration information<a id="_idIndexMarker840"/> is asked for by a microservice, or anyone using the API of the config server, it will be protected against eavesdropping by the edge server since it already uses HTTPS.</p>
    <p class="normal">To ensure that the API user is a known client, we will use HTTP basic authentication. We can set up HTTP basic authentication by using Spring Security in the config server and specifying the environment variables <code class="inlineCode">SPRING_SECURITY_USER_NAME</code> and <code class="inlineCode">SPRING_SECURITY_USER_PASSWORD</code> with the permitted<a id="_idIndexMarker841"/> credentials.</p>
    <h3 id="_idParaDest-316" class="heading-3">Securing the configuration at rest</h3>
    <p class="normal">To avoid a situation<a id="_idIndexMarker842"/> where someone with access to the configuration repository can steal sensitive information, such as passwords, the config server supports the encryption of configuration information when stored on disk. The config server supports the use of both symmetric and asymmetric keys. Asymmetric keys are more secure but harder to manage.</p>
    <p class="normal">In this chapter, we will use a symmetric key. The symmetric key is given to the config server at startup by specifying an environment variable, <code class="inlineCode">ENCRYPT_KEY</code>. The encrypted key is just a plain text string that needs to be protected in the same way as any sensitive information.</p>
    <p class="normal">To learn more about the use<a id="_idIndexMarker843"/> of asymmetric keys, see <a href="https://docs.spring.io/spring-cloud-config/docs/4.0.1/reference/html/#_key_management"><span class="url">https://docs.spring.io/spring-cloud-config/docs/4.0.1/reference/html/#_key_management</span></a>.</p>
    <h2 id="_idParaDest-317" class="heading-2">Introducing the config server API</h2>
    <p class="normal">The config server exposes<a id="_idIndexMarker844"/> a REST API that can be used by its clients to retrieve their configuration. In this chapter, we will use the following endpoints in the API:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">/actuator</code>: The standard actuator endpoint exposed by all microservices. As always, these should be used with care. They are very useful during development but must be locked down before being used in production.</li>
      <li class="bulletList"><code class="inlineCode">/encrypt</code> and <code class="inlineCode">/decrypt</code>: Endpoints for encrypting and decrypting sensitive information. These must also be locked down before being used in production.</li>
      <li class="bulletList"><code class="inlineCode">/{microservice}/{profile}</code>: Returns the configuration for the specified microservice and the specified Spring profile.</li>
    </ul>
    <p class="normal">We will see some sample uses for the API when we try out the config server.</p>
    <h1 id="_idParaDest-318" class="heading-1">Setting up a config server</h1>
    <p class="normal">Setting up a config server<a id="_idIndexMarker845"/> on the basis of the decisions discussed is straightforward:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Spring Boot project using Spring Initializr, as described in <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating a Set of Cooperating Microservices</em>. Refer to the <em class="italic">Using Spring Initializr to generate skeleton code</em> section.</li>
      <li class="numberedList">Add the dependencies, <code class="inlineCode">spring-cloud-config-server</code> and <code class="inlineCode">spring-boot-starter-security</code>, to the Gradle build file, <code class="inlineCode">build.gradle</code>.</li>
      <li class="numberedList">Add the annotation <code class="inlineCode">@EnableConfigServer</code> to the application class, <code class="inlineCode">ConfigServerApplication</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@EnableConfigServer</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfigServerApplication</span> {
</code></pre>
      </li>
      <li class="numberedList">Add the configuration for the config server to the default property file, <code class="inlineCode">application.yml</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">server.port:</span> <span class="hljs-number">8888</span>
<span class="hljs-attr">spring.cloud.config.server.native.searchLocations:</span> <span class="hljs-string">file:${PWD}/config-repo</span>
<span class="hljs-attr">management.endpoint.health.show-details:</span> <span class="hljs-string">"ALWAYS"</span>
<span class="hljs-attr">management.endpoints.web.exposure.include:</span> <span class="hljs-string">"*"</span>
<span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">root:</span> <span class="hljs-string">info</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring.config.activate.on-profile:</span> <span class="hljs-string">docker</span>
<span class="hljs-attr">spring.cloud.config.server.native.searchLocations:</span> <span class="hljs-string">file:/config-repo</span>
</code></pre>
        <p class="normal">The most important configuration is to specify where to find the configuration repository, indicated using the <code class="inlineCode">spring.cloud.config.server.native.searchLocations</code> property.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Add a routing rule to the edge server to make the API of the config server accessible from outside the microservice landscape.</li>
      <li class="numberedList">Add a Dockerfile and a definition of the config server to the three Docker Compose files.</li>
      <li class="numberedList">Externalize sensitive configuration parameters to the standard Docker Compose environment file, <code class="inlineCode">.env</code>. The parameters are described below, in the <em class="italic">Configuring the config server for use with Docker</em> section.</li>
      <li class="numberedList">Add the config server to the common build file, <code class="inlineCode">settings.gradle</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">include</span> <span class="hljs-string">':spring-cloud:config-server'</span>
</code></pre>
      </li>
    </ol>
    <p class="normal">The source code for the Spring Cloud Config Server can be found in <code class="inlineCode">$BOOK_HOME/Chapter12/spring-cloud/config-server</code>.</p>
    <p class="normal">Now, letâ€™s look into how to set up<a id="_idIndexMarker846"/> the routing rule referred to in <em class="italic">step 5</em> and how to configure the config server added in Docker Compose, as described in <em class="italic">steps 6</em> and <em class="italic">7</em>.</p>
    <h2 id="_idParaDest-319" class="heading-2">Setting up a routing rule in the edge server</h2>
    <p class="normal">To be able to access the API<a id="_idIndexMarker847"/> of the config server<a id="_idIndexMarker848"/> from outside the microservice landscape, we add a routing rule to the edge server. All requests to the edge server that begin with <code class="inlineCode">/config</code> will be routed to the config server with the following routing rule:</p>
    <pre class="programlisting code"><code class="hljs-code"> <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">config-server</span>
   <span class="hljs-attr">uri:</span> <span class="hljs-string">http://${app.config-server}:8888</span>
  <span class="hljs-attr">predicates:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/config/**</span>
  <span class="hljs-attr">filters:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/config/(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\{segment}</span>
</code></pre>
    <p class="normal">The <code class="inlineCode">RewritePath</code> filter in the routing rule will remove the leading part, <code class="inlineCode">/config</code>, from the incoming URL before it sends it to the config server.</p>
    <p class="normal">The edge server is also configured to permit all requests to the config server, delegating the security checks to the config server. The following line is added to the <code class="inlineCode">SecurityConfig</code> class in the edge server:</p>
    <pre class="programlisting code"><code class="hljs-code">  .pathMatchers(<span class="hljs-string">"/config/**"</span>).permitAll()
</code></pre>
    <p class="normal">With this routing rule in place, we can use the API of the config server; for example, run the following command to ask for the configuration of the <code class="inlineCode">product</code> service when it uses the <code class="inlineCode">docker</code> Spring profile:</p>
    <pre class="programlisting con"><code class="hljs-con">curl https://dev-usr:dev-pwd@localhost:8443/config/product/docker -ks | jq
</code></pre>
    <p class="normal">We will run this command <a id="_idIndexMarker849"/>when we try out the config<a id="_idIndexMarker850"/> server later on.</p>
    <h2 id="_idParaDest-320" class="heading-2">Configuring the config server for use with Docker</h2>
    <p class="normal">The Dockerfile of the config server<a id="_idIndexMarker851"/> looks the same as for the other<a id="_idIndexMarker852"/> microservices, except for the fact that it exposes port <code class="inlineCode">8888</code> instead of port <code class="inlineCode">8080</code>.</p>
    <p class="normal">When it comes to adding the config server to the Docker Compose files, it looks a bit different from what we have seen for the other microservices:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">config-server:</span>
  <span class="hljs-attr">build:</span> <span class="hljs-string">spring-cloud/config-server</span>
  <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">512m</span>
  <span class="hljs-attr">environment:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_PROFILES_ACTIVE=docker,native</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">ENCRYPT_KEY=${CONFIG_SERVER_ENCRYPT_KEY}</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_SECURITY_USER_NAME=${CONFIG_SERVER_USR}</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">SPRING_SECURITY_USER_PASSWORD=${CONFIG_SERVER_PWD}</span>
  <span class="hljs-attr">volumes:</span>
    <span class="hljs-bullet">-</span> <span class="hljs-string">$PWD/config-repo:/config-repo</span>
</code></pre>
    <p class="normal">Here are the explanations for the preceding source code:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The Spring profile, <code class="inlineCode">native</code>, is added to signal to the config server that the config repository is based on local files.</li>
      <li class="numberedList">The environment variable <code class="inlineCode">ENCRYPT_KEY</code> is used to specify the symmetric encryption key that will be used by the config server to encrypt and decrypt sensitive configuration information.</li>
      <li class="numberedList">The environment variables <code class="inlineCode">SPRING_SECURITY_USER_NAME</code> and <code class="inlineCode">SPRING_SECURITY_USER_PASSWORD</code> are used to specify the credentials to be used for protecting the APIs using basic HTTP authentication.</li>
      <li class="numberedList">The <code class="inlineCode">volumes</code> declaration will make the <code class="inlineCode">config-repo</code> folder accessible in the Docker container at <code class="inlineCode">/config-repo</code>.</li>
    </ol>
    <p class="normal">The values of the three preceding environment variables, marked in the Docker Compose file with <code class="inlineCode">${...}</code>, are fetched<a id="_idIndexMarker853"/> by Docker Compose<a id="_idIndexMarker854"/> from the <code class="inlineCode">.env</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">CONFIG_SERVER_ENCRYPT_KEY=my-very-secure-encrypt-key
CONFIG_SERVER_USR=dev-usr
CONFIG_SERVER_PWD=dev-pwd
</code></pre>
    <div class="packt_tip">
      <p class="normal">The information stored in the <code class="inlineCode">.env</code> file, that is, the username, password, and encryption key, is sensitive and must be protected if used for something other than development and testing. Also, note that losing the encryption key will lead to a situation where the encrypted information in the config repository cannot be decrypted!</p>
    </div>
    <h1 id="_idParaDest-321" class="heading-1">Configuring clients of a config server</h1>
    <p class="normal">To be able to get their configurations<a id="_idIndexMarker855"/> from the config server, our microservices need to be updated. This can be done with the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <code class="inlineCode">spring-cloud-starter-config</code> and <code class="inlineCode">spring-retry</code> dependencies to the Gradle build file, <code class="inlineCode">build.gradle</code>.</li>
      <li class="numberedList">Move the configuration file, <code class="inlineCode">application.yml</code>, to the config repository and rename it with the name of the client as specified by the property <code class="inlineCode">spring.application.name</code>.</li>
      <li class="numberedList">Add a new <code class="inlineCode">application.yml</code> file to the <code class="inlineCode">src/main/resources</code> folder. This file will be used to hold the configuration required to connect to the config server. Refer to the following <em class="italic">Configuring connection information</em> section for an explanation of its content.</li>
      <li class="numberedList">Add credentials for accessing the config server to the Docker Compose files, for example, the <code class="inlineCode">product</code> service:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">product:</span>
  <span class="hljs-attr">environment:</span>
 <span class="hljs-bullet">-</span> <span class="hljs-string">CONFIG_SERVER_USR=${CONFIG_SERVER_USR}</span>
 <span class="hljs-bullet">-</span> <span class="hljs-string">CONFIG_SERVER_PWD=${CONFIG_SERVER_PWD}</span>
</code></pre>
      </li>
      <li class="numberedList">Disable the use of the config server when running Spring Boot-based automated tests. This is done by adding <code class="inlineCode">spring.cloud.config.enabled=false</code> to the <code class="inlineCode">@DataMongoTest</code>, <code class="inlineCode">@DataJpaTest</code>, and <code class="inlineCode">@SpringBootTest</code> annotations. They look like this:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@DataMongoTest(properties = {"spring.cloud.config.enabled=false"})</span>
<span class="hljs-meta">@DataJpaTest(properties = {"spring.cloud.config.enabled=false"})</span>
<span class="hljs-meta">@SpringBootTest(webEnvironment=RANDOM_PORT, properties = {"eureka.client.enabled=false", "spring.cloud.config.enabled=false"})</span>
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-322" class="heading-2">Configuring connection information</h2>
    <p class="normal">As mentioned<a id="_idIndexMarker856"/> previously, the <code class="inlineCode">src/main/resources/application.yml</code> file now holds the client configuration that is required to connect to the config server. This file has the same content for all clients of the config server, except for the application name, as specified by the <code class="inlineCode">spring.application.name</code> property (in the following example, set to <code class="inlineCode">product</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">spring.config.import:</span> <span class="hljs-string">"configserver:"</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application.name:</span> <span class="hljs-string">product</span>
  <span class="hljs-attr">cloud.config:</span>
    <span class="hljs-attr">failFast:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">retry:</span>
      <span class="hljs-attr">initialInterval:</span> <span class="hljs-number">3000</span>
      <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1.3</span>
      <span class="hljs-attr">maxInterval:</span> <span class="hljs-number">10000</span>
      <span class="hljs-attr">maxAttempts:</span> <span class="hljs-number">20</span>
    <span class="hljs-attr">uri:</span> <span class="hljs-string">http://localhost:8888</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">${CONFIG_SERVER_USR}</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">${CONFIG_SERVER_PWD}</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring.config.activate.on-profile:</span> <span class="hljs-string">docker</span>
<span class="hljs-attr">spring.cloud.config.uri:</span> <span class="hljs-string">http://config-server:8888</span>
</code></pre>
    <p class="normal">This configuration will make the client do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Connect to the config server using the <code class="inlineCode">http://localhost:8888</code> URL when it runs outside Docker, and using the <code class="inlineCode">http://config-server:8888</code> URL when running in a Docker container</li>
      <li class="numberedList">Use HTTP Basic authentication, based on the value of the <code class="inlineCode">CONFIG_SERVER_USR</code> and <code class="inlineCode">CONFIG_SERVER_PWD</code> properties, as the clientâ€™s username and password</li>
      <li class="numberedList">Try to reconnect to the config server during startup up to 20 times, if required</li>
      <li class="numberedList">If the connection attempt fails, the client will initially wait for 3 seconds before trying to reconnect</li>
      <li class="numberedList">The wait time for subsequent retries will increase by a factor of 1.3</li>
      <li class="numberedList">The maximum wait time between connection attempts will be 10 seconds</li>
      <li class="numberedList">If the client canâ€™t connect to the config server after 20 attempts, its startup will fail</li>
    </ol>
    <p class="normal">This configuration is generally good for resilience against temporary connectivity problems with the config server. It is especially useful when the whole landscape of microservices and its config server are started up at once, for example, when using the <code class="inlineCode">docker-compose up</code> command. In this scenario, many of the clients will be trying to connect to the config server before it is ready, and the <code class="inlineCode">retry</code> logic will make the clients<a id="_idIndexMarker857"/> connect to the config server successfully once it is up and running.</p>
    <h1 id="_idParaDest-323" class="heading-1">Structuring the configuration repository</h1>
    <p class="normal">After moving the configuration<a id="_idIndexMarker858"/> files from each clientâ€™s source code to the configuration repository, we will have some common configuration in many of the configuration files, for example, for the configuration of actuator endpoints and how to connect to Eureka, RabbitMQ, and Kafka. </p>
    <p class="normal">The common parts have been placed in a common configuration file named <code class="inlineCode">application.yml</code>. This file is shared by all clients. The configuration repository contains the following files:</p>
    <pre class="programlisting code"><code class="hljs-code">config-repo/
â”œâ”€â”€ application.yml
â”œâ”€â”€ auth-server.yml
â”œâ”€â”€ eureka-server.yml
â”œâ”€â”€ gateway.yml
â”œâ”€â”€ product-composite.yml
â”œâ”€â”€ product.yml
â”œâ”€â”€ recommendation.yml
â””â”€â”€ review.yml
</code></pre>
    <p class="normal">The configuration repository can be found in <code class="inlineCode">$BOOK_HOME/Chapter12/config-repo</code>.</p>
    <h1 id="_idParaDest-324" class="heading-1">Trying out the Spring Cloud Config Server</h1>
    <p class="normal">Now it is time to try out the config server:</p>
    <ul>
      <li class="bulletList">First, we will build from source and run the test script to ensure that everything fits together.</li>
      <li class="bulletList">Next, we will try out the config server API to retrieve the configuration for our microservices.</li>
      <li class="bulletList">Finally, we will see how we can encrypt and decrypt sensitive information, for example, passwords.</li>
    </ul>
    <h2 id="_idParaDest-325" class="heading-2">Building and running automated tests</h2>
    <p class="normal">So, now we build<a id="_idIndexMarker859"/> and run verification<a id="_idIndexMarker860"/> tests of the system landscape, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Build the Docker images with the following commands:
        <pre class="programlisting con"><code class="hljs-con">cd $BOOK_HOME/Chapter12
./gradlew build &amp;&amp; docker-compose build
</code></pre>
      </li>
      <li class="numberedList">Start the system landscape in Docker and run the usual tests with the following command:
        <pre class="programlisting con"><code class="hljs-con">./test-em-all.bash start
</code></pre>
      </li>
    </ol>
    <h2 id="_idParaDest-326" class="heading-2">Getting the configuration using the config server API</h2>
    <p class="normal">As described previously, we can reach the API<a id="_idIndexMarker861"/> of the config server through the edge<a id="_idIndexMarker862"/> server by using the URL prefix, <code class="inlineCode">/config</code>. We also have to supply credentials as specified in the <code class="inlineCode">.env</code> file for HTTP Basic authentication. For example, to retrieve the configuration used for the <code class="inlineCode">product</code> service when it runs as a Docker container, that is, having activated the Spring profile <code class="inlineCode">docker</code>, run the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">curl https://dev-usr:dev-pwd@localhost:8443/config/product/docker -ks | jq .
</code></pre>
    <p class="normal">Expect a response with the following structure (many of the properties in the response are replaced by <code class="inlineCode">...</code> to increase readability):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"product"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"profiles"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"docker"</span>
  <span class="hljs-punctuation">],</span>
  ...
  <span class="hljs-attr">"propertySources"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"...file [/config-repo/product.yml]..."</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"spring.config.activate.on-profile"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"docker"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"server.port"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8080</span><span class="hljs-punctuation">,</span>
        ...
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"...file [/config-repo/product.yml]..."</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"server.port"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">7001</span><span class="hljs-punctuation">,</span>
        ...
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"...file [/config-repo/application.yml]..."</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        <span class="hljs-attr">"spring.config.activate.on-profile"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"docker"</span><span class="hljs-punctuation">,</span>
        ...
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">},</span>
    <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"...file [/config-repo/application.yml]..."</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">"source"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
        ...
        <span class="hljs-attr">"app.eureka-password"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"p"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">"spring.rabbitmq.password"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"guest"</span>
      <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
    <p class="normal">The explanations for this response are as follows:</p>
    <ul>
      <li class="bulletList">The response contains properties from a number of <strong class="keyWord">property sources</strong>, one per property file and Spring profile that matched the API request. The property sources are returned in priority order; if a property is specified in multiple property sources, the first property in the response takes precedence. The preceding sample response contains the following property sources, in the following priority order:<ul>
          <li class="bulletList"><code class="inlineCode">/config-repo/product.yml</code>, for the <code class="inlineCode">docker</code> Spring profile</li>
          <li class="bulletList"><code class="inlineCode">/config-repo/product.yml</code>, for the <code class="inlineCode">default</code> Spring profile</li>
          <li class="bulletList"><code class="inlineCode">/config-repo/application.yml</code>, for the <code class="inlineCode">docker</code> Spring profile</li>
          <li class="bulletList"><code class="inlineCode">/config-repo/application.yml</code>, for the <code class="inlineCode">default</code> Spring profile</li>
        </ul>
        <p class="normal">For example, the port used will be <code class="inlineCode">8080</code> and not <code class="inlineCode">7001</code>, since <code class="inlineCode">"server.port": 8080</code> is specified before <code class="inlineCode">"server.port": 7001</code> in the preceding response.</p>
      </li>
    </ul>
    <ul>
      <li class="bulletList">Sensitive information, such as the passwords<a id="_idIndexMarker863"/> to Eureka and RabbitMQ, are returned<a id="_idIndexMarker864"/> in plain text, for example, <code class="inlineCode">"p"</code> and <code class="inlineCode">"guest"</code>, but they are encrypted on disk. In the configuration file, <code class="inlineCode">application.yml</code>, they are specified as follows:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">app:</span>
  <span class="hljs-attr">eureka-password:</span>
<span class="hljs-string">'{cipher}bf298f6d5f878b342f9e44bec08cb9ac00b4ce57e98316f030194a225fac89fb'</span>
<span class="hljs-attr">spring.rabbitmq:</span>
  <span class="hljs-attr">password:</span> <span class="hljs-string">'{cipher}17fcf0ae5b8c5cf87de6875b699be4a1746dd493a99d926c7a26a68c422117ef'</span>
</code></pre>
      </li>
    </ul>
    <h2 id="_idParaDest-327" class="heading-2">Encrypting and decrypting sensitive information</h2>
    <p class="normal">Information can be encrypted<a id="_idIndexMarker865"/> and decrypted<a id="_idIndexMarker866"/> using the <code class="inlineCode">/encrypt</code> and <code class="inlineCode">/decrypt</code> endpoints exposed by the config server. The <code class="inlineCode">/encrypt</code> endpoint can be used to create encrypted values to be placed in the <code class="inlineCode">property</code> file in the config repository. Refer to the example in the previous section, where the passwords to Eureka and RabbitMQ are stored encrypted on disk. The <code class="inlineCode">/decrypt</code> endpoint can be used to verify encrypted information that is stored on disk in the config repository.</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">To encrypt the <code class="inlineCode">hello world</code> string, run the following command:
        <pre class="programlisting con"><code class="hljs-con">curl -k https://dev-usr:dev-pwd@localhost:8443/config/encrypt --data-urlencode "hello world"
</code></pre>
        <div class="packt_tip">
          <p class="normal">It is important to use the <code class="inlineCode">--data-urlencode</code> flag when using <code class="inlineCode">curl</code> to call the <code class="inlineCode">/encrypt</code> endpoint, to ensure the correct handling of special characters such as <code class="inlineCode">+</code>.</p>
        </div>
        <p class="normal">Expect a response along the lines of the following:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_12_02.png" alt="Graphical user interface, text, application  Description automatically generated" width="812" height="90"/></figure>
    <p class="packt_figref">Figure 12.2: An encrypted value of a configuration parameter</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">To decrypt the encrypted<a id="_idIndexMarker867"/> value, run<a id="_idIndexMarker868"/> the following command:
        <pre class="programlisting con"><code class="hljs-con">curl -k https://dev-usr:dev-pwd@localhost:8443/config/decrypt -d d91001603dcdf3eb1392ccbd40ff201cdcf7b9af2fcaab3da39e37919033b206
</code></pre>
        <p class="normal">Expect the <code class="inlineCode">hello world</code> string as the response:</p>
      </li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B19825_12_03.png" alt="" role="presentation" width="145" height="74"/></figure>
    <p class="packt_figref">Figure 12.3: A decrypted value of a configuration parameter</p>
    <div class="note">
      <p class="normal">If you want to use an encrypted value in a configuration file, you need to prefix it with <code class="inlineCode">{cipher}</code> and wrap it in <code class="inlineCode">''</code>. For example, to store the encrypted version of <code class="inlineCode">hello world</code>, add the following line in a YAML-based configuration file:</p>
      <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attr">my-secret:</span> <span class="hljs-string">'{cipher}d91001603dcdf3eb1392ccbd40ff201cdcf7b9af2 fcaab3da39e37919033b206'</span>
</code></pre>
      <p class="normal">When the config server detects values in the format <code class="inlineCode">'{cipher}...'</code>, it tries to decrypt them using its encryption key before sending them to a client.</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">These tests conclude the chapter on centralized configuration. Wrap it up by shutting<a id="_idIndexMarker869"/> down the system<a id="_idIndexMarker870"/> landscape:
        <pre class="programlisting con"><code class="hljs-con">docker-compose down
</code></pre>
      </li>
    </ol>
    <h1 id="_idParaDest-328" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have seen how we can use the Spring Cloud Config Server to centralize managing the configuration of our microservices. We can place the configuration files in a common configuration repository and share common configurations in a single configuration file while keeping microservice-specific configuration in microservice-specific configuration files. The microservices have been updated to retrieve their configuration from the config server at startup and are configured to handle temporary outages while retrieving their configuration from the config server.</p>
    <p class="normal">The config server can protect configuration information by requiring authenticated usage of its API with HTTP basic authentication and can prevent eavesdropping by exposing its API externally through the edge server that uses HTTPS. To prevent intruders who obtained access to the configuration files on disk from gaining access to sensitive information such as passwords, we can use the config server <code class="inlineCode">/encrypt</code> endpoint to encrypt the information and store it encrypted on disk.</p>
    <p class="normal">While exposing the APIs from the config server externally is useful during development, they should be locked down before use in production.</p>
    <p class="normal">In the next chapter, we will learn how we can use <strong class="keyWord">Resilience4j</strong> to mitigate the potential drawbacks of overusing synchronous communication between microservices.</p>
    <h1 id="_idParaDest-329" class="heading-1">Questions</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What API call can we expect from a review service to the config server during startup to retrieve its configuration?</li>
      <li class="numberedList">The review service was started up using the following command: <code class="inlineCode">docker compose up -d</code>. <p class="normal">What configuration information should we expect back from an API call to the config server using the following command?</p>
        <pre class="programlisting con"><code class="hljs-con">curl https://dev-usr:dev-pwd@localhost:8443/config/application/default -ks | jq 
</code></pre>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">What types of repository backend does Spring Cloud Config support?</li>
      <li class="numberedList">How can we encrypt sensitive information on disk using the Spring Cloud Config Server?</li>
      <li class="numberedList">How can we protect the config server API from misuse?</li>
      <li class="numberedList">Mention some pros and cons for clients that first connect to the config server as opposed to those that first connect to the discovery server.</li>
    </ol>
  </div>
</div>
</div>
</body></html>