- en: Chapter 7. Concepts of Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen data structures such as linked list and array. They represent
    data stored in a linear fashion. In this chapter, we will discuss a new kind of
    data structure, called a tree. A tree is a generalization of a linked list. While
    a linked list node has one reference to the next node, a tree node has references
    to possibly more than one next node. These next nodes are called children of the
    node, and the node holding the references to the children is called a parent node.
    In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Concept of a tree as a data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept of a tree as an ADT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different kinds of tree traversals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tree search algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's jump into it right away.
  prefs: []
  type: TYPE_NORMAL
- en: A tree data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tree data structure looks very much like a real tree, the kind you can see
    in a garden or by the roadside. If we look at a tree, we will see that it has
    a root that makes the stem outside of the ground. The stem splits into branches,
    and at the end of the branches, we find leaves. In our tree data structure, we
    start from the root. The root is the node that does not have any parent. The children
    can be thought of as being attached to the stem by lines just like the branches
    of a real tree. At the end, we find some nodes that have no children and hence
    are called leaves. The following figure shows an example of a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree data structure](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example tree
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tree is drawn upside down. The root is at the top and the leaves
    are below. This is just a convention that most people prefer. Think of this as
    the reflection of a tree on water.
  prefs: []
  type: TYPE_NORMAL
- en: A tree can be represented in many ways, but we will get started with the idea
    of generalization of a **linked** list. In the case of a linked list, a node stores
    a single reference that points to the next node. In a tree, a node needs to store
    the references to all its children. Multiple children could be stored in an array,
    but since we have access to our own class `LinkedList`, we will use that. We will
    use our non-functional version of the linked list because our first tree will
    be non-functional and will allow modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined our `Node` class as an inner class. Apart from remembering
    the value it stores inside and the list of children, it also stores the parent
    and the tree that it is a member of. Once we create an instance of a tree, we
    must be able to store a node in it. The node that does not have a parent is called
    the root of the tree. So, we add an `addRoot` method to add a root to the tree.
    The tree, itself, only has to store the reference of the root node as all the
    other nodes can be reached from this node by traversing the references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we test whether the tree already has a root node, in which case, we
    throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now that we have a way of adding a root node, we need to have a method
    for adding nodes as we like. The method takes a parent node and a value in order
    to add a new node. This method will return the newly added node so that we keep
    adding more nodes as its children:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first check whether the parent is null or whether
    the parent is the node of a different tree instance. In either case, an exception
    must be thrown. Otherwise, we just add a new node as the child of the parent node
    passed as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait a second! How would we ever be able to pass a parent node if we do
    not have a reference to the root node in the calling code? So, we add a method,
    `getRoot`, to access the root node of the Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now let''s create a `Tree` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is self-explanatory. We just create a tree by adding the nodes one
    by one. But how do we see what the tree looks like? For that, we will have to
    learn about the traversal of a tree. The preceding code will create the tree shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A tree data structure](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example tree
  prefs: []
  type: TYPE_NORMAL
- en: The traversal of a tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree traversal is an algorithm to visit or to process all nodes of a tree exactly
    once. This obviously involves recursively looking into the children of the nodes.
    The order in which the children are processed depends on the particular algorithm
    we use. The simplest algorithm for traversing a tree is the depth-first traversal.
  prefs: []
  type: TYPE_NORMAL
- en: The depth-first traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the depth-first traversal, we process every child of a node recursively and
    wait for it to finish with all its descendants before proceeding to the next child.
    To understand the depth-first search, we have to understand what a subtree is.
    A subtree is a node with all its descendants up to the leaves. The following figure
    shows some examples of subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: '![The depth-first traversal](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Examplesubtrees
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you think about it, each node not only stores references to the children,
    but also sort of holds references to entire subtrees rooted at the child nodes.
    So, the depth-first traversal algorithm is nothing but the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Process the value in the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each child node of the current node, recursively traverse the entire subtree
    rooted at the child node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following method does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes a lambda and a node to traverse. All this method does is first
    run the lambda on the current value and then call itself recursively on each of
    the subtrees. Now, we can write a wrapper method without the parent node argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is still not clear, though, why this way of traversing is called a depth-first
    traversal. If you think about the order in which the nodes are processed, you
    can see that since the complete subtree root at any child node must be entirely
    processed before the next child is processed, the depth of the tree will be covered
    before the breadth.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used a recursive function to do our depth-first search. Alternatively,
    we can use a stack to do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what is happening in the preceding piece of code. We first push the
    root into the stack and go in a loop that continues until all the stack elements
    have been cleared. Every time we pop a node, we process it and push all its children
    into the stack. Now, since the stack is **last in first out** (**LIFO**), all
    these children will be popped and processed before any other node can be processed.
    However, the moment the first of these children is popped, its children will be
    pushed into the stack and would be processed before anything else is processed.
    This will go on until we hit the leaf nodes, which would not have any more children.
    This, in effect, is almost the same as the recursive version.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a slight difference between the outputs of this code and the recursive
    version, although both are indeed depth-first. However, please note that in the
    case of the recursive version, the child that is near the head of the linked list
    is processed first. In the case of the stack version, we push the children in
    the same order, but since the stack is LIFO, we pop the children in the reverse
    order. To reverse this order, we can store the list of children in the opposite
    order in a temporary list before pushing them into the stack, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The list is reversed by storing in a temporary list, called `reverseList`, by
    appending the elements to its beginning. Then, the elements are pushed into the
    stack from `reverseList`.
  prefs: []
  type: TYPE_NORMAL
- en: The breadth-first traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breadth-first traversal is the opposite of the depth-first traversal, in the
    sense that depth-first traversal processes children before siblings and breadth-first
    traversal processes the nodes of the same level before it processes any node of
    the succeeding level. In other words, in a breadth-first traversal, the nodes
    are processed level by level. This is simply achieved by taking the stack version
    of the depth-first traversal and replacing the stack with a queue. That is all
    that is needed for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that everything else remains exactly the same as that of the depth-first
    traversal. We still take one element from the queue, process its value and then
    enqueue the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why the use of a queue lets us process nodes level by level,
    we need the following analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Root is pushed in the beginning, so root is dequeued first and processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the root is processed, the children of root, that is the nodes in level
    1, get enqueued. This means the level 1 nodes would be dequeued before any further
    levels are dequeued.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any node in level 1 is dequeued next, its children, which are the nodes
    of level 2, will all get enqueued. However, since all the nodes in level 1 are
    enqueued in the previous step, the nodes of level 2 will not be dequeued before
    the nodes of level 1 are dequeued. When all the nodes of level 1 are dequeued
    and processed, all the level 2 nodes would be enqueued because they are all children
    of level 1 nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means all the level 2 nodes would be dequeued and processed before any
    nodes of higher levels are processed. When all the level 2 nodes are already processed,
    all the level 3 nodes would be enqueued.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a similar manner, in all further levels, all the nodes in a particular level
    will be processed before all the nodes of the next level are processed. In other
    words, the nodes will be process level by level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tree abstract data type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have some idea of the tree, we can define the tree ADT. A tree
    ADT can be defined in multiple ways. We will check out two. In an imperative setting,
    that is, when trees are mutable, we can define a tree ADT as having the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the root node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a node, get its children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all that is required to have a model for a tree. We may also include
    some appropriate mutation methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive definition for the tree ADT can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A tree is an ordered pair containing the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a list of other trees, which are meant to be it's subtrees
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can develop a tree implementation in exactly the same way as it is defined
    in the functional tree ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As defined in the ADT, the tree is an ordered pair of a value and a list of
    other trees, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is quite simple. The depth-first traversal can be achieved
    using recursive calls to the children, which are indeed subtrees. A tree without
    any children needs to have an empty list of children. With this, we can create
    the functional version of the same tree that we had created for an imperative
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we can do a depth-first traversal to see if it outputs the same
    tree as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Binary tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A binary tree is a tree that has a maximum of two children per node. The two
    children can be called the left and the right child of a node. The following figure
    shows an example of a binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binary tree](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example binary tree
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular tree is important mostly because of its simplicity. We can
    create a `BinaryTree` class by inheriting the general tree class. However, it
    will be difficult to stop someone from adding more than two nodes and will take
    a lot of code just to perform the checks. So, instead, we will create a `BinaryTree`
    class from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Node` has a very obvious implementation just like the generic tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the root is exactly the same as that for a generic tree, except for
    the fact that we don''t check for the existence of the root. This is just to save
    space; you can implement as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method lets us add a child. It takes a Boolean parameter that
    is `true` when the child to be added is the left child and `false` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create two wrapper methods for specifically adding either the left or
    the right child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the traversal algorithms for a generic tree would also work for this
    special case. However, for a binary tree, the depth-first traversal can be of
    three different types.
  prefs: []
  type: TYPE_NORMAL
- en: Types of depth-first traversals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The depth-first traversal of a binary tree can be of three types according
    to when the parent node is processed with respect to when the child subtrees are
    processed. The orders can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-order traversal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the parent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the left subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the right subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In-order traversal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the left subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the parent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the right subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Post-order traversal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the left subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the right subtree.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the parent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These different traversal types will produce a slightly different ordering
    when traversing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an `enum` `DepthFirstTraversalType` to pass to the `traverseDepthFirst`
    method. We process the current node according to its value. Note that the only
    thing that changes is when the processor is called to process a node. Let''s create
    a binary tree and see how the results differ in the case of each ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created the same binary tree as shown in the previous figure. The following
    is the output of the program. Try to relate how the positions are getting affected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take a note of the following points while matching the program output:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a pre-order traversal, in any path starting from the root to
    any leaf, a parent node will always be printed before any of the children.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of an in-order traversal, if we look at any path from the root to
    a particular leaf, whenever we move from the parent to the left child, the parent's
    processing is postponed. But whenever we move from the parent to the right child,
    the parent is immediately processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a post-order traversal, all the children are processed before
    any parent is processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-recursive depth-first search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The depth-first search we have seen for the general tree is pre-order in the
    sense that the parent node is processed before any of the children are processed.
    So, we can use the same implementation for the pre-order traversal of a binary
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have to check whether the children are null. This is because the absence
    of children is expressed as null references instead of an empty list, as in the
    case of a generic tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation of the in-order and post-order traversals is a bit tricky. We
    need to suspend processing of the parent node even when the children are expanded
    and pushed to the stack. We can achieve this by pushing each node twice. Once,
    we push it when it is first discovered due to its parent being expanded, and the
    next time we do it when its own children are expanded. So, we must remember which
    of these pushes caused it to be in the stack when it''s popped. This is achieved
    using an additional flag, which is then wrapped up in a class called `StackFrame`.
    The in-order algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the stack is LIFO, so the thing that needs to be popped later must
    be pushed earlier. The post-order version is extremely similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only thing that has changed is the order of pushing the children
    and the parent. Now we write the following code to test these out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We preserved the recursive versions as well so that we can compare the output,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines are the same as the last three, showing that they produce
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned what a tree is. We started out with an actual
    implementation and then designed an ADT out of it. You also learned about a binary
    tree, which is just a tree with a maximum of two children per node. We also saw
    different traversal algorithms for a generic tree. They are depth-first and breadth-first
    traversals. In the case of a binary tree, a depth-first traversal can be done
    in three different ways: pre-order, in-order, and post-order. Even in the case
    of a generic tree, we can find equivalents of the pre-order and post-order traversals
    for a depth-first traversal. However, it is difficult to point to any particular
    equivalent of an in-order traversal as it is possible to have more than two children.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see the use of a binary tree in searching, and
    we will see some other ways of searching as well.
  prefs: []
  type: TYPE_NORMAL
