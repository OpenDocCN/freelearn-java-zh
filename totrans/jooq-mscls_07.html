<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-77"><em class="italic"><a id="_idTextAnchor076"/>Chapter 5</em>: Tackling Different Kinds of SELECT, INSERT, UPDATE, DELETE, and MERGE</h1>
			<p>A common scenario for jOOQ beginners originates from having a plain valid SQL that should be expressed via the jOOQ DSL API. While the jOOQ DSL API is extremely intuitive and easy to learn, the lack of practice may still lead to scenarios where we simply cannot find or intuit the proper DSL methods that should be chained to express a certain SQL.</p>
			<p>This chapter addresses this kind of issue via a comprehensive collection of popular queries, which gives you the chance to practice jOOQ DSL syntax based on the Java-based schema. More precisely, our aim is to express, in jOOQ DSL syntax, a carefully harvested list of <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong> statements that are used in our day-to-day job.</p>
			<p>This way, by the end of this chapter, you should have funneled a significant number of SQLs through the jOOQ DSL syntax and tried them out against MySQL, PostgreSQL, SQL Server, and Oracle databases in Java applications based on Maven and Gradle. Being dialect-agnostic, jOOQ DSL excels at handling tons of dialect-specific issues by emulating a valid syntax, therefore, this is also a good chance to taste this aspect for these four popular databases.</p>
			<p>Notice that, even if you see some performance tips, our focus is not on finding the best SQL or the most optimal SQL for a certain use case. This is not our goal! Our goal is to learn the jOOQ DSL syntax at a decent level that allows writing almost any <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong> statement in a productive manner.</p>
			<p>In this context, our agenda contains the following:</p>
			<ul>
				<li>Expressing <strong class="source-inline">SELECT</strong> statements</li>
				<li>Expressing <strong class="source-inline">INSERT</strong> statements</li>
				<li>Expressing <strong class="source-inline">UPDATE</strong> statements</li>
				<li>Expressing <strong class="source-inline">DELETE</strong> statements</li>
				<li>Expressing <strong class="source-inline">MERGE</strong> statements</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter05</a>.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Expressing SELECT statements</h1>
			<p>In this section, we will express/write via jOOQ DSL syntax a wide range of <strong class="source-inline">SELECT</strong> statements, including common<a id="_idIndexMarker365"/> projections, popular subqueries, scalar and correlated subqueries, unions, and row value expressions. We'll start with the commonly used projections.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Expressing commonly used projections</h2>
			<p>By <em class="italic">commonly used projections</em>, we understand the projections written against the well-known dummy table, <strong class="source-inline">DUAL</strong>. As you most <a id="_idIndexMarker366"/>probably know, the <strong class="source-inline">DUAL</strong> table is specific to Oracle; it's mostly unnecessary in MySQL (although jOOQ still renders it for MySQL 5.7 compatibility) and doesn't exist in PostgreSQL and SQL Server.</p>
			<p>In this context, even if the SQL standard requires a <strong class="source-inline">FROM</strong> clause, jOOQ never requires such a clause and it renders the <strong class="source-inline">DUAL</strong> table whenever it is needed/supported. For example, selecting <em class="italic">0</em> and <em class="italic">1</em> can be done via the  <strong class="source-inline">selectZero()</strong> and <strong class="source-inline">selectOne()</strong>methods (these statics are available in <strong class="source-inline">org.jooq.impl.DSL</strong>). The latter (<strong class="source-inline">selectOne()</strong>), including some alternatives, is exemplified next:</p>
			<pre class="source-code">MySQL 8.x                          : select 1 as `one`</pre>
			<pre class="source-code">PostgreSQL (no dummy-table concept): select 1 as "one"</pre>
			<pre class="source-code">ctx.selectOne().fetch();</pre>
			<pre class="source-code">ctx.select(val(1).as("one")).fetch();</pre>
			<pre class="source-code">ctx.fetchValue((val(1).as("one")));</pre>
			<p>As a parenthesis, the DSL class also expose three helpers for expressing the commonly used <strong class="source-inline">0 literal (DSL.zero())</strong>, <strong class="source-inline">1 literal (DSL.one())</strong>, and <strong class="source-inline">2 literal (DSL.two())</strong>. So, while selectZero() results in a new DSL subselect for a constant 0 literal, the zero() represents the 0 literal itself. Selecting ad hoc values can be done as follows (since we cannot use plain values in <strong class="source-inline">select()</strong>, we rely on the <strong class="source-inline">val()</strong> method introduced in <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>, to obtain the proper parameters):</p>
			<pre class="source-code">Oracle: select 1 "A", 'John' "B", 4333 "C", 0 "D" from dual</pre>
			<pre class="source-code">ctx.select(val(1).as("A"), val("John").as("B"), </pre>
			<pre class="source-code">           val(4333).as("C"), val(false).as("D")).fetch();</pre>
			<p>Or, it can be done via the <strong class="source-inline">values()</strong> table constructor, which allows us to express in-memory temporary tables. With jOOQ, the <strong class="source-inline">values()</strong> table constructor can be used to create tables that can be used in a <strong class="source-inline">SELECT</strong> statement's <strong class="source-inline">FROM</strong> clause. Notice how we specified the column<a id="_idIndexMarker367"/> aliases ("derived column lists") along with the table alias (<strong class="source-inline">"t"</strong>) for the <strong class="source-inline">values()</strong> constructor:</p>
			<pre class="source-code">MySQL: </pre>
			<pre class="source-code">select `t`.`A`, ..., `t`.`D`        </pre>
			<pre class="source-code">  from (select null as `A`, ..., null as `D`            </pre>
			<pre class="source-code">          where false </pre>
			<pre class="source-code">          union all</pre>
			<pre class="source-code">            select * from </pre>
			<pre class="source-code">              (values row ('A', 'John', 4333, false)) as `t`</pre>
			<pre class="source-code">       ) as `t`</pre>
			<pre class="source-code">ctx.select().from(values(row("A", "John", 4333, false))</pre>
			<pre class="source-code">   .as("t", "A", "B", "C", "D")).fetch();</pre>
			<p>Here is another alternative to <strong class="source-inline">selectOne()</strong>:</p>
			<pre class="source-code">PostgreSQL (no dummy-table concept): </pre>
			<pre class="source-code">select "t"."one" from (values (1)) as "t" ("one")</pre>
			<pre class="source-code">ctx.select().from(values(row(1)).as("t", "one")).fetch();</pre>
			<p>We can also specify an explicit <strong class="source-inline">FROM</strong> clause to point out some specific tables. Here is an example:</p>
			<pre class="source-code">SQL Server: </pre>
			<pre class="source-code">select 1 [one] from [classicmodels].[dbo].[customer], </pre>
			<pre class="source-code">                    [classicmodels].[dbo].[customerdetail]</pre>
			<pre class="source-code">ctx.selectOne().from(CUSTOMER, CUSTOMERDETAIL).fetch();</pre>
			<p>Of course, the purpose of offering <strong class="source-inline">selectOne()</strong> and the like is not really to allow for querying <strong class="source-inline">ctx.selectOne().fetch()</strong>, but to be used in queries where the projection doesn't matter, as in the<a id="_idIndexMarker368"/> following example:</p>
			<pre class="source-code">ctx.deleteFrom(SALE)</pre>
			<pre class="source-code">   .where(exists(selectOne().from(EMPLOYEE) </pre>
			<pre class="source-code">// .whereExists(selectOne().from(EMPLOYEE)</pre>
			<pre class="source-code">      .where(SALE.EMPLOYEE_NUMBER.eq(EMPLOYEE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">        .and(EMPLOYEE.JOB_TITLE.ne("Sales Rep")))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>In the code bundled with this book, you can find more examples that are not listed here. Take your time to explore the <em class="italic">CommonlyUsedProjections</em> application. Next, let's tackle <strong class="source-inline">SELECT</strong> subqueries or subselects.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Expressing SELECT to fetch only the needed data</h2>
			<p>Starting with jOOQ DSL may target <a id="_idIndexMarker369"/>a simple <strong class="source-inline">SELECT</strong> query of the <strong class="source-inline">SELECT all_columns FROM table</strong> or <strong class="source-inline">SELECT * FROM table</strong> type. This kind of query can be written in jOOQ as follows:</p>
			<pre class="source-code">ctx.select().from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(10101L)).fetch();</pre>
			<pre class="source-code">ctx.selectFrom(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(10101L)).fetch();</pre>
			<pre class="source-code">ctx.select(ORDER.fields()).from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(10101L)).fetch();</pre>
			<p>Since we rely on the generated Java-based schema (obtained via the jOOQ generator as you saw in <a href="B16833_02.xhtml#_idTextAnchor024"><em class="italic">Chapter 2</em></a>, <em class="italic">Customizing the jOOQ Level of Involvement</em>), jOOQ can infer the fields (columns) of the <strong class="source-inline">ORDER</strong> table and explicitly render them in the generated query. But, if you need to render the <strong class="source-inline">*</strong> itself instead of the list of fields, then you can use the handy <strong class="source-inline">asterisk()</strong> method, as in the following query:</p>
			<pre class="source-code">ctx.select(asterisk()).from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(10101L))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>As Lukas Eder mentioned: "<em class="italic">Perhaps worth stressing more heavily here that the asterisk (</em><strong class="source-inline">*</strong><em class="italic">) is not the same thing as the other three ways of querying all columns. The asterisk (</em><strong class="source-inline">*</strong><em class="italic">) projects all the columns from the live database schema including the ones that jOOQ doesn't know. The other three approaches project all the columns that jOOQ knows but those columns may no longer exist in the live database schema. There may be a mismatch, which is especially important when mapping to records (for instance, using </em><strong class="source-inline">selectFrom()</strong><em class="italic">, or </em><strong class="source-inline">into(recordtype)</strong><em class="italic">). Even so, when using *, and when all the tables in </em><strong class="source-inline">from()</strong><em class="italic"> are known to jOOQ, jOOQ will try to expand the asterisk in order to access all converters and data type bindings, and embeddable records, and other things</em>."</p>
			<p>Moreover, notice that such queries may fetch more data than needed, and relying on <strong class="source-inline">* </strong>instead of a list of columns may come with performance penalties, which are discussed in this article: <a href="https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/">https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/</a>. When I say that <em class="italic">it may fetch more data than needed</em>, I refer to the scenarios that process only a <a id="_idIndexMarker370"/>subset of the fetched result set, while the rest of it is simply discarded. Fetching data can be an expensive (especially, time-consuming) operation, therefore, fetching data just to discard it is a waste of resources and it can lead to long-running transactions that affect the application's scalability. This is a common scenario in JPA-based applications (for instance, in Spring Boot, <strong class="source-inline">spring.jpa.open-in-view=true</strong> may lead to loading more data than is needed).</p>
			<p>Among others, Tanel<a id="_idIndexMarker371"/> Poder's article mentions one thing that a lot of beginners overlook. By forcing the database to do "<em class="italic">useless, mandatory work</em>" (you'll love this article for sure: <a href="https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/">https://blog.jooq.org/2017/03/08/many-sql-performance-problems-stem-from-unnecessary-mandatory-work/</a>) via a <strong class="source-inline">*</strong> projection, it can no longer apply some optimizations to the query, for example, join elimination, which is essential for complex queries (<a href="https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible">https://tanelpoder.com/posts/reasons-why-select-star-is-bad-for-sql-performance/#some-query-plan-optimizations-not-possible</a>).</p>
			<h3>Fetching a subset of columns</h3>
			<p>As a rule of thumb, fetching <a id="_idIndexMarker372"/>more data than needed is<a id="_idIndexMarker373"/> a common cause of persistence layer performance penalties. Therefore, if all you need is a subset of columns from <strong class="source-inline">ORDER</strong>, then simply enlist them explicitly in <strong class="source-inline">SELECT</strong> as <strong class="source-inline">select(ORDER.ORDER_ID, ORDER.ORDER_DATE, ORDER.REQUIRED_DATE, ORDER.SHIPPED_DATE, ORDER.CUSTOMER_NUMBER)</strong>. Sometimes, the needed subset of columns is almost equal to (but not equal to) the total number of fields/columns. In such cases, instead of enlisting the subset of columns as previously, it is more practical to point out the fields/columns that should be excluded via the <strong class="source-inline">except()</strong> method. Here is an example of fetching all fields/columns from <strong class="source-inline">ORDER</strong> except <strong class="source-inline">ORDER.COMMENTS</strong> and <strong class="source-inline">ORDER.STATUS</strong>:</p>
			<pre class="source-code">ctx.select(asterisk().except(ORDER.COMMENTS, ORDER.STATUS))</pre>
			<pre class="source-code">   .from(ORDER)</pre>
			<pre class="source-code">   .where(ORDER.ORDER_ID.eq(10101L)).fetch();</pre>
			<p>Here is another example that applies the SQL <strong class="source-inline">nvl()</strong> function to the <strong class="source-inline">OFFICE.CITY</strong> field. Whenever <strong class="source-inline">OFFICE.CITY</strong> is <strong class="source-inline">null</strong>, we fetch the <strong class="source-inline">N/A</strong> string:</p>
			<pre class="source-code">ctx.select(nvl(OFFICE.CITY, "N/A"),</pre>
			<pre class="source-code">               OFFICE.asterisk().except(OFFICE.CITY))</pre>
			<pre class="source-code">   .from(OFFICE).fetch();</pre>
			<p>If you need to attach an alias to a <a id="_idIndexMarker374"/>condition, then we<a id="_idIndexMarker375"/> first need to wrap this condition in a field via the <strong class="source-inline">field()</strong> method. Here is an example:</p>
			<pre class="source-code">ctx.select(field(SALE.SALE_.gt(5000.0)).as("saleGt5000"),</pre>
			<pre class="source-code">                 SALE.asterisk().except(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE).fetch();</pre>
			<p>And, the result set table-like head of this query looks as here:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B16833_Figure_5.1.jpg" alt=""/>
				</div>
			</div>
			<p>Notice that the <strong class="source-inline">* EXCEPT (...)</strong> syntax is inspired by BigQuery, which also has a <strong class="source-inline">* REPLACE (...)</strong> syntax that jOOQ plans to implement. You can track its progress here: <a href="https://github.com/jOOQ/jOOQ/issues/11198">https://github.com/jOOQ/jOOQ/issues/11198</a>.</p>
			<p>In the code bundled with this book (<strong class="source-inline">SelectOnlyNeededData</strong>), you can see more examples of juggling with the <strong class="source-inline">asterisk()</strong> and <strong class="source-inline">except()</strong> methods to materialize different scenarios that involve one or more tables.</p>
			<h3>Fetching a subset of rows</h3>
			<p>Besides using predicates, fetching only a<a id="_idIndexMarker376"/> subset of rows is commonly <a id="_idIndexMarker377"/>accomplished via the <strong class="source-inline">LIMIT ... OFFSET</strong> clause. Unfortunately, this clause is not part of the SQL standard and it is understood only by a limited number of database vendors such as MySQL and PostgreSQL. Nevertheless, jOOQ allows us to use <strong class="source-inline">LIMIT ... OFFSET</strong> via the <strong class="source-inline">limit()</strong> and <strong class="source-inline">offset()</strong> methods and will handle all aspects of emulating a compatible syntax for the used dialect. Here is an example of rendering <strong class="source-inline">LIMIT 10 OFFSET 5</strong>:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME, EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .limit(10)</pre>
			<pre class="source-code">   .offset(5)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Here is the same thing (the same query and result) but<a id="_idIndexMarker378"/> expressed via the <strong class="source-inline">limit(Number offset, Number numberOfRows)</strong> flavor (pay attention<a id="_idIndexMarker379"/> that the offset is the first argument – the order of arguments inherited from MySQL):</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, </pre>
			<pre class="source-code">           EMPLOYEE.LAST_NAME,EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .orderBy(EMPLOYEE.SALARY)</pre>
			<pre class="source-code">   .limit(5, 10)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>And, jOOQ will render the following SQL depending on the database vendor:</p>
			<pre class="source-code">MySQL and PostgreSQL (jOOQ 3.14):</pre>
			<pre class="source-code">select ... from ...limit 10 offset 5</pre>
			<pre class="source-code">PostgreSQL (jOOQ 3.15+):</pre>
			<pre class="source-code">select ... from ...offset 5 rows fetch first 10 rows only</pre>
			<pre class="source-code">SQL Server:</pre>
			<pre class="source-code">select ... from ...offset 5 rows fetch next 10 rows only</pre>
			<pre class="source-code">Oracle:</pre>
			<pre class="source-code">select ... from ...offset 5 rows fetch next 10 rows only</pre>
			<p>Commonly, the arguments of <strong class="source-inline">LIMIT</strong> and <strong class="source-inline">OFFSET</strong> are some hard-coded integers. But, jOOQ allows us to use <strong class="source-inline">Field</strong> as well. For instance, here we use a scalar subquery in <strong class="source-inline">LIMIT</strong> (the same thing can be done in <strong class="source-inline">OFFSET</strong>):</p>
			<pre class="source-code">ctx.select(ORDERDETAIL.ORDER_ID, ORDERDETAIL.PRODUCT_ID,            ORDERDETAIL.QUANTITY_ORDERED)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .orderBy(ORDERDETAIL.QUANTITY_ORDERED)                        </pre>
			<pre class="source-code">   .limit(field(select(min(ORDERDETAIL.QUANTITY_ORDERED)).       from(ORDERDETAIL)))                        </pre>
			<pre class="source-code">   .fetch();</pre>
			<p>As a note from Lukas Eder, "<em class="italic">Starting with version 3.15, jOOQ generates standard SQL for </em><strong class="source-inline">OFFSET … FETCH</strong><em class="italic"> in PostgreSQL, not the vendor-specific </em><strong class="source-inline">LIMIT … OFFSET</strong><em class="italic"> anymore. This is to provide native support for </em><strong class="source-inline">FETCH NEXT … ROWS WITH TIES</strong><em class="italic">. Maybe, a future jOOQ will also offer the SQL Standard 2011 Oracle's/SQL Server's syntax: </em><strong class="source-inline">OFFSET n ROW[S] FETCH { FIRST | NEXT } m [ PERCENT ] ROW[S] { ONLY | WITH TIES }</strong>." Track it here: <a href="https://github.com/jOOQ/jOOQ/issues/2803">https://github.com/jOOQ/jOOQ/issues/2803</a>.</p>
			<p>Notice that the previous queries<a id="_idIndexMarker380"/> use an explicit <strong class="source-inline">ORDER BY</strong> to avoid unpredictable results. If we omit <strong class="source-inline">ORDER BY</strong>, then jOOQ will emulate it on our behalf whenever it is needed. For instance, <strong class="source-inline">OFFSET</strong> (unlike <strong class="source-inline">TOP</strong>) requires <strong class="source-inline">ORDER BY</strong> in SQL Server, and if we omit <strong class="source-inline">ORDER BY</strong>, then jOOQ will render it on our<a id="_idIndexMarker381"/> behalf as in the following SQL:</p>
			<pre class="source-code">SQL Server:</pre>
			<pre class="source-code">select ... from ...</pre>
			<pre class="source-code">   order by (select 0)</pre>
			<pre class="source-code">   offset n rows fetch next m rows only</pre>
			<p>Since we touched on this emulation topic, let's have a note that you should be aware of.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">One of the coolest things about jOOQ is the capability to emulate the valid and optimal SQL syntax when the user database is<a id="_idIndexMarker382"/> lacking a specific feature (consider reading this article: <a href="https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/">https://blog.jooq.org/2018/03/13/top-10-sql-dialect-emulations-implemented-in-jooq/</a>). The jOOQ documentation mentions that "<em class="italic">jOOQ API methods which are not annotated with the </em><strong class="source-inline">org.jooq.Support</strong><em class="italic"> annotation (</em><strong class="source-inline">@Support</strong><em class="italic">), or which are annotated with the </em><strong class="source-inline">@Support</strong><em class="italic"> annotation, but without any SQL dialects can be safely used in all SQL dialects. The aforementioned </em><strong class="source-inline">@Support</strong><em class="italic"> annotation does not only designate which databases natively support a feature. It also indicates that a feature is emulated by jOOQ for some databases lacking this feature</em>." Moreover, whenever jOOQ doesn't support some vendor-specific functionality/syntax, the solution is to use plain SQL templating. This is dissected in a future chapter of this book.</p>
			<p>For more examples, please consider the code bundled with this book. You'll find a collection of 15+ examples, including <a id="_idIndexMarker383"/>several corner cases as well. For instance, in <strong class="source-inline">EXAMPLE 10.1</strong> and <strong class="source-inline">10.2</strong>, you can see an example of fetching the rows in a certain order via the jOOQ <strong class="source-inline">sortAsc()</strong> method (if you are in such a position, then I suggest you read this article as well: <a href="https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/">https://blog.jooq.org/2014/05/07/how-to-implement-sort-indirection-in-sql/</a>). Or, in <strong class="source-inline">EXAMPLE 11</strong>, you can see how to choose at runtime between <strong class="source-inline">WHERE ... IN</strong> and <strong class="source-inline">WHERE ... NOT IN</strong> statements via the jOOQ <strong class="source-inline">org.jooq.Comparator</strong> API and a Boolean variable. Moreover, in <strong class="source-inline">EXAMPLE 15</strong> and <strong class="source-inline">16</strong>, you can see the usage of the <strong class="source-inline">SelectQuery</strong> API for<a id="_idIndexMarker384"/> fetching columns from different tables. Take your time and practice each of these examples. I'm pretty sure that you'll learn a lot of tricks from them. The application is named <strong class="source-inline">SelectOnlyNeededData</strong>. For now, let's talk about expressing subselects in jOOQ.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Expressing SELECT subqueries (subselects)</h2>
			<p>Roughly speaking, a <strong class="source-inline">SELECT</strong> subquery (or subselect) is represented by a <strong class="source-inline">SELECT</strong> statement nested in another <strong class="source-inline">SELECT</strong> statement. Commonly, they appear in the <strong class="source-inline">WHERE</strong> or the <strong class="source-inline">FROM</strong> clauses, but it<a id="_idIndexMarker385"/> is no surprise to see them in the <strong class="source-inline">HAVING</strong> clause or combined with database views. </p>
			<p>For example, let's take the following plain SQL containing a subselect in the <strong class="source-inline">WHERE</strong> clause as part of the predicate:</p>
			<pre class="source-code">SELECT first_name, last_name FROM employee</pre>
			<pre class="source-code">WHERE office_code IN</pre>
			<pre class="source-code">    (SELECT office_code FROM office WHERE city LIKE "S%")</pre>
			<p>In jOOQ, we can express this query straightforwardly:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.OFFICE_CODE.in(</pre>
			<pre class="source-code">       select(OFFICE.OFFICE_CODE).from(OFFICE)</pre>
			<pre class="source-code">          .where(OFFICE.CITY.like("S%")))).fetch()</pre>
			<p>Notice how we have used the <strong class="source-inline">IN</strong> statement via the jOOQ <strong class="source-inline">in()</strong> method. In the same manner, you can use other statements supported by jOOQ, such as <strong class="source-inline">NOT IN</strong> (<strong class="source-inline">notIn()</strong>), <strong class="source-inline">BETWEEN</strong> (<strong class="source-inline">between()</strong>), <strong class="source-inline">LIKE</strong> (<strong class="source-inline">like()</strong>), and many others. Always pay attention to using <strong class="source-inline">NOT IN</strong> and<a id="_idIndexMarker386"/> that it's a peculiar behavior regarding <strong class="source-inline">NULL</strong> originating from the subquery (<a href="https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/">https://www.jooq.org/doc/latest/manual/sql-building/conditional-expressions/in-predicate/</a>). </p>
			<p>Almost any SQL statement has<a id="_idIndexMarker387"/> a jOOQ equivalent implementation, therefore, take your time and scan the jOOQ API to cover it as much as possible. This is the right direction in becoming a jOOQ power user.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In subselects of type <strong class="source-inline">SELECT foo...</strong>, <strong class="source-inline">(SELECT buzz)</strong> is a common case to use both <strong class="source-inline">DSLContext.select()</strong> and <strong class="source-inline">DSL.select()</strong> as <strong class="source-inline">ctx.select(foo) ... (select(buzz))</strong>. The <strong class="source-inline">DSLContext.select()</strong> method is used for the outer <strong class="source-inline">SELECT</strong> in order to obtain a reference to a database configured connection, while for the inner or nested <strong class="source-inline">SELECT</strong>, we can use <strong class="source-inline">DSL.select()</strong> or <strong class="source-inline">DSLContext.select()</strong>. However, using <strong class="source-inline">DSL.select()</strong> for the inner <strong class="source-inline">SELECT</strong> is more convenient because it can be statically imported and referenced simply as <strong class="source-inline">select()</strong>. Notice that using <strong class="source-inline">DSL.select()</strong>for both types of <strong class="source-inline">SELECT</strong> or only for the inner <strong class="source-inline">SELECT</strong> leads to an exception of type <em class="italic">Cannot execute query. No Connection configured</em>. But, of course, you can still execute <strong class="source-inline">DSL.select()</strong> via <strong class="source-inline">DSLContext.fetch(ResultQuery)</strong> and the like.</p>
			<p>Next, let's have another plain SQL that has a subselect in the <strong class="source-inline">FROM</strong> clause, as follows:</p>
			<pre class="source-code">SELECT sale_id, sale</pre>
			<pre class="source-code">FROM sale,</pre>
			<pre class="source-code">  (SELECT avg(sale) AS avgs,employee_number AS sen</pre>
			<pre class="source-code">     FROM sale</pre>
			<pre class="source-code">     GROUP BY employee_number) AS saleTable</pre>
			<pre class="source-code">WHERE (employee_number = saleTable.sen</pre>
			<pre class="source-code">  AND sale &lt; saleTable.avgs);</pre>
			<p>This time, let's express the subselect via a derived table as follows:</p>
			<pre class="source-code">// Table&lt;Record2&lt;BigDecimal, Long&gt;&gt;</pre>
			<pre class="source-code">var saleTable = select(avg(SALE.SALE_).as("avgs"),  </pre>
			<pre class="source-code">                       SALE.EMPLOYEE_NUMBER.as("sen"))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .asTable("saleTable"); // derived table</pre>
			<p>Another approach relies on <strong class="source-inline">table(select(…))</strong>. Practically, <strong class="source-inline">table</strong><strong class="source-inline">(Select&lt;R&gt;)</strong> is a synonym for <strong class="source-inline">asTable()</strong>. Choose the one that you find more fluent:</p>
			<pre class="source-code">var saleTable = table(select(...)).as("saleTable");</pre>
			<p>Next, we can use this derived<a id="_idIndexMarker388"/> table to express the outer <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">ctx.select(SALE.SALE_ID, SALE.SALE_)</pre>
			<pre class="source-code">   .from(SALE, saleTable)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">     .eq(saleTable.field("sen", Long.class))</pre>
			<pre class="source-code">       .and(SALE.SALE_</pre>
			<pre class="source-code">         .lt(saleTable.field("avgs", Double.class))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Since jOOQ cannot infer the field types of a user-defined derived table, we can rely on coercing to fill up the expected types of the <strong class="source-inline">sen</strong> and <strong class="source-inline">avgs</strong> fields (for a quick reminder of the <em class="italic">coercing</em> goal, please revisit <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>), or <strong class="source-inline">saleTable.field(name, type)</strong>, as here.</p>
			<p>The jOOQ API is so flexible and rich that it allows us to express the same SQL in multiple ways. It depends on us to choose the most convenient approach in a certain scenario. For example, if we consider that the SQL part <strong class="source-inline">WHERE (employee_number = saleTable.sen AND sale &lt; saleTable.avgs)</strong>can be written as <strong class="source-inline">WHERE (employee_number = sen AND sale &lt; avgs)</strong>, then we can extract the following fields as local<a id="_idIndexMarker389"/> variables:</p>
			<pre class="source-code">Field&lt;Double&gt; avgs = avg(SALE.SALE_)</pre>
			<pre class="source-code">  .coerce(Double.class).as("avgs");</pre>
			<pre class="source-code">Field&lt;Long&gt; sen = SALE.EMPLOYEE_NUMBER.as("sen");</pre>
			<p>And, we can use them in the derived table and outer <strong class="source-inline">SELECT</strong>:</p>
			<pre class="source-code">var saleTable = select(avgs, sen)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .asTable("saleTable"); // derived table</pre>
			<pre class="source-code">ctx.select(SALE.SALE_ID, SALE.SALE_)</pre>
			<pre class="source-code">   .from(SALE, saleTable)</pre>
			<pre class="source-code">   .where(SALE.EMPLOYEE_NUMBER.eq(sen)</pre>
			<pre class="source-code">      .and(SALE.SALE_.lt(avgs)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Or, we can eliminate the explicitly derived table and embed the subselect in a fluent style:</p>
			<pre class="source-code">ctx.select(SALE.SALE_ID, SALE.SALE_)</pre>
			<pre class="source-code">   .from(SALE, select(avgs, sen)</pre>
			<pre class="source-code">               .from(SALE)</pre>
			<pre class="source-code">               .groupBy(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">  .where(SALE.EMPLOYEE_NUMBER.eq(sen)</pre>
			<pre class="source-code">    .and(SALE.SALE_.lt(avgs)))</pre>
			<pre class="source-code">  .fetch();</pre>
			<p>Notice that we removed the explicit <strong class="source-inline">saleTable</strong> alias as well. As MySQL complains (and not only), every derived table requires an alias, but we don't have to worry about it. jOOQ knows this and will generate an alias on our behalf (something similar to <strong class="source-inline">alias_25088691</strong>). But, if your <a id="_idIndexMarker390"/>benchmarks reveal that alias generation is not negligible, then it is better to supply an explicit alias. As Lukas Eder says, "<em class="italic">However, the generated alias is based deterministically on the SQL string, in order to be stable, which is important for execution plan caches (for instance, Oracle, SQL Server, irrelevant in MySQL, PostgreSQL)</em>."</p>
			<p>Consider more examples in the bundled code. For instance, if you are interested in using <strong class="source-inline">SELECT</strong> nested in<strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>, then you can find examples in the bundled code. The application is named <em class="italic">SampleSubqueries</em>. Next, let's talk about scalar subqueries.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Expressing scalar subqueries</h2>
			<p>A scalar subquery<a id="_idIndexMarker391"/> selects only one column/expression and returns only one row. It can be used in an SQL query anywhere that a column/expression<a id="_idIndexMarker392"/> can be used. For example, let's assume plain SQL that selects the employees with a salary greater than or equal to the average salary plus <em class="italic">25,000</em>:</p>
			<pre class="source-code">SELECT first_name, last_name FROM employee</pre>
			<pre class="source-code">WHERE salary &gt;= (SELECT (AVG(salary) + 25000) FROM employee);</pre>
			<p>In jOOQ, this query is generated by the following code:</p>
			<pre class="source-code">ctx.select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME)</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.SALARY.coerce(BigDecimal.class)</pre>
			<pre class="source-code">      .ge(select(avg(EMPLOYEE.SALARY).plus(25000))</pre>
			<pre class="source-code">   .from(EMPLOYEE))).fetch();</pre>
			<p>Have you noticed the <strong class="source-inline">...ge(select(...))</strong> construct? In the left-hand of <strong class="source-inline">ge()</strong> we have a <strong class="source-inline">Field</strong>, but in the right-hand we have a <strong class="source-inline">Select</strong>. This is possible thanks to <strong class="source-inline">ge(Select&lt;? extends Record1&lt;T&gt;&gt; select)</strong>, which is a very handy shortcut that saves us from the explicit usage of <strong class="source-inline">field()</strong> as <strong class="source-inline">ge(field(select(...)))</strong>, or from <strong class="source-inline">asField()</strong> as <strong class="source-inline">ge(select(...).asField())</strong>. We can also write conditions such as <strong class="source-inline">select(...).ge(select(...))</strong>. But, what is the difference between <strong class="source-inline">field()</strong> and <strong class="source-inline">asField()</strong>?</p>
			<p>Let's have another example<a id="_idIndexMarker393"/> that inserts a new <strong class="source-inline">PRODUCT</strong> (I've listed only the<a id="_idIndexMarker394"/> relevant part):</p>
			<pre class="source-code">ctx.insertInto(PRODUCT, </pre>
			<pre class="source-code">               PRODUCT.PRODUCT_ID, ..., PRODUCT.MSRP)</pre>
			<pre class="source-code">   .values(...,</pre>
			<pre class="source-code">     field(select(avg(PRODUCT.MSRP)).from(PRODUCT)))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>To insert the value of <strong class="source-inline">PRODUCT.MSRP</strong> as the average <strong class="bold">MSRPs</strong>, we rely on a scalar <a id="_idIndexMarker395"/>subquery that should be transformed in <strong class="source-inline">Field</strong>. This can be done as we did via <strong class="source-inline">field(Select&lt;? extends Record1&lt;T&gt;&gt; s)</strong> or via <strong class="source-inline">asField()</strong>. If we go with <strong class="source-inline">asField()</strong>, then we write something like this:</p>
			<pre class="source-code">...select(avg(PRODUCT.MSRP)).from(PRODUCT).asField())</pre>
			<p>But, <strong class="source-inline">asField()</strong> returns this result provider as a <strong class="source-inline">Field&lt;?/Object&gt;</strong> object. In other words, <strong class="source-inline">asField()</strong> loses type information and so isn't type-safe. By losing type information, <strong class="source-inline">asField()</strong> allows us to accidentally introduce type-safety-related errors that cannot be detected until runtime, or even worse, that will produce unexpected results. Here, we have typed <strong class="source-inline">array(PRODUCT.MSRP)</strong> instead of <strong class="source-inline">avg(PRODUCT.MSRP)</strong> but we have no complaints until runtime:</p>
			<pre class="source-code">...select(array(PRODUCT.MSRP)).from(PRODUCT).asField())</pre>
			<p>Of course, you won't be writing such blabbering, but the idea is that using <strong class="source-inline">asField()</strong> in such contexts is prone to other data type incompatibilities that might be hard to spot and might produce unexpected results. So, let's keep <strong class="source-inline">asField()</strong> for queries as <strong class="source-inline">SELECT b.*, (SELECT foo FROM a) FROM b</strong>, and let's focus on <strong class="source-inline">field()</strong>:</p>
			<pre class="source-code">... field(select(array(PRODUCT.MSRP)).from(PRODUCT)))</pre>
			<p>Do you think this code will <a id="_idIndexMarker396"/>compile? The correct answer is no! Your IDE will immediately signal a data type incompatibility. While <strong class="source-inline">PRODUCT.MSRP</strong> is  <strong class="source-inline">BigDecimal</strong>, <strong class="source-inline">(array(PRODUCT.MSRP))</strong> is <strong class="source-inline">Field&lt;BigDecimal[]&gt;</strong>, so <strong class="source-inline">INSERT</strong> is <a id="_idIndexMarker397"/>wrong. Replace <strong class="source-inline">array()</strong> with <strong class="source-inline">avg()</strong>. Problem solved!</p>
			<p>In the bundled code (<strong class="source-inline">ScalarSubqueries</strong>), you have more examples, including using scalar queries nested in <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>. Next, let's talk about correlated subqueries.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Expressing correlated subqueries</h2>
			<p>A correlated subquery (or repeating<a id="_idIndexMarker398"/> subquery) uses the values of the outer query for computing its values. Since it depends on the outer query, a correlated <a id="_idIndexMarker399"/>subquery can't be executed independently as a standalone subquery. As Lukas Eder mentioned, "<em class="italic">In any case, no RDBMS is forced to naively execute a correlated subquery once for each row evaluated by the outer query (obviously, if such a thing would happen, then this may come with an overhead in performance if the correlated subquery must be executed for a significant number of times). Many RDBMS would optimize a correlated subquery by applying a transformation to a join or semi-join. Other, such as Oracle 11g and later, optimizes correlated subqueries thanks to scalar subquery caching</em>." (<a href="https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql">https://blogs.oracle.com/oraclemagazine/on-caching-and-evangelizing-sql</a>)</p>
			<p>Let's consider the following plain SQL representing a correlated scalar subquery:</p>
			<pre class="source-code">SELECT s1.sale, s1.fiscal_year, s1.employee_number</pre>
			<pre class="source-code">FROM sale AS s1</pre>
			<pre class="source-code">WHERE s1.sale =</pre>
			<pre class="source-code">    (SELECT max(s2.sale)</pre>
			<pre class="source-code">     FROM sale AS s2</pre>
			<pre class="source-code">     WHERE (s2.employee_number = s1.employee_number</pre>
			<pre class="source-code">            AND s2.fiscal_year = s1.fiscal_year))</pre>
			<pre class="source-code">ORDER BY s1.fiscal_year</pre>
			<p>Expressing this query in jOOQ can be done as follows (notice that we want to preserve the <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong> aliases in the<a id="_idIndexMarker400"/> rendered SQL):</p>
			<pre class="source-code">Sale s1 = SALE.as("s1");</pre>
			<pre class="source-code">Sale s2 = SALE.as("s2");</pre>
			<pre class="source-code">ctx.select(s1.SALE_, s1.FISCAL_YEAR, s1.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .from(s1)</pre>
			<pre class="source-code">   .where(s1.SALE_.eq(select(max(s2.SALE_))</pre>
			<pre class="source-code">      .from(s2)</pre>
			<pre class="source-code">      .where(s2.EMPLOYEE_NUMBER.eq(s1.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">         .and(s2.FISCAL_YEAR.eq(s1.FISCAL_YEAR)))))</pre>
			<pre class="source-code">   .orderBy(s1.FISCAL_YEAR)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Did you spot this: <strong class="source-inline">...where(s1.SALE_.eq(select(max(s2.SALE_))</strong>? No <strong class="source-inline">asField()</strong> /<strong class="source-inline">field()</strong> required! The query didn't need to call <strong class="source-inline">asField()</strong>/<strong class="source-inline">field()</strong>, because there's a convenience overload provided by jOOQ as <strong class="source-inline">Field&lt;T&gt;.eq(Select&lt;? extends Record1&lt;T&gt;&gt;)</strong>. Yes, I know I already told you about it earlier, but I just <a id="_idIndexMarker401"/>wanted to enforce it again. </p>
			<p>However, as you probably intuited, this correlated subquery, which relies on repeatedly self-joined tables, can be expressed more efficiently via <strong class="source-inline">GROUP BY</strong> as follows (this time, we don't preserve the aliases):</p>
			<pre class="source-code">ctx.select(SALE.FISCAL_YEAR, </pre>
			<pre class="source-code">           SALE.EMPLOYEE_NUMBER, max(SALE.SALE_))</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .groupBy(SALE.FISCAL_YEAR, SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">   .orderBy(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In this case, <strong class="source-inline">GROUP BY</strong> is <em class="italic">much</em> better, because it eliminates that self-join, turning <em class="italic">O(n</em><span class="superscript">2</span><em class="italic">)</em> into <em class="italic">O(n).</em> As Lukas Eder shared, "<em class="italic">With modern SQL, self-joins are almost never really needed anymore. Beginners might think that these self-joins are the way to go, when they can be quite detrimental, </em><a href="https://twitter.com/MarkusWinand/status/1118147557828583424">https://twitter.com/MarkusWinand/status/1118147557828583424</a><em class="italic">, O(n</em><span class="superscript">2</span>) <em class="italic">in the worst case</em>." So, before jumping in to write such correlated subqueries, try to evaluate some alternatives and<a id="_idIndexMarker402"/> compare the execution plans.</p>
			<p>Let's look at another example <a id="_idIndexMarker403"/>based on the following plain SQL:</p>
			<pre class="source-code">SELECT product_id, product_name, buy_price</pre>
			<pre class="source-code">FROM product</pre>
			<pre class="source-code">WHERE</pre>
			<pre class="source-code">  (SELECT avg(buy_price)</pre>
			<pre class="source-code">   FROM product) &gt; ANY</pre>
			<pre class="source-code">     (SELECT price_each</pre>
			<pre class="source-code">      FROM orderdetail</pre>
			<pre class="source-code">      WHERE product.product_id = orderdetail.product_id);</pre>
			<p>So, this query compares the average buy price (or list price) of all products with all the sale prices of each product. If this average is greater than any of the sale prices of a product, then the product is fetched in the result set. In jOOQ, this can be expressed as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.PRODUCT_ID, </pre>
			<pre class="source-code">           PRODUCT.PRODUCT_NAME, PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .where(select(avg(PRODUCT.BUY_PRICE))</pre>
			<pre class="source-code">   .from(PRODUCT).gt(any(</pre>
			<pre class="source-code">        select(ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">           .from(ORDERDETAIL)</pre>
			<pre class="source-code">              .where(PRODUCT.PRODUCT_ID</pre>
			<pre class="source-code">                 .eq(ORDERDETAIL.PRODUCT_ID)))))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In the bundled code, you have a comprehensive list of examples, including examples containing <strong class="source-inline">WHERE (NOT) EXISTS</strong>, <strong class="source-inline">ALL</strong>, and <strong class="source-inline">ANY</strong>. As Lukas Eder says, "<em class="italic">It is worth mentioning that the name of ALL and ANY is "quantifier" and the comparison is called quantified comparison predicate. These are much more elegant than comparing with </em><strong class="source-inline">MIN()</strong><em class="italic"> or </em><strong class="source-inline">MAX()</strong><em class="italic">, or using </em><strong class="source-inline">ORDER BY .. LIMIT 1</strong><em class="italic">, especially when row value expressions are used</em>." Moreover, you <a id="_idIndexMarker404"/>can check out examples of using correlated subqueries <a id="_idIndexMarker405"/>nested in <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>. The application<a id="_idIndexMarker406"/> is named <em class="italic">CorrelatedSubqueries</em>. Next, let's talk about writing row expressions in jOOQ.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Expressing row expressions</h2>
			<p>Row value expressions are quite handy for<a id="_idIndexMarker407"/> writing elegant multi-row predicates. jOOQ represents row value<a id="_idIndexMarker408"/> expressions via the <strong class="source-inline">org.jooq.Row</strong> interface. Its usage is straightforward, as the following plain SQL shows:</p>
			<pre class="source-code">SELECT customer_number, address_line_first,   </pre>
			<pre class="source-code">       address_line_second, city, state, postal_code, country</pre>
			<pre class="source-code">FROM customerdetail</pre>
			<pre class="source-code">WHERE (city, country) IN(SELECT city, country FROM office)</pre>
			<p>In jOOQ, this can be expressed via <strong class="source-inline">row()</strong>, as follows:</p>
			<pre class="source-code">ctx.selectFrom(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .where(row(CUSTOMERDETAIL.CITY, CUSTOMERDETAIL.COUNTRY)</pre>
			<pre class="source-code">         .in(select(OFFICE.CITY, OFFICE.COUNTRY).from(OFFICE)))</pre>
			<pre class="source-code">.fetch();</pre>
			<p>In the bundled code (<strong class="source-inline">RawValueExpression</strong>), you can practice examples of using row value expressions with comparison predicates, <strong class="source-inline">BETWEEN</strong> and <strong class="source-inline">OVERLAPS</strong> predicates (jOOQ supports<a id="_idIndexMarker409"/> overlapping dates and arbitrary row value expressions of degree 2 – how <a id="_idIndexMarker410"/>cool is that?!), and <strong class="source-inline">NULL</strong>. Next, let's tackle the <strong class="source-inline">UNION</strong> and <strong class="source-inline">UNION ALL</strong> operators.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Expressing the UNION and UNION ALL operators</h2>
			<p>The <strong class="source-inline">UNION</strong> and <strong class="source-inline">UNION ALL</strong> operators<a id="_idIndexMarker411"/> are useful for combining two or more result <a id="_idIndexMarker412"/>sets from different <strong class="source-inline">SELECT</strong> statements or <strong class="source-inline">SELECT</strong>s into one result set. <strong class="source-inline">UNION</strong> eliminates duplicate rows from the results of the <strong class="source-inline">SELECT</strong> statements, while <strong class="source-inline">UNION ALL</strong> doesn't do this. To work, the number and order of columns<a id="_idIndexMarker413"/> must correspond in both queries and the <a id="_idIndexMarker414"/>data types must be the same or at least compatible. Let's consider the following SQL:</p>
			<pre class="source-code">SELECT concat(first_name, ' ', last_name) AS full_name,</pre>
			<pre class="source-code">  'Employee' AS contactType</pre>
			<pre class="source-code">FROM employee</pre>
			<pre class="source-code">UNION</pre>
			<pre class="source-code">SELECT concat(contact_first_name, ' ', contact_last_name),</pre>
			<pre class="source-code">  'Customer' AS contactType</pre>
			<pre class="source-code">FROM customer;</pre>
			<p>jOOQ renders <strong class="source-inline">UNION</strong> via the <strong class="source-inline">union()</strong> method and <strong class="source-inline">UNION ALL</strong> via the <strong class="source-inline">unionAll()</strong> method. The previous SQL is rendered via <strong class="source-inline">union()</strong> as follows:</p>
			<pre class="source-code">ctx.select(</pre>
			<pre class="source-code">      concat(EMPLOYEE.FIRST_NAME, inline(" "),</pre>
			<pre class="source-code">      EMPLOYEE.LAST_NAME).as("full_name"),</pre>
			<pre class="source-code">      inline("Employee").as("contactType"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .union(select(</pre>
			<pre class="source-code">          concat(CUSTOMER.CONTACT_FIRST_NAME, inline(" "),</pre>
			<pre class="source-code">          CUSTOMER.CONTACT_LAST_NAME),</pre>
			<pre class="source-code">         inline("Customer").as("contactType"))</pre>
			<pre class="source-code">   .from(CUSTOMER))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Lukas Eder noted that <em class="italic">"</em><strong class="source-inline">UNION</strong><em class="italic"> (</em><strong class="source-inline">ALL</strong><em class="italic">) acts differently with respect to </em><strong class="source-inline">NULL</strong><em class="italic"> than other operators, meaning that two </em><strong class="source-inline">NULL</strong><em class="italic"> values are 'not distinct.' So </em><strong class="source-inline">SELECT NULL UNION SELECT NULL</strong><em class="italic"> produces only one row, just like </em><strong class="source-inline">SELECT NULL INTERSECT SELECT NULL</strong><em class="italic">.</em><em class="italic">"</em></p>
			<p>In the bundled code, you can practice more <a id="_idIndexMarker415"/>examples, including <strong class="source-inline">UNION</strong> and <strong class="source-inline">ORDER BY</strong>, <strong class="source-inline">UNION</strong> and <strong class="source-inline">LIMIT</strong>, <strong class="source-inline">UNION</strong> and <strong class="source-inline">HAVING</strong>, <strong class="source-inline">UNION</strong> and <strong class="source-inline">SELECT INTO</strong> (MySQL <a id="_idIndexMarker416"/>and PostgreSQL), <strong class="source-inline">UNION ALL</strong>, and so on. Unfortunately, there<a id="_idIndexMarker417"/> is no space here to list and dissect these examples, therefore, consider the<a id="_idIndexMarker418"/> application named <em class="italic">SelectUnions</em>. Next, let's cover the <strong class="source-inline">INTERSECT</strong> and <strong class="source-inline">EXCEPT</strong> operators.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Expressing the INTERSECT (ALL) and EXCEPT (ALL) operators</h2>
			<p>The <strong class="source-inline">INTERSECT</strong> operator <a id="_idIndexMarker419"/>produces only the values (rows) that are returned by (or common to) both <a id="_idIndexMarker420"/>subselects. The <strong class="source-inline">EXCEPT</strong> operator (or <strong class="source-inline">MINUS</strong> in Oracle) produces only the values that <a id="_idIndexMarker421"/>occur in the first (or left) subselect and don't occur in the <a id="_idIndexMarker422"/>second (or right) subselect. While <strong class="source-inline">INTERSECT</strong> and <strong class="source-inline">EXCEPT</strong> remove duplicates from their results, <strong class="source-inline">INTERSECT ALL</strong> and <strong class="source-inline">EXCEPT ALL</strong> don't do this. Exactly as in the case of <strong class="source-inline">UNION</strong>, to work, the number and order of columns must correspond in both queries and the data types must be the same or at least compatible.</p>
			<p>Let's consider the following plain SQL:</p>
			<pre class="source-code">SELECT buy_price FROM product</pre>
			<pre class="source-code">INTERSECT</pre>
			<pre class="source-code">SELECT price_each FROM orderdetail</pre>
			<p>In jOOQ, this can be expressed via <strong class="source-inline">intersect()</strong> as follows (for rendering <strong class="source-inline">INTERSECT ALL</strong>, use<a id="_idIndexMarker423"/> the <strong class="source-inline">intersectAll()</strong> method):</p>
			<pre class="source-code">ctx.select(PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .intersect(select(ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">      .from(ORDERDETAIL))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>By replacing the SQL <strong class="source-inline">INTERSECT</strong> with <strong class="source-inline">EXCEPT</strong> and, in <a id="_idIndexMarker424"/>jOOQ, the <strong class="source-inline">intersect()</strong> method <a id="_idIndexMarker425"/>with <strong class="source-inline">except()</strong> we can obtain an <strong class="source-inline">EXCEPT</strong> use case (for <strong class="source-inline">EXCEPT ALL</strong>, use the <strong class="source-inline">exceptAll()</strong> method). Here is<a id="_idIndexMarker426"/> the plain SQL (this time, let's add an <strong class="source-inline">ORDER BY</strong> clause as well):</p>
			<pre class="source-code">SELECT buy_price FROM product</pre>
			<pre class="source-code">EXCEPT</pre>
			<pre class="source-code">SELECT price_each FROM orderdetail</pre>
			<pre class="source-code">ORDER BY buy_price</pre>
			<p>And the jOOQ code is as follows:</p>
			<pre class="source-code">ctx.select(PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .except(select(ORDERDETAIL.PRICE_EACH).from(ORDERDETAIL))</pre>
			<pre class="source-code">   .orderBy(PRODUCT.BUY_PRICE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Nevertheless, if your database doesn't support these operators (for example, MySQL), then you have to emulate<a id="_idIndexMarker427"/> them. There are several ways to accomplish this <a id="_idIndexMarker428"/>and in the application named <em class="italic">IntersectAndExcept</em> (for MySQL), you can see a non-exhaustive list of solutions that emulate <strong class="source-inline">INTERSECT</strong> (<strong class="source-inline">ALL</strong>) based on <strong class="source-inline">IN</strong> (useful when no duplicates or <strong class="source-inline">NULL</strong> are present) and <strong class="source-inline">WHERE EXISTS</strong>, and emulate <strong class="source-inline">EXCEPT</strong> (<strong class="source-inline">ALL</strong>) based on <strong class="source-inline">LEFT OUTER JOIN</strong> and <strong class="source-inline">WHERE NOT EXISTS</strong>. Of course, feel free to check out the examples from <em class="italic">IntersectAndExcept</em> for PostgreSQL, SQL Server, and Oracle as well. Notice that Oracle 18c (used in our applications) supports only <strong class="source-inline">INTERSECT</strong> and <strong class="source-inline">EXCEPT</strong>, while Oracle20c supports all these four operators. Next, let's tackle the well-known <strong class="source-inline">SELECT DISTINCT</strong> and more.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Expressing distinctness</h2>
			<p>jOOQ comes with a<a id="_idIndexMarker429"/> suite of methods for expressing distinctness in our queries. We have<a id="_idIndexMarker430"/> the following:</p>
			<ul>
				<li><strong class="source-inline">SELECT DISTINCT</strong> via <strong class="source-inline">selectDistinct()</strong></li>
				<li><strong class="source-inline">IS</strong> (<strong class="source-inline">NOT</strong>) <strong class="source-inline">DISTINCT FROM</strong> via <strong class="source-inline">isDistinctFrom()</strong> and <strong class="source-inline">isNotDistinctFrom()</strong></li>
				<li><strong class="source-inline">COUNT (DISTINCT...)</strong> via <strong class="source-inline">countDistinct()</strong></li>
				<li><strong class="source-inline">AVG</strong>/<strong class="source-inline">SUM</strong>/<strong class="source-inline">MIN</strong>/<strong class="source-inline">MAX (DISTINCT ...)</strong> via <strong class="source-inline">avg</strong>/<strong class="source-inline">sum</strong>/<strong class="source-inline">min</strong>/<strong class="source-inline">maxDistinct()</strong></li>
				<li>PostgreSQL <strong class="source-inline">DISTINCT ON</strong> via <strong class="source-inline">selectDistinct().on()</strong> or <strong class="source-inline">distinctOn()</strong></li>
			</ul>
			<p>Let's look at an example of <strong class="source-inline">IS DISTINCT FROM</strong> as follows (in MySQL, <strong class="source-inline">IS DISTINCT FROM</strong> is represented by the <strong class="source-inline">&lt;=&gt;</strong> operator):</p>
			<pre class="source-code">SELECT office.office_code, ...</pre>
			<pre class="source-code">FROM office</pre>
			<pre class="source-code">JOIN customerdetail</pre>
			<pre class="source-code">  ON office.postal_code = customerdetail.postal_code</pre>
			<pre class="source-code">WHERE (not((office.city, office.country) &lt;=&gt;</pre>
			<pre class="source-code">      (customerdetail.city, customerdetail.country)))</pre>
			<p>And jOOQ renders this query via the following snippet of code:</p>
			<pre class="source-code">ctx.select()</pre>
			<pre class="source-code">   .from(OFFICE)</pre>
			<pre class="source-code">   .innerJoin(CUSTOMERDETAIL)</pre>
			<pre class="source-code">     .on(OFFICE.POSTAL_CODE.eq(CUSTOMERDETAIL.POSTAL_CODE))</pre>
			<pre class="source-code">   .where(row(OFFICE.CITY, OFFICE.COUNTRY).isDistinctFrom(</pre>
			<pre class="source-code">          row(CUSTOMERDETAIL.CITY, CUSTOMERDETAIL.COUNTRY)))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Depending on the used dialect, jOOQ <a id="_idIndexMarker431"/>emulates the correct syntax. While for MySQL, jOOQ renders the <strong class="source-inline">&lt;=&gt;</strong> operator, for Oracle, it relies on <strong class="source-inline">DECODE</strong> and <strong class="source-inline">INTERSECT</strong>, and for SQL Server, it relies on <strong class="source-inline">INTERSECT</strong>. PostgreSQL supports <strong class="source-inline">IS DISTINCT FROM</strong>.</p>
			<p>Next, let's see an example of<a id="_idIndexMarker432"/> PostgreSQL's <strong class="source-inline">DISTINCT ON</strong>:</p>
			<pre class="source-code">SELECT DISTINCT ON (product_vendor, product_scale) </pre>
			<pre class="source-code">    product_id, product_name, ...</pre>
			<pre class="source-code">FROM product</pre>
			<pre class="source-code">ORDER BY product_vendor, product_scale</pre>
			<p>And the jOOQ code is as follows:</p>
			<pre class="source-code">ctx.selectDistinct()</pre>
			<pre class="source-code">   .on(PRODUCT.PRODUCT_VENDOR, PRODUCT.PRODUCT_SCALE)</pre>
			<pre class="source-code">   .from(PRODUCT)</pre>
			<pre class="source-code">   .orderBy(PRODUCT.PRODUCT_VENDOR, PRODUCT.PRODUCT_SCALE)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>It is definitely worth mentioning here that jOOQ emulates this PostgreSQL-specific <strong class="source-inline">DISTINCT ON</strong> for MySQL, SQL Server, Oracle, and so on, via the <strong class="source-inline">row_number()</strong> window function.</p>
			<p>Of course, we can write jOOQ <a id="_idIndexMarker433"/>queries that emulate <strong class="source-inline">DISTINCT ON</strong> as well. For instance, the following example fetches the employee numbers of the maximum sales per fiscal year via jOOQ's <strong class="source-inline">rowNumber()</strong> and <strong class="source-inline">qualify()</strong>:</p>
			<pre class="source-code">ctx.selectDistinct(SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">                   SALE.FISCAL_YEAR, SALE.SALE_)</pre>
			<pre class="source-code">   .from(SALE)</pre>
			<pre class="source-code">   .qualify(rowNumber().over(</pre>
			<pre class="source-code">      partitionBy(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">         .orderBy(SALE.FISCAL_YEAR, SALE.SALE_.desc())).eq(1))</pre>
			<pre class="source-code">   .orderBy(SALE.FISCAL_YEAR)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>A classical scenario solved via <strong class="source-inline">DISTINCT ON</strong> relies on selecting some distinct column(s) while ordering by other column(s). For instance, the following query relies on the PostgreSQL <strong class="source-inline">DISTINCT ON</strong> to fetch the<a id="_idIndexMarker434"/> distinct employee numbers ordered by minimum sales:</p>
			<pre class="source-code">ctx.select(field(name("t", "employee_number")))</pre>
			<pre class="source-code">   .from(select(SALE.EMPLOYEE_NUMBER, SALE.SALE_)</pre>
			<pre class="source-code">      .distinctOn(SALE.EMPLOYEE_NUMBER)</pre>
			<pre class="source-code">      .from(SALE)</pre>
			<pre class="source-code">      .orderBy(SALE.EMPLOYEE_NUMBER, SALE.SALE_).asTable("t"))</pre>
			<pre class="source-code">   .orderBy(field(name("t", "sale")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Of course, this can be emulated without <strong class="source-inline">DISTINCT ON</strong> as well. Here is an alternative:</p>
			<pre class="source-code">ctx.select(field(name("t", "employee_number")))</pre>
			<pre class="source-code">   .from(select(SALE.EMPLOYEE_NUMBER,</pre>
			<pre class="source-code">       min(SALE.SALE_).as("sale"))</pre>
			<pre class="source-code">     .from(SALE)</pre>
			<pre class="source-code">     .groupBy(SALE.EMPLOYEE_NUMBER).asTable("t"))</pre>
			<pre class="source-code">   .orderBy(field(name("t", "sale")))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>In the bundled code (<strong class="source-inline">SelectDistinctOn</strong>), you can find examples that cover all the bullets of the previous list. Take your time to practice them and get familiar with jOOQ syntax. Moreover, don't stop at these <a id="_idIndexMarker435"/>examples; feel free to experiment as much as <a id="_idIndexMarker436"/>possible with <strong class="source-inline">SELECT</strong>.</p>
			<p>That's all about <strong class="source-inline">SELECT</strong>. Next, let's start talking about inserts.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Expressing INSERT statements</h1>
			<p>In this section, we will express different <a id="_idIndexMarker437"/>kinds of inserts including <strong class="source-inline">INSERT ... VALUES</strong>, <strong class="source-inline">INSERT ... SET</strong>, <strong class="source-inline">INSERT ... RETURNING</strong>, and <strong class="source-inline">INSERT ...DEFAULT VALUES</strong> via the jOOQ DSL syntax. Let's start with the well-known <strong class="source-inline">INSERT ... VALUES</strong> insert, which is supported by most database vendors.</p>
			<h3>Expressing INSERT ... VALUES</h3>
			<p>jOOQ supports <strong class="source-inline">INSERT ... VALUES</strong> via the <strong class="source-inline">insertInto()</strong> and <strong class="source-inline">values()</strong> methods. Optionally, we can use the <strong class="source-inline">columns()</strong> method for separating the name of the table in which we insert from the list of fields/columns that we insert. To trigger the actual <strong class="source-inline">INSERT</strong> statement, we have to explicitly call <strong class="source-inline">execute()</strong>; pay attention to this aspect since jOOQ novices tend to forget this call at the end of the insert/update/delete expressions. This method returns the number of rows <a id="_idIndexMarker438"/>affected by this <strong class="source-inline">INSERT</strong> statement as an integer value (<strong class="source-inline">0</strong>), which means that nothing happened.</p>
			<p>For example, the following jOOQ type-safe expression will render an <strong class="source-inline">INSERT</strong> statement that can be successfully executed against at least MySQL, PostgreSQL, SQL Server, and Oracle (the primary key of the <strong class="source-inline">ORDER</strong> table, <strong class="source-inline">ORDER.ORDER_ID</strong>, is auto-generated, therefore, it can be omitted):</p>
			<pre class="source-code">ctx.insertInto(ORDER,</pre>
			<pre class="source-code">      ORDER.COMMENTS, ORDER.ORDER_DATE, ORDER.REQUIRED_DATE,</pre>
			<pre class="source-code">      ORDER.SHIPPED_DATE, ORDER.STATUS, ORDER.CUSTOMER_NUMBER,</pre>
			<pre class="source-code">      ORDER.AMOUNT)</pre>
			<pre class="source-code">   .values("New order inserted...", LocalDate.of(2003, 2, 12),</pre>
			<pre class="source-code">          LocalDate.of(2003, 3, 1), LocalDate.of(2003, 2, 27),</pre>
			<pre class="source-code">          "Shipped", 363L, BigDecimal.valueOf(314.44))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Or, using <strong class="source-inline">columns()</strong>, it can be expressed like this:</p>
			<pre class="source-code">ctx.insertInto(ORDER)</pre>
			<pre class="source-code">   .columns(ORDER.COMMENTS, ORDER.ORDER_DATE,</pre>
			<pre class="source-code">           ORDER.REQUIRED_DATE, ORDER.SHIPPED_DATE,</pre>
			<pre class="source-code">           ORDER.STATUS, ORDER.CUSTOMER_NUMBER, ORDER.AMOUNT)</pre>
			<pre class="source-code">   .values("New order inserted...", LocalDate.of(2003, 2, 12),</pre>
			<pre class="source-code">          LocalDate.of(2003, 3, 1), LocalDate.of(2003, 2, 27),</pre>
			<pre class="source-code">          "Shipped", 363L, BigDecimal.valueOf(314.44))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>If the entire list of columns/fields is omitted (for example, for verbosity reasons), then the jOOQ expression is non-type-safe and you have to explicitly specify a value for each field/column of the table, including for the field/column representing an auto-generated primary key and the fields/columns having default values, otherwise you'll get an exception, as <em class="italic">the number of values must match the number of fields</em>. Moreover, you have to pay attention to the order of values; jOOQ matches the values to the fields only if you follow the order of arguments defined in the <a id="_idIndexMarker439"/>constructor of the <strong class="source-inline">Record</strong> class generated for the table in which we insert (for example, in this case, the order of arguments from the constructor of <strong class="source-inline">OrderRecord</strong>). As Lukas Eder adds, "<em class="italic">The </em><strong class="source-inline">Record</strong><em class="italic"> constructor parameter order is also derived, like everything else, from the order of columns as declared in DDL, which is always the source of truth</em>." In this context, specifying an explicit dummy value for the auto-generated primary key (or other field) can rely on the almost universal (and standard SQL) way, SQL <strong class="source-inline">DEFAULT</strong>, or <strong class="source-inline">DSL.default_()</strong>/<strong class="source-inline">DSL.defaultValue()</strong> in jOOQ (attempting to use <strong class="source-inline">NULL</strong> instead of SQL <strong class="source-inline">DEFAULT</strong> produces implementation-specific behavior):</p>
			<pre class="source-code">ctx.insertInto(ORDER)</pre>
			<pre class="source-code">   .values(default_(), // Oracle, MySQL, PostgreSQL</pre>
			<pre class="source-code">           LocalDate.of(2003, 2, 12), LocalDate.of(2003, 3, 1),</pre>
			<pre class="source-code">           LocalDate.of(2003, 2, 27), "Shipped",</pre>
			<pre class="source-code">           "New order inserted ...", 363L, 314.44)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>In PostgreSQL, we can use the <strong class="source-inline">ORDER_SEQ.nextval()</strong> call as well; <strong class="source-inline">ORDER_SEQ</strong> is the explicit sequence associated with the <strong class="source-inline">ORDER</strong> table:</p>
			<pre class="source-code">ctx.insertInto(ORDER)</pre>
			<pre class="source-code">   .values(ORDER_SEQ.nextval(), </pre>
			<pre class="source-code">           LocalDate.of(2003, 2, 12), LocalDate.of(2003, 3, 1),</pre>
			<pre class="source-code">           LocalDate.of(2003, 2, 27), "Shipped",</pre>
			<pre class="source-code">           "New order inserted ...", 363L, 314.44)</pre>
			<pre class="source-code">    .execute();</pre>
			<p>Generally speaking, we can use the explicit or auto-assigned sequence (if the primary key is of the (<strong class="source-inline">BIG</strong>)<strong class="source-inline">SERIAL</strong> type) associated with the table and call the <strong class="source-inline">nextval()</strong> method. jOOQ defines a <strong class="source-inline">currval()</strong> method as well, representing the current value of the sequence.</p>
			<p>SQL Server is quite challenging because it cannot insert explicit values for the identity column when <strong class="source-inline">IDENTITY_INSERT</strong> is set to <strong class="source-inline">OFF</strong> (<a href="https://github.com/jOOQ/jOOQ/issues/1818">https://github.com/jOOQ/jOOQ/issues/1818</a>). Until jOOQ comes up with an elegant workaround, you can rely on a batch of three queries: one query sets <strong class="source-inline">IDENTITY_INSERT</strong> to <strong class="source-inline">ON</strong>, one query is <strong class="source-inline">INSERT</strong>, and the last query sets <strong class="source-inline">IDENTITY_INSERT</strong> to <strong class="source-inline">OFF</strong>. But, even so, this is useful only for specifying an explicit valid primary key. The SQL <strong class="source-inline">DEFAULT</strong> or <strong class="source-inline">NULL</strong> values, or any other dummy values, are not allowed as explicit identity values. SQL Server will simply <a id="_idIndexMarker440"/>attempt to use the dummy value as the primary key and will end up with an error. As Lukas Eder said, "<em class="italic">In some other RDBMS you'd still get an exception if the auto-generated value is </em><strong class="source-inline">GENERATED ALWAYS AS IDENTITY</strong><em class="italic"> (as opposed to </em><strong class="source-inline">GENERATED BY DEFAULT AS IDENTITY</strong><em class="italic">), and you're trying to insert an explicit value</em>."</p>
			<p>No matter whether the primary key is of an auto-generated type or not, if you specify it explicitly (manually) as a valid value (not a dummy and not a duplicate key), then <strong class="source-inline">INSERT</strong> succeeds in all these four databases (of course, in SQL Server, in the context of <strong class="source-inline">IDENTITY_INSERT</strong> set to <strong class="source-inline">ON</strong>).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Omitting the column list was interesting to explain <strong class="source-inline">DEFAULT</strong> and identities/sequences, but it's really not recommended to omit the column list in <strong class="source-inline">INSERT</strong>. So, you'd better strive to use the column list.</p>
			<p>For inserting multiple rows, you can simply add a <strong class="source-inline">values()</strong> call per row in fluent style or use a loop to iterate a list of rows (typically, a list of records) and reuse the same <strong class="source-inline">values()</strong> call with different values. In the end, don't forget to call <strong class="source-inline">execute()</strong>. This approach (and not only) is available in the bundled code. But, starting with jOOQ 3.15.0, this can be done via <strong class="source-inline">valuesOfRecords()</strong> or <strong class="source-inline">valuesOfRows()</strong>. For instance, consider a list of records:</p>
			<pre class="source-code">List&lt;SaleRecord&gt; listOfRecord = List.of( ... );</pre>
			<p>We can insert this list into the database via <strong class="source-inline">valuesOfRecords()</strong> as follows:</p>
			<pre class="source-code">ctx.insertInto(SALE, SALE.fields())</pre>
			<pre class="source-code">   .valuesOfRecords(listOfRecord)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Here's an example with a list of rows:</p>
			<pre class="source-code">var listOfRows</pre>
			<pre class="source-code">  = List.of(row(2003, 3443.22, 1370L,</pre>
			<pre class="source-code">            SaleRate.SILVER, SaleVat.MAX, 3, 14.55), </pre>
			<pre class="source-code">            row(...), ...);</pre>
			<p>This time, we can use <strong class="source-inline">valuesOfRows()</strong>:</p>
			<pre class="source-code">ctx.insertInto(SALE,</pre>
			<pre class="source-code">               SALE.FISCAL_YEAR, SALE.SALE_,</pre>
			<pre class="source-code">               SALE.EMPLOYEE_NUMBER, SALE.RATE, SALE.VAT,</pre>
			<pre class="source-code">               SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .valuesOfRows(listOfRows)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Whenever you need to collect data (for instance, POJOs) into a list or <a id="_idIndexMarker441"/>array of <strong class="source-inline">RowN</strong>, you can use the built-in <strong class="source-inline">toRowList()</strong> respectively <strong class="source-inline">toRowArray()</strong> collectors. You can find examples in the bundled code.</p>
			<p>In other thoughts, inserting <strong class="source-inline">Record</strong> can be done in several ways; for a quick reminder of jOOQ records, please revisit <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>. For now, let's insert the following <strong class="source-inline">SaleRecord</strong> corresponding to the <strong class="source-inline">SALE</strong> table:</p>
			<pre class="source-code">SaleRecord sr = new SaleRecord();</pre>
			<pre class="source-code">sr.setFiscalYear(2003); // or, sr.set(SALE.FISCAL_YEAR, 2003);</pre>
			<pre class="source-code">sr.setSale(3443.22);    // or, sr.set(SALE.SALE_, 3443.22); </pre>
			<pre class="source-code">sr.setEmployeeNumber(1370L); </pre>
			<pre class="source-code">sr.setFiscalMonth(3);</pre>
			<pre class="source-code">sr.setRevenueGrowth(14.55);</pre>
			<p>To insert <strong class="source-inline">sr</strong>, we do the following:</p>
			<pre class="source-code">ctx.insertInto(SALE)</pre>
			<pre class="source-code">   .values(sr.getSaleId(), sr.getFiscalYear(), sr.getSale(), </pre>
			<pre class="source-code">       sr.getEmployeeNumber(), default_(), SaleRate.SILVER,  </pre>
			<pre class="source-code">       SaleVat.MAX, sr.getFiscalMonth(), sr.getFiscalYear(), </pre>
			<pre class="source-code">       default_())</pre>
			<pre class="source-code">   .execute()</pre>
			<p>Or, we can do the following:</p>
			<pre class="source-code">ctx.insertInto(SALE)</pre>
			<pre class="source-code">   .values(sr.valuesRow().fields())</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Or, we can even do the following:</p>
			<pre class="source-code">ctx.executeInsert(sr);</pre>
			<p>Or, we can attach the record to the<a id="_idIndexMarker442"/> current configuration via <strong class="source-inline">attach()</strong>:</p>
			<pre class="source-code">sr.attach(ctx.configuration());</pre>
			<pre class="source-code">sr.insert();</pre>
			<p>Trying to insert a POJO requires us to wrap it first in the corresponding <strong class="source-inline">Record</strong>. This can be done via the <strong class="source-inline">newRecord()</strong> method, which can load a jOOQ-generated record from your POJO or the jOOQ-generated POJO. Here is an example for the jOOQ-generated <strong class="source-inline">Sale</strong> POJO:</p>
			<pre class="source-code">// jOOQ Sale POJO</pre>
			<pre class="source-code">Sale sale = new Sale(null, 2005, 343.22, 1504L,</pre>
			<pre class="source-code">     null, SaleRate.SILVER, SaleVat.MAX, 4, 15.55, null);</pre>
			<pre class="source-code">ctx.newRecord(SALE, sale).insert();</pre>
			<p>Another approach relies on the handy <strong class="source-inline">Record.from(POJO)</strong> method, as follows (basically, this time you use an explicit instance of <strong class="source-inline">SaleRecord</strong>):</p>
			<pre class="source-code">SaleRecord sr = new SaleRecord();</pre>
			<pre class="source-code">sr.from(sale); // sale is the previous POJO instance</pre>
			<pre class="source-code">ctx.executeInsert(sr);</pre>
			<p><strong class="source-inline">Record.from()</strong> comes in several flavors that allow us to populate <strong class="source-inline">Record</strong> from an array or even <strong class="source-inline">Map</strong> of values.</p>
			<p>Whenever you need to reset a <strong class="source-inline">Record</strong> primary key (or another field), call the <strong class="source-inline">reset()</strong> method as in the following<a id="_idIndexMarker443"/> scenario, which resets the manually assigned primary key and allows the database to generate one on our behalf:</p>
			<pre class="source-code">Sale sale = new Sale(1L, 2005, 343.22, 1504L, null,    </pre>
			<pre class="source-code">                SaleRate.SILVER, SaleVat.MAX, 6, 23.99, null);</pre>
			<pre class="source-code">SaleRecord sr = new SaleRecord();</pre>
			<pre class="source-code">sr.from(sale);</pre>
			<pre class="source-code">// reset the current ID and allow DB to generate one</pre>
			<pre class="source-code">sr.reset(SALE.SALE_ID);       </pre>
			<pre class="source-code">ctx.executeInsert(sr);</pre>
			<p>Nevertheless, the <strong class="source-inline">reset()</strong> method resets both the <em class="italic">changed</em> flag (which tracks record changes) and <em class="italic">value</em> (in this case, the primary key). If you want to reset only the value (primary key or another field), then you can rely on the <strong class="source-inline">changed</strong><strong class="source-inline">(Field&lt;?&gt; field, boolean changed)</strong> method as here:</p>
			<pre class="source-code">record.changed(SALE.SALE_ID, false);</pre>
			<p>Well, these were just a handful of examples. Many more, including <a id="_idIndexMarker444"/>using UDTs (in PostgreSQL and Oracle) and user-defined functions in <strong class="source-inline">INSERT</strong>, are available in the bundled code in the application named <em class="italic">InsertValues</em>. Next, let's talk about <strong class="source-inline">INSERT ... SET</strong>.</p>
			<h3>Expressing INSERT ... SET</h3>
			<p><strong class="source-inline">INSERT ... SET</strong> is an alternative to <strong class="source-inline">INSERT ... VALUES</strong>, having an <strong class="source-inline">UPDATE</strong>-like syntax, and is commonly used <a id="_idIndexMarker445"/>in MySQL (but not only so). Practically, instead of listing columns and values separately, in <strong class="source-inline">INSERT ... SET</strong>, we write field-value pairs via the <strong class="source-inline">set(field, value)</strong> method. This is more readable since we can easily identify the value of each field. Let's look at an example of inserting two rows:</p>
			<pre class="source-code">ctx.insertInto(SALE)</pre>
			<pre class="source-code">   .set(SALE.FISCAL_YEAR, 2005)      // first row</pre>
			<pre class="source-code">   .set(SALE.SALE_, 4523.33)</pre>
			<pre class="source-code">   .set(SALE.EMPLOYEE_NUMBER, 1504L)</pre>
			<pre class="source-code">   .set(SALE.FISCAL_MONTH, 3)</pre>
			<pre class="source-code">   .set(SALE.REVENUE_GROWTH, 12.22)</pre>
			<pre class="source-code">   .newRecord()</pre>
			<pre class="source-code">   .set(SALE.FISCAL_YEAR, 2005)      // second row</pre>
			<pre class="source-code">   .set(SALE.SALE_, 4523.33)</pre>
			<pre class="source-code">   .set(SALE.EMPLOYEE_NUMBER, 1504L)</pre>
			<pre class="source-code">   .set(SALE.FISCAL_MONTH, 4)</pre>
			<pre class="source-code">   .set(SALE.REVENUE_GROWTH, 22.12)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This syntax works for <strong class="source-inline">Record</strong> as well:</p>
			<pre class="source-code">SaleRecord sr = new SaleRecord(...);</pre>
			<pre class="source-code">ctx.insertInto(SALE).set(sr).execute();</pre>
			<p>Since <strong class="source-inline">INSERT … SET</strong> and <strong class="source-inline">INSERT … VALUES</strong> are equivalent, jOOQ emulates <strong class="source-inline">INSERT … SET</strong> as <strong class="source-inline">INSERT … VALUES</strong> for all databases<a id="_idIndexMarker446"/> supported by jOOQ. The complete application is named <em class="italic">InsertSet</em>. Next, let's tackle the <strong class="source-inline">INSERT ... RETURNING</strong> syntax.</p>
			<h3>Expressing INSERT ... RETURNING</h3>
			<p>The particularity of <strong class="source-inline">INSERT ... RETURNING</strong> relies on the fact that it can return what was inserted (fetch back something that we need further). This may resume returning the primary key of the inserted row(s) or other<a id="_idIndexMarker447"/> fields as well (for instance, other sequences, default generated values, and trigger results). PostgreSQL has native support for <strong class="source-inline">INSERT ... RETURNING</strong>. Oracle also supports <strong class="source-inline">INSERT ... RETURNING</strong>, and jOOQ generates a PL/SQL anonymous block for it (not always). SQL Server supports <strong class="source-inline">OUTPUT</strong>, which is almost the same (apart from how trigger-generated values are affected). Other databases have poor support, and jOOQ has to emulate it on our behalf. In such cases, jOOQ relies on the JDBC <strong class="source-inline">getGeneratedKeys()</strong> method to retrieve the inserted primary keys. Moreover, if the generated primary keys (or other columns) cannot be retrieved directly, jOOQ may need to execute an additional <strong class="source-inline">SELECT</strong> to achieve this goal and this may lead to race conditions (for instance, such <strong class="source-inline">SELECT</strong> are needed in MySQL).</p>
			<p>The jOOQ API for <strong class="source-inline">INSERT ... RETURNING</strong> contains the <strong class="source-inline">returningResult()</strong> method that comes in different flavors. It comes with different lists of arguments allowing us to specify which fields should be returned. If all fields should be returned, then simply use it without arguments. If only the primary key should be returned (being a popular use case for database auto-generated primary keys such us MySQL's <strong class="source-inline">AUTO_INCREMENT</strong> or PostgreSQL's (<strong class="source-inline">BIG</strong>)<strong class="source-inline">SERIAL</strong>, which automatically produces a sequence), then simply specify it as <strong class="source-inline">returningResult(pk_field)</strong>. If the primary key has multiple fields (a composite primary key), then list all of its fields separated by commas.</p>
			<p>Here is an example that<a id="_idIndexMarker448"/> returns the primary key of a single insert:</p>
			<pre class="source-code">// Record1&lt;Long&gt;</pre>
			<pre class="source-code">var insertedId = ctx.insertInto(SALE, </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR, SALE.SALE_, SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">      SALE.REVENUE_GROWTH, SALE.FISCAL_MONTH)</pre>
			<pre class="source-code">   .values(2004, 2311.42, 1370L, 10.12, 1)</pre>
			<pre class="source-code">   .returningResult(SALE.SALE_ID)</pre>
			<pre class="source-code">   .fetchOne();</pre>
			<p>Since there is a single result, we fetch it via the <strong class="source-inline">fetchOne()</strong> method. Fetching multiple primary keys can be done via <strong class="source-inline">fetch()</strong>, as follows:</p>
			<pre class="source-code">// Result&lt;Record1&lt;Long&gt;&gt;</pre>
			<pre class="source-code">var insertedIds = ctx.insertInto(SALE, </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR,SALE.SALE_, SALE.EMPLOYEE_NUMBER, </pre>
			<pre class="source-code">      SALE.REVENUE_GROWTH, SALE.FISCAL_MONTH)</pre>
			<pre class="source-code">   .values(2004, 2311.42, 1370L, 12.50, 1)</pre>
			<pre class="source-code">   .values(2003, 900.21, 1504L, 23.99, 2)</pre>
			<pre class="source-code">   .values(2005, 1232.2, 1166L, 14.65, 3)</pre>
			<pre class="source-code">   .returningResult(SALE.SALE_ID)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This time, the returned result contains three primary keys. Returning more/other fields can be done as follows (the result looks like an <em class="italic">n-cols x n-rows</em> table):</p>
			<pre class="source-code">// Result&lt;Record2&lt;String, LocalDate&gt;&gt;</pre>
			<pre class="source-code">var inserted = ctx.insertInto(PRODUCTLINE,  </pre>
			<pre class="source-code">      PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION, </pre>
			<pre class="source-code">      PRODUCTLINE.CODE)</pre>
			<pre class="source-code">    .values(..., "This new line of electric vans ...", 983423L)</pre>
			<pre class="source-code">    .values(..., "This new line of turbo N cars ...", 193384L)</pre>
			<pre class="source-code">    .returningResult(PRODUCTLINE.PRODUCT_LINE, </pre>
			<pre class="source-code">                     PRODUCTLINE.CREATED_ON)</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>Now, let's look at a more interesting example. In our database schema, the <strong class="source-inline">CUSTOMER</strong> and <strong class="source-inline">CUSTOMERDETAIL</strong> tables are in a one-to-one relationship and share the primary key value. In other words, the <strong class="source-inline">CUSTOMER</strong> primary key is at the same time the primary key and foreign key in <strong class="source-inline">CUSTOMERDETAIL</strong>; this way, there is no<a id="_idIndexMarker449"/> need to maintain a separate foreign key. So, we have to use the <strong class="source-inline">CUSTOMER</strong> returned primary key for inserting the corresponding row in <strong class="source-inline">CUSTOMERDETAIL</strong>:</p>
			<pre class="source-code">ctx.insertInto(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .values(ctx.insertInto(CUSTOMER)</pre>
			<pre class="source-code">      .values(default_(), ..., "Kyle", "Doyle", </pre>
			<pre class="source-code">              "+ 44 321 321", default_(), default_(), default_())</pre>
			<pre class="source-code">      .returningResult(CUSTOMER.CUSTOMER_NUMBER).fetchOne()</pre>
			<pre class="source-code">         .value1(), ..., default_(), "Los Angeles", </pre>
			<pre class="source-code">           default_(), default_(), "USA")</pre>
			<pre class="source-code">   .execute();</pre>
			<p>If you are familiar with JPA, then you can recognize an elegant alternative to <strong class="source-inline">@MapsId</strong> here.</p>
			<p>The first <strong class="source-inline">INSERT</strong> (inner <strong class="source-inline">INSERT</strong>) will insert a row in <strong class="source-inline">CUSTOMER</strong> and will return the generated primary key via <strong class="source-inline">returningResult()</strong>. Next, the second <strong class="source-inline">INSERT</strong> (outer <strong class="source-inline">INSERT</strong>) will insert a row in <strong class="source-inline">CUSTOMERDETAIL</strong> using this returned primary key as a value for the <strong class="source-inline">CUSTOMERDETAIL.CUSTOMER_NUMBER</strong> primary key.</p>
			<p>Moreover, the <strong class="source-inline">returningResult()</strong> method can also return expressions such as <strong class="source-inline">returningResult(A.concat(B).as("C"))</strong>.</p>
			<p>As usual, take your time and check out the bundled code, which comes<a id="_idIndexMarker450"/> with many more examples. The application is named <em class="italic">InsertReturning</em>. Next, let's talk about <strong class="source-inline">INSERT ... DEFAULT VALUES</strong>.</p>
			<h3>Expressing INSERT ... DEFAULT VALUES</h3>
			<p>The straightforward approach for inserting <a id="_idIndexMarker451"/>default values is to omit the fields having default values from <strong class="source-inline">INSERT</strong>. For example, look at the following code:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT)</pre>
			<pre class="source-code">   .columns(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_LINE,   </pre>
			<pre class="source-code">            PRODUCT.CODE, PRODUCT.PRODUCT_SCALE,</pre>
			<pre class="source-code">            PRODUCT.PRODUCT_VENDOR, PRODUCT.BUY_PRICE, </pre>
			<pre class="source-code">            PRODUCT.MSRP)</pre>
			<pre class="source-code">   .values("Ultra Jet X1", "Planes", 433823L, "1:18", </pre>
			<pre class="source-code">           "Motor City Art Classics",</pre>
			<pre class="source-code">            BigDecimal.valueOf(45.9), BigDecimal.valueOf(67.9))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The <strong class="source-inline">PRODUCT</strong> fields that are not listed (<strong class="source-inline">PRODUCT_DESCRIPTION</strong>, <strong class="source-inline">PRODUCT_UID</strong>, <strong class="source-inline">SPECS</strong>, and <strong class="source-inline">QUANTITY_IN_STOCK</strong>) will take advantage of implicit default values. </p>
			<p>The jOOQ API comes with <strong class="source-inline">defaultValues()</strong>, <strong class="source-inline">defaultValue()</strong>, and <strong class="source-inline">default_()</strong> methods for explicitly pointing out the fields that should rely on default values. The former is useful for inserting a single row having only default values; if you check the database schema, you <a id="_idIndexMarker452"/>can notice that the <strong class="source-inline">MANAGER</strong> table has a default value for each of its columns:</p>
			<pre class="source-code">ctx.insertInto(MANAGER).defaultValues().execute();</pre>
			<p>On the other hand, the <strong class="source-inline">defaultValue()</strong> method (or <strong class="source-inline">default_()</strong>) allows us to point to the fields that should rely on default values:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT)</pre>
			<pre class="source-code">   .columns(PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_LINE,</pre>
			<pre class="source-code">     PRODUCT.CODE, PRODUCT.PRODUCT_SCALE,   </pre>
			<pre class="source-code">     PRODUCT.PRODUCT_VENDOR, PRODUCT.PRODUCT_DESCRIPTION,  </pre>
			<pre class="source-code">     PRODUCT.QUANTITY_IN_STOCK, PRODUCT.BUY_PRICE, </pre>
			<pre class="source-code">     PRODUCT.MSRP, PRODUCT.SPECS, PRODUCT.PRODUCT_UID)</pre>
			<pre class="source-code">   .values(val("Ultra Jet X1"), val("Planes"), </pre>
			<pre class="source-code">           val(433823L),val("1:18"), </pre>
			<pre class="source-code">           val("Motor City Art Classics"),</pre>
			<pre class="source-code">           defaultValue(PRODUCT.PRODUCT_DESCRIPTION),</pre>
			<pre class="source-code">           defaultValue(PRODUCT.QUANTITY_IN_STOCK),</pre>
			<pre class="source-code">           val(BigDecimal.valueOf(45.99)),  </pre>
			<pre class="source-code">           val(BigDecimal.valueOf(67.99)),</pre>
			<pre class="source-code">           defaultValue(PRODUCT.SPECS),  </pre>
			<pre class="source-code">           defaultValue(PRODUCT.PRODUCT_UID))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The non-type-safe version of this example is as follows:</p>
			<pre class="source-code">ctx.insertInto(PRODUCT)</pre>
			<pre class="source-code">   .values(defaultValue(), "Ultra Jet X1", "Planes", 433823L,</pre>
			<pre class="source-code">     defaultValue(), "Motor City Art Classics",</pre>
			<pre class="source-code">     defaultValue(), defaultValue(), 45.99, 67.99,  </pre>
			<pre class="source-code">     defaultValue(), defaultValue())</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.insertInto(PRODUCT)</pre>
			<pre class="source-code">   .values(defaultValue(PRODUCT.PRODUCT_ID), </pre>
			<pre class="source-code">           "Ultra JetX1", "Planes", 433823L, </pre>
			<pre class="source-code">           defaultValue(PRODUCT.PRODUCT_SCALE),</pre>
			<pre class="source-code">           "Motor City Art Classics",</pre>
			<pre class="source-code">           defaultValue(PRODUCT.PRODUCT_DESCRIPTION),</pre>
			<pre class="source-code">           defaultValue(PRODUCT.QUANTITY_IN_STOCK),</pre>
			<pre class="source-code">           45.99, 67.99, defaultValue(PRODUCT.SPECS),</pre>
			<pre class="source-code">           defaultValue(PRODUCT.PRODUCT_UID))</pre>
			<pre class="source-code">   .execute()</pre>
			<p>The same result can be obtained by specifying the types of columns. For example, the previous <strong class="source-inline">defaultValue(PRODUCT.QUANTITY_IN_STOCK)</strong> calls can be written as follows:</p>
			<pre class="source-code">defaultValue(INTEGER) // or, defaultValue(Integer.class)</pre>
			<p>Inserting <strong class="source-inline">Record</strong> with default values <a id="_idIndexMarker453"/>can be done quite simply, as in the following examples:</p>
			<pre class="source-code">ctx.newRecord(MANAGER).insert();</pre>
			<pre class="source-code">ManagerRecord mr = new ManagerRecord();</pre>
			<pre class="source-code">ctx.newRecord(MANAGER, mr).insert();</pre>
			<p>Using default values is useful to fill up those fields that will be later updated (for example, via subsequent updates, trigger-generated values, and so on) or if we simply don't have values. </p>
			<p>The complete application is <a id="_idIndexMarker454"/>named <em class="italic">InsertDefaultValues</em>. Next, let's talk about jOOQ and <strong class="source-inline">UPDATE</strong> statements.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Expressing UPDATE statements</h1>
			<p>In this section, we will express <a id="_idIndexMarker455"/>different kinds of updates, including <strong class="source-inline">UPDATE ... SET</strong>, <strong class="source-inline">UPDATE ... FROM</strong>, and <strong class="source-inline">UPDATE ... RETURNING</strong>, and update using row value expressions via the jOOQ DSL syntax. At the time of writing, jOOQ supports updates against a single table, while updates against multiple tables represent a work in progress task.</p>
			<h3>Expressing UPDATE ... SET</h3>
			<p>The straightforward <strong class="source-inline">UPDATE ... SET</strong> statement <a id="_idIndexMarker456"/>can be expressed in jOOQ via the <strong class="source-inline">set(field, value)</strong> method, as in the following example (don't forget to call <strong class="source-inline">execute()</strong> to trigger the update):</p>
			<pre class="source-code">ctx.update(OFFICE)</pre>
			<pre class="source-code">   .set(OFFICE.CITY, "Banesti")</pre>
			<pre class="source-code">   .set(OFFICE.COUNTRY, "Romania")</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq("1"))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The rendered SQL for MySQL dialect will be as follows:</p>
			<pre class="source-code">UPDATE `classicmodels`.`office`</pre>
			<pre class="source-code">SET `classicmodels`.`office'.`city` = ?,</pre>
			<pre class="source-code">    `classicmodels`.`office`.`country` = ?</pre>
			<pre class="source-code">WHERE `classicmodels`.`office`.`office_code` = ?</pre>
			<p>Looks like a classic <strong class="source-inline">UPDATE</strong>, right? Notice that jOOQ automatically renders only the updated columns. If you are coming from JPA, then you know that Hibernate JPA renders, by default, all columns and we have<a id="_idIndexMarker457"/> to rely on <strong class="source-inline">@DynamicUpdate</strong> to obtain the same thing as jOOQ.</p>
			<p>Check out another example for increasing the employee salary by an amount computed based on their sales:</p>
			<pre class="source-code">ctx.update(EMPLOYEE)</pre>
			<pre class="source-code">   .set(EMPLOYEE.SALARY, EMPLOYEE.SALARY.plus(</pre>
			<pre class="source-code">      field(select(count(SALE.SALE_).multiply(5.75)).from(SALE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">      .eq(SALE.EMPLOYEE_NUMBER)))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And here is the generated SQL for SQL Server dialect:</p>
			<pre class="source-code">UPDATE [classicmodels].[dbo].[employee]</pre>
			<pre class="source-code">SET [classicmodels].[dbo].[employee].[salary] = </pre>
			<pre class="source-code">  ([classicmodels].[dbo].[employee].[salary] +</pre>
			<pre class="source-code">   (SELECT (count([classicmodels].[dbo].[sale].[sale]) * ?)</pre>
			<pre class="source-code">    FROM [classicmodels].[dbo].[sale]</pre>
			<pre class="source-code">    WHERE [classicmodels].[dbo].[employee].[employee_number] </pre>
			<pre class="source-code">        = [classicmodels].[dbo].[sale].[employee_number]))</pre>
			<p>Notice that this is an <strong class="source-inline">UPDATE</strong> without a <strong class="source-inline">WHERE</strong> clause and jOOQ will log a message as <strong class="source-inline">A statement is executed without WHERE clause</strong>. This is just friendly information that you can ignore if you have omitted the <strong class="source-inline">WHERE</strong> clause on purpose. But, if you know that this was not done on purpose, then you may want to avoid such situations by relying on the jOOQ <strong class="source-inline">withExecuteUpdateWithoutWhere()</strong> setting. You can choose from several behaviors including throwing an exception, as in this example:</p>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">   .withExecuteUpdateWithoutWhere(ExecuteWithoutWhere.THROW))</pre>
			<pre class="source-code">   .dsl()</pre>
			<pre class="source-code">   .update(OFFICE)</pre>
			<pre class="source-code">   .set(OFFICE.CITY, "Banesti")</pre>
			<pre class="source-code">   .set(OFFICE.COUNTRY, "Romania")                  </pre>
			<pre class="source-code">   .execute();</pre>
			<p>Notice that we use <strong class="source-inline">Configuration.derive()</strong>, not <strong class="source-inline">Configuration.set()</strong>, because if the <strong class="source-inline">DSLContext</strong> is injected, <strong class="source-inline">Configuration</strong> is global and shared. Using <strong class="source-inline">Configuration.set()</strong> will affect the global settings. If this is the desired behavior, then it is better to rely on a separate <strong class="source-inline">@Bean</strong>, as you already<a id="_idIndexMarker458"/> saw in this book.</p>
			<p>This time, whenever we attempt to execute <strong class="source-inline">UPDATE</strong> without the <strong class="source-inline">WHERE</strong> clause, <strong class="source-inline">UPDATE</strong> doesn't take any action and jOOQ throws an exception of the <strong class="source-inline">org.jooq.exception.DataAccessException</strong> type.</p>
			<p>Updating <strong class="source-inline">Record</strong> is also quite simple. Check this out:</p>
			<pre class="source-code">OfficeRecord or = new OfficeRecord();</pre>
			<pre class="source-code">or.setCity("Constanta");</pre>
			<pre class="source-code">or.setCountry("Romania");</pre>
			<pre class="source-code">ctx.update(OFFICE)</pre>
			<pre class="source-code">   .set(or)</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq("1")).execute();</pre>
			<pre class="source-code">// or, like this</pre>
			<pre class="source-code">ctx.executeUpdate(or, OFFICE.OFFICE_CODE.eq("1"));</pre>
			<p>As you'll see in<a id="_idIndexMarker459"/> the bundled code, using <strong class="source-inline">DSLContext.newRecord()</strong> is also an option.</p>
			<h3>Expressing UPDATE using row value expressions</h3>
			<p>Updating using row value expressions is a <a id="_idIndexMarker460"/>very handy tool, and jOOQ expresses such updates in a very clean and intuitive way. Check out this <a id="_idIndexMarker461"/>example:</p>
			<pre class="source-code">ctx.update(OFFICE)</pre>
			<pre class="source-code">    .set(row(OFFICE.ADDRESS_LINE_FIRST, </pre>
			<pre class="source-code">             OFFICE.ADDRESS_LINE_SECOND, OFFICE.PHONE),</pre>
			<pre class="source-code">         select(EMPLOYEE.FIRST_NAME, EMPLOYEE.LAST_NAME, </pre>
			<pre class="source-code">             val("+40 0721 456 322"))</pre>
			<pre class="source-code">           .from(EMPLOYEE)</pre>
			<pre class="source-code">           .where(EMPLOYEE.JOB_TITLE.eq("President")))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The produced SQL for PostgreSQL is as follows:</p>
			<pre class="source-code">UPDATE "public"."office"</pre>
			<pre class="source-code">SET ("address_line_first", "address_line_second", "phone") =</pre>
			<pre class="source-code">  (SELECT "public"."employee"."first_name",</pre>
			<pre class="source-code">          "public"."employee"."last_name", ?</pre>
			<pre class="source-code">   FROM "public"."employee"</pre>
			<pre class="source-code">   WHERE "public"."employee"."job_title" = ?)</pre>
			<p>Even if row value expressions are particularly useful for writing subselects, as in the previous example, it doesn't mean that <a id="_idIndexMarker462"/>you cannot write the following:</p>
			<pre class="source-code">ctx.update(OFFICE)</pre>
			<pre class="source-code">   .set(row(OFFICE.CITY, OFFICE.COUNTRY),</pre>
			<pre class="source-code">        row("Hamburg", "Germany"))</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq("1"))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This can be useful for reusing fields with <a id="_idIndexMarker463"/>minimum verbosity:</p>
			<pre class="source-code">Row2&lt;String, String&gt; r1 = row(OFFICE.CITY, OFFICE.COUNTRY);</pre>
			<pre class="source-code">Row2&lt;String, String&gt; r2 = row("Hamburg", "Germany");</pre>
			<pre class="source-code">ctx.update(OFFICE).set(r1, r2).where(r1.isNull())</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Next, let's tackle the <strong class="source-inline">UPDATE ... FROM</strong> syntax.</p>
			<h3>Expressing UPDATE ... FROM</h3>
			<p>Using the <strong class="source-inline">UPDATE ... FROM</strong> syntax, we can join additional tables to an <strong class="source-inline">UPDATE</strong> statement. Notice that this <strong class="source-inline">FROM</strong> clause is <a id="_idIndexMarker464"/>vendor-specific supported in PostgreSQL and SQL Server, but not supported in MySQL and Oracle (however, when you read this book, jOOQ may have already emulated this syntax, so check it out). Here is an example:</p>
			<pre class="source-code">ctx.update(PRODUCT)</pre>
			<pre class="source-code">   .set(PRODUCT.BUY_PRICE, ORDERDETAIL.PRICE_EACH)</pre>
			<pre class="source-code">   .from(ORDERDETAIL)</pre>
			<pre class="source-code">   .where(PRODUCT.PRODUCT_ID.eq(ORDERDETAIL.PRODUCT_ID))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>And the SQL rendered for PostgreSQL is as follows:</p>
			<pre class="source-code">UPDATE "public"."product"</pre>
			<pre class="source-code">SET "buy_price" = "public"."orderdetail"."price_each"</pre>
			<pre class="source-code">FROM "public"."orderdetail"</pre>
			<pre class="source-code">WHERE "public"."product"."product_id" </pre>
			<pre class="source-code">    = "public"."orderdetail"."product_id"</pre>
			<p>Finally, let's tackle<a id="_idIndexMarker465"/> the <strong class="source-inline">UPDATE ... RETURNING</strong> syntax.</p>
			<h3>Expressing UPDATE ... RETURNING</h3>
			<p><strong class="source-inline">UPDATE ... RETURNING</strong> is like <strong class="source-inline">INSERT ... RETURNING</strong> but for <strong class="source-inline">UPDATE</strong>. This is supported natively by PostgreSQL and is emulated by jOOQ for<a id="_idIndexMarker466"/> SQL Server and Oracle. In jOOQ DSL, we express <strong class="source-inline">UPDATE ... RETURNING</strong> via <strong class="source-inline">returningResult()</strong> as in the following example:</p>
			<pre class="source-code">ctx.update(OFFICE)</pre>
			<pre class="source-code">   .set(OFFICE.CITY, "Paris")</pre>
			<pre class="source-code">   .set(OFFICE.COUNTRY, "France")</pre>
			<pre class="source-code">   .where(OFFICE.OFFICE_CODE.eq("1"))</pre>
			<pre class="source-code">   .returningResult(OFFICE.CITY, OFFICE.COUNTRY)</pre>
			<pre class="source-code">   .fetchOne();</pre>
			<p>The SQL rendered for PostgreSQL is shown next:</p>
			<pre class="source-code">UPDATE "public"."office"</pre>
			<pre class="source-code">SET "city" = ?,</pre>
			<pre class="source-code">    "country" = ?</pre>
			<pre class="source-code">WHERE "public"."office"."office_code" = ? </pre>
			<pre class="source-code">RETURNING "public"."office"."city",</pre>
			<pre class="source-code">          "public"."office"."country"</pre>
			<p>We can use <strong class="source-inline">UPDATE ... RETURNING</strong> for logically chaining multiple updates. For example, let's assume that we want to increase the salary of an employee with the average of their sales and the credit limit of their customers <a id="_idIndexMarker467"/>with the returned salary multiplied by two. We can express these two <strong class="source-inline">UPDATE</strong> statements fluently via <strong class="source-inline">UPDATE ... RETURNING</strong> as follows:</p>
			<pre class="source-code">ctx.update(CUSTOMER)</pre>
			<pre class="source-code">   .set(CUSTOMER.CREDIT_LIMIT, CUSTOMER.CREDIT_LIMIT.plus(</pre>
			<pre class="source-code">      ctx.update(EMPLOYEE)</pre>
			<pre class="source-code">         .set(EMPLOYEE.SALARY, EMPLOYEE.SALARY.plus(</pre>
			<pre class="source-code">            field(select(avg(SALE.SALE_)).from(SALE)</pre>
			<pre class="source-code">                  .where(SALE.EMPLOYEE_NUMBER</pre>
			<pre class="source-code">                     .eq(EMPLOYEE.EMPLOYEE_NUMBER)))))</pre>
			<pre class="source-code">         .where(EMPLOYEE.EMPLOYEE_NUMBER.eq(1504L))</pre>
			<pre class="source-code">         .returningResult(EMPLOYEE.SALARY</pre>
			<pre class="source-code">            .coerce(BigDecimal.class))</pre>
			<pre class="source-code">         .fetchOne().value1()</pre>
			<pre class="source-code">            .multiply(BigDecimal.valueOf(2))))</pre>
			<pre class="source-code">   .where(CUSTOMER.SALES_REP_EMPLOYEE_NUMBER.eq(1504L))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>However, pay attention to potential race conditions, given that there are two round trips hidden in what looks like a single query.</p>
			<p>Practicing this example and many others can be done via the application named <em class="italic">UpdateSamples</em>. Next, let's tackle the <strong class="source-inline">DELETE</strong> statement.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Expressing DELETE statements</h1>
			<p>Expressing <strong class="source-inline">DELETE</strong> statements<a id="_idIndexMarker468"/> in jOOQ can be done via the <strong class="source-inline">DSLContext.delete()</strong> and <strong class="source-inline">DSLContext.deleteFrom()</strong> API or via <strong class="source-inline">DSLContext.deleteQuery()</strong> and <strong class="source-inline">DSLContext.executeDelete()</strong>, respectively. While the first three methods receive an argument of the <strong class="source-inline">Table&lt;R&gt; </strong>type, the <strong class="source-inline">executeDelete()</strong>method is useful for deleting a record as <strong class="source-inline">TableRecord&lt;?&gt;</strong> or <strong class="source-inline">UpdatableRecord&lt;?&gt;</strong>. As you can see from the following example, <strong class="source-inline">delete()</strong> and <strong class="source-inline">deleteFrom()</strong> work exactly the same:</p>
			<pre class="source-code">ctx.delete(SALE)</pre>
			<pre class="source-code">   .where(SALE.FISCAL_YEAR.eq(2003))</pre>
			<pre class="source-code">   .execute();</pre>
			<pre class="source-code">ctx.deleteFrom(SALE)</pre>
			<pre class="source-code">   .where(SALE.FISCAL_YEAR.eq(2003))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>Both of these expressions render this SQL:</p>
			<pre class="source-code">DELETE FROM `classicmodels`.`sale`</pre>
			<pre class="source-code">WHERE `classicmodels`.`sale`.`fiscal_year` = ?</pre>
			<p>Combining <strong class="source-inline">DELETE</strong> and row value expressions is useful for deleting via subselects, as in the following example:</p>
			<pre class="source-code">ctx.deleteFrom(CUSTOMERDETAIL)</pre>
			<pre class="source-code">   .where(row(CUSTOMERDETAIL.POSTAL_CODE,</pre>
			<pre class="source-code">              CUSTOMERDETAIL.STATE).in(</pre>
			<pre class="source-code">                 select(OFFICE.POSTAL_CODE, OFFICE.STATE)</pre>
			<pre class="source-code">                   .from(OFFICE)</pre>
			<pre class="source-code">                   .where(OFFICE.COUNTRY.eq("USA"))))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>One important aspect of <strong class="source-inline">DELETE</strong> resumes to cascading deletion from parent to child. Whenever possible, it is a good idea to rely on database support for accomplishing <strong class="source-inline">DELETE</strong> cascading tasks. For example, you can use <strong class="source-inline">ON DELETE CASCADE</strong> or a stored procedure that implements the cascading deletion logic. As Lukas Eder highlights, "<em class="italic">The rule of thumb is to </em><strong class="source-inline">CASCADE</strong><em class="italic"> compositions (UML speak) and to </em><strong class="source-inline">RESTRICT</strong><em class="italic"> or </em><strong class="source-inline">NO ACTION</strong><em class="italic">, or </em><strong class="source-inline">SET NULL</strong><em class="italic"> (if supported) aggregations. In other words, if the child cannot live without the parent (composition), then delete it with the parent. Otherwise, raise an exception (</em><strong class="source-inline">RESTRICT</strong><em class="italic">, </em><strong class="source-inline">NO ACTION</strong><em class="italic">), or set the reference to </em><strong class="source-inline">NULL</strong><em class="italic">. jOOQ might support </em><strong class="source-inline">DELETE ... CASCADE</strong><em class="italic"> in the future: </em><a href="https://github.com/jOOQ/jOOQ/issues/7367">https://github.com/jOOQ/jOOQ/issues/7367</a>."</p>
			<p>However, if none of these approaches are possible, then you can do it via jOOQ as well. You can write a chain of separate <strong class="source-inline">DELETE</strong> statements or rely on <strong class="source-inline">DELETE ... RETURNING</strong> as in the following examples, which<a id="_idIndexMarker469"/> delete <strong class="source-inline">PRODUCTLINE</strong> via cascading (<strong class="source-inline">PRODUCTLINE</strong> – <strong class="source-inline">PRODUCTLINEDETAIL</strong> – <strong class="source-inline">PRODUCT</strong> – <strong class="source-inline">ORDERDETAIL</strong>). In order to delete <strong class="source-inline">PRODUCTLINE</strong>, we have to delete all its products from <strong class="source-inline">PRODUCT</strong> and the corresponding record from <strong class="source-inline">PRODUCTLINEDETAIL</strong>. To delete all products of <strong class="source-inline">PRODUCTLINE</strong> from <strong class="source-inline">PRODUCT</strong>, we have to delete all references for these products from <strong class="source-inline">ORDERDETAIL</strong>. So, we start deleting from <strong class="source-inline">ORDERDETAIL</strong>, as follows:</p>
			<pre class="source-code">ctx.delete(PRODUCTLINE)</pre>
			<pre class="source-code"> .where(PRODUCTLINE.PRODUCT_LINE.in(</pre>
			<pre class="source-code">   ctx.delete(PRODUCTLINEDETAIL)</pre>
			<pre class="source-code">    .where(PRODUCTLINEDETAIL.PRODUCT_LINE.in(</pre>
			<pre class="source-code">      ctx.delete(PRODUCT)</pre>
			<pre class="source-code">       .where(PRODUCT.PRODUCT_ID.in(</pre>
			<pre class="source-code">         ctx.delete(ORDERDETAIL)</pre>
			<pre class="source-code">          .where(ORDERDETAIL.PRODUCT_ID.in(</pre>
			<pre class="source-code">            select(PRODUCT.PRODUCT_ID).from(PRODUCT)</pre>
			<pre class="source-code">             .where(PRODUCT.PRODUCT_LINE.eq("Motorcycles")</pre>
			<pre class="source-code">               .or(PRODUCT.PRODUCT_LINE</pre>
			<pre class="source-code">                 .eq("Trucks and Buses")))))</pre>
			<pre class="source-code">         .returningResult(ORDERDETAIL.PRODUCT_ID).fetch()))</pre>
			<pre class="source-code">       .returningResult(PRODUCT.PRODUCT_LINE).fetch()))</pre>
			<pre class="source-code">     .returningResult(PRODUCTLINEDETAIL.PRODUCT_LINE).fetch()))</pre>
			<pre class="source-code"> .execute();</pre>
			<p>This jOOQ fluent expression renders four <strong class="source-inline">DELETE</strong> statements, which you can check in the bundled code. The challenge here consists of guaranteeing the roll-back functionality if something goes <a id="_idIndexMarker470"/>wrong. But, having the jOOQ expression in a Spring Boot <strong class="source-inline">@Transactional</strong> method, the roll-back functionality is out of the box. This is much better than the JPA cascading via <strong class="source-inline">CascadeType.REMOVE</strong> or <strong class="source-inline">orphanRemoval=true</strong>, which are very prone to <em class="italic">N + 1</em> issues. jOOQ allows us to control both what is deleted, and how this takes place.</p>
			<p>In other thoughts, deleting <strong class="source-inline">Record</strong> (<strong class="source-inline">TableRecord</strong> or <strong class="source-inline">UpdatableRecord</strong>) can be done via <strong class="source-inline">executeDelete()</strong>, as in the following examples:</p>
			<pre class="source-code">PaymentRecord pr = new PaymentRecord();</pre>
			<pre class="source-code">pr.setCustomerNumber(114L);    </pre>
			<pre class="source-code">pr.setCheckNumber("GG31455");</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">// jOOQ render a WHERE clause based on the record PK</pre>
			<pre class="source-code">ctx.executeDelete(pr);</pre>
			<pre class="source-code">// jOOQ render our explicit Condition</pre>
			<pre class="source-code">ctx.executeDelete(pr, </pre>
			<pre class="source-code">   PAYMENT.INVOICE_AMOUNT.eq(BigDecimal.ZERO));</pre>
			<p>Exactly as in the case of <strong class="source-inline">UPDATE</strong>, if we attempt to perform <strong class="source-inline">DELETE</strong> without a <strong class="source-inline">WHERE</strong> clause, then jOOQ will inform us in a friendly way via a message. We can take control of what should happen in such cases via the <strong class="source-inline">withExecuteDeleteWithoutWhere()</strong> setting. </p>
			<p>In the bundled code, you can see <strong class="source-inline">withExecuteDeleteWithoutWhere()</strong> next to many other examples that have not<a id="_idIndexMarker471"/> been listed here. The complete application is named <em class="italic">DeleteSamples</em>. Next, let's talk about <strong class="source-inline">MERGE</strong> statements.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>Expressing MERGE statements</h1>
			<p>The <strong class="source-inline">MERGE</strong> statement is quite a<a id="_idIndexMarker472"/> powerful tool; it allows us to perform <strong class="source-inline">INSERT</strong>/<strong class="source-inline">UPDATE</strong> and even <strong class="source-inline">DELETE</strong> on a table known as the <em class="italic">target table</em> from a table known as the <em class="italic">source table</em>. I strongly suggest you read this article, especially if you need a quick reminder of the <strong class="source-inline">MERGE</strong> statement: <a href="https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/">https://blog.jooq.org/2020/04/10/the-many-flavours-of-the-arcane-sql-merge-statement/</a>.</p>
			<p>MySQL and PostgreSQL support a <strong class="source-inline">MERGE</strong> flavor known as <strong class="source-inline">UPSERT</strong> (<strong class="source-inline">INSERT</strong> or <strong class="source-inline">UPDATE</strong>) via <strong class="source-inline">ON DUPLICATE KEY UPDATE</strong>, respectively via <strong class="source-inline">ON CONFLICT DO UPDATE</strong> clauses. You can find examples of these statements next to the well-known <strong class="source-inline">INSERT IGNORE INTO</strong> (MySQL) and <strong class="source-inline">ON CONFLICT DO NOTHING</strong> (PostgreSQL) clauses in the code bundled with this book. By the way, we can use all these statements interchangeably (for example, we can use <strong class="source-inline">onConflictDoNothing()</strong> with MySQL and <strong class="source-inline">onDuplicateKeyIgnore()</strong> with PostgreSQL), since jOOQ will always emulate the correct syntax. We can even use them with SQL Server and Oracle, as jOOQ will emulate them via the <strong class="source-inline">MERGE INTO</strong> syntax.</p>
			<p>SQL Server and Oracle have support for <strong class="source-inline">MERGE INTO</strong> with different additional clauses. Here is an example of exploiting the <strong class="source-inline">WHEN MATCHED THEN UPDATE</strong> (jOOQ <strong class="source-inline">whenMatchedThenUpdate()</strong>) and <strong class="source-inline">WHEN NOT MATCHED THEN INSERT</strong> (jOOQ <strong class="source-inline">whenNotMatchedThenInsert()</strong>) clauses:</p>
			<pre class="source-code">ctx.mergeInto(PRODUCT)</pre>
			<pre class="source-code">   .usingDual() // or, (ctx.selectOne())</pre>
			<pre class="source-code">   .on(PRODUCT.PRODUCT_NAME.eq("1952 Alpine Renault 1300"))</pre>
			<pre class="source-code">   .whenMatchedThenUpdate()</pre>
			<pre class="source-code">   .set(PRODUCT.PRODUCT_NAME, "1952 Alpine Renault 1600")</pre>
			<pre class="source-code">   .whenNotMatchedThenInsert(</pre>
			<pre class="source-code">     PRODUCT.PRODUCT_NAME, PRODUCT.CODE)</pre>
			<pre class="source-code">   .values("1952 Alpine Renault 1600", 599302L)</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The rendered SQL for the SQL Server <a id="_idIndexMarker473"/>dialect is as follows:</p>
			<pre class="source-code">MERGE INTO [classicmodels].[dbo].[product] USING</pre>
			<pre class="source-code">  (SELECT 1 [one]) t ON  </pre>
			<pre class="source-code">    [classicmodels].[dbo].[product].[product_name] = ? </pre>
			<pre class="source-code">WHEN MATCHED THEN</pre>
			<pre class="source-code">  UPDATE</pre>
			<pre class="source-code">  SET [classicmodels].[dbo].[product].[product_name] = ? </pre>
			<pre class="source-code">WHEN NOT MATCHED THEN</pre>
			<pre class="source-code">  INSERT ([product_name], [code])</pre>
			<pre class="source-code">  VALUES (?, ?);</pre>
			<p>Now, let's look at another example using the <strong class="source-inline">WHEN MATCHED THEN DELETE</strong> (jOOQ <strong class="source-inline">whenMatchedThenDelete()</strong>) and <strong class="source-inline">WHEN NOT MATCHED THEN INSERT</strong> (jOOQ <strong class="source-inline">whenNotMatchedThenInsert()</strong>) clauses:</p>
			<pre class="source-code">ctx.mergeInto(SALE)</pre>
			<pre class="source-code">   .using(EMPLOYEE)   </pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .whenMatchedThenDelete()</pre>
			<pre class="source-code">   .whenNotMatchedThenInsert(SALE.EMPLOYEE_NUMBER,   </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR, SALE.SALE_,</pre>
			<pre class="source-code">      SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(EMPLOYEE.EMPLOYEE_NUMBER, val(2015),</pre>
			<pre class="source-code">      coalesce(val(-1.0).mul(EMPLOYEE.COMMISSION), val(0.0)), </pre>
			<pre class="source-code">      val(1), val(0.0))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>This works flawlessly in SQL Server, but it doesn't <a id="_idIndexMarker474"/>work in Oracle because Oracle doesn't support the <strong class="source-inline">WHEN MATCHED THEN DELETE</strong> clause. But, we can easily obtain the same result by combining <strong class="source-inline">WHEN MATCHED THEN UPDATE</strong> with <strong class="source-inline">DELETE WHERE</strong> (obtained via the jOOQ <strong class="source-inline">thenDelete()</strong>) clause. This works because, in Oracle, you can add a <strong class="source-inline">DELETE WHERE</strong> clause, but only together with an <strong class="source-inline">UPDATE</strong>:</p>
			<pre class="source-code">ctx.mergeInto(SALE)</pre>
			<pre class="source-code">   .using(EMPLOYEE)</pre>
			<pre class="source-code">   .on(EMPLOYEE.EMPLOYEE_NUMBER.eq(SALE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">// .whenMatchedThenDelete() - not supported by Oracle</pre>
			<pre class="source-code">   .whenMatchedAnd(selectOne().asField().eq(1))</pre>
			<pre class="source-code">   .thenDelete()</pre>
			<pre class="source-code">   .whenNotMatchedThenInsert(SALE.EMPLOYEE_NUMBER,  </pre>
			<pre class="source-code">      SALE.FISCAL_YEAR, SALE.SALE_,</pre>
			<pre class="source-code">      SALE.FISCAL_MONTH, SALE.REVENUE_GROWTH)</pre>
			<pre class="source-code">   .values(EMPLOYEE.EMPLOYEE_NUMBER, val(2015),</pre>
			<pre class="source-code">      coalesce(val(-1.0).mul(EMPLOYEE.COMMISSION), val(0.0)),  </pre>
			<pre class="source-code">      val(1), val(0.0))</pre>
			<pre class="source-code">   .execute();</pre>
			<p><strong class="source-inline">WHEN MATCHED THEN UPDATE</strong> is obtained via jOOQ's <strong class="source-inline">whenMatchedAnd()</strong>; this is the jOOQ implementation for the <strong class="source-inline">WHEN MATCHED AND &lt;some predicate&gt; THEN</strong> clause, but in this case, it is rendered as <strong class="source-inline">WHEN MATCHED THEN UPDATE</strong>.</p>
			<p>Using the <strong class="source-inline">DELETE WHERE</strong> clause in SQL Server and in Oracle works the same. An important aspect of using the <strong class="source-inline">DELETE WHERE</strong> clause consists of which table the <strong class="source-inline">DELETE WHERE</strong> clause references. This clause can target the rows before or after an update. The following <strong class="source-inline">MERGE</strong> example<a id="_idIndexMarker475"/> updates all the rows in the <em class="italic">target table</em> that have a matching row in the <em class="italic">source table</em>. The <strong class="source-inline">DELETE WHERE</strong> clause deletes only those rows that were matched by <strong class="source-inline">UPDATE</strong> (this is <strong class="source-inline">DELETE</strong> after <strong class="source-inline">UPDATE</strong>):</p>
			<pre class="source-code">ctx.mergeInto(SALE)</pre>
			<pre class="source-code">   .using(EMPLOYEE)</pre>
			<pre class="source-code">   .on(SALE.EMPLOYEE_NUMBER.eq(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .whenMatchedThenUpdate()</pre>
			<pre class="source-code">   .set(SALE.SALE_, coalesce(SALE.SALE_</pre>
			<pre class="source-code">        .minus(EMPLOYEE.COMMISSION), SALE.SALE_))</pre>
			<pre class="source-code">   .deleteWhere(SALE.SALE_.lt(1000.0))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>The following example shows that <strong class="source-inline">DELETE WHERE</strong> can match against values of the rows before <strong class="source-inline">UPDATE</strong> as well. This time, <strong class="source-inline">DELETE WHERE</strong> references the <em class="italic">source table</em>, so the status is checked against the source not against the result of <strong class="source-inline">UPDATE</strong> (this is <strong class="source-inline">DELETE</strong> before <strong class="source-inline">UPDATE</strong>):</p>
			<pre class="source-code">ctx.mergeInto(SALE)</pre>
			<pre class="source-code">   .using(EMPLOYEE)</pre>
			<pre class="source-code">   .on(SALE.EMPLOYEE_NUMBER.eq(EMPLOYEE.EMPLOYEE_NUMBER))</pre>
			<pre class="source-code">   .whenMatchedThenUpdate()</pre>
			<pre class="source-code">   .set(SALE.SALE_, coalesce(SALE.SALE_</pre>
			<pre class="source-code">       .minus(EMPLOYEE.COMMISSION), SALE.SALE_))</pre>
			<pre class="source-code">   .deleteWhere(EMPLOYEE.COMMISSION.lt(1000))</pre>
			<pre class="source-code">   .execute();</pre>
			<p>In the bundled code, you can practice<a id="_idIndexMarker476"/> more examples. The application is named <em class="italic">MergeSamples</em>.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Summary</h1>
			<p>This chapter is a comprehensive resource for examples of expressing popular <strong class="source-inline">SELECT</strong>, <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">MERGE</strong> statements in the jOOQ DSL syntax relying on the Java-based schema. </p>
			<p>For brevity, we couldn't list all the examples here, but I strongly recommend you take each application and practice the examples against your favorite database. The main goal is to get you familiar with the jOOQ syntax and to become capable of expressing any plain SQL via the jOOQ API in a productive amount of time.</p>
			<p>In the next chapter, we continue this adventure with a very exciting topic: expressing <strong class="source-inline">JOIN</strong> in jOOQ.</p>
		</div>
	</body></html>