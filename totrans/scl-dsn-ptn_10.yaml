- en: Functional Design Patterns – the Deep Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Scala programming language is a hybrid between a functional and object-oriented
    language. Most of the object-oriented design patterns are still applicable. However,
    in order to facilitate the full power of Scala, you also need to be aware of the
    purely functional aspects of it. When using the language and reading tutorials
    or best practices, developers will most likely notice terms such as **monoids**,
    **monads**, and **functors** appearing more often as the problems become harder
    or the solutions are desired to be more elegant. In this chapter, we will focus
    on the following functional design patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot of resources on the preceding topics all over the internet.
    The problem is that many of them are extremely theoretical and hard to understand
    by someone who is not really familiar with mathematics, and more specifically,
    category theory. As it happens, in practice, many developers lack the deep mathematical
    background needed to grasp the topics, and it is not unusual to completely avoid
    these concepts in the code.
  prefs: []
  type: TYPE_NORMAL
- en: In my experience, most of the Scala developers I know have tried to read tutorials
    on the topics covered in this chapter, and they've found these topics difficult
    to understand and have given up. Expert mathematicians seem to find these concepts
    much easier. However, despite repeated attempts at understanding, most people
    admit that they are not completely comfortable with the deep functional programming
    theory. In this chapter, we will try and present this theory in a way that is
    easy to understand, and we will give an idea of how and when to apply the theory.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction and vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big part of programming is abstraction. We find common functionality, laws,
    and behavior and encapsulate them into classes, interfaces, functions, and so
    on, which are abstract and allow code reuse. Then, we refer to them and reuse
    them to minimize code duplication and the possibility of errors. Some of these
    abstractions are more common than others and are observed in different projects
    and used by more people. These abstractions lead to the creation of a common vocabulary,
    which additionally helps in communication and understanding. Everybody knows certain
    data structures such as trees and hash maps, and so there is no need to get into
    detail about them because their behavior and requirements are well-known. Similarly,
    when someone gains enough experience in design patterns, they can see them and
    easily apply the patterns to the problems they are trying to tackle.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will try to look at monoids, monads, and functors from a
    point of view that will teach us how to recognize them and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All monoids, monads, and functors are derived from mathematics. One thing about
    this subject is that similarly to programming, it tries to find abstractions.
    If we try to map mathematics to programming, we can think about the different
    datatypes we have—`Int`, `Double`, `Long`, or custom datatypes. Each type can
    be characterized by the operations it supports and the laws of these operations,
    and this is called the *algebra* of the type.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we think about it, we can identify the operations that are shared by
    multiple types, for example, addition, multiplication, subtraction, and so on.
    Different types can share the same operations and they can conform to exactly
    the same laws. This is something we can take advantage of because this allows
    us to write generic programs that apply to different types that follow some specific
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: What are monoids?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the preceding brief introduction to monoids, let''s get straight to business
    and look at a formal definition of a *monoid*:'
  prefs: []
  type: TYPE_NORMAL
- en: A monoid is a purely algebraic structure, which means that it is defined only
    by its algebra. All monoids must conform to the so-called **monoid laws**.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding definition is definitely not enough to have a good understanding
    of monoids, so let's break it into pieces in this section and try to come up with
    a better one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s clarify the term **algebraic structure**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algebraic**: It is defined only by its algebra, for example, the operations
    it supports and the laws it conforms to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that monoids are defined only by the operations they support,
    let''s have a look at the monoid laws:'
  prefs: []
  type: TYPE_NORMAL
- en: A monoid contains a `T` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A monoid contains one associative binary operation. This means that for any
    `x`, `y`, and `z` of the `T` type, the following is true:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`op(op(x, y), z) == op(x, op(y, z))`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A structure must have an *identity element*—`zero`. This element is characterized
    by the fact that the previous operation will always return the other element—`op(x,
    zero) == x` and `op(zero, x) == x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other than the preceding laws, different monoids might not have absolutely
    anything to do with each other—they can have any type. Now let''s look at a better
    definition of a monoid that would actually mean more to you as a developer:'
  prefs: []
  type: TYPE_NORMAL
- en: A monoid is a type with an associative binary operation over it, which also
    has an identity element.
  prefs: []
  type: TYPE_NORMAL
- en: The monoid rules are extremely simple but they give us great power to write
    polymorphic functions based just on the fact that monoids always conform to the
    same rules. With the use of monoids, we can easily facilitate parallel computation
    and build complex calculations from small pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use monoids all the time without realizing it—string concatenation, sums
    of integers, products, Boolean operations, lists, and so on—they are all examples
    of monoids. Let''s look at integer addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Our type**: `Int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Our associative operation**: `add`. It is indeed associative because `((1
    + 2) + 3) == (1 + (2 + 3))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Our identity element**: `0`. It does nothing when added to another integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily come up with similar examples for string concatenation, where
    the identity element will be an empty string, or for list concatenation, where
    the identity element will be an empty list, and many others. Similar examples
    can be found absolutely everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything we mentioned previously takes us to the following Scala representation
    of a monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting from this base trait, we can define just about any monoid we want.
    The following are a few implementations of a integer addition monoid, integer
    multiplication monoid, and a string concatenation monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the same framework as shown previously, we can define monoids for as many
    different types as we can think of, as long as they always satisfy the rules.
    However, you should note that not every operation follows the monoid rules. For
    example, integer division—`(6/3)/2 != 6/(3/2)`.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to write monoids. But how do we use them? What are they helpful for
    and can we just write generic functions based only on the rules we know? Of course
    we can, and we will see this in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we already mentioned that monoids can be used for
    parallel computation and to build complex computations using small and simple
    chunks. Monoids can also be naturally used with lists and collections, in general.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we will look at different use cases with examples for monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids and foldable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show how useful monoids are with collections that support the `foldLeft`
    and `foldRight` functions, let''s take a look at the standard Scala list and the
    declarations of these two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, the `z` parameter in these two functions is called the `zero` value,
    so if `A` and `B` are of the same type, we will end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the functions now, we can see that these are exactly monoid rules.
    This means that we can write an example as shown in the following code, which
    uses the monoids we created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another thing to note in the preceding code is that it doesn't actually matter
    for the final result whether we use `foldLeft` or `foldRight` because our monoids
    have an associative operation. It does, however, matter in terms of performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding example is as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7686cb64-3b96-44cb-849d-1d0da21aad98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the preceding example, you can see that we can write a generic function
    that will fold a list using a monoid and do different things depending on the
    monoid operation. Here is the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now rewrite our example and use our generic function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output, of course, will be exactly the same. However, things are much neater
    now, and this is how monoids can become useful when used together with lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, we made the `A` and `B` types to be the same in
    the `foldLeft` and `foldRight` functions. However, we might build a different
    data structure with a different type, or our algorithm might rely on a different
    type that has a different monoid to the type of the list we have. In order to
    support such a scenario, we have to add the possibility of mapping the type of
    the original list to a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how our fold functions will change. This would give
    us the possibility of implementing even more complex operations on top of our
    lists using different types of monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids and parallel computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fact that a monoid operation is associative means that if we have to chain
    multiple operations, we could probably do it in parallel. For example, if we have
    the numbers `1`, `2`, `3`, and `4` and wanted to find `4!`, we can use what we
    used previously, which would end up being evaluated to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The associativity, however, would allow us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the nested operations could be done independently and in parallel. This
    is also called **balanced fold**. An implementation of a balanced fold would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that we've used an `IndexedSeq` here, as it will guarantee
    that getting elements by index will be efficient. Also, this code is not parallel,
    but we've switched the order of the operations as we mentioned previously. In
    the case of integers, it might not make much of a difference but for other types
    such as strings, it will improve the performance. The reason is that strings are
    immutable and every concatenation will create a new string by allocating new space.
    So, if we are simply going from the left-hand side to the right-hand side, we
    will be allocating more and more space and throwing away the intermediate results
    all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code listing shows how to use our `balancedFold` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5334da2c-125d-4bd3-a363-e82e973f12a4.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a few ways to make this code parallel. The hard way would involve
    quite a lot of extra code writing in order to manage threads, and it is really
    advanced. It probably deserves a chapter (if not an entire book) of its own, and
    we will just mention it for the more curious readers—*purely functional parallelism*.
    There are some materials on GitHub ([https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism](https://github.com/fpinscala/fpinscala/wiki/Chapter-7:-Purely-functional-parallelism))
    that cover this concept nicely with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `par` method that most Scala collections have. Due to the
    laws that monoids conform to, we are guaranteed to always get the correct results,
    no matter how the underlying collections are parallelized. The following listing
    shows example implementations of our fold methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between these methods and what we had before is the call
    to `par` before we use `foldLeft`. Using the methods is exactly the same as we
    did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, the result here would be exactly the same as it was for
    the sequential example.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen some examples where monoids are used to improve efficiency
    and write generic functions. They, however, are even more powerful. The reason
    is that they follow another useful rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Monoids support *composition*; if `A` and `B` are monoids, then their product
    `(A, B)` is also a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does this mean exactly and how can we take advantage of this? Let''s look
    at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we showed a function that applies the composition exactly
    as we mentioned in our definition. This would now allow us to simultaneously apply
    multiple operations using a monoid, and we can compose even more and apply even
    more operations. Let''s see an example that will calculate the sum and the factorial
    of the numbers given to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we took advantage of the `map` function as well because
    our new monoid expects a tuple of integers rather than just the single integers
    we have in our array. Running the example will yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e95b3b7-ec3c-4c42-989c-5ca1612402d5.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding `compose` function is really powerful, and we can do a lot of
    things with it. We can also efficiently calculate the mean of all items in a list—we
    just need to use the `intAddition` monoid twice and map the numbers to `(number,
    1)` in order to have the count together with the sum.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen how to compose monoids with operations. However, monoids
    are quite useful for building data structures as well. Data structures can also
    form monoids as long as their values also form monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through an example. In machine learning, we might need to extract the
    features from some text. Then, each feature will be weighted using a coefficient
    and a number equal to the number of times we've seen it. Let's try and get to
    a monoid that can be used to fold a collection and give us what we need—the count
    of each feature.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it is clear that we will be counting how many times we see each
    feature. Building a map of features to be counted sounds like a good idea! We
    will be incrementing the count for a feature every time we see it. So, if we imagine
    that each element in our feature list becomes a map of one element, we will have
    to fold these maps and use our integer sum monoid to sum the values for the same
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a function that can return a monoid, which can be used to fold
    items into a map and will apply any monoid to the values of the same key of the
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this monoid to do different aggregations—sums, multiplications,
    concatenations, and so on. For our features counting, we will have to use sums
    and here is how we''ve done it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ebe6ad-1973-4819-956a-5c689477ea5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `mapMerge` function that we defined previously can now take any monoid,
    and we can even easily create maps of maps and so on, without extra code writing.
  prefs: []
  type: TYPE_NORMAL
- en: When to use monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding examples, we showed how to use monoids in order to achieve
    certain things. However, if we look at the previous example, we could simplify
    it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In fact, each example could be rewritten to a representation similar to the
    preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: While someone might be tempted to do things this way, it might not always be
    scalable. As we already mentioned, the purpose of monoids is to actually allow
    us to write generic and reusable code. With the help of monoids, we can focus
    on simple operations and then just compose them together rather than build concrete
    implementations for everything we want. It might not be worth it for one-off functions,
    but using monoids would definitely have a positive effect when we are reusing
    functionality. Moreover, as you already saw, composition here is extremely easy,
    and with time it will save us from writing a huge amount of code (read less code
    duplication and possibilities to introduce bugs).
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **functor** is one of those terms that comes from category theory in mathematics
    and causes a lot of pain to developers who come into functional programming and
    have less of a mathematical background. It is a requirement for monads, and here
    we will try to explain it in a way that will be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: What is a functor? In the preceding section, we looked at monoids as a way to
    abstract some computation and then used them in different ways for optimization
    or to create more complex computations. Even though some people might not agree
    with the correctness of this approach, let's look at functors from the same point
    of view—something that will abstract some specific computations.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, a functor is a class that has a  `map` method and conforms to a few
    laws. Let's call them **functor laws**.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` method for a functor of the `F[T]` type takes a function from `T`
    to `Y` as a parameter and returns a `F[Y]` as a result. This will become much
    clearer in the next subsection, where we will show some actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functors also obey some functor laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: Whenever the `identity` function is mapped over some data, it
    doesn''t change it, in other words, `map(x)(i => i) == x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: Multiple maps must compose together. It should make no difference
    if we do this operation: `map(map(x)(i => y(i)))(i => z(i))` or `map(x)(i => z(y(i)))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `map` function preserves the structure of the data, for example, it does
    not add or remove elements, change their order, and so on. It just changes the
    representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding laws give developers some grounds to assume certain things when
    performing different computations. For example, we can now safely postpone different
    mappings of data in time or just do them all together, and be sure that the final
    result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: From what we mentioned previously, we can actually come up with the conclusion
    that functors set a specific set of laws on their operations (`map`, in this case)
    that must be in place and allow us to automatically reason about their results
    and effects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a definition for functors and we showed the laws they should
    follow, in the next subsection we can create a base trait that all functors will
    be able to extend.
  prefs: []
  type: TYPE_NORMAL
- en: Functors in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we show an example functor trait based on the laws we showed in the preceding
    section, you can conclude that standard Scala types such as `List`, `Option`,
    and others that define a `map` method are functors.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` method in the built-in Scala types such as `List` has a different
    signature from the example we show here. In our examples, the first parameter
    is the functor and the second one is the transformation function we apply to it.
    In the standard Scala types, the first parameter doesn't need to be passed, as
    it is the actual object we're calling it on (`this`).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create our own types that follow the functor laws, we can create
    a base trait and make sure to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a list functor that will simply call the `map` function
    of the Scala `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the fact that an object is a functor simply allows us
    to assume that certain laws are in place.
  prefs: []
  type: TYPE_NORMAL
- en: Using our functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple example of using our `listFunctor` that we defined in the preceding
    section can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fcaad83-9593-40b8-bebd-d780b83c09f3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, functors don't really do much by themselves. They are not exciting
    at all. However, they set some specific rules that help us understand the results
    from specific operations. This means that we can define methods based on the abstract
    `map` inside the `Functor` trait, which rely on the rules we've stated previously.
  prefs: []
  type: TYPE_NORMAL
- en: Functors are an important concept that are required for monads, which we will
    look at in the following subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we defined functors. With their `map` methods, the
    standard Scala collections seem to be good examples of functors. We should, however,
    emphasize again that a functor doesn't mean a collection—it can be a container
    and any custom-defined class. Based on an abstract `map` method and the rules
    it follows, we can define other functions that will help us reduce code duplication.
    However, there are not many exciting things we can do based on a mapping only.
    In our programs, we will have different operations, some of which not only transform
    a collection or an object, but also modify it in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Monads are another one of those scary terms that come from category theory,
    which we will try to explain in a way that you will be able to easily understand,
    identify, and use in your daily routine as a developer.
  prefs: []
  type: TYPE_NORMAL
- en: What is a monad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already talked about laws earlier in this chapter. The monoid is defined
    based on some laws it follows, and these laws allow us to implement generic functionality
    with certainty, just because we expect certain conditions to hold. If a law is
    broken, then there is no way for us to know for sure what to expect in terms of
    how something will behave. In such cases, things would most probably end up returning
    wrong results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the other concepts we already saw in this chapter, monads are defined
    in terms of the laws they follow. In order for a structure to be considered a
    monad, it must satisfy all the rules. Let''s start with a short definition, which
    we will expand on later:'
  prefs: []
  type: TYPE_NORMAL
- en: Monads are functors that have the `unit` and `flatMap` methods and follow the
    **monad rules**.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does the preceding definition mean? First of all, it means that monads
    follow all the rules we previously defined about functors. Additionally, they
    take things further and add support for two more methods.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we formally define the rules, let''s have a brief discussion about `flatMap`.
    We assume that you are familiar with Scala collections and are aware of the existence
    of the `flatten` method. So, just the name of `flatMap` tells us that it maps
    and then flattens, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have the monad definition we referred to in the preceding code yet,
    but that''s fine. We will get there. For now, let''s just look at it as another
    generic parameter. You should also know that `flatten` has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For example, if `F` is actually a `List`, `flatten` will convert a list of lists
    into a simple list of whatever the type of the internal one is. If `F` is an `Option`,
    then the ones with the `None` value in the nested option will disappear and the
    rest will remain. These two examples show us that the `flatten` result actually
    depends on the specifics of the type being flattened, but in any case, it is clear
    how it transforms our data.
  prefs: []
  type: TYPE_NORMAL
- en: The unit method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other method we mentioned previously is `unit`. It actually doesn''t matter
    how this method is called and it could be different for different languages based
    on their standards. What is important is its functionality. The signature of `unit`
    can be written in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the preceding line mean? It is pretty simple—it takes a value of
    the `T` type and turns it into a monad of the `T` type. This is nothing more than
    a single argument constructor or just a factory method. In Scala, this can be
    expressed using a companion object with an `apply` method as well. As long as
    it does the right thing, the implementation doesn''t really matter. In Scala,
    we have many of the collection types as examples—`List`, `Array`, `Seq`—they all
    have an `apply` method that supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The connection between map, flatMap, and unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we showed how `flatMap` can be defined using `map`
    and `flatten`. We can, however, take a different approach and define `map` using
    `flatMap`. Here is what the definition would look like in our pseudo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding definition is important because it draws the relationship between
    all the `map`, `flatMap`, and `unit` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what kind of monads we implement, it could sometimes be easier
    to implement `map` first (usually, if we build collection-like monads) and then
    `flatMap` based on it and `flatten`, while other times it could be easier to first
    implement
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap` instead. As long as the monad laws are satisfied, it shouldn''t matter
    which approach we take.'
  prefs: []
  type: TYPE_NORMAL
- en: The names of the methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding section, we mentioned that it doesn''t actually matter how
    the `unit` method is called. While it is true for `unit` and it could be propagated
    to any of the other methods, it is recommended that `map` and `flatMap` actually
    remain this way. It doesn''t mean that it is not possible to make things work,
    but following common conventions would make things much simpler. Moreover, `map`
    and `flatMap` give us something extra—the possibility of using our classes in
    *for comprehensions*. Consider the following example, which is only here to illustrate
    how having methods with such names helps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we just wrap a list in an object and define the `map`
    and `flatMap` methods. If we didn''t have the preceding object, we could have
    written something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With our wrapper object, we could do the same as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Both applications do the same and will have exactly the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4083777-2904-4438-b4d5-495ac7548c79.png)'
  prefs: []
  type: TYPE_IMG
- en: What the second application uses, however, is the fact that our wrapper class
    contains methods specifically with the names such as `map` and `flatMap`. If we
    rename any of them, we would get a compilation error—we could still manage to
    write the same code but it will not be able to use syntactic sugar in Scala. Another
    point here is that the *for comprehension* would work correctly in the case where
    both the methods actually follow the rules for `map` and `flatMap`.
  prefs: []
  type: TYPE_NORMAL
- en: The monad laws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going a bit through the methods a monad is supposed to support, now we
    can formally define the monad laws. You already saw that monads are functors and
    they follow the functor laws. Being explicit is always better, so here we will
    mix the laws together:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity law**: Doing `map` over the identity function doesn''t change the
    data—`map(x)(i => i) == x`. Flat mapping over the `unit` function also keeps the
    data the same—`x.flatMap(i => unit(i)) == x`. The latter basically says that `flatMap`
    undoes `unit`. Using the connection between `map`, `flatMap`, and `unit` we defined
    earlier, we can derive one of these two rules from the other and vice versa. The
    `unit` method can be thought of as the zero element in monoids.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The unit law**: From the definition of `unit`, we can also say this: `unit(x).flatMap
    { y => f(y) } == f(x)`. From this, we will get `unit(x).map { y => f(x) } == unit(f(x))`.
    This gives us some interesting connections between all the methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition**: Multiple maps must be composed together. It should make no
    difference if we do `x.map(i => y(i)).map(i => z(i))` or `x.map(i => z(y(i)))`.
    Moreover, multiple `flatMap` calls must also compose, making the following true:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x.flatMap(i => y(i)).flatMap(i => z(i)) == x.flatMap(i => y(i).flatMap(j =>
    z(j)))`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Monads, similarly to monoids, also have a zero element. Some real-world examples
    of monadic zeros are `Nil` in the Scala List and the `None` option. However, here
    we can also have multiple zero elements, which are represented by an algebraic
    datatype with a constructor parameter to which we can pass different values. In
    order to be complete, we might not have zeros at all if there is no such concept
    for the monads we are modeling. In any case, the zero monad represents some kind
    of emptiness and follows some extra laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zero identity**: This one is pretty straightforward. It says that no matter
    what function we apply to a zero monad, it is still going to be zero—`zero.flatMap(i
    => f(i)) == zero` and `zero.map(i => f(i)) == zero`. `Zero` shouldn''t be confused
    with `unit`, as they are different and the latter doesn''t represent emptiness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse zero**: This is straightforward as well. Basically, if we replace
    everything with zero, our final result will also be zero—`x.flatMap(i => zero)
    == zero`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commutativity** : Monads can have a concept of addition, whether it is concatenation
    or something else. In any case, this kind of operation when done with the zero
    monad will be commutative, for example, `x plus zero == zero plus x == x`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monads and side effects
  prefs: []
  type: TYPE_NORMAL
- en: 'When presenting the composition law, we kind of assumed that an operation has
    no side effects. We said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x.map(i => y(i)).map(i => z(i)) == x.map(i => z(y(i)))`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, let's now think about what would happen if `y` or `z` cause some side
    effects. On the left-hand side, we first run all `y`s and then all `z`s. On the
    right-hand side, however, we interleave them, doing `y` and `z` all the time.
    Now, if an operation causes a side effect, it would mean that the two might end
    up producing different results. That's why developers should prefer using the
    left-hand side version, especially when there might be side effects such as IO.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the monad laws. For those who have more experience with Scala,
    monads might seem pretty close to the collection classes, and the rules we defined
    previously might seem logical. However, we are pointing out once more that it
    is not necessary for a monad to be a collection, and it is important that these
    rules are followed in order to be able to call an algebraic data structure a monad.
  prefs: []
  type: TYPE_NORMAL
- en: Monads in real life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through a lot of theory about monads, it would now be useful to
    go through some code that demonstrates how to implement and use the theoretical
    concepts, which real-world situations they are good for, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now do something similar to what we did before, and show what a monad
    trait will look like in Scala. Before doing this, however, let''s slightly change
    our functor definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, instead of passing the element that will be mapped,
    we assume that the type that mixes `Functor` will have a way to pass it to the
    `map` implementation. We also changed the return type so that we can chain multiple
    functors using `map`. After we''ve done this, we can show our `Monad` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code follows a convention similar to what we used for monoids.
    The methods the monad has are exactly the same as we have already mentioned earlier
    in the theoretical part of this chapter. The signatures might be slightly different,
    but mapping them to the theoretical code, which was made to be understood easily,
    shouldn't cause any issues.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the monads extend functors. Now, whenever we want to write monads,
    we just need to extend the preceding trait and implement the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply having a monad trait puts us in a framework that we can follow. We already
    went through the theory of monads and the laws that they follow. However, in order
    to understand how monads work and what they are useful for, looking at an actual
    example is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: However, how are we supposed to even use monads if we don't know what their
    purpose is? Let's call them computation builders, as this is exactly what they
    are used for. This gives the ordinary developer much more understanding about
    when and where to use monad's computation builder chain operations in some way,
    which are then performed.
  prefs: []
  type: TYPE_NORMAL
- en: The Option monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already mentioned a few times that the standard Scala `Option` is a
    monad. In this subsection, we will provide our own monadical implementation of
    this standard class and show one of the many possible uses of monads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to show how useful the option is, we will see what happens if we don''t
    have it. Let''s imagine that we have the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test, we have added a `Boolean` flag that will or will not fail
    to get the required objects. In reality, this could be some complicated function
    that, depending on parameters or something else, could return `null` in some specific
    cases. The following piece of code shows how the preceding classes should be used
    in order to be completely protected from failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `compute` method in the `NoMonadExample` object looks really bad and hard
    to read. We shouldn't write code like that.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at what's happening in the preceding code, we can see that we are actually
    trying to build a chain of operations, which can individually fail. Monads can
    help us and abstract this protective logic. Now, let's show a much better solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s define our own `Option` monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two concrete cases in the preceding code—one where we can get a value
    and other where the result will be empty. Now, let''s rewrite our computation
    classes so that they use the new monad we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use them in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've shown a *for comprehension* usage of our monad,
    but the part that is commented out is also valid. The first one is preferred because
    it makes things look really simple, and some completely different computations
    end up looking the same, which is good for understanding and changing code.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, everything we showed in our example can be implemented using the
    standard Scala `Option`. It is almost certain that you have already seen and used
    this class before, which means that you have actually used monads before, maybe
    without realizing this was the case.
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced monad example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example was pretty simple, and it showed a great use of monads.
    We made our code much more straightforward, and we abstracted some logic inside
    the monads. Also, our code became much more readable than it was before.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this subsection, let''s see another use of monads, which is much more advanced
    this time. All the software we write becomes much more challenging and interesting
    whenever we add I/O to it. This can be reading and writing data to and from files,
    communicating with a user, making web requests, and so on. Monads can be used
    in order to write I/O applications in a purely functional way. There is a really
    important feature here: I/O has to deal with side effects, operations are usually
    performed in a sequence, and the result depends on a state. This state can be
    anything—if we ask the user what cars they like, the response would vary depending
    on the user, and if we ask them what they ate for breakfast, or what the weather
    is like, the responses to these question will also depend on the user. Even if
    we try and read the same file twice, there might be differences—we might fail,
    the file could be changed, and so on. Everything we have described so far is a
    state. Monads help us hide this state from the user and just expose the important
    parts as well as abstract the way we deal with errors, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few important aspects about the state we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: The state changes between different I/O operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state is only one and we can't just create a new one whenever we want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any moment in time, there can be only one state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the previous statements are quite logical, but they will actually guide
    the way we implement our state and our monads.
  prefs: []
  type: TYPE_NORMAL
- en: We will write an example, which will read the lines from a file and then go
    through them and write them in a new file with all the letters capitalized. This
    can be written in a really easy and straightforward way with Scala, but as soon
    as some of the operations become more complex or we try to handle errors properly,
    it can become pretty difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the example, we will try to show what steps we have taken in order
    to make sure the previous statements about our state are correct.
  prefs: []
  type: TYPE_NORMAL
- en: The  following example we will show doesn't really need to use state. It just
    performs a file read and write in a monadic manner. The reader should have enough
    knowledge by now to take the state out of the code, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: We've decided to show a very simple usage of state, where we just increment
    a number. This can give the reader an idea of how a state can be used and wired
    up in applications that might actually need it. Additionally, the use of state
    can actually modify the behavior of our program and trigger different actions
    depending on it—for example, a vending machine and a user trying to request something
    that is out of stock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the state. For the current example, we don''t really need
    a special state, but we have used one anyway. It is just to show how to handle
    cases when one is actually needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding trait has a `next` method, which will return the next state when
    we move between different operations. Just by calling it when we pass a state,
    we make sure that different operations cause a change in state.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make sure that our application has only one state and that nobody
    can create a state whenever they want. The fact that the trait is sealed helps
    us to make sure nobody can extend our state outside the file, where we have defined
    it. Being sealed is not enough, though. We need to make sure all the implementations
    of the state are hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines the state as a private class, and this means that
    nobody else will be able to create one. Let's ignore the other methods for now,
    as we will come back to them later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third rule we defined for our state earlier is much trickier to achieve.
    We have taken multiple steps in order to make sure the state behaves correctly.
    First of all, as can be seen from the previous listing, there is no clue of a
    state that the user can get to, except the private class that nobody can instantiate.
    Instead of loading the user with the burden of executing a task and passing a
    state, we only expose an `IOAction` to them, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s focus only on the `IOAction` signature. It extends a function
    from an old state to a tuple of the new state and the result of the operation.
    So, it turns out that we are still exposing the state to our users in a way—it
    is just in the form of a class. However, we already saw that it is pretty straightforward
    to hide a state by creating a private class that nobody can instantiate. Our users
    will be working with the `IOAction` class, so we need to make sure they don''t
    have to deal with states themselves. We have already defined the `IOAction` to
    be sealed. Additionally, we can create a factory object, which will help us create
    new instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite important in terms of how things will get wired
    up later. First of all, we have a private implementation of `IOAction`. It only
    takes a by-name parameter, which means that it will only be evaluated when the
    `apply` method is called—this is really important. Moreover, in the preceding
    code, we have an `apply` method for the `IOAction` object, which allows the users
    to instantiate actions. Again, here the value is passed by name.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code, basically, enables us to define actions and only execute
    them whenever we have a state available.
  prefs: []
  type: TYPE_NORMAL
- en: If we now have a think, you can see that we've managed to satisfy all three
    requirements for our state. Indeed, by hiding the state behind a class, whose
    instance creations are controlled by us, we have managed to protect the state
    so that we don't have more than one at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have everything in place, we can make sure our `IOAction` is a
    monad. It will need to satisfy the monad laws and define the required methods.
    We''ve already shown them, but let''s have a closer look at the methods again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We haven't specifically extended our `Monad` trait, but instead we have just
    defined the methods here. We already know that `map` can be defined using `flatMap`
    and `unit`. For the latter, we have used the factory method for the `SimpleAction`.
    Our implementation of the former is quite interesting—it performs the current
    operation first and then sequentially after that, based on the resulting state,
    the second operation. This allows us to chain multiple I/O operations together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our `IOAction` class again. Does it satisfy the monad rules?
    The answer is no, but there is a really easy fix. The problem is that our `unit`
    method, if we look into it, would change the state because it uses a `SimpleAction`.
    But it shouldn''t. What we have to do is create another `IOAction` implementation
    that doesn''t change the state, and we use it for `unit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our `IOAction` object will get an extra function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also have to change the unit method in the `IOAction` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have defined our monad, made sure the state is handled properly,
    and that the actions can be created by a user in a controlled manner. What we
    need to do now is just add some useful methods and try them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is the code of a package object that reads and writes files and
    returns instances of `IOAction` (in the current case, `SimpleAction` is created
    using the `IOAction` `apply` method). Now that we have these methods and our monad,
    we can use the framework we have defined and wire everything up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a framework that the users of our library will follow;
    they will have to extend `FileIO`, implement `runIO`, and call the `run` method
    whenever they are ready to use our application. By now, you should be familiar
    enough with monads and see that the only thing the highlighted code will do is
    *build a computation*. It can be thought of as a graph of operations that have
    to be performed. It will not execute anything until the next line, where it actually
    gets the state passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows an example usage of the `FileIO` library that we created.
    We can now run it with the following input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The command that we need to use is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76ddb10f-b600-4719-b4a2-3942a6fbf7f2.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the output file will contain the same text with all uppercase letters.
    You can, of course, try with different inputs and see how the code performs.
  prefs: []
  type: TYPE_NORMAL
- en: Monad intuition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we went through some theory and real-world examples with monads.
    Hopefully, we have managed to give an easy to understand explanation of what is
    what, and how and why it works. Monads are not as scary as they initially seem
    to be and some time spent with them would give an even better understanding of
    how and why things work in a certain way.
  prefs: []
  type: TYPE_NORMAL
- en: The last example could seem pretty complicated, but some extra time spent with
    it using an IDE will make it clear and easy for you to realize how exactly everything
    gets wired up. Then, you will be able to easily spot and use monads on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a developer can probably get away without monads, but using them
    can help with hiding details about exception handling, specific operations, and
    so on. Monads are actually good because of the extra work that happens inside
    them, and they can be used to implement some of the design patterns we saw earlier
    in this book. We can implement better states, rollbacks, and many, many more.
    It is also worth mentioning that it is likely that many times we use monads without
    even realizing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to some of the functional programming theories that
    seem to put many people off pure functional programming. Because the majority
    of explanations require a strong mathematical background, we see people avoiding
    the concepts covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about monoids, monads, and functors, and we showed some examples of
    how to use them and the difference between having and not having them. It turns
    out that we use these concepts more often than we think, but we just don't realize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that monoids, functors, and monads can be used for a variety of purposes—performance
    optimization, abstraction, and removal of code duplication. Properly understanding
    these concepts and feeling comfortable with them might take some time initially,
    but after some practice, developers tend to get a much better understanding and
    use them much more often than before. Hopefully, this chapter has made monoids,
    monads, and functors look much simpler than you may have thought and you will
    make them a part of the production code more often.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover some functional programming design patterns
    that are specific to Scala, due to its expressiveness. Some of them will be new
    and previously unseen, while others we have already met, but we will look at 
    from a different perspective.
  prefs: []
  type: TYPE_NORMAL
