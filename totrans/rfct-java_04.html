<html><head></head><body>
<div id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-90"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-91"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.2.1">Testing</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When we talk about refactoring, as we have already mentioned, we essentially mean rewriting the code in a better way (where “better” can have various meanings) without changing its behavior. </span><span class="koboSpan" id="kobo.3.2">This last point is crucial, and we have not yet delved deep enough into it. </span><span class="koboSpan" id="kobo.3.3">To ensure that the behavior does not change and, in general, to approach every refactoring with a high level of confidence, it is necessary to be covered by an adequate set </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">of tests.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">It may sound obvious, but a test is nothing more than a way to verify the functionality of certain software (whether it is a piece of code, a module, or an entire architecture) against a set of requirements. </span><span class="koboSpan" id="kobo.5.2">In practice, we’re saying: “</span><em class="italic"><span class="koboSpan" id="kobo.6.1">Check that my code, given a certain input X, produces a certain output Y</span></em><span class="koboSpan" id="kobo.7.1">.” </span><span class="koboSpan" id="kobo.7.2">It can be much more complex than that, but for now, let’s settle with </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this explanation.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">There can be various types of tests, as well as different approaches to writing them, as we will see during the course of this chapter. </span><span class="koboSpan" id="kobo.9.2">But before discussing the “how,” we will look at why testing is essential, especially when it comes to refactoring. </span><span class="koboSpan" id="kobo.9.3">Within the context of refactoring, I would say testing is a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">fundamental condition.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Fortunately, there are methodologies</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.12.1"> and tools that can assist us, such as the famous </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">JUnit framework</span></strong><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">In terms of methodologies, it is certainly worth mentioning </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">Test-Driven Development</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.17.1">TDD</span></strong><span class="koboSpan" id="kobo.18.1">), which </span><em class="italic"><span class="koboSpan" id="kobo.19.1">serves</span></em><span class="koboSpan" id="kobo.20.1"> refactoring and simultaneously </span><em class="italic"><span class="koboSpan" id="kobo.21.1">uses</span></em><span class="koboSpan" id="kobo.22.1"> refactoring – you will see what I mean</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.23.1"> by this somewhat cryptic statement. </span><span class="koboSpan" id="kobo.23.2">But to be truly safe, it is also necessary to ensure that most of the implemented functionalities have been rigorously tested; also, for this, we have tools that can save us quite a bit </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">of headaches.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.27.1">Why you should test, and why you should do </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">it often</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.29.1">Unit testing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.30.1">Integration testing</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Contract testing</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Be safe – checking and improving your </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">test coverage</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.34.1">Test-driven development</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.35.1">Before anything else, however, as a famous book by Simon Sinek suggests, let’s start </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">with “why.”</span></span></p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.37.1">Why you should test (often)</span></h1>
<p><span class="koboSpan" id="kobo.38.1">As already mentioned, testing</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.39.1"> is a fundamental part of the work of a software engineer. </span><span class="koboSpan" id="kobo.39.2">It is a statement that we can all agree on – I would say it is almost intuitive – but let’s try to dig a little deeper and truly understand why it is essential to test our code (and our code interacting with other code and systems). </span><span class="koboSpan" id="kobo.39.3">The reasons I am about to present are not necessarily listed in order of importance, and they may not be the only ones. </span><span class="koboSpan" id="kobo.39.4">I am sharing what, in my experience, has </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">been significant.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.41.1">Identifying and fixing defects</span></h2>
<p><span class="koboSpan" id="kobo.42.1">Let’s start with the most obvious</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.43.1"> motivation. </span><span class="koboSpan" id="kobo.43.2">Testing your software allows</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.44.1"> you to identify defects (bugs), errors, and faults. </span><span class="koboSpan" id="kobo.44.2">In this regard, we have included an article in the </span><em class="italic"><span class="koboSpan" id="kobo.45.1">Further reading</span></em><span class="koboSpan" id="kobo.46.1"> section that explains the differences between these terms, which are often used interchangeably. </span><span class="koboSpan" id="kobo.46.2">These issues can manifest in various forms, such as functional flaws, performance bottlenecks, security vulnerabilities, or usability problems. </span><span class="koboSpan" id="kobo.46.3">When left unresolved, these problems can have severe consequences, leading to system failures, data breaches, dissatisfied users, and </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">costly rework.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">By conducting comprehensive testing throughout the development cycle, developers can detect and address these issues early on. </span><span class="koboSpan" id="kobo.48.2">This proactive approach to testing allows them to pinpoint and rectify potential problems before they escalate into more significant issues, thereby minimizing the risk of critical defects in the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">final product.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">One of the primary benefits of early bug identification and resolution is the prevention of downstream complications. </span><span class="koboSpan" id="kobo.50.2">As the development progresses, the complexity of the software typically increases, making it more challenging to identify and fix defects. </span><span class="koboSpan" id="kobo.50.3">Bugs that go unnoticed in the initial stages can compound as new features are added, resulting in a cascade of interconnected problems that are difficult and time-consuming </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">to resolve.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Moreover, addressing bugs at later stages of development – or, worse, after the software is released – can significantly impact the project’s timeline and budget. </span><span class="koboSpan" id="kobo.52.2">The cost of fixing defects in the production phase is usually much higher than resolving them during the development phase. </span><span class="koboSpan" id="kobo.52.3">Additionally, urgent bug fixes might necessitate disrupting regular development activities, leading to delays in delivering new features or updates (I can already see you nodding </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">and sighing).</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">In brief, the more you test and the earlier you do so (that is, test small chunks of software while you’re writing it – we’ll see in a moment how we can be helped in such an activity), the better it is. </span><span class="koboSpan" id="kobo.54.2">Thinking a bit more laterally, anticipating potential issues brings both financial benefits (cost-effectiveness) and risk mitigation, especially in the case of software where even</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.55.1"> small defects can lead to significant</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.56.1"> damages (consider, for example, sectors such as healthcare, finance, or the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">aerospace industry).</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.58.1">Ensuring quality and reliability</span></h2>
<p><span class="koboSpan" id="kobo.59.1">Testing is a critical aspect</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.60.1"> of the software development process that goes beyond simply</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.61.1"> identifying bugs and defects. </span><span class="koboSpan" id="kobo.61.2">It involves a systematic and comprehensive examination of the software to ensure that it meets the required quality standards and performs as expected. </span><span class="koboSpan" id="kobo.61.3">This process is essential to deliver a reliable, stable, and high-quality product that meets the needs and expectations of </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">its users.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">When software undergoes thorough</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.64.1"> testing, it is placed under rigorous scrutiny across various dimensions. </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">Functional testing</span></strong><span class="koboSpan" id="kobo.66.1"> verifies that the software’s features and functionalities behave correctly and in accordance with the specified requirements. </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Non-functional testing</span></strong><span class="koboSpan" id="kobo.68.1">, on the other hand, evaluates aspects such as performance, security, usability, and compatibility</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.69.1"> to ensure that the software meets the expected levels in </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">these areas.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">By subjecting the software to a suite of tests, developers can have confidence that the application will operate smoothly under normal conditions and handle challenging scenarios without unexpected crashes or malfunctions. </span><span class="koboSpan" id="kobo.71.2">This is especially crucial in mission-critical systems where any unforeseen issues could have </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">severe consequences.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">When talking about quality and reliability, it is worth defining some terms that I often hear being used – and I sometimes use myself – incorrectly. </span><span class="koboSpan" id="kobo.73.2">Let’s define what performance tests, load tests, and stress </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">tests are:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.75.1">Performance tests</span></strong><span class="koboSpan" id="kobo.76.1">: These are tests designed to assess</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.77.1"> the speed, responsiveness, and overall efficiency of a system or software under specific conditions. </span><span class="koboSpan" id="kobo.77.2">They aim to evaluate how well the system performs in </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">normal situations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Load tests</span></strong><span class="koboSpan" id="kobo.80.1">: Load tests are conducted to evaluate</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.81.1"> how well a system can handle a specific amount of load or user activity. </span><span class="koboSpan" id="kobo.81.2">The objective is to determine the system’s capacity and identify any performance bottlenecks under anticipated loads. </span><span class="koboSpan" id="kobo.81.3">They are a subset of </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">performance tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.83.1">Stress tests</span></strong><span class="koboSpan" id="kobo.84.1">: Stress tests involve pushing the system</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.85.1"> or software beyond its normal operating limits. </span><span class="koboSpan" id="kobo.85.2">The purpose is to check how the system behaves under extreme conditions, such as high user traffic, excessive data volumes, or limited resources. </span><span class="koboSpan" id="kobo.85.3">The goal is to identify potential weaknesses or failures in the system’s stability and resilience. </span><span class="koboSpan" id="kobo.85.4">Stress tests are also used for sizing environments (e.g., you need to set up a new tier, and you know in advance how many resources you will need) or simply to know what the limit is, so you know in advance if and when </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">to scale.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.87.1">There is a very common</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.88.1"> tool, used for performance</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.89.1"> testing, which you probably know, called </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">JMeter</span></strong><span class="koboSpan" id="kobo.91.1">. </span><span class="koboSpan" id="kobo.91.2">We’re mentioning it just because</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.92.1"> it’s one of the most famous, but it’s not necessarily the best – it heavily depends on your needs. </span><span class="koboSpan" id="kobo.92.2">It’s likely very widespread because it is open source and free to use and there is a lot of knowledge and documentation around it. </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Apache JMeter</span></strong><span class="koboSpan" id="kobo.94.1"> is a Java application explicitly crafted for conducting</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.95.1"> load testing while measuring application performance and response times. </span><span class="koboSpan" id="kobo.95.2">JMeter boasts numerous sophisticated features. </span><span class="koboSpan" id="kobo.95.3">It operates as a thick client Java application and offers the capability to conduct performance testing across various technologies, employing a diverse range of protocols, including Java objects, web HTTP/HTTPS, SOAP and REST services, FTP, and databases with JDBC. </span><span class="koboSpan" id="kobo.95.4">Additionally, it provides a user-friendly IDE</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.96.1"> for recording, building, and debugging performance tests effectively. </span><span class="koboSpan" id="kobo.96.2">Starting from </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">JMeter 3.1</span></strong><span class="koboSpan" id="kobo.98.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">Groovy</span></strong><span class="koboSpan" id="kobo.100.1"> is set as the default programming</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.101.1"> language, because it’s easy to use, flexible, and constantly being developed. </span><span class="koboSpan" id="kobo.101.2">In addition, Groovy can be fully integrated with Java, which provides many scripting capabilities via an expressive, concise, and readable syntax. </span><span class="koboSpan" id="kobo.101.3">As one of the most popular load-testing tools, JMeter allows users to configure and assess the performance of mobile apps. </span><span class="koboSpan" id="kobo.101.4">Moreover, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">jmeter-java-dsl</span></strong><span class="koboSpan" id="kobo.103.1">, you have the option to write your performance tests in Java, taking advantage of IDEs’ autocompletion and inline documentation. </span><span class="koboSpan" id="kobo.103.2">To get started, you can find a good resource in the </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.105.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.106.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">While JMeter remains one of the popular load-testing tools, scaling it for a large, distributed test can be somewhat challenging, particularly when dealing with multiple machines that require intricate configurations</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.108.1"> to communicate effectively. </span><span class="koboSpan" id="kobo.108.2">Additionally, executing large JMeter tests may lead</span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.109.1"> to a range of </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">orchestrating issues.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.111.1">Customer satisfaction</span></h2>
<p><span class="koboSpan" id="kobo.112.1">Customer satisfaction is the level</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.113.1"> of contentment customers feel after using a product or service, based on their perceptions and expectations. </span><span class="koboSpan" id="kobo.113.2">It’s a critical indicator of business success, impacting loyalty and reputation. </span><span class="koboSpan" id="kobo.113.3">There are many ways to measure it; jump to the </span><em class="italic"><span class="koboSpan" id="kobo.114.1">Further reading</span></em><span class="koboSpan" id="kobo.115.1"> section if you’d like to </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">learn more.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">High-quality software that undergoes rigorous testing not only ensures its reliability but also increases the likelihood of meeting the needs and expectations of its users. </span><span class="koboSpan" id="kobo.117.2">When customers find the software to be efficient, stable, and bug-free, they are more likely to be satisfied with </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">their experience.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Satisfied customers tend to build a sense of trust and loyalty toward the product and the company behind it. </span><span class="koboSpan" id="kobo.119.2">They are more inclined to continue using the software for extended periods, fostering long-term engagement and loyalty. </span><span class="koboSpan" id="kobo.119.3">Moreover, happy customers often become advocates for the product, enthusiastically recommending it to their peers, friends, </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">and colleagues.</span></span></p>
<p><span class="koboSpan" id="kobo.121.1">Word-of-mouth referrals from satisfied users can be a powerful driver for the software’s success. </span><span class="koboSpan" id="kobo.121.2">Positive recommendations can significantly expand the software’s user base, leading to increased adoption rates and potential revenue growth for </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">the company.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.123.1">Compliance and standards</span></h2>
<p><span class="koboSpan" id="kobo.124.1">In certain industries, such</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.125.1"> as healthcare, finance, and aerospace, the software used plays</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.126.1"> a critical role in the safety, security, and well-being of individuals and organizations. </span><span class="koboSpan" id="kobo.126.2">Due to the high stakes involved, these industries are subject to strict regulations and standards that software must </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">adhere to.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">In healthcare, for example, software for medical devices and health management must meet strict regulations set by authorities such as the FDA and EMA to ensure patient safety. </span><span class="koboSpan" id="kobo.128.2">The financial industry relies on software to handle critical tasks, and compliance with SEC and FCA standards is vital to protect consumers from fraud and data breaches. </span><span class="koboSpan" id="kobo.128.3">Similarly, aerospace software must adhere to FAA and EASA standards to ensure passenger safety and avoid accidents or operational disruptions. </span><span class="koboSpan" id="kobo.128.4">Non-compliance can have severe consequences for all </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">these sectors.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Testing helps identify and address </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.131.1">potential issues, vulnerabilities, and defects that could compromise</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.132.1"> the software’s performance, security, or compliance. </span><span class="koboSpan" id="kobo.132.2">By conducting deep testing, organizations can avoid legal and financial consequences that may arise from non-compliance with </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">industry regulations.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.134.1">Security</span></h2>
<p><span class="koboSpan" id="kobo.135.1">In today’s digital landscape, where cyber threats</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.136.1"> and attacks are becoming increasingly sophisticated, it is imperative to fortify software systems against potential </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">security breaches.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">During the testing process, security experts and testers employ various methodologies and tools to simulate real-world attack scenarios, attempting to exploit weaknesses in the software’s defenses. </span><span class="koboSpan" id="kobo.138.2">This includes techniques such as penetration testing, where testers try to gain unauthorized access to the system, and vulnerability assessments, which identify potential areas </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">of weakness.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">By conducting such tests, developers can proactively identify and address security flaws before the software is deployed to the production environment. </span><span class="koboSpan" id="kobo.140.2">This proactive approach significantly reduces the risk of potential security breaches that could lead to data breaches, unauthorized access, or </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">service disruptions.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Here are some suggestions</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.143.1"> to effectively integrate security testing into the </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">Software Development Life Cycle</span></strong><span class="koboSpan" id="kobo.145.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.146.1">SDLC</span></strong><span class="koboSpan" id="kobo.147.1">); these are just a few ideas, based on what we have encountered in experience, and we suggest you look deeper into each point if it piques </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">your interest:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.149.1">Create security requirements specific to your application</span></strong><span class="koboSpan" id="kobo.150.1">: Ensure these requirements align with industry standards and </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">compliance regulations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">Training and awareness</span></strong><span class="koboSpan" id="kobo.153.1">: Train developers and the development team on secure coding practices, fostering a security-aware culture within </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">your organization.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">Dependency scanning</span></strong><span class="koboSpan" id="kobo.156.1">: Regularly scan third-party dependencies for known vulnerabilities. </span><span class="koboSpan" id="kobo.156.2">Implement or use automated tools that can alert you when a dependency has a </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">security issue.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.158.1">Penetration testing</span></strong><span class="koboSpan" id="kobo.159.1">: Conduct penetration testing to simulate real-world attacks. </span><span class="koboSpan" id="kobo.159.2">Test the application from an attacker’s perspective to identify vulnerabilities that automated tools </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">might miss.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.161.1">These are just some of the measures</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.162.1"> we’ve seen implemented in companies, usually large companies that have dedicated teams. </span><span class="koboSpan" id="kobo.162.2">These activities are not only time-consuming but also very complex and require </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">specific skills.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.164.1">Integration and compatibility</span></h2>
<p><span class="koboSpan" id="kobo.165.1">Testing plays a crucial role in verifying</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.166.1"> the seamless integration and compatibility of software</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.167.1"> with other components or systems. </span><span class="koboSpan" id="kobo.167.2">In today’s complex technological landscape, software rarely operates in isolation; it often interacts with various hardware, software modules, databases, APIs, and external systems. </span><span class="koboSpan" id="kobo.167.3">Ensuring that all these pieces work harmoniously together is essential for the overall success and efficiency of </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">One of the primary testing</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.170.1"> methodologies used to assess integration and compatibility is </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">integration testing</span></strong><span class="koboSpan" id="kobo.172.1">. </span><span class="koboSpan" id="kobo.172.2">This type of testing focuses on evaluating how different modules or components of the software interact and exchange data with each other. </span><span class="koboSpan" id="kobo.172.3">We’ll deep dive into this topic in a </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">dedicated section.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.174.1">Compatibility testing</span></strong><span class="koboSpan" id="kobo.175.1"> is another vital aspect of the testing process. </span><span class="koboSpan" id="kobo.175.2">With the wide variety of devices, operating</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.176.1"> systems, web browsers, and configurations available, it is essential to validate that the software functions correctly across different environments. </span><span class="koboSpan" id="kobo.176.2">Compatibility testing involves testing the software on various platforms to ensure that it behaves consistently and uniformly across all </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.178.1">By conducting compatibility testing, developers</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.179.1"> can identify platform-specific issues and make necessary adjustments to the software. </span><span class="koboSpan" id="kobo.179.2">This not only improves the user experience but also expands the potential user base, as a broader range of users can access and use the software without encountering </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">compatibility-related problems.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">Integration and compatibility</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.182.1"> issues can arise at different stages of software development, from the initial design to the final implementation. </span><span class="koboSpan" id="kobo.182.2">By incorporating testing throughout the development process, developers can proactively address these challenges, reducing the likelihood of integration bottlenecks (that is, a point in a system where the flow of data or functionality between different components</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.183.1"> is restricted, causing delays or inefficiencies) or compatibility</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.184.1"> conflicts in the later stages of </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the project.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.186.1">Confidence and peace of mind</span></h2>
<p><span class="koboSpan" id="kobo.187.1">It might sound strange, but rigorous</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.188.1"> testing of our software allows us to sleep more peacefully, and that is not a trivial matter. </span><span class="koboSpan" id="kobo.188.2">Let me explain further. </span><span class="koboSpan" id="kobo.188.3">If every time we release a new version of our software, we know that it has been well tested and we are confident in its proper functioning, this increases the team’s self-confidence and, ultimately, we work better, which is undoubtedly a benefit for everyone. </span><span class="koboSpan" id="kobo.188.4">When we work better, we become more productive and produce something of </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">higher quality.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">Furthermore, I must add that many developers don’t enjoy working on bugs, especially when they are complex to identify and resolve. </span><span class="koboSpan" id="kobo.190.2">Bug-fixing is time-consuming and often difficult to predict. </span><span class="koboSpan" id="kobo.190.3">As already mentioned, it takes time away from the team’s </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">core activities.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">That’s why it’s essential for developers to care about testing; it’s not only crucial in itself but also affects people’s well-being in some way. </span><span class="koboSpan" id="kobo.192.2">The primary goal (before clean code and refactoring – which cannot be safely done without a proper battery of tests) of developers must be that their software is adequately and automatically tested every time a change is made. </span><span class="koboSpan" id="kobo.192.3">The first</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.193.1"> and most immediate way to perform automatic tests is to write so-called “unit tests”; in Java, the most widely used framework for this is </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">undoubtedly JUnit.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.195.1">Unit testing</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.196.1">Unit testing</span></strong><span class="koboSpan" id="kobo.197.1"> is a type of software testing where individual units</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.198.1"> or components of a software application are tested in isolation to ensure they function correctly. </span><span class="koboSpan" id="kobo.198.2">A </span><em class="italic"><span class="koboSpan" id="kobo.199.1">unit</span></em><span class="koboSpan" id="kobo.200.1"> typically refers to the smallest testable part of the software, such as a function, method, or class. </span><span class="koboSpan" id="kobo.200.2">The main goal of unit testing is to validate that each unit of the software works as expected and produces the correct output for a given input. </span><span class="koboSpan" id="kobo.200.3">By testing units independently, developers can identify and fix bugs or issues in the early stages of development, making it easier</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.201.1"> to maintain and improve (hence, to refactor) the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">There are several benefits to adopting</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.204.1"> unit testing, some of which are </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.206.1">Velocity</span></strong><span class="koboSpan" id="kobo.207.1">: Unit tests are fast! </span><span class="koboSpan" id="kobo.207.2">They focus on testing small, isolated units of code, typically individual functions or methods, in isolation from the rest of the system. </span><span class="koboSpan" id="kobo.207.3">This isolation allows unit tests to execute quickly because they don’t rely on external dependencies or perform complex setup and teardown processes. </span><span class="koboSpan" id="kobo.207.4">This helps developers to run them often and get </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">quick feedback.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.209.1">Isolation</span></strong><span class="koboSpan" id="kobo.210.1">: Each unit test is designed to run independently of the rest of the application. </span><span class="koboSpan" id="kobo.210.2">This isolation ensures that if a test fails, the cause is likely within the specific unit being tested, making it easier to pinpoint and fix </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">the issue.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.212.1">Automation</span></strong><span class="koboSpan" id="kobo.213.1">: Unit tests are usually automated, meaning they can be run automatically and regularly as part of the development process. </span><span class="koboSpan" id="kobo.213.2">This automation helps ensure that new code changes don’t introduce regressions or break </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">existing functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.215.1">Early detection of issues</span></strong><span class="koboSpan" id="kobo.216.1">: Unit testing facilitates the early detection of defects, which can significantly reduce the cost and effort required for debugging and maintenance later in the </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">development cycle.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.218.1">Documentation</span></strong><span class="koboSpan" id="kobo.219.1">: Unit tests serve as living documentation, providing examples of how units are expected to behave. </span><span class="koboSpan" id="kobo.219.2">Developers can refer to these tests to understand the intended functionality of a unit and its possible edge cases. </span><span class="koboSpan" id="kobo.219.3">This is crucial; a well-written unit test can be better than 10 pages </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">of documentation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Refactoring support</span></strong><span class="koboSpan" id="kobo.222.1">: Of course, that’s why we’re talking about tests in this book! </span><span class="koboSpan" id="kobo.222.2">When refactoring code, unit tests act as a safety net. </span><span class="koboSpan" id="kobo.222.3">If the refactored code breaks any functionality, the unit tests will catch it, helping ensure the changes do not </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">introduce</span></span><span class="No-Break"><a id="_idIndexMarker288"/></span><span class="No-Break"><span class="koboSpan" id="kobo.224.1"> bugs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.225.1">In practice, in a unit test, nothing else is done except executing a certain portion of code (for example, a method) and verifying that, starting from a specific input, the same output is always produced. </span><span class="koboSpan" id="kobo.225.2">Easy, right? </span><span class="koboSpan" id="kobo.225.3">Well, not always, and soon we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">see why.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">To test our unit, we will write – in fact – a Java</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.228.1"> class with several methods (each of which is a unit test) that will test the various functionalities. </span><span class="koboSpan" id="kobo.228.2">It is always advisable to be organized even in the design of test classes; by convention, to test, for example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">com.acme.demo.MyClass</span></strong><span class="koboSpan" id="kobo.230.1"> class, we will create a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">com.acme.demo.MyClassTest</span></strong><span class="koboSpan" id="kobo.232.1">. </span><span class="koboSpan" id="kobo.232.2">The former will be placed under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">main</span></strong><span class="koboSpan" id="kobo.234.1"> folder, while the latter will be under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">test</span></strong><span class="koboSpan" id="kobo.236.1"> folder. </span><span class="koboSpan" id="kobo.236.2">Inside each</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.237.1"> unit test, it is advisable to follow a fairly established pattern, called </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">AAA</span></strong><span class="koboSpan" id="kobo.239.1">, or the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">three As:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.241.1">Arrange</span></strong><span class="koboSpan" id="kobo.242.1">: This phase involves preparing</span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.243.1"> the objects that will be subjected to testing. </span><span class="koboSpan" id="kobo.243.2">During this phase, you establish the desired condition of the system under test and set up its dependencies. </span><span class="koboSpan" id="kobo.243.3">This can involve directly creating instances of the necessary objects or getting them ready by creating their test counterparts. </span><span class="koboSpan" id="kobo.243.4">This may include initializing resources (collaborators) needed for the class under test, and </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.245.1">Act</span></strong><span class="koboSpan" id="kobo.246.1">: This is where you interact with the system</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.247.1"> under test. </span><span class="koboSpan" id="kobo.247.2">In this phase, you invoke one of its methods, providing any required dependencies, and capturing any resulting output values </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">if applicable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.249.1">Assert</span></strong><span class="koboSpan" id="kobo.250.1">: This is where you check Boolean</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.251.1"> expressions (assertions) that must be true if the test is successful; that is, the observed output data and/or post-conditions are different from the expected ones. </span><span class="koboSpan" id="kobo.251.2">Sometimes, it is not only the output that is evaluated, but it is also possible to verify the method’s execution flow by making assertions regarding whether a certain component – present </span><em class="italic"><span class="koboSpan" id="kobo.252.1">inside</span></em><span class="koboSpan" id="kobo.253.1"> the class under test – has been called, how many times, and with </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">what input.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.255.1">Let’s go through a trivial</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.256.1"> example. </span><span class="koboSpan" id="kobo.256.2">Let’s suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">Calculator</span></strong><span class="koboSpan" id="kobo.258.1"> class, which has a method that takes two integers and returns their sum (I said it </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">was trivial!):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.260.1">
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.261.1">Let’s now write a test class </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Calculator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
public class CalculatorTest {
    public static void main(String[] args) {
        testAddition();
    }
    public static void testAddition() {
        // Arrange
        Calculator calculator = new Calculator();
        // Act
        int result = calculator.add(5, 3);
        // Assert
        int expected = 8;
        if (result == expected) {
            System.out.println("testAddition PASSED");
        } else {
            System.out.println("testAddition FAILED");
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.266.1">In this example, we have created a test method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">testAddition</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">The test method creates an instance </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.269.1">of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Calculator</span></strong><span class="koboSpan" id="kobo.271.1"> class, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">testAddition</span></strong><span class="koboSpan" id="kobo.273.1"> with a specific input, and then compares the result with the expected output. </span><span class="koboSpan" id="kobo.273.2">When you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">CalculatorTest</span></strong><span class="koboSpan" id="kobo.275.1"> class, it will output whether the test has passed or failed based on the comparison of the actual results and </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">expected results.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">Keep in mind that this is just a basic example to demonstrate how unit tests can be written without using a testing framework such as JUnit. </span><span class="koboSpan" id="kobo.277.2">In real-world scenarios, using a testing framework such as JUnit provides many additional features and benefits, such as easier test organization, assertions, test reporting, and integration with build tools and </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">CI/CD pipelines.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.279.1">JUnit framework</span></h2>
<p><span class="koboSpan" id="kobo.280.1">JUnit is a popular testing</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.281.1"> framework for Java that is primarily used to perform unit testing of Java applications. </span><span class="koboSpan" id="kobo.281.2">It provides a set of annotations, assertions, and test runners that make writing and executing tests easier and more organized. </span><span class="koboSpan" id="kobo.281.3">JUnit is widely used in the Java development community and has become a standard for writing </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">Here are some key features and concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">of JUnit:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.285.1">Annotations</span></strong><span class="koboSpan" id="kobo.286.1">: JUnit uses annotations </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.287.1">to define test methods, setup, and teardown</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.288.1"> methods. </span><span class="koboSpan" id="kobo.288.2">Some commonly used annotations in JUnit are </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">@Test</span></strong><span class="koboSpan" id="kobo.290.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">@Before</span></strong><span class="koboSpan" id="kobo.292.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">@After</span></strong><span class="koboSpan" id="kobo.294.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">@BeforeClass</span></strong><span class="koboSpan" id="kobo.296.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">@AfterClass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.300.1">Test methods</span></strong><span class="koboSpan" id="kobo.301.1">: Test methods are annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">@Test</span></strong><span class="koboSpan" id="kobo.303.1"> and are responsible for verifying specific functionality in the code being tested. </span><span class="koboSpan" id="kobo.303.2">Each test method should be independent and focus on testing a specific part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">code base.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Setup and teardown</span></strong><span class="koboSpan" id="kobo.306.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">@Before</span></strong><span class="koboSpan" id="kobo.308.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">@After</span></strong><span class="koboSpan" id="kobo.310.1"> annotations are used to mark methods that will be executed before and after each test method. </span><span class="koboSpan" id="kobo.310.2">They are used for setting up the test environment (e.g., initializing objects) and cleaning up resources after </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">each test.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.312.1">Test runners</span></strong><span class="koboSpan" id="kobo.313.1">: JUnit provides various test runners that determine how tests are executed. </span><span class="koboSpan" id="kobo.313.2">A widely</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.314.1"> used test runner is </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">BlockJUnit4ClassRunner</span></strong><span class="koboSpan" id="kobo.316.1">, but </span><strong class="bold"><span class="koboSpan" id="kobo.317.1">JUnit 5</span></strong><span class="koboSpan" id="kobo.318.1"> has introduced a more flexible and extensible model based </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">org.junit.platform.runner.JUnitPlatform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.322.1">Assertions</span></strong><span class="koboSpan" id="kobo.323.1">: JUnit provides a set of static methods (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">assertEquals</span></strong><span class="koboSpan" id="kobo.325.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">assertTrue</span></strong><span class="koboSpan" id="kobo.327.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">assertFalse</span></strong><span class="koboSpan" id="kobo.329.1">, etc.) to perform various types of assertions to check the expected outcomes of </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.331.1">Test suites</span></strong><span class="koboSpan" id="kobo.332.1">: JUnit allows you to group related test classes into test suites using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">@RunWith</span></strong><span class="koboSpan" id="kobo.334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">@</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Suite</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1"> annotations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.338.1">Parameterized tests</span></strong><span class="koboSpan" id="kobo.339.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">JUnit 4</span></strong><span class="koboSpan" id="kobo.341.1"> introduced the concept</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.342.1"> of parameterized tests, allowing</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.343.1"> you to run the</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.344.1"> same test with multiple sets</span><a id="_idIndexMarker303"/> <span class="No-Break"><span class="koboSpan" id="kobo.345.1">of data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.346.1">JUnit 5 is the next major version of JUnit</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.347.1"> and introduced several new features and improvements over JUnit 4. </span><span class="koboSpan" id="kobo.347.2">It offers a more modular and extensible architecture, better support for </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">Java 8</span></strong><span class="koboSpan" id="kobo.349.1"> and above, and various</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.350.1"> new annotations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">@BeforeEach</span></strong><span class="koboSpan" id="kobo.352.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">@AfterEach</span></strong><span class="koboSpan" id="kobo.354.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">@DisplayName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">If we wanted to rewrite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">CalculatorTest</span></strong><span class="koboSpan" id="kobo.360.1"> class using JUnit, the result would be as follows. </span><span class="koboSpan" id="kobo.360.2">The example is straightforward, but it helps us understand how the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">framework works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
@Test
@DisplayName("Tests the Addition method of the Calculator")
void testAddition() {
    Calculator calculator = new Calculator();
    int result = calculator.add(5, 3);
    int expected = 8;
    Assertions.assertEquals(result, expected);
}</span></pre> <p><span class="koboSpan" id="kobo.363.1">You can notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">@Test</span></strong><span class="koboSpan" id="kobo.365.1"> annotation, which allows the framework to “understand” that that is a unit test. </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">@DisplayName</span></strong><span class="koboSpan" id="kobo.367.1"> is utilized to specify a personalized name for the annotated test class or test</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.368.1"> method; these display names are commonly employed for test reporting within IDEs and build tools, and they have the flexibility to include spaces, special characters, </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">and emojis.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">This is how the IntelliJ IDE represents the execution of a successful </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">JUnit test:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.372.1"><img alt="Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE" src="image/B20912_04_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.373.1">Figure 4.1 – Execution of a successful JUnit test in the IntelliJ IDE</span></p>
<p><span class="koboSpan" id="kobo.374.1">Now, it is quite intuitive, I believe, to understand how an automated test suite can be integrated into the code development process; frameworks such as JUnit help developers test their code, find</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.375.1"> bugs, and potentially</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.376.1"> improve performance. </span><span class="koboSpan" id="kobo.376.2">JUnit (and unit testing in general) reaches its full </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.377.1">potential when</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.378.1"> integrated through tools such as </span><strong class="bold"><span class="koboSpan" id="kobo.379.1">Maven</span></strong><span class="koboSpan" id="kobo.380.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">Gradle</span></strong><span class="koboSpan" id="kobo.382.1"> (which allow code build management and automated test execution) and </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">Jenkins</span></strong><span class="koboSpan" id="kobo.384.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">GitHub</span></strong><span class="koboSpan" id="kobo.386.1">, which handle </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.388.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">CI</span></strong><span class="koboSpan" id="kobo.390.1">), a practice that involves automatically and regularly integrating </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.391.1">code changes into a shared repository and running automated tests to detect integration issues early. </span><span class="koboSpan" id="kobo.391.2">CI is a very broad topic, so I refer you to the </span><em class="italic"><span class="koboSpan" id="kobo.392.1">Further reading</span></em><span class="koboSpan" id="kobo.393.1"> section, where there is a related Wikipedia entry. </span><span class="koboSpan" id="kobo.393.2">Unfortunately, it is challenging to find </span><em class="italic"><span class="koboSpan" id="kobo.394.1">agnostic</span></em><span class="koboSpan" id="kobo.395.1">, meaning not tied to specific products, material online that explains the concepts. </span><span class="koboSpan" id="kobo.395.2">I hope this can serve as a starting point and stimulate </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">your curiosity.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Writing unit tests is hard and complicated, much more than it may seem from these few simple examples. </span><span class="koboSpan" id="kobo.397.2">It is also a crucial task, essential both for a smooth production release and to be able to perform any desired refactoring. </span><span class="koboSpan" id="kobo.397.3">One of the most challenging aspects is imagining all possible test cases (i.e., all potential behaviors of the application, all the “flows” it can follow – think of all the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">if</span></strong><span class="koboSpan" id="kobo.399.1"> statements</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.400.1"> and polymorphism you have used in your code); fortunately, we don’t have to imagine, as we can use tools designed for </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">this purpose.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.402.1">Integration testing</span></h1>
<p><span class="koboSpan" id="kobo.403.1">Integration testing involves checking how various pieces, modules, or parts</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.404.1"> of a software application work together, even if different programmers </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">coded them.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">The goal of integration testing is to examine the connections between these modules and uncover any issues that might pop up when these components come together and have to </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">work together.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">It is usually performed downstream of unit tests; assuming that individual software modules (be they projects, classes, or entire applications) are tested individually, we begin to test the interactions they have with other modules with which they collaborate, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">Figure 4</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.410.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.412.1"><img alt="Figure 4.2 – Unit tests concern each module individually, while integration tests concern interactions" src="image/B20912_04_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.413.1">Figure 4.2 – Unit tests concern each module individually, while integration tests concern interactions</span></p>
<p><span class="koboSpan" id="kobo.414.1">To carry out integration testing, testers use test drivers and </span><em class="italic"><span class="koboSpan" id="kobo.415.1">stubs</span></em><span class="koboSpan" id="kobo.416.1">, that is, placeholder programs that step in for any absent modules and mimic data exchange between modules for testing. </span><span class="koboSpan" id="kobo.416.2">There are several frameworks that can help you along the way; you don’t have to do all the work by yourself! </span><span class="koboSpan" id="kobo.416.3">The most famous framework</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.417.1"> used to perform integration testing (at least on a basic and widespread level) is JUnit (which we just saw) in combination </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">with Mockito.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.419.1">Mockito</span></h2>
<p><span class="koboSpan" id="kobo.420.1">Mockito is a widely used Java-based open source framework</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.421.1"> for creating and configuring mock</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.422.1"> objects in both unit testing and integration testing. </span><span class="koboSpan" id="kobo.422.2">In the context of Java software development, Mockito is favored for its ability to facilitate testing by creating mock objects that mimic the behavior of real components. </span><span class="koboSpan" id="kobo.422.3">These mock objects are especially valuable in integration testing for </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">several reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.424.1">Firstly, Mockito aids in isolating specific parts of an application. </span><span class="koboSpan" id="kobo.424.2">It allows developers to create mock objects that simulate the behavior of real components, thereby enabling them to test particular modules, components, or services in isolation. </span><span class="koboSpan" id="kobo.424.3">This isolation is crucial when you want to verify the behavior of a specific part of your application without involving the entire system or interacting </span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.425.1">with real dependencies, such as databases, web services, or external APIs. </span><span class="koboSpan" id="kobo.425.2">In the following</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.426.1"> code snippet, we can get an idea of how </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">Mockito works:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.428.1">
import static org.mockito.Mockito.*;
// Create a mock HTTP client
HttpClient httpClientMock = mock(HttpClient.class);
// Create an instance of your service and inject the
  mock
MyService myService = new MyService(httpClientMock);
// Define the behavior of the mock
when(httpClientMock.get(anyString())).thenReturn
  ("Mocked response");
// Perform a test using MyService
String result = myService.getDataFromExternalService
  ("https://example.com/api");</span></pre></li> <li><span class="koboSpan" id="kobo.429.1">Secondly, Mockito provides control and verification capabilities. </span><span class="koboSpan" id="kobo.429.2">Developers can define the behavior of mock objects, specify what methods should return, and record interactions with these objects during the test. </span><span class="koboSpan" id="kobo.429.3">This level of control and verification ensures that the component under test correctly interacts with its dependencies. </span><span class="koboSpan" id="kobo.429.4">To verify something, you just have to write something such as </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.431.1">
// Verify interactions with the mock
verify(httpClientMock).get("https://example.com/api");</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.432.1">Additionally, Mockito contributes to the efficiency and speed of integration tests. </span><span class="koboSpan" id="kobo.432.2">Using real external dependencies in integration tests can be slow and complex to set up, and may result in undesirable side effects. </span><span class="koboSpan" id="kobo.432.3">In contrast, Mockito’s mock objects are lightweight and do not rely on external resources, making integration tests faster, more efficient, and less prone to </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">side effects.</span></span></p></li> <li><span class="koboSpan" id="kobo.434.1">Lastly, Mockito</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.435.1"> offers test flexibility. </span><span class="koboSpan" id="kobo.435.2">Developers can create </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.436.1">customizable mock objects that allow them to specify different behaviors for various test cases. </span><span class="koboSpan" id="kobo.436.2">This flexibility simplifies the simulation of various scenarios in </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">integration tests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.438.1">We have left some material in the </span><em class="italic"><span class="koboSpan" id="kobo.439.1">Further Readings</span></em><span class="koboSpan" id="kobo.440.1"> section to deep dive into the magic </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">of Mockito.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.442.1">Contract testing</span></h1>
<p><span class="koboSpan" id="kobo.443.1">We have seen that integration</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.444.1"> tests are also used to test external services, services that are probably not in our code base and that may not even be maintained by us. </span><span class="koboSpan" id="kobo.444.2">You then create a stub, or mock, that returns a “fake” answer, based on documentation or, often, on the real answers exchanged at runtime between the two services. </span><span class="koboSpan" id="kobo.444.3">But what happens if something changes, if one of the two changes the contract? </span><span class="koboSpan" id="kobo.444.4">How do you make sure that the mock we’ve created is really a representation of the outside service? </span><span class="koboSpan" id="kobo.444.5">Contract testing </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">helps us.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Contract testing aims to ensure compatibility and agreement between different services or components within a distributed system. </span><span class="koboSpan" id="kobo.446.2">It is particularly useful in scenarios such as microservices architectures where different services need to communicate seamlessly. </span><span class="koboSpan" id="kobo.446.3">In contract testing, services communicate with each other based on well-defined interfaces or contracts. </span><span class="koboSpan" id="kobo.446.4">These contracts outline how data is exchanged, specify available methods or endpoints, and describe </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">expected responses.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">There are two primary roles in contract testing: consumers and providers. </span><span class="koboSpan" id="kobo.448.2">Consumers are the services or components that utilize data or functionality from another service, known as the provider. </span><span class="koboSpan" id="kobo.448.3">Contracts define what</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.449.1"> the consumer expects from the provider; that is why it is said that contract tests </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">are consumer-driven.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">The process starts with the definition</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.452.1"> of contracts, which can take various forms, such as API specifications or interface documentation. </span><span class="koboSpan" id="kobo.452.2">Contract testing primarily focuses on the consumer’s perspective. </span><span class="koboSpan" id="kobo.452.3">Consumer tests are written to ensure that the provider’s behavior aligns with the contract. </span><span class="koboSpan" id="kobo.452.4">These tests are typically managed by the consumer’s team. </span><span class="koboSpan" id="kobo.452.5">Provider tests, on the other hand, are written by the provider’s team. </span><span class="koboSpan" id="kobo.452.6">They verify that the provider complies with the contract specifications. </span><span class="koboSpan" id="kobo.452.7">Automated contract tests run continuously as part of the build and deployment process. </span><span class="koboSpan" id="kobo.452.8">They help detect compatibility issues early whenever changes occur in either the consumer or provider service. </span><span class="koboSpan" id="kobo.452.9">Here is a diagram to help understand </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">contract testing:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.454.1"><img alt="Figure 4.3 – Contract testing" src="image/B20912_04_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">Figure 4.3 – Contract testing</span></p>
<p><span class="koboSpan" id="kobo.456.1">Various tools and libraries support contract testing, depending on the project’s technology stack and requirements. </span><span class="koboSpan" id="kobo.456.2">Some popular</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.457.1"> options include Pact, Spring Cloud Contract, </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">and Pacto.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.459.1">Be safe – checking and improving your test coverage</span></h1>
<p><span class="koboSpan" id="kobo.460.1">Testing is important, but we need to make sure</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.461.1"> we test our code thoroughly, not just a part of it; covering</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.462.1"> all the code doesn’t only mean all the classes, but also all possible execution paths. </span><span class="koboSpan" id="kobo.462.2">We might think it’s easy to keep all possible cases in mind, and perhaps this is true for very small projects; but as the project grows and inevitably becomes more complex (for example, the number of features increases or the possible execution paths multiply), it becomes difficult to understand the efficiency of our tests for keeping us safe. </span><span class="koboSpan" id="kobo.462.3">This is why we introduce the concept</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.463.1"> of test coverage</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.464.1"> and a tool to </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">measure it.</span></span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.466.1">What is test coverage?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.467.1">Test coverage</span></strong><span class="koboSpan" id="kobo.468.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">code coverage</span></strong><span class="koboSpan" id="kobo.470.1">, is a metric used to measure the extent to which the source code</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.471.1"> of a program is executed by a set of test cases. </span><span class="koboSpan" id="kobo.471.2">It is a quantitative measure</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.472.1"> that helps developers and testers understand how much of the code is being exercised </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">during testing.</span></span></p>
<p><span class="koboSpan" id="kobo.474.1">Test coverage is usually expressed as a percentage, representing the proportion of code lines, branches, statements, or methods that have been executed by the test suite compared to the total number of such elements in the </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">There are different types</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.477.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">coverage metrics:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.479.1">Line coverage</span></strong><span class="koboSpan" id="kobo.480.1">: This measures the percentage of lines of code that have been executed</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.481.1"> at least once </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">during testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.483.1">Branch coverage</span></strong><span class="koboSpan" id="kobo.484.1">: Branch coverage measures </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.485.1">the percentage of branches (i.e., decision points – basically, and simplifying, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">if</span></strong><span class="koboSpan" id="kobo.487.1"> instances in your code) that have been taken or not taken during testing. </span><span class="koboSpan" id="kobo.487.2">It ensures that both true and false branches of conditional statements </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">are tested.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.489.1">Statement coverage</span></strong><span class="koboSpan" id="kobo.490.1">: This measures the percentage</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.491.1"> of executable statements that have been executed </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">during testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.493.1">Method coverage</span></strong><span class="koboSpan" id="kobo.494.1">: Method coverage measures the percentage</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.495.1"> of methods or functions that have been called </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">during testing.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.497.1">Test coverage is not a definitive measure of software quality but provides valuable insights into the thoroughness of testing efforts. </span><span class="koboSpan" id="kobo.497.2">High coverage indicates that a significant portion of the code has been tested, increasing confidence in the correctness of the application. </span><span class="koboSpan" id="kobo.497.3">However, even 100% coverage does not guarantee a bug-free application, as it is possible to have untested edge cases or incorrect assumptions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">test cases.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">By improving test coverage, developers</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.500.1"> can mitigate the risk of undiscovered defects and make their code more robust and maintainable. </span><span class="koboSpan" id="kobo.500.2">We use code coverage tools to generate coverage reports, which can be analyzed to identify areas of the code that need </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">more testing.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.502.1">A Java code coverage tool – JaCoCo</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.503.1">JaCoCo</span></strong><span class="koboSpan" id="kobo.504.1"> (short for </span><strong class="bold"><span class="koboSpan" id="kobo.505.1">Java Code Coverage</span></strong><span class="koboSpan" id="kobo.506.1">) is a widely used open source code coverage library</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.507.1"> for Java projects. </span><span class="koboSpan" id="kobo.507.2">It provides a comprehensive and detailed analysis of code coverage, allowing developers to understand how much of their Java code is exercised by </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">their tests.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">JaCoCo offers various types of code coverage analysis, including line coverage, branch coverage, and method coverage. </span><span class="koboSpan" id="kobo.509.2">It instruments the Java bytecode during the build process to collect execution data, which is then used to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">coverage reports.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">JaCoCo primarily provides three </span><a id="_idIndexMarker338"/><span class="No-Break"><span class="koboSpan" id="kobo.512.1">significant metrics:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.513.1">Line coverage</span></strong><span class="koboSpan" id="kobo.514.1"> indicates the extent of code that has been executed based on the number of Java bytecode instructions called by </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">the tests</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.516.1">Branches coverage</span></strong><span class="koboSpan" id="kobo.517.1"> shows the percentage of exercised branches in the code, usually associated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">if</span></strong><span class="koboSpan" id="kobo.519.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">else</span></strong><span class="koboSpan" id="kobo.521.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.523.1"> statements</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.524.1">Cyclomatic complexity</span></strong><span class="koboSpan" id="kobo.525.1"> reflects the code’s complexity by quantifying the number of paths required to cover all the possible code paths through a </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">linear combination</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.527.1">To illustrate with a simple example, if the code contains no </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">if</span></strong><span class="koboSpan" id="kobo.529.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">switch</span></strong><span class="koboSpan" id="kobo.531.1"> statements, the cyclomatic complexity will be 1, as only one execution path is needed to cover the entire code. </span><span class="koboSpan" id="kobo.531.2">In general, the cyclomatic complexity represents the number of test cases required to achieve full </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">code coverage.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">To illustrate how JaCoCo works, let’s start with a very simple example. </span><span class="koboSpan" id="kobo.533.2">It is not my intention to create a tutorial on this tool here – there are already plenty of them online – but I would like to show you its main features so that you can get a rough idea of how </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">it works.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">Let’s suppose we have a project </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.536.1">consisting of only one class named </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Calculator</span></strong><span class="koboSpan" id="kobo.538.1">, defined </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
public class Calculator {
    public Integer sum(Integer a, Integer b) {
        return a + b;
    }
    public Integer subtract(Integer a, Integer b) {
        return a - b;
    }
    public Integer multiply(Integer a, Integer b) {
        return a * b;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">As you can see, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">Calculator</span></strong><span class="koboSpan" id="kobo.543.1"> class exposes three very simple methods that take two integers as input and return, respectively, their sum, difference, and product. </span><span class="koboSpan" id="kobo.543.2">Let’s proceed to write the corresponding test class, which we will define </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
class CalculatorTest {
    private final Calculator calculator = new Calculator();
    @Test
    void sum() {
        var sum = calculator.sum(1, 4);
        assertEquals(5, sum);
    }
    @Test
    void subtract() {
        var sum = calculator.subtract(10, 4);
        assertEquals(6, sum);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.546.1">The test class creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Calculator</span></strong><span class="koboSpan" id="kobo.548.1"> and then performs two unit tests, one for the sum and the other for the difference. </span><span class="koboSpan" id="kobo.548.2">Using the JUnit framework, we verify that the expected result matches the </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">actual result.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">There are many ways to use</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.551.1"> a tool like JaCoCo, but in my opinion, the best approach is to integrate it into the development cycle. </span><span class="koboSpan" id="kobo.551.2">Assuming we are using Maven, we will configure our </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">pom.xml</span></strong><span class="koboSpan" id="kobo.553.1"> file so that the plugin is executed and reports </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">are generated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.555.1">
&lt;plugin&gt;
   &lt;groupId&gt;org.jacoco&lt;/groupId&gt;
   &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;
   &lt;version&gt;0.8.10&lt;/version&gt;
   &lt;executions&gt;
      &lt;execution&gt;
         &lt;goals&gt;
            &lt;goal&gt;prepare-agent&lt;/goal&gt;
         &lt;/goals&gt;
      &lt;/execution&gt;
      &lt;execution&gt;
         &lt;id&gt;report&lt;/id&gt;
         &lt;phase&gt;prepare-package&lt;/phase&gt;
         &lt;goals&gt;
            &lt;goal&gt;report&lt;/goal&gt;
         &lt;/goals&gt;
      &lt;/execution&gt;
   &lt;/executions&gt;
&lt;/plugin&gt;</span></pre> <p><span class="koboSpan" id="kobo.556.1">The execution of JaCoCo’s Maven plugin</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.557.1"> will create a report inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">target/site</span></strong><span class="koboSpan" id="kobo.559.1"> folder, which can be easily viewed through any </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">web browser.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.561.1"><img alt="Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for each class" src="image/B20912_04_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.562.1">Figure 4.4 – The mini-website created by JaCoCo shows the test coverage for each class</span></p>
<p><span class="koboSpan" id="kobo.563.1">In this table, we find the only class in our project. </span><span class="koboSpan" id="kobo.563.2">We can see from the report that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">Calculator</span></strong><span class="koboSpan" id="kobo.565.1"> class has </span><strong class="bold"><span class="koboSpan" id="kobo.566.1">70%</span></strong><span class="koboSpan" id="kobo.567.1"> test coverage. </span><span class="koboSpan" id="kobo.567.2">This is because we haven’t performed any tests on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">multiply</span></strong><span class="koboSpan" id="kobo.569.1"> method. </span><span class="koboSpan" id="kobo.569.2">Let’s add a third unit test to our </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">test class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
@Test
void multiply() {
    var sum = calculator.multiply(6, 5);
    assertEquals(30, sum);
}</span></pre> <p><span class="koboSpan" id="kobo.572.1">Then, let’s run the JaCoCo Maven plugin again. </span><span class="koboSpan" id="kobo.572.2">The report will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.574.1"><img alt="Figure 4.5 – After adding a test case, coverage is now 100%" src="image/B20912_04_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.575.1">Figure 4.5 – After adding a test case, coverage is now 100%</span></p>
<p><span class="koboSpan" id="kobo.576.1">All the methods of </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">Calculator</span></strong><span class="koboSpan" id="kobo.578.1"> have been tested. </span><span class="koboSpan" id="kobo.578.2">The coverage </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">is </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.580.1">100%</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">What happens if we make changes? </span><span class="koboSpan" id="kobo.582.2">Let’s say, for</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.583.1"> example, we decide not to support negative results in the subtraction operation by adding a check that throws an exception when the subtrahend (the number that is subtracted from another number) is greater than the minuend (the number from which another number </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">is subtracted):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.585.1">
public Integer subtract(Integer minuend, Integer
  subtrahend) {
    if (subtrahend &gt; minuend) {
        throw new IllegalArgumentException("Minuend must be
           greater than the subtrahend");
    }
    return minuend - subtrahend;
}</span></pre> <p><span class="koboSpan" id="kobo.586.1">If we run JaCoCo again, we can notice something </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">very interesting:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.588.1"><img alt="Figure 4.6 – By adding a new feature without adding the relative test, the coverage decreases" src="image/B20912_04_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.589.1">Figure 4.6 – By adding a new feature without adding the relative test, the coverage decreases</span></p>
<p><span class="koboSpan" id="kobo.590.1">The coverage has decreased, and specifically, the </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">Missed Branches</span></strong><span class="koboSpan" id="kobo.592.1"> column has been populated. </span><span class="koboSpan" id="kobo.592.2">In the context of JaCoCo, a </span><em class="italic"><span class="koboSpan" id="kobo.593.1">branch</span></em><span class="koboSpan" id="kobo.594.1"> refers to a specific path or decision point in the code</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.595.1"> where the program flow can take different routes. </span><span class="koboSpan" id="kobo.595.2">Branches are typically associated with conditional statements, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">if</span></strong><span class="koboSpan" id="kobo.597.1">-</span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">else</span></strong><span class="koboSpan" id="kobo.599.1"> statements and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">switch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">-</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">case</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1"> statements.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">We can see which method is affected by clicking </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">Calculator</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.608.1"><img alt="Figure 4.7 – By clicking on the Calculator entry, it is clearer which of its methods is not fully covered" src="image/B20912_04_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.609.1">Figure 4.7 – By clicking on the Calculator entry, it is clearer which of its methods is not fully covered</span></p>
<p><span class="koboSpan" id="kobo.610.1">We can even click on the method</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.611.1"> to see which part of the code is </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">not covered:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.613.1"><img alt="Figure 4.8 – Clicking on the single method entry, it’s possible to see where the test coverage is missing" src="image/B20912_04_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.614.1">Figure 4.8 – Clicking on the single method entry, it’s possible to see where the test coverage is missing</span></p>
<p><span class="koboSpan" id="kobo.615.1">Since we have added an </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">if</span></strong><span class="koboSpan" id="kobo.617.1"> statement, we have created a branch. </span><span class="koboSpan" id="kobo.617.2">Whenever a branch is created, which represents a new possible execution flow, we must cover it with tests. </span><span class="koboSpan" id="kobo.617.3">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.619.1">
@Test
void subtractWithIllegalArgument() {
    assertThrows(IllegalArgumentException.class, () -&gt;
      calculator.subtract(10, 21));
}</span></pre> <p><span class="koboSpan" id="kobo.620.1">Let’s regenerate the report to see </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">the changes:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.622.1"><img alt="Figure 4.9 – Again, full coverage" src="image/B20912_04_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.623.1">Figure 4.9 – Again, full coverage</span></p>
<p><span class="koboSpan" id="kobo.624.1">The coverage is now back </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">to </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.626.1">100%</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">This is just the tip of the iceberg. </span><span class="koboSpan" id="kobo.628.2">JaCoCo is highly configurable (for example, you can configure branches and missed instructions) and can be used to completely block the build when a minimum coverage threshold is not met. </span><span class="koboSpan" id="kobo.628.3">You can exclude individual classes, class patterns, packages, and more. </span><span class="koboSpan" id="kobo.628.4">I strongly encourage you to explore this </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">tool further.</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">Now that we have roughly</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.631.1"> seen how JaCoCo works and, above all, what test coverage is, let’s delve further into our reasoning and try to understand why it is convenient, sensible, and extremely advantageous, when developing, not only to write tests but also to... </span><span class="koboSpan" id="kobo.631.2">start </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">with them!</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.633.1">Test-driven development</span></h1>
<p><span class="koboSpan" id="kobo.634.1">As the name suggests, </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">test-driven development</span></strong><span class="koboSpan" id="kobo.636.1">, abbreviated as </span><strong class="bold"><span class="koboSpan" id="kobo.637.1">TDD</span></strong><span class="koboSpan" id="kobo.638.1">, is a widely used software development</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.639.1"> practice in Agile methodologies, especially in </span><strong class="bold"><span class="koboSpan" id="kobo.640.1">Extreme Programming</span></strong><span class="koboSpan" id="kobo.641.1">. </span><span class="koboSpan" id="kobo.641.2">It is widely regarded as a fundamental technique for achieving</span><a id="_idIndexMarker347"/> <span class="No-Break"><span class="koboSpan" id="kobo.642.1">higher-quality software.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">As the name itself suggests, development is driven by tests, not the other way around. </span><span class="koboSpan" id="kobo.643.2">The classic development cycle involves </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.645.1"><img alt="Figure 4.10 – The classic development cycle involves designing, coding, and then testing" src="image/B20912_04_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.646.1">Figure 4.10 – The classic development cycle involves designing, coding, and then testing</span></p>
<p><span class="koboSpan" id="kobo.647.1">This is flipped around. </span><span class="koboSpan" id="kobo.647.2">We start with the tests to arrive at defining the design; of course, writing the code </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">in between:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.649.1"><img alt="Figure 4.11 – The TDD cycle starts with the tests" src="image/B20912_04_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.650.1">Figure 4.11 – The TDD cycle starts with the tests</span></p>
<p><span class="koboSpan" id="kobo.651.1">Attention is given to the functional</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.652.1"> aspects of the code, specifically the method signatures, before the actual implementation of the code. </span><span class="koboSpan" id="kobo.652.2">To start with the tests, you need to take the perspective of the “client” of your code and primarily consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">public methods:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.654.1">The methodology involves immediately writing a test; by executing this test (which requires defining an input, invoking a method, and asserting the result), the outcome will inevitably</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.655.1"> be a failure since the implementation</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.656.1"> does not exist yet. </span><span class="koboSpan" id="kobo.656.2">This phase is called </span><strong class="bold"><span class="koboSpan" id="kobo.657.1">Red</span></strong><span class="koboSpan" id="kobo.658.1"> (the color that commonly indicates a failure of a unit test in </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">many IDEs).</span></span></li>
<li><span class="koboSpan" id="kobo.660.1">The next step is to implement the missing functionality by writing the bare minimum to make the test pass as quickly </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.661.1">as possible. </span><span class="koboSpan" id="kobo.661.2">When the test passes, you are in the so-called </span><strong class="bold"><span class="koboSpan" id="kobo.662.1">Green</span></strong><span class="koboSpan" id="kobo.663.1"> phase. </span><span class="koboSpan" id="kobo.663.2">Don’t worry if the code</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.664.1"> you wrote is not perfect or if you think it could be improved; that will be addressed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">next phase.</span></span></li>
<li><span class="koboSpan" id="kobo.666.1">The third and final phase of TDD is </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">Refactor</span></strong><span class="koboSpan" id="kobo.668.1">, which allows you to transform your code</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.669.1"> by adapting, simplifying, streamlining, and</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.670.1"> removing duplicates. </span><span class="koboSpan" id="kobo.670.2">In this phase, you do not add new features, as it is purely a refactoring process. </span><span class="koboSpan" id="kobo.670.3">If you want to add new features, you must go back to the Red phase and start again </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">from there.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.672.1">Here is a diagram of the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">TDD process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.674.1"><img alt="Figure 4.12 – The TDD cycle" src="image/B20912_04_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.675.1">Figure 4.12 – The TDD cycle</span></p>
<p><span class="koboSpan" id="kobo.676.1">I think that by this point, you will have understood</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.677.1"> how cool this technique is; however, as with all things, there are not just advantages. </span><span class="koboSpan" id="kobo.677.2">Let’s take a closer look at the pros and cons of this methodology so that you can form your own opinion. </span><span class="koboSpan" id="kobo.677.3">As usual, don’t expect an exhaustive list; even though I tried to refer to the existing literature on the subject, much of it is influenced by my </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">personal experience.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.679.1">Advantages of TDD</span></h2>
<p><span class="koboSpan" id="kobo.680.1">Here are some advantages</span><a id="_idIndexMarker356"/> <span class="No-Break"><span class="koboSpan" id="kobo.681.1">of TDD:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.682.1">You only write code that’s needed</span></strong><span class="koboSpan" id="kobo.683.1">: According to the principles, it’s important to avoid writing production code right after all your tests pass. </span><span class="koboSpan" id="kobo.683.2">Instead, when your project requires a new feature, you should create a test first to guide the implementation process. </span><span class="koboSpan" id="kobo.683.3">The code you write should be the most straightforward and minimal necessary to fulfill the feature’s requirements. </span><span class="koboSpan" id="kobo.683.4">In this way, only the essential code to implement the features will end up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">final product.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.685.1">Fast failing</span></strong><span class="koboSpan" id="kobo.686.1">: The distinctive aspect of TDD is its ability to facilitate rapid failure. </span><span class="koboSpan" id="kobo.686.2">This shortens the feedback loop, allowing the development team to quickly determine whether the code is correct. </span><span class="koboSpan" id="kobo.686.3">Developers can conduct self-assessments and manual acceptance tests, while also engaging in peer-to-peer reviews. </span><span class="koboSpan" id="kobo.686.4">The outcome is a reduced turnaround time, leading to minimal defects </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">during testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.688.1">Continuous change</span></strong><span class="koboSpan" id="kobo.689.1">: As usual, most developers collaborate on the same code base. </span><span class="koboSpan" id="kobo.689.2">Whenever an individual developer starts working, CI tools detect the changes and promptly execute the unit tests, assessing the code within a few minutes. </span><span class="koboSpan" id="kobo.689.3">If any failures occur, they are promptly reported to the developers, who resolve the issues before proceeding to manual or integrated testing, ensuring that end users do not encounter </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">these problems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.691.1">Easier to maintain and refactor the code base</span></strong><span class="koboSpan" id="kobo.692.1">: Decoupling and clear interfaces make code more manageable. </span><span class="koboSpan" id="kobo.692.2">You can replace microfeature implementations without affecting other modules and rewrite the entire application with preserved tests. </span><span class="koboSpan" id="kobo.692.3">Thorough testing for each feature eliminates the fear of making changes. </span><span class="koboSpan" id="kobo.692.4">A complete test suite allows confident code improvements without breaking </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.694.1">Clear documentation</span></strong><span class="koboSpan" id="kobo.695.1">: TDD uses unit tests, which act as effective documentation, sparing the need for time-consuming and difficult-to-maintain written documentation. </span><span class="koboSpan" id="kobo.695.2">This aspect is a key characteristic of good test coverage overall. </span><span class="koboSpan" id="kobo.695.3">TDD significantly contributes to achieving comprehensive </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">test coverage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.697.1">Nudge to refactoring</span></strong><span class="koboSpan" id="kobo.698.1">: There is a dedicated Refactor step as part of the Red-Green-Refactor cycle, ensuring that developers think about improvements in the design for every single line</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.699.1"> of code that </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">they write.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.701.1">Development speed – a note</span></h3>
<p><span class="koboSpan" id="kobo.702.1">Especially at the beginning, the feeling</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.703.1"> is that of progressing very slowly. </span><span class="koboSpan" id="kobo.703.2">TDD is more focused on delivering quality code rather than delivering code quickly. </span><span class="koboSpan" id="kobo.703.3">People might also write too many tests that are similar or redundant, or perhaps write tests that are too simple or test trivial parts of the code. </span><span class="koboSpan" id="kobo.703.4">Until the mindset is well integrated within the team, it may take some time to proceed at a </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">decent pace.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">Anyway, when developers delay the creation of tests, it may initially appear to expedite the development process. </span><span class="koboSpan" id="kobo.705.2">However, this approach frequently results in tightly coupled code, rendering certain portions untestable. </span><span class="koboSpan" id="kobo.705.3">In the event of discovering bugs, the debugging phase can become a time-consuming and unpredictable task. </span><span class="koboSpan" id="kobo.705.4">Consequently, choosing to replace the uncertain and variable debugging process with a more predictable and structured testing procedure is often a </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">better idea.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">To summarize, TDD is a software development methodology in which developers create automated tests before writing the actual code. </span><span class="koboSpan" id="kobo.707.2">This process involves three main steps: writing a failing test that defines the desired functionality, writing the minimum code required to pass the test, and then refining the code while ensuring all tests continue to pass. </span><span class="koboSpan" id="kobo.707.3">It can be implemented over unit tests and also other kind of tests, such as integration tests. </span><span class="koboSpan" id="kobo.707.4">TDD encourages iterative</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.708.1"> development, improves code quality, and helps catch bugs early in the </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">development process.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.710.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.711.1">I hope I have conveyed to you the importance of testing, not only as a necessary condition for refactoring but also as a cornerstone of quality code. </span><span class="koboSpan" id="kobo.711.2">In this chapter, we have understood why testing is crucial and why it is beneficial to do it frequently, allowing us to fail as early as possible – this may appear like a paradox, but </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">it isn’t.</span></span></p>
<p><span class="koboSpan" id="kobo.713.1">We have various types of tests at our disposal, but we focused particularly on unit testing, for which a framework such as JUnit is of </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">great help.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">Since testing is essential, it is crucial to have as much of our code base covered by tests as possible. </span><span class="koboSpan" id="kobo.715.2">For this purpose, we have the assistance of another </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">tool, JaCoCo.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">Furthermore, we introduced the fundamental methodology TDD, reversing the traditional development flow to start with tests and then proceeding to write </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">Now that we have covered all the fundamentals, we can move on to the next chapter, where we will finally analyze some refactoring techniques, delving deeper into topics that we only briefly touched upon in the chapter on code smells – </span><a href="B20912_03.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.720.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.721.1">.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.722.1">Further reading</span></h1>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.723.1">The Confusion: Error vs. </span><span class="koboSpan" id="kobo.723.2">Fault vs. </span><span class="koboSpan" id="kobo.723.3">Bug vs. </span><span class="koboSpan" id="kobo.723.4">Defect vs. </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.724.1">Failure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">: </span></span><a href="https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b"><span class="No-Break"><span class="koboSpan" id="kobo.726.1">https://farhan-labib.medium.com/the-confusion-error-vs-fault-vs-bug-vs-defect-vs-failure-c557af04726b</span></span></a></li>
<li><span class="koboSpan" id="kobo.727.1">Getting started with Apache </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">JMeter: </span></span><a href="https://jmeter.apache.org/usermanual/get-started.html"><span class="No-Break"><span class="koboSpan" id="kobo.729.1">https://jmeter.apache.org/usermanual/get-started.html</span></span></a></li>
<li><span class="koboSpan" id="kobo.730.1">Customer </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">satisfaction: </span></span><a href="https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer"><span class="No-Break"><span class="koboSpan" id="kobo.732.1">https://www.linkedin.com/advice/1/what-key-performance-indicators-measuring-customer</span></span></a></li>
<li><span class="koboSpan" id="kobo.733.1">Continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">integration: </span></span><a href="https://en.wikipedia.org/wiki/Continuous_integration "><span class="No-Break"><span class="koboSpan" id="kobo.735.1">https://en.wikipedia.org/wiki/Continuous_integration</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.736.1">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</span></em><span class="koboSpan" id="kobo.737.1"> by Jez Humble and David Farley (</span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">Addison-Weasley, 2010)</span></span></li>
<li><span class="koboSpan" id="kobo.739.1">The JUnit framework’s official </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">website: </span></span><a href="https://junit.org/junit5/"><span class="No-Break"><span class="koboSpan" id="kobo.741.1">https://junit.org/junit5/</span></span></a></li>
<li><span class="koboSpan" id="kobo.742.1">Getting started with </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">Mockito: </span></span><a href="https://www.baeldung.com/mockito-series"><span class="No-Break"><span class="koboSpan" id="kobo.744.1">https://www.baeldung.com/mockito-series</span></span></a></li>
<li><span class="koboSpan" id="kobo.745.1">JaCoCo </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">website: </span></span><a href="https://www.jacoco.org/jacoco/"><span class="No-Break"><span class="koboSpan" id="kobo.747.1">https://www.jacoco.org/jacoco/</span></span></a></li>
</ul>
</div>
</body></html>