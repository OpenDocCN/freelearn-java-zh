- en: Using Platform APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how the Java platform has been modularized,
    what the modules look like and how to navigate and find more information about
    them. In this chapter, we'll get hands-on and implement and extend functionality
    in the address book viewer application by using some of the platform APIs. In
    the process, I'll walk you through the typical process of finding and using platform
    APIs, as well as how to organize application modules to have better reusability
    and modularity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the enhancements we''ll make to the address book viewer application
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll add logging logic to the application using the Java Logging APIs. This
    is not really a user-facing feature, but it's handy as a developer to be able
    to log informational and error messages from your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use XML APIs to read contact information from an XML file. The application
    currently has a bunch of hardcoded users. We'd like to update that to read from
    an XML file on a path that's provided by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll add a graphical user interface to the application by displaying a list
    of names. Clicking on a name in the list then displays detailed contact information
    of that contact. We'll be building this using the Java FX APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding features requires the usage of Java platform APIs. By achieving
    the preceding three objectives, you will have had good practice in establishing
    dependencies on and using the Java platform modules. Note that the focus in this
    chapter is on using the platform APIs and not on learning about the specific APIs
    themselves. So, even though you don't plan to use or learn about the Java XML
    APIs or the Java FX APIs, I still recommend you open your editor and follow through
    the steps covered in this chapter hands-on. Using these specific APIs in this
    chapter is just a means to learning about using platform APIs in general. Once
    you are done working on this chapter, you'll be in a much better position to browse
    and use other Java Platform APIs too.
  prefs: []
  type: TYPE_NORMAL
- en: We have a lot to cover, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging ability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with using the logging API in Java to log messages to the console.
    As an example, we want to be able to log some sample messages during the application
    start and completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''d typically do in Java 8 or earlier is just import the necessary logging
    classes and start using the logging APIs. That is, the `Logger` class from the `java.util.logging` package.
    However, as we''ve learned in the previous chapter, there''s an additional step
    in Java 9\. Using the logging APIs directly will result in a compilation error.
    That''s because the logging APIs aren''t available in the `java.base` module.
    We''ve seen that the best way to search for a module is using the `--list-modules` parameter
    to the `java` command. Let''s run that and see if we find a module related to
    logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s a module called `java.logging`. That looks promising!
    The next step is to see if that module exports the APIs we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Good news! It does. The `java.logging` module exports the package `java.util.logging`,
    which is just what we need. Let''s add this module as a dependency in the `packt.addressbook` module
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are free to use the logging APIs in our code. In the `Main.java` class,
    first import the `Logger` class and create a static `logger` variable by initializing
    `Logger` with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the logger to log a message both at the start and the end
    of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the modules by running this command in the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute with the `java` command and you should get output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we''ve successfully integrated logging APIs into our application.
    This is the simplest of the three use cases we''ll be looking at in this chapter.
    The usage of the logging platform API involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the need for a platform module--with the `requires` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of the platform module APIs in the Java source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an alternative compiler command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we begin creating more modules, the compiler command will continue to grow.
    This is because we need to specify every module in the module path that needs
    compilation directly in the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a macOS/Unix/Linux operating systems, there''s an alternative
    way you can get all the modules compiled, and I find this method shorter and easier.
    Remember in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*, we listed all the Java classes directly in
    the command for the compiler to compile. Now rather than entering all the classes
    in all the modules manually in the command, the idea is to use the Unix `find`
    command with a command line wildcard to get all the file names with the `.java`
    extension and plug them in directly.  The below command illustrates how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The part of the command  `$(find . -name '*.java')` expands all the file names
    of the Java files (as specified by `-name '*.java'`) in the current folder (as
    specified by the  `.` ), including nested subfolders, in one go. Since this command
    is shorter and much easier on the eyes, I'll be using this version from now on.
    This format also has the additional advantage of being consistent. You can pretty
    much copy-paste this command to compile all modules in the module current directory,
    irrespective of how many modules you have. If you are on Windows, or if you prefer
    to use the `--module` format, make sure you specify all the individual module
    names following the `--module` option.
  prefs: []
  type: TYPE_NORMAL
- en: Reading contacts from an XML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next improvement we'll make is to have the address book viewer application
    read an XML file to get contact information instead of a hard-coded list. There
    are a couple of nuances with this integration, so let's try that out now!
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of contacts being displayed by the address book viewer is from hard-coded
    data in the `ContactUtil` class. Here''s the sample structure of the XML file
    we''d like to read it from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The root node is `addressbook` and within it are several `contact` child nodes.
    Each `contact` node has `firstname`, `lastname`, and a nested `address` node,
    as shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have the application read from an XML file, what we''d like to
    do is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the existing hardcoded logic from the module`packt.addressbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement functionality of opening and reading the XML file in a separate module.
    This module will contain code to read from the source XML file and return a list
    of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the *main* address book module to depend on this new module to get the
    list of contacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fact that we need to do #1 is obvious. But why #2 and #3? Why move that
    portion of the code to its own module? Well, as you can imagine, there''s no *right*
    answer for this one.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of modularization is to achieve the separation of monolithic code into
    modular building blocks that can be freely reused and replaced. Consider the scenario
    where, in the future, you decide to *not* use an XML file to store the data, but
    instead, read from a JSON file. Or a database. Or even a REST API! No matter what
    the new source is, the fact that there is this one separate module that acts as
    a *provider* of the list of contacts makes the change relatively easy. All you
    have to do then is to remove the XML-based module we'll create now and plug in
    a new module that reads from the new source of data. Granted, you'll still need
    to change the consumers to depend on the new module. But the change will be minimized,
    and so will the scope of any side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the hard-coded contact list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin by removing the hard-coded source of contacts. This is fairly
    simple. You''ll need to delete the `ContactUtil.java` class in the package `packt.addressbook.util`.
    We are now left with a couple of lines of code in `Main.java` that are not valid
    anymore. Let''s remove those two lines too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Creating the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's create a new module that holds code that acts as a source of contact
    information. I'll call the module `packt.contact`. You should know the drill by
    now. Create a new module root folder with the name `packt.contact` in the `src`
    folder, just where the other module root folders reside. Next, create a `module-info.java`
    module descriptor in the module root folder.
  prefs: []
  type: TYPE_NORMAL
- en: What modules do we need here? Since this module needs the XML APIs, we'll have
    to declare it with the `requires` statement. We saw in the previous chapter that
    there's a module called `java.xml` that contains the XML APIs. Of course, a way
    of searching for the right module is using the `java --list-modules` command as
    before. here's the module descriptor with this dependency added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code in this module belongs to two classes. First is the class `ContactLoader`
    in the package `packt.contact.util`. This class contains the method `loadContacts`
    that takes in the filename of the XML file to read and it returns the list of
    `Contact` objects. This is the method that consumers of this module will call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that the name of the method is the generic `loadContacts`, and contains
    no particular indication that what it's loading from is an XML file. This is again
    useful to achieve the abstraction, and the module could very well change its functionality
    in the future to read contacts from another source or file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second class `XMLUtil` consists of some generic but handy XML utility methods.
    These are methods that the `ContactLoader` class will use to read and parse XML.
    Since this aspect of dealing with XML is not the *purpose* of this module, this
    class will be in a separate `packt.contact.internal` package so that it can be
    protected against use outside the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the file and folder structure of the module at this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Coding the XmlUtil class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now add the first of two methods to the  `XmlUtil`--a `loadXmlFile()`
    method that takes in an XML filename as a `String`, parses it, and returns an
    XML document object.
  prefs: []
  type: TYPE_NORMAL
- en: The code involves opening the file to get a `File` object. Then, using the DOM
    XML API, we create a `DocumentBuilderFactory`. With that, we create a new `DocumentBuilder`.
    And with that, we parse the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the method in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the exceptions that the method throws. The three exceptions are a result
    of using the File API to open the file and the XML API to parse it. Rather than
    have the method catch the exception, which it wouldn't really know what to do
    with, it throws them. These exceptions have an interesting implication to modularity
    that we'll look at shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method is `getElement()`, which takes in an XML node and the element
    name to return the value of that element in the node. If no value is found, an
    empty string is returned. This is all XML API specific and not too interesting
    for us in the context of this chapter, so here''s the method in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are done with `XmlUtil`. We'll now move on to the more interesting
    `ContactLoader` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the ContactLoader class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen that `ContactLoader` should have a single method `loadContacts()` ,
    which takes as argument the file name and returns a list of `Contacts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the method, we initialize a new instance of `XmlUtil` and use the `loadXmlFile`
    method to get the XML Document object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now what's left is processing the resulting DOM object structure and constructing
    the list of contacts in the model type we need. Again, to avoid getting into too
    much detail about XML, I'll just point you to the bundled source code at `05-jdk-modules/src/packt.contact`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of problems with the `packt.contact` module right now--shared
    classes and dependency leakage. One of which you might have already noticed.
  prefs: []
  type: TYPE_NORMAL
- en: Shared classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the more obvious of the two problems. We've created a new module and
    designed a method in a class to return a list of `Contact` instances. The problem
    is that the `Contact` and `Address` model classes are not in the module! They
    are in the `packt.addressbook` module. Compiling this module now will result in
    a compilation error about the two classes not found. How do we solve this?
  prefs: []
  type: TYPE_NORMAL
- en: Here's a thought. How about depending on the module that contains the classes?
    The `packt.contact` module needs the `Contact` and `Address` classes that are
    available in the `packt.addressbook` module. Could we have the `packt.contact` module
    require the `packt.addressbook` module? We'll of course also need the dependency
    the other way round. `packt.addressbook` needs to `requires packt.contact` to
    get the list of contacts. Can this be done? Turns out it cannot, because it introduces
    circular dependencies, which are not allowed by the Java module system.
  prefs: []
  type: TYPE_NORMAL
- en: A **circular dependency** is when two or more modules depend on each other in
    such a way that the dependency graph forms a loop. Both of the examples in the
    following diagram represent circular dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows two circular dependency scenarios. Modules **A**
    and **B** depend on each other, forming a circular dependency. In the second example,
    to the right, module **Z** reads **X**, **X** reads **Y**, and **Y**, in turn,
    reads **Z**. This is also a circular dependency, now between three modules. If
    the Java platform encounters circular dependencies like these, it''ll throw an
    error and fail to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Circular dependencies are disallowed by the Java module system because it invalidates
    the concept of modules having **directed** dependencies. Think back to the module
    graph we've been drawing. There is a sense in which dependencies have **direction**
    and when one module depends on another, there's a directed arrow drawn from the
    former to the latter. Having circular dependencies, or as they are often called, **cyclic**
    dependencies implies that the two modules are so closely tied to each other, that
    the idea of splitting them into two separate modules becomes moot. If one module
    cannot exist without the other, what's the point in having them as separate modules
    anyway?
  prefs: []
  type: TYPE_NORMAL
- en: It is important to have the module graph as a **directed acyclic graph**. This
    is a type of graph, which as the name says, is **directed**, as in you can arrange
    all the nodes in such a way that there is a top-down direction of all dependencies,
    and it is **acyclic,** as in there are no loops.
  prefs: []
  type: TYPE_NORMAL
- en: Since we cannot implement circular dependencies, we are left with two options
    to solve this problem. First option--move the model classes from `packt.addressbook`
    to `packt.contact` and have `packt.contact` export them. This way, since `packt.addressbook`
    requires `packt.contact` anyway, it gets to use the model classes too.
  prefs: []
  type: TYPE_NORMAL
- en: The second option is to create a separate module for the model classes and have
    both `packt.addressbook` and `packt.contact` require them. This also allows for
    other modules to possibly use the model classes. For the sake of simplicity, I'll
    go with the first approach and move the model classes into `packt.contact` for
    now. In a similar real-world use case, you may want to consider the anticipated
    usage of such shared classes to decide whether they warrant a separate module.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the model classes in the `packt.contact` module, here''s how the module
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `module-info.java` needs to be updated to `export` the util and model packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Dependency leakage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the second problem with the way we''ve built the `packt.contact` module,
    and this one may not be all that obvious. Here''s the method signature of the
    method in `ContactLoader` that we want consumers of this module to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What does a consumer of this module need to do to access this method? First,
    the consuming module needs to `require packt.contact`. With that, they have access
    to `ContactLoader` in their module. They can then call the `loadContacts` method
    in one of their classes. But wait! Since the `loadContacts()` throws three exceptions,
    the consuming method will need to catch them too!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And herein lies the problem. The code from the consuming module is forced to
    use XML exception classes in order to catch them. `IOException` is from `java.lang`,
    so all modules get it because of the implicit `java.base` dependency. But the
    consuming modules don't automatically have access to `ParserConfigurationException`
    or `SAXException` , since they are classes from the `java.xml` module. The only
    way `loadContacts()` can be used by other modules is if they also `require java.xml`
    overtime they use `packt.contact`. Even if they are not using any XML APIs themselves.
    So much for encapsulating XML functionality!
  prefs: []
  type: TYPE_NORMAL
- en: While this is a workable solution, we don't want to build modules that enforce
    dependencies like this. Ideally, a module should be self-sufficient, and shouldn't
    necessitate other peer dependencies just to make it usable. There are a couple
    of ways to solve this problem. One way is to establish what's called a *transitive*
    dependency in the `packt.contact` module. Transitive dependency is a way in which
    the module system allows you to configure modules to declare automatic peer dependencies.
    For example, you can have a dependency on `packt.contact` also establish a dependency
    on `java.xml` automatically, so that any module that has a dependency on the former
    also gets the latter. We'll learn more about transitive dependencies in [Chapter
    6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module Resolution,
    Accessibility, and Readability*.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this case, that's not ideal either. We want to tuck away anything
    XML-related into `packt.contact` and not have any XML classes leak into the consuming
    module. So, in this case, we'll create a custom exception and throw that when
    anything goes wrong. We'll make sure the exception is in an exported package,
    so that the consuming module gets the exception automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call the class `ContactLoadException` and place it in the `packt.contact.util`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `ContactLoader` needs to catch the XML exceptions and throw the custom
    exception instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we've completely isolated the XML-related functionality into `packt.contact`
    and none of the modules that uses it needs to deal with the XML APIs.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the `packt.contact` module. We can now move on to
    `packt.addressbook` and use this module.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the new module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we establish a dependency in `packt.addressbook`. Here''s the `module-info.java`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `Main.java`, we create a new instance of `ContactLoader` and call
    the `loadContacts` method by passing in the path to the XML file. Using the `input.xml`
    file that is bundled with the source code, here''s what it takes to read the file
    and return `Contact` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `catch` block uses the `logger` instance previously created to log the exception
    message and exit the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the complete `Main` method with these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling and executing the application now will result in an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Nice work! In the process of adding XML functionality into the address book
    viewer application, you've handled a couple of issues and design considerations
    when dealing with modules. Let's move on to the third objective in this chapter--integrating
    with the Java FX APIs to create a UI for our address book viewer application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI with Java FX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create a UI application that allows us to click and browse contact
    information. We will be using the Java FX APIs to create and display the UI. As
    in the last section, I should highlight that the focus here is not for us to learn
    the JavaFX API itself. In fact, I'll be glossing over most of the Java FX API
    details in this section because that's beyond the scope of this book, although
    the full working code is available for you to peruse if you are interested. The
    intention of this exercise is for us to learn how to use Java APIs and how to
    handle the different usage scenarios and nuances that come with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll do to add UI to the address book application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new module called `packt.addressbook.ui` which contains code to display
    the address book in a Java FX powered user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the `packt.addressbook.ui` module depend on `packt.contacts` to get the
    list of `Contact` instances. Also have the module depend on `packt.sortutil` to
    sort the `Contact` instances by last name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating the new module `packt.addressbook.ui`. As before,
    create the module root folder with the same name in the project folder, and then
    create the module descriptor `module-info.java`. We already know that we need
    to depend on `packt.contacts` and `packt.sortutil`, so let''s add those two dependencies
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We need to use the JavaFX libraries in this module, so we need to use the `requires`
    clause in the module descriptor to specify this dependency. How do we know what
    the libraries are? The answer is the same as earlier--using `java --list-modules`
    and `java -d <module-name>`. But before we browse for what modules to depend on,
    we should know what APIs we need! Let's look at the code we'll need to write to
    build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a Main.java class in the package `packt.addressbook.ui`. This
    class will launch the UI. As with any Java FX app, the class that *launches* the
    application is required to extend `javafx.application.Application`. We then override
    the `start` method and add the functionality of building the UI in it. This method
    is called by the JavaFX framework to launch our application. Remember this method!
    We will revisit this shortly when we execute the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `start` method, the logic to get the `Contact` instances and to sort
    them is exactly the same as the command-line application in the `packt.addressbook`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s different in this case is what we do with the sorted list of `Contacts`.
    We don''t just print it to the console. Instead, we will build a JavaFX `ListView`
    that displays the list. We''ll also add a click handler to each element in the
    list, so that when a name is clicked, we can display the details of that contact
    to the right of the list. Here''s what we''d like the UI to look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Without going into too much detail of how the JavaFX controls are built and
    displayed, here''s the core functionality that builds the list of `Contacts` from
    the list that `sortutil` has sorted, and handles click events on the list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code wires in the logic we are already familiar with (the `ContactLoader`
    and `SortUtil`) into the JavaFX code that displays that data in a UI for browsing.
    We have used quite a lot of JavaFX APIs here, as we normally would when building
    a JavaFX application like this. Now that we know what the APIs we need to use
    are, we next need to find the modules that `exports` these APIs and set up dependencies
    in the `packt.addressbook.ui` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `java --list-modules` command, we see there are multiple modules
    associated with JavaFX. Those are the ones that start with the `javafx.` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To know the packages we use, all we need to do is look at the list of imports
    in the `Main.java` class. We can examine the package level information for each
    of the JavaFX modules to get the set of modules that together have all the packages
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `javafx.base` exports `javafx.collections` that we use in `Main.java`.
    So, that''s a module we''ll be adding. Here are more modules we are interested
    in. The left column shows the package we need, and used in our Java code. The
    right column is the Java platform module that exports that package (which we find
    by running `java -d <module-name>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this, the three modules we''ll need to require are `javafx.base`,
    `javafx.controls`, and `javafx.graphics`. Let''s add these three into the `packt.addressbook.ui`
    module definition using the `requires` clause. Here''s `module-info.java` when
    we are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While we've found the packages exported by the modules and we are technically
    not wrong in what we've required, this step could be done in a much better way.
    We actually needed to require just one JavaFX module here! This is thanks to a
    certain qualifier called `transitive`. We will be covering more about what that
    is and how it affects our dependencies in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*. But, since we haven't covered
    it yet, let's go with adding all three JavaFX modules for now.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like the process of finding these dependencies by running the
  prefs: []
  type: TYPE_NORMAL
- en: '`--list-modules` command is tedious, well, you are not alone! This is something
    that I hope will quickly be unnecessary once IDEs get support for Java 9\. Ideally,
    an IDE should be able to help us identify the modules based on the packages we
    import into our Java applications, and preferably add the modules to the module
    descriptor automatically. This feature might already be available in most of the
    standard IDEs by the time you are reading this!'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so with this, we have all the dependencies established. Let''s give this
    a go! Compile all modules using the  `javac` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code should compile without any errors. Let''s try to execute it. Since
    we are running the Main.java file in the new module `packt.addressbook.ui`, make
    sure you specify that in the command this time. Notice that we get an error when
    we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The error indicates that the module `javafx.graphics` is trying to access our
    `Main` class and is unable to access it because our module `packt.addressbook.ui`
    doesn't export it! You might be wondering what business the module `javafx.graphics`
    has with a class we wrote! Why would it need to access our class?
  prefs: []
  type: TYPE_NORMAL
- en: Turns out the answer is because of the way JavaFX works. Remember that I mentioned
    about the `start()` method in `Main.java` and how the JavaFX framework calls that
    method to launch the application. The framework uses reflection to identify classes
    that extend the `Application` class. The framework then uses that information
    to launch the JavaFX application by calling the `start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: And there is our problem. In the module descriptor of `packt.addressbook.ui`,
    we don't export the package that `Main` is in, that is `packt.addressbook.ui`.
    So, `Main` is not accessible to any code outside the module, and so JavaFX cannot
    launch the application! The encapsulation that applied to static access of types
    outside the module is in effect even for runtime reflective access!
  prefs: []
  type: TYPE_NORMAL
- en: One way to solve this problem is by making `Main` public. We just need to export
    the package that the type is in. That's enough for JavaFX to access it. That also
    actually enables *any* module to access it! This may or may not be what you want.
    But for now, let's export the package and make `Main.java` available externally.
    We'll revisit this too in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability,* and find a better way to
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the final `module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the application again, and everything should work this time
    around. A GUI window should load with the list of contacts sorted by last name.
    Clicking on a name should display the details on the right-hand side. You can
    close the application by clicking the close button on the title bar.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve made several enhancements to the address book application to make use
    of some platform APIs and learnt some lessons on how to find and use platform
    modules, as well as how to handle some tricky scenarios that showed up along the
    way. Here''s what we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: We used the `java.logging` module to add logging functionality to the `packt.addressbook`
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `java.xml` module and created a new custom module that reads and
    parses an XML file to return a list of model objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We encountered two problems--shared code and dependency leakage and we implemented
    a strategy to get around those problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the JavaFX modules to build a UI for the address book. We created a
    new module that leveraged our existing contact and sort modules to build this
    UI. We learnt about the impact of modularity on reflection. We got around the
    problem by just exporting the class that needed access by the framework, although
    we'll be learning a better way to do this in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One additional point that I want to highlight is how, in this chapter, we were
    able to leverage the modules that we'd already built to create a new custom GUI
    module. Notice that we didn't have to mess around with existing code and pile
    up logic and functionality on them with if clauses. We were easily able to create
    a new module for GUI, and thanks to the other core functionality being separate
    modules, we were just able to use them as building blocks to create a brand new
    module with all the functionality we needed. The `packt.contact` and `packt.sortutil`
    aren't aware of where they are being used, so they technically don't care!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at a few more tricks that the Java module system
    has up its sleeve! We'll also deep-dive into concepts related to readability and
    gain an understanding of more powerful ways to make different modules accessible
    to one another.
  prefs: []
  type: TYPE_NORMAL
