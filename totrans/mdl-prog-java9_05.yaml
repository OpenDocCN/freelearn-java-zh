- en: Using Platform APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用平台 API
- en: In the previous chapter, we looked at how the Java platform has been modularized,
    what the modules look like and how to navigate and find more information about
    them. In this chapter, we'll get hands-on and implement and extend functionality
    in the address book viewer application by using some of the platform APIs. In
    the process, I'll walk you through the typical process of finding and using platform
    APIs, as well as how to organize application modules to have better reusability
    and modularity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Java 平台的模块化过程，模块的形态以及如何导航和查找更多关于它们的信息。在本章中，我们将通过使用一些平台 API 来实际操作，并在地址簿查看器应用程序中实现和扩展功能。在这个过程中，我将向您展示查找和使用平台
    API 的典型流程，以及如何组织应用程序模块以实现更好的重用性和模块化。
- en: 'Here are the enhancements we''ll make to the address book viewer application
    in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将对地址簿查看器应用程序进行以下增强：
- en: We'll add logging logic to the application using the Java Logging APIs. This
    is not really a user-facing feature, but it's handy as a developer to be able
    to log informational and error messages from your application.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 Java 日志记录 API 将日志逻辑添加到应用程序中。这并不是一个面向用户的功能，但对于开发者来说，能够从应用程序中记录信息和错误消息是非常方便的。
- en: We'll use XML APIs to read contact information from an XML file. The application
    currently has a bunch of hardcoded users. We'd like to update that to read from
    an XML file on a path that's provided by the user.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 XML API 从 XML 文件中读取联系信息。当前的应用程序中有一堆硬编码的用户。我们希望将其更新为从用户提供的路径上的 XML 文件中读取。
- en: We'll add a graphical user interface to the application by displaying a list
    of names. Clicking on a name in the list then displays detailed contact information
    of that contact. We'll be building this using the Java FX APIs.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将通过显示姓名列表来为应用程序添加图形用户界面。点击列表中的姓名将显示该联系人的详细联系信息。我们将使用 Java FX API 来构建这个功能。
- en: All of the preceding features requires the usage of Java platform APIs. By achieving
    the preceding three objectives, you will have had good practice in establishing
    dependencies on and using the Java platform modules. Note that the focus in this
    chapter is on using the platform APIs and not on learning about the specific APIs
    themselves. So, even though you don't plan to use or learn about the Java XML
    APIs or the Java FX APIs, I still recommend you open your editor and follow through
    the steps covered in this chapter hands-on. Using these specific APIs in this
    chapter is just a means to learning about using platform APIs in general. Once
    you are done working on this chapter, you'll be in a much better position to browse
    and use other Java Platform APIs too.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的上述功能都需要使用 Java 平台 API。通过实现上述三个目标，您将已经在建立对 Java 平台模块的依赖和使用方面有了良好的实践。请注意，本章的重点在于使用平台
    API，而不是学习具体的 API。因此，即使您不打算使用或学习 Java XML API 或 Java FX API，我仍然建议您打开您的编辑器并亲手完成本章中涵盖的步骤。在本章中使用这些特定的
    API 只是为了学习如何一般性地使用平台 API。完成本章的工作后，您将能够更好地浏览和使用其他 Java 平台 API。
- en: We have a lot to cover, so let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多内容要介绍，所以让我们开始吧！
- en: Adding logging ability
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加日志功能
- en: Let's start with using the logging API in Java to log messages to the console.
    As an example, we want to be able to log some sample messages during the application
    start and completion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在 Java 中使用日志记录 API 将消息记录到控制台开始。作为一个例子，我们希望在应用程序启动和完成时能够记录一些示例消息。
- en: 'What we''d typically do in Java 8 or earlier is just import the necessary logging
    classes and start using the logging APIs. That is, the `Logger` class from the `java.util.logging` package.
    However, as we''ve learned in the previous chapter, there''s an additional step
    in Java 9\. Using the logging APIs directly will result in a compilation error.
    That''s because the logging APIs aren''t available in the `java.base` module.
    We''ve seen that the best way to search for a module is using the `--list-modules` parameter
    to the `java` command. Let''s run that and see if we find a module related to
    logging:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 或更早版本中，我们通常会直接导入必要的日志类并开始使用日志 API。也就是说，从 `java.util.logging` 包中的 `Logger`
    类。然而，正如我们在上一章中学到的，Java 9 中有一个额外的步骤。直接使用日志 API 将导致编译错误。这是因为日志 API 不在 `java.base`
    模块中可用。我们已经看到，使用 `java` 命令的 `--list-modules` 参数是搜索模块的最佳方式。让我们运行它并查看是否能找到与日志相关的模块：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, there''s a module called `java.logging`. That looks promising!
    The next step is to see if that module exports the APIs we need:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有一个名为 `java.logging` 的模块，看起来很有希望！下一步是看看这个模块是否导出了我们需要的 API：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Good news! It does. The `java.logging` module exports the package `java.util.logging`,
    which is just what we need. Let''s add this module as a dependency in the `packt.addressbook` module
    first:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！是的，`java.logging` 模块导出了 `java.util.logging` 包，这正是我们所需要的。让我们首先将这个模块作为依赖项添加到
    `packt.addressbook` 模块中：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we are free to use the logging APIs in our code. In the `Main.java` class,
    first import the `Logger` class and create a static `logger` variable by initializing
    `Logger` with the class name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地在代码中使用日志记录 API。在 `Main.java` 类中，首先导入 `Logger` 类，并通过使用类名初始化 `Logger`
    来创建一个静态的 `logger` 变量：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we can use the logger to log a message both at the start and the end
    of the application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以使用记录器在应用程序的开始和结束时记录一条消息：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compile the modules by running this command in the project root directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录中运行此命令来编译模块：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute with the `java` command and you should get output that looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java` 命令执行，你应该得到类似以下的输出：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this, we''ve successfully integrated logging APIs into our application.
    This is the simplest of the three use cases we''ll be looking at in this chapter.
    The usage of the logging platform API involved:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经成功地将日志记录 API 集成到我们的应用程序中。这是本章我们将要探讨的三个用例中最简单的一个。使用日志平台 API 的部分涉及：
- en: Declaring the need for a platform module--with the `requires` statement
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明需要平台模块——使用 `requires` 语句
- en: Usage of the platform module APIs in the Java source
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Java 源中使用平台模块 API
- en: Using an alternative compiler command
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用替代的编译命令
- en: As we begin creating more modules, the compiler command will continue to grow.
    This is because we need to specify every module in the module path that needs
    compilation directly in the command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始创建更多模块，编译命令将继续增长。这是因为我们需要在命令中直接指定每个需要编译的模块在模块路径中的位置。
- en: 'If you are using a macOS/Unix/Linux operating systems, there''s an alternative
    way you can get all the modules compiled, and I find this method shorter and easier.
    Remember in [Chapter 2](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb),
    *Creating Your First Java Module*, we listed all the Java classes directly in
    the command for the compiler to compile. Now rather than entering all the classes
    in all the modules manually in the command, the idea is to use the Unix `find`
    command with a command line wildcard to get all the file names with the `.java`
    extension and plug them in directly.  The below command illustrates how this works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 macOS/Unix/Linux 操作系统，有一个替代的方法可以编译所有模块，我发现这个方法更短，更容易。记住在 [第 2 章](part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb)，*创建你的第一个
    Java 模块*中，我们直接在编译器的命令中列出了所有 Java 类。现在，我们不再需要手动在命令中输入所有模块中的所有类，而是使用 Unix 的 `find`
    命令和命令行通配符来获取所有具有 `.java` 扩展名的文件名，并将其直接插入。以下命令说明了这是如何工作的：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The part of the command  `$(find . -name '*.java')` expands all the file names
    of the Java files (as specified by `-name '*.java'`) in the current folder (as
    specified by the  `.` ), including nested subfolders, in one go. Since this command
    is shorter and much easier on the eyes, I'll be using this version from now on.
    This format also has the additional advantage of being consistent. You can pretty
    much copy-paste this command to compile all modules in the module current directory,
    irrespective of how many modules you have. If you are on Windows, or if you prefer
    to use the `--module` format, make sure you specify all the individual module
    names following the `--module` option.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 `$(find . -name '*.java')` 一次性展开当前文件夹（由 `.` 指定）中所有 Java 文件的文件名（由 `-name '*.java'`
    指定），包括嵌套的子文件夹。由于这个命令更短，更容易阅读，所以我将从现在开始使用这个版本。这种格式还有一个额外的优势，就是一致性。你可以基本上复制粘贴这个命令来编译当前目录中的所有模块，无论你有多少个模块。如果你使用的是
    Windows，或者你更喜欢使用 `--module` 格式，确保你指定所有单个模块名称，紧随 `--module` 选项之后。
- en: Reading contacts from an XML file
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 XML 文件中读取联系人
- en: The next improvement we'll make is to have the address book viewer application
    read an XML file to get contact information instead of a hard-coded list. There
    are a couple of nuances with this integration, so let's try that out now!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的改进是将地址簿查看器应用程序读取 XML 文件以获取联系人信息，而不是使用硬编码的列表。这个集成有几个细微之处，所以现在让我们试试看！
- en: 'The list of contacts being displayed by the address book viewer is from hard-coded
    data in the `ContactUtil` class. Here''s the sample structure of the XML file
    we''d like to read it from:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 地址簿查看器显示的联系人列表来自`ContactUtil`类中的硬编码数据。以下是我们要从中读取的XML文件的示例结构：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The root node is `addressbook` and within it are several `contact` child nodes.
    Each `contact` node has `firstname`, `lastname`, and a nested `address` node,
    as shown.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点是`addressbook`，其中包含几个`contact`子节点。每个`contact`节点都有`firstname`、`lastname`和一个嵌套的`address`节点，如下所示。
- en: 'In order to have the application read from an XML file, what we''d like to
    do is the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让应用程序从XML文件中读取，我们想做的如下：
- en: Remove the existing hardcoded logic from the module`packt.addressbook`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模块`packt.addressbook`中移除现有的硬编码逻辑。
- en: Implement functionality of opening and reading the XML file in a separate module.
    This module will contain code to read from the source XML file and return a list
    of contacts.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的模块中实现打开和读取XML文件的功能。这个模块将包含从源XML文件读取并返回联系人列表的代码。
- en: Update the *main* address book module to depend on this new module to get the
    list of contacts.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新主地址簿模块，使其依赖于这个新的模块以获取联系人列表。
- en: 'The fact that we need to do #1 is obvious. But why #2 and #3? Why move that
    portion of the code to its own module? Well, as you can imagine, there''s no *right*
    answer for this one.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做#1的事实是显而易见的。但为什么是#2和#3？为什么将代码的这一部分移动到自己的模块中？嗯，正如你可以想象的那样，这个问题没有*正确*的答案。
- en: The goal of modularization is to achieve the separation of monolithic code into
    modular building blocks that can be freely reused and replaced. Consider the scenario
    where, in the future, you decide to *not* use an XML file to store the data, but
    instead, read from a JSON file. Or a database. Or even a REST API! No matter what
    the new source is, the fact that there is this one separate module that acts as
    a *provider* of the list of contacts makes the change relatively easy. All you
    have to do then is to remove the XML-based module we'll create now and plug in
    a new module that reads from the new source of data. Granted, you'll still need
    to change the consumers to depend on the new module. But the change will be minimized,
    and so will the scope of any side effects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的目标是实现将单体代码分离成可自由重用和替换的模块化构建块。考虑这样一个场景，在未来，你决定*不*使用XML文件来存储数据，而是从JSON文件、数据库或甚至REST
    API中读取。无论新的数据源是什么，事实是存在这样一个独立的模块，它作为联系人列表的*提供者*，使得更改相对容易。你所需做的就是移除我们现在创建的基于XML的模块，并插入一个新的模块，该模块从新的数据源读取。当然，你仍然需要更改消费者以依赖于新的模块。但更改将最小化，任何副作用的影响范围也将缩小。
- en: Removing the hard-coded contact list
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除硬编码的联系人列表
- en: 'Let''s begin by removing the hard-coded source of contacts. This is fairly
    simple. You''ll need to delete the `ContactUtil.java` class in the package `packt.addressbook.util`.
    We are now left with a couple of lines of code in `Main.java` that are not valid
    anymore. Let''s remove those two lines too:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先移除硬编码的联系人数据源。这相当简单。你需要删除`packt.addressbook.util`包中的`ContactUtil.java`类。现在我们在`Main.java`中剩下几行代码已经不再有效。让我们也移除这两行：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating the module
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: Now let's create a new module that holds code that acts as a source of contact
    information. I'll call the module `packt.contact`. You should know the drill by
    now. Create a new module root folder with the name `packt.contact` in the `src`
    folder, just where the other module root folders reside. Next, create a `module-info.java`
    module descriptor in the module root folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的模块，该模块包含作为联系人信息源的代码。我将这个模块命名为`packt.contact`。你现在应该很熟悉这个过程了。在`src`文件夹中创建一个名为`packt.contact`的新模块根文件夹，就在其他模块根文件夹所在的位置。接下来，在模块根文件夹中创建一个`module-info.java`模块描述符。
- en: What modules do we need here? Since this module needs the XML APIs, we'll have
    to declare it with the `requires` statement. We saw in the previous chapter that
    there's a module called `java.xml` that contains the XML APIs. Of course, a way
    of searching for the right module is using the `java --list-modules` command as
    before. here's the module descriptor with this dependency added.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要哪些模块？由于这个模块需要XML API，我们必须使用`requires`语句来声明它。我们在上一章中看到有一个名为`java.xml`的模块，其中包含XML
    API。当然，使用`java --list-modules`命令来搜索正确的模块也是一种方法。以下是添加了这个依赖关系的模块描述符。
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The source code in this module belongs to two classes. First is the class `ContactLoader`
    in the package `packt.contact.util`. This class contains the method `loadContacts`
    that takes in the filename of the XML file to read and it returns the list of
    `Contact` objects. This is the method that consumers of this module will call:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本模块的源代码属于两个类。首先是位于 `packt.contact.util` 包中的 `ContactLoader` 类。这个类包含一个 `loadContacts`
    方法，它接受要读取的 XML 文件名，并返回 `Contact` 对象的列表。这是模块消费者将调用的方法：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the name of the method is the generic `loadContacts`, and contains
    no particular indication that what it's loading from is an XML file. This is again
    useful to achieve the abstraction, and the module could very well change its functionality
    in the future to read contacts from another source or file format.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该方法的名称是通用的 `loadContacts`，并且没有特别指出它从 XML 文件中加载。这再次有助于实现抽象，并且该模块完全有可能在未来更改其功能，从其他来源或文件格式读取联系人。
- en: 'The second class `XMLUtil` consists of some generic but handy XML utility methods.
    These are methods that the `ContactLoader` class will use to read and parse XML.
    Since this aspect of dealing with XML is not the *purpose* of this module, this
    class will be in a separate `packt.contact.internal` package so that it can be
    protected against use outside the module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类 `XMLUtil` 包含一些通用的但实用的 XML 工具方法。这些是 `ContactLoader` 类将用于读取和解析 XML 的方法。由于处理
    XML 的这一方面不是本模块的 *目的*，因此该类将位于单独的 `packt.contact.internal` 包中，以便可以防止在模块外部使用：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s the file and folder structure of the module at this time:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是这个模块的文件和文件夹结构：
- en: '![](img/00049.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: Coding the XmlUtil class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 XmlUtil 类
- en: Let's now add the first of two methods to the  `XmlUtil`--a `loadXmlFile()`
    method that takes in an XML filename as a `String`, parses it, and returns an
    XML document object.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将第一个方法添加到 `XmlUtil` 中——一个 `loadXmlFile()` 方法，它接受一个 XML 文件名作为 `String`，解析它，并返回一个
    XML 文档对象。
- en: The code involves opening the file to get a `File` object. Then, using the DOM
    XML API, we create a `DocumentBuilderFactory`. With that, we create a new `DocumentBuilder`.
    And with that, we parse the input file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码涉及打开文件以获取 `File` 对象。然后，使用 DOM XML API，我们创建一个 `DocumentBuilderFactory`。有了这个，我们创建一个新的
    `DocumentBuilder`。然后，我们解析输入文件。
- en: 'The following is the method in its entirety:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该方法的全部内容：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the exceptions that the method throws. The three exceptions are a result
    of using the File API to open the file and the XML API to parse it. Rather than
    have the method catch the exception, which it wouldn't really know what to do
    with, it throws them. These exceptions have an interesting implication to modularity
    that we'll look at shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意该方法抛出的异常。这三个异常是使用文件 API 打开文件和 XML API 解析文件的结果。而不是让该方法捕获异常，因为它实际上不知道该如何处理，它抛出了这些异常。这些异常对模块化有一个有趣的含义，我们将在稍后探讨。
- en: 'The second method is `getElement()`, which takes in an XML node and the element
    name to return the value of that element in the node. If no value is found, an
    empty string is returned. This is all XML API specific and not too interesting
    for us in the context of this chapter, so here''s the method in its entirety:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是 `getElement()`，它接受一个 XML 节点和元素名称，以返回该节点中该元素的值。如果没有找到值，则返回一个空字符串。这完全是
    XML API 特定的，对我们来说在本章的上下文中并不太有趣，所以这里是该方法的全部内容：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this, we are done with `XmlUtil`. We'll now move on to the more interesting
    `ContactLoader` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们就完成了 `XmlUtil`。现在，我们将继续探讨更有趣的 `ContactLoader` 类。
- en: Coding the ContactLoader class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 ContactLoader 类
- en: 'We''ve already seen that `ContactLoader` should have a single method `loadContacts()` ,
    which takes as argument the file name and returns a list of `Contacts`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `ContactLoader` 应该有一个单一的方法 `loadContacts()`，它接受文件名作为参数，并返回一个 `Contacts`
    列表：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the method, we initialize a new instance of `XmlUtil` and use the `loadXmlFile`
    method to get the XML Document object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，我们初始化 `XmlUtil` 的新实例，并使用 `loadXmlFile` 方法获取 XML 文档对象：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now what's left is processing the resulting DOM object structure and constructing
    the list of contacts in the model type we need. Again, to avoid getting into too
    much detail about XML, I'll just point you to the bundled source code at `05-jdk-modules/src/packt.contact`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的是处理生成的 DOM 对象结构，并构建我们需要的模型类型中的联系人列表。为了避免过多地详细介绍 XML，我将仅向您指出捆绑的源代码位于 `05-jdk-modules/src/packt.contact`。
- en: There are a couple of problems with the `packt.contact` module right now--shared
    classes and dependency leakage. One of which you might have already noticed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 目前`packt.contact`模块存在一些问题--共享类和依赖泄露。其中之一你可能已经注意到了。
- en: Shared classes
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享类
- en: This is the more obvious of the two problems. We've created a new module and
    designed a method in a class to return a list of `Contact` instances. The problem
    is that the `Contact` and `Address` model classes are not in the module! They
    are in the `packt.addressbook` module. Compiling this module now will result in
    a compilation error about the two classes not found. How do we solve this?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个问题中更明显的一个。我们创建了一个新的模块，并在一个类中设计了一个方法来返回`Contact`实例的列表。问题是`Contact`和`Address`模型类不在模块中！它们在`packt.addressbook`模块中。现在编译这个模块将导致关于这两个类未找到的编译错误。我们该如何解决这个问题？
- en: Here's a thought. How about depending on the module that contains the classes?
    The `packt.contact` module needs the `Contact` and `Address` classes that are
    available in the `packt.addressbook` module. Could we have the `packt.contact` module
    require the `packt.addressbook` module? We'll of course also need the dependency
    the other way round. `packt.addressbook` needs to `requires packt.contact` to
    get the list of contacts. Can this be done? Turns out it cannot, because it introduces
    circular dependencies, which are not allowed by the Java module system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个想法。我们是否可以依赖于包含这些类的模块？`packt.contact`模块需要`packt.addressbook`模块中可用的`Contact`和`Address`类。我们能否让`packt.contact`模块要求`packt.addressbook`模块？当然，我们还需要双向的依赖。`packt.addressbook`需要`requires
    packt.contact`以获取联系人列表。这能行吗？结果是不能，因为这引入了循环依赖，而Java模块系统不允许循环依赖。
- en: A **circular dependency** is when two or more modules depend on each other in
    such a way that the dependency graph forms a loop. Both of the examples in the
    following diagram represent circular dependencies.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环依赖**是指两个或多个模块以这种方式相互依赖，以至于依赖图形成一个循环。下面图中的两个例子都代表了循环依赖。'
- en: 'The following diagram shows two circular dependency scenarios. Modules **A**
    and **B** depend on each other, forming a circular dependency. In the second example,
    to the right, module **Z** reads **X**, **X** reads **Y**, and **Y**, in turn,
    reads **Z**. This is also a circular dependency, now between three modules. If
    the Java platform encounters circular dependencies like these, it''ll throw an
    error and fail to work:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了两种循环依赖场景。模块**A**和**B**相互依赖，形成一个循环依赖。在第二个例子中，右侧，模块**Z**读取**X**，**X**读取**Y**，而**Y**反过来读取**Z**。这也是一个循环依赖，现在是在三个模块之间。如果Java平台遇到这样的循环依赖，它会抛出一个错误并无法工作：
- en: '![](img/00050.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00050.jpeg)'
- en: Circular dependencies are disallowed by the Java module system because it invalidates
    the concept of modules having **directed** dependencies. Think back to the module
    graph we've been drawing. There is a sense in which dependencies have **direction**
    and when one module depends on another, there's a directed arrow drawn from the
    former to the latter. Having circular dependencies, or as they are often called, **cyclic**
    dependencies implies that the two modules are so closely tied to each other, that
    the idea of splitting them into two separate modules becomes moot. If one module
    cannot exist without the other, what's the point in having them as separate modules
    anyway?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Java模块系统不允许循环依赖，因为这会破坏模块具有**有向**依赖的概念。回想一下我们一直在绘制的模块图。在某种意义上，依赖关系是有**方向**的，当一个模块依赖于另一个模块时，会从前者到后者画出一个有向箭头。存在循环依赖，或者如它们通常所说的，**循环**依赖意味着两个模块之间联系如此紧密，以至于将它们分成两个独立的模块的想法变得没有意义。如果一个模块没有另一个模块就无法存在，那么将它们作为独立模块的意义又在哪里呢？
- en: It is important to have the module graph as a **directed acyclic graph**. This
    is a type of graph, which as the name says, is **directed**, as in you can arrange
    all the nodes in such a way that there is a top-down direction of all dependencies,
    and it is **acyclic,** as in there are no loops.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个**有向无环图**的模块图是很重要的。这种图，正如其名所示，是**有向**的，也就是说你可以以这样的方式排列所有节点，使得所有依赖关系都有一个自上而下的方向，并且它是**无环**的，也就是说没有循环。
- en: Since we cannot implement circular dependencies, we are left with two options
    to solve this problem. First option--move the model classes from `packt.addressbook`
    to `packt.contact` and have `packt.contact` export them. This way, since `packt.addressbook`
    requires `packt.contact` anyway, it gets to use the model classes too.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能实现循环依赖，我们只剩下两个选项来解决这个问题。第一个选项是将模型类从`packt.addressbook`移动到`packt.contact`，并让`packt.contact`导出它们。这样，由于`packt.addressbook`无论如何都需要`packt.contact`，它也可以使用模型类。
- en: The second option is to create a separate module for the model classes and have
    both `packt.addressbook` and `packt.contact` require them. This also allows for
    other modules to possibly use the model classes. For the sake of simplicity, I'll
    go with the first approach and move the model classes into `packt.contact` for
    now. In a similar real-world use case, you may want to consider the anticipated
    usage of such shared classes to decide whether they warrant a separate module.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是为模型类创建一个单独的模块，并让`packt.addressbook`和`packt.contact`都要求使用它们。这也允许其他模块可能使用模型类。为了简单起见，我将采用第一种方法，并将模型类暂时移动到`packt.contact`中。在类似的真实世界用例中，你可能需要考虑这些共享类的预期使用情况，以决定它们是否需要单独的模块。
- en: 'With the model classes in the `packt.contact` module, here''s how the module
    looks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`packt.contact`模块中，模型类是这样的：
- en: '![](img/00051.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'The `module-info.java` needs to be updated to `export` the util and model packages:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新`module-info.java`以`export` util和model包：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Dependency leakage
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖泄露
- en: 'Here''s the second problem with the way we''ve built the `packt.contact` module,
    and this one may not be all that obvious. Here''s the method signature of the
    method in `ContactLoader` that we want consumers of this module to call:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在构建`packt.contact`模块时遇到的第二个问题，这个问题可能并不那么明显。这是`ContactLoader`中我们希望模块消费者调用的方法的签名：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What does a consumer of this module need to do to access this method? First,
    the consuming module needs to `require packt.contact`. With that, they have access
    to `ContactLoader` in their module. They can then call the `loadContacts` method
    in one of their classes. But wait! Since the `loadContacts()` throws three exceptions,
    the consuming method will need to catch them too!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者模块需要做什么才能访问这个方法？首先，消费模块需要`require packt.contact`。有了这个，他们就可以访问他们模块中的`ContactLoader`。然后，他们可以在他们的某个类中调用`loadContacts`方法。但是等等！由于`loadContacts()`抛出了三个异常，消费方法也需要捕获它们！
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And herein lies the problem. The code from the consuming module is forced to
    use XML exception classes in order to catch them. `IOException` is from `java.lang`,
    so all modules get it because of the implicit `java.base` dependency. But the
    consuming modules don't automatically have access to `ParserConfigurationException`
    or `SAXException` , since they are classes from the `java.xml` module. The only
    way `loadContacts()` can be used by other modules is if they also `require java.xml`
    overtime they use `packt.contact`. Even if they are not using any XML APIs themselves.
    So much for encapsulating XML functionality!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题就出在这里。消费模块的代码被迫使用XML异常类来捕获它们。`IOException`来自`java.lang`，因此所有模块都因为它隐含的`java.base`依赖而获得它。但是，消费模块并不自动有权访问`ParserConfigurationException`或`SAXException`，因为它们是来自`java.xml`模块的类。`loadContacts()`能够被其他模块使用，唯一的办法是它们在每次使用`packt.contact`时也`require
    java.xml`。即使它们自己没有使用任何XML API。这样封装XML功能就太好了！
- en: While this is a workable solution, we don't want to build modules that enforce
    dependencies like this. Ideally, a module should be self-sufficient, and shouldn't
    necessitate other peer dependencies just to make it usable. There are a couple
    of ways to solve this problem. One way is to establish what's called a *transitive*
    dependency in the `packt.contact` module. Transitive dependency is a way in which
    the module system allows you to configure modules to declare automatic peer dependencies.
    For example, you can have a dependency on `packt.contact` also establish a dependency
    on `java.xml` automatically, so that any module that has a dependency on the former
    also gets the latter. We'll learn more about transitive dependencies in [Chapter
    6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb), *Module Resolution,
    Accessibility, and Readability*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个可行的解决方案，但我们不希望构建强制依赖这样的模块。理想情况下，一个模块应该是自给自足的，并且不应该需要其他对等依赖才能使其可用。解决这个问题有几个方法。一种方法是在`packt.contact`模块中建立所谓的*传递性依赖关系*。传递性依赖关系是模块系统允许你配置模块以声明自动对等依赖关系的一种方式。例如，你可以对`packt.contact`有一个依赖关系，同时也自动建立对`java.xml`的依赖关系，这样任何对前者有依赖关系的模块也会得到后者。我们将在第6章中了解更多关于传递性依赖关系的信息，*模块解析、可访问性和可读性*。
- en: However, in this case, that's not ideal either. We want to tuck away anything
    XML-related into `packt.contact` and not have any XML classes leak into the consuming
    module. So, in this case, we'll create a custom exception and throw that when
    anything goes wrong. We'll make sure the exception is in an exported package,
    so that the consuming module gets the exception automatically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，这也不是最佳选择。我们希望将所有与XML相关的功能都放入`packt.contact`中，并且不要有任何XML类泄漏到消费模块中。因此，在这种情况下，我们将创建一个自定义异常，并在出现任何错误时抛出它。我们将确保异常位于一个导出包中，这样消费模块就可以自动获取异常。
- en: 'We''ll call the class `ContactLoadException` and place it in the `packt.contact.util`
    package:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将类命名为`ContactLoadException`并将其放置在`packt.contact.util`包中：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now `ContactLoader` needs to catch the XML exceptions and throw the custom
    exception instead:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ContactLoader`需要捕获XML异常并抛出自定义异常：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Great! Now we've completely isolated the XML-related functionality into `packt.contact`
    and none of the modules that uses it needs to deal with the XML APIs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经完全将XML相关的功能隔离到`packt.contact`中，并且使用它的任何模块都不需要处理XML API。
- en: With this, we are done with the `packt.contact` module. We can now move on to
    `packt.addressbook` and use this module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了`packt.contact`模块。现在我们可以继续进行到`packt.addressbook`并使用此模块。
- en: Consuming the new module
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费新的模块
- en: 'First, we establish a dependency in `packt.addressbook`. Here''s the `module-info.java`
    file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`packt.addressbook`中建立一个依赖关系。以下是`module-info.java`文件：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, in `Main.java`, we create a new instance of `ContactLoader` and call
    the `loadContacts` method by passing in the path to the XML file. Using the `input.xml`
    file that is bundled with the source code, here''s what it takes to read the file
    and return `Contact` instances:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Main.java`中，我们创建一个新的`ContactLoader`实例，并通过传递XML文件的路径来调用`loadContacts`方法。使用与源代码捆绑的`input.xml`文件，以下是读取文件并返回`Contact`实例的步骤：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `catch` block uses the `logger` instance previously created to log the exception
    message and exit the application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块使用之前创建的`logger`实例来记录异常消息并退出应用程序。'
- en: 'Here''s the complete `Main` method with these changes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含这些更改的完整`Main`方法：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compiling and executing the application now will result in an output as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并执行应用程序将产生以下输出：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Nice work! In the process of adding XML functionality into the address book
    viewer application, you've handled a couple of issues and design considerations
    when dealing with modules. Let's move on to the third objective in this chapter--integrating
    with the Java FX APIs to create a UI for our address book viewer application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在将XML功能添加到地址簿查看器应用程序的过程中，你处理了一些模块相关的问题和设计考虑。让我们继续本章的第三个目标——与Java FX API集成以创建地址簿查看器应用程序的UI。
- en: Adding UI with Java FX
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java FX添加UI
- en: Let's now create a UI application that allows us to click and browse contact
    information. We will be using the Java FX APIs to create and display the UI. As
    in the last section, I should highlight that the focus here is not for us to learn
    the JavaFX API itself. In fact, I'll be glossing over most of the Java FX API
    details in this section because that's beyond the scope of this book, although
    the full working code is available for you to peruse if you are interested. The
    intention of this exercise is for us to learn how to use Java APIs and how to
    handle the different usage scenarios and nuances that come with it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个UI应用程序，允许我们点击并浏览联系人信息。我们将使用Java FX API来创建和显示UI。与上一节一样，我应该强调这里的重点不是让我们学习JavaFX
    API本身。实际上，在本节中，我将略过大多数Java FX API的细节，因为那超出了本书的范围，尽管完整的源代码是可用的，如果你感兴趣的话。这个练习的目的是让我们学习如何使用Java
    API以及如何处理与之相关的不同使用场景和细微差别。
- en: 'Here''s what we''ll do to add UI to the address book application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在地址簿应用程序中添加UI的步骤如下：
- en: Create a new module called `packt.addressbook.ui` which contains code to display
    the address book in a Java FX powered user interface.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`packt.addressbook.ui`的新模块，其中包含用于在Java FX用户界面中显示地址簿的代码。
- en: Have the `packt.addressbook.ui` module depend on `packt.contacts` to get the
    list of `Contact` instances. Also have the module depend on `packt.sortutil` to
    sort the `Contact` instances by last name.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`packt.addressbook.ui`模块依赖`packt.contacts`以获取`Contact`实例的列表。同时让模块依赖`packt.sortutil`以按姓氏对`Contact`实例进行排序。
- en: Creating the module
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'Let''s start by creating the new module `packt.addressbook.ui`. As before,
    create the module root folder with the same name in the project folder, and then
    create the module descriptor `module-info.java`. We already know that we need
    to depend on `packt.contacts` and `packt.sortutil`, so let''s add those two dependencies
    first:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建新的模块`packt.addressbook.ui`。和之前一样，在项目文件夹中创建具有相同名称的模块根文件夹，然后创建模块描述符`module-info.java`。我们已经知道我们需要依赖`packt.contacts`和`packt.sortutil`，所以让我们先添加这两个依赖项：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We need to use the JavaFX libraries in this module, so we need to use the `requires`
    clause in the module descriptor to specify this dependency. How do we know what
    the libraries are? The answer is the same as earlier--using `java --list-modules`
    and `java -d <module-name>`. But before we browse for what modules to depend on,
    we should know what APIs we need! Let's look at the code we'll need to write to
    build the UI.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模块中，我们需要使用JavaFX库，因此我们需要在模块描述符中使用`requires`子句来指定这个依赖项。我们如何知道需要哪些库？答案是和之前一样——使用`java
    --list-modules`和`java -d <module-name>`。但在我们浏览依赖的模块之前，我们应该知道我们需要哪些API！让我们看看我们需要编写的代码来构建UI。
- en: 'We''ll create a Main.java class in the package `packt.addressbook.ui`. This
    class will launch the UI. As with any Java FX app, the class that *launches* the
    application is required to extend `javafx.application.Application`. We then override
    the `start` method and add the functionality of building the UI in it. This method
    is called by the JavaFX framework to launch our application. Remember this method!
    We will revisit this shortly when we execute the code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`packt.addressbook.ui`包中创建一个`Main.java`类。这个类将启动UI。与任何Java FX应用程序一样，启动应用程序的类必须扩展`javafx.application.Application`。然后我们重写`start`方法，并在其中添加构建UI的功能。这个方法由JavaFX框架调用以启动我们的应用程序。记住这个方法！我们将在执行代码时很快再次回到这里：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `start` method, the logic to get the `Contact` instances and to sort
    them is exactly the same as the command-line application in the `packt.addressbook`
    module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`start`方法中，获取`Contact`实例并进行排序的逻辑与`packt.addressbook`模块中的命令行应用程序完全相同：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What''s different in this case is what we do with the sorted list of `Contacts`.
    We don''t just print it to the console. Instead, we will build a JavaFX `ListView`
    that displays the list. We''ll also add a click handler to each element in the
    list, so that when a name is clicked, we can display the details of that contact
    to the right of the list. Here''s what we''d like the UI to look like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，与以往不同的地方在于我们对排序后的`Contacts`列表的处理方式。我们不仅仅将其打印到控制台。相反，我们将构建一个JavaFX `ListView`来显示这个列表。我们还会为列表中的每个元素添加一个点击处理程序，这样当点击一个名字时，我们就可以在列表右侧显示该联系人的详细信息。以下是我们希望UI看起来像什么：
- en: '![](img/00052.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00052.jpeg)'
- en: 'Without going into too much detail of how the JavaFX controls are built and
    displayed, here''s the core functionality that builds the list of `Contacts` from
    the list that `sortutil` has sorted, and handles click events on the list item:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在不深入探讨 JavaFX 控件的构建和显示细节的情况下，这里的核心功能是从 `sortutil` 排序后的列表中构建 `Contacts` 列表，并处理列表项上的点击事件：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code wires in the logic we are already familiar with (the `ContactLoader`
    and `SortUtil`) into the JavaFX code that displays that data in a UI for browsing.
    We have used quite a lot of JavaFX APIs here, as we normally would when building
    a JavaFX application like this. Now that we know what the APIs we need to use
    are, we next need to find the modules that `exports` these APIs and set up dependencies
    in the `packt.addressbook.ui` module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将我们已熟悉的逻辑（`ContactLoader` 和 `SortUtil`）连接到显示数据的 JavaFX 代码中，以便在 UI 中浏览。我们在这里使用了相当多的
    JavaFX API，就像我们通常在构建类似这样的 JavaFX 应用程序时一样。现在我们已经知道了我们需要使用的 API，接下来我们需要找到导出这些 API
    的模块，并在 `packt.addressbook.ui` 模块中设置依赖关系。
- en: 'Using the `java --list-modules` command, we see there are multiple modules
    associated with JavaFX. Those are the ones that start with the `javafx.` prefix:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `java --list-modules` 命令，我们可以看到与 JavaFX 相关的多个模块。这些模块都是以 `javafx.` 前缀开始的：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To know the packages we use, all we need to do is look at the list of imports
    in the `Main.java` class. We can examine the package level information for each
    of the JavaFX modules to get the set of modules that together have all the packages
    we need.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道我们使用的包，我们只需要查看 `Main.java` 类中的导入列表。我们可以检查每个 JavaFX 模块的包级别信息，以获取所有我们需要包的模块集合。
- en: 'For example, `javafx.base` exports `javafx.collections` that we use in `Main.java`.
    So, that''s a module we''ll be adding. Here are more modules we are interested
    in. The left column shows the package we need, and used in our Java code. The
    right column is the Java platform module that exports that package (which we find
    by running `java -d <module-name>`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`javafx.base` 导出了我们在 `Main.java` 中使用的 `javafx.collections`。因此，这是一个我们需要添加的模块。以下是更多我们感兴趣的模块。左侧列出了我们需要的包，以及在我们
    Java 代码中使用的情况。右侧列出了导出该包的 Java 平台模块（我们通过运行 `java -d <module-name>` 找到）：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Based on this, the three modules we''ll need to require are `javafx.base`,
    `javafx.controls`, and `javafx.graphics`. Let''s add these three into the `packt.addressbook.ui`
    module definition using the `requires` clause. Here''s `module-info.java` when
    we are done:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们需要添加的三个模块是 `javafx.base`、`javafx.controls` 和 `javafx.graphics`。让我们使用 `requires`
    子句将这些三个模块添加到 `packt.addressbook.ui` 模块定义中。完成之后，这是 `module-info.java` 文件的内容：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While we've found the packages exported by the modules and we are technically
    not wrong in what we've required, this step could be done in a much better way.
    We actually needed to require just one JavaFX module here! This is thanks to a
    certain qualifier called `transitive`. We will be covering more about what that
    is and how it affects our dependencies in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability*. But, since we haven't covered
    it yet, let's go with adding all three JavaFX modules for now.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经找到了模块导出的包，并且我们在技术上所要求的并没有错误，但这一步可以做得更好。实际上，我们只需要在这里要求一个 JavaFX 模块！这要归功于一个名为
    `transitive` 的特定限定符。我们将在第 6 章[Module Resolution, Accessibility, and Readability](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)中更详细地介绍这个限定符是什么以及它如何影响我们的依赖关系。但由于我们还没有介绍它，现在我们先添加所有三个
    JavaFX 模块。
- en: If you feel like the process of finding these dependencies by running the
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得通过运行
- en: '`--list-modules` command is tedious, well, you are not alone! This is something
    that I hope will quickly be unnecessary once IDEs get support for Java 9\. Ideally,
    an IDE should be able to help us identify the modules based on the packages we
    import into our Java applications, and preferably add the modules to the module
    descriptor automatically. This feature might already be available in most of the
    standard IDEs by the time you are reading this!'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`--list-modules` 命令很繁琐，不过，你并不孤单！我希望一旦 IDE 支持了 Java 9，这很快就会变得不再必要。理想情况下，IDE
    应该能够根据我们导入到 Java 应用程序中的包来帮助我们识别模块，并且最好能够自动将模块添加到模块描述符中。这个功能在你阅读本文时可能已经在大多数标准 IDE
    中可用！'
- en: 'OK, so with this, we have all the dependencies established. Let''s give this
    a go! Compile all modules using the  `javac` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以，有了这些，我们已经建立了所有的依赖关系。让我们试试看！使用 `javac` 命令编译所有模块：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The code should compile without any errors. Let''s try to execute it. Since
    we are running the Main.java file in the new module `packt.addressbook.ui`, make
    sure you specify that in the command this time. Notice that we get an error when
    we run the code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该能够无错误地编译。让我们尝试执行它。由于我们正在运行位于新模块`packt.addressbook.ui`中的`Main.java`文件，请确保这次在命令中指定它。请注意，当我们运行代码时，我们会得到一个错误：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The error indicates that the module `javafx.graphics` is trying to access our
    `Main` class and is unable to access it because our module `packt.addressbook.ui`
    doesn't export it! You might be wondering what business the module `javafx.graphics`
    has with a class we wrote! Why would it need to access our class?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 错误表明，模块`javafx.graphics`正在尝试访问我们的`Main`类，但由于我们的模块`packt.addressbook.ui`没有导出它，因此无法访问它！你可能会想知道模块`javafx.graphics`与我们编写的类有什么关系！为什么它需要访问我们的类？
- en: Turns out the answer is because of the way JavaFX works. Remember that I mentioned
    about the `start()` method in `Main.java` and how the JavaFX framework calls that
    method to launch the application. The framework uses reflection to identify classes
    that extend the `Application` class. The framework then uses that information
    to launch the JavaFX application by calling the `start()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，答案是JavaFX的工作方式。记得我提到过`Main.java`中的`start()`方法以及JavaFX框架如何调用该方法来启动应用程序。框架使用反射来识别扩展`Application`类的类。然后，框架使用这些信息通过调用`start()`方法来启动JavaFX应用程序。
- en: And there is our problem. In the module descriptor of `packt.addressbook.ui`,
    we don't export the package that `Main` is in, that is `packt.addressbook.ui`.
    So, `Main` is not accessible to any code outside the module, and so JavaFX cannot
    launch the application! The encapsulation that applied to static access of types
    outside the module is in effect even for runtime reflective access!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的问题。在`packt.addressbook.ui`的模块描述符中，我们没有导出`Main`所在的包，即`packt.addressbook.ui`。因此，`Main`对模块外部的任何代码都是不可访问的，所以JavaFX无法启动应用程序！应用于模块外部类型静态访问的封装在运行时反射访问中仍然有效！
- en: One way to solve this problem is by making `Main` public. We just need to export
    the package that the type is in. That's enough for JavaFX to access it. That also
    actually enables *any* module to access it! This may or may not be what you want.
    But for now, let's export the package and make `Main.java` available externally.
    We'll revisit this too in [Chapter 6](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb),
    *Module Resolution, Accessibility, and Readability,* and find a better way to
    do this.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是将`Main`设置为公共的。我们只需要导出类型所在的包。这足以让JavaFX访问它。这也实际上允许任何模块访问它！这可能是你想要的，也可能不是。但就目前而言，让我们导出这个包，并使`Main.java`对外可用。我们也会在[第6章](part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb)“模块解析、可访问性和可读性”中重新审视这个问题，并找到更好的解决方案。
- en: 'Here''s the final `module-info.java`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是最终的`module-info.java`文件：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Compile and run the application again, and everything should work this time
    around. A GUI window should load with the list of contacts sorted by last name.
    Clicking on a name should display the details on the right-hand side. You can
    close the application by clicking the close button on the title bar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译并运行应用程序，这次应该一切正常。一个GUI窗口应该加载带有按姓氏排序的联系人列表。点击一个名字应该在右侧显示详细信息。你可以通过点击标题栏上的关闭按钮来关闭应用程序。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve made several enhancements to the address book application to make use
    of some platform APIs and learnt some lessons on how to find and use platform
    modules, as well as how to handle some tricky scenarios that showed up along the
    way. Here''s what we have done so far:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对地址簿应用程序进行了几项改进，以利用一些平台API，并从中学习了一些关于如何查找和使用平台模块的教训，以及如何处理沿途出现的一些棘手场景。以下是到目前为止我们所做的工作：
- en: We used the `java.logging` module to add logging functionality to the `packt.addressbook`
    module.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`java.logging`模块为`packt.addressbook`模块添加了日志功能。
- en: We used the `java.xml` module and created a new custom module that reads and
    parses an XML file to return a list of model objects.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`java.xml`模块并创建了一个新的自定义模块，该模块读取并解析XML文件以返回模型对象的列表。
- en: We encountered two problems--shared code and dependency leakage and we implemented
    a strategy to get around those problems.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遇到了两个问题——共享代码和依赖泄露，并实施了一种策略来绕过这些问题。
- en: We used the JavaFX modules to build a UI for the address book. We created a
    new module that leveraged our existing contact and sort modules to build this
    UI. We learnt about the impact of modularity on reflection. We got around the
    problem by just exporting the class that needed access by the framework, although
    we'll be learning a better way to do this in the next chapter.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了JavaFX模块来构建地址簿的用户界面。我们创建了一个新的模块，该模块利用我们现有的联系人和排序模块来构建这个UI。我们了解了模块化对反射的影响。我们通过仅导出框架需要访问的类来解决这个问题，尽管我们将在下一章学习更好的方法来做这件事。
- en: One additional point that I want to highlight is how, in this chapter, we were
    able to leverage the modules that we'd already built to create a new custom GUI
    module. Notice that we didn't have to mess around with existing code and pile
    up logic and functionality on them with if clauses. We were easily able to create
    a new module for GUI, and thanks to the other core functionality being separate
    modules, we were just able to use them as building blocks to create a brand new
    module with all the functionality we needed. The `packt.contact` and `packt.sortutil`
    aren't aware of where they are being used, so they technically don't care!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想强调一点，在本章中，我们是如何利用我们已经构建的模块来创建一个新的自定义GUI模块的。请注意，我们不必与现有代码纠缠，也不需要用if语句在它们上面堆砌逻辑和功能。我们轻松地创建了一个新的GUI模块，多亏了其他核心功能是独立的模块，我们只需将它们作为构建块来创建一个全新的模块，这个模块包含了我们需要的所有功能。`packt.contact`和`packt.sortutil`并不关心它们被用在何处，所以从技术上讲，它们并不在乎！
- en: In the next chapter, we'll look at a few more tricks that the Java module system
    has up its sleeve! We'll also deep-dive into concepts related to readability and
    gain an understanding of more powerful ways to make different modules accessible
    to one another.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Java模块系统的一些更多技巧！我们还将深入研究与可读性相关的概念，并了解使不同模块之间相互访问的更强大方式。
