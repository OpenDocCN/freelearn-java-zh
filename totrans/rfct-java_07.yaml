- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static and Dynamic Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our way to clean, robust, and maintainable code, we’ll often need to “take
    a look” at how our software works and how it’s written. After identifying the
    code smells and doing some refactoring steps (in fact, we should never stop doing
    this!), it can be useful to scan our code for design flaws, security vulnerabilities,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: This analysis can be carried out directly on the code – that is, static analysis
    – or on the running program – that is, (without involving too much imagination)
    dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic analysis tools scrutinize code to identify issues and inefficiencies.
    Their insights provide the foundation for improvements, and this is where refactoring
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is static analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we need static analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some static analysis tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is dynamic analysis?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some dynamic analysis techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is static analysis?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name may suggest, **static analysis** in the context of Java (or any
    programming language, actually) refers to the process of analyzing source code
    without running it. It is a technique that’s used to find issues, potential bugs,
    security vulnerabilities, and other issues in the code before it is run or compiled.
    Static analysis tools are used for this purpose (we’ll jump into that shortly).
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of reasons to perform static analysis; let’s see some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Code errors or bad practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first one we will show you may seem trivial, but it is the main reason
    we scan our code in search of problems – that is, problems in the code! Which
    problems? We’ll put them under the generic term of coding errors – that is, mistakes
    made by programmers when writing code (yes, it turns out that even programmers
    make mistakes – no matter how much experience they have, programmers still make
    mistakes. But, as they gain more experience, they’re more likely to own up to
    their errors!). These errors can lead to a variety of problems, including crashes,
    unexpected behavior, and security vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could have **null pointer dereferences** when a program tries to access
    a memory location that has not been initialized, as shown here. This can lead
    to crashes and other unexpected behavior:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, we have a null reference (`text`) to a string, and attempting
    to access its `length()` method leads to a `NullPointerException`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`if` statement that is always false. Unreachable code is not harmful, but it
    can make code more difficult to read and maintain. In general, it is useless,
    and we do not like useless code (unless your pay increases with the number of
    code lines you write, but we don’t believe that’s the case). Here’s an example
    of the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Class cast exceptions**, on the other hand, are runtime exceptions in Java
    that occur when you try to cast an object to a type that is not compatible with
    the object’s actual type. In other words, you’re trying to convert an object into
    a type that it is not, resulting in an exception:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a very simple problem that is usually detected by your IDE while you’re
    writing code, but still, that is an example of static analysis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some static analysis tools can also detect some bad practices; one of the most
    common is a class implementing a `compareTo` method but then you’re using `equals`.
    When you implement the `compareTo()` method, it’s important to ensure that you
    also override the `equals()` method. This ensures consistency in how objects of
    the class are compared for ordering and equality:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of this method is probably not what we wanted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@Override'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (o == null || getClass() != o.getClass()) return false;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return this.compareTo(o) == 0;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, a good static analysis of your code can detect **duplicated code**,
    which in my opinion is the most common smell I’ve come across; static analysis
    tools can recognize code fragments that are repeated and flag them for developers’
    attention (often, this step can be done directly by your favorite IDE).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static analysis of code is essential for security as it plays a pivotal role
    in identifying and mitigating security vulnerabilities. By thoroughly examining
    the source code of an application or system before it is executed, static analysis
    helps to enhance the overall security posture of software. One of the significant
    benefits of static code analysis is its ability to reduce security vulnerabilities,
    such as **cross-site scripting** (**XSS**) and injection attacks, which are common
    and potentially devastating threats to the integrity and confidentiality of data
    and the smooth operation of applications. Here are some more benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Detection of XSS vulnerabilities**: Static code analysis scans the source
    code for any instances where user inputs, such as form fields or URL parameters,
    are not properly validated or sanitized. This meticulous examination helps identify
    potential entry points for malicious code injection. For example, in the context
    of a web application, static analysis can pinpoint locations where user-supplied
    data might be directly included in HTML or JavaScript code. This information is
    invaluable in fixing these issues as it adds proper input validation and output
    encoding, thereby thwarting XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation of injection attacks**: Static analysis is highly effective in
    detecting vulnerabilities that can lead to injection attacks, including SQL injection,
    which can compromise the database and sensitive data. By analyzing the code, it
    can flag any instances where user inputs are used directly in SQL queries, without
    proper parameterization or escaping. Developers can then modify the code so that
    it uses prepared statements or stored procedures, effectively preventing injection
    attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library and component vulnerability scanning**: We can extend the analysis
    to dynamically linked libraries and third-party components. We should regularly
    scan for known vulnerabilities in libraries and dependencies used by the application.
    Automated tools can help identify outdated or susceptible components, ensuring
    that the software relies on secure and up-to-date code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Early detection and prevention**: One of the key advantages of static code
    analysis is its ability to detect vulnerabilities at an early stage of the development
    process. This early detection is crucial because addressing security issues at
    later stages, such as during testing or in production, can be considerably more
    expensive and disruptive. Static analysis empowers development teams to address
    vulnerabilities as they write the code, reducing the likelihood of security issues
    making their way into the final product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By addressing these vulnerabilities at their root, organizations can minimize
    the potential for security breaches and the associated risks and costs.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclomatic complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static analysis of code can also be used to calculate and keep the cyclomatic
    complexity of the code itself under control. Let’s try to understand what it is.
    Simply put, **cyclomatic complexity** is like counting the different ways you
    can walk through a piece of code. If there are fewer routes and they’re not too
    complicated, the cyclomatic complexity is lower, and the code becomes easier to
    read and get.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce cyclomatic complexity, you “just” have to write clean code, but apply
    all the advice we gave in the previous chapters and remove all the code smells
    that you get. Static analysis can help you, for example, in detecting methods
    or functions that are too long, duplicated code, or dead code (that is, code that
    is never used at runtime); it can also help you reduce the number of decision
    structures (that’s a big deal: try to avoid as many `if` statements as possible
    in your code to reduce the complexity) and help you avoid flag arguments in methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not going to look at this in too much detail here, but we think it’s
    generally interesting to understand how to calculate cyclomatic complexity for
    a simple method. Let’s suppose you have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can calculate cyclomatic complexity for functions, modules, methods, or
    classes in a software program using control flow graphs. It should be easier to
    draw the control flow graph for the `calculateSum` method than to explain what
    a control flow graph is. It represents all the possible paths of execution of
    your program and it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The control flow graph for the calculateSum method](img/B20912_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The control flow graph for the calculateSum method
  prefs: []
  type: TYPE_NORMAL
- en: The previous diagram represents the control flow graph for the `calculateSum`
    method. We can see a **START** node, from which starts an edge that goes into
    a conditional node; depending on the condition (**TRUE** or **FALSE**), the flow
    goes through one edge or another (**a+b** or **a-b**). They both end at the **END**
    node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To calculate the cyclomatic complexity, there’s a simple formula: **M = E –
    N + 2**. Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** represents the cyclomatic complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E** is the number of edges in the control flow graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**N** is the number of nodes in the control flow graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, it would be **M = 5 – 5 + 2 =** **2**.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a piece of code with a cyclomatic complexity value exceeding 11
    is considered overly complex and brings challenges for testing and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common cyclomatic complexity values that are used by
    static analysis tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-4**: Low complexity – relatively easy to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**5-7**: Moderate complexity – manageable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8-10**: High complexity – suggests the need for refactoring to improve testability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**11 and above**: Very high complexity – extremely challenging to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code’s complexity level also impacts its testability. The higher the cyclomatic
    complexity, the more difficult it is to create comprehensive tests. The cyclomatic
    complexity value indicates the number of test cases required to achieve 100% branch
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Exception (mis)handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions in Java programs are not always treated as they deserve; defects
    coming from their mishandling are common and often underestimated. Handling exceptions
    correctly in Java is vital to preventing program crashes, maintaining data integrity,
    providing a better user experience, enhancing debugging, improving security, and
    maintaining code quality. Properly handled exceptions help your software recover
    gracefully from errors and meet regulatory requirements when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis tools can help us detect some common exception mishandling;
    we’re going to see some of them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an `IOException` is thrown in the `finally` block; in general,
    throwing exceptions in the `finally` block is considered a smell since it could
    hide some other exception being thrown in the `try` block. In this case, the expected
    output would be a `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, employing the `return` statement within a `finally` block can introduce
    confusion. This rule’s significance lies in the fact that when the code throws
    an exception, the `return` statement can discard it. Let’s see how by changing
    a bit of the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `NullPointerException` is thrown, but the `finally` block containing the
    `return` statement is just swept under the carpet. Nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last smell in exception handling we’re going to see is when we close a
    stream into the `finally` block and something fails. What happens if `close()`,
    when invoked on a stream, fails and there are other instructions to be executed
    after it? Those instructions are simply not executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `copyFiles` method copies one file to another (we’re omitting the internal
    copy method for conciseness), opening two streams (`inputStream` and `outputStream`).
    As you can see, in the `finally` block, the two streams are closed in the same
    `try` block: if the first one fails, the other one will stay open.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen what we’re looking for when we perform static code analysis,
    let’s get to know some tools that can help us. As usual, consider the next few
    sections as suggestions to deepen your knowledge so that you can improve the quality
    of your code day by day.
  prefs: []
  type: TYPE_NORMAL
- en: Automated static analysis tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated static analysis tools, such as SonarQube, Checkstyle, FindBugs, and
    PMD, play a crucial role in the software development process by helping developers
    maintain code quality, identify potential issues, and adhere to coding standards.
    These tools are instrumental in ensuring that software projects are not only functionally
    correct but also maintainable and robust.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube and SonarLint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SonarQube** is a comprehensive tool that’s designed for continuous code inspection.
    Its primary function is to analyze code bases automatically, pinpointing potential
    issues such as bugs, security vulnerabilities, and code smells. By integrating
    seamlessly into the **continuous integration and continuous deployment** (**CI/CD**)
    pipelines, SonarQube ensures that each build undergoes a deep examination for
    code quality. This process includes identifying and reporting on areas that may
    require improvement or attention.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the notable features of SonarQube is its ability to perform security
    vulnerability detection, which is crucial in today’s software development landscape
    where security is a top priority. This tool offers a holistic view of the code
    base, helping development teams maintain a high standard of code quality throughout
    the entire development life cycle. Additionally, SonarQube provides historical
    analysis, allowing developers to track changes in code quality over time. This
    historical perspective proves invaluable in assessing the effectiveness of code
    improvements or identifying potential regressions.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube and **SonarLint** often go together, like *Batman* and *Robin*. SonarLint
    is a lightweight IDE extension and serves as a valuable companion to SonarQube,
    offering developers a means to address code quality issues directly within their
    IDEs. SonarLint operates in real-time, providing instant feedback as developers
    write code. By integrating with popular IDEs such as Eclipse, IntelliJ IDEA, and
    Visual Studio, SonarLint seamlessly becomes a part of the local development environment.
  prefs: []
  type: TYPE_NORMAL
- en: One of SonarLint’s strengths lies in its language support, which covers a variety
    of programming languages. This versatility allows developers to apply consistent
    code quality standards across different projects and code bases. Importantly,
    SonarLint can be configured to synchronize with SonarQube, ensuring that developers
    adhere to the same rule sets locally as those enforced by the centralized analysis
    performed by SonarQube.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, SonarQube and SonarLint work hand-in-hand to create a robust system
    for maintaining and enhancing code quality. SonarQube provides centralized, comprehensive
    analysis, while SonarLint brings that analysis directly into the developers’ local
    environments, enabling them to proactively address issues during the coding process.
    Together, these tools contribute significantly to the overall goal of producing
    high-quality, secure, and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Checkstyle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Checkstyle** is an open source tool that enforces coding standards and conventions
    for Java code. It checks the source code against a set of predefined rules and
    reports violations. Checkstyle is highly configurable, allowing development teams
    to customize and enforce their own coding standards. Some of the key features
    of Checkstyle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizable rules**: Checkstyle allows you to define your own coding rules
    or use predefined rule sets based on established coding standards such as Sun
    Code Conventions, Google Java Style, and more. You can define rules about indentation,
    line length, variable naming, import order, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: Checkstyle can be integrated into popular IDEs and build systems,
    making it seamless for developers to incorporate code checks into their development
    workflows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration**: It is often integrated into **Continuous Integration**
    (**CI**) pipelines, ensuring that code quality checks are performed automatically
    whenever code changes are committed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Report generation**: Checkstyle generates detailed reports, making it easy
    for developers to identify and fix code violations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FindBugs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**FindBugs** is a static analysis tool for identifying bugs and potential security
    vulnerabilities in Java code. It uses static analysis to detect issues in bytecode,
    making it particularly valuable for finding problems that might not be apparent
    from the source code alone. Here are some of the key features of FindBugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug detection**: It is designed to find a wide range of bugs, including null
    pointer dereferences, thread synchronization problems, and performance bottlenecks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: Like Checkstyle, FindBugs can be integrated into various development
    environments and CI/CD pipelines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User-defined checks**: Developers can create custom bug detectors for project-specific
    issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community support**: FindBugs has an active community that maintains and
    updates the tool, ensuring it remains relevant and effective'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FindBugs reviews your code by looking at its bytecode – that is, without needing
    to access the original source code. But because its analysis isn’t always perfect,
    FindBugs can sometimes raise warnings that aren’t real issues. The rate of these
    false warnings reported by FindBugs is less than 50%.
  prefs: []
  type: TYPE_NORMAL
- en: PMD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PMD** is a static source code analyzer for various programming languages,
    including Java. It focuses on code quality and identifies potential issues, redundancies,
    and complex code patterns. PMD offers the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple languages**: It supports multiple languages, not just Java, making
    it versatile for projects with diverse code bases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule-based analysis**: It analyzes source code against a set of predefined
    rules that can be customized based on project requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code duplication detection**: PMD can detect duplicate code fragments, helping
    developers maintain cleaner and more maintainable code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration**: PMD can be integrated into different IDEs and build systems
    (PMD offers an extension for Visual Studio Code, making it convenient for developers
    working in this popular IDE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tools that check code for mistakes is important in both the place where
    we write code (IDEs) and in the system that keeps an eye on our code as we work
    (CI pipelines). These tools help us find mistakes early, which is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: In our code writing environment (IDE), these tools help us spot problems as
    we write the code, making it less likely for errors to show up later.
  prefs: []
  type: TYPE_NORMAL
- en: In our code monitoring system (CI pipeline), these tools make sure the code
    we write follows the rules and standards we set. This keeps the quality of our
    code high and makes sure we don’t accidentally break things that used to work.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great things about these tools is that they make sure everyone on
    the team follows the same rules. This helps our code be more organized, easier
    to understand, and generally better. These tools also save us time and money.
    They help us find and fix problems early, which is cheaper and faster than waiting
    until later when problems can be much harder to solve.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, using these tools makes our code better, helps us work
    together more easily, and keeps our code secure and safe from mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve taken a quick look at static analysis, focusing on what to
    look for and how to look for it. Unfortunately, static analysis alone is not enough.
    Clean code is one thing – efficient code is another. It is strictly necessary
    to analyze the code while it is running.
  prefs: []
  type: TYPE_NORMAL
- en: What is dynamic analysis?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While static analysis is done on the code, its complementary version, **dynamic
    analysis**, is done on the program while it is running. This approach involves
    analyzing the code during execution, rather than just inspecting the source code,
    or performing static analysis, which examines code without executing it. Dynamic
    analysis provides insights into how a program behaves in real-world scenarios
    and helps identify issues that might not be apparent through static analysis alone.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever done some unit testing or some debugging, well, you did some
    kind of dynamic analysis. But there is much more to this. Dynamic program analysis
    involves collecting diverse insights about a program’s behavior, which includes
    understanding variables’ value assignments, the sequence and timing of function
    calls, data structure manipulations and modifications, memory allocation and usage,
    utilization of system resources, and the detection of encountered errors. This
    information is essential for purposes such as bug and security vulnerability identification,
    program performance enhancement, verification of program adherence to its requirements,
    and gaining a deeper understanding of the program’s operational principles.
  prefs: []
  type: TYPE_NORMAL
- en: There are many examples of dynamic program analysis; let the journey begin.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As trivial as it may seem, **debugging** is the most widely used technique for
    dynamic program analysis; maybe it’s the single activity we do the most in our
    industry – yes, certainly much more than writing the code or designing the architectures.
    And yes, we know that by implementing some good habits in respect of testing (such
    as **test-driven development** (**TDD**)) the need for debugging should be minimal,
    ideally zero, but in the real world, it isn’t always possible to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s such a popular activity, we won’t dwell too much on debugging. However,
    I would like to draw attention to some aspects that some people might underestimate,
    especially at the beginning of their professional careers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For effective debugging, try to reproduce the bug first; from experience, this
    can be a difficult phase, sometimes much more difficult than the resolution itself.
    It involves having it explained to you what was done to produce that bug (in case
    you haven’t noticed it yourself) and reproducing the same input that generated
    the problem or at least an input of the same type. It is not even granted that
    you can use a debugger, actually: for example, if you can’t reproduce the problem
    in an environment where you can use the debugger (for example, your local host),
    you’ll need to use some other technique, such as logging. By logging the program’s
    state at key points, you can track down the source of the error more easily. As
    we already know – and it’s the key target of this whole book – refactoring can
    help you debug. Sometimes, it could just look like a game, but refactoring your
    code and making it cleaner will likely help you understand what’s happening.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it is widely used as a technique, I must point out that crying and
    banging your head on the keyboard does not work to fix bugs; on the other hand,
    do not hesitate to ask for help. This can also be an exceedingly difficult thing.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even the most skilled development teams may find that a few lines of code don’t
    achieve peak performance right from the start. To uncover the most efficient methods
    for improving code speed, it must undergo evaluation, debugging, and review.
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers (and quality assurance professionals) must take some steps
    to guarantee that their code is as swift, smooth, and flawless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Profiling** is the process of measuring and analyzing the runtime behavior
    and performance characteristics of a program. The primary goal of profiling is
    to identify bottlenecks, performance issues, and areas for optimization in the
    code. This is crucial for improving the efficiency and speed of a program. Profiling
    can be applied to various types of software, including desktop applications, web
    applications, and server-side software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different profiling tools available, and they can be used to
    collect several types of data, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU usage**: This data shows how much CPU time the program is using'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory usage**: This data shows how much memory the program is using'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function call frequency**: This data shows how often each function in the
    program is being called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function execution time**: This data shows how long each function in the
    program is taking to execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource usage**: This data shows how many various system resources, such
    as disk I/O and network bandwidth, the program is using'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the profiling data has been collected, it can be analyzed to identify bottlenecks.
    A bottleneck is a part of the program that is slowing it down. For example, a
    function that is called very often and takes a long time to execute may be a bottleneck.
    Once the bottlenecks have been identified, they can be fixed by optimizing the
    code. For example, the bottleneck function may be rewritten to make it more efficient.
    Profiling is a valuable tool for improving the performance of software. It can
    be used to identify and fix bottlenecks, and to make sure that the program is
    using system resources efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling has practical applications in various fields. For instance, web application
    developers can employ profilers to identify performance bottlenecks in their applications,
    allowing them to optimize the code for quicker loading. Similarly, game developers
    use profilers to improve frame rates by identifying and optimizing problematic
    sections of their games. Server administrators also make use of profilers to pinpoint
    resource-intensive processes, enabling them to reduce the server’s resource burden.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of tools are used to profile running Java applications. Sometimes, they
    are included in your IDEs in their plugin/extensions, such as NetBeans or Eclipse.
    One of the most used and common tools is VisualVM, a visual tool integrated into
    the **Java Development Kit** (**JDK**) that provides a wide range of profiling,
    monitoring, and diagnostic capabilities, including CPU profiling, memory profiling,
    and thread analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**VisualVM** provides a user-friendly graphical interface for monitoring and
    analyzing Java applications. It offers a wealth of visual data and performance
    metrics, making it easier to identify and address performance issues. One of VisualVM’s
    key features is its Java profiling capabilities. It allows developers to profile
    their applications to identify bottlenecks, memory leaks, and other performance-related
    problems. You can perform CPU profiling, thread analysis, and memory profiling,
    which are essential for improving the efficiency and reliability of Java applications.'
  prefs: []
  type: TYPE_NORMAL
- en: When your application starts freaking out and you don’t know exactly what is
    happening (for example, everything starts slowing down), one of the best chances
    (and one of the most desperate, at the same time) is to make a so-called “heap
    dump” or “memory dump.” A **memory dump** is essentially a snapshot of the contents
    of a computer’s memory (RAM) or a specific process’s memory at a given point in
    time. This snapshot captures the state of the system or application at the moment
    it was created. Memory dumps serve various important purposes, including debugging
    software errors and crashes, analyzing security incidents and malware infections,
    investigating system crashes, and optimizing memory usage in applications. They
    come in different types, such as complete memory dumps (for hardware-related issues),
    kernel memory dumps (for operating system issues), process memory dumps (for application-specific
    debugging), and mini dumps (for smaller and more manageable data). Memory dump
    analysis is crucial for gaining insights into system and software behavior and
    is an essential tool in resolving a wide range of computing issues.
  prefs: []
  type: TYPE_NORMAL
- en: VisualVM (like other profiling tools) allows you to capture heap dumps and thread
    dumps, which are essential for diagnosing memory-related issues and analyzing
    thread behavior in your Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Fuzzing**, also known as **fuzz testing**, is an automated software testing
    approach where unconventional, often random, and invalid data is provided as input
    to a computer program. The program’s responses are closely monitored for anomalies
    such as crashes, violations of built-in code rules, or potential memory issues.
    Fuzzers are typically employed to assess software programs that rely on structured
    inputs, such as file formats or protocols that distinguish between valid and invalid
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: A good fuzzer generates partially valid inputs that are “valid enough” to avoid
    immediate rejection by the input parser but are “invalid enough” to uncover unanticipated
    program behaviors, especially in corner cases that may not have been adequately
    addressed.
  prefs: []
  type: TYPE_NORMAL
- en: In a security context, the most valuable input to fuzz is often data that traverses
    a trust boundary. A **trust boundary** is a point where data or program execution
    transitions between different trust levels or where data and commands are exchanged
    between entities with varying privileges. Trust boundaries can be found at distinct
    locations in a system where all subsystems and their data have equal trust. For
    instance, an execution trust boundary occurs when an application gains elevated
    privileges, such as root access. A data trust boundary occurs when data originates
    from an untrusted source, such as user input or a network socket. For instance,
    it’s more critical to fuzz code that’s responsible for handling file uploads from
    any user, as it crosses a trust boundary, than code dealing with a configuration
    file accessible only to privileged users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every fuzzer can be put into one of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mutation-based fuzzers**: These fuzzers start with existing data samples
    and make changes to them to create new test cases. They take an original input
    or test case and then modify it in various ways, such as changing random bits
    or values, to see if these modifications trigger unexpected behavior or vulnerabilities
    in the software being tested. Mutation-based fuzzers are good at finding certain
    types of bugs or vulnerabilities, especially when you have an initial set of valid
    inputs to work with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generation-based fuzzers**: These fuzzers build test cases by understanding
    the structure and rules of the target protocol or file format. Instead of modifying
    existing data samples, they generate new data that follows the specific format
    and logic required for testing. These fuzzers are good at exploring different
    aspects of a program or system because they can create a wide range of test cases
    based on their knowledge of the protocol or file format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we’ll delve into subcategories within these two groups. There’s no universally
    agreed-upon list of fuzzing categories, but I liked the approaches described in
    the book *Fuzzing: Brute Force Vulnerability Discovery* (see *Further reading*),
    so I’ll try to resume them.'
  prefs: []
  type: TYPE_NORMAL
- en: Pre-generated test cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, the **pre-generated test cases** method, exemplified by
    the PROTOS framework, starts by studying a specific specification. It involves
    understanding supported data structures and acceptable value ranges. Test cases
    are then crafted as hard-coded packets or files, designed to test boundary conditions
    or challenge the specification itself. These test cases prove valuable for assessing
    how accurately the specification has been implemented on various systems. While
    this method requires substantial upfront effort in test case creation, its advantage
    lies in its reusability across multiple implementations of the same protocol or
    file format. A limitation, however, is that fuzz testing is finite as there’s
    no random element; once the list of test cases is exhausted, fuzzing concludes.
  prefs: []
  type: TYPE_NORMAL
- en: Random
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **random approach** is the simplest yet least effective method. It involves
    hurling pseudo-random data at the target while hoping for the best (or worst,
    depending on your perspective). Surprisingly, vulnerabilities in critical software
    have been uncovered using this technique. The challenging part is identifying
    the cause of an exception or a server crash resulting from tons of random bytes.
    Capturing the traffic with a sniffer is essential to facilitate debugging, often
    requiring extensive time in a debugger and disassembler. Debugging stack smashing
    can be especially troublesome as the call stack becomes corrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Manual protocol mutation testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Manual protocol mutation testing** is even less sophisticated than random
    fuzzing. It doesn’t involve an automated fuzzer; instead, the tester becomes the
    fuzzer. By entering inappropriate data into the target application, the goal is
    to crash the server or provoke undesired behavior. It’s a straightforward, cost-effective
    approach that’s often applied to web applications, allowing the analyst to rely
    on experience and intuition during the audit.'
  prefs: []
  type: TYPE_NORMAL
- en: We think that this approach is sometimes referred to as **hallway usability
    testing**, even though a usability test is something different than testing the
    program’s correctness. If you’re interested in what hallway usability testing
    is, take a look at the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation or brute-force testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Brute-force testing** involves taking a valid sample of a protocol or data
    format and continuously modifying every byte, word, or string within that data
    packet or file. While this approach requires minimal upfront research and is relatively
    easy to implement, it’s somewhat inefficient because it may waste CPU cycles on
    data that cannot be interpreted. Nevertheless, it can be fully automated, and
    it relies on a collection of known good packets or files for testing. Examples
    of brute-force file format fuzzers include FileFuzz for Windows and notSPIKEfile
    for Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic protocol generation testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In **automatic protocol generation testing**, the tester initially studies and
    understands the protocol specification or file definition. Instead of creating
    hard-coded test cases, a grammar is developed to describe the protocol’s operation.
    Static and fuzzable variables are identified within the packet or file. The fuzzer
    works by looking at templates, creating fuzzy data, and then sending the changed
    data to the target. How well this works depends on the tester’s skills in finding
    the parts of the specification that are likely to cause problems during the parsing
    process. Notable examples are SPIKE and SPIKEfile. However, this method demands
    time to create the grammar or definition upfront.
  prefs: []
  type: TYPE_NORMAL
- en: We just wanted to give you a general smattering of concepts that we have often
    seen put in place without a real “structurization” of what was being done. As
    usual, we do not pretend to be exhaustive but simply wish to spark some curiosity
    in you regarding this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Symbolic execution** stands as a program analysis method in which programs
    are run with symbolic inputs rather than concrete ones. Simultaneously, it preserves
    a path condition (see the *Cyclomatic complexity* section to learn what a *path*
    is) that evolves each time a branch instruction is encountered, encapsulating
    the constraints on the inputs that lead to that specific point within the program.
    In other words, it works by replacing real data with symbolic values as input
    and describing program variable values as symbolic expressions. This way, the
    program’s results are expressed as functions of these symbolic inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: To create tests, this method relies on solving the gathered constraints using
    a constraint solver. Symbolic execution is also handy for finding bugs since it
    inspects the program as it runs for errors or assertion violations and creates
    test inputs that can trigger these issues.
  prefs: []
  type: TYPE_NORMAL
- en: It is also seen as a sort of **white-box fuzzing** because you are fuzzing (see
    the previous section) but you have the knowledge of how the program works (yes,
    also of the code – it’s also something in between static and dynamic analysis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this very trivial Java method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method does indeed do something, so its name does not lie, but it doesn’t
    do anything meaningful. It’s just a means to explain how symbolic execution would
    work on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a regular execution (often called “concrete” execution), the program operates
    as follows: it reads a specific input value (for example, `10`) and assigns this
    value to the variable, `x`. Subsequently, the program executes the addition (`z
    = x + 2`) and the conditional branch, which, in this case, results in a false
    evaluation and `OK` as the output.'
  prefs: []
  type: TYPE_NORMAL
- en: During symbolic execution, the program operates differently. It reads a symbolic
    value, represented by a symbol such as λ, and assigns this symbol to the variable,
    `x`. The program then continues with the addition, setting `z` to λ + 2\. When
    it encounters the `if` statement, it evaluates the condition as λ + 2 > 20\. At
    this stage, the symbol λ can take on any value, and symbolic execution splits
    into two distinct paths by «forking.» Each path retains a copy of the program
    state at the branching point along with a path condition.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, one path is associated with the λ + 2 > 20 path condition,
    leading to the execution of the `if` branch, while the other path is tied to the
    λ + 2 <= 20 path condition, resulting in the execution of the `else` branch. Both
    paths can be independently symbolically executed.
  prefs: []
  type: TYPE_NORMAL
- en: As the paths reach their conclusion, which might happen due to an exception
    (for example, throwing a `RuntimeException`) or program termination, symbolic
    execution figures out a specific value for λ by solving the path constraints for
    each path it explores. These specific values can be thought of as real-world test
    cases, which can be instrumental for tasks such as bug reproduction. In this particular
    case, the constraint solver would establish that to throw the `RuntimeException`,
    λ needs to be greater than or equal to 18.
  prefs: []
  type: TYPE_NORMAL
- en: We must admit that this technique is not used much and presents several downsides.
    For example, as you can easily guess, the greater the cyclomatic complexity of
    the program, the greater the complexity of the symbolic execution; this technique
    does not scale at all as the complexity of the program increases. In addition,
    the efficiency of this analysis technique depends largely on the efficiency of
    the program itself. There are other contradictions that I invite you to observe
    in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Taint tracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Taint tracking**, often referred to as **information flow tracking** or **data
    flow tracking**, is a technique that’s used in computer security and software
    analysis to monitor the flow of data within a program or system to identify potential
    security vulnerabilities. Taint tracking works by marking data as *tainted* if
    it comes from an untrusted source, such as user input or a file from the internet.
    The taint tracker then tracks the flow of this tainted data through the program
    to identify any operations that could potentially lead to a security vulnerability.
    Tainted data can include things such as passwords, personal information, or any
    data that should not be exposed or manipulated by unauthorized users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how taint tracking typically works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data labeling**: Taint tracking systems label certain data as “tainted” or
    “untrusted” when it originates from external sources, such as user inputs. For
    example, if a user provides a password as input, that password data is labeled
    as tainted.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data flow monitoring**: The system then monitors how this tainted data flows
    through the program. It keeps track of which variables, functions, and components
    the tainted data interacts with.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Violations detection**: Taint tracking mechanisms continuously check if tainted
    data is used in a way that could compromise security. For example, if tainted
    data is used in a database query, sent over a network, or included in a response,
    the taint tracking system can flag this as a potential security risk.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Alerts generation**: When a potential security violation is detected, the
    system can generate alerts, log the event, or take some other predefined action
    to mitigate the risk. This helps in identifying and fixing security vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – One of the possible inputs is marked as tainted (because it
    comes from an untrusted source) and its flow through the program is tracked until
    its possible outputs](img/B20912_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – One of the possible inputs is marked as tainted (because it comes
    from an untrusted source) and its flow through the program is tracked until its
    possible outputs
  prefs: []
  type: TYPE_NORMAL
- en: For example, a taint tracker could be used to identify SQL injection vulnerabilities
    in web applications. SQL injection vulnerabilities occur when an attacker can
    inject malicious SQL code into a web application’s database queries. This can
    allow the attacker to read or modify data in the database, or even execute arbitrary
    code on the web server. A taint tracker could be used to identify SQL injection
    vulnerabilities by marking all user input as tainted. The taint tracker would
    then track the flow of this tainted data through the web application’s code to
    identify any operations that could potentially lead to a SQL injection vulnerability.
    For example, if the tainted data is used in a database query without being properly
    sanitized, the taint tracker would flag this as a potential vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: A small digression – what is SQL injection?
  prefs: []
  type: TYPE_NORMAL
- en: Even if it is not strictly related to taint tracking, we think it is worth knowing
    what **SQL** **injection** is.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL injection is a common and dangerous type of cyber-attack where an attacker
    can manipulate a web application’s SQL query by injecting malicious SQL code.
    This can potentially lead to unauthorized access, data theft, or even data manipulation.
    But how can this happen? Suppose you have a web application that takes user input
    to search for a specific user in a database using the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM user WHERE username = ''``input'';`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the input is taken directly from `user` input, and the application does
    not properly validate or sanitize this `input`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attacker can exploit this vulnerability by inputting the following as their
    username:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''` `OR ''1''=''1`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL query would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT * FROM users WHERE username = ''''` `OR ''1''=''1'';`'
  prefs: []
  type: TYPE_NORMAL
- en: The `'1'='1'` condition is always true, so the query effectively selects all
    rows in the `users` table, allowing the attacker to bypass any authentication
    and access all user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent SQL injection, you should use parameterized queries or prepared
    statements provided by Java’s **Java Database Connectivity** (**JDBC**) API or
    some other popular frameworks, such as Hibernate. Here’s how you can rewrite the
    vulnerable code so that it becomes secure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`String userInput =` `getUserInput();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`String sqlQuery = "SELECT * FROM users WHERE username = ?";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`PreparedStatement preparedStatement =` `connection.prepareStatement(sqlQuery);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`preparedStatement.setString(1, userInput);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResultSet resultSet =` `preparedStatement.executeQuery();`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a parameterized SQL query is created using `PreparedStatement`,
    where `?` is a placeholder for the user input. The user input is then safely set
    as a parameter using the `setString` method (note that no quotes and no string
    concatenation are involved). The query is executed, and the results are processed
    securely.
  prefs: []
  type: TYPE_NORMAL
- en: By using parameterized queries like this, you can prevent SQL injection attacks
    because the JDBC driver handles the input as data rather than executable SQL code.
    This ensures the user input is treated safely and doesn’t interfere with the query’s
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Taint tracking can be used to identify a variety of other security vulnerabilities,
    such as XSS, command injection, and insecure path traversal. It can also be used
    to track the flow of sensitive data, such as credit card numbers and social security
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Using taint tracking offers various advantages, including the ability to uncover
    security vulnerabilities in software that would be difficult or even impossible
    to identify through alternative testing methods. This approach also allows you
    to monitor sensitive data flow, helping to mitigate the risk of data breaches.
    Moreover, it provides a means to establish security sandboxes, effectively isolating
    untrusted code from trusted components.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, taint tracking presents several challenges. Its implementation
    can be intricate, requiring expertise in software security and taint tracking.
    It may introduce a performance impact on the monitored program, and it can result
    in a significant number of false positives, which can be time-consuming to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noticing that some programming languages, such as Perl, Ruby, or
    Ballerina, natively support *taint checking*, a feature that proceeds variable
    by variable, forming a list of variables that are potentially influenced by outside
    input. More information can be found in the *Further* *reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we added another tool to our toolbox for writing and maintaining
    clean code and efficient software: code analysis. We learned that we can do it
    in two ways: by checking the code before it’s even run (statically) and by watching
    the code as it runs (dynamically). We tried to figure out what kind of problems
    we should look out for in each of these analyses, and we also found some tools
    and techniques that can help.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the other stuff we’ve covered, this chapter is meant to give you ideas
    for going deeper. Code analysis is often seen as something extra, like an optional
    step, but it’s a crucial part of making a project efficient and easy to maintain.
    So, don’t underestimate its importance!
  prefs: []
  type: TYPE_NORMAL
- en: Besides the times when you do analysis and improve your work, it’s crucial to
    keep a certain level of quality in your everyday tasks. You can make a significant
    difference with minimal, targeted effort by using some simple but effective methods.
    In the next chapter, we’ll explore some of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cyclomatic complexity: [https://www.geeksforgeeks.org/cyclomatic-complexity/](https://www.geeksforgeeks.org/cyclomatic-complexity/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SonarQube documentation: [https://docs.sonarsource.com/sonarqube/latest/](https://docs.sonarsource.com/sonarqube/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PMD documentation: [https://pmd.github.io/pmd/index.html](https://pmd.github.io/pmd/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FindBugs manual: [https://findbugs.sourceforge.net/manual/index.html](https://findbugs.sourceforge.net/manual/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An introduction to CheckStyle: [https://www.baeldung.com/checkstyle-java](https://www.baeldung.com/checkstyle-java)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with VisualVM: [https://visualvm.github.io/gettingstarted.html](https://visualvm.github.io/gettingstarted.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M. Sutton, A. Greene, and P. Amini, *Fuzzing: Brute Force Vulnerability Discovery*,
    by Addison-Wesley Professional'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hallway usability testing: [https://www.techopedia.com/definition/30678/hallway-usability-testing](https://www.techopedia.com/definition/30678/hallway-usability-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limitations of symbolic execution: [https://en.wikipedia.org/wiki/Symbolic_execution#Limitations](https://en.wikipedia.org/wiki/Symbolic_execution#Limitations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Taint checking in programming languages: [https://en.wikipedia.org/wiki/Taint_checking](https://en.wikipedia.org/wiki/Taint_checking)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Further Learning'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the actual act of refactoring, it’s crucial to keep up a certain
    level of quality in your everyday work. There are small but powerful ways to achieve
    this goal, making a big impact with minimal, focused effort. We’ll discuss things
    like how you format your code, manage versions of your code, and work together
    with others through techniques like pair programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we’ve covered everything about fixing up classes and packages, let’s
    zoom out and look at the big picture: architecture. Even if your code is good,
    things can go wrong if the way different parts interact is not well-managed. We’ll
    talk about signs to watch out for and what to do instead to keep everything running
    smoothly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20912_08.xhtml#_idTextAnchor183), *Crafting Quality Every Day*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20912_09.xhtml#_idTextAnchor217), *Beyond Code – Mastering Software
    Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
