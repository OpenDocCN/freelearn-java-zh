<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Developing Macros in ImageJ"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Developing Macros in ImageJ</h1></div></div></div><p>In this chapter, we will take a look at ways to automate our image processing to allow for faster and more efficient processing. The processing we did earlier was adequate, but time consuming. When dealing with very large stacks or time series, or with many individual files, the processing we performed was good but inefficient. We will look at macros in ImageJ and understand how they will help us with the processing. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Recording and running macros</li><li class="listitem" style="list-style-type: disc">Modifying macros</li><li class="listitem" style="list-style-type: disc">User input in macros</li><li class="listitem" style="list-style-type: disc">Progress in macros</li><li class="listitem" style="list-style-type: disc">Running macros in batch mode</li><li class="listitem" style="list-style-type: disc">Installing macros</li></ul></div><div class="section" title="Recording macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Recording macros</h1></div></div></div><p>Macros are sets of <a id="id273" class="indexterm"/>commands that allow you to perform a series of tasks on a single image or multiple images. In a macro, you can place all the commands you can find in the ImageJ menu structure. A very basic application of a macro is to convert images from one specific type into another type. In order to create a macro, we could create one from scratch by typing all the commands in a text file, which we can then execute. However, if we are using commands from the menu structure, an easier way would be to use the macro recorder.</p><p>The macro recorder will<a id="id274" class="indexterm"/> register every command and selection you make, and place them in a simple editor. This is a very simple and fast way to create a macro that will perform a basic set of tasks on an image. To begin recording, go to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Record…</strong></span> from the menu, which will open a new recorder window:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_01.jpg" alt="Recording macros"/></div><p>The recorder window has a list to allow different types of recordings. The default is macro, but it is also possible to record commands for a plugin using Java as the recording type. ImageJ also supports JavaScript code and Beanshell scripts to run, and these types can also be created here. When JavaScript or BeanShell is selected, the commands recorded will look slightly different from the default macro commands. There is also an option to set the <a id="id275" class="indexterm"/>name of the new macro you are creating. Macros in ImageJ do not require an underscore in their names and have the <code class="literal">.ijm</code> extension to indicate that they are ImageJ macros. When you have performed all the processing steps you wish to unleash on your image, you can press the <span class="strong"><strong>Create</strong></span> button to finalize the macro for saving.</p><div class="section" title="Recording a macro for conversion"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Recording a macro for conversion</h2></div></div></div><p>Let's take a look <a id="id276" class="indexterm"/>at a simple recording of a macro that will take a multichannel image, change the lookup table of the blue channel, and convert it to an RGB image. We will use the sample image of the HeLa cells. For better processing, we will not include the open image command. So, we will first open the image by going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open Samples</strong></span> | <span class="strong"><strong>HeLa Cells</strong></span>. We will then start the macro recorder by going to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Record…</strong></span> from the ImageJ menu. Make sure that the type is set to <span class="strong"><strong>Macro</strong></span>, and enter a name for your macro. Next, we will perform the steps we wish to record in the order we wish to use them. To start with, activate the image window and select the blue channel by pressing the right arrow key twice. You will see that there are now two commands in the recorder window:</p><div class="informalexample"><pre class="programlisting">run("Next Slice [&gt;]");
run("Next Slice [&gt;]");</pre></div><p>Note that when you click on the channel bar with the mouse, nothing will be recorded and no commands are added to the recorder window.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The recorder does not record mouse clicks that change the state of the display. It does not record mouse clicks to change the channel, frames, or slices in stacks nor when you adjust the brightness/contrast. Only the <span class="strong"><strong>Set</strong></span> and <span class="strong"><strong>Apply</strong></span> commands will show up in the recorder.</p></div></div><p>With the blue<a id="id277" class="indexterm"/> channel selected, we will now change the LUT of this channel to <span class="strong"><strong>Cyan</strong></span> by going to <span class="strong"><strong>Image</strong></span> | <span class="strong"><strong>Lookup Tables</strong></span> | <span class="strong"><strong>Cyan</strong></span> from the menu. This will add a new command to the recorder, corresponding to the action we just performed:</p><div class="informalexample"><pre class="programlisting">run("Cyan");</pre></div><p>We will now perform the last step in this process, which is converting the image to an RGB image. To do so, go to <span class="strong"><strong>Image</strong></span> | <span class="strong"><strong>Type</strong></span> | <span class="strong"><strong>RGB Color</strong></span> from the menu. A new image will be created of the RGB type, and a new command is added to the recorder window:</p><div class="informalexample"><pre class="programlisting">run("RGB Color");</pre></div><p>Now, we have a complete macro to convert a three-channel image into an RGB image, with a change of the LUT in one channel. The final recorder window will look like the following screenshot:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_02.jpg" alt="Recording a macro for conversion"/></div><p>The name of the macro I have selected is <code class="literal">convert_3ch_rgb.ijm</code>. When you create the macro, this will be the default name used when you save the macro. When you push the <span class="strong"><strong>Create</strong></span> button, a new window will open that will look a little different, depending on the distribution of ImageJ that you are using. When using Fiji, the <span class="strong"><strong>Script Editor</strong></span> window will open, with the <a id="id278" class="indexterm"/>commands that we recorded in the editor:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_03.jpg" alt="Recording a macro for conversion"/></div><p>The advantage of the Fiji script editor is that it has <a id="id279" class="indexterm"/>
<span class="strong"><strong>syntax highlighting</strong></span> (indicated by the colors for different elements) and line numbering. It also supports a tabbed interface, allowing multiple macros to be opened at the same time within the same window. This editor also has a run button at the bottom of the window to let you run the macro directly.</p><p>In the standard ImageJ distribution, the editor will look a little more basic, and it does not have the added features that the Fiji script editor provides:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_04.jpg" alt="Recording a macro for conversion"/></div><p>Notice the lack of highlighting and the absence of line numbers in the editor. Once we have created the macro, we can run it using the keyboard shortcut <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>R</em></span> or by going to <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Run</strong></span> (standard ImageJ) or <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run (Fiji)</strong></span>.</p><p>The recording of<a id="id280" class="indexterm"/> the macro allows for many steps to be recorded in sequence. However, there is a drawback to the macro as we have it now: we need to open the image we want to process ourselves, and we need to save the resulting image as well. Furthermore, the macro in its current form only processes the currently active image. As long as only one image is open, this will not pose a problem. However, when we have more than one image open when we run the macro, we have to make sure that the window that we want to process is selected before we run the macro. In the next section, we will try to add some commands to deal with opening and closing images to allow for more robust processing.</p></div></div></div>
<div class="section" title="Modifying macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Modifying macros</h1></div></div></div><p>The macro we<a id="id281" class="indexterm"/> created in the previous section was effective. However, it does not deal with opening and closing images. So now, we will look at the process of modifying the current macro we now have. Most of the work will be done in the editor window, but we will still use the recorder window to discover the functions required to open and close images.</p><p>Let's start by adding an option to open the image you wish to process to the macro that we have. I will use the image we used earlier. However, since you are more likely to have images saved locally on a disk, we will save the <span class="strong"><strong>HeLa Cells</strong></span> image to the local disk. Let's make a folder named <code class="literal">processing</code> on the desktop and store the <span class="strong"><strong>HeLa Cells</strong></span> image in it. To save the image, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Save</strong></span> or press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>S</em></span> and select the folder on the desktop as the destination. After saving the image, we can start with the process of opening an image within our macro.</p><p>To start with, we <a id="id282" class="indexterm"/>need to make sure our previous macro is opened in the editor window and start the macro recorder. We also need to make sure that there are no images open. Now, we will start by opening the image we saved by selecting <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Open…</strong></span>. Then, we will select the image from the folder we created in the previous step. In the recorder window, we will now see a line that tells ImageJ to open the image. When done on our computer, <code class="literal">&lt;username&gt;</code> will be set to the user name that was used when you logged in:</p><div class="informalexample"><pre class="programlisting">open("/Users/&lt;username&gt;/Desktop/processing/hela-cells.tif");</pre></div><p>This tells us that ImageJ requires the <code class="literal">open()</code>function with a single parameter, which is a line of text (called a <code class="literal">string</code>, delimited by double quotes in Java/ImageJ). This line of text contains the full path of the file you wish to open. To implement this command into our macro, we need to copy or type this command into the editor window on the first line. We can now test whether everything works as we expect by running the macro. To do so, we need to close the image and run the macro by selecting the editor window and pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>R</em></span> to run the macro. If all goes well, the image will open, the blue channel will be selected and changed to cyan, and finally, the image will be converted to an RGB image.</p><p>Next, we will look at how to save the new image to the same folder but with a different name. We need to make sure the recorder window is still open, and then click on the newly created image to activate it. Next, we will save the image as a TIFF file by going to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Save</strong></span>. We will keep the name as it was set by ImageJ. In the recorder window, we should now see a new line with the save command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>run("Save", "save=[/Users/&lt;username&gt;/Desktop/processing/hela-cells.tif (RGB).tif]");</strong></span>
</pre></div><p>This command is a little more complex than the open command, as it uses the more general <code class="literal">run()</code> <a id="id283" class="indexterm"/>method. The run method takes two parameters: a string with the command, (in this case <span class="strong"><strong>Save</strong></span>) and a string with the form <code class="literal">save=[]</code>, with the filename between the square brackets for saving. Note that the user name was replaced with <code class="literal">&lt;username&gt;</code> in this command. It should be changed to the user name of your logged-in account. We can now add this command to our script to perform the save function.</p><p>Next, to complete the process, we will close all the images that are currently open. To do so, we will select the recently saved image and close it. Alternatively, we will select <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Close All</strong></span> from the menu. If we close an image or use close all, the following line will be placed in the recorder window, respectively:</p><div class="informalexample"><pre class="programlisting">close();
run("Close All");</pre></div><p>The first line means the currently active window will be closed, while the second command will close all open images. Since we want to close all the images that are open, when we are finished processing, the second command is more suited for our macro. We will add the <code class="literal">Close All</code> <a id="id284" class="indexterm"/>command to the script, which means our final macro will look as follows:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_05.jpg" alt="Modifying macros"/></div><p>When using the script editor in Fiji, we can also see the runs that were performed with the current macro in the list below the editor. Using the <span class="strong"><strong>Clear</strong></span> button allows us to reset this history. When you open this macro as it is now, it will open the image, change the LUT of the third channel, convert it to RGB, save the resulting image, and then close all the images. Even though this macro is very simple, it processes this image much faster than we will ever be able to do by hand. There is only one problem with this macro: it only works for a single image in a specific location. If we want to process many different images, this macro will not be very practical. We would have to manually change the macro for each file that we wish to process. So, in the next section, we will add the possibility for the <a id="id285" class="indexterm"/>user to select a file when the macro is run.</p><div class="section" title="User input in macros"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>User input in macros</h2></div></div></div><p>Our previous<a id="id286" class="indexterm"/> macro was very efficient at processing a specific image, but it would be more efficient if the macro asked for the file to be processed. To do this, we will need to add a method that will ask the user for a file. The only problem is that we <a id="id287" class="indexterm"/>cannot use the recorder to get this function. We need to find a function that asks the user for a file location, which can be done with the built-in macro<a id="id288" class="indexterm"/> functions available in ImageJ. On the ImageJ website, there is an extensive list of all the macro functions that you can access at <a class="ulink" href="http://imagej.nih.gov/ij/developer/macro/functions.html">http://imagej.nih.gov/ij/developer/macro/functions.html</a>. The functions are sorted alphabetically.</p><div class="section" title="Opening a specific file"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Opening a specific file</h3></div></div></div><p>The function we <a id="id289" class="indexterm"/>want is a file open dialog that asks the user to locate an image file. The easiest way to find a function on this page is to use the find function of your browser to search for relevant keywords. To find the function we need, we will use the search term "file open dialog" in the search box. When we enter the search term, there will be multiple occurrences on the page, so we will look at all the descriptions for each occurrence. In this case, the function that describes what we need is a function called <code class="literal">File.openDialog(title)</code>, and the description says that it will display a file open dialog that returns the path of the file that the user selects. We will now change our current macro to use this function to allow us to change any file that we select. We will change the first line of our macro into the following two lines:</p><div class="informalexample"><pre class="programlisting">fname = File.openDialog("Select 3 channel image");
open(fname);</pre></div><p>The first line tells ImageJ to display a file open dialog with the title <span class="strong"><strong>Select 3 channel image</strong></span> and then store the path that the user selected in a variable called <code class="literal">fname</code>. On the next line, we modified the <code class="literal">open()</code> command to use the <code class="literal">fname</code> variable to open the image that the user selected. One thing to note in this example is that the variable type is not specified. Macros in ImageJ are weakly typed and do not require that you specify the type beforehand.</p></div><div class="section" title="Saving an image to a folder"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec22"/>Saving an image to a folder</h3></div></div></div><p>So now, we<a id="id290" class="indexterm"/> made the macro a little bit more flexible. We can now select any file we wish at any location on the hard disk or attached storage. The only problem is that the image is still saved to a fixed location with a fixed name. So now, we have to change the portion of our macro that deals with saving the image. There are many possible solutions to this problem. We can save the new image in the same folder as the image we opened, or we could save it in a different folder where we collect all the processed images. We will start with the first option: saving it to the same folder as the image that we opened.</p><p>To get the name of the folder<a id="id291" class="indexterm"/> we selected, we can use a function called <code class="literal">File.directory()</code>, which will give us the directory of the last file that was opened using a file open dialog. This is exactly what we need for our save function, so let's start by adding this function<a id="id292" class="indexterm"/> in our code. To do so, we will add a new line before the <code class="literal">run("Save", …)</code> command and add the following code:</p><div class="informalexample"><pre class="programlisting">fdir = File.directory();</pre></div><p>This will store the path of the last opened image in a variable named <code class="literal">fdir</code>. In order to save a file, we need the path but also the filename of the new file. The filename in this case is just the title of the created image, so we will use a function to get the title of the current image by adding this line underneath the <code class="literal">fdir</code> line:</p><div class="informalexample"><pre class="programlisting">newName = getTitle();</pre></div><p>We will store the value of the new filename in a variable named <code class="literal">newName</code>. We are now ready to modify the <code class="literal">save</code> function to use the two variables that we created. What we need to do is combine the <code class="literal">fdir</code> and <code class="literal">newName</code> variables. We can do this within the <code class="literal">save</code> command, so we will change the old <code class="literal">save</code> command to the following line:</p><div class="informalexample"><pre class="programlisting">run("Save", "save=["+fidr+newName+".tif]");</pre></div><p>We have replaced the path that was specified between the square brackets with the two variables. We had to add a set of quotes between the square brackets to interrupt the string, and we used the <code class="literal">+</code> operator to concatenate the strings. We specified the extension of the file we wished to save. As the title of the image does not contain an extension at the end of the name, we need to add it. Alternatively, we could use the <code class="literal">saveAs</code> macro command to achieve the same result (adding the extension is not required because we will save the image as a TIFF file):</p><div class="informalexample"><pre class="programlisting">saveAs("Tiff", fdir+newName);</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>In this case, the <code class="literal">RGB Color</code> command creates a new image. When calling <code class="literal">Save</code> on a new image, we can change the name, and it will work the same way as the <code class="literal">saveAs</code> command. If your<a id="id293" class="indexterm"/> function does not create a new image but you would still like to store the result as a separate file, use the <code class="literal">saveAs</code> command. Otherwise, the save function will overwrite the image on the disk with the modified data.</p></div></div><p>Our macro should now look like this:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_06.jpg" alt="Saving an image to a folder"/></div><p>Our macro is now more flexible. We can select any file for processing, and the result will be stored in the<a id="id294" class="indexterm"/> same folder as the original but with a modified name. The next step is to modify the code to control which channel will be modified.</p></div><div class="section" title="Adding choices"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec23"/>Adding choices</h3></div></div></div><p>Our macro now<a id="id295" class="indexterm"/> allows us to modify any image that we can locate and save the result in the same folder. In the next step, we will ask the user which channel we wish to change. We need to ask the user for a number between 1 and 3, which will be the channel that will be updated. There are two basic ways of retrieving a number: we could use a text field where the user can enter a number, or we could present a list of numbers where the user can select the correct one. The first method is very easy, but also requires additional checking. What if the user enters a value larger than the number of channels (or not a number at all)? A slightly safer method is to give the user a limited set of choices where only one can be selected.</p><p>We will use a set of functions related to creating a dialog and adding fields to it. We will need to place this code somewhere at the beginning of the macro, before we call the next slice command. We will place the following code directly after the open command:</p><div class="informalexample"><pre class="programlisting">Dialog.create("Select a channel");
Dialog.addChoice("Channel number:", newArray("1","2","3"));
Dialog.show();</pre></div><p>The first line will create<a id="id296" class="indexterm"/> a dialog with the title <code class="literal">Select a channel</code>. Next, we added a choice list to the newly created dialog with an array containing the options <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code> as strings. Finally, we called the <code class="literal">show()</code> method to display the dialog we created.</p><p>We created a dialog that asks the user to select a channel number, but we did not use the selection yet. If we run the code as it is now, the result would be the same regardless of the selection we make in the dialog. So, our next step is to retrieve the user selection and extract the number that the user selected. The function to do this is <code class="literal">getChoice()</code>, which is part of the dialog function. We will add it directly after the show command as follows:</p><div class="informalexample"><pre class="programlisting">chChoice = Dialog.getChoice();</pre></div><p>This command will store the selected choice in a variable called <code class="literal">chChoice</code>. However, if we look at the description of the function, this function returns a string. This is a problem, because we need it to be a number in order to select the correct slice. There is a function available to convert a string to an integer in the macro language. It is called <code class="literal">parseInt()</code>, and we can implement it as follows:</p><div class="informalexample"><pre class="programlisting">sliceNumber = parseInt(chChoice);</pre></div><p>The <code class="literal">sliceNumber</code> variable now contains the user's channel selection. Next, we will use this number to select the correct slice in our image. We could use a small loop combined with our next slice commands. However, there is a faster and simpler method using a built-in macro function called <code class="literal">setSlice()</code>. To do this, replace the two lines with <code class="literal">run("Next Slice [&gt;]")</code> with the following line:</p><div class="informalexample"><pre class="programlisting">setSlice(sliceNumber);</pre></div><p>If we wish to also change the color of the lookup table that will be used, we could add a second choice list to our dialog using the same methodology. We could just add another <code class="literal">addChoice()</code> command, but this time, with several choices of LUTs (for example, cyan, yellow, magenta, and so on). The <code class="literal">getChoice()</code> function retrieves the results of each choice list in the order they are added to the dialog. If you add the LUT choice after the channel number, it would be retrieved with the second call to <code class="literal">getChoice()</code>. Our macro will now look as follows (I have added the color choice as well):</p><div class="informalexample"><pre class="programlisting">fname = File.openDialog("Select 3 channel image");
open(fname);
Dialog.create("Select a channel");
Dialog.addChoice("Channel number:",newArray("1","2","3")));
Dialog.addChoice("Select color:", newArray("Cyan","Magenta","Yellow"));
Dialog.show();
chChoice  =Dialog.getChoice();
clrChoice = Dialog.getChoice();
sliceNumber = parseInt(chChoice);
setSlice(sliceNumber);
run(clrChoice);
run("RGB Color");
fdir = File.directory();
newName = getTitle();
run("Save", "save=["+fdir+newName+".tif]");
run("Close All");</pre></div><div class="mediaobject"><img src="graphics/Insert_image_4909_06_07.jpg" alt="Adding choices"/></div><p>There is now a new variable called <code class="literal">clrChoice</code>, which holds the value of the color selection that the user makes. If you run the modified macro, you would have to select the image you wish to process and then set the channel and LUT color. After this, the image will be processed<a id="id297" class="indexterm"/> according to the values you set. The macro is now quite flexible and allows for different types of conversions of a specific channel with a specific color. We now only need one more modification to make it a little more robust. We need to check whether the image that the user selected actually has three channels or not.</p></div><div class="section" title="Performing input checking"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec24"/>Performing input checking</h3></div></div></div><p>To add a check<a id="id298" class="indexterm"/> for the number of slices in the selected image, we need a simple conditional statement. The <code class="literal">if</code> statement will perform this check. We will add this conditional after we open the image, but before we ask the user for input. If there are less than three channels, we need to stop the execution of the macro and close the image we opened:</p><div class="informalexample"><pre class="programlisting">if(nSlices&lt;3) {
run("Close All");
exit("Not enough channels in the image (min. is 3)!");
}</pre></div><p>The <code class="literal">nSlices</code> function is a built-in macro function that returns the number of slices of the current image. We will check the value of the number of slices against the value that we require. If there are insufficient channels, we would close all images and abort the macro using the <code class="literal">exit()</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>When using the <code class="literal">nSlices</code> function, remember that ImageJ calculates this value by multiplying the number of slices, frames, and channels of an image. When working with (hyper)stacks, the <code class="literal">nSlices</code> function does not return the value you might expect. For example, a 5D image with two channels, five slices, and 51 frames will return a value of 510 (<span class="emphasis"><em>2*5*51</em></span>). For stacks, you can use the <code class="literal">Stack</code> methods. To count the number of channels, you can use the <code class="literal">Stack.getDimensions()</code> function.</p></div></div><p>There are two forms of the exit function: one without a parameter and one with a string parameter. The string parameter will display a message indicating why the macro was aborted. It is recommended that you use the latter form to make a user understand why the macro is not performing a task by providing feedback. Our macro should now look like this:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_08.jpg" alt="Performing input checking"/></div><p>Our macro is now robust and will run in a predictable way every time we run it. If our image has very few slices, it would abort. If it has more slices, it would run correctly. However, we will be unable to modify any slice beyond the third slice. So, our final modification will check for the number of slices in the image and adjust our choices accordingly by <a id="id299" class="indexterm"/>manipulating the array of slice numbers.</p><p>To change the content of the choice list, we first need to create an array that is slightly longer than the one that is currently specified. We want to limit the number of channels somewhat, so we will create an array with five channels as a maximum. We will also adjust the check for the number of channels to reflect this alteration. We will start by creating an array containing numbers <code class="literal">1</code> through <code class="literal">5</code> as strings and modify the conditional statement:</p><div class="informalexample"><pre class="programlisting">chNumbers = newArray("1","2","3","4","5");
if(nSlices&gt;chNumbers.length) {
  run("Close All");
  exit("The many channels in the image (max is"+chNumbers.length+")!");
}</pre></div><p>This will store the channel numbers in the <code class="literal">chNumbers</code> array, and the conditional array will now check whether the number of slices is not larger than the length of that array. This method allows us to easily enter additional channel numbers in the future to the array, without having to modify any other code.</p><p>Next, we added the list of channel numbers to our choice list in the dialog. However, we have to take into account that the user can select an image with fewer channels than five, so we need to <a id="id300" class="indexterm"/>change the array that we add to the choice list to reflect the number of channels that are present in the selected image. To do this, we can use the <code class="literal">trim</code> function that works on arrays. The <code class="literal">trim</code> function takes two parameters: the first one is the array, and the second one is an integer that specifies the number of elements that need to be returned, starting from the first element. We can use the <code class="literal">nSlices</code> function to give us the number of elements we want the <code class="literal">trim</code> function to return:</p><div class="informalexample"><pre class="programlisting">Dialog.addChoice("Channel number:", Array.trim(chNumbers, nSlices));</pre></div><p>If we now run the modified macro on our <span class="strong"><strong>HeLa Cells</strong></span> file, we would see that the choice list for the channel number only contains the values <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>, which is exactly what we would expect for this image. If we opened another image with five channels, we could choose from five options in the list. You can try this by saving the <span class="strong"><strong>Neuron (1.6M 5 channels)</strong></span> sample image to test this. The final macro will now look like the following screenshot:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_09.jpg" alt="Performing input checking"/></div><p>For the next step<a id="id301" class="indexterm"/> in processing using macros, we will create a macro that will perform processing steps on a list of files contained within a folder. This process will require some form of progress to let the user know that something is happening and to give a hint of how long the processing will take.</p></div></div></div>
<div class="section" title="Showing progress in macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Showing progress in macros</h1></div></div></div><p>In the previous sections, we saw that we can process a single image file using a (relatively) simple<a id="id302" class="indexterm"/> macro. Although the macro is quite flexible, it still requires the user to select each file individually and to set the values each time. Many times, you <a id="id303" class="indexterm"/>wish to perform the same processing steps on a collection of many similar images. The images have the same specifications (number of channels, colors, and so on) but are of different samples or individuals. When processing large numbers of images, it is useful to show progress to indicate how far we are in the processing and provide some visual feedback of how many items have been processed. The easiest type of feedback is to present the percentage of files that have been processed. Any value lower than 100 percent indicates that we are not done yet. If we keep track of how long it takes to process 10 percent of the images, we can (roughly) estimate the time required to finish the processing. Another useful type of feedback is to provide a message at the end of processing that we are finished.</p><p>For this section, we<a id="id304" class="indexterm"/> will create a different macro that will take a folder with time series images, each containing 20 frames and two channels. We will take the first channel of each image and create an average projection of the first five frames and save the result in the same folder. We will then take the second channel of each image, create<a id="id305" class="indexterm"/> a maximum projection, and store it in the same folder as well. The folder will contain 10 files that need to be processed, as well as a single text file that contains a description of the files in the folder. We will start by creating a macro for the processing steps in the next section.</p><div class="section" title="Processing the time series"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Processing the time series</h2></div></div></div><p>We will begin by<a id="id306" class="indexterm"/> creating the steps to perform the processing. We can use the recorder as well as the built-in macro function reference page in the ImageJ website to help us with the processing. We will first open the image in ImageJ in the regular way. The code to open the images one by one from a folder will be written later on. Once the image is open, we will create the code that will process each channel. I will introduce some useful constructs that will make the code a little more clear. I will add comments to the code to indicate what is happening, and I will encapsulate the processing in functions.</p><p>Let's start by creating a function that will generate the average projection of the green channel and save it. Creating a function in an ImageJ macro is very simple. To declare a function, we will use the <code class="literal">function</code> keyword, followed by the name of the function and the parameter list. For our green channel, the function declaration is as follows:</p><div class="informalexample"><pre class="programlisting">function processGreenChannel() {

}</pre></div><p>The function is called <code class="literal">processGreenChannel</code> and has no parameters (this will change later on, but for now it is fine). Our first processing step is to generate an average of the green channel. There are many ways of doing this, but for now, we will use the most basic one. We will create an average for both channels and remove the channel we do not want before saving. To create an average projection, we need the recorder to discover the format of the command. Start the recorder by going to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Record…</strong></span> if it is not already open. Next, we will go to <span class="strong"><strong>Image</strong></span> | <span class="strong"><strong>Stacks</strong></span> | <span class="strong"><strong>Z Project...</strong></span> from the menu and enter <code class="literal">5</code> for <span class="strong"><strong>Stop slice</strong></span>, and <span class="strong"><strong>Average intensity</strong></span> for the method. We will see that the command that gives us the result is shown in the recorder:</p><div class="informalexample"><pre class="programlisting">run("Z Project...", "stop=5 projection=[Average Intensity]");</pre></div><p>This will be the first command we will add to our function to process the green channel. Next, we wish to remove the red channel from this average projection. To do this, we will go to <span class="strong"><strong>Image</strong></span> | <span class="strong"><strong>Stacks</strong></span> | <span class="strong"><strong>Delete Slice</strong></span> from the menu. A dialog will open, giving us a choice to delete the channel (there is not really a choice here). By pressing <span class="strong"><strong>OK</strong></span>, the first channel (the red one) will be removed. The recorder shows us that the command used for this is the following one:</p><div class="informalexample"><pre class="programlisting">run("Delete Slice", "delete=channel");</pre></div><p>We can add the<a id="id307" class="indexterm"/> same code we used to save the image in our previous macro to apply here as well. Our function will now look as follows:</p><div class="informalexample"><pre class="programlisting">function processGreenChannel() {
  //create an average projection of the first 5 frames
  run("Z Project...","stop=5 projection=[Average Intensity]");
  //delete the red channel
  run("Delete Slice","delete=channel");
  //save the new image
  fdir = File.directory();
  fname = getTitle();
  run("Save","save=["+fdir+fname+"]");
  //close the saved image
  close();
}</pre></div><p>Notice that we do not require the extension at the end of the name. The projection command used a prefix to change the name (<code class="literal">AVG_</code>), and our original image already had an extension at the end, which was preserved by the <code class="literal">projection</code> command. The final step in the processing of the green channel is to close the image we have created and saved. This time, however, we cannot use the <code class="literal">close all</code> command, as we are not done yet with the processing of the original image. We will just use the <code class="literal">close</code> command, which only closes the currently active image as indicated by the last line of our function. I have included single-line comments in the function to indicate what is going to happen in the next line(s) as an aid to understanding what will happen next. This is a very basic programming tool that can save a lot of time when we examine our code after weeks or months. Single-line comments are indicated by text preceded by two forward slashes. If you need more text over multiple lines for readability, there are multiline comments, which start with <code class="literal">/*</code> and end with <code class="literal">*/</code>:</p><div class="informalexample"><pre class="programlisting">//single-line comment
/*
multi line comment
that is spread over 
several lines.
*/</pre></div><p>The function we will create for our red channel is very similar, except we will now use a different projection method. Also, we must delete a different channel compared to the previous function. The<a id="id308" class="indexterm"/> complete function to process the red channel is as follows:</p><div class="informalexample"><pre class="programlisting">functionprocessRedChannel() {
  //create the maximum projection
  run("Z Project...","projection=[Max Intensity]");
  //select the green channel (which is number 2)
  setSlice(2);
  //delete the green channel
  run("Delete","delete=channel");
  //save the new image
  fdir  =File.directory();
  fname = getTitle();
  run("Save","save=["+fdir+fname+"]");
  //close the new image
  close();
}</pre></div><p>There are only two minor alterations compared to the processing of the green channel. The type of projection was changed from <code class="literal">Average Intensity</code> to <code class="literal">Max Intensity</code>, and the <code class="literal">setSlice</code> command was added to select the green channel before calling the delete channel function. Note that if we also wanted to perform a measurement on each of the channels, we could add some measurement code or a function call before the <code class="literal">close()</code> statement to perform the measurement on the selected channel.</p><p>Now that we have completed the processing code for each channel, we can already see that there are many similarities between the two functions. It would be possible to create a single function that will process each channel accordingly using a few input parameters. In this case, you would need three parameters: one for the stop point you wish to use for the projection, one for the type of projection, and one for the slice number you wish to remove. We could do this for the current function, but it may be simpler to keep separate functions. If we want to change something in the green channel, processing it might mean we have to introduce even more parameters to the function to make it work. This would make the function call very complex. Therefore, it is easier to keep two separate functions. The only parameter that would be useful in this context is the directory where the image will be saved. As we will write code to process an entire directory, we will have the path to that folder already present, so we can easily add it as a parameter. We will modify the function definition as follows for the green channel processing function:</p><div class="informalexample"><pre class="programlisting">function processGreenChannel(fdir) {
...
}</pre></div><p>This means that we can remove (or comment out) the line that provides a value to <code class="literal">fdir</code> within the body of the function:</p><div class="informalexample"><pre class="programlisting">//fdir  =File.directory();</pre></div><p>In this case, I've commented out the line instead of removing it. This is generally a good practice if it involves only a few lines, as it shows how the function should work and what the function of the variable is. However, this is not advised for large sections, as the code will become very long with dead code that you need to skip.</p><p>Our next step will deal with selecting the folder to create a list of files that need to be processed. For the sake of overview, we will also create a function for this part. The first step in this function will be to ask the user for a folder that contains the files that need to be processed. When we search the reference web page, we will find a function called <code class="literal">getDirectory(string)</code> that provides the functionality we need. In the description, there is also a reference to the <code class="literal">getFileList</code> function. This function will return a list of files in a specified<a id="id309" class="indexterm"/> directory path. We need both of them for our folder processing function, which will look as follows:</p><div class="informalexample"><pre class="programlisting">function processFolder() {
  //get a folder for processing
  fdir = getDirectory();
  //create a list of files that we need to process
  flist = getFileList(fdir);
}</pre></div><p>The point where we add this function description is not important for the processing in our macro. The declaration can be anywhere within the macro, but I will place it at the beginning of the code. It makes sense to place the function declarations in the order that you expect them to be called.</p><p>At this point, it might be useful to introduce a simple tool that is available to debug macros in ImageJ: the <span class="strong"><strong>log window</strong></span>. The log window is a text window that can print the value of a variable, allowing you to see whether the value is what you expect it to be. It can also be used as a reference for the user to see which folders have been processed, thus avoiding a folder being processed more than once. We will add a log call to our function, showing the folder that is being processed as well as the number of files that are present in that folder. Placing the following lines directly below the <code class="literal">flist</code> statement will result in the following output:</p><div class="informalexample"><pre class="programlisting">//display the folder and the number of files
IJ.log("Current folder: "+fdir);
IJ.log("Nr of files: "+flist.length);</pre></div><p>The last step is to go over each of the files and run our processing functions on the image that we open. To do this, we will use a basic loop structure, the <code class="literal">for</code> loop:</p><div class="informalexample"><pre class="programlisting">//go over all the files in the file list
for(i=0; i&lt;flist.length; i++) {
  //get the full file name
  fname = fdir + flist[i];
  //open the image specified by fname
  open(fname);
  //process each channel
  processGreenChannel(fdir);
  processRedChannel(fdir);
  //close all images when we are done
  run("Close All");
}</pre></div><p>We ended the loop with a <code class="literal">Close All</code> statement to make sure that all images are closed before we go on to<a id="id310" class="indexterm"/> the next file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Fiji also provides a small list of templates that allow a general framework for image processing in macros. For Fiji, two templates are very useful. The first is the <span class="strong"><strong>Process Folder</strong></span> template (<span class="strong"><strong>Templates</strong></span> | <span class="strong"><strong>IJ1 Macro</strong></span> | <span class="strong"><strong>Process Folder</strong></span>), which can be used for the same purpose as I am using for this example. The other template is the <span class="strong"><strong>Scale All ROIs</strong></span> template (<span class="strong"><strong>Templates</strong></span> | <span class="strong"><strong>IJ1 Macro</strong></span> | <span class="strong"><strong>Scale All ROIs</strong></span>). This template tells us how to go over a list of ROIs in the ROI manager and alter the size of the ROIs.</p></div></div><p>For this loop, we might also want to show the processing progress to indicate how many files we have processed. To do this, we will add a call to the <code class="literal">showProgress()</code> function, which takes a single parameter between <code class="literal">0</code> and <code class="literal">1</code>, indicating the fraction of files that have been processed. We can place the call directly after the <code class="literal">close all</code> command:</p><div class="informalexample"><pre class="programlisting">//show the progress
showProgress((i+1)/flist.length);</pre></div><p>As arrays in Java are zero-based, we added a value of <code class="literal">1</code> to the index to indicate the file number that was processed. The progress bar will be shown in the bottom-right corner of the ImageJ window. This completes the macro to process an entire folder, except that in the current state, we will still have two problems when we wish to run it. We only have function definitions, but we don't have any direct calls to those functions. We are missing the entry point for our macro. This point is easily resolved by adding a call to our <code class="literal">processFolder</code> function at the beginning of the macro.</p><p>The second problem is a little harder to solve. As specified at the beginning of this section, we also have a text file in the folder we wish to process. If we run the code as it is now, this text file would also be opened by our macro. This will result in an error when we try to process our channels using our functions. If our text file was the last file being processed, this would not be a huge problem (just a little sloppy). However, when our text file is in the beginning or somewhere halfway, the macro will terminate at an undetermined point, and we would have to manually correct it. This would negate the entire benefit of having a macro to process a folder. It will result in us still having to manually go over each file.</p><p>We could solve the problem by removing the text file from our folder, which may be a good solution if it is only one folder. However, if you have many folders that you wish to process, this method <a id="id311" class="indexterm"/>would not be very useful. Also, deleting the text file means you will lose the information that was contained within it, which might be important. Another option would be to create a subfolder in your processing folder and place the text file there. There is a problem with this solution as well. Folders are also seen by Java as types of files. When creating the file list, the subfolder would still be included. Trying to open the subfolder using the open command might have unexpected side effects.</p><p>We can solve all these problems by adding a conditional statement inside the loop that checks the type of file that we are currently processing. This <code class="literal">if</code> statement needs to check two conditions: whether the current file a directory and whether it is an image. To do this, we will add the following <code class="literal">if</code> statement around our open and process commands:</p><div class="informalexample"><pre class="programlisting">//verify that this file is correct
if(!File.isDirectory(fname) &amp;&amp; endsWith(flist[i], ".tif")) {
  ...
}</pre></div><p>This <code class="literal">if</code> statement checks whether the full path stored in the <code class="literal">fname</code> variable is not a directory and the current file name ends with <code class="literal">.tif</code>. This check will exclude any directories from being processed as well as any file that does not have the <code class="literal">.tif</code> extension. The <code class="literal">showProgress</code> call can stay outside of the <code class="literal">if</code> statement. The completed macro can be downloaded from the Packt Publishing's website for comparison (<code class="literal">batch_project.ijm</code>). When we run the macro, we will see that processing occurs fairly rapidly and the progress bar in the main ImageJ window is displayed while the processing occurs. Depending on the number of images and the processing power of your computer, processing might go too fast to see everything.</p><p>There is one argument that we can add to the current macro. This argument may speed up the process and also prevent all the images being shown when they're being processed. This can be controlled using the following command:</p><div class="informalexample"><pre class="programlisting">setBatchMode(true);</pre></div><p>When the batch mode is set to <code class="literal">true</code>, the images will not be shown, and only the newly created images will be visible. If the value is set to <code class="literal">false</code>, the images will be shown. By setting the batch mode to <code class="literal">true</code>, a 20-fold speed increase can be achieved in some cases. In the next section, we will look at another way to run a macro over multiple files using the built-in method that comes with ImageJ: batch process mode.</p></div></div>
<div class="section" title="Running macros in batch process mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Running macros in batch process mode</h1></div></div></div><p>In the previous <a id="id312" class="indexterm"/>sections, we looked at processing a folder using a macro with different processing functions. The method described earlier is very flexible and powerful, and allows a great deal of control over the processing flow and what will be processed. ImageJ, however, also<a id="id313" class="indexterm"/> has a method that can perform a similar task, which is the batch process command. This command allows you to run a specified macro that you created over a folder and allows you to store the results in the same or a different folder. To start the batch process command, go to <span class="strong"><strong>Process</strong></span> | <span class="strong"><strong>Batch</strong></span> | <span class="strong"><strong>Macro…</strong></span> in the ImageJ menu, which will open the following dialog:</p><div class="mediaobject"><img src="graphics/Insert_image_4909_06_10.jpg" alt="Running macros in batch process mode"/></div><p>You can set the input and output folders using the buttons. You can also set the output format. If you don't set the output folder, the image would not be saved unless you saved it within your own code. You can use one of the macros that come with ImageJ using the <span class="strong"><strong>Add Macro Code</strong></span><a id="id314" class="indexterm"/> selector, or you can use the <span class="strong"><strong>Open…</strong></span> button to<a id="id315" class="indexterm"/> load your own code file. To specify that you <a id="id316" class="indexterm"/>only wish to process image files, you could use the <span class="strong"><strong>File name contains</strong></span> field to specify a pattern that indicates you only wish to process TIFF files by typing (<code class="literal">.tif</code>) with the brackets included. When you press the <span class="strong"><strong>Process</strong></span> button, the code that is shown in the text field will be run for each image that matches the<a id="id317" class="indexterm"/> pattern.</p><p>Note that your macro needs to conform to a few rules to be able to use it in the batch mode. If you wish to perform the saving yourself inside the macro, you need to place code to save the results in your macro and leave the <span class="strong"><strong>Output</strong></span> field in the <span class="strong"><strong>Batch Process</strong></span> dialog empty. To perform the same task that we did in our previous macro, we will copy the entire code to the <span class="strong"><strong>Batch Process</strong></span> dialog. Then, we will remove the <code class="literal">processFolder()</code> function and the function call, replace it with a line that gives us the current directory of the opened image, and then call the processing functions:</p><div class="informalexample"><pre class="programlisting">fdir = File.directory();
processGreenChannel(fdir);
processRedChannel(fdir);

//processing functions...</pre></div><p>We can leave the output field in the process dialog empty, as images are saved inside our processing functions. We can add <code class="literal">(.tif)</code> to the <span class="strong"><strong>File name contains</strong></span> field to ensure that the text file will be skipped. When we click the <span class="strong"><strong>Process</strong></span> button, the folder will be processed in a similar way, and the results will be stored as we described in our macro's processing functions.</p><p>Both methods are very suitable for processing entire folders, and the results are similar. The biggest difference is that the <span class="strong"><strong>Batch Process</strong></span> mode allows slightly less control over the processing steps, and it does not allow recursive processing of folders and subfolders. Also, it is not possible to include multiple user inputs or dialogs before the folder is processed. The code within the <span class="strong"><strong>Batch Process</strong></span> command needs to be self-sufficient. Any user input will have to be entered every iteration.</p></div>
<div class="section" title="Installing macros"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Installing macros</h1></div></div></div><p>Once you have <a id="id318" class="indexterm"/>created your macro, you can save it in the macros folder within the ImageJ folder. When <a id="id319" class="indexterm"/>you wish to run your macro, you can go to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Open</strong></span> or <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Run</strong></span> to open and run your macro. It is also possible to add your macros to the macros menu. You can do this by installing a macro in ImageJ by selecting <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Install…</strong></span> from the menu. Once you have selected your macro, it will be added at the bottom of the macros menu. It is also possible to add your macro to the <code class="literal">StartupMacros.txt</code> file in the <code class="literal">macros</code> folder. All macros mentioned in this file will be added to the macros menu automatically.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Note that in Fiji, when you use the install option, the macro is only added for the duration of the session. As soon as you restart Fiji, the macro menu will be reset to the default content. It is, therefore, advised that you always place your macros and script in the macros or scripts folder of Fiji. To always load it when Fiji runs, use the <code class="literal">StartupMacros.fiji.ijm</code> file as described in the following code.</p></div></div><p>If you wish to make a toolbar button with a list of your macros that you often use, you can do so by modifying the <code class="literal">StartupMacros.txt</code> file (or <code class="literal">StartupMacros.fiji.ijm</code> file for Fiji). This<a id="id320" class="indexterm"/> could be very handy if you have multiple macros that you use frequently. To <a id="id321" class="indexterm"/>add your macros as a toolbar menu, add the following structure somewhere in the startup file:</p><div class="informalexample"><pre class="programlisting">var myTools = newMenu("My awesome tools",
newArray("Macro_1", "Macro_2", "-", "Macro_3"));

macro"My awesome tools - C037T0b11MT7b09aTcb09t" {
  cmd = getArgument();
  if(cmd== "Macro_1")
  runMacro("/PATH/TO/Macro_1_tool");
  else if(cmd == "Macro_2)"
  runMacro("/PATH/TO/some_other_tool");
}</pre></div><p>The first argument for the <code class="literal">newMenu</code> method is a name for your menu item; in this case, I used <code class="literal">My awesome tools</code>. The second argument adds an array of macro commands to the menu, which will be displayed within the toolbar menu when added. If you add a dash in the array, a horizontal divider will be added to the menu at that location. This can be useful to group macros with similar functions. After defining the menu, we can implement the menu items using an <code class="literal">if...else</code> structure, where we compare the command that was selected using the <code class="literal">getArgument</code> method to see which tool needs to be launched. If we want to know the command necessary to run our macro, we can start the macro recorder and then go to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Macros</strong></span> | <span class="strong"><strong>Run…</strong></span>, select our macro, and see what the command for our macro is.</p><p>It is also possible to add an icon to our menu, which needs to be specified as a string behind our macro implementation. This string consists of instructions to draw elements that we specify using a letter followed by coordinates. For instance, if we wish to write the string<a id="id322" class="indexterm"/> <span class="strong"><strong>Mat</strong></span> (<span class="strong"><strong>My awesome tools</strong></span>), we could use the following string for the icon:
</p><div class="mediaobject"><img src="graphics/chap6.jpg" alt="Installing macros"/></div><p>
</p><p>The underlined characters are the letters we wish to add, while the value preceding it is the font size in points (<code class="literal">11</code>, <code class="literal">09</code>, and <code class="literal">09</code>, respectively). The alphabet <code class="literal">T</code> indicates that a character must be drawn, and the value next to it indicates the position of the character. It is also possible to <a id="id323" class="indexterm"/>draw a polygon using the following format (this requires ImageJ 1.48k):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Gxyxy...xy00</strong></span>
</pre></div><p>Drawing this icon <a id="id324" class="indexterm"/>can be somewhat complicated, and in Fiji, there is a <a id="id325" class="indexterm"/>
<span class="strong"><strong>Beanshell</strong></span> script that can convert an image to a toolbar icon string. This can be used by opening an image and going to <span class="strong"><strong>Plugins</strong></span> | <span class="strong"><strong>Examples</strong></span> | <span class="strong"><strong>Image To Tool Icon</strong></span>. There is also an alternative that provides more flexibility and higher quality buttons in a separate toolbar. This alternative is<a id="id326" class="indexterm"/> <span class="strong"><strong>ActionBar</strong></span> by <span class="emphasis"><em>Jerome Mutterer</em></span>, which is a plugin that creates separate toolbars that can be set up to your own liking. It also supports icons in the PNG format.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Documentation for <a id="id327" class="indexterm"/>ActionBar can be found at <a class="ulink" href="http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start">http://imagejdocu.tudor.lu/doku.php?id=plugin:utilities:action_bar:start</a>. It also contains an example of how to create your own toolbar and how to auto-load your tool bar when you start ImageJ.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, you looked at how to create a macro using the recorder to discover commands and functions that we could apply. We made a basic macro that processed an image and generated a new image. Next, we looked at processing a folder full of images and created resulting images that were saved to a disk. Finally, we looked at batch process mode that allows ImageJ to process a folder in a similar way. In the next chapter, we will take a closer look at the constructs available for developing plugins and how to set up an environment for developing plugins.</p></div></body></html>