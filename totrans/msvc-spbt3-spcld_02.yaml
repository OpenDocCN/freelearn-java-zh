- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Introduction to Spring Boot
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot简介
- en: In this chapter, we will be introduced to how to build a set of cooperating
    microservices using Spring Boot, focusing on how to develop functionality that
    delivers business value. The challenges with microservices that we pointed out
    in the previous chapter will be considered only to some degree, but they will
    be addressed to their full extent in later chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用Spring Boot构建一组协作的微服务，重点关注如何开发提供业务价值的功能。我们将对上一章中指出的微服务挑战进行一定程度上的考虑，但在后续章节中将对它们进行全面解决。
- en: We will develop microservices that contain business logic based on plain **Spring
    Beans** and expose REST APIs using **Spring WebFlux**. The APIs will be documented
    based on the OpenAPI Specification using `springdoc-openapi`. To make the data
    processed by the microservices persistent, we will use **Spring Data** to store
    data in both SQL and NoSQL databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发包含业务逻辑的微服务，基于普通的**Spring Beans**，并使用**Spring WebFlux**公开REST API。API将根据OpenAPI规范使用`springdoc-openapi`进行文档编制。为了使微服务处理的数据持久化，我们将使用**Spring
    Data**在SQL和NoSQL数据库中存储数据。
- en: Since Spring Boot v2.0 was released in March 2018, it has become much easier
    to develop reactive microservices, including non-blocking synchronous REST APIs.
    To develop message-based asynchronous services, we will use **Spring Cloud Stream**.
    Refer to *Chapter 1*, *Introduction to Microservices*, the *Reactive microservices*
    section, for more information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自2018年3月Spring Boot v2.0版本发布以来，开发反应式微服务（包括非阻塞同步REST API）变得更加容易。为了开发基于消息的异步服务，我们将使用**Spring
    Cloud Stream**。有关更多信息，请参阅*第1章*，*微服务简介*中的*反应式微服务*部分。
- en: In November 2022, Spring Boot 3.0 was released. It is based on Spring Framework
    6.0 and Jakarta EE 9, also being compatible with Jakarta EE 10\. Java 17, the
    current **long-term support** (**LTS**) release, is required as the minimum Java
    version.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2022年11月，Spring Boot 3.0版本发布。它基于Spring Framework 6.0和Jakarta EE 9，同时也兼容Jakarta
    EE 10。作为最低Java版本，需要Java 17，这是当前的**长期支持**（**LTS**）版本。
- en: Finally, we will use **Docker** to run our microservices as containers. This
    will allow us to start and stop our microservice landscape, including database
    servers and a message broker, with a single command.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用**Docker**将我们的微服务作为容器运行。这将使我们能够通过单个命令启动和停止包括数据库服务器和消息代理在内的微服务景观。
- en: That’s a lot of technologies and frameworks, so let’s go through each of them
    briefly to see what they are about!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多技术和框架，所以让我们简要地了解一下它们各自的内容！
- en: 'In this chapter, we will introduce the following open source projects:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下开源项目：
- en: Spring Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot
- en: (This section also includes an overview of what’s new in v3.0 and on how to
    migrate v2 applications.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: （本节还包括v3.0的新功能和如何迁移v2应用程序的概述。）
- en: Spring WebFlux
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: '`springdoc-openapi`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`springdoc-openapi`'
- en: Spring Data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data
- en: Spring Cloud Stream
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud Stream
- en: Docker
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: More details about each product will be provided in upcoming chapters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品的更多详细信息将在后续章节中提供。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not contain any source code that can be downloaded, nor does
    it require any tools to be installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含任何可以下载的源代码，也不需要安装任何工具。
- en: Spring Boot
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Spring Boot, and the Spring Framework that Spring Boot is based on, is a great
    framework for developing microservices in Java.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot，以及它所基于的Spring框架，是一个用于在Java中开发微服务的优秀框架。
- en: When the Spring Framework v1.0 was released back in 2004, one of its main goals
    was to address the overly complex **J2EE** standard (short for **Java 2 Platform,
    Enterprise Edition**) with its infamous and heavyweight deployment descriptors.
    The Spring Framework provided a much more lightweight development model based
    on the concept of **dependency injection**. The Spring Framework also used far
    more lightweight XML configuration files compared to the deployment descriptors
    in J2EE.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Framework v1.0版本在2004年发布时，其主要目标之一是解决过于复杂的**J2EE**标准（即**Java 2 Platform,
    Enterprise Edition**）及其臭名昭著且重量级的部署描述符。Spring框架提供了一个基于**依赖注入**概念的更轻量级的开发模型。与J2EE中的部署描述符相比，Spring框架还使用了更轻量级的XML配置文件。
- en: 'To make things even worse with the J2EE standard, the heavyweight deployment
    descriptors actually came in two types:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使J2EE标准的问题更加严重，重量级的部署描述符实际上有两种类型：
- en: Standard deployment descriptors, describing the configuration in a standardized
    way
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准部署描述符，以标准化的方式描述配置
- en: Vendor-specific deployment descriptors, mapping the configuration to vendor-specific
    features in the vendor’s application server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商特定的部署描述符，将配置映射到供应商应用程序服务器中的特定功能
- en: In 2006, J2EE was renamed **Java EE,** short for **Java Platform, Enterprise
    Edition**. In 2017, Oracle submitted Java EE to the Eclipse Foundation. In February
    2018, Java EE was renamed Jakarta EE. The new name, Jakarta EE, also affects the
    names of the Java packages defined by the standard, requiring developers to perform
    package renaming when upgrading to Jakarta EE, as described in the *Migrating
    a Spring Boot 2 application* section. Over the years, while the Spring Framework
    gained increasing popularity, the functionality in the Spring Framework grew significantly.
    Slowly, the burden of setting up a Spring application using the no-longer-so-lightweight
    XML configuration file became a problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2006 年，J2EE 被更名为**Java EE**，即**Java 平台，企业版**。在 2017 年，Oracle 将 Java EE 提交给
    Eclipse 基金会。2018 年 2 月，Java EE 被更名为 Jakarta EE。新的名称，Jakarta EE，也影响了由标准定义的 Java
    包的名称，要求开发者在升级到 Jakarta EE 时进行包重命名，如*迁移 Spring Boot 2 应用程序*部分所述。多年来，随着 Spring 框架越来越受欢迎，Spring
    框架的功能也显著增长。慢慢地，使用不再轻量级的 XML 配置文件设置 Spring 应用程序所带来的负担成为一个问题。
- en: In 2014, Spring Boot v1.0 was released, addressing these problems!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2014 年，Spring Boot v1.0 发布，解决了这些问题！
- en: Convention over configuration and fat JAR files
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定优于配置和胖 JAR 文件
- en: Spring Boot targets the fast development of production-ready Spring applications
    by being strongly opinionated about how to set up both core modules from the Spring
    Framework and third-party products, such as libraries that are used for logging
    or connecting to a database. Spring Boot does that by applying a number of conventions
    by default, minimizing the need for configuration. Whenever required, each convention
    can be overridden by writing some configuration, case by case. This design pattern
    is known as **convention over configuration** and minimizes the need for initial
    configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 通过对如何设置 Spring 框架的核心模块和第三方产品（如用于日志记录或连接到数据库的库）有明确的意见，旨在快速开发生产就绪的
    Spring 应用程序。Spring Boot 通过默认应用一系列约定来实现这一点，最大限度地减少了对配置的需求。在需要时，可以通过编写一些配置来覆盖每个约定，具体情况具体分析。这种设计模式被称为**约定优于配置**，并最大限度地减少了初始配置的需求。
- en: Configuration, when required, is, in my opinion, written best using Java and
    annotations. The good old XML-based configuration files can still be used, although
    they are significantly smaller than before Spring Boot was introduced.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要时，我认为使用 Java 和注解编写配置最佳。虽然它们比 Spring Boot 之前要小得多，但基于 XML 的老式配置文件仍然可以使用。
- en: Added to the usage of convention over configuration, Spring Boot also favors
    a runtime model based on a standalone JAR file, also known as a **fat JAR file**.
    Before Spring Boot, the most common way to run a Spring application was to deploy
    it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment
    is still supported by Spring Boot.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用约定优于配置之外，Spring Boot 还倾向于基于独立 JAR 文件（也称为**胖 JAR 文件**）的运行时模型。在 Spring Boot
    之前，运行 Spring 应用程序最常见的方式是将它作为 WAR 文件部署在 Java EE 服务器上，例如 Apache Tomcat。Spring Boot
    仍然支持 WAR 文件部署。
- en: A fat JAR file contains not only the classes and resource files of the application
    itself but also all the JAR files the application depends on. This means that
    the fat JAR file is the only JAR file required to run the application; that is,
    we only need to transfer one JAR file to an environment where we want to run the
    application instead of transferring the application’s JAR file along with all
    the JAR files the application depends on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个胖 JAR 文件不仅包含应用程序本身的类和资源文件，还包含应用程序所依赖的所有 JAR 文件。这意味着胖 JAR 文件是运行应用程序所需的唯一 JAR
    文件；也就是说，我们只需要将一个 JAR 文件传输到我们想要运行应用程序的环境中，而不是将应用程序的 JAR 文件以及所有依赖的 JAR 文件一起传输。
- en: Starting a fat JAR requires no separately installed Java EE web server, such
    as Apache Tomcat. Instead, it can be started with a simple command such as `java
    -jar app.jar`, making it a perfect choice for running in a Docker container! If
    the Spring Boot application, for example, uses HTTP to expose a REST API, it will
    also contain an embedded web server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 启动胖 JAR 文件不需要安装单独的 Java EE 服务器，例如 Apache Tomcat。相反，可以使用简单的命令（如 `java -jar app.jar`）启动，使其成为在
    Docker 容器中运行的理想选择！例如，如果 Spring Boot 应用程序使用 HTTP 来公开 REST API，它也将包含一个嵌入的 Web 服务器。
- en: Code examples for setting up a Spring Boot application
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Spring Boot 应用程序的代码示例
- en: To better understand what this means, let’s look at some source code examples.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这意味着什么，让我们看看一些源代码示例。
- en: We will only look at some small fragments of code here to point out the main
    features. For a fully working example, you’ll have to wait until the next chapter!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只将查看一些小的代码片段来指出主要特性。对于完整的工作示例，你将不得不等到下一章才能看到！
- en: The magic @SpringBootApplication annotation
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 魔法的`@SpringBootApplication`注解
- en: 'The convention-based autoconfiguration mechanism can be initiated by annotating
    the application class (that is, the class that contains the static `main` method)
    with the `@SpringBootApplication` annotation. The following code shows this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基于约定的自动配置机制可以通过在应用程序类（即包含静态`main`方法的类）上使用`@SpringBootApplication`注解来启动。以下代码展示了这一点：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following functionality will be provided by this annotation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此注解将提供以下功能：
- en: It enables component scanning, that is, looking for Spring components and configuration
    classes in the package of the application class and all its sub-packages.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用了组件扫描，即在应用程序类的包及其所有子包中查找Spring组件和配置类。
- en: The application class itself becomes a configuration class.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类本身变成了一个配置类。
- en: It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath
    that it can configure automatically. For example, if you have Tomcat in the classpath,
    Spring Boot will automatically configure Tomcat as an embedded web server.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用了自动配置，Spring Boot会在类路径中查找它可以自动配置的JAR文件。例如，如果你有Tomcat在类路径中，Spring Boot将自动配置Tomcat作为嵌入式Web服务器。
- en: Component scanning
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件扫描
- en: 'Let’s assume we have the following Spring component in the package of the application
    class (or in one of its sub-packages):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下Spring组件在应用程序类（或其子包）的包中：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another component in the application can get this component automatically injected,
    also known as **auto-wired**, using the `@Autowired` annotation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的另一个组件可以使用`@Autowired`注解自动获取这个组件，也称为**自动装配**：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I prefer using constructor injection (over field and setter injection) to keep
    the state in my components immutable. An immutable state is important if you want
    to be able to run the component in a multithreaded runtime environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用构造函数注入（而不是字段和setter注入）来保持组件的状态不可变。在多线程运行时环境中运行组件时，不可变状态非常重要。
- en: 'If we want to use components that are declared in a package outside the application’s
    package, for example, a utility component shared by multiple Spring Boot applications,
    we can complement the `@SpringBootApplication` annotation in the application class
    with a `@ComponentScan` annotation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用在应用程序包外部声明的组件，例如，多个Spring Boot应用程序共享的实用组件，我们可以在应用程序类中的`@SpringBootApplication`注解上补充一个`@ComponentScan`注解：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now auto-wire components from the `se.magnus.util` package in the application
    code, for example, a utility component named `MyUtility`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从应用程序代码中的`se.magnus.util`包自动装配组件，例如，一个名为`MyUtility`的实用组件，如下所示：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This utility component can be auto-wired in an application component like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用组件可以像这样在一个应用程序组件中自动装配：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Java-based configuration
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: If we want to override Spring Boot’s default configuration or we want to add
    our own configuration, we can simply annotate a class with `@Configuration` and
    it will be picked up by the component scanning mechanism we described previously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖Spring Boot的默认配置，或者我们想要添加自己的配置，我们可以简单地使用`@Configuration`注解一个类，它将被我们之前描述的组件扫描机制所拾取。
- en: 'For example, if we want to set up a filter in the processing of HTTP requests
    (handled by Spring WebFlux, which is described in the following section) that
    writes a log message at the beginning and the end of the processing, we can configure
    a log filter, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在处理HTTP请求（由Spring WebFlux处理，将在下一节中描述）的过程中设置一个过滤器，在处理开始和结束时写入日志消息，我们可以配置一个日志过滤器，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can also place the configuration directly in the application class since
    the `@SpringBootApplication` annotation implies the `@Configuration` annotation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接在应用程序类中放置配置，因为`@SpringBootApplication`注解隐含了`@Configuration`注解。
- en: That’s all for now about Spring Boot, but before moving to the next component,
    let’s see what is new in Spring Boot 3.0 and how to migrate a Spring Boot 2 application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Spring Boot的内容就到这里，但在我们转向下一个组件之前，让我们看看Spring Boot 3.0的新特性以及如何迁移Spring Boot
    2应用程序。
- en: What’s new in Spring Boot 3.0
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Spring Boot 3.0的新特性
- en: 'For the scope of this book, the most important new items in Spring Boot 3.0
    are the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的范围，Spring Boot 3.0 中最重要的新功能如下：
- en: '**Observability**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观测性**'
- en: Spring Boot 3.0 comes with improved support for observability, adding built-in
    support for distributed tracing to the already existing support for metrics and
    logging in previous Spring Boot releases. The new distributed tracing support
    is based on a new Observability API in Spring Framework v6.0 and a new module
    named Micrometer Tracing. Micrometer Tracing is based on Spring Cloud Sleuth,
    which is now deprecated. *Chapter 14*, *Understand Distributed Tracing*, covers
    how to use the new support for observability and distributed tracing.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Spring Boot 3.0 增强了对可观测性的支持，在之前 Spring Boot 版本中已有的对指标和日志的支持基础上，增加了内置的分布式跟踪支持。新的分布式跟踪支持基于
    Spring 框架 v6.0 中的新可观测性 API 和名为 Micrometer Tracing 的新模块。Micrometer Tracing 基于 Spring
    Cloud Sleuth，现在已被弃用。*第14章*，*理解分布式跟踪*，介绍了如何使用新的可观测性和分布式跟踪支持。
- en: '**Native compilation**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原生编译**'
- en: Spring Boot 3.0 also comes with support for compiling Spring Boot applications
    to native images, which are standalone executable files. A native-compiled Spring
    Boot application starts significantly faster and consumes less memory. *Chapter
    23*, *Native-Compiled Java Microservices*, describes how to native compile microservices
    based on Spring Boot.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Spring Boot 3.0 还支持将 Spring Boot 应用程序编译成原生镜像，这些镜像是可以独立执行的文件。原生编译的 Spring Boot
    应用程序启动速度更快，并且消耗更少的内存。*第23章*，*原生编译的 Java 微服务*，描述了如何基于 Spring Boot 原生编译微服务。
- en: '**Virtual threads**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟线程**'
- en: Finally, Spring Boot 3.0 comes with support for lightweight threads called virtual
    threads from the OpenJDK Project Loom. Virtual threads are expected to simplify
    the programming model for developing reactive non-blocking microservices, for
    example, compared to the programming model used in Project Reactor and various
    Spring components. Virtual threads are currently only available as a preview in
    Java 19\. They also currently lack support for composability features, for example,
    required to build microservices that concurrently aggregate information from other
    microservices. Therefore, virtual threads will not be covered in this book. *Chapter
    7*, *Developing Reactive Microservices*,covers how virtual threads can be implemented
    using Project Reactor and Spring WebFlux.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，Spring Boot 3.0 支持轻量级线程，称为来自 OpenJDK Project Loom 的虚拟线程。虚拟线程预计将简化开发反应式非阻塞微服务的编程模型，例如，与
    Project Reactor 和各种 Spring 组件使用的编程模型相比。虚拟线程目前在 Java 19 中仅作为预览版提供。它们目前也缺乏对可组合性功能的支持，例如，构建同时从其他微服务聚合信息的微服务所需的。因此，虚拟线程将不会在本书中介绍。*第7章*，*开发反应式微服务*，介绍了如何使用
    Project Reactor 和 Spring WebFlux 实现虚拟线程。
- en: Migrating a Spring Boot 2 application
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Spring Boot 2 应用程序迁移
- en: 'If you already have applications based on Spring Boot 2, you might be interested
    in understanding what it takes to migrate to Spring Boot 3.0\. Here is a list
    of actions you need to take:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经基于 Spring Boot 2 开发了应用程序，您可能想了解迁移到 Spring Boot 3.0 需要做什么。以下是需要采取的操作列表：
- en: Pivotal recommends first upgrading Spring Boot 2 applications to the latest
    v2.7.x release since their migration guide assumes you are on v2.7.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pivotal 建议首先将 Spring Boot 2 应用程序升级到最新的 v2.7.x 版本，因为他们的迁移指南假设您正在使用 v2.7。
- en: Ensure you have Java 17 or later installed, both in your development and runtime
    environments. If your Spring Boot applications are deployed as Docker containers,
    you need to ensure that your company approves the usage of Docker images based
    on Java 17 or newer releases.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已安装 Java 17 或更高版本，无论是在您的开发环境还是运行时环境中。如果您的 Spring Boot 应用程序作为 Docker 容器部署，您需要确保贵公司批准使用基于
    Java 17 或更高版本发布的 Docker 镜像。
- en: 'Remove calls to deprecated methods in Spring Boot 2.x. All deprecated methods
    are removed in Spring Boot 3.0, so you must ensure that your application does
    not call any of these methods. To see exactly where calls are being made in your
    application, you can enable the `lint:deprecation` flag in the Java compiler using
    (assuming the use of Gradle):'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除对 Spring Boot 2.x 中已弃用方法的调用。所有弃用方法都在 Spring Boot 3.0 中被移除，因此您必须确保您的应用程序没有调用这些方法中的任何一个。要查看应用程序中调用这些方法的确切位置，您可以在
    Java 编译器中启用 `lint:deprecation` 标志（假设使用 Gradle）：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rename all imports of `javax` packages that are now part of Jakarta EE to `jakarta`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `javax` 包的所有导入重命名为 `jakarta`。
- en: For libraries that are not managed by Spring, you need to ensure that you are
    using versions that are Jakarta compliant, that is, using `jakarta` packages.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于不由 Spring 管理的库，您需要确保您使用的是符合 Jakarta 规范的版本，即使用 `jakarta` 包。
- en: 'For breaking changes and other important migration information, read through:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于破坏性变更和其他重要迁移信息，请阅读以下内容：
- en: '[https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)'
- en: '[https://docs.spring.io/spring-security/reference/migration/index.html](https://docs.spring.io/spring-security/reference/migration/index.html)'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://docs.spring.io/spring-security/reference/migration/index.html](https://docs.spring.io/spring-security/reference/migration/index.html)'
- en: Ensure that you have end-to-end black-box tests that verify the functionality
    of your application. Run these tests before and after the migration to ensure
    that the application’s functionality has not been affected by the migration.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您有端到端的全黑盒测试来验证您应用程序的功能。在迁移前后运行这些测试，以确保应用程序的功能没有受到迁移的影响。
- en: 'When migrating the source code of the previous edition of this book to Spring
    Boot 3.0, the most time-consuming part was figuring out how to handle breaking
    changes in the Spring Security configuration; see *Chapter 11*, *Securing Access
    to APIs*, for details. As an example, the following configuration of the authorization
    server in the previous edition needed to be updated:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在将本书前版源代码迁移到 Spring Boot 3.0 时，最耗时的工作是弄清楚如何处理 Spring Security 配置中的破坏性变更；有关详细信息，请参阅第
    11 章，*保护 API 访问*。例如，前版中授权服务器的以下配置需要更新：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration looks like the following with Spring Boot 3.0:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置在 Spring Boot 3.0 中看起来如下：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The end-to-end test script, `test-em-all.bash`, that comes with each chapter
    turned out to be indispensable in verifying that the functionality was unaffected
    after the migration of each chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个章节一起提供的端到端测试脚本 `test-em-all.bash` 在验证每个章节迁移后功能未受影响方面变得不可或缺。
- en: Now that we have learned about Spring Boot, let’s talk about Spring WebFlux.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Spring Boot，那么让我们来谈谈 Spring WebFlux。
- en: Spring WebFlux
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring WebFlux
- en: Spring Boot 3.0 is based on the Spring Framework 6.0, which has built-in support
    for developing reactive applications. The Spring Framework uses **Project Reactor**
    as the base implementation of its reactive support and also comes with a new web
    framework, **Spring WebFlux**, which supports the development of reactive, that
    is, non-blocking, HTTP clients and services.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 3.0 基于 Spring Framework 6.0，它内置了对开发反应式应用程序的支持。Spring Framework 使用
    **Project Reactor** 作为其反应式支持的基础实现，并附带了一个新的网络框架 **Spring WebFlux**，该框架支持开发反应式（即非阻塞）的
    HTTP 客户端和服务。
- en: 'Spring WebFlux supports two different programming models:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 支持两种不同的编程模型：
- en: An annotation-based imperative style, similar to the already existing web framework,
    Spring Web MVC, but with support for reactive services
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于注解的命令式风格，类似于已经存在的网络框架 Spring Web MVC，但支持反应式服务
- en: A new function-oriented model based on routers and handlers
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路由器和处理器的新功能导向模型
- en: In this book, we will use the annotation-based imperative style to demonstrate
    how easy it is to move REST services from Spring Web MVC to Spring WebFlux and
    then start to refactor the services so that they become fully reactive.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用基于注解的命令式风格来演示如何轻松地将 REST 服务从 Spring Web MVC 移动到 Spring WebFlux，然后开始重构服务，使它们成为完全反应式的。
- en: Spring WebFlux also provides a fully reactive HTTP client, `WebClient`, as a
    complement to the existing `RestTemplate` client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 还提供了一个完全反应式的 HTTP 客户端 `WebClient`，作为现有 `RestTemplate` 客户端的补充。
- en: Spring WebFlux supports running on a servlet container based on the Jakarta
    Servlet specification v5.0 or higher, such as Apache Tomcat, but also supports
    reactive non-servlet-based embedded web servers such as Netty ([https://netty.io/](https://netty.io/)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux 支持在基于 Jakarta Servlet 规范 v5.0 或更高版本的 servlet 容器上运行，例如 Apache
    Tomcat，但也支持基于反应式且非 servlet 的嵌入式网络服务器，如 Netty ([https://netty.io/](https://netty.io/))。
- en: The Servlet specification is a specification in the Java EE platform that standardizes
    how to develop Java applications that communicate using web protocols such as
    HTTP.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Servlet 规范是 Java EE 平台中的一个规范，它标准化了如何开发使用 HTTP 等网络协议进行通信的 Java 应用程序。
- en: Code examples of setting up a REST service
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 REST 服务的代码示例
- en: Before we can create a REST service based on Spring WebFlux, we need to add
    Spring WebFlux (and the dependencies that Spring WebFlux requires) to the classpath
    for Spring Boot to be detected and configured during startup. Spring Boot provides
    a large number of convenient **starter dependencies** that bring in a specific
    feature, together with the dependencies each feature normally requires. So, let’s
    use the starter dependency for Spring WebFlux and then see what a simple REST
    service looks like!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够创建基于 Spring WebFlux 的 REST 服务之前，我们需要将 Spring WebFlux（以及 Spring WebFlux
    所需的依赖项）添加到类路径中，以便 Spring Boot 在启动时检测和配置。Spring Boot 提供了大量方便的 **启动依赖项**，它们带来了特定的功能，以及每个功能通常所需的依赖项。因此，让我们使用
    Spring WebFlux 的启动依赖项，然后看看一个简单的 REST 服务是什么样的！
- en: Starter dependencies
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动依赖项
- en: 'In this book, we will use Gradle as our build tool, so the Spring WebFlux starter
    dependency will be added to the `build.gradle` file. It looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 Gradle 作为我们的构建工具，因此 Spring WebFlux 的启动依赖项将被添加到 `build.gradle` 文件中。它看起来像这样：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You might be wondering why we don’t specify a version number. We will talk about
    that when we look at a complete example in *Chapter 3*, *Creating a Set of Cooperating
    Microservices*!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不指定版本号。当我们查看 *第 3 章*，*创建一组协作微服务* 的完整示例时，我们将讨论这个问题！
- en: 'When the microservice is started up, Spring Boot will detect Spring WebFlux
    on the classpath and configure it, as well as other things such as starting up
    an embedded web server. Spring WebFlux uses Netty by default, which we can see
    from the log output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务启动时，Spring Boot 将检测类路径上的 Spring WebFlux 并进行配置，以及启动嵌入式 Web 服务器等其他事情。Spring
    WebFlux 默认使用 Netty，这可以从日志输出中看到：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we want to switch from Netty to Tomcat as our embedded web server, we can
    override the default configuration by excluding Netty from the starter dependency
    and adding the starter dependency for Tomcat:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将 Netty 作为嵌入式 Web 服务器切换到 Tomcat，我们可以通过排除 Netty 的启动依赖项并添加 Tomcat 的启动依赖项来覆盖默认配置：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After restarting the microservice, we can see that Spring Boot picked Tomcat
    instead:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务重启后，我们可以看到 Spring Boot 选择了 Tomcat：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Property files
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性文件
- en: As you can see from the preceding examples, the web server is started up using
    port `8080`. If you want to change the port, you can override the default value
    using a property file. Spring Boot application property files can either be a
    `.properties` file or a YAML file. By default, they are named `application.properties`
    and `application.yml`, respectively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例所示，Web 服务器使用端口 `8080` 启动。如果您想更改端口，您可以使用属性文件覆盖默认值。Spring Boot 应用程序属性文件可以是
    `.properties` 文件或 YAML 文件。默认情况下，它们分别命名为 `application.properties` 和 `application.yml`。
- en: 'In this book, we will use YAML files so that the HTTP port used by the embedded
    web server can be changed to, for example, `7001`. By doing this, we can avoid
    port collisions with other microservices running on the same server. To do this,
    we can add the following line to the `application.yml` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用 YAML 文件，以便嵌入式 Web 服务器使用的 HTTP 端口可以更改为，例如，`7001`。通过这样做，我们可以避免与其他在同一服务器上运行的微服务发生端口冲突。为此，我们可以在
    `application.yml` 文件中添加以下行：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we begin to develop our microservices as containers in *Chapter 4*, *Deploying
    Our Microservices Using Docker*, port collisions will no longer be a problem.
    Each container has its own hostname and port range, so all microservices can use,
    for example, port `8080` without colliding with each other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 *第 4 章*，*使用 Docker 部署我们的微服务* 中开始以容器形式开发我们的微服务时，端口冲突将不再成为问题。每个容器都有自己的主机名和端口范围，因此所有微服务都可以使用，例如端口
    `8080`，而不会相互冲突。
- en: Sample RestController
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例 RestController
- en: 'Now, with Spring WebFlux and an embedded web server of our choice in place,
    we can write a REST service in the same way as when using Spring MVC, that is,
    as a `RestController`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了 Spring WebFlux 和我们选择的嵌入式 Web 服务器，我们可以像使用 Spring MVC 一样编写 REST 服务，即作为一个
    `RestController`：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `@GetMapping` annotation on the `listResources()` method will map the Java
    method to an HTTP `GET` API on the `host:8080/myResource` URL. The return value
    of the `List<Resource>` type will be converted into JSON.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`listResources()` 方法上的 `@GetMapping` 注解将 Java 方法映射到 `host:8080/myResource`
    URL 上的 HTTP `GET` API。`List<Resource>` 类型的返回值将被转换为 JSON。'
- en: Now that we’ve talked about Spring WebFlux, let’s see how we can document the
    APIs we develop using Spring WebFlux.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了 Spring WebFlux，让我们看看我们如何使用 Spring WebFlux 记录我们开发的 API。
- en: springdoc-openapi
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: springdoc-openapi
- en: One very important aspect of developing APIs, for example, RESTful services,
    is how to document them so that they are easy to use. The Swagger specification
    from SmartBear Software is one of the most widely used ways of documenting RESTful
    services. Many leading API gateways have native support for exposing the documentation
    of RESTful services using the Swagger specification.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 开发API的一个重要方面，例如RESTful服务，是如何对其进行文档化，以便它们易于使用。SmartBear Software的Swagger规范是记录RESTful服务最广泛使用的方法之一。许多领先的API网关都原生支持使用Swagger规范公开RESTful服务的文档。
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the **OpenAPI Initiative** and created the **OpenAPI Specification**. The
    name Swagger is still used for the tooling provided by SmartBear Software.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，SmartBear Software在**OpenAPI倡议**下将Swagger规范捐赠给了Linux Foundation，并创建了**OpenAPI规范**。Swagger这个名字仍然被用于SmartBear
    Software提供的工具。
- en: '`springdoc-openapi` is an open source project, separate from the Spring Framework,
    that can create OpenAPI-based API documentation at runtime. It does so by examining
    the application, for example, inspecting WebFlux and Swagger-based annotations.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`springdoc-openapi`是一个开源项目，独立于Spring框架，可以在运行时创建基于OpenAPI的API文档。它是通过检查应用程序来实现的，例如，检查WebFlux和基于Swagger的注解。'
- en: 'We will look at full source code examples in upcoming chapters, but for now,
    the following condensed screenshot (removed parts are marked with “**…**”) of
    a sample API documentation will do:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中查看完整的源代码示例，但到目前为止，以下简化的截图（被移除的部分用“**…**”标记）将展示一个示例API文档：
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19825_02_01.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序，团队描述自动生成](img/B19825_02_01.png)'
- en: 'Figure 2.1: Sample API documentation visualized using Swagger UI'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：使用Swagger UI可视化的示例API文档
- en: Note the big **Execute** button, which can be used to actually try out the API,
    not just read its documentation!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到大的**执行**按钮，它可以用来实际尝试API，而不仅仅是阅读其文档！
- en: '`springdoc-openapi` helps us to document the APIs exposed by our microservices.
    Now, let’s move on to Spring Data.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`springdoc-openapi`帮助我们记录微服务暴露的API。现在，让我们继续了解Spring Data。'
- en: Spring Data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Data
- en: Spring Data comes with a common programming model for persisting data in various
    types of database engines, ranging from traditional relational databases (SQL
    databases) to various types of NoSQL database engines, such as document databases
    (for example, MongoDB), key-value databases (for example, Redis), and graph databases
    (for example, Neo4j).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了一种通用的编程模型，用于在多种类型的数据库引擎中持久化数据，从传统的关系型数据库（SQL数据库）到各种类型的NoSQL数据库引擎，例如文档数据库（例如，MongoDB）、键值数据库（例如，Redis）和图数据库（例如，Neo4j）。
- en: The Spring Data project is divided into several subprojects, and in this book,
    we will use Spring Data subprojects for MongoDB and JPA that have been mapped
    to a MySQL database.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data项目被分为几个子项目，在这本书中，我们将使用映射到MySQL数据库的Spring Data子项目，即MongoDB和JPA。
- en: '**JPA** stands for **Jakarta Persistence API** and is a Java specification
    about how to handle relational data. Please go to [https://jakarta.ee/specifications/persistence/](https://jakarta.ee/specifications/persistence/)
    for the latest specifications. Jakarta EE 9 is based on Jakarta Persistence 3.0.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPA**代表**Jakarta持久化API**，是关于如何处理关系型数据的一个Java规范。请访问[https://jakarta.ee/specifications/persistence/](https://jakarta.ee/specifications/persistence/)获取最新的规范。Jakarta
    EE 9基于Jakarta Persistence 3.0。'
- en: The two core concepts of the programming model in Spring Data are **entities**
    and **repositories**. Entities and repositories generalize how data is stored
    and accessed from the various types of databases. They provide a common abstraction
    but still support adding database-specific behavior to the entities and repositories.
    These two core concepts are briefly explained together with some illustrative
    code examples as we proceed through this chapter. Remember that more details will
    be provided in the upcoming chapters!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data编程模型的两个核心概念是**实体**和**仓库**。实体和仓库概括了如何从各种类型的数据库中存储和访问数据。它们提供了一个共同的抽象，但仍然支持向实体和仓库添加特定于数据库的行为。随着我们继续本章，我们将简要解释这两个核心概念，并伴随一些示例代码。请记住，更多细节将在接下来的章节中提供！
- en: Even though Spring Data provides a common programming model for different types
    of databases, this doesn’t mean that you will be able to write portable source
    code. For example, switching the database technology from a SQL database to a
    NoSQL database will, in general, not be possible without some changes in the source
    code!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring Data为不同类型的数据库提供了一个共同的编程模型，但这并不意味着您将能够编写可移植的源代码。例如，将数据库技术从SQL数据库切换到NoSQL数据库通常需要在源代码中进行一些更改才能实现！
- en: Entity
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体
- en: An entity describes the data that will be stored by Spring Data. Entity classes
    are, in general, annotated with a mix of generic Spring Data annotations and annotations
    that are specific to each database technology.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实体描述了Spring Data将要存储的数据。实体类通常使用通用的Spring Data注解和针对每种数据库技术特定的注解进行注解。
- en: 'For example, an entity that will be stored in a relational database can be
    annotated with JPA annotations such as the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个将要存储在关系型数据库中的实体可以注解以下JPA注解：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If an entity is to be stored in a MongoDB database, annotations from the Spring
    Data MongoDB subproject can be used together with generic Spring Data annotations.
    For example, consider the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个实体要存储在MongoDB数据库中，可以使用Spring Data MongoDB子项目中的注解，与通用的Spring Data注解一起使用。例如，考虑以下代码：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `@Id` and `@Version` annotations are generic annotations, while the `@Document`
    annotation is specific to the Spring Data MongoDB subproject.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`和`@Version`注解是通用注解，而`@Document`注解是Spring Data MongoDB子项目特有的。'
- en: This can be revealed by studying the `import` statements; the `import` statements
    that contain `mongodb` come from the Spring Data MongoDB subproject.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过研究`import`语句来揭示；包含`mongodb`的`import`语句来自Spring Data MongoDB子项目。
- en: Repositories
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: Repositories are used to store and access data from different types of databases.
    In its most basic form, a repository can be declared as a Java interface, and
    Spring Data will generate its implementation on the fly using opinionated conventions.
    These conventions can be overridden and/or complemented by additional configuration
    and, if required, some Java code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库用于存储和访问不同类型数据库的数据。在其最基本的形式中，一个仓库可以被声明为一个Java接口，Spring Data将根据既定的约定动态生成其实现。这些约定可以通过额外的配置来覆盖和/或补充，如果需要，还可以通过一些Java代码。
- en: Spring Data also comes with some base Java interfaces, for example, `CrudRepository`,
    to make the definition of a repository even simpler. The base interface, `CrudRepository`,
    provides us with standard methods for `create`, `read`, `update`, and `delete`
    operations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data还提供了一些基本的Java接口，例如`CrudRepository`，以使仓库的定义更加简单。基本接口`CrudRepository`为我们提供了`创建`、`读取`、`更新`和`删除`操作的标准方法。
- en: 'To specify a repository for handling the JPA entity `ReviewEntity`, we only
    need to declare the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定处理JPA实体`ReviewEntity`的仓库，我们只需要声明以下内容：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example we use a class, `ReviewEntityPK`, to describe a composite primary
    key. It looks as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用一个类，`ReviewEntityPK`，来描述一个复合主键。它看起来如下所示：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have also added an extra method, `findByProductId`, which allows us to look
    up `Review` entities based on `productid` – a field that is part of the primary
    key. The naming of the method follows a naming convention defined by Spring Data
    that allows Spring Data to generate the implementation of this method on the fly
    as well.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个额外的方法`findByProductId`，允许我们根据`productid`（它是主键的一部分）查找`Review`实体。方法的命名遵循Spring
    Data定义的命名约定，允许Spring Data动态生成此方法的实现。
- en: 'If we want to use the repository, we can simply inject it and then start to
    use it, for example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要使用仓库，我们可以简单地注入它，然后开始使用它，例如：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Added to the `CrudRepository` interface, Spring Data also provides a reactive
    base interface, `ReactiveCrudRepository`, which enables reactive repositories.
    The methods in this interface do not return objects or collections of objects;
    instead, they return **Mono** and **Flux** objects. `Mono` and `Flux` objects
    are, as we will see in *Chapter 7*, *Developing Reactive Microservices*, reactive
    streams that are capable of returning either `0...1` or `0...m` entities as they
    become available on the stream.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`CrudRepository`接口外，Spring Data还提供了一个反应式的基本接口`ReactiveCrudRepository`，它使得反应式仓库成为可能。该接口中的方法不返回对象或对象集合；相反，它们返回**Mono**和**Flux**对象。正如我们将在第7章*开发反应式微服务*中看到的，`Mono`和`Flux`对象是能够返回0到1个或0到m个实体作为它们在流中可用时的反应式流。
- en: The reactive-based interface can only be used by Spring Data subprojects that
    support reactive database drivers; that is, they are based on non-blocking I/O.
    The Spring Data MongoDB subproject supports reactive repositories, while Spring
    Data JPA does not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a reactive repository for handling the MongoDB entity, `RecommendationEntity`,
    as described previously, might look something like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This concludes the section on Spring Data. Now let’s see how we can use Spring
    Cloud Stream to develop message-based asynchronous services.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will not focus on Spring Cloud in this part; we will do that in *Part 2*
    of the book, from *Chapter 8*, *Introduction to Spring Cloud,* to *Chapter 14*,
    *Understanding Distributed Tracing*. However, we will bring in one of the modules
    that’s part of Spring Cloud: **Spring Cloud Stream**. Spring Cloud Stream provides
    a streaming abstraction over messaging, based on the **publish and subscribe**
    integration pattern. Spring Cloud Stream currently comes with built-in support
    for Apache Kafka and RabbitMQ. A number of separate projects exist that provide
    integration with other popular messaging systems. See [https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)
    for more details.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The core concepts in Spring Cloud Stream are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Message**: A data structure that’s used to describe data sent to and received
    from a messaging system.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**: Sends messages to the messaging system, also known as a **Supplier**.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: Receives messages from the messaging system, also known as
    a **Consumer**.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination**: Used to communicate with the messaging system. Publishers
    use output destinations and subscribers use input destinations. Destinations are
    mapped by the specific binders to queues and topics in the underlying messaging
    system.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binder**: A binder provides the actual integration with a specific messaging
    system, similar to what a JDBC driver does for a specific type of database.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual messaging system to be used is determined at runtime, depending on
    what is found on the classpath. Spring Cloud Stream comes with opinionated conventions
    on how to handle messaging. These conventions can be overridden by specifying
    a configuration for messaging features such as consumer groups, partitioning,
    persistence, durability, and error handling; for example, retries and dead letter
    queue handling.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Code examples for sending and receiving messages
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand how all this fits together, let’s look at some source code
    examples.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Stream comes with two programming models: one older and nowadays
    deprecated model based on the use of annotations (for example, `@EnableBinding`,
    `@Output`, and `@StreamListener`) and one newer model based on writing functions.
    In this book, we will use functional implementations.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a publisher, we only need to implement the `java.util.function.Supplier`
    functional interface as a Spring Bean. For example, the following is a publisher
    that publishes messages as a String:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A subscriber is implemented as a Spring Bean implementing the `java.util.function.Consumer`
    functional interface. For example, the following is a subscriber that consumes
    messages as Strings:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is also possible to define a Spring Bean that processes messages, meaning
    that it both consumes and publishes messages. This can be done by implementing
    the `java.util.function.Function` functional interface. For example, a Spring
    Bean that consumes incoming messages and publishes a new message after some processing
    (both messages are Strings in this example):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make Spring Cloud Stream aware of these functions, we need to declare them
    using the `spring.cloud.function.definition` configuration property. For example,
    for the three functions defined previously, this would look as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to tell Spring Cloud Stream what destination to use for each
    function. To connect our three functions so that our processor consumes messages
    from our publisher and our subscriber consumes messages from the processor, we
    can supply the following configuration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will result in the following message flow:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A supplier is triggered by Spring Cloud Stream by default every second, so
    we could expect output like the following if we start a Spring Boot application
    including the functions and configuration described previously:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In cases where the supplier should be triggered by an external event instead
    of using a timer, the `StreamBridge` helper class can be used. For example, if
    a message should be published to the processor when a REST API, `sampleCreateAPI`,
    is called, the code could look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we understand the various Spring APIs, let’s learn a bit about Docker
    and containers in the next section.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that Docker and the concept of containers need no in-depth introduction.
    Docker made the concept of containers as a lightweight alternative to virtual
    machines very popular in 2013\. A container is actually a process in a Linux host
    that uses Linux **namespaces** to provide isolation between different containers,
    in terms of their use of global system resources such as users, processes, filesystems,
    and networking. Linux **control groups** (also known as **cgroups**) are used
    to limit the amount of CPU and memory that a container is allowed to consume.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Compared to a virtual machine that uses a hypervisor to run a complete copy
    of an operating system in each virtual machine, the overhead in a container is
    a fraction of the overhead in a traditional virtual machine.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: This leads to much faster startup times and significantly lower overhead in
    terms of CPU and memory usage.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The isolation that’s provided for a container is, however, not considered to
    be as secure as the isolation that’s provided for a virtual machine. With the
    release of Windows Server 2016, Microsoft supports the use of Docker in Windows
    servers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: During the last few years, a lightweight form of virtual machines has evolved.
    It mixes the best of traditional virtual machines and containers, providing virtual
    machines with a footprint and startup time similar to containers and with the
    same level of secure isolation provided by traditional virtual machines. Some
    examples are **Amazon Firecracker** and **Microsoft Windows Subsystem for Linux
    v2** (**WSL2**). For more information, see [https://firecracker-microvm.github.io](https://firecracker-microvm.github.io)
    and [https://docs.microsoft.com/en-us/windows/wsl/](https://docs.microsoft.com/en-us/windows/wsl/).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Containers are very useful during both development and testing. Being able to
    start up a complete system landscape of cooperating microservices and resource
    managers (for example, database servers, messaging brokers, and so on) with a
    single command for testing is simply amazing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write scripts in order to automate end-to-end tests of our
    microservice landscape. A test script can start up the microservice landscape,
    run tests using the exposed APIs, and tear down the landscape. This type of automated
    test script is very useful, both for running locally on a developer PC before
    pushing code to a source code repository, and to be executed as a step in a delivery
    pipeline. A build server can run these types of tests in its continuous integration
    and deployment process whenever a developer pushes code to the source repository.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: For production usage, we need a container orchestrator such as Kubernetes. We
    will come back to container orchestrators and Kubernetes later in this book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the microservices we will look at in this book, a **Dockerfile**
    such as the following is all that is required to run the microservice as a Docker
    container:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we want to start and stop many containers with one command, **Docker Compose**
    is the perfect tool. Docker Compose uses a YAML file to describe the containers
    to be managed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'For our microservices, it might look something like the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let me explain the preceding source code a little:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The `build` directive is used to specify which Dockerfile to use for each microservice.
    Docker Compose will use it to build a Docker image and then launch a Docker container
    based on that Docker image.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ports` directive for the composite service is used to expose port `8080`
    on the server where Docker runs. On a developer’s machine, this means that the
    port of the composite service can be reached simply by using `localhost:8080!`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the containers in the YAML files can be managed with simple commands such
    as the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose up -d`: Starts all containers. `-d` means that the containers
    run in the background, not locking the terminal from where the command was executed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose down`: Stops and removes all containers.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose logs -f --tail=0`: Prints out log messages from all containers.
    `-f` means that the command will not complete, and instead waits for new log messages.
    `--tail=0` means that we don’t want to see any previous log messages, only new
    ones.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of Docker Compose commands, see [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to Docker. We will go into more detail about Docker
    starting with *Chapter 4*, *Deploying Our Microservices Using Docker*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been introduced to Spring Boot and complementary open
    source tools that can be used to build cooperating microservices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is used to simplify the development of Spring-based, production-ready
    applications, such as microservices. It is strongly opinionated in terms of how
    to set up both core modules from the Spring Framework and third-party tools. Using
    Spring WebFlux, we can develop microservices that expose reactive, that is, non-blocking,
    REST services. To document these REST services, we can use `springdoc-openapi`
    to create OpenAPI-based documentation for the APIs. If we need to persist data
    used by the microservices, we can use Spring Data, which provides an elegant abstraction
    for accessing and manipulating persistent data using entities and repositories.
    Spring Data’s programming model is similar, but not fully portable between different
    types of databases, for example, relational, document, key-value, and graph databases.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: If we prefer sending messages asynchronously between our microservices, we can
    use Spring Cloud Stream, which provides a streaming abstraction over messaging.
    Spring Cloud Stream comes with out-of-the-box support for Apache Kafka and RabbitMQ
    but can be extended to support other messaging brokers using custom binders. Finally,
    Docker makes the concept of containers as a lightweight alternative to virtual
    machines easy to use. Based on Linux namespaces and control groups, containers
    provide isolation similar to what traditional virtual machines provide, but with
    a significantly lower overhead in terms of CPU and memory usage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our first small steps, creating microservices
    with minimalistic functionality using Spring Boot and Spring WebFlux.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `@SpringBootApplication` annotation?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main differences between the older Spring component for developing
    REST services, Spring Web MVC, and the new Spring WebFlux?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `springdoc-openapi` help a developer document REST APIs?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function of a repository in Spring Data and what is the simplest
    possible implementation of a repository?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a binder in Spring Cloud Stream?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of Docker Compose?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 的目的是什么？
