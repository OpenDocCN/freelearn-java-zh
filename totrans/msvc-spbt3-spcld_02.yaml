- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be introduced to how to build a set of cooperating
    microservices using Spring Boot, focusing on how to develop functionality that
    delivers business value. The challenges with microservices that we pointed out
    in the previous chapter will be considered only to some degree, but they will
    be addressed to their full extent in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop microservices that contain business logic based on plain **Spring
    Beans** and expose REST APIs using **Spring WebFlux**. The APIs will be documented
    based on the OpenAPI Specification using `springdoc-openapi`. To make the data
    processed by the microservices persistent, we will use **Spring Data** to store
    data in both SQL and NoSQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Boot v2.0 was released in March 2018, it has become much easier
    to develop reactive microservices, including non-blocking synchronous REST APIs.
    To develop message-based asynchronous services, we will use **Spring Cloud Stream**.
    Refer to *Chapter 1*, *Introduction to Microservices*, the *Reactive microservices*
    section, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In November 2022, Spring Boot 3.0 was released. It is based on Spring Framework
    6.0 and Jakarta EE 9, also being compatible with Jakarta EE 10\. Java 17, the
    current **long-term support** (**LTS**) release, is required as the minimum Java
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use **Docker** to run our microservices as containers. This
    will allow us to start and stop our microservice landscape, including database
    servers and a message broker, with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot of technologies and frameworks, so let’s go through each of them
    briefly to see what they are about!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce the following open source projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (This section also includes an overview of what’s new in v3.0 and on how to
    migrate v2 applications.)
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`springdoc-openapi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about each product will be provided in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not contain any source code that can be downloaded, nor does
    it require any tools to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot, and the Spring Framework that Spring Boot is based on, is a great
    framework for developing microservices in Java.
  prefs: []
  type: TYPE_NORMAL
- en: When the Spring Framework v1.0 was released back in 2004, one of its main goals
    was to address the overly complex **J2EE** standard (short for **Java 2 Platform,
    Enterprise Edition**) with its infamous and heavyweight deployment descriptors.
    The Spring Framework provided a much more lightweight development model based
    on the concept of **dependency injection**. The Spring Framework also used far
    more lightweight XML configuration files compared to the deployment descriptors
    in J2EE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things even worse with the J2EE standard, the heavyweight deployment
    descriptors actually came in two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard deployment descriptors, describing the configuration in a standardized
    way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor-specific deployment descriptors, mapping the configuration to vendor-specific
    features in the vendor’s application server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In 2006, J2EE was renamed **Java EE,** short for **Java Platform, Enterprise
    Edition**. In 2017, Oracle submitted Java EE to the Eclipse Foundation. In February
    2018, Java EE was renamed Jakarta EE. The new name, Jakarta EE, also affects the
    names of the Java packages defined by the standard, requiring developers to perform
    package renaming when upgrading to Jakarta EE, as described in the *Migrating
    a Spring Boot 2 application* section. Over the years, while the Spring Framework
    gained increasing popularity, the functionality in the Spring Framework grew significantly.
    Slowly, the burden of setting up a Spring application using the no-longer-so-lightweight
    XML configuration file became a problem.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Spring Boot v1.0 was released, addressing these problems!
  prefs: []
  type: TYPE_NORMAL
- en: Convention over configuration and fat JAR files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring Boot targets the fast development of production-ready Spring applications
    by being strongly opinionated about how to set up both core modules from the Spring
    Framework and third-party products, such as libraries that are used for logging
    or connecting to a database. Spring Boot does that by applying a number of conventions
    by default, minimizing the need for configuration. Whenever required, each convention
    can be overridden by writing some configuration, case by case. This design pattern
    is known as **convention over configuration** and minimizes the need for initial
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration, when required, is, in my opinion, written best using Java and
    annotations. The good old XML-based configuration files can still be used, although
    they are significantly smaller than before Spring Boot was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Added to the usage of convention over configuration, Spring Boot also favors
    a runtime model based on a standalone JAR file, also known as a **fat JAR file**.
    Before Spring Boot, the most common way to run a Spring application was to deploy
    it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment
    is still supported by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: A fat JAR file contains not only the classes and resource files of the application
    itself but also all the JAR files the application depends on. This means that
    the fat JAR file is the only JAR file required to run the application; that is,
    we only need to transfer one JAR file to an environment where we want to run the
    application instead of transferring the application’s JAR file along with all
    the JAR files the application depends on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a fat JAR requires no separately installed Java EE web server, such
    as Apache Tomcat. Instead, it can be started with a simple command such as `java
    -jar app.jar`, making it a perfect choice for running in a Docker container! If
    the Spring Boot application, for example, uses HTTP to expose a REST API, it will
    also contain an embedded web server.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples for setting up a Spring Boot application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand what this means, let’s look at some source code examples.
  prefs: []
  type: TYPE_NORMAL
- en: We will only look at some small fragments of code here to point out the main
    features. For a fully working example, you’ll have to wait until the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: The magic @SpringBootApplication annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The convention-based autoconfiguration mechanism can be initiated by annotating
    the application class (that is, the class that contains the static `main` method)
    with the `@SpringBootApplication` annotation. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following functionality will be provided by this annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: It enables component scanning, that is, looking for Spring components and configuration
    classes in the package of the application class and all its sub-packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application class itself becomes a configuration class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath
    that it can configure automatically. For example, if you have Tomcat in the classpath,
    Spring Boot will automatically configure Tomcat as an embedded web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s assume we have the following Spring component in the package of the application
    class (or in one of its sub-packages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another component in the application can get this component automatically injected,
    also known as **auto-wired**, using the `@Autowired` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I prefer using constructor injection (over field and setter injection) to keep
    the state in my components immutable. An immutable state is important if you want
    to be able to run the component in a multithreaded runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use components that are declared in a package outside the application’s
    package, for example, a utility component shared by multiple Spring Boot applications,
    we can complement the `@SpringBootApplication` annotation in the application class
    with a `@ComponentScan` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now auto-wire components from the `se.magnus.util` package in the application
    code, for example, a utility component named `MyUtility`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This utility component can be auto-wired in an application component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Java-based configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to override Spring Boot’s default configuration or we want to add
    our own configuration, we can simply annotate a class with `@Configuration` and
    it will be picked up by the component scanning mechanism we described previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to set up a filter in the processing of HTTP requests
    (handled by Spring WebFlux, which is described in the following section) that
    writes a log message at the beginning and the end of the processing, we can configure
    a log filter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can also place the configuration directly in the application class since
    the `@SpringBootApplication` annotation implies the `@Configuration` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all for now about Spring Boot, but before moving to the next component,
    let’s see what is new in Spring Boot 3.0 and how to migrate a Spring Boot 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: What’s new in Spring Boot 3.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the scope of this book, the most important new items in Spring Boot 3.0
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observability**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 3.0 comes with improved support for observability, adding built-in
    support for distributed tracing to the already existing support for metrics and
    logging in previous Spring Boot releases. The new distributed tracing support
    is based on a new Observability API in Spring Framework v6.0 and a new module
    named Micrometer Tracing. Micrometer Tracing is based on Spring Cloud Sleuth,
    which is now deprecated. *Chapter 14*, *Understand Distributed Tracing*, covers
    how to use the new support for observability and distributed tracing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Native compilation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 3.0 also comes with support for compiling Spring Boot applications
    to native images, which are standalone executable files. A native-compiled Spring
    Boot application starts significantly faster and consumes less memory. *Chapter
    23*, *Native-Compiled Java Microservices*, describes how to native compile microservices
    based on Spring Boot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Virtual threads**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Spring Boot 3.0 comes with support for lightweight threads called virtual
    threads from the OpenJDK Project Loom. Virtual threads are expected to simplify
    the programming model for developing reactive non-blocking microservices, for
    example, compared to the programming model used in Project Reactor and various
    Spring components. Virtual threads are currently only available as a preview in
    Java 19\. They also currently lack support for composability features, for example,
    required to build microservices that concurrently aggregate information from other
    microservices. Therefore, virtual threads will not be covered in this book. *Chapter
    7*, *Developing Reactive Microservices*,covers how virtual threads can be implemented
    using Project Reactor and Spring WebFlux.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Migrating a Spring Boot 2 application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already have applications based on Spring Boot 2, you might be interested
    in understanding what it takes to migrate to Spring Boot 3.0\. Here is a list
    of actions you need to take:'
  prefs: []
  type: TYPE_NORMAL
- en: Pivotal recommends first upgrading Spring Boot 2 applications to the latest
    v2.7.x release since their migration guide assumes you are on v2.7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you have Java 17 or later installed, both in your development and runtime
    environments. If your Spring Boot applications are deployed as Docker containers,
    you need to ensure that your company approves the usage of Docker images based
    on Java 17 or newer releases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove calls to deprecated methods in Spring Boot 2.x. All deprecated methods
    are removed in Spring Boot 3.0, so you must ensure that your application does
    not call any of these methods. To see exactly where calls are being made in your
    application, you can enable the `lint:deprecation` flag in the Java compiler using
    (assuming the use of Gradle):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename all imports of `javax` packages that are now part of Jakarta EE to `jakarta`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For libraries that are not managed by Spring, you need to ensure that you are
    using versions that are Jakarta compliant, that is, using `jakarta` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For breaking changes and other important migration information, read through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://docs.spring.io/spring-security/reference/migration/index.html](https://docs.spring.io/spring-security/reference/migration/index.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that you have end-to-end black-box tests that verify the functionality
    of your application. Run these tests before and after the migration to ensure
    that the application’s functionality has not been affected by the migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When migrating the source code of the previous edition of this book to Spring
    Boot 3.0, the most time-consuming part was figuring out how to handle breaking
    changes in the Spring Security configuration; see *Chapter 11*, *Securing Access
    to APIs*, for details. As an example, the following configuration of the authorization
    server in the previous edition needed to be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration looks like the following with Spring Boot 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The end-to-end test script, `test-em-all.bash`, that comes with each chapter
    turned out to be indispensable in verifying that the functionality was unaffected
    after the migration of each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about Spring Boot, let’s talk about Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot 3.0 is based on the Spring Framework 6.0, which has built-in support
    for developing reactive applications. The Spring Framework uses **Project Reactor**
    as the base implementation of its reactive support and also comes with a new web
    framework, **Spring WebFlux**, which supports the development of reactive, that
    is, non-blocking, HTTP clients and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring WebFlux supports two different programming models:'
  prefs: []
  type: TYPE_NORMAL
- en: An annotation-based imperative style, similar to the already existing web framework,
    Spring Web MVC, but with support for reactive services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new function-oriented model based on routers and handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will use the annotation-based imperative style to demonstrate
    how easy it is to move REST services from Spring Web MVC to Spring WebFlux and
    then start to refactor the services so that they become fully reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux also provides a fully reactive HTTP client, `WebClient`, as a
    complement to the existing `RestTemplate` client.
  prefs: []
  type: TYPE_NORMAL
- en: Spring WebFlux supports running on a servlet container based on the Jakarta
    Servlet specification v5.0 or higher, such as Apache Tomcat, but also supports
    reactive non-servlet-based embedded web servers such as Netty ([https://netty.io/](https://netty.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: The Servlet specification is a specification in the Java EE platform that standardizes
    how to develop Java applications that communicate using web protocols such as
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples of setting up a REST service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can create a REST service based on Spring WebFlux, we need to add
    Spring WebFlux (and the dependencies that Spring WebFlux requires) to the classpath
    for Spring Boot to be detected and configured during startup. Spring Boot provides
    a large number of convenient **starter dependencies** that bring in a specific
    feature, together with the dependencies each feature normally requires. So, let’s
    use the starter dependency for Spring WebFlux and then see what a simple REST
    service looks like!
  prefs: []
  type: TYPE_NORMAL
- en: Starter dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this book, we will use Gradle as our build tool, so the Spring WebFlux starter
    dependency will be added to the `build.gradle` file. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why we don’t specify a version number. We will talk about
    that when we look at a complete example in *Chapter 3*, *Creating a Set of Cooperating
    Microservices*!
  prefs: []
  type: TYPE_NORMAL
- en: 'When the microservice is started up, Spring Boot will detect Spring WebFlux
    on the classpath and configure it, as well as other things such as starting up
    an embedded web server. Spring WebFlux uses Netty by default, which we can see
    from the log output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to switch from Netty to Tomcat as our embedded web server, we can
    override the default configuration by excluding Netty from the starter dependency
    and adding the starter dependency for Tomcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After restarting the microservice, we can see that Spring Boot picked Tomcat
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Property files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see from the preceding examples, the web server is started up using
    port `8080`. If you want to change the port, you can override the default value
    using a property file. Spring Boot application property files can either be a
    `.properties` file or a YAML file. By default, they are named `application.properties`
    and `application.yml`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use YAML files so that the HTTP port used by the embedded
    web server can be changed to, for example, `7001`. By doing this, we can avoid
    port collisions with other microservices running on the same server. To do this,
    we can add the following line to the `application.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we begin to develop our microservices as containers in *Chapter 4*, *Deploying
    Our Microservices Using Docker*, port collisions will no longer be a problem.
    Each container has its own hostname and port range, so all microservices can use,
    for example, port `8080` without colliding with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Sample RestController
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, with Spring WebFlux and an embedded web server of our choice in place,
    we can write a REST service in the same way as when using Spring MVC, that is,
    as a `RestController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `@GetMapping` annotation on the `listResources()` method will map the Java
    method to an HTTP `GET` API on the `host:8080/myResource` URL. The return value
    of the `List<Resource>` type will be converted into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve talked about Spring WebFlux, let’s see how we can document the
    APIs we develop using Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: springdoc-openapi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very important aspect of developing APIs, for example, RESTful services,
    is how to document them so that they are easy to use. The Swagger specification
    from SmartBear Software is one of the most widely used ways of documenting RESTful
    services. Many leading API gateways have native support for exposing the documentation
    of RESTful services using the Swagger specification.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the **OpenAPI Initiative** and created the **OpenAPI Specification**. The
    name Swagger is still used for the tooling provided by SmartBear Software.
  prefs: []
  type: TYPE_NORMAL
- en: '`springdoc-openapi` is an open source project, separate from the Spring Framework,
    that can create OpenAPI-based API documentation at runtime. It does so by examining
    the application, for example, inspecting WebFlux and Swagger-based annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at full source code examples in upcoming chapters, but for now,
    the following condensed screenshot (removed parts are marked with “**…**”) of
    a sample API documentation will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B19825_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Sample API documentation visualized using Swagger UI'
  prefs: []
  type: TYPE_NORMAL
- en: Note the big **Execute** button, which can be used to actually try out the API,
    not just read its documentation!
  prefs: []
  type: TYPE_NORMAL
- en: '`springdoc-openapi` helps us to document the APIs exposed by our microservices.
    Now, let’s move on to Spring Data.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Data comes with a common programming model for persisting data in various
    types of database engines, ranging from traditional relational databases (SQL
    databases) to various types of NoSQL database engines, such as document databases
    (for example, MongoDB), key-value databases (for example, Redis), and graph databases
    (for example, Neo4j).
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Data project is divided into several subprojects, and in this book,
    we will use Spring Data subprojects for MongoDB and JPA that have been mapped
    to a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: '**JPA** stands for **Jakarta Persistence API** and is a Java specification
    about how to handle relational data. Please go to [https://jakarta.ee/specifications/persistence/](https://jakarta.ee/specifications/persistence/)
    for the latest specifications. Jakarta EE 9 is based on Jakarta Persistence 3.0.'
  prefs: []
  type: TYPE_NORMAL
- en: The two core concepts of the programming model in Spring Data are **entities**
    and **repositories**. Entities and repositories generalize how data is stored
    and accessed from the various types of databases. They provide a common abstraction
    but still support adding database-specific behavior to the entities and repositories.
    These two core concepts are briefly explained together with some illustrative
    code examples as we proceed through this chapter. Remember that more details will
    be provided in the upcoming chapters!
  prefs: []
  type: TYPE_NORMAL
- en: Even though Spring Data provides a common programming model for different types
    of databases, this doesn’t mean that you will be able to write portable source
    code. For example, switching the database technology from a SQL database to a
    NoSQL database will, in general, not be possible without some changes in the source
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An entity describes the data that will be stored by Spring Data. Entity classes
    are, in general, annotated with a mix of generic Spring Data annotations and annotations
    that are specific to each database technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, an entity that will be stored in a relational database can be
    annotated with JPA annotations such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If an entity is to be stored in a MongoDB database, annotations from the Spring
    Data MongoDB subproject can be used together with generic Spring Data annotations.
    For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `@Id` and `@Version` annotations are generic annotations, while the `@Document`
    annotation is specific to the Spring Data MongoDB subproject.
  prefs: []
  type: TYPE_NORMAL
- en: This can be revealed by studying the `import` statements; the `import` statements
    that contain `mongodb` come from the Spring Data MongoDB subproject.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Repositories are used to store and access data from different types of databases.
    In its most basic form, a repository can be declared as a Java interface, and
    Spring Data will generate its implementation on the fly using opinionated conventions.
    These conventions can be overridden and/or complemented by additional configuration
    and, if required, some Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data also comes with some base Java interfaces, for example, `CrudRepository`,
    to make the definition of a repository even simpler. The base interface, `CrudRepository`,
    provides us with standard methods for `create`, `read`, `update`, and `delete`
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a repository for handling the JPA entity `ReviewEntity`, we only
    need to declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we use a class, `ReviewEntityPK`, to describe a composite primary
    key. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have also added an extra method, `findByProductId`, which allows us to look
    up `Review` entities based on `productid` – a field that is part of the primary
    key. The naming of the method follows a naming convention defined by Spring Data
    that allows Spring Data to generate the implementation of this method on the fly
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use the repository, we can simply inject it and then start to
    use it, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Added to the `CrudRepository` interface, Spring Data also provides a reactive
    base interface, `ReactiveCrudRepository`, which enables reactive repositories.
    The methods in this interface do not return objects or collections of objects;
    instead, they return **Mono** and **Flux** objects. `Mono` and `Flux` objects
    are, as we will see in *Chapter 7*, *Developing Reactive Microservices*, reactive
    streams that are capable of returning either `0...1` or `0...m` entities as they
    become available on the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive-based interface can only be used by Spring Data subprojects that
    support reactive database drivers; that is, they are based on non-blocking I/O.
    The Spring Data MongoDB subproject supports reactive repositories, while Spring
    Data JPA does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a reactive repository for handling the MongoDB entity, `RecommendationEntity`,
    as described previously, might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the section on Spring Data. Now let’s see how we can use Spring
    Cloud Stream to develop message-based asynchronous services.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will not focus on Spring Cloud in this part; we will do that in *Part 2*
    of the book, from *Chapter 8*, *Introduction to Spring Cloud,* to *Chapter 14*,
    *Understanding Distributed Tracing*. However, we will bring in one of the modules
    that’s part of Spring Cloud: **Spring Cloud Stream**. Spring Cloud Stream provides
    a streaming abstraction over messaging, based on the **publish and subscribe**
    integration pattern. Spring Cloud Stream currently comes with built-in support
    for Apache Kafka and RabbitMQ. A number of separate projects exist that provide
    integration with other popular messaging systems. See [https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The core concepts in Spring Cloud Stream are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message**: A data structure that’s used to describe data sent to and received
    from a messaging system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publisher**: Sends messages to the messaging system, also known as a **Supplier**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: Receives messages from the messaging system, also known as
    a **Consumer**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination**: Used to communicate with the messaging system. Publishers
    use output destinations and subscribers use input destinations. Destinations are
    mapped by the specific binders to queues and topics in the underlying messaging
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binder**: A binder provides the actual integration with a specific messaging
    system, similar to what a JDBC driver does for a specific type of database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual messaging system to be used is determined at runtime, depending on
    what is found on the classpath. Spring Cloud Stream comes with opinionated conventions
    on how to handle messaging. These conventions can be overridden by specifying
    a configuration for messaging features such as consumer groups, partitioning,
    persistence, durability, and error handling; for example, retries and dead letter
    queue handling.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples for sending and receiving messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To better understand how all this fits together, let’s look at some source code
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud Stream comes with two programming models: one older and nowadays
    deprecated model based on the use of annotations (for example, `@EnableBinding`,
    `@Output`, and `@StreamListener`) and one newer model based on writing functions.
    In this book, we will use functional implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a publisher, we only need to implement the `java.util.function.Supplier`
    functional interface as a Spring Bean. For example, the following is a publisher
    that publishes messages as a String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A subscriber is implemented as a Spring Bean implementing the `java.util.function.Consumer`
    functional interface. For example, the following is a subscriber that consumes
    messages as Strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to define a Spring Bean that processes messages, meaning
    that it both consumes and publishes messages. This can be done by implementing
    the `java.util.function.Function` functional interface. For example, a Spring
    Bean that consumes incoming messages and publishes a new message after some processing
    (both messages are Strings in this example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To make Spring Cloud Stream aware of these functions, we need to declare them
    using the `spring.cloud.function.definition` configuration property. For example,
    for the three functions defined previously, this would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to tell Spring Cloud Stream what destination to use for each
    function. To connect our three functions so that our processor consumes messages
    from our publisher and our subscriber consumes messages from the processor, we
    can supply the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following message flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A supplier is triggered by Spring Cloud Stream by default every second, so
    we could expect output like the following if we start a Spring Boot application
    including the functions and configuration described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where the supplier should be triggered by an external event instead
    of using a timer, the `StreamBridge` helper class can be used. For example, if
    a message should be published to the processor when a REST API, `sampleCreateAPI`,
    is called, the code could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand the various Spring APIs, let’s learn a bit about Docker
    and containers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that Docker and the concept of containers need no in-depth introduction.
    Docker made the concept of containers as a lightweight alternative to virtual
    machines very popular in 2013\. A container is actually a process in a Linux host
    that uses Linux **namespaces** to provide isolation between different containers,
    in terms of their use of global system resources such as users, processes, filesystems,
    and networking. Linux **control groups** (also known as **cgroups**) are used
    to limit the amount of CPU and memory that a container is allowed to consume.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to a virtual machine that uses a hypervisor to run a complete copy
    of an operating system in each virtual machine, the overhead in a container is
    a fraction of the overhead in a traditional virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to much faster startup times and significantly lower overhead in
    terms of CPU and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: The isolation that’s provided for a container is, however, not considered to
    be as secure as the isolation that’s provided for a virtual machine. With the
    release of Windows Server 2016, Microsoft supports the use of Docker in Windows
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: During the last few years, a lightweight form of virtual machines has evolved.
    It mixes the best of traditional virtual machines and containers, providing virtual
    machines with a footprint and startup time similar to containers and with the
    same level of secure isolation provided by traditional virtual machines. Some
    examples are **Amazon Firecracker** and **Microsoft Windows Subsystem for Linux
    v2** (**WSL2**). For more information, see [https://firecracker-microvm.github.io](https://firecracker-microvm.github.io)
    and [https://docs.microsoft.com/en-us/windows/wsl/](https://docs.microsoft.com/en-us/windows/wsl/).
  prefs: []
  type: TYPE_NORMAL
- en: Containers are very useful during both development and testing. Being able to
    start up a complete system landscape of cooperating microservices and resource
    managers (for example, database servers, messaging brokers, and so on) with a
    single command for testing is simply amazing.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can write scripts in order to automate end-to-end tests of our
    microservice landscape. A test script can start up the microservice landscape,
    run tests using the exposed APIs, and tear down the landscape. This type of automated
    test script is very useful, both for running locally on a developer PC before
    pushing code to a source code repository, and to be executed as a step in a delivery
    pipeline. A build server can run these types of tests in its continuous integration
    and deployment process whenever a developer pushes code to the source repository.
  prefs: []
  type: TYPE_NORMAL
- en: For production usage, we need a container orchestrator such as Kubernetes. We
    will come back to container orchestrators and Kubernetes later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the microservices we will look at in this book, a **Dockerfile**
    such as the following is all that is required to run the microservice as a Docker
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we want to start and stop many containers with one command, **Docker Compose**
    is the perfect tool. Docker Compose uses a YAML file to describe the containers
    to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our microservices, it might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me explain the preceding source code a little:'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` directive is used to specify which Dockerfile to use for each microservice.
    Docker Compose will use it to build a Docker image and then launch a Docker container
    based on that Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ports` directive for the composite service is used to expose port `8080`
    on the server where Docker runs. On a developer’s machine, this means that the
    port of the composite service can be reached simply by using `localhost:8080!`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the containers in the YAML files can be managed with simple commands such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose up -d`: Starts all containers. `-d` means that the containers
    run in the background, not locking the terminal from where the command was executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose down`: Stops and removes all containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose logs -f --tail=0`: Prints out log messages from all containers.
    `-f` means that the command will not complete, and instead waits for new log messages.
    `--tail=0` means that we don’t want to see any previous log messages, only new
    ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of Docker Compose commands, see [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief introduction to Docker. We will go into more detail about Docker
    starting with *Chapter 4*, *Deploying Our Microservices Using Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been introduced to Spring Boot and complementary open
    source tools that can be used to build cooperating microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is used to simplify the development of Spring-based, production-ready
    applications, such as microservices. It is strongly opinionated in terms of how
    to set up both core modules from the Spring Framework and third-party tools. Using
    Spring WebFlux, we can develop microservices that expose reactive, that is, non-blocking,
    REST services. To document these REST services, we can use `springdoc-openapi`
    to create OpenAPI-based documentation for the APIs. If we need to persist data
    used by the microservices, we can use Spring Data, which provides an elegant abstraction
    for accessing and manipulating persistent data using entities and repositories.
    Spring Data’s programming model is similar, but not fully portable between different
    types of databases, for example, relational, document, key-value, and graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: If we prefer sending messages asynchronously between our microservices, we can
    use Spring Cloud Stream, which provides a streaming abstraction over messaging.
    Spring Cloud Stream comes with out-of-the-box support for Apache Kafka and RabbitMQ
    but can be extended to support other messaging brokers using custom binders. Finally,
    Docker makes the concept of containers as a lightweight alternative to virtual
    machines easy to use. Based on Linux namespaces and control groups, containers
    provide isolation similar to what traditional virtual machines provide, but with
    a significantly lower overhead in terms of CPU and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our first small steps, creating microservices
    with minimalistic functionality using Spring Boot and Spring WebFlux.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of the `@SpringBootApplication` annotation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the main differences between the older Spring component for developing
    REST services, Spring Web MVC, and the new Spring WebFlux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `springdoc-openapi` help a developer document REST APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the function of a repository in Spring Data and what is the simplest
    possible implementation of a repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a binder in Spring Cloud Stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
