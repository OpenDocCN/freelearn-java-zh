- en: Working with Implicits and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"How ironic, when you do business you create exceptions to create new opportunities,
    when you write code (do a job) you handle exceptions to make it clean."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Pushkar Saraf'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programs are expressions. When we say we want to run a functional
    program, we mean we want to evaluate the expressions. When we evaluate an expression,
    we get a value. We also know that functional programming is about composing and
    evaluating expressions. This means that the function signature you write down
    holds true for each evaluation. But there are scenarios where it''s unlikely to
    happen. Your code might not work as expected and might result in an exceptional
    behavior. How do we deal with such scenarios, and how do we handle exceptions
    in functional programming? These are some fundamental questions, and anyone who''s
    starting with functional programming might ask the same. So, in this chapter,
    we''ll try answering these questions, and then we''ll move forward to look at
    another important and much-talked-about concept in Scala known as **implicits**.
    We''ll take a look at what they are and the instances where we might want to use
    them. So here''s what we''ll go through in our chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling - the old way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the option way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either left or right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicits - what and why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by introducing an exceptional behavior to a particular functionality
    and handling it.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling – the old way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write some code so that we can talk about exception handling. Take a
    look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `toInt` is a function that takes a `String` value,
    which supposedly can be converted to a corresponding `Int` value. The definition
    looks okay, but as functional programmers, we are so used to trying out the function
    to see whether it does what it says (in the definition). Let''s try out some calls
    to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Things worked fine for us. We passed a number in a string format and got the
    corresponding integer values. But what if you try something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Say that we get something unexpected, some exception saying this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of responding with an integer result, what we got is an exception—that''s
    bad. But let''s be positive; there are a few things that we can learn from this
    failure:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of our function was not right. It was telling us, *you give me
    a string and I'll give you back the corresponding integer.* But it didn't happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We knew that instead of the ideal cases, there might be scenarios where our
    operation might fail to complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, learning from this experience, we now have an idea that we might want to
    handle the unwanted scenarios. But how?
  prefs: []
  type: TYPE_NORMAL
- en: 'In some programming languages, we get a construct that wraps a block of code
    that might throw an exception and catches exceptions when thrown, and we are allowed
    to introduce our desired behaviour by putting in catch blocks. These are nothing
    but `try... catch` blocks. Why don''t we try out these blocks?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Something unexpected happened; you may want to check the string you passed
    for conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does this implementation seem reasonable? To some extent, it's a workaround
    and it does what it says in the function's signature. But returning zero in exceptional
    cases is still not a good option.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Option way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try and change the function signature in a way that we can reason about
    and modify it so that it does what it says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding definition, we knew that the response was optional. We might
    or might not get a corresponding integer value for every string we pass to our
    function. Hence, we made the response type an `Option[Int]`*.* Also, as you may
    have noticed, we used another construct available to us from the `scala.util`
    package, named `Try`*.* How do we use `Try`*?* We pass a function for its evaluation
    to the `Try` block's constructor/apply method. As might be obvious, the `Try`
    block's `apply` method takes a function as a `by-name` parameter, which tries
    to evaluate that function. Based on the result or exception, it responds as a
    `Success(value)` or `Failure(exception)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `Try`  construct and passed logic as an argument. On success*,*
    we responded as `Some(value)`, and in case of failure, we returned `None`*.* Both
    worked well, as these are subtypes of the `Option` type*.* We''ve already seen
    `Option[+T]` in [Chapter 9](part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84),
    *Using Powerful Functional Constructs.* Let''s talk a bit about the `Try[+T]`
    type*.* We will start with the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are comfortable working with parameterized types, it will be easier
    for us to understand the signature of `Try`*.* A couple of things to notice are
    the `Success` and `Failure` subtypes—no need to explain what they are here for.
    Let's take a look at the companion object of the type `Try`, which has an `apply`
    method, as discussed already. It expects a `by-name` parameter. Our famous `try...
    catch` block is taking care of the rest of the stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s one of the ways you may want to change the function signature to handle
    exceptions and work as it says it''s going to work. Let''s talk about a scenario
    where we might want to pipeline a few operations—in other words, we want to perform
    functional composition. Take a look at the following function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Seeing these two functions, it seems they can be pipelined together to perform
    logic in one go. But how? We can pass an account ID to our `getAccountInfo` function,
    which in turn returns an optional `AccountInfo`. We can take this account info
    and the amount and call `makeTransaction` to make a transaction. These two operations
    look good enough to be composed together, but the only problem we have is that
    the first one''s output is optional, and so the second function might or might
    not get called. So for this, the `flatMap` operation looks good. So let''s try
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we take a look at the preceding code, we can see that our `getAccountInfo`
    and `makeTransaction` functions return optional values and either of these results
    can be `None`*.* It will be hard for us to know which operation went wrong as
    there's no good error message that tells us what went wrong. So to conclude, `Option`
    is a way to handle such scenarios, but it would have been better if we had a way
    of knowing what went wrong. For that purpose, we can use another construct from
    Scala, named `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: Either left or right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala has an `Either[+A, +B]` type for us. But before we talk about `Either`,
    let''s use it. We''ll refactor our code with the `Either` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we knew things might go wrong with the conversion from
    a `string` to an `int`. So the result can be either an exception or the intended
    integer. So we tried to do the same: we used the `Either` type with the left value
    as a `String` message when things go wrong, and an `Int` as the right value. Why
    so? Let''s take a look at the signature of the `Either` type to understand that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding signatures, we can see that the `Either` type takes two
    type parameters, `A` and `B`; by convention, we think of the `Left` value as the
    exceptional case value and the right value as the intended resulting value. That''s
    the reason we declared the response type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This states that we expect either a `String` or an `Int` value. So the use
    case is clear. We got to know what happened with our operation—that is, the conversion
    from a string to the corresponding integer value. Now, why don''t we go ahead
    and try to do some function composition using the `Either` type? We can use the
    same scenario for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is interesting. This new construct made our life easier and gave us meaningful
    messages about the failures. We're also now able to recognize what went wrong,
    as well as when things went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `Either` helps us better in dealing with exceptions. Also, we've
    seen a couple of ways that we can deal with exceptional cases. What's the take
    away from the discussion? Let's conclude.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen a few of the constructs available for us to handle exceptional scenarios
    in Scala programs. You may argue that one of the constructs, `Try[+T]`, does nothing
    but use a *`try... catch` block to handle exceptions. So the response we have
    for the argument is in terms of *functional composition.* The reason you may want
    to go for `scala.util.Try[+T]` instead of a normal `try... catch` block is for
    reasons of functional composition*.**
  prefs: []
  type: TYPE_NORMAL
- en: '*The type provides us some functions, such as `map` for transformation and
    `flatMap` for composition, so that we can combine two operations together using
    the `flatMap` operation. If you''re wondering what this is, let me tell you that
    we have already seen examples of this. We wanted to compose two functions together
    to get the result using the `flatMap` method, which was possible only because
    our types `Try`*,* `Option`, and `Either` had this crazy-looking function named
    `flatMap`*.* It''s worth taking a look at the implementation of the `flatMap`
    method. This `flatMap` function for `Option` might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: According to the signature, we're going to pass `Option[A]`. The `A` argument
    here is nothing but a type parameter and a function of the form `A => Option[B]`,
    and the definition is going to give us back the type `Option[B]`. That's powerful,
    and helps us in composing the two functions together. That's one of the reasons
    you might want to go for `Option`/`Either`/`Try` constructs. Which of the three
    is going to be used depends upon the use case. The `Either` type gives you the
    convenience of returning a message when things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So that explains how we might want to handle exceptions in our Scala programs.
    Now let's go ahead and talk about a concept that Scala provides to let you do
    stuff implicitly. Let's talk about implicits in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Implicits - what and why
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are *implicits*? When we talk about implicits, we mean implicit parameters
    or conversions that happen implicitly. Implicit parameters are the ones that come
    along with a keyword, `implicit`, and we don't have to explicitly pass an argument
    for these parameters if they were in Scope. Let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example, and create a `Future` value. A `Future` is nothing
    but a computation (that we provide) that''s going to happen at a later point in
    time. It means a computation that''s going to happen in the future. We''ll talk
    about `Future` values in depth when we discuss concurrent programming techniques
    in [Chapter 13](part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84), *Concurrent
    Programming in Scala.* Let''s write a code snippet for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The Scala compiler greets us with two compilation errors. The first one says
    that it wasn''t able to find an implicit value of the `ExecutionContext` type*.*
    Okay, we don''t know what this `ExecutionContext` is, for now. Let''s look at
    the next error. It says `not enough arguments for method apply: (implicit executor:
    ExecutionContext) scala.concurrent.Future[Int]`*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ve got this idea that there''s an argument that is needed that''s
    not available to our code. Let''s take a look at the `Future` block''s `apply`
    method for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this seems interesting. We''ve got this `implicit` keyword for the parameter
    `ExecutionContext`. It means that it''s okay to call the `Future` block''s `apply`
    method; the only thing we need to take care of is the implicit value of the type
    declared. So things should work fine if somehow we can get the value of type `ExecutionContext`
    available into our scope. What do we mean by scope? Let''s think of the current
    compilation unit (Scala file) as the scope, for now. So let''s do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve declared an `implicit` value named `ctx` of the type `ExecutionContext`*,*
    and then tried to run the application again, and magically things worked fine.
    We didn''t pass any context explicitly or do something extraordinary—we''ve just
    brought the value of the desired type into scope and things worked. We''ve got
    the results. One thing to note, though, is that we''ve used this `implicit` keyword*;*
    that''s the reason `Future.apply` was able to infer the value available in scope.
    If we tried this without the `implicit` keyword, we''d get similar compilation
    errors to those that we had previously. So the idea is to get an implicit value
    in scope, and now we know what''s implicit. There''s a big question though: why
    would you want to have this kind of behavior? We''re going to have a healthy discussion
    regarding this idea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the idea that implicits in Scala can be used to automate
    the process of passing a value to an operation or conversion from one type to
    another type. Let''s talk about the first one: implicit parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use implicit parameters when we want the compiler to help us find a value
    that's already available for a certain type. We've just seen an example of an
    implicit parameter when we talked about `Future`. Why don't we define something
    similar for ourselves?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of a scenario where we need to show the present date in our application
    and we want to avoid passing a date''s instance explicitly again and again. Instead,
    we can make the `LocalDateTime.now` value implicit to the respective functions
    and let the current date and time be passed as an implicit parameter to them.
    Let''s write some code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Think of the `showDateTime` function as the one that needs the date-time's current
    value—hence it's possible for us to make it available as an implicit one. That's
    what we did—in the definition of `showDateTime`*,* we declared an implicit parameter
    named `date` of the type `LocalDateTime`*.*  We also have an implicit value named
    `dateNow` in scope. That's why we didn't have to pass an argument at the call
    site  and things still worked out good for us.
  prefs: []
  type: TYPE_NORMAL
- en: This seems a good use case. You can make your desired values automatically available
    for yourself using *implicits.*
  prefs: []
  type: TYPE_NORMAL
- en: The implicitly method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala''s standard library provides a utility method to create concrete instances
    of types'' availability implicitly. The method''s name is also `implicitly`*.*
    Let''s take a look at the function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This `implicitly` method simply expects a type parameter, finds the implicit
    value available in scope, and summons and returns it to us. This is a good option
    available to us to tell whether a particular type''s value is available in implicit
    scope. Let''s look at an application of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So this is how we can use the `implicit` parameter in our definitions and make
    them available to respective scopes.
  prefs: []
  type: TYPE_NORMAL
- en: With some idea about implicits now, let's take a look at *implicit conversions.*
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard Scala FAQ page describes implicit conversions as: *"*If one calls
    a method `m` on an object `o` of a class `C` and that class `C` does not support
    method `m`, then Scala compiler will look for an implicit conversion from `C`
    type to something that does support `m` method*"*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is clear: it''s a synthetic behavior (using a method) that we''re
    forcing on instances of a particular type, and these behaviors (methods) aren''t
    a part of the defined type. It''s like we have a library with certain functionalities
    already available and we want to give some add-on functionality to a certain type
    from the library. Think about it—this is powerful. Having the ability to add on
    a functionality for a particular type is itself powerful. And that''s what implicits
    let us do. We''ll try our hand at something like the following.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, think of a scenario where we want to create some syntax methods. We
    have a few methods available for the date-time library `java.time.LocalDate` that
    can help us add or subtract days/weeks/months/years, and those methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What we would like to have is a simple + or - for days/weeks/months/years to
    work as the `plusXXX` or  methods. What are all the options we have to achieve
    such a syntax?
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the options is to create a `Wrapper` class over `LocalDate`*,* such
    as a `CustomDate(date: LocalDate)`, and define these methods for it. In that case,
    the code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have noticed in the preceding code, we have a `CustomDate` class wrapping
    over the type `LocalDate`, and are using the `LocalDate` type''s methods to define
    our own desired syntax methods. Let''s try using it. For this, we can create another
    object extending `App` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we''re going to create an implicit class that takes nothing but a
    `val` of the type `LocalDate`*,* then similar logic to provide all of our syntax
    methods. Afterwards, we''ll bring that implicit class in scope by importing it.
    Let''s write that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to use the same in our `BeautifulDateApp` class*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see the difference in the two approaches we took. The second one seems
    the more native approach. As consumers of these syntax methods, we never tried
    to call the `CustomDate` class—rather, we created an instance of the `LocalDate`
    type*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We used `+` and `-` like native methods defined in the `LocalDate` class. That's
    the power, or let's say magic, of *implicit conversions.* For those who want to
    know what happened in the background, let's look at the workings of the code in
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scala compiler saw this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The compiler then tried to look for a method named `+` that takes a day as a
    parameter in the `LocalDate` class. It's not surprising that the compiler wasn't
    able to find such a method there, hence it tried to check whether there was any
    other class available in the implicit scope that is expecting a `LocalDate` and
    that was performing operations such as `+` with a day/week/month/year*.* Then,
    the compiler found our `CustomDate` implicit class. Finally, implicit conversion
    took place and this particular method call worked for us. We were then able to
    make such method syntax hacks possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen such an example, one question that we might want to ask
    ourselves is what do we mean by *implicit scope?* We also need to see how the
    Scala compiler searches for implicit values. Let's try to get an answer to this.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for implicits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your usual application Scala code might contain some constructs that import
    other classes and objects, or it might also inherit other classes. You write methods
    that expect types as parameters and also declare parameters. So when the Scala
    compiler looks for an implicit value, where should it start looking for such a
    value? The compiler starts to look for an implicit value according to the following
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined in current scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly imported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imported using wildcards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Companion object of a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit scope of an argument's type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit scope of type arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outer objects for nested types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We know that if we define an implicit value in the current scope (block of
    code), it gets the highest precedence. Afterwards, you can also import it using
    an `import` statement, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A wildcard import can also work for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'But life''s a bit uncomfortable for the compiler, as well as us, when it sees
    two implicit values eligible for the same type in the same scope. What we then
    see is a compilation error stating `ambiguous implicits`*.* Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For the preceding code, we''ll face this compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So, we need to take care of the implicit value's ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the compiler isn''t able to find the implicit value in the current block
    of code or via imports, it searches for it in companion objects of the type. That''s
    how the compiler searches for implicit values. The standard Scala documentation
    explains the topic of finding implicits, which you can find at: [http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html](http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html).'
  prefs: []
  type: TYPE_NORMAL
- en: With this discussion of implicits, we've seen few ways in which we can use the
    concept and let the magic work for us. It's widely used by library designers when
    they define type-classes and make their instances available via implicit values.
    We've covered what type classes are, and we can create one on our own. Let's try
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Type-classes ahead!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating type-classes to solve problems, such as providing a mechanism
    to encode types in a particular format, we have to unleash the power of languages
    such as Scala. What we desire is a way to encode values of a certain type in **comma-separated
    value** (**CSV**) format. For that purpose, we''ll create a type-class named `CSVEncoder`.
    In Scala, we can do this using a trait of some type by convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'What we defined is a functionality provider for our types. The functionality
    right now is to encode a value of some particular type and give back a list of
    string values that we can represent in CSV. Now, you might want to use this functionality
    by calling some functions on it, right? For a simple type such as `Person`, it
    can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Some other syntax might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To use something like these, what we need is this:'
  prefs: []
  type: TYPE_NORMAL
- en: A way to encode the type `Person` in CSV format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The utility function `toCSV`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define the ways our type-class-provided functionality can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a companion object for `CSVEncoder` and defined our utility
    function named `toCSV`, which takes a type parameter and sequence of values of
    the same type, except that it expects an implicit `CSVEncoder` instance for the
    same type. What it returns in turn is a `List[String]`*.* We know it's easy to
    convert a sequence of string values in CSV. The definition is something that we
    want from this function. Hence, we simply call `encoder.encode(value)` and convert
    the values in comma-separated format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a way to encode the `Person` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we provided a way to encode our `Person` type. Now,
    let''s use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did here in our `EncoderApp` is import `CSVEncoder[Person]` implicitly
    and call a `toCSV` function with the expected value. Calling this function gives
    us the desired result*.* We can now hack the `toCSV` function syntax using an
    implicit class and give the consumer of our type-class another way of using our
    encoder. Let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We achieved this syntax call using the implicit `CSVEncoderExt` class, which
    was the approach we took in the case of the syntax methods for `LocalDate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All we had to do was take care that this particular class was in the scope at
    the call site, so we imported it. This is how we have created and used our first
    type-class. It wasn't that hard, was it? Sure, we have covered enough about type-classes
    in this chapter. Let's go ahead and summarize what we've learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we discussed exceptional cases that occur when we try programming. We
    saw how we handle these exceptional cases in functional programming. We even tried
    exception handling in functional composition. Then, we began to see the magic
    that implicits bring in Scala. We discussed implicit parameters and then *implicit
    conversion.* We saw the `implicitly` method, provided by the Scala standard library.
    Finally, we talked about the already much-talked-about type-classes, and defined/used
    our first one. Once you practice enough with the concepts that we have discussed,
    it's worth going through type-classes in detail. Most of the Scala libraries'
    frameworks heavily use this concept.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the Akka toolkit. We'll cover *Actor
    System*, one of Akka's offerings, and much more.*
  prefs: []
  type: TYPE_NORMAL
