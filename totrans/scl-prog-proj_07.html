<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Online Shopping - REST API</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will explain how to develop a REST API using Play Framework. <strong>API</strong> is an acronym for <strong>Application Programming Interface</strong>. The <strong>REST</strong> acronym stands for <strong>Representational State Transfer</strong>. Basically, we will provide an interface for our application, so that other programs can interact with it. REST is an architectural pattern that will guide us in designing our API.</p>
<p>Typically, a program calling our API will be a user interface running in a browser, which we will implement in the next chapter. It could also be another backend application, which could be from another program, and so on.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>REST principles</li>
<li>Implementing the API with persistence</li>
<li>Swagger</li>
<li>Deploying on Heroku</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The REST API</h1>
                </header>
            
            <article>
                
<p>The objective of the REST API is to interact with the shopping cart from the user interface in the browser. The main interactions are as follows:</p>
<ul>
<li>Creating the cart</li>
<li>Adding, removing, and updating products in the cart</li>
</ul>
<p>We will design our API by following REST architecture principles which was defined in 2000, by Roy Fielding.</p>
<div class="packt_infobox">A formal description of the REST API can be found in <em>Fielding Dissertation, CHAPTER 5, Representational State Transfer (REST)</em>, at <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a>.</div>
<p>The main principles of the architecture are as follows:</p>
<ul>
<li>It is based on client-server architecture, which means that a server can serve multiple clients.</li>
<li>It should be stateless—the server should not keep any context between client calls. The context should be kept by the client. All of the information required for the processing on the server should be part of the message sent.</li>
<li>As no context is kept on the server, it should be possible to cache responses at the server level.</li>
<li>Each resource on the system should be identified uniquely. Since our resources are web resources, we use a <strong>Uniform Resource Identifier (URI)</strong> for that purpose.</li>
</ul>
<p>Keeping all of the preceding in mind, let's design our API. In <a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml" target="_blank"/><a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml" target="_blank">Chapter 6</a>, <em>Online Shopping – Persistence</em>, two tables where defined:</p>
<ul>
<li><span>The cart</span></li>
<li>The product</li>
</ul>
<p>Intuitively, in this chapter, we will keep these two objects to design our API. </p>
<p>For the cart, we would like to perform the following actions:</p>
<ul>
<li><span>Add a product</span></li>
<li>Delete a product</li>
<li>Update the quantity of a product</li>
<li>Get a list of products in the cart</li>
</ul>
<p>For the product, we would like to perform the following actions:</p>
<ul>
<li><span>List the products</span></li>
<li>Add a product</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the tests</h1>
                </header>
            
            <article>
                
<p>First, let's write the tests. We will create one test per API call, to cover all the cases. By doing so, we are going to define the URI for each case. All of the test implementations will be grouped in a test class; let's call it <kbd>APISpec</kbd><span>.</span></p>
<p>We can create the class and define the URLs of our API; at this point, the <kbd>APISpec</kbd> class should be as follows:</p>
<pre>class APISpec extends PlaySpec with ScalaFutures with GuiceOneServerPerSuite {

  val baseURL = s"localhost:$port/v1"
  val productsURL = s"http://$baseURL/products"
  val addProductsURL = s"http://$baseURL/products/add"
  val productsInCartURL = s"http://$baseURL/cart/products"
  def deleteProductInCartURL(productID: String) = <br/>    s"http://$baseURL/cart/products/$productID"
  def actionProductInCartURL(productID: String, quantity: Int) = <br/>    s"http://$baseURL/cart/products/$productID/quantity/$quantity"

   "The API" should {
     val wsClient = app.injector.instanceOf[WSClient]
   }
}</pre>
<p class="mce-root">As in <kbd><span>DatabaseSpec</span></kbd>, we extend the ScalaTest integration class, <kbd>PlaySpec</kbd>, as well as a Play server, <span><kbd>GuiceOneServerPerSuite</kbd>, and define all of the URLs required. We defined the <kbd>wsClient</kbd> value, </span>a helper from Play, to define a web service client.</p>
<p>We will start with a test of the product API, and, more precisely, with the list of products. The test is as follows:</p>
<pre>   "list all the product" in {
     val response = Await.result(<br/>                          wsClient.url(productsURL).get(),<br/>                          1 seconds)
     response.status mustBe OK
   }</pre>
<p><kbd>WSClient</kbd> is a convenient class to perform a REST call; we just need to set the URL and call the HTTP method.</p>
<p>Let's define the <kbd>add a product</kbd> case, as follows:</p>
<pre>"add a product" in {
  val newProduct =
"""
 {
      "name" : "NewOne",
      "code" : "New",
      "description" : "The brand new product",
      "price" : 100.0
 }
"""

     val posted = wsClient.url(addProductsURL).<br/>                  post(newProduct).futureValue
        posted.status mustBe OK
}</pre>
<p>First, we define the new product to insert. Notice that we are using a string representation of the new product, using the JSON format. We could have defined it as an object, but that will be covered later in this chapter. To add something to the database, we are using the <kbd>HTTP POST</kbd> method.</p>
<p>We are now done with the product section. Now, we need to add new tests for listing all of the products in a cart, adding a product to the cart, deleting a product from the cart, and updating the quantity of a product in the cart. The corresponding unit tests are as follows:</p>
<pre>    "add a product in the cart" in {
      val productID = "ALD1"
      val quantity = 1
      val posted = wsClient.url(actionProductInCartURL(productID, <br/>                   quantity)).post("").futureValue
      posted.status mustBe OK
    }
    "delete a product from the cart" in {
      val productID = "ALD1"
      val quantity = 1
      val posted = wsClient.url(deleteProductInCartURL(productID))<br/>                  .delete().futureValue
      posted.status mustBe OK
    }
    "update a product quantity in the cart" in {
      val productID = "ALD1"
      val quantity = 1
      val posted = wsClient.url(actionProductInCartURL(productID,                                <br/>                   quantity))<br/>        .post("").futureValue
      posted.status mustBe OK

      val newQuantity = 99
      val update = wsClient.url(actionProductInCartURL(productID,             <br/>                   newQuantity)).put("").futureValue
      update.status mustBe OK
    }</pre>
<p>We have defined basic tests for all of the functions. When we run <kbd>ApiSpec</kbd>, all of the tests will fail with the error <kbd>404 was not equal to 200</kbd>. This is expected, as no route has been defined in Play.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the routes</h1>
                </header>
            
            <article>
                
<p>We define all of the URLs of our API in the <kbd>config/routes</kbd> file. In this file, we define the mapping between the URL and the code. In our example, the file looks as follows:</p>
<pre># Product API
GET    /v1/products                         W.listProduct
POST   /v1/products/add                     W.addProduct

# Cart API
GET    /v1/cart/products                    W.listCartProducts()
DELETE /v1/cart/products/:id                W.deleteCartProduct(id)
POST   /v1/cart/products/:id/quantity/:qty  W.addCartProduct(id,qty)
PUT    /v1/cart/products/:id/quantity/:qty  W.updateCartProduct(id,qty)</pre>
<p>For more clarity, we squeezed the <kbd>controllers.WebServices</kbd> package to <kbd>W</kbd>, to fit the page width.</p>
<p>For each line, if it starts with <kbd>#</kbd>, the line is a comment; otherwise, the first column defines the HTTP action to perform, followed by the context URL. Finally, the last column is the method to call with the parameters, if any.</p>
<p>At the URL level, you can use the wildcard, <kbd>:</kbd>, to define a variable in the path; this variable can be used in the method call. For example, the <kbd>id</kbd> variable is defined in the <kbd>cart/products/:id</kbd> path, and then used in the <kbd>controllers.Cart.deleteProduct(id)</kbd> method call.</p>
<p>We have now defined the route that Play is going to create; the next step is to define the methods defined in this routing file.</p>
<p>To do so, create a new file, named <kbd>WebServices</kbd>, in the <kbd>controllers</kbd> folder. In this file, the implementation is as follows:</p>
<pre>@Singleton
class WebServices  @Inject()(cc: ControllerComponents, productDao: ProductsDao) extends AbstractController(cc) {

  // *********** CART Controler ******** //
  def listCartProducts() = play.mvc.Results.TODO

  def deleteCartProduct(id: String) = play.mvc.Results.TODO

  def addCartProduct(id: String, quantity: String) =     <br/>    play.mvc.Results.TODO

  def updateCartProduct(id: String, quantity: String) =   <br/>    play.mvc.Results.TODO

  // *********** Product Controler ******** //
  def listProduct() = play.mvc.Results.TODO

  def addProduct() = play.mvc.Results.TODO

}</pre>
<p>We have defined all of the methods, but instead of coding the details of all of the implementations, we will set it to <kbd>play.mvc.Results.TODO</kbd>. At that point, we can try to run the test, to make sure that we do not have any compilation errors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the test</h1>
                </header>
            
            <article>
                
<p>When running the test, <kbd>APISpec</kbd>, you should not get 404 errors anymore. However, the tests should now fail with the error 501 was not equal to 200.</p>
<p>This is expected. The server can now find the URL mapping for our REST calls, but in our code, all methods are implemented with <kbd>play.mvc.Results.TODO</kbd>. This special return value makes the server return the HTTP status error code 501.</p>
<p>What have we achieved? Well, Play is serving all of the URLs of our API. For each of them, it calls the associated method, and returns an error code instead of the real implementation!</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the API</h1>
                </header>
            
            <article>
                
<p>At this point, it might be interesting to introduce external tools to check the API.</p>
<p>Indeed, these tools are widely used and can make your life easier, especially when you want to explain it to someone or perform multiple calls on a different server.</p>
<p>These tools are as follows:</p>
<ul>
<li>
<p><strong>Paw</strong>: This is a paid tool and only works on macOS. You can look upon it at <a href="https://paw.cloud/">https://paw.cloud/</a>.</p>
</li>
<li>
<p><strong>Postman</strong>: This is a free and multiplatform application. Postman is a Google Chrome extension. <span>You can look upon it at <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en</a>.</span></p>
</li>
</ul>
<p>Once one of these tools installed, start the project in IntelliJ, and then browse to, for example, <kbd>http://localhost:9000/cart/products</kbd>. You should receive the error 501 Not Implemented:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e33a3eec-e74b-4a1a-a570-de1cd9fae4ac.png"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Observe the error in the TODO section</div>
<p>All of the defined URLs will have the same behavior.</p>
<p>The advantage of this tool is that you can see all of the details of the request and the response. It is very useful to understand the HTTP protocol with all of the headers, URL parameters, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the API with persistence</h1>
                </header>
            
            <article>
                
<p>In this chapter, we created the route for the API without an implementation. In the previous chapter, <a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml"/><a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml">Chapter 6</a>, <em>Online Shopping – Persistence</em>, we created the database to persist the carts. It is now time to bind the API with the persistence.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing the product tests</h1>
                </header>
            
            <article>
                
<p>We want to check not only the HTTP status but the content received back; for example, for the list of products, we would like to make sure that we are receiving all of the default products:</p>
<pre>    "list all the products" in {
      val response = wsClient.url(productsURL).get().futureValue
      println(response.body)
      response.status mustBe OK
      response.body must include("PEPER")
      response.body must include("NAO")
      response.body must include("BEOBOT")
    }</pre>
<p>In this test, we look at the body of the response and make sure that the three default products are present.</p>
<p>Similarly, to check the <kbd>add a product</kbd> function, we first add the product, and then call the list of products:</p>
<pre>   "add a product" in {
      val newProduct =
        """
       {
            "name" : "NewOne",
            "code" : "New",
            "description" : "The brand new product",
            "price" : 100.0
       }
      """

      val posted = wsClient.url(addProductsURL).post(newProduct).<br/>                   futureValue
      posted.status mustBe OK

      val response = wsClient.url(productsURL).get().futureValue
      println(response.body)
      response.body must include("NewOne")
    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the product API</h1>
                </header>
            
            <article>
                
<p>All of the tests are ready, so let's implement the API for all the methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product list</h1>
                </header>
            
            <article>
                
<p>The first method that we are going to implement is the list of products. As you will remember from <a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml"/><a href="3faf4d15-9055-4617-af6b-d0b6cc17bc71.xhtml">Chapter 6</a>, <em>Online Shopping – Persistence</em>, we created a list of default products upon the creation of the application. Hence, our first task will be to get these products and send them back as JSON objects.</p>
<p>As we have already written a data access layer, the extraction from the database is pretty simple. Indeed, we just need to call the <kbd>all()</kbd> method from the product DAO instance, as follows:</p>
<pre>def listProduct() = Action.async { request =&gt;
  val futureProducts = productDao.all()
  for (
    products &lt;- futureProducts
  ) yield (Ok(products.mkstring(",")))
}</pre>
<p>The <kbd>productDao.all()</kbd> method returns all of the products from the database as <kbd>Future[Seq[Product]]</kbd>. We can reuse what we learned in the previous chapter and use the <kbd>for</kbd> comprehension to extract, in the <kbd>products</kbd> variable, the sequence of products from <kbd>Future</kbd>.</p>
<p>From the <kbd>products</kbd> variable, thanks to <kbd>.mkstring(",")</kbd>, we return a string with all of the products, separated by commas.</p>
<p>But we are not quite done yet. We mentioned that we would like to return a JSON representation of this sequence of products. Therefore, we need some mechanism to transform our case class instances into JSON.</p>
<p>We could improve the code and create it manually, but there are many good libraries that can help us to do it. It would be better to use one of them and reduce the boilerplate code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encoding JSON with Circe</h1>
                </header>
            
            <article>
                
<p>There are many Scala libraries to manipulate JSON, so why did we choose Circe?</p>
<p>Circe is a very clean JSON framework with good performance, but the real reason we have chosen it is that Circe provides a complete documentation, with an explanation of all of the principles used to play with JSON. Circe uses Cats underneath, which we used in <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank">Chapter 3</a>, <em>Handling Errors</em>. Cats is a library from Typelevel. Typelevel is a community that is extremely kind to newcomers in functional programming. It provides lots of great documentation; you can check it out at <a href="https://typelevel.org/">https://typelevel.org/</a>. In fact, if you wish to dig deeper into functional programming, this is the place to start! The downside of Circe is the number of transitive dependencies; hence, it is fine to use it in a server application, but it might be a little heavy if you want a smaller footprint.</p>
<p>In order to integrate Circe with Play, we can use the integration done by Jilen at <a href="https://github.com/jilen">https://github.com/jilen</a>. We have already added the dependency to our template, but for reference, the following needs to be added to <kbd>libraryDependencies</kbd>, in <kbd>build.sbt</kbd>:</p>
<pre>libraryDependencies += "com.dripower" %% "play-circe" % "2609.0"</pre>
<p>Then, we need to add the <kbd>Circe</kbd> trait to our controller, as follows:</p>
<pre>class WebServices @Inject()(cc: ControllerComponents, productDao: ProductsDao) extends AbstractController(cc) with Circe</pre>
<p>We will import the required classes, as follows:</p>
<pre>import play.api.libs.circe.Circe
import io.circe.generic.auto._
import io.circe.syntax._</pre>
<p>We are almost there; we need to replace <kbd>.mkstring(",")</kbd> with <kbd>.asJson</kbd>. That's it!</p>
<p>The final code is as follows:</p>
<pre>def listProduct() = Action.async { request =&gt;
  val futureProducts = productDao.all()
    for(
      products &lt;- futureProducts
    ) yield (Ok(products.asJson))
}</pre>
<p>Now we can run <kbd>APISpec</kbd>; we should have your first working test for the API!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Action definition </h1>
                </header>
            
            <article>
                
<p>In the previous code, the <kbd>for</kbd> comprehension retrieves the products from the database and converts them to JSON. We are already familiar with this kind of syntax, but what about <kbd>Action.async</kbd> and <kbd>Ok()</kbd>?</p>
<p>In Play, all of the <kbd>Action</kbd> elements are asynchronous. The expected return of an <kbd>Action</kbd> is a status, which represents the HTTP status code (<kbd>OK() = 200 OK</kbd>, <kbd>Created() = 201 CREATED</kbd>, and so on).</p>
<p>As you may have noticed, the return type of the <kbd>for</kbd> comprehension is a status wrapped in <kbd>Future</kbd>. The <kbd>Action.async</kbd> <span>helper function </span>allows us to create an asynchronous <kbd>Action</kbd> from this <kbd>Future</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a product</h1>
                </header>
            
            <article>
                
<p>The next method to implement is the ability to add a product to the database.</p>
<div class="packt_tip">If you are annoyed by the errors shown by IntelliJ when you start a new implementation, you can add a dummy return status.</div>
<p class="mce-root">First, we will return a dummy status to avoid IntelliJ errors:</p>
<pre>def addProduct() = Action.async { request =&gt;
  Future.successful(Ok)
}</pre>
<p>Then, we will complete the implementation, as follows:</p>
<pre>  def addProduct() = Action.async { request =&gt;
    val productOrNot = decode[Product]<br/>    (request.body.asText.getOrElse(""))
    productOrNot match {
      case Right(product) =&gt; {
        val futureInsert = productDao.insert(product).recover {
          case e =&gt; {
            Logger.error("Error while writing in the database", e)
            InternalServerError("Cannot write in the database")
          }
        futureInsert.map(_ =&gt; Ok)
      }
      case Left(error) =&gt; {
        Logger.error("Error while adding a product",error)
        Future.successful(BadRequest)
      }
    }
  }</pre>
<p>We expect to receive the new product details as a JSON payload in the body. Therefore, in the first line, we get the body as text; if it is not defined, we replace it with an empty string.</p>
<p>Circe provides a method, named <kbd>decode</kbd>, which takes a string as a parameter and transforms it into an object. The type parameter (<kbd>[Product]</kbd>, in our case) defines the class of the target object.</p>
<p>This <kbd>decode</kbd> method returns an <kbd>Either</kbd> instance. If there is an error, it will be <kbd>Left</kbd>, and if the decoding works, it will be <kbd>Right</kbd>. We can pattern match on this <kbd>Either</kbd> value to return <kbd>Ok</kbd>; or, in the case of an error, to return a <kbd>BadRequest</kbd> status.</p>
<p>When the decoding works, we call <kbd>productDao.insert</kbd> to store the new product in the database. If anything goes wrong during the insert, the <kbd>.recover</kbd> block will return an internal server error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Completing the cart test</h1>
                </header>
            
            <article>
                
<p>The first thing that we would like to do is test the list of products in the customer's cart. But how do we make sure that the customer can only see their cart and not somebody else's?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Logging in</h1>
                </header>
            
            <article>
                
<p>To solve this problem, we are going to add a <kbd>login</kbd> endpoint on the API. This endpoint will create a session cookie and will keep the session ID in it. This way, the session ID will be passed every time a request is sent to the server. The server will then be able to associate a session ID with a specific customer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit test</h1>
                </header>
            
            <article>
                
<p>When the client calls the login URL, the server responds with a <kbd>Set-Cookie</kbd> header. In this header, the encrypted session data can be obtained by using the <kbd>PLAY_SESSION</kbd> key.</p>
<p>The following is the unit test for the new <kbd>login</kbd> endpoint:</p>
<pre>    "return a cookie when a user logins" in {
       val cookieFuture = wsClient.url(login).post("myID").map {<br/>        response =&gt;<br/>          response.headers.get("Set-Cookie").map(<br/>            header =&gt; header.head.split(";")<br/>              .filter(_.startsWith("PLAY_SESSION")).head)<br/>       }<br/>      }
      val loginCookies = Await.result(cookieFuture, 1 seconds)
      val play_session_Key = loginCookies.get.split("=").head
      play_session_Key must equal("PLAY_SESSION")
    }</pre>
<p>The test sends a <kbd>POST</kbd> request to the <kbd>login</kbd> endpoint. For now, we send a dummy payload, <kbd>myID</kbd>, which represents a user identifier. Once posted, we map the returned response to get the <kbd>Set-Cookie</kbd> header. This <kbd>header</kbd> contains multiple values, separated by semicolons. We are not interested in the other values; hence, we need to process this <kbd>header</kbd> to get only the <kbd>PLAY_SESSION</kbd> cookie. To do so, we split on the semicolon and keep only the element starting with the <kbd>PLAY_SESSION</kbd><span> key</span>.</p>
<p>We assign this transformed response to a value: <kbd>cookieFuture</kbd>. We then wait for <kbd>Future</kbd> to complete; then, the response is split on <kbd>=</kbd>, and only the key is kept and checked.</p>
<p>You can run the test now; it should fail, with a 404 Not Found error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation</h1>
                </header>
            
            <article>
                
<p>First, we need to add the new endpoint to the <kbd>routes</kbd> file, as follows:</p>
<pre># Login
POST    /v1/login    controllers.WebServices.login</pre>
<p>With this new entry, Play reacts to the <kbd>POST</kbd> action and calls the <kbd>login</kbd> method of the <span><kbd>Webservices</kbd></span> class<span>.</span></p>
<p>The implementation of this <kbd>login</kbd> method is as follows:</p>
<pre>  def login() = Action { request =&gt;
    request.body.asText match {
      case None =&gt; BadRequest
      case Some(user) =&gt; Ok.withSession("user" -&gt; user)
    }
  }</pre>
<p>If a body with the username is present, the <kbd>OK</kbd> status is returned, with a new session cookie. The username is added in the cookie, with the <kbd>user</kbd> key, and can be retrieved on a subsequent request.</p>
<p>Run <kbd>APISpec</kbd> again; the login test should now be green.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Passing the cookie</h1>
                </header>
            
            <article>
                
<p>From now on, every time we interact with the cart, we will have to pass the cookie with the session ID to bind our user with the cart. The test to get the list of products in the cart is as follows:</p>
<pre>    "list all the products in a cart" in {
      val loginCookies = <br/>      Await.result(wsClient.url(login).post("me").map(p =&gt; <br/>      p.headers.get("Set-Cookie").map(_.head.split(";").head)), 1     <br/>      seconds)
      val play_session = loginCookies.get.split("=").tail.mkString("")

      val response = (wsClient.url(productsInCartURL).<br/>      addCookies(DefaultWSCookie("PLAY_SESSION", <br/>        play_session)).get().futureValue
      println(response)
      response.status mustBe OK

      val listOfProduct = decode[Seq[Cart]](response.body)
      listOfProduct.right.get mustBe empty
    }</pre>
<p>First, we call the <kbd>login</kbd> endpoint to build the session cookie; then, the cookie is passed in the second call. In order to check the number of products in the cart, we use Circe to transform the JSON response to a sequence of a cart.</p>
<p>Since the session cookie has to be used by all of the subsequent tests, we can move the code to get the cookie from a <kbd>lazy val</kbd>, as follows:</p>
<pre>    lazy val defaultCookie = {
      val loginCookies = Await.result(wsClient.url(login).post("me")<br/>        .map(p =&gt; p.headers.get("Set-Cookie").map(<br/>          _.head.split(";").head)), 1 seconds)
      val play_session = loginCookies.get.split("=").tail.mkString("")

      DefaultWSCookie("PLAY_SESSION", play_session)
    } </pre>
<div class="packt_tip">The <kbd>lazy</kbd> keyword indicates that the code will be evaluated as late as possible, upon the first usage of the value.</div>
<p>Then, we can refactor our test to use it, as follows:</p>
<pre>    "list all the products in a cart" in {
       val response = wsClient.url(productsInCartURL)<br/>        .addCookies(defaultCookie).get().futureValue
      response.status mustBe OK
      val listOfProduct = decode[Seq[Cart]](response.body)
      listOfProduct.right.get mustBe empty
    }</pre>
<p>Check the addition of a product to the cart, as follows:</p>
<pre>"add a product in the cart" in {<br/>      val productID = "ALD1"<br/>      val quantity = 1<br/>      val posted = wsClient.url(actionProductInCartURL(productID,   <br/>        quantity)).addCookies(defaultCookie).post("").futureValue<br/>      posted.status mustBe OK<br/><br/>      val response = wsClient.url(productsInCartURL)<br/>        .addCookies(defaultCookie).get().futureValue<br/>      println(response)<br/>      response.status mustBe OK<br/>      response.body must include("ALD1")<br/>    }</pre>
<p>We must be able to remove a product from the cart, as follows:</p>
<pre>"delete a product from the cart" in {<br/>      val productID = "ALD1"<br/>      val posted = wsClient.url(deleteProductInCartURL(productID))<br/>        .addCookies(defaultCookie).delete().futureValue<br/>      posted.status mustBe OK<br/><br/>      val response = wsClient.url(productsInCartURL)<br/>        .addCookies(defaultCookie).get().futureValue<br/>      println(response)<br/>      response.status mustBe OK<br/>      response.body mustNot include("ALD1")<br/>    }</pre>
<p>The last test is to update the quantity of a product in the cart, as follows:</p>
<pre>"update a product quantity in the cart" in {<br/>      val productID = "ALD1"<br/>      val quantity = 1<br/>      val posted = wsClient.url(actionProductInCartURL(productID, <br/>        quantity)).addCookies(defaultCookie).post("").futureValue<br/>      posted.status mustBe OK<br/><br/>      val newQuantity = 99<br/>      val update = wsClient.url(actionProductInCartURL(productID,     <br/>        newQuantity)).addCookies(defaultCookie).put("").futureValue<br/>      update.status mustBe OK<br/><br/>      val response = wsClient.url(productsInCartURL)<br/>        .addCookies(defaultCookie).get().futureValue<br/>      println(response)<br/>      response.status mustBe OK<br/>      response.body must include(productID)<br/>      response.body must include(newQuantity.toString)<br/>    }</pre>
<p>As the test is now defined, let's implement the endpoints.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing products in cart</h1>
                </header>
            
            <article>
                
<p>Something is missing from the implementation; indeed, we do not have a <kbd>cartDao</kbd> instance in our <kbd>WebService</kbd> class.</p>
<p>To add it, just add it as a new parameter; as all of the parameters are injected, Play will automatically do it for you. The <kbd>WebService</kbd> class definition becomes the following code:</p>
<pre>class WebServices @Inject()(cc: ControllerComponents, productDao: ProductsDao, cartsDao: CartsDao) extends AbstractController(cc) with Circe {</pre>
<p>The implementation to get all of the products is as follows:</p>
<pre>def listCartProducts() = Action.async { request =&gt;
  val userOption = request.session.get("user")
  userOption match {
    case Some(user) =&gt; {
      Logger.info(s"User '$user' is asking for the list of product in <br/>        the cart")
      val futureInsert = cartsDao.all(user)
      futureInsert.map(products =&gt; Ok(products.asJson)).recover {
        case e =&gt; {
          Logger.error("Error while writing in the database", e)
          InternalServerError("Cannot write in the database")
        }
      }
    }
      case None =&gt; Future.successful(Unauthorized)
   }

}</pre>
<p>The <kbd>addCartProduct</kbd> implementation is as follows:</p>
<pre>def addCartProduct(id: String, quantity: String) = <br/>  Action.async { request =&gt;
    val user = request.session.get("user")
      user match {
        case Some(user) =&gt; {
          val futureInsert = cartsDao.insert(Cart(user, id, <br/>            quantity.toInt))
          futureInsert.map(_ =&gt; Ok).recover {
            case e =&gt; {
              Logger.error("Error while writing in the database", e)
              InternalServerError("Cannot write in the database")
          }
        }
        }
        case None =&gt; Future.successful(Unauthorized)
      }
    }</pre>
<p><span><span>It appears that the code is the same in the <kbd>.recover</kbd> partial function of <kbd>addCartProduct</kbd> and <kbd>listCartProducts</kbd></span></span>; in order to avoid code duplication, we could extract it as follows:</p>
<pre>val recoverError: PartialFunction[Throwable, Result] = {
  case e: Throwable =&gt; {
    Logger.error("Error while writing in the database", e)
    InternalServerError("Cannot write in the database")
  }
}</pre>
<p>We can refractor the list of products and add a product to use the new variable. The delete product action is as follows:</p>
<pre>  def deleteCartProduct(id: String) = Action.async { request =&gt;
    val userOption = request.session.get("user")
    userOption match {
      case Some(user) =&gt; {
        Logger.info(s"User '$user' is asking to delete the product <br/>          '$id' from the cart")
        val futureInsert = cartsDao.remove(ProductInCart(user, id))
        futureInsert.map(_ =&gt; Ok).recover(recoverError)
      }
      case None =&gt; Future.successful(Unauthorized)
    }
  }</pre>
<p>Finally, the update product action is as follows:</p>
<pre>def updateCartProduct(id: String, quantity: String) = Action.async {   <br/>request =&gt;
  val userOption = request.session.get("user")
  userOption match {
    case Some(user) =&gt; {
      Logger.info(s"User '$user' is updating the product'$id' in it <br/>                  is cart with a quantity of '$quantity")
      val futureInsert = cartsDao.update(Cart(user, id, <br/>                                         quantity.toInt))
      futureInsert.map(_ =&gt; Ok).recover(recoverError)
     }
    case None =&gt; Future.successful(Unauthorized)
  }
}</pre>
<p>Congratulations; all of the tests are now passing!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swagger</h1>
                </header>
            
            <article>
                
<p>An API needs to be documented to be usable. Indeed, when you want to use an API, you will not want to read a complete manual beforehand. It is better to have a self-explanatory and intuitive API.</p>
<p>To help with the documentation and testing part, there is a useful framework: Swagger.</p>
<p>Swagger not only helps to write the documentation; it also allows you to test the API directly while reading the documentation. In order to visualize the documentation with the Swagger UI, you must first declare a specification file, in JSON or YAML format. This specification file defines all of the URLs and data models that constitute your API.</p>
<p>There are multiple ways to use Swagger, as follows:</p>
<ul>
<li>You can write the specification of your API using the Swagger Editor, and Swagger will generate a skeleton of the code for you</li>
<li>You can add the Swagger specification directly in the <kbd>route.conf</kbd> file</li>
<li>You can add annotations in your code to generate the Swagger <kbd>specification</kbd> file</li>
</ul>
<p>For our project, we are going to generate the Swagger <kbd>specification</kbd> file by using annotations in our code.</p>
<p>The advantage of doing it this way is that all of the associated documentation will be in one place. It makes it easier to keep the documentation in sync, especially when code gets refactored. Many Swagger options are configurable, simply by adding annotations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Swagger</h1>
                </header>
            
            <article>
                
<p>The installation is already done, thanks to the Gitter8 template we used to generate this project, so the following details are just for reference.</p>
<p>The integration that we use is based on the <kbd>swagger-api/swagger-play</kbd> GitHub repository; please refer to it for any updates. We have to add a reference to the library in <kbd>build.sbt</kbd>. The <kbd>libraryDependencies</kbd> variable must contain the following code:</p>
<pre>"io.swagger" %% "swagger-play2" % "1.6.0"</pre>
<p>Then, the module must be enabled by adding the following to <kbd>application.conf</kbd>:</p>
<pre>play.modules.enabled += "play.modules.swagger.SwaggerModule"</pre>
<p>From here, we can publish the JSON definition by adding the following route in the <kbd>routes</kbd> file:</p>
<pre>GET  /swagger.json  controllers.ApiHelpController.getResources</pre>
<p>We would like to serve the API documentation directly from our server. In order to do that, we need to add the <kbd>swagger-ui</kbd> dependency to <kbd>libraryDependencies</kbd>, in <kbd>built.sbt</kbd>:</p>
<pre>"org.webjars" % "swagger-ui" % "3.10.0",</pre>
<p>To get the <kbd>swagger-ui</kbd> exposed in Play, the <kbd>routes</kbd> file needs to be updated with the following:</p>
<pre>GET  /docs/swagger-ui/*file controllers.Assets.at(path:String="/public/lib/swagger-ui", file:String)</pre>
<p>The Swagger UI uses JavaScript with inline code. By default, the security policy of Play forbids inline code. Also, we would like to allow requests from the localhost and from Heroku where it will be deployed. Hence, the following code needs to be added to <kbd>application.conf</kbd>:</p>
<pre>play.filters.hosts {
  # Allow requests from heroku and the temporary domain and localhost:9000.
  allowed = ["shopping-fs.herokuapp.com", "localhost:9000"]
}
play.filters.headers.contentSecurityPolicy = "default-src * 'self' 'unsafe-inline' data:"
 </pre>
<p>OK, the plumbing is done. It is time to add the definition of our project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Declaring endpoints</h1>
                </header>
            
            <article>
                
<p>Now that Swagger is installed in our project, we need to provide some information about our API. First, we need to add the following to <kbd>application.conf</kbd>:</p>
<pre>api.version = "1.0.0"
swagger.api.info = {
  description : "API for the online shopping example",
  title : "Online Shopping"
}</pre>
<p>Then, we need to declare our controller. For this, we will add the <kbd>@Api</kbd> annotation to the controller named <kbd>Application</kbd>:</p>
<pre>@Singleton
@Api(value = "Product and Cart API")
class WebServices @Inject()(cc: ControllerComponents, productDao: ProductsDao, cartsDao: CartsDao) extends AbstractController(cc) with Circe {</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the application</h1>
                </header>
            
            <article>
                
<p>At this point, we can run Play to see the result.</p>
<p>In the <span class="packt_screen">sbt shell</span> tab of IntelliJ enter <kbd>run</kbd> followed by <em>Enter</em> as in the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/12909458-8bd0-4898-a145-cc6c2fd224ab.png"/></p>
<p>The console should print:</p>
<pre>--- (Running the application, auto-reloading is enabled) ---<br/>[info] p.c.s.AkkaHttpServer - Listening for HTTP on /0:0:0:0:0:0:0:0:9000<br/>(Server started, use Enter to stop and go back to the console...)</pre>
<p><span>You can now safely browse </span><kbd>http://localhost:9000/docs/swagger-ui/index.html?url=/v1/swagger.json</kbd><span>, Play is going to compile all the files and after a while, the Swagger UI will appear, as follows:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/446f17d7-d741-4c0a-8c2e-2e1f2ee8d1e7.png"/></p>
<p>Click on the <span class="packt_screen">Product and Cart API</span> link. All of the endpoints are shown, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/59f5552e-74f6-4d5c-a953-3024c64e925d.png"/></p>
<p>This looks good, but we have to add some information about our API. For example, if you click on the <kbd>login</kbd> endpoint, there is no way to test it with a body containing the username.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Login</h1>
                </header>
            
            <article>
                
<p>To test the <kbd>login</kbd> endpoint, go to the <kbd>WebService</kbd> class and add the following annotations, just before the <kbd>login</kbd> definition:</p>
<pre>  @ApiOperation(value = "Login to the service", consumes = "text/plain")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(
      value = "Create a session for this user",
      required = true,
      dataType = "java.lang.String", // complete path
      paramType = "body"
    )
  ))
  @ApiResponses(Array(new ApiResponse(code = 200, message = "login         success"), new ApiResponse(code = 400, message =<br/>     "Invalid user name supplied")))
  def login() = Action { request =&gt;</pre>
<p>The <kbd>ApiOperation</kbd> object adds a description of the operation and defines the content type of the body sent. In this case, we are not sending JSON, but just a plain string. The <kbd>ApiImplicitParams</kbd> object defines the body sent to the server. The <kbd>ApiResponses</kbd> object informs the user about the possible statuses that can be returned in the response. The <kbd>login</kbd> documentation is now as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bed6f262-12cc-493b-9995-7afc35a8b8e1.png"/></p>
<p>If you click on <span class="packt_screen">Try it out</span>, you can type in a name and submit it by clicking on <span class="packt_screen">E</span><span class="packt_screen">xecute</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90489ceb-8e83-4aa5-9fd9-036b0d1d8aac.png"/></p>
<p>The call should return a successful status code <span class="packt_screen">200</span>, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e13ea24d-7701-4a16-941f-0544af074fab.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List of products</h1>
                </header>
            
            <article>
                
<p>Now, we can add some annotations to the list of products, as follows:</p>
<pre>  @ApiOperation(value = "List all the products")
  @ApiResponses(Array(new ApiResponse(code = 200, message = "The list <br/>   of all the product")))
  def listProduct() = Action.async { request =&gt;</pre>
<p>When we use Swagger to call <kbd>GET /v1/products</kbd>, the result of the execution is a JSON representation of all of the products, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b5a8c1a5-e02d-4fcc-aace-70169ba6a582.png"/></p>
<p>For <kbd>addProduct</kbd>, the following are the annotations that we need to add:</p>
<pre>@ApiOperation(value = "Add a product", consumes = "text/plain")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(
      value = "The product to add",
      required = true,
      dataType = "models.Product", // complete path
      paramType = "body"
    )
  ))
  @ApiResponses(Array(new ApiResponse(code = 200, message = "Product <br/>    added"),
                      new ApiResponse(code = 400, message = "Invalid <br/>    body supplied"),
                      new ApiResponse(code = 500, message = "Internal <br/>    server error, database error")))
  def addProduct() = Action.async { request =&gt;</pre>
<p>Thanks to the <kbd>dataType = "models.Product"</kbd> declaration, the <span class="packt_screen">Model</span> section in Swagger shows a JSON model that corresponds to the <kbd>Product</kbd> case class:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/09d78e29-18ca-460d-9aaa-3553833e5ec2.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cart endpoints</h1>
                </header>
            
            <article>
                
<p>Now, let's document the cart section with the list of products in the cart:</p>
<pre>  @ApiOperation(value = "List the product in the cart", consumes = <br/>    "text/plain")
  @ApiResponses(Array(new ApiResponse(code = 200, message = "Product <br/>    added"),
    new ApiResponse(code = 401, message = "unauthorized, please login <br/>    before to proceed"),
    new ApiResponse(code = 500, message = "Internal server error, <br/>    database error")))
  def listCartProducts() = Action.async { request =&gt;</pre>
<p>If we call <kbd>listCartProducts</kbd>, we receive an empty array. To test it with some products, complete the declaration of <kbd>addCartProduct</kbd> with the following:</p>
<pre>  @ApiOperation(value = "Add a product in the cart", consumes = <br/>    "text/plain")
  @ApiResponses(Array(new ApiResponse(code = 200, message = "Product <br/>    added in the cart"),<br/>    new ApiResponse(code = 400, message = "Cannot insert duplicates in <br/>    the database"),
    new ApiResponse(code = 401, message = "unauthorized, please login <br/>    before to proceed"),
    new ApiResponse(code = 500, message = "Internal server error, <br/>    database error")))
  def addCartProduct(
         @ApiParam(name = "id", value = "The product code", required = <br/>            true) id: String,
         @ApiParam(name = "quantity", value= "The quantity to add", <br/>            required = true) quantity: String) = Action.async { request <br/>            =&gt;</pre>
<p>In Swagger, we can now add a new product to the cart, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e151c5a8-68a0-41bc-9b6f-9cf6d182a416.png"/></p>
<p>Then, the list of products will return the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b7a14505-5dfe-4e07-a490-e7a60f0e62a8.png"/></p>
<p>After that, we can try to update a product. Add the following annotations to <kbd>updateCartProduct</kbd>:</p>
<pre>  @ApiOperation(value = "Update a product quantity in the cart", <br/>    consumes = "text/plain")
  @ApiResponses(Array(new ApiResponse(code = 200, message = "Product <br/>    added in the cart"),
    new ApiResponse(code = 401, message = "unauthorized, please login <br/>    before to proceed"),
    new ApiResponse(code = 500, message = "Internal server error, <br/>    database error")))
  def updateCartProduct(@ApiParam(name = "id", value = "The product <br/>    code", required = true, example = "ALD1") id: String, <br/>    @ApiParam(name = "quantity", value= "The quantity to update", <br/>    required = true) quantity: String) = Action.async { request =&gt;
  </pre>
<p>Then, use Swagger to update the quantity, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/931138c7-a9e3-48e5-a02d-61594cd31862.png"/></p>
<p>After the update, the list of products returns, as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b020352-a2b9-40a9-ad02-ccb92a2293a9.png"/></p>
<p>Perfect; the last operation to document is <kbd>deleteCartProduct</kbd>:</p>
<pre>  @ApiOperation(value = "Delete a product from the cart", consumes = <br/>    "text/plain")
  @ApiResponses(Array(new ApiResponse(code = 200, message = "Product <br/>    delete from the cart"),
    new ApiResponse(code = 401, message = "unauthorized, please login <br/>    before to proceed"),
    new ApiResponse(code = 500, message = "Internal server error, <br/>    database error")))
  def deleteCartProduct(@ApiParam(name = "id", value = "The product <br/>    code", required = true) id: String) = Action.async { request =&gt;</pre>
<p>We now have complete Swagger documentation for our API, and users can test it directly from their browsers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying on Heroku</h1>
                </header>
            
            <article>
                
<p>The API is now finished. We can deploy it to Heroku, to make it available on the internet. As we already set up Heroku in the previous chapter, there is just one command to achieve our deployment. From the command line in the root of your project, enter the following:</p>
<pre><strong>git push heroku master</strong></pre>
<p>Once the deployment has finished, you can browse to <a href="https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json">https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json</a>.</p>
<p>Congratulations! You can now test the API online.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to design and implement a REST API, while respecting the REST architectural principles.</p>
<p>We created tests to check the API from a client's perspective. We implemented all of the methods by using the DAO that we wrote in the last chapter. All of the calls are asynchronous because we used <kbd>Future</kbd>, which guarantees that our server can handle a lot of concurrent requests.</p>
<p>You also learned how to use the excellent Circe library to encode and decode JSON from Scala. Finally, we added a web interface to document and test the API, using Swagger.</p>
<p>In the next chapter, we are going to use this API to create a web interface based on Scala.js.</p>


            </article>

            
        </section>
    </body></html>