<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Online Shopping - User Interface</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to use Scala.js to build the user interface. In this interface, you can select a product to add to your cart, update the number of products that you wish to buy, and remove them from the cart if needed.</p>
<p>Scala.js is a project initiated by Sebastien Doeraene back in 2013. This project is mature and provides a clean way to build frontend applications. Indeed, you can code with a strongly-typed system to avoid stupid mistakes, but this is not only for strong typing; the code—written in Scala—is compiled into a highly efficient JavaScript. It can interoperate with all of the JavaScript frameworks. Moreover, the code can be shared between the front-end and the back-end developers. This feature simplifies communication between developers, as they are using the same concepts and classes.</p>
<p>Thanks to its interoperability, there are multiple ways to use Scala.js. You can use an HTML template and adapt it to interoperate with Scala.js. For example, you can buy the excellent<span> </span>SmartAdmin (<a href="https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0">https://wrapbootstrap.com/theme/smartadmin-responsive-webapp-WB0573SK0</a>) template (HTML5 version) as a base for the layout and all of the components/widgets, and then use Scala.js to implement the specific behaviors.</p>
<p>Another way is to start from scratch and build the HTML layout, CSS, components, and behaviors using the Scala.js ecosystem. This is the option that we will choose in this book. To generate the HTML and CSS,<span> </span>ScalaTags (<a href="http://www.lihaoyi.com/scalatags/">http://www.lihaoyi.com/scalatags/</a>) from<span> </span>Li Haoyi (<a href="http://www.lihaoyi.com/">http://www.lihaoyi.com/</a>) will be used.</p>
<p>This chapter will explain how to develop a dynamic web UI using Scala.js.</p>
<p>We will cover the following topics:</p>
<ul>
<li>Defining the layout</li>
<li>Creating the layout</li>
<li>Building the layout</li>
<li>Main layout</li>
<li>Product list panel</li>
<li>Cart panel</li>
<li>Introducing the UI manager</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning objectives</h1>
                </header>
            
            <article>
                
<p>The objectives of this chapter are to introduce a user interface into our project and interact with the server to get data from it.</p>
<p>More precisely, we will learn the following skills:</p>
<ul>
<li><span>How to develop a simple web UI</span></li>
<li>How to apply styles</li>
<li>How to interact with the server using a web service call</li>
<li>How to debug Scala code on the client side</li>
</ul>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up</h1>
                </header>
            
            <article>
                
<p>Note that this setup has already been completed when you start using the template. The following steps are only for reference:</p>
<ol>
<li>To enable Scala.js with Play, you first need to add the following code to <kbd>project</kbd>/<kbd>plugins.sbt</kbd>: </li>
</ol>
<pre style="padding-left: 60px">addSbtPlugin("org.scala-js" % "sbt-scalajs" % "0.6.24")
addSbtPlugin("com.vmunier" % "sbt-web-scalajs" % "1.0.8-0.6")</pre>
<ol start="2">
<li>In the <kbd>build.sbt</kbd>, you need to add the plugins by adding the following code in the <kbd>client</kbd> variable:</li>
</ol>
<pre style="padding-left: 60px">.enablePlugins(ScalaJSPlugin, ScalaJSWeb)</pre>
<ol start="3">
<li>You need to add the ScalaTags dependency by adding the following in <kbd>libraryDependencies</kbd> of the client configuration:</li>
</ol>
<pre style="padding-left: 60px">"com.lihaoyi" %%% "scalatags" % "0.6.7"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the layout</h1>
                </header>
            
            <article>
                
<p>For the purpose of this book, the shopping cart is designed as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/6ff8c185-587f-4c23-8bb9-6d9509b41240.png"/></p>
<p>On the left-hand side, a panel lists all of the products with all of their details. Underneath, a button adds the product to the cart. On the right-hand panel, there is a list of all of the products that have been added to the cart. On the <strong>Cart Panel</strong>, the number of products can be changed by clicking on the number and entering the right number. Each line has a button to delete the product from the list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the layout</h1>
                </header>
            
            <article>
                
<p>Multiple technologies are used to create the layout—more specifically, the top layout—using the <kbd>&lt;html&gt;</kbd> and <kbd>&lt;body&gt;</kbd> tags, and the two <kbd>div</kbd> containers for the products and the cart panels <span>respectively</span><span> </span><span>are going to be built with a Play template engine, named Twirl. Using this template, the inner HTML of the product and cart instances of <kbd>div</kbd> are going to be filled with ScalaTags.</span></p>
<p>Let's first create the main entry point. We named it <kbd>index.html</kbd>, and it is implemented by creating a file called <kbd>index.scala.html</kbd> in the <kbd>view</kbd> package of the server.</p>
<p>The content is as follows:</p>
<pre>@(title: String)
&lt;!DOCTYPE html&gt;
&lt;html&gt;<br/>    &lt;head&gt;<br/>        &lt;title&gt;@title&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;div class="container"&gt;<br/>            &lt;div class="row"&gt;<br/>                &lt;div id="productPanel" class="col-8"&gt;<br/>                    &lt;div id="products" class="row"&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>                &lt;div id="cartPanel" class="col-4"&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/><br/>        @scalajs.html.scripts("client",<br/>           routes.Assets.versioned(_).toString,<br/>           name =&gt; getClass.getResource(s"/public/$name") != null)<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>This file looks like a standard HTML file. In fact, this file is a template that is processed by the server.</p>
<p>The first line starts with an <kbd>@</kbd> character. It defines the input parameter that is passed by the caller, but who is calling this template? It is the <kbd>index()</kbd> function in the <kbd>Application</kbd> controller that calls the template, and effectively, the template is called by using the title of the page.</p>
<p>On the line starting with <kbd>@scalajs.html.scripts</kbd>, we are using a helper method provided by the <kbd>sbt-web-scalajs</kbd> plugin. This method retrieves all of the scripts generated by the <kbd>client</kbd> Scala.js project.</p>
<p>The two instances of <kbd>div</kbd> are going to be set from the code; we will look at this in more detail in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the page</h1>
                </header>
            
            <article>
                
<p>We will have two main sections on the main page: the product list and the cart.</p>
<p>To create the layout, we could use basic HTML tags, such as <kbd>table</kbd> and <kbd>div</kbd>, but this is quite laborious for our task. Instead, let's introduce a framework named Bootstrap (<a href="https://getbootstrap.com/">https://getbootstrap.com/</a><a href="https://getbootstrap.com/">).</a></p>
<p>This open source framework is widely used and very mature. It allows us to build a responsive website based on a grid, with a lot of components such as notifications, menus, badges, and tooltips. Bootstrap needs a CSS and some JavaScript libraries to work.</p>
<p>For now, we just need to add the Bootstrap CSS by adding the link in the HTML header, as follows:</p>
<pre>&lt;head&gt;
    &lt;title&gt;@title&lt;/title&gt;
      &lt;!-- Bootstrap CSS --&gt;
    &lt;link rel="stylesheet" <br/>    href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0<br/>    /css/bootstrap.min.css" integrity="sha384-        <br/>    Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW<br/>    /dAiS6JXm" crossorigin="anonymous"&gt;

&lt;/head&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Main layout</h1>
                </header>
            
            <article>
                
<p>In Bootstrap, a grid is a container composed of rows, each with 12 columns. A <span><kbd>class</kbd> attribute is used t</span><span>o define the type of</span> <kbd>div</kbd><span>.</span></p>
<p>So, in our case, we would like to have the product list occupy two-thirds of the screen, with the cart getting the rest of <kbd>row</kbd>.</p>
<p>The structure of the body in our <kbd>index.scala.html</kbd> is as follows:</p>
<pre> &lt;body&gt;
        &lt;div class="container"&gt;<br/>            &lt;div class="row"&gt;<br/>                &lt;div id="productPanel" class="col-8"&gt;<br/>                    &lt;div id="products" class="row"&gt;&lt;/div&gt;<br/>                &lt;/div&gt;<br/>                &lt;div id="cartPanel" class="col-4"&gt;&lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;

&lt;/body&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product list panel</h1>
                </header>
            
            <article>
                
<p>To structure our HTML page, we are going to create a panel called <kbd>productPanel</kbd>. This panel is a container for all product details.</p>
<p>A product is defined with a name, description, and button to add it to the cart, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a5831e93-4191-4718-b456-44238369c614.png"/></p>
<p>As we have multiple products, we would like to add each one in <kbd>productPanel</kbd> and fit the total width of <kbd>productPanel</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1f47f425-56d8-4cf7-97d3-6e578e1ed0c4.png"/></p>
<p>To reach this goal, we can recreate a row inside <kbd>productPanel</kbd>, with <kbd>products</kbd> forming a column of the row, as shown in the following code:</p>
<pre>&lt;div id="productPanel" class="col-8"&gt;
  &lt;div id="products" class="row"&gt;<br/>     &lt;-- Added programatically --&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<p>There we go. The main layout is done. Now we have to create the HTML product's representation as <kbd>div</kbd>, with its name, description, price, and a button to add it to the cart.</p>
<p>This looks almost the same as what we did when we modeled the product for the database. Wouldn't it be great if we could reuse the model created on the server side on the client? As we are using Scala.js, this is possible; indeed, we are using the same language. This is what we call an <strong>isomorphic</strong> <strong>application</strong>.</p>
<p>All we have to do is move the model code from the server project to the shared project. Using IntelliJ, just drag the <kbd>Models.scala</kbd> file from <kbd>server/app/models</kbd> to <kbd>shared/src/main/scala/io/fscala/shopping/shared</kbd>. By doing so, we can use the same model to create our product representation.</p>
<p>Create a new class named <kbd>ProductDiv</kbd> under <kbd>client/src/main/scala/io/fscala/shopping</kbd>. This class represents the HTML content of a product with a button to add itself to the cart.</p>
<p>The <kbd>ProductDiv</kbd> class contains the <kbd>Product</kbd> model, and looks like the following:</p>
<pre>case class ProductDiv(product: Product) {
  def content: Div = div(`class` := "col")<br/>                    (getProductDescription, getButton).render<br/>  private def getProductDescription =
    div(
      p(product.name),
      p(product.description),
      p(product.price))


  private def getButton = button(<br/>    `type` := "button",<br/>    onclick := addToCart)("Add to Cart")

  private def addToCart = () =&gt; ???
}</pre>
<p>The main method is the <kbd>content</kbd> method. It creates the product description and the button.</p>
<p>The <kbd>getProductDescription</kbd> method creates an HTML <kbd>div</kbd> with a paragraph for each of its properties.</p>
<p>The <kbd>getButton()</kbd> method creates an HTML button and uses the <kbd>addToCart</kbd> function to handle the <kbd>onclick</kbd> event. For now, we are not going to look at the implementation details of the <kbd>onclick</kbd> event.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cart panel</h1>
                </header>
            
            <article>
                
<p>The cart panel is a representation of the cart. It has a line for every product that is added, displaying the number of items, the name of the item type, the total price, and a button to remove it from the cart, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bb709f62-78c1-4eb9-8cea-4561a58391af.png" style="width:19.83em;height:2.75em;"/></p>
<p>We would like to add a line each time a new product is added to the cart, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0113d396-0a16-47a6-ae9e-020e6906ef59.png" style="width:20.50em;height:8.67em;"/></p>
<p>In this case, we do not need to modify the main layout as we are going to represent each line as a row with columns. The model of a line in the cart is shown in the following code:</p>
<pre><span>case class </span>CartLine(qty: <span>Int, </span>product: Product)</pre>
<p>The HTML content of the cart is shown in the following code:</p>
<pre>def content: Div = div(`class` := "row", id := s"cart-${product.code}-row")(<br/>  div(`class` := "col-1")(getDeleteButton),<br/>  div(`class` := "col-2")(getQuantityInput),<br/>  div(`class` := "col-6")(getProductLabel),<br/>  div(`class` := "col")(getPriceLabel)<br/>).render</pre>
<p>The previous code is for a row with four columns. The code for the button to delete it from the cart (<kbd>getDeleteButton</kbd>) is as follows:</p>
<pre>private def getDeleteButton = button(<br/>               `type` := "button",<br/>               onclick := removeFromCart)("X").render</pre>
<p>Note how you can add a listener to an event emitted by the component just by adding the method name on the <kbd>onclick</kbd> event. For now, we are not going to implement the action, and will leave it unimplemented (<kbd>???</kbd>), as shown in the following code:</p>
<pre>private def removeFromCart = () =&gt; ???</pre>
<p>The <kbd>input</kbd> text field representing the quantity in the cart (<kbd>quantityInput</kbd>) is written as follows:</p>
<pre>private def getQuantityInput = input(<br/>              id := s"cart-${product.code}-qty",<br/>              onchange := changeQty,<br/>              value := qty.toString,<br/>              `type` := "text",<br/>              style := "width: 100%;").render</pre>
<p>Again, on the <kbd>onchange</kbd> event, we call the <kbd>changeQty</kbd> function, defined as follows:</p>
<pre>private def changeQty = () =&gt; ???</pre>
<p>The product name (<kbd>getProductLabel</kbd>) is written as follows:</p>
<pre>private def getProductLabel = label(product.name).render</pre>
<p>Finally, the total price is written as <kbd>getPriceLabel</kbd>, as follows:</p>
<pre>private def getPriceLabel = label(product.price * qty).render</pre>
<p>As we will have the definition of a line in the cart, we can define the cart's <kbd>div</kbd>.</p>
<p>This <kbd>div</kbd> should provide an HTML representation of all of the lines and allow you to add a cart <kbd>line</kbd>. The implementation is as follows:</p>
<pre>case class CartDiv(lines: Set[CartLine]) {
  def content = lines.foldLeft(div.render) { (a, b) =&gt;
    a.appendChild(b.content).render
    a
  }
  def addProduct(line: CartLine): CartDiv = {
    new CartDiv(this.lines + line)
  }
}</pre>
<p>Upon its creation, <kbd>CartDiv</kbd> receives the list of lines represented by the <kbd>lines</kbd> value.</p>
<p>To get the HTML representation, the <kbd>content</kbd> function is called. In this function, we create an empty <kbd>div</kbd> and then append each <kbd>CartLine</kbd> into that <kbd>div</kbd>.</p>
<p>This is implemented using <kbd>foldLeft</kbd>. The empty <kbd>div</kbd> is created as the initial value, and then for each <kbd>CartLine</kbd> an anonymous function is called with <kbd>(a, b)</kbd> as parameters. The <kbd>a</kbd> parameter is the previous value (the empty <kbd>div</kbd> on the first iteration) and the <kbd>b</kbd> parameter is the next <kbd>CartLine</kbd> of the collection. The body of the method just appends <span>the content of</span> <kbd>CartDiv</kbd><span> </span><span>to</span> <kbd>div</kbd> <span>and returns <kbd>div</kbd> for the next iteration.</span></p>
<p>We added a function to add a product to <kbd>div</kbd> (<kbd>addProduct()</kbd>). We could have implemented this method by creating a mutable variable that holds the list of <kbd>CartLine</kbd> and updates it each time we want to add <kbd>CartLine</kbd>, but this would not be in the <span>spirit</span><span> of functional programming.</span></p>
<p>Instead, a new <kbd>CartDiv</kbd> with <kbd>new CartLine</kbd> that we added is returned from the function call.</p>
<p>Now that we have defined the product <kbd>div</kbd> and the cart <kbd>div</kbd>, it is time to build the interaction between these instances of <kbd>div</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the UI manager</h1>
                </header>
            
            <article>
                
<p>At some point, we will need to have a class that is responsible for the workflow of the user experience. For example, when a user clicks on the <span class="packt_screen">Add to cart</span> button, the product has to be added to the cart at the server level and the user interface has to be updated.</p>
<p>The UI manager takes responsibility for managing the workflow of the user experience, handling all communication with the server when needed, and is used as an entry point to start the Scala.js code. This is the main entry point of our client application when the application is executed in the browser.</p>
<p>For communicating with the server, we are going to use jQuery. This JavaScript library is widely used and is a reference in the JavaScript world.</p>
<p>This is one of the advantages of Scala.js. We can use existing JavaScript libraries, such as jQuery, from Scala. To use existing JavaScript libraries, we only need to define an interface, which is called a <strong>facade</strong> in Scala.js. The facade can be seen as an interface to redefine the JavaScript type and the JavaScript function signature. It means we need a facade for all of the JavaScript libraries we want to use. Fortunately, there are already a number of facades that already exist for the most important JavaScript frameworks. A list of available facades can be found at the Scala website (<a href="https://www.scala-js.org/libraries/facades.html">https://www.scala-js.org/libraries/facades.html</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding jQuery to our project</h1>
                </header>
            
            <article>
                
<p>To add jQuery and its facade into our project, we need to add the Scala facade and the JavaScript library.</p>
<p>For the facade, add the following<span> dependency</span><span> to the <kbd>libraryDependencies</kbd> variable in the <kbd>build.sbt</kbd> file</span><span> </span><span>:</span></p>
<pre>"org.querki" %%% "jquery-facade" % "1.2"</pre>
<p>To add the JavaScript library, add the following dependency to the <kbd>jsDependencies</kbd> variable:</p>
<pre>jsDependencies += 
                "org.webjars" % "jquery" % "2.2.1" / "jquery.js" 
                minified "jquery.min.js"</pre>
<div class="packt_infobox">This is the first library we are using in which we are adding a WebJar as a JavaScript library. This WebJar is a repository of JavaScript libraries packaged as a JAR file.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calling our API</h1>
                </header>
            
            <article>
                
<p>The first call we have to perform is the login to the server. For the purposes of this book, we have not designed a proper login page. Besides, the login itself is not really a login as it accepts any user!</p>
<p>We are going to log in with a random user every time we browse the index of the website.</p>
<p>By the way, what is the entry point of our client application?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting the main method</h1>
                </header>
            
            <article>
                
<p>By default, Scala.js only creates a JavaScript library with all your dependencies. To make it an application, you have to add the client configuration of the <kbd>build.sbt</kbd> file, as shown in the following code:</p>
<pre>scalaJSUseMainModuleInitializer := true</pre>
<p>Once defined, Scala.js looks for an object containing the <kbd>main</kbd> method, as in a normal JVM application. We can create that object in the <kbd>client/src/main/scala/io/fscala/shopping/client</kbd><span> folder.</span><span> C</span><span>reate a Scala file named</span> <kbd>UIManager.scala</kbd>.</p>
<p>In the <kbd>main</kbd> function, we would like to log in to the API and initialize the interface with <kbd>ProductDiv</kbd> and <kbd>CartDiv</kbd>, which we defined earlier, as shown in the following code:</p>
<pre>object UIManager {

  val origin: UndefOr[String] = dom.document.location.origin
  val cart: CartDiv = CartDiv(Set.empty[CartLine])<br/>  val webSocket: WebSocket = getWebSocket<br/>  val dummyUserName = s"user-${Random.nextInt(1000)}"<br/>  def main(args: Array[String]): Unit = {
    val settings = JQueryAjaxSettings<br/>                   .url(s"$origin/v1/login")<br/>                   .data(dummyUserName)                                                                 <br/>                   .contentType("text/plain")
    $.post(settings._result).done((_: String) =&gt; {
      initUI(origin)
    })
  }
}</pre>
<p>We define three properties on the <kbd>UIManager</kbd> object:</p>
<ul>
<li>The first is the <kbd>origin</kbd> property. This property uses the <kbd>dom</kbd> utility object from Scala.js; we will get <kbd>document.location.origin</kbd> from it. This represents the server location, with the protocol, hostname, and port. In development mode, this looks like <kbd>http://locahost:9000</kbd>.</li>
<li>The second property is <kbd>cart</kbd>, representing <kbd>CartDiv</kbd>. This is to keep a reference to it on the manager for later use. In the <kbd>main</kbd> function, we perform the login with a hardcoded user and, once successful, we initialize the user interface.</li>
<li>The last property is <kbd>dummyUserName</kbd>, representing a randomly generated username. This will simplify the code as we are not going to implement a real login process.</li>
</ul>
<p>Note how we can use jQuery from Scala. This is the beauty of the facade—we can use almost the same syntax as in JavaScript but with the advantage of strong Scala typing.</p>
<p>For example, to create the settings of the <kbd>post</kbd> call, we can use a method on the <kbd>JQueryAjaxSettings</kbd> object instead of creating a <kbd>Map</kbd> with a string as a key and anything as a value. This way, it is less error-prone, and we can take advantage of the IDE to autocomplete all of the possible properties.</p>
<p><span><span>The signature of the <kbd>done</kbd> jQuery function </span></span><span><span>is <kbd>Function</kbd> (<kbd>PlainObject</kbd> data, <kbd>String textStatus</kbd>, jqXHR). You can find out more about these types on the jQuery website:</span></span></p>
<ul>
<li><span><span><a href="http://api.jquery.com/Types/#Function">http://api.jquery.com/Types/#Function</a> </span></span></li>
<li><span><span><a href="http://api.jquery.com/Types/#PlainObject">http://api.jquery.com/Types/#PlainObject</a></span></span></li>
<li><span><span><a href="http://api.jquery.com/Types/#String">http://api.jquery.com/Types/#String</a></span></span></li>
<li><span><span><a href="http://api.jquery.com/Types/#jqXHR">http://api.jquery.com/Types/#jqXHR</a></span></span></li>
</ul>
<p>This function takes three parameters<span>, but as we are just interested in the first one, the <kbd>data</kbd></span><span> response</span><span>, we can ignore the o</span><span>thers. This is a particularity of JavaScript. </span>The implementation of the corresponding facade is as follows:</p>
<pre>def done(doneCallbacks: js.Function*): JQueryDeferred = js.native</pre>
<p>The function uses variadic parameters, noted with the asterisk character after the type. This is a perfect match with JavaScript, where the parameters are not mandatory.</p>
<p>It is now time to look at the creation of the user interface based on the data coming from the server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the user interface</h1>
                </header>
            
            <article>
                
<p>To initialize the user interface, we need to get all of the products from the database—including the cart for the user, if there are any—<span>through the web service API</span> and add it to the layout. The code for this looks like the following:</p>
<pre>private def initUI(origin: UndefOr[String]) = {
  $.get(url = s"$origin/v1/products", dataType = "text")
    .done((answers: String) =&gt; {
      val products = decode[Seq[Product]](answers)
      products.right.map { seq =&gt;
        seq.foreach(p =&gt; 
          $("#products").append(ProductDiv(p).content)
        )
        initCartUI(origin, seq)
      }
    })
    .fail((xhr: JQueryXHR, textStatus: String, textError: String) =&gt;
      println(s"call failed: $textStatus with status code: <br/>      ${xhr.status} $textError")
    )
}</pre>
<p>It will come as no surprise that we use jQuery to perform the <kbd>GET</kbd> method on the API. The <kbd>dataType</kbd> asks for a text<span> </span><span>response</span><span>, so that we can use Circe to parse the response and transform it into a sequence of</span> <kbd>Product</kbd><span>.</span></p>
<p>But, <span>is</span><span> </span><kbd>decode[Seq[Product]]</kbd><span> the same code that we used in</span> <a href="f2a68dcf-78e4-452e-b2bb-8b40f22a55c9.xhtml">Chapter 2</a><span>, <em>Developing a Retirement Calculator</em></span>, <span>the</span> REST <span>API, when we received JSON and converted it into a class?</span></p>
<p>Yes, we are using the same code with the same framework (Circe) to decode JSON and encode the class to JSON! The code running on the server, compiled as a JVM bytecode, is the same as the one running on the client, compiled as JavaScript.</p>
<p>Once we get the list of products, for each of them, we add <kbd>ProductDiv</kbd> in the <kbd>products</kbd> container. Again, jQuery is used to get an HTML element using its <kbd>id</kbd> attribute. At this point, knowledge of jQuery is more important than the Scala syntax.</p>
<p>The product panel is set up. Now it is the cart's turn.</p>
<p>The <kbd>initCartUI()</kbd> function is responsible for creating the HTML code representing the cart.The cart for the user is taken from the server. We cast it to a <kbd><span>Cart </span></kbd><span>sequence</span><span> and, for each of them, we get the corresponding product in order to have the name and price. Finally we append the line in</span> <kbd>CartDiv</kbd><span>, as shown in the following code:</span></p>
<pre>private def initCartUI(origin: UndefOr[String], products: Seq[Product]) = {
  $.get(url = s"$origin/v1/cart/products", dataType = "text")
    .done((answers: String) =&gt; {
      val carts = decode[Seq[Cart]](answers)
      carts.right.map { cartLines =&gt;
        cartLines.foreach { cartDao =&gt;
          val product = products.find(<br/>                                _.code == cartDao.productCode)
          product match {
            case Some(p) =&gt;
              val cartLine = CartLine(cartDao.quantity, p.name,  <br/>              cartDao.productCode, p.price)
              val cartContent = UIManager.cart.addProduct(cartLine)<br/>                                .content
              $("#cartPanel").append(cartContent)
            case None =&gt;
              println(<br/>                 s"product code ${cartDao.productCode} doesn't <br/>                   exists in the catalog")
          }
        }
      }
    })
    .fail((xhr: JQueryXHR, textStatus: String, textError: String) =&gt;
      println(<br/>        s"call failed: $textStatus with status code: <br/>          ${xhr.status} $textError")
    )
}</pre>
<p>In case of failure, we just print <span>the error</span> in the browser console.</p>
<p>With all this code, our user interface is now initialized. We can now implement the action on the user interface that we left unimplemented<span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing UI actions</h1>
                </header>
            
            <article>
                
<p>When the application is started, the user interface is the representation of the database in terms of the product and the user cart.</p>
<p>In this chapter, we will implement actions such as adding a product to the cart, updating the quantity to buy, and removing a product from the cart.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a product to the cart</h1>
                </header>
            
            <article>
                
<p>To add a product to the cart, we have to click on the <span class="packt_screen">Add to cart</span> button of the product panel. We need to edit <kbd>ProductDiv</kbd> again and implement the <kbd>addToCart</kbd> method.</p>
<p>As we said in the <em>Introducing the UI manager</em> section of this chapter, we would like to delegate the user interface manipulation to the <kbd>UIManager</kbd> class, so the <kbd>addToCart</kbd> method implementation is as follows:</p>
<pre>private def addToCart() = () =&gt; UIManager.addOneProduct(product)</pre>
<p>Indeed, we are asking <kbd>UIManager</kbd> to add the product to the cart. The <kbd>UIManager</kbd> builds a <kbd>div</kbd> representing the product in the cart, and if it is already in the cart, nothing happens.</p>
<p>The implementation is as follows:</p>
<pre>def addOneProduct(product: Product): JQueryDeferred = {
  val quantity = 1
  def onDone = () =&gt; {
    val cartContent = cart.addProduct(CartLine(quantity, product)
                                     ).content
    $("#cartPanel").append(cartContent)
    println(s"Product $product added in the cart")
  }
  postInCart(product.code, quantity, onDone)
}</pre>
<p>The <kbd>postInCart</kbd> <span>method</span><span> </span><span>is called with the product code and the initial quantity of</span> one <span>to create a new entry in the <kbd>Cart</kbd> table. Once created, the</span> <kbd>onDone()</kbd><span> method</span><span> </span><span>is called. This method adds the HTML elements that are needed to visualize the cart line in the user interface.</span></p>
<p>The <kbd>postInCart</kbd> method receives <kbd>productCode</kbd>, the quantity, and the method to call once the web service call is a success, as shown in the following code:</p>
<pre>private def postInCart(productCode: String, quantity: Int, onDone: () =&gt; Unit) = {
  val url = s"${UIManager.origin}/v1/cart/products/$productCode<br/>  /quantity/$quantity"
  $.post(JQueryAjaxSettings.url(url)._result)
    .done(onDone)
    .fail(() =&gt; println("cannot add a product twice"))
}</pre>
<p>If the web service call is a failure, we just print <span>the error </span><span>in the browser console and nothing is added to the user interface.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing a product from the cart</h1>
                </header>
            
            <article>
                
<p>The action to remove a product from the cart is triggered when the <span class="packt_screen">X</span> button related to a cart entry is clicked. This is implemented in the <kbd>removeFromCart()</kbd> method, located in the <kbd>CartLine</kbd> class. This is similar to the method we used in the previous section. The code is as follows:</p>
<pre>private def removeFromCart() = <br/>           () =&gt; UIManager.deleteProduct(product)</pre>
<p>We delegate the action to <kbd>UIManager</kbd>, and the implementation is as follows:</p>
<pre>def deleteProduct(product: Product): JQueryDeferred = {<br/>  def onDone = () =&gt; {<br/>    val cartContent = $(s"#cart-${product.code}-row")<br/>    cartContent.remove()<br/>    println(s"Product ${product.code} removed from the cart")<br/>  }<br/><br/>   deletefromCart(product.code, onDone)<br/>}</pre>
<p>This time, we call the <kbd>deleteFromCart</kbd> method and remove the row with the related ID.</p>
<p>The implementation of the web service call is as follows:</p>
<pre>private def deletefromCart(<br/>                           productCode: String,<br/>                           onDone: () =&gt; Unit) = {
  val url = s"${UIManager.origin}/v1/cart/products/$productCode"
  $.ajax(JQueryAjaxSettings.url(url).method("DELETE")._result)
    .done(onDone)
}</pre>
<p>As jQuery does not have a <kbd>delete()</kbd> method, we have to use the <kbd>ajax()</kbd> method and set the HTTP method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the quantity</h1>
                </header>
            
            <article>
                
<p>To update the quantity of a product in the cart, an HTML input text is used. As soon as the value is changed, we update the database with the new value. The <kbd>onchange()</kbd> event of the input text is used for this purpose.</p>
<p>It should come as no surprise that, in <kbd>CartDiv</kbd>, <span>as we did previously, </span>we delegate the call to <kbd>UIManager</kbd>, as shown in the following code:</p>
<pre>private def changeQty() = <br/>            () =&gt; UIManager.updateProduct(product)</pre>
<p>The implementation of <kbd>updateProduct</kbd> is as follows:</p>
<pre>def updateProduct(productCode: String): JQueryDeferred = {
  putInCart(product.code, quantity(product.code))
}</pre>
<p>We call the web service using the <kbd>quantity</kbd> set in <kbd>inputText</kbd>. The method to get the quantity is as follows:</p>
<pre> private def quantity(productCode: String) = Try {<br/>   val inputText = $(s"#cart-$productCode-qty")<br/>   if (inputText.length != 0) <br/>     Integer.parseInt(inputText.`val`().asInstanceOf[String]) <br/>   else 1<br/> }.getOrElse(1)</pre>
<p>We get the quantity from the HTML input text element. If it exists, we parse it as an integer. If the field does not exist or we are having a parsing error (a letter is inputted), we return the quantity of <kbd>1</kbd>.</p>
<p>The web service call to update the product quantity is as follows:</p>
<pre>private def putInCart(productCode: String, updatedQuantity: Int) = {
  val url = <br/>    s"${UIManager.origin}/v1/cart/products/<br/>    $productCode/quantity/$updatedQuantity"
    $.ajax(JQueryAjaxSettings.url(url).method("PUT")._result)
     .done()
}</pre>
<p>There we are. We have finished the implementation of the user interface for the shopping cart.</p>
<p>It is time to deploy it and check whether it works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying the user interface</h1>
                </header>
            
            <article>
                
<p>To deploy from the command line in the root of your project, enter the following code:</p>
<pre><strong>git push heroku master</strong></pre>
<p>Once the deployment is a success, you can browse <a href="https://shopping-fs.herokuapp.com/docs/swagger-ui/index.html?url=/v1/swagger.json">https://shopping-fs.herokuapp.com/</a>. The interface will be displayed as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7a9cd9db-8f6c-4550-8325-981034bf2ad0.png"/></p>
<p>You can now play with the interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Debugging the interface</h1>
                </header>
            
            <article>
                
<p>During development, we will not write the right code on the first draft. As humans, we make mistakes and do not perfectly remember all of the framework that we use.</p>
<p>In this chapter, we would like to give an entry point into debugging the code. The most obvious debugging system is to print in the console of the browser. This is done by directly using <kbd>println()</kbd> in Scala, and then looking at the log that is displayed in the console.</p>
<p>To have a look at the console and other debugging tools, you have to enable the developer tools on your browser. I am using Safari on Macintosh, but if you do not want to use it, I would recommend Google Chrome; the features are almost the same.</p>
<p>In Safari, enable the developer tools by clicking on the <span class="packt_screen">Show Develop menu in menu ba</span><span class="packt_screen">r</span> checkbox from the <span class="packt_screen">Advanced Preferences</span>.</p>
<p>Once done, a new <span><span class="packt_screen">Develop </span></span><span>menu will appear. Open this menu and select <span class="packt_screen">Show JavaScript Console</span>. A new section will appear in the Safari window with the console. If you click on the button to delete a cart row, a log is printed in the console, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/34173816-d2d5-4d88-a189-52a312f71fd2.png"/></p>
<p>You can interact with JavaScript by typing anything in the last line of the console.</p>
<p>For example, if you input <kbd>$("#productPanel")</kbd>, then the product <kbd>div</kbd> is selected, and you can inspect it, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d9165c82-2284-4532-8be3-379cc95374bd.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The inspect element code of the web page</div>
<p>You can even run tests. If you input <kbd>$("#productPanel").remove()</kbd>, the <kbd>div</kbd> will be removed from <kbd>dom</kbd> and your page will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/aa7483bd-c569-4a58-b7c5-0c09209ed5d6.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The inspect element code for the test</div>
<p>Refresh the page to get back to the product list. You can even debug the Scala code from inside the browser.</p>
<div class="packt_tip">You need to have the project in development mode to have the necessary files generated for debugging (the source maps files).</div>
<p>Click on the <span class="packt_screen">Debugger</span> tab and look for <kbd>UIManager.scala</kbd> on the left-hand panel, under <kbd>Sources/client-fast-opt.js</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/50f1f776-4826-43f6-b9b8-1fcdb7c689e7.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The UIManager.scala source code</div>
<p>Once <kbd>UIManager.scala</kbd> is selected, you can see the Scala source on the middle panel. Click on the gutter in line <strong><span class="packt_screen">30</span></strong>. A breakpoint will be set when the UI is initialized and product <kbd>div</kbd> instances are appended.</p>
<p>If you refresh the page, the engine will stop at that point and, on the right-hand panel, you will have all of the variables, even the local variables, such as <kbd>p</kbd>, representing the product to add at this point.</p>
<p>Click on the <span class="packt_screen">Continue script execution</span> button, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/76838a18-ada5-4ea6-903e-e2fc81e1d165.png"/></p>
<p>The script will continue until the next element in the collection, and the <kbd>p</kbd> variable on the right-hand panel will be updated with the next element.</p>
<p>I've just scratched the surface of all of the <span class="packt_screen">Develop</span> menu possibilities. You can have metrics that govern the time spent to load elements in the page and to process, inspect, and change any HTML elements in the page.</p>
<p>For more information, read the official documentation for Safari (<a href="https://support.apple.com/en-in/guide/safari-developer/welcome/mac">https://support.apple.com/en-in/guide/safari-developer/welcome/mac</a><a href="https://support.apple.com/en-in/guide/safari-developer/welcome/mac">)</a> and for Google Chrome (<a href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to build <span>a user interface</span><span> from scratch by first creating a mockup of the interface.</span></p>
<p>Then, we implemented the main layout, representing the skeleton of the application with all of the files that need to be linked, such as the CSS files and scripts. Once the layout was ready, we modeled the different HTML parts of the user interface in Scala, such as the product panel and the cart panel. The last step was to create the navigation system and user interaction. For that purpose, we created a UI manager, responsible for all the interaction.</p>
<p>As a side note, our user interface is pretty simple, without much interaction. This is why we chose to write the UI manager by hand. If the interface becomes more complex, then it might be useful to use a framework to manage it. At the time of writing, React.js and Angular are two of the most popular frameworks. Be aware, however, that frameworks come with a learning curve, and can quickly become obsolete.</p>
<p>Another solution would be to use Akka.js and more specifically the FSM actor to manage your user interface. After all, this is a state machine, reacting and acting based on events. This will be developed in the next chapter on the automatic price updater.</p>
<p>We also looked at the debugging facilities provided by the browser. By now, you should be aware of the advantages of using the same principles and code when writing the back-end and front-end of a complete solution.</p>
<p>We are going to go a step further in the next chapter. We will enable our application to get data from external sources and asynchronously update the user interface using Akka/Akka.js.</p>


            </article>

            
        </section>
    </body></html>