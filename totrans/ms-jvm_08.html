<html><head></head><body>
<div id="_idContainer034" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-79"><a id="_idTextAnchor103" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-80" class="calibre6"><a id="_idTextAnchor104" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">Garbage Collection and Memory Profiling</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In the intricate dance of </span><strong class="bold"><span class="kobospan" id="kobo.4.1">Java Virtual Machine</span></strong><span class="kobospan" id="kobo.5.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.6.1">JVM</span></strong><span class="kobospan" id="kobo.7.1">) internals, where bytecode is compiled and programs are executed</span><a id="_idIndexMarker392" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.8.1"> within the confines of register memory, an indispensable aspect emerges the artful orchestration of memory resources. </span><span class="kobospan" id="kobo.8.2">After traversing the realms of bytecode compilation and program execution, it is paramount to delve into the nuanced domain of memory management within the JVM. </span><span class="kobospan" id="kobo.8.3">This chapter embarks on a</span><a id="_idIndexMarker393" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.9.1"> comprehensive exploration of </span><strong class="bold"><span class="kobospan" id="kobo.10.1">garbage collectors</span></strong><span class="kobospan" id="kobo.11.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.12.1">GCs</span></strong><span class="kobospan" id="kobo.13.1">), unraveling the intricate tapestry governing Java </span><span><span class="kobospan" id="kobo.14.1">programs’ sustenance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.15.1">Our journey through the inner workings of the JVM reaches a crucial juncture as we unravel the mysteries of memory allocation, heap structures, and the ever-pivotal garbage collection mechanisms. </span><span class="kobospan" id="kobo.15.2">By comprehending the nuances of memory management, including distinctions between heap and stack, and mastering the intricacies of garbage collection, you will enhance your understanding of JVM internals and acquire the skills to wield precise control over memory usage. </span><span class="kobospan" id="kobo.15.3">Join us as we navigate the intricate terrain of GCs, unlocking the keys to optimizing memory efficiency in </span><span><span class="kobospan" id="kobo.16.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.17.1">In this chapter, we’ll explore the </span><span><span class="kobospan" id="kobo.18.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><span class="kobospan" id="kobo.19.1">GC overview</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.20.1">JVM tuning </span><span><span class="kobospan" id="kobo.21.1">and ergonomic</span><a id="_idTextAnchor105" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.22.1">s</span></span></li>
</ul>
<h1 id="_idParaDest-81" class="calibre6"><a id="_idTextAnchor106" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.23.1">GC overview</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">In the intricate landscape of </span><a id="_idIndexMarker394" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.25.1">JVM internals, the GC role stands as a critical component, influencing the efficiency and reliability of Java applications. </span><span class="kobospan" id="kobo.25.2">Our exploration delves into the fundamental concept of garbage collection and its pivotal role in managing memory within </span><span><span class="kobospan" id="kobo.26.1">the JVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">At its core, the purpose of the GC is to automatically reclaim memory occupied by objects no longer in use by the program. </span><span class="kobospan" id="kobo.27.2">In languages such as Java, which employ automatic memory management, developers are spared the burden of explicitly deallocating memory, enhancing productivity and reducing the likelihood of </span><span><span class="kobospan" id="kobo.28.1">memory-related errors.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.29.1">Imagine a scenario where each dynamically allocated object had to be manually deallocated by the programmer. </span><span class="kobospan" id="kobo.29.2">Not only does this introduce a considerable cognitive load, but it also opens</span><a id="_idIndexMarker395" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.30.1"> the door to memory leaks and inefficiencies. </span><span class="kobospan" id="kobo.30.2">In the absence of a GC, the responsibility of memory management falls entirely on the developer’s shoulders, increasing the likelihood of bugs and hindering the </span><span><span class="kobospan" id="kobo.31.1">development process.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">Java, with its </span><em class="italic"><span class="kobospan" id="kobo.33.1">Write Once, Run Anywhere</span></em><span class="kobospan" id="kobo.34.1"> philosophy, utilizes garbage collection to provide a seamless and robust memory management system. </span><span class="kobospan" id="kobo.34.2">The JVM’s GC identifies and reclaims unreachable objects, preventing memory leaks and ensuring optimal resource utilization. </span><span class="kobospan" id="kobo.34.3">The Java approach allows developers to focus on application logic rather than micromanaging memory, contributing to the language’s popularity in </span><span><span class="kobospan" id="kobo.35.1">enterprise-level applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">While Java champions automatic memory management through its GC, other programming languages have embraced various memory management strategies. </span><span class="kobospan" id="kobo.36.2">For instance, languages such as C and C++ frequently depend on manual memory management, granting developers explicit control but also leaving them susceptible to potential pitfalls. </span><span class="kobospan" id="kobo.36.3">Conversely, languages such as Python and C# implement their own garbage collection mechanisms, each meticulously crafted to address the unique requirements of their </span><span><span class="kobospan" id="kobo.37.1">respective languages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">Even among languages with garbage collection, the implementations can differ significantly. </span><span class="kobospan" id="kobo.38.2">Java’s GC is known for its generational approach, dividing the heap into different generations (young and old) and applying different collection algorithms to each. </span><span class="kobospan" id="kobo.38.3">Within the JVM itself, multiple GCs exist, each with its strategies and trade-offs. </span><span class="kobospan" id="kobo.38.4">This contrasts with, for instance, Python’s reference counting mechanism or the GCs used in languages such as Go </span><span><span class="kobospan" id="kobo.39.1">or C#.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">Memory leaks often result from programming errors, such as failing to release dynamically allocated memory or inadvertently maintaining references to objects beyond their useful lifespan. </span><span class="kobospan" id="kobo.40.2">Common scenarios include neglecting to free memory in languages that require manual memory management, such as C or C++, or unintentionally creating circular references in languages with automatic memory management, such </span><span><span class="kobospan" id="kobo.41.1">as Java.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">The GC plays a pivotal role in mitigating the risk of memory leaks in languages that employ automatic </span><a id="_idIndexMarker396" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.43.1">memory management. </span><span class="kobospan" id="kobo.43.2">Its primary function is to identify and reclaim memory occupied by objects no longer reachable or in use by the program. </span><span class="kobospan" id="kobo.43.3">By automating the memory deallocation process, the GC significantly reduces the likelihood of </span><span><span class="kobospan" id="kobo.44.1">memory leaks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">In automatic memory management, the GC acts as a vigilant defender, crucially mitigating the risk of memory leaks. </span><span class="kobospan" id="kobo.45.2">Automating the identification and reclamation of unused memory in languages such as Java streamlines the development process and enhances system stability. </span><span class="kobospan" id="kobo.45.3">With a generational approach that swiftly handles short-lived objects and smart memory management adapting to dynamic applications, the GC stands as a pivotal chapter in fortifying software integrity against the subtle menace of </span><span><span class="kobospan" id="kobo.46.1">memory leaks:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.47.1">Automated memory management</span></strong><span class="kobospan" id="kobo.48.1">: In languages such as Java, where automatic memory management is integral, the GC regularly scans the heap to identify objects with no reachable references. </span><span class="kobospan" id="kobo.48.2">Once identified, these unreferenced objects are marked for collection and deallocated, freeing up memory for </span><span><span class="kobospan" id="kobo.49.1">new allocations.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.50.1">Generational approach</span></strong><span class="kobospan" id="kobo.51.1">: Java’s GC often employs a generational approach, categorizing objects into different generations based on their age. </span><span class="kobospan" id="kobo.51.2">Younger objects, which are more likely to become unreachable quickly, are collected more frequently, while older objects undergo less frequent, more comprehensive garbage collection. </span><span class="kobospan" id="kobo.51.3">It helps quickly identify and collect short-lived objects, reducing the chances of </span><span><span class="kobospan" id="kobo.52.1">memory leaks.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.53.1">Smart memory management</span></strong><span class="kobospan" id="kobo.54.1">: Modern GCs are designed to be intelligent and adaptive. </span><span class="kobospan" id="kobo.54.2">They utilize algorithms and heuristics to optimize memory management based on the application’s behavior. </span><span class="kobospan" id="kobo.54.3">This adaptability ensures efficient garbage collection and minimizes the risk of memory leaks, even in complex and </span><span><span class="kobospan" id="kobo.55.1">dynamic applications.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.56.1">Within the intricate tapestry of JVM internals, the </span><em class="italic"><span class="kobospan" id="kobo.57.1">Mark and Sweep</span></em><span class="kobospan" id="kobo.58.1"> GC algorithm emerges as a cornerstone in managing memory efficiently. </span><span class="kobospan" id="kobo.58.2">This fundamental process operates in two key phases: the mark phase, where the GC discerns the utilization status of memory, marking objects as either reachable or unreachable, and the subsequent sweep phase, where the collector liberates the heap by reclaiming memory occupied by objects marked as</span><a id="_idIndexMarker397" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.59.1"> unreachable. </span><span class="kobospan" id="kobo.59.2">The advantages of this approach are profound, offering automatic memory management, mitigating dangling pointer issues, and significantly contributing to memory leak management, as the following </span><span><span class="kobospan" id="kobo.60.1">diagram shows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer029">
<span class="kobospan" id="kobo.61.1"><img alt="Figure 6.1: Mark and Sweep steps of the GC" src="image/B22030_06_01.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.62.1">Figure 6.1: Mark and Sweep steps of the GC</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">As we delve into the nuances of Mark and Sweep, we navigate the benefits and challenges inherent in this automatic memory management paradigm. </span><span class="kobospan" id="kobo.63.2">While it liberates developers from the intricacies of manual memory handling, it introduces considerations such as increased CPU power consumption and relinquishing control over object cleanup scheduling. </span><span class="kobospan" id="kobo.63.3">Join us on this exploration into the heart of JVM internals, where the Mark and Sweep algorithm plays a pivotal role in shaping the reliability and efficiency of </span><span><span class="kobospan" id="kobo.64.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">In our exploration, we’ve uncovered the automatic process of Mark and Sweep: its ability to effortlessly handle memory allocation and deallocation, its role in mitigating dangling pointers, and its significant contribution to managing </span><span><span class="kobospan" id="kobo.66.1">memory leaks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.67.1">However, no architectural marvel comes without its trade-offs. </span><span class="kobospan" id="kobo.67.2">In the case of Mark and Sweep, a prominent </span><a id="_idIndexMarker398" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.68.1">consideration emerges in the form of memory fragmentation. </span><span class="kobospan" id="kobo.68.2">As we unravel this aspect, we delve into the intricacies of how the algorithm, while adept at reclaiming memory, can leave behind fragmented pockets in the memory space. </span><span class="kobospan" id="kobo.68.3">These fragments, akin to scattered puzzle pieces, introduce challenges to the efficient allocation of contiguous memory blocks, impacting the overall efficiency of </span><span><span class="kobospan" id="kobo.69.1">the application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Our narrative thus far has illuminated the delicate balancing act between the advantages of automatic memory management and the potential drawbacks, emphasizing the need for a nuanced approach. </span><span class="kobospan" id="kobo.70.2">The trade-off between seamless automation and the specter of fragmentation prompts developers to weigh the benefits against the efficiency requirements of </span><span><span class="kobospan" id="kobo.71.1">their applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.72.1">Within the intricate realm of JVM internals, the choice of GC can profoundly impact the performance of Java applications. </span><strong class="bold"><span class="kobospan" id="kobo.73.1">Serial GC</span></strong><span class="kobospan" id="kobo.74.1">, a simple</span><a id="_idIndexMarker399" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.75.1"> and single-threaded collector, suits applications with modest</span><a id="_idIndexMarker400" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.76.1"> memory requirements, offering a straightforward approach to garbage collection. </span><span class="kobospan" id="kobo.76.2">Conversely, </span><strong class="bold"><span class="kobospan" id="kobo.77.1">Parallel GC</span></strong><span class="kobospan" id="kobo.78.1"> steps up for throughput-centric scenarios, leveraging multiple threads to expedite garbage collection tasks and enhance overall </span><a id="_idIndexMarker401" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.79.1">system efficiency. </span><span class="kobospan" id="kobo.79.2">Java’s default collector since version 9, </span><strong class="bold"><span class="kobospan" id="kobo.80.1">Garbage-First (G1) GC</span></strong><span class="kobospan" id="kobo.81.1">, strikes a balance between low latency and high throughput, making it a versatile choice for various applications. </span><span class="kobospan" id="kobo.81.2">Introducing a new</span><a id="_idIndexMarker402" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.82.1"> paradigm, the </span><strong class="bold"><span class="kobospan" id="kobo.83.1">Z GC</span></strong><span class="kobospan" id="kobo.84.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.85.1">ZGC</span></strong><span class="kobospan" id="kobo.86.1">) in Java 11 promises minimal pause times and enhanced scalability, catering to the demands of modern, resource-intensive applications. </span><span class="kobospan" id="kobo.86.2">As we embark on a journey through the intricacies of each collector, a nuanced understanding will empower developers to make informed decisions, optimizing garbage collection strategies to align with the specific needs of their </span><span><span class="kobospan" id="kobo.87.1">Java </span><a id="_idTextAnchor107" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.88.1">projects.</span></span></p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor108" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.89.1">Serial GC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">Within the tapestry </span><a id="_idIndexMarker403" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.91.1">of JVM internals, Serial GC is a fundamental player in</span><a id="_idIndexMarker404" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.92.1"> garbage collection strategies. </span><span class="kobospan" id="kobo.92.2">We will dissect the essence of Serial GC, a collector distinguished by its simplicity and singular-threaded approach to memory management. </span><span class="kobospan" id="kobo.92.3">As we delve into the intricacies of its operation, we explore why such a straightforward design is essential and the scenarios in which Serial GC shines. </span><span class="kobospan" id="kobo.92.4">Unveiling its advantages and limitations, we navigate the landscape to understand the optimal scenarios where this minimalist collector becomes a strategic choice for Java developers. </span><span class="kobospan" id="kobo.92.5">We will explore Serial GC, where the pursuit of simplicity intertwines with efficiency in the orchestration of memory within </span><span><span class="kobospan" id="kobo.93.1">the JVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.94.1">Serial GC is characterized by its </span><a id="_idIndexMarker405" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.95.1">sequential, </span><strong class="bold"><span class="kobospan" id="kobo.96.1">stop-the-world</span></strong><span class="kobospan" id="kobo.97.1"> approach to garbage collection. </span><span class="kobospan" id="kobo.97.2">It halts the application’s execution during the collection process, ensuring that no parallel threads interfere with identifying and reclaiming unreachable objects. </span><span class="kobospan" id="kobo.97.3">This simplicity allows Serial GC to streamline memory management without the complexity of </span><span><span class="kobospan" id="kobo.98.1">concurrent operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">The elegance of Serial GC </span><a id="_idIndexMarker406" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.100.1">comes with trade-offs, notably in the realm of throughput and responsiveness. </span><span class="kobospan" id="kobo.100.2">Given</span><a id="_idIndexMarker407" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.101.1"> its single-threaded nature, there may be more efficient choices for applications with large heaps or those requiring low pause times. </span><span class="kobospan" id="kobo.101.2">Stop-the-world pauses, while brief, can impact the user experience, making Serial GC better suited for scenarios where these pauses </span><span><span class="kobospan" id="kobo.102.1">are acceptable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.103.1">Serial GC seamlessly integrates with the Mark and Sweep algorithm. </span><span class="kobospan" id="kobo.103.2">It identifies reachable and unreachable objects during the mark phase, marking them accordingly. </span><span class="kobospan" id="kobo.103.3">In the subsequent sweep phase, it clears memory occupied by unreachable objects. </span><span class="kobospan" id="kobo.103.4">The sequential nature of Serial GC ensures a straightforward execution of these phases, simplifying the coordination between marking and sweeping, as the following </span><span><span class="kobospan" id="kobo.104.1">diagram shows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer030">
<span class="kobospan" id="kobo.105.1"><img alt="Figure 6.2: Serial GC working" src="image/B22030_06_02.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.106.1">Figure 6.2: Serial GC working</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.107.1">The simplicity of Serial GC shines in scenarios where the memory footprint is modest and the application’s performance is not overly sensitive to brief pauses. </span><span class="kobospan" id="kobo.107.2">It is well suited for client applications or environments with limited resources, where the straightforward, stop-the-world approach aligns seamlessly with the </span><span><span class="kobospan" id="kobo.108.1">system’s demands.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.109.1">As we immerse ourselves in the orchestration of memory within the JVM, a crucial aspect unfolds through the configuration options tailored for Serial GC. </span><span class="kobospan" id="kobo.109.2">The following table presents a harmonious ensemble of commands, each holding the power to influence and optimize the behavior of Serial GC. </span><span class="kobospan" id="kobo.109.3">From enabling or disabling the use of Serial GC to fine-tuning ratios, sizes, and thresholds, these commands offer a conductor’s wand to shape</span><a id="_idIndexMarker408" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.110.1"> the memory management symphony. </span><span class="kobospan" id="kobo.110.2">Join us in deciphering the significance of each command, providing developers and administrators with the means to sculpt an optimal </span><a id="_idIndexMarker409" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.111.1">performance for their Java applications by adjusting the parameters that govern the workings of </span><span><span class="kobospan" id="kobo.112.1">Serial GC:</span></span></p>
<table class="no-table-style" id="table001-3">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre16">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.113.1">Command</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.114.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.115.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">XX:+UseSerialGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.117.1">Enables the use of </span><span><span class="kobospan" id="kobo.118.1">Serial GC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.119.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">XX:-UseSerialGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.121.1">Disables Serial GC (default for </span><span><span class="kobospan" id="kobo.122.1">server-class machines).</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.123.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">XX:NewRatio=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.125.1">Sets the ratio of the young generation to the </span><span><span class="kobospan" id="kobo.126.1">old generation.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.127.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.128.1">XX:NewSize=&lt;size&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.129.1">Sets the initial size of the </span><span><span class="kobospan" id="kobo.130.1">young generation.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.131.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.132.1">XX:MaxNewSize=&lt;size&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.133.1">Sets the maximum size of the </span><span><span class="kobospan" id="kobo.134.1">young generation.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.135.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.136.1">XX:SurvivorRatio=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.137.1">Sets the ratio of Eden space to </span><span><span class="kobospan" id="kobo.138.1">survivor space.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.139.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">XX:MaxTenuringThreshold=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.141.1">Sets the maximum tenuring threshold for objects in the </span><span><span class="kobospan" id="kobo.142.1">young generation.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.143.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.144.1">XX:TargetSurvivorRatio=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.145.1">Sets the desired survivor space size as a percentage of the young </span><span><span class="kobospan" id="kobo.146.1">generation size.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.147.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.148.1">XX:PretenureSizeThreshold=&lt;size&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.149.1">Sets the threshold for object allocation in the old generation. </span><span class="kobospan" id="kobo.149.2">Objects larger than this size go directly to the </span><span><span class="kobospan" id="kobo.150.1">old generation.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.151.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.152.1">XX:MaxHeapSize=&lt;size&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.153.1">Sets the maximum </span><span><span class="kobospan" id="kobo.154.1">heap size.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.155.1">Table 6.1: Serial GC commands</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.156.1">These options allow developers and administrators to configure aspects of Serial GC, such as the size of the young generation, the ratio of survivor spaces, and overall heap size. </span><span class="kobospan" id="kobo.156.2">Adjusting these parameters enables fine-tuning of memory management for specific application </span><a id="_idIndexMarker410" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.157.1">requirements and </span><span><span class="kobospan" id="kobo.158.1">hardware characteristics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.159.1">The harmonious</span><a id="_idIndexMarker411" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.160.1"> coordination of memory management orchestrated by Serial GC has illuminated its advantages, trade-offs, and strategic scenarios in which its singular approach excels. </span><span class="kobospan" id="kobo.160.2">As we transition to our next section, the stage is set for a parallel performance as we delve into Parallel GC. </span><span class="kobospan" id="kobo.160.3">The evolution from singular to parallel threads promises an exploration of efficiency at scale and </span><span><span class="kobospan" id="kobo.161.1">enhanced throughput.</span></span><a id="_idTextAnchor109" class="calibre4 pcalibre pcalibre1"/></p>
<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor110" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.162.1">Parallel GC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.163.1">As we embark on the next</span><a id="_idIndexMarker412" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.164.1"> movement in our exploration of JVM</span><a id="_idIndexMarker413" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.165.1"> internals, the spotlight now shifts to Parallel GC. </span><span class="kobospan" id="kobo.165.2">In this section, we dive into the world of parallelism, where the efficiency of memory management takes center stage. </span><span class="kobospan" id="kobo.165.3">Parallel GC, with its multithreaded prowess, orchestrates a symphony of garbage collection, promising enhanced throughput and optimized performance for Java applications. </span><span class="kobospan" id="kobo.165.4">Through a nuanced lens, we unravel the complexities of Parallel GC—its characteristics, advantages, and scenarios where its parallel threads harmonize seamlessly with the demands of large-scale, data-intensive environments. </span><span class="kobospan" id="kobo.165.5">Join us in this section as we traverse the parallel rhythms of JVM internals, uncovering parallel threads that propel memory management to </span><span><span class="kobospan" id="kobo.166.1">new heights.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.167.1">Parallel GC’s hallmark lies in its multithreaded approach, making it particularly adept at handling more enormous heaps and achieving higher throughput compared to its single-threaded counterparts. </span><span class="kobospan" id="kobo.167.2">It divides the heap into sections, employing parallel threads to perform garbage collection tasks concurrently, resulting in faster execution and reduced </span><span><span class="kobospan" id="kobo.168.1">pause times.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.169.1">Parallel GC orchestrates a synchronized dance of efficiency within the JVM, seamlessly integrating with the Mark and Sweep algorithm. </span><span class="kobospan" id="kobo.169.2">In the intricate garbage collection process, Parallel GC leverages the power of multiple threads to execute the crucial steps of marking and sweeping</span><a id="_idIndexMarker414" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.170.1"> concurrently. </span><span class="kobospan" id="kobo.170.2">During the mark phase, each thread traverses a designated heap section, identifying and marking objects as reachable or unreachable. </span><span class="kobospan" id="kobo.170.3">This simultaneous marking across threads ensures a swift and parallel assessment of the memory space. </span><span class="kobospan" id="kobo.170.4">As the mark phase concludes, the </span><a id="_idIndexMarker415" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.171.1">collective effort of threads harmonizes in the sweep phase, where Parallel GC efficiently reclaims memory by discarding unreachable objects identified during marking. </span><span class="kobospan" id="kobo.171.2">The parallelism embedded in the Mark and Sweep process under Parallel GC optimizes throughput. </span><span class="kobospan" id="kobo.171.3">It showcases the synchronized brilliance of multiple threads working in unison to choreograph a performance that elegantly balances responsiveness and efficiency in memory management, as the following </span><span><span class="kobospan" id="kobo.172.1">diagram shows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer031">
<span class="kobospan" id="kobo.173.1"><img alt="Figure 6.3: Parallel GC working" src="image/B22030_06_03.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.174.1">Figure 6.3: Parallel GC working</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.175.1">While Parallel GC excels in throughput, its reliance on parallelism introduces trade-offs, notably in responsiveness. </span><span class="kobospan" id="kobo.175.2">Stop-the-world pauses, while minimized, can still impact the application’s responsiveness, making it less suitable for scenarios where low latency is paramount. </span><span class="kobospan" id="kobo.175.3">Additionally, the increased CPU usage due to parallelism might be a consideration for </span><span><span class="kobospan" id="kobo.176.1">resource-constrained environments.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.177.1">Parallel GC shines brightest in </span><a id="_idIndexMarker416" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.178.1">scenarios where large heaps and data-intensive applications are the norm. </span><span class="kobospan" id="kobo.178.2">It is well suited for batch processing, scientific computing, and scenarios where maximizing throughput is crucial. </span><span class="kobospan" id="kobo.178.3">However, its trade-offs make it a strategic choice for applications that can tolerate brief pauses in exchange for optimized </span><span><span class="kobospan" id="kobo.179.1">overall performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.180.1">As we unravel the intricacies of Parallel GC, we explore how its parallel threads choreograph a performance that balances the demands of large-scale memory management. </span><span class="kobospan" id="kobo.180.2">Join us in this section as we navigate the landscape of parallel garbage collection, understanding when its parallel prowess becomes a strategic choice for optimizing memory orchestration within </span><span><span class="kobospan" id="kobo.181.1">the JVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.182.1">In our exploration of </span><a id="_idIndexMarker417" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.183.1">Parallel GC within the intricacies of JVM internals, the ability to finely tune its behavior becomes paramount. </span><span class="kobospan" id="kobo.183.2">The following table offers a comprehensive ensemble of commands, each a key to unlocking the potential of</span><a id="_idIndexMarker418" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.184.1"> Parallel GC’s efficiency and throughput. </span><span class="kobospan" id="kobo.184.2">From turning its use on or off to configuring the number of threads, setting pause-time goals, and employing adaptive sizing policies, these options empower developers and administrators to shape the orchestration of memory management within the JVM. </span><span class="kobospan" id="kobo.184.3">As we delve into the nuances of each command, this ensemble becomes a conductor’s guide, enabling the crafting of a performance optimized to meet the unique demands of Java applications. </span><span class="kobospan" id="kobo.184.4">Join us in deciphering the significance of these commands, providing a symphony of possibilities for molding Parallel GC to harmonize seamlessly with the diverse landscapes of </span><span><span class="kobospan" id="kobo.185.1">JVM environments:</span></span></p>
<table class="no-table-style" id="table002">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.186.1">Command</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.187.1">Description</span></strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.188.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">XX:+UseParallelGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.190.1">Enables the use of </span><span><span class="kobospan" id="kobo.191.1">Parallel GC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.192.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.193.1">XX:-UseParallelGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.194.1">Disables </span><span><span class="kobospan" id="kobo.195.1">Parallel GC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.196.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">XX:ParallelGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.198.1">Sets the number of threads for </span><span><span class="kobospan" id="kobo.199.1">garbage collection.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.200.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.201.1">XX:MaxGCPauseMillis=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.202.1">Sets the maximum desired pause-time goal for </span><span><span class="kobospan" id="kobo.203.1">garbage collection.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.204.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.205.1">XX:GCTimeRatio=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.206.1">Sets the target ratio of garbage collection time to </span><span><span class="kobospan" id="kobo.207.1">application time.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.208.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.209.1">XX:UseAdaptiveSizePolicy</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.210.1">Enables adaptive sizing policies for heap and </span><span><span class="kobospan" id="kobo.211.1">survivor spaces.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.212.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">XX:AdaptiveSizeThroughPutPolicy</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.214.1">Configures the adaptive sizing policy for throughput-oriented </span><span><span class="kobospan" id="kobo.215.1">garbage collection.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.216.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.217.1">XX:AdaptiveSizePolicyOutputInterval=&lt;n&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.218.1">Sets the interval, in the number of collections, for adaptive sizing </span><span><span class="kobospan" id="kobo.219.1">policy output.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.220.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">XX:ParallelGCVerbose</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.222.1">Enables verbose output from </span><span><span class="kobospan" id="kobo.223.1">Parallel GC.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.224.1">Table 6.2: Parallel GC commands</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.225.1">These options provide a means to configure and fine-tune the behavior of Parallel GC, allowing developers and administrators to optimize garbage collection for specific application requirements and </span><span><span class="kobospan" id="kobo.226.1">hardware characteristics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.227.1">As we conclude our exploration</span><a id="_idIndexMarker419" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.228.1"> into the Parallel GC world, we find ourselves enriched with insights into the parallel threads that orchestrate a harmonious performance within the JVM. </span><span class="kobospan" id="kobo.228.2">The multithreaded efficiency of Parallel GC, showcased</span><a id="_idIndexMarker420" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.229.1"> through its configuration options, provides a powerful toolkit for developers and administrators seeking to optimize memory management in diverse JVM environments. </span><span class="kobospan" id="kobo.229.2">Our journey through the parallel rhythms has set the stage for the next act—G1 GC. </span><span class="kobospan" id="kobo.229.3">Join us in the upcoming section as we delve into the nuances of G1, unraveling its characteristics, advantages, and intricacies that position it as a pivotal player in the </span><a id="_idIndexMarker421" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.230.1">symphony of garbage</span><a id="_idIndexMarker422" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.231.1"> collection strategies within </span><span><span class="kobospan" id="kobo.232.1">the J</span><a id="_idTextAnchor111" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.233.1">VM.</span></span></p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor112" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.234.1">G1</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.235.1">As we continue our</span><a id="_idIndexMarker423" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.236.1"> exploration of JVM internals, our spotlight now turns to G1 GC. </span><span class="kobospan" id="kobo.236.2">Positioned </span><a id="_idIndexMarker424" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.237.1">as a modern successor to its predecessors, G1 introduces a paradigm shift in garbage collection strategies. </span><span class="kobospan" id="kobo.237.2">In this section, we delve into the intricacies of G1, unraveling its characteristics, operational nuances, and the innovative approaches it brings to the forefront of memory management. </span><span class="kobospan" id="kobo.237.3">G1’s meticulous focus on achieving low latency, predictable pause times, and efficient heap utilization marks it as a key player in the symphony of garbage collection within the JVM. </span><span class="kobospan" id="kobo.237.4">Join us in this section as we explore the evolution of garbage collection strategies, dissect the principles that underpin G1, and unveil the symphonic efficiency it brings to the dynamic landscape of </span><span><span class="kobospan" id="kobo.238.1">JVM internals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.239.1">G1 GC is designed to address the challenges posed by traditional garbage collection strategies. </span><span class="kobospan" id="kobo.239.2">It introduces a region-based approach, dividing the Java heap into smaller, uniformly sized regions. </span><span class="kobospan" id="kobo.239.3">This departure from the monolithic heap structure allows G1 to manage memory more flexibly </span><span><span class="kobospan" id="kobo.240.1">and precisely.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.241.1">G1 divides the heap into regions and categorizes them into three main types: Eden, survivor, and old. </span><span class="kobospan" id="kobo.241.2">The size and configuration of these regions are dynamic, allowing G1 to adapt to the memory needs of </span><span><span class="kobospan" id="kobo.242.1">the application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.243.1">The concept of the liveness space is central to G1’s efficiency. </span><span class="kobospan" id="kobo.243.2">The liveness space comprises regions with live objects—objects still actively referenced by the application. </span><span class="kobospan" id="kobo.243.3">G1 identifies and prioritizes regions with the least live data for garbage collection. </span><span class="kobospan" id="kobo.243.4">This strategic approach optimizes the collection process by targeting areas where reclaimable memory is most concentrated, reducing both the frequency and duration of garbage collection pauses, as the following </span><span><span class="kobospan" id="kobo.244.1">diagram shows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer032">
<span class="kobospan" id="kobo.245.1"><img alt="Figure 6.4: G1 process and liveness space working" src="image/B22030_06_04.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.246.1">Figure 6.4: G1 process and liveness space working</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.247.1">G1’s primary goal is to achieve low latency and predictable pause times. </span><span class="kobospan" id="kobo.247.2">By prioritizing regions with the least live data, G1 minimizes the impact on application responsiveness. </span><span class="kobospan" id="kobo.247.3">It makes G1 particularly</span><a id="_idIndexMarker425" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.248.1"> well suited for scenarios where maintaining consistent and low pause times is critical, such as in interactive and </span><span><span class="kobospan" id="kobo.249.1">real-time applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">G1 employs adaptive collection strategies to adjust its approach based on the application’s dynamic </span><a id="_idIndexMarker426" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.251.1">behavior. </span><span class="kobospan" id="kobo.251.2">It can dynamically resize regions, alter the garbage collection frequency, and adapt its overall strategy to align with the evolving demands of </span><span><span class="kobospan" id="kobo.252.1">the application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.253.1">In essence, G1 GC’s utilization of liveness spaces, along with its region-based approach, positions it as a sophisticated and efficient solution for memory management in modern Java applications. </span><span class="kobospan" id="kobo.253.2">The focus on predictability and adaptability makes G1 valuable in the landscape of garbage collection strategies within </span><span><span class="kobospan" id="kobo.254.1">the JVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.255.1">In our journey through the orchestration of memory within the JVM, the following table unfolds as a conductor’s guide to G1. </span><span class="kobospan" id="kobo.255.2">Each command within this ensemble provides a key to unlocking the precision and efficiency that G1 brings to garbage collection. </span><span class="kobospan" id="kobo.255.3">From turning G1 on or off to fine-tuning parameters such as heap region size, pause-time goals, and adaptive strategies, these options empower developers and administrators to sculpt the symphony of memory management within the JVM. </span><span class="kobospan" id="kobo.255.4">As we delve into the significance of each command, we navigate the intricacies that define G1’s performance, crafting a balance between predictability and adaptability. </span><span class="kobospan" id="kobo.255.5">Join us in deciphering this symphony of configurations, where each note resonates with the nuanced precision that G1 introduces to the dynamic landscape of </span><span><span class="kobospan" id="kobo.256.1">JVM internals:</span></span></p>
<table class="no-table-style" id="table003">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre16">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.257.1">Command</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.258.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.259.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">XX:+UseG1GC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.261.1">Enables the use of </span><span><span class="kobospan" id="kobo.262.1">G1 GC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.263.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.264.1">XX:-UseG1GC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.265.1">Disables </span><span><span class="kobospan" id="kobo.266.1">G1 GC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.267.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.268.1">XX:G1HeapRegionSize=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.269.1">Sets the size of G1 garbage </span><span><span class="kobospan" id="kobo.270.1">collection regions.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.271.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.272.1">XX:MaxGCPauseMillis=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.273.1">Sets the maximum desired pause-time goal for G1 </span><span><span class="kobospan" id="kobo.274.1">garbage collection.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.275.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.276.1">XX:InitiatingHeapOccupancyPercent=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.277.1">Sets the percentage of heap occupancy to start a G1 garbage </span><span><span class="kobospan" id="kobo.278.1">collection cycle.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.279.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">XX:G1NewSizePercent=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.281.1">Sets the percentage of heap size to use as the minimum for the young generation </span><span><span class="kobospan" id="kobo.282.1">in G1.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.283.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">XX:G1MaxNewSizePercent=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.285.1">Sets the maximum percentage of heap size to use as the maximum for the young generation </span><span><span class="kobospan" id="kobo.286.1">in G1.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.287.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.288.1">XX:ParallelGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.289.1">Sets the number of parallel garbage collection threads </span><span><span class="kobospan" id="kobo.290.1">for G1.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.291.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.292.1">XX:ConcGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.293.1">Sets the number of parallel garbage collection threads for the concurrent phase </span><span><span class="kobospan" id="kobo.294.1">in G1.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.295.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.296.1">XX:G1ReservePercent=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.297.1">Sets the target percentage of heap to reserve as space for future garbage </span><span><span class="kobospan" id="kobo.298.1">collection cycles.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.299.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.300.1">XX:G1TargetSurvivorOccupancy=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.301.1">Sets the target occupancy of survivor space within each </span><span><span class="kobospan" id="kobo.302.1">G1 region.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.303.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.304.1">XX:G1HeapWastePercent=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.305.1">Sets the target percentage of wasted space within a G1 region before a region is considered </span><span><span class="kobospan" id="kobo.306.1">for reclamation.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.307.1">Table 6.3: G1 commands</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.308.1">These options provide a means to configure and fine-tune the behavior of G1 GC, allowing developers and administrators to optimize garbage collection for specific application requirements </span><a id="_idIndexMarker427" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.309.1">and </span><span><span class="kobospan" id="kobo.310.1">hardware characteristics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.311.1">On our exploration into the intricacies of G1 GC, we stand enriched with insights into the precision and adaptability that define its symphony of memory management within the JVM. </span><span class="kobospan" id="kobo.311.2">The meticulous configuration options presented in our ensemble guide offer a conductor’s wand, shaping G1’s performance to align seamlessly with the diverse demands of Java </span><a id="_idIndexMarker428" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.312.1">applications. </span><span class="kobospan" id="kobo.312.2">As we set our sights on the next section, the stage is set for a crescendo as we unravel the innovative nuances </span><span><span class="kobospan" id="kobo.313.1">of ZGC.</span></span><a id="_idTextAnchor113" class="calibre4 pcalibre pcalibre1"/></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor114" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.314.1">ZGC</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.315.1">In our continued exploration </span><a id="_idIndexMarker429" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.316.1">of JVM internals, our focus shifts to the forefront of innovation by</span><a id="_idIndexMarker430" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.317.1"> introducing ZGC. </span><span class="kobospan" id="kobo.317.2">Positioned as a game-changer in garbage collection strategies, ZGC emerges as a beacon of efficiency and low-latency performance. </span><span class="kobospan" id="kobo.317.3">This section serves as our gateway into the world of ZGC, unraveling its cutting-edge features, adaptive techniques, and commitment to minimizing pause times. </span><span class="kobospan" id="kobo.317.4">With the pursuit of responsiveness at its core, ZGC redefines the dynamics of garbage collection, offering a solution tailored for modern, dynamic applications. </span><span class="kobospan" id="kobo.317.5">Join us in this section as we delve into the revolutionary advancements that ZGC brings to the JVM, marking a pivotal milestone in the evolution of garbage </span><span><span class="kobospan" id="kobo.318.1">collection strategies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.319.1">ZGC stands at the forefront of</span><a id="_idIndexMarker431" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.320.1"> modern garbage collection strategies, introducing groundbreaking features that redefine the dynamics of memory management within the JVM. </span><span class="kobospan" id="kobo.320.2">At its core, ZGC prioritizes low latency and responsiveness, aiming to minimize pause times for applications with stringent performance requirements. </span><span class="kobospan" id="kobo.320.3">One of ZGC’s key innovations is its concurrent approach to garbage collection. </span><span class="kobospan" id="kobo.320.4">Unlike traditional collectors that halt the application during certain phases, ZGC performs major garbage collection tasks concurrently with the application threads, ensuring that pause times are kept to a minimum. </span><span class="kobospan" id="kobo.320.5">This concurrent model is particularly advantageous for applications where responsiveness is critical, such as in real-time systems, interactive applications, or services where downtime must </span><span><span class="kobospan" id="kobo.321.1">be minimized.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">In computer memory, multi-mapping</span><a id="_idIndexMarker432" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.323.1"> refers to a technique in which specific addresses in the virtual memory space point to the same ones in physical memory. </span><span class="kobospan" id="kobo.323.2">It means that multiple virtual addresses correspond to the same physical location. </span><span class="kobospan" id="kobo.323.3">Applications interact with data through virtual memory, and they remain oblivious to the underlying multi-mapping mechanism. </span><span class="kobospan" id="kobo.323.4">This abstraction is crucial for the applications, allowing them to access data without being aware of the complexities involved in mapping virtual to physical memory, as the following </span><span><span class="kobospan" id="kobo.324.1">diagram shows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer033">
<span class="kobospan" id="kobo.325.1"><img alt="Figure 6.5: ZGC process mapping" src="image/B22030_06_05.jpg" class="calibre5"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.326.1">Figure 6.5: ZGC process mapping</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">Dynamic memory allocation, a common practice in programming, contributes to memory fragmentation over time. </span><span class="kobospan" id="kobo.327.2">When objects are allocated and deallocated, free space gaps can emerge in the memory layout. </span><span class="kobospan" id="kobo.327.3">Over time, these gaps accumulate, leading to </span><strong class="bold"><span class="kobospan" id="kobo.328.1">fragmentation</span></strong><span class="kobospan" id="kobo.329.1">, wherein the</span><a id="_idIndexMarker433" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.330.1"> memory resembles a chessboard with alternating areas of free and used space. </span><span class="kobospan" id="kobo.330.2">To address this, there are two </span><span><span class="kobospan" id="kobo.331.1">main strategies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.332.1">One approach involves scanning </span><a id="_idIndexMarker434" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.333.1">the memory for free space large enough to accommodate the desired object. </span><span class="kobospan" id="kobo.333.2">This method, while feasible, is resource-intensive, especially if performed frequently. </span><span class="kobospan" id="kobo.333.3">Additionally, it does not entirely eliminate</span><a id="_idIndexMarker435" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.334.1"> fragmentation, as finding an exact match for the required space size can be challenging, leaving gaps </span><span><span class="kobospan" id="kobo.335.1">between objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.336.1">The alternative strategy is to periodically relocate objects from fragmented memory areas to free spacein a more compact format. </span><span class="kobospan" id="kobo.336.2">It involves dividing the memory space into blocks and relocating entire blocks of objects simultaneously. </span><span class="kobospan" id="kobo.336.3">By doing so, the allocation of memory becomes faster, as known empty blocks are available. </span><span class="kobospan" id="kobo.336.4">This strategy helps manage memory fragmentation more efficiently, balancing the need for dynamic allocation and the desire for a more contiguous and organized </span><span><span class="kobospan" id="kobo.337.1">memory layout.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.338.1">Trade-offs are inherent in any garbage collection strategy, and ZGC is no exception. </span><span class="kobospan" id="kobo.338.2">While it excels in reducing pause times, it may not achieve the same throughput as collectors optimized for throughput at the expense of latency. </span><span class="kobospan" id="kobo.338.3">Additionally, ZGC might not be optimal for applications with extremely large heaps, as its concurrent approach may introduce some overhead. </span><span class="kobospan" id="kobo.338.4">However, for scenarios where low latency is paramount, and the application’s responsiveness takes precedence over maximum throughput, ZGC emerges as a </span><span><span class="kobospan" id="kobo.339.1">powerful solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.340.1">Another notable feature of ZGC is its ability to resize the heap dynamically. </span><span class="kobospan" id="kobo.340.2">ZGC adapts the heap size to the</span><a id="_idIndexMarker436" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.341.1"> application’s demand, allowing it to manage memory in response to changing workloads efficiently. </span><span class="kobospan" id="kobo.341.2">This adaptability is particularly beneficial in environments where workloads vary, providing an agile and responsive memory </span><span><span class="kobospan" id="kobo.342.1">management solution.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.343.1">In essence, ZGC represents a paradigm shift in garbage collection, offering a sophisticated solution for applications demanding low latency and responsiveness without compromising</span><a id="_idIndexMarker437" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.344.1"> memory management efficiency. </span><span class="kobospan" id="kobo.344.2">Its innovative features and concurrent design make it a compelling choice for modern Java applications operating in dynamic and </span><span><span class="kobospan" id="kobo.345.1">resource-intensive scenarios.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.346.1">In the dynamic realm of JVM internals, ZGC takes center stage as a cutting-edge solution, prioritizing low-latency performance and responsiveness. </span><span class="kobospan" id="kobo.346.2">This table serves as a compass in navigating the configuration landscape of ZGC, providing developers and administrators with a curated set of commands to sculpt its behavior. </span><span class="kobospan" id="kobo.346.3">From turning ZGC on or off to fine-tuning parameters such as pause times, thread counts, and memory uncommit policies, these options empower users to tailor ZGC to the specific demands of their Java applications. </span><span class="kobospan" id="kobo.346.4">As we delve into the significance of each command, this guide becomes an essential resource for optimizing ZGC performance, ensuring a harmonious balance between efficiency and adaptability. </span><span class="kobospan" id="kobo.346.5">Join us in unlocking the potential of ZGC, where each command becomes a note in the symphony of precision that defines the future of garbage collection strategies within </span><span><span class="kobospan" id="kobo.347.1">the JVM:</span></span></p>
<table class="no-table-style" id="table004">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre16">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.348.1">Command</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.349.1">Description</span></strong></span></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.350.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.351.1">XX:+UseZGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.352.1">Enables the use </span><span><span class="kobospan" id="kobo.353.1">of ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.354.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.355.1">XX:-UseZGC</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.356.1">Disables ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.357.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.358.1">XX:MaxGCPauseMillis=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.359.1">Sets the maximum desired pause time goal for ZGC </span><span><span class="kobospan" id="kobo.360.1">garbage collection.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.361.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.362.1">XX:GCPauseIntervalMillis=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.363.1">Sets the maximum interval between </span><span><span class="kobospan" id="kobo.364.1">ZGC pauses.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.365.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.366.1">XX:ConcGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.367.1">Sets the number of parallel garbage collection threads </span><span><span class="kobospan" id="kobo.368.1">for ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.369.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.370.1">XX:ParallelGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.371.1">Sets the number of parallel garbage collection threads for the parallel phase </span><span><span class="kobospan" id="kobo.372.1">of ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.373.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.374.1">XX:ConcGCThreads=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.375.1">Sets the number of parallel garbage collection threads for the concurrent phase </span><span><span class="kobospan" id="kobo.376.1">of ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.377.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.378.1">XX:ZUncommitDelay=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.379.1">Sets the delay for uncommitting memory after a region is no </span><span><span class="kobospan" id="kobo.380.1">longer needed.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.381.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">XX:ZUncommitDelayMax=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.383.1">Sets the maximum delay for uncommitting memory after a region is no </span><span><span class="kobospan" id="kobo.384.1">longer needed.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.385.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">XX:ZUncommitDelayPolicy=&lt;adaptive\|fixed&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.387.1">Sets the uncommit delay policy for ZGC. </span><span class="kobospan" id="kobo.387.2">Options include </span><strong class="bold"><span class="kobospan" id="kobo.388.1">adaptive</span></strong> <span><span class="kobospan" id="kobo.389.1">and </span></span><span><strong class="bold"><span class="kobospan" id="kobo.390.1">fixed</span></strong></span><span><span class="kobospan" id="kobo.391.1">.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.392.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.393.1">XX:SoftMaxHeap=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.394.1">Sets the soft maximum heap size </span><span><span class="kobospan" id="kobo.395.1">for ZGC.</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.396.1">-</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.397.1">XX:ZHeapSize=&lt;value&gt;</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.398.1">Sets the ZGC </span><span><span class="kobospan" id="kobo.399.1">heap size.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.400.1">Table 6.4: ZGC commands</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.401.1">These options provide a means to configure and fine-tune the behavior of ZGC, allowing developers and administrators to optimize garbage collection for specific application requirements and </span><span><span class="kobospan" id="kobo.402.1">hardware characteristics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.403.1">As we wrap up our exploration into the intricacies of ZGC, we find ourselves immersed in the world of precision performance and low-latency responsiveness. </span><span class="kobospan" id="kobo.403.2">The table of ZGC commands presented here serves as a guide, unlocking the potential for users to fine-tune and optimize ZGC for </span><a id="_idIndexMarker438" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.404.1">their Java applications. </span><span class="kobospan" id="kobo.404.2">This section has laid the foundation for understanding how ZGC reshapes the landscape of garbage </span><span><span class="kobospan" id="kobo.405.1">collection strategies.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.406.1">Our journey doesn’t end here but gracefully transitions into the next act—ergonomics and tuning. </span><span class="kobospan" id="kobo.406.2">In the forthcoming chapters, we will delve into the art of optimizing Java applications, exploring </span><a id="_idIndexMarker439" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.407.1">strategies to fine-tune the performance of the JVM to meet the nuanced demands of diverse workloads. </span><span class="kobospan" id="kobo.407.2">Join us as we navigate the realm of JVM tuning, where each adjustment becomes a brushstroke in the canvas of crafting optimal Java </span><span><span class="kobospan" id="kobo.408.1">application performance</span><a id="_idTextAnchor115" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.409.1">.</span></span></p>
<h1 id="_idParaDest-86" class="calibre6"><a id="_idTextAnchor116" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.410.1">JVM tuning and ergonomics</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.411.1">In the dynamic landscape of Java application development, the twin pillars of ergonomics and profiling emerge as crucial elements in achieving optimal performance. </span><span class="kobospan" id="kobo.411.2">This section marks our journey into fine-tuning</span><a id="_idIndexMarker440" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.412.1"> Java applications, exploring the principles of ergonomics to adapt the JVM automatically to varying workloads. </span><span class="kobospan" id="kobo.412.2">Simultaneously, we</span><a id="_idIndexMarker441" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.413.1"> delve into profiling, a powerful tool for gaining insights into the runtime behavior of applications. </span><span class="kobospan" id="kobo.413.2">As we navigate the nuances of optimizing Java performance, ergonomics and profiling become our guiding lights, offering strategies to sculpt applications for responsiveness and efficiency. </span><span class="kobospan" id="kobo.413.3">Join us in this section as we uncover the synergy between adaptive tuning and insightful profiling, unlocking the potential to elevate Java applications to new levels of performance </span><span><span class="kobospan" id="kobo.414.1">and responsiveness.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.415.1">Ergonomics in the context of Java refers to the adaptive tuning capabilities embedded within the JVM to adjust its configuration automatically based on the characteristics of the underlying hardware and the application’s behavior. </span><span class="kobospan" id="kobo.415.2">The primary goal of ergonomics is to enhance the performance and responsiveness of Java applications without requiring manual intervention from developers. </span><span class="kobospan" id="kobo.415.3">By dynamically adjusting parameters such as garbage collection algorithms, heap sizes, and thread counts, ergonomics aims to strike an optimal balance for a given </span><span><span class="kobospan" id="kobo.416.1">runtime environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.417.1">However, the default configuration set by ergonomics is often considered a form of premature optimization. </span><span class="kobospan" id="kobo.417.2">It is because the default settings are determined at JVM startup, relying on heuristics and assumptions about the environment. </span><span class="kobospan" id="kobo.417.3">While these defaults may work reasonably well for a broad range of applications and hardware, they might not be the most efficient configuration for specific use cases. </span><span class="kobospan" id="kobo.417.4">Premature optimization occurs when</span><a id="_idIndexMarker442" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.418.1"> the JVM makes assumptions about application behavior without sufficient </span><a id="_idIndexMarker443" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.419.1">runtime information, potentially leading to </span><span><span class="kobospan" id="kobo.420.1">suboptimal performance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.421.1">Ergonomics can choose between Serial GC and G1 based on the system’s capabilities. </span><span class="kobospan" id="kobo.421.2">Serial GC is typically chosen as the default, especially for single-processor systems or when memory is limited. </span><span class="kobospan" id="kobo.421.3">On the other hand, G1 may be selected when there are more than two processors and a sufficient amount of memory (1792 MB or </span><span><span class="kobospan" id="kobo.422.1">more) available.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.423.1">Furthermore, ergonomics adjusts the default maximum heap size based on the available memory. </span><span class="kobospan" id="kobo.423.2">The default maximum heap size can be set to 50%, 25%, or 1/64 of the available memory, providing flexibility to accommodate different application requirements and system constraints. </span><span class="kobospan" id="kobo.423.3">In essence, ergonomics acts as an intelligent conductor, dynamically tailoring the JVM’s configuration to orchestrate a performance symphony that aligns with the unique characteristics of each </span><span><span class="kobospan" id="kobo.424.1">runtime environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.425.1">The recommendation to </span><em class="italic"><span class="kobospan" id="kobo.426.1">always set the configuration of GC and avoid the ergonomic</span></em><span class="kobospan" id="kobo.427.1"> stems from the idea that manually configuring GC parameters gives developers more control and predictability over the JVM’s behavior. </span><span class="kobospan" id="kobo.427.2">While ergonomic settings are designed to adjust the JVM configuration based on heuristics and runtime characteristics, this automated approach may not always produce the most optimized performance for specific </span><span><span class="kobospan" id="kobo.428.1">use cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.429.1">When developers manually configure the GC, they can tailor the JVM settings according to the application’s unique requirements, workload characteristics, and the underlying infrastructure. </span><span class="kobospan" id="kobo.429.2">This manual tuning allows more fine-grained control over parameters such as heap size, thread counts, and garbage </span><span><span class="kobospan" id="kobo.430.1">collection algorithms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.431.1">Avoiding ergonomic settings becomes especially relevant when applications have specific performance goals, stringent latency requirements, or when the default configurations generated by the ergonomic tuning may not align with the application’s optimal needs. </span><span class="kobospan" id="kobo.431.2">Manual tuning allows developers to experiment with, analyze, and adjust JVM parameters to achieve the desired </span><span><span class="kobospan" id="kobo.432.1">performance outcomes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.433.1">However, it’s crucial to note that while manual tuning provides greater control, it also requires a deep understanding of the application’s behavior, garbage collection algorithms, and JVM internals. </span><span class="kobospan" id="kobo.433.2">Developers must carefully assess the impact of their configurations and regularly monitor the application’s performance to ensure that the chosen settings align</span><a id="_idIndexMarker444" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.434.1"> with evolving </span><span><span class="kobospan" id="kobo.435.1">application demands.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.436.1">In summary, the</span><a id="_idIndexMarker445" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.437.1"> recommendation to manually set the configuration of the GC and avoid relying solely on ergonomic settings reflects a desire for more precise control over JVM behavior, particularly in scenarios where tailored performance optimization is crucial for the </span><span><span class="kobospan" id="kobo.438.1">application’s success.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">In Bruno Borges’ insightful </span><em class="italic"><span class="kobospan" id="kobo.440.1">Secrets of Performance Tuning Java on Kubernetes</span></em><span class="kobospan" id="kobo.441.1"> presentation, he shared invaluable recommendations for optimizing Java applications running on Kubernetes. </span><span class="kobospan" id="kobo.441.2">Borges discussed the performance implications associated with different garbage collection algorithms, namely Serial, Parallel, G1, and Z, considering key factors such as the number of cores, multithreaded environments, Java heap size, pause times, overhead, and tail-latency effects. </span><span class="kobospan" id="kobo.441.3">Each garbage collection strategy was dissected in the context of its suitability for specific scenarios. </span><span class="kobospan" id="kobo.441.4">Whether an application benefits from the simplicity of Serial, the parallel processing of Parallel, the adaptability of G1, or the low-latency focus of Z, Borges provided nuanced insights into choosing the most effective garbage collection approach. </span><span class="kobospan" id="kobo.441.5">The recommendations presented by Borges offer a comprehensive guide for Java developers navigating the complexities of performance tuning in Kubernetes environments, shedding light on the intricate dance between application demands and garbage </span><span><span class="kobospan" id="kobo.442.1">collection strategies:</span></span></p>
<table class="no-table-style" id="table005">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2"/>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.443.1">Serial</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.444.1">Parallel</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.445.1">G1</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.446.1">Z</span></strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.447.1">Number </span><span><span class="kobospan" id="kobo.448.1">of cores</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.449.1">1</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.450.1">+2</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.451.1">+2</span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.452.1">+2</span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.453.1">Multithreaded</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.454.1">No</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.455.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.456.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.457.1">Yes</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.458.1">Java </span><span><span class="kobospan" id="kobo.459.1">heap size</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.460.1">&gt; </span><span><span class="kobospan" id="kobo.461.1">4 GB</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.462.1">&lt; </span><span><span class="kobospan" id="kobo.463.1">4 GB</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.464.1">&gt; </span><span><span class="kobospan" id="kobo.465.1">4 GB</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.466.1">&gt; </span><span><span class="kobospan" id="kobo.467.1">4 GB</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.468.1">Pause</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.469.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.470.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.471.1">Yes</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.472.1">Yes (&gt; </span><span><span class="kobospan" id="kobo.473.1">1 ms)</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.474.1">Overhead</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.475.1">Minimal</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.476.1">Minimal</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.477.1">Moderate</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.478.1">Moderate</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.479.1">Tail-latency </span><span><span class="kobospan" id="kobo.480.1">effect</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.481.1">High</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.482.1">High</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.483.1">High</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.484.1">Low</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.485.1">Best for</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.486.1">Single-core </span><span><span class="kobospan" id="kobo.487.1">small heaps</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.488.1">Multi-core small heaps. </span><span class="kobospan" id="kobo.488.2">Batch jobs, with any </span><span><span class="kobospan" id="kobo.489.1">heap size.</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.490.1">Responsive in medium-to-large </span><span><span class="kobospan" id="kobo.491.1">heaps (request-</span></span><span class="kobospan" id="kobo.492.1"> response/DB </span><span><span class="kobospan" id="kobo.493.1">interactions)</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.494.1">Responsive in medium-to-large </span><span><span class="kobospan" id="kobo.495.1">heaps (request-</span></span> <span><span class="kobospan" id="kobo.496.1">response</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.497.1">Table 6.5: Comparing all GCs’ aspects</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.498.1">In our exploration of JVM tuning, we’ve delved into the realms of ergonomics, profiling, and the delicate balance between automated adaptation and manual precision. </span><span class="kobospan" id="kobo.498.2">Ergonomics </span><a id="_idIndexMarker446" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.499.1">dynamically tunes the JVM configuration for varying workloads, yet the recommendation</span><a id="_idIndexMarker447" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.500.1"> emerges to configure the GC for greater control manually. </span><span class="kobospan" id="kobo.500.2">A distilled summary awaits as we approach the conclusion, crystallizing the wisdom gained in navigating JVM </span><span><span class="kobospan" id="kobo.501.1">tuning intricacies</span><a id="_idTextAnchor117" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.502.1">.</span></span></p>
<h1 id="_idParaDest-87" class="calibre6"><a id="_idTextAnchor118" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.503.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">As we draw the curtain on our exploration into the intricate GC world, we’ve navigated diverse strategies, nuances, and configurations that shape the memory management landscape within the JVM. </span><span class="kobospan" id="kobo.504.2">From the adaptive finesse of ergonomics to the precision of Serial, Parallel, G1, and ZGC GCs, our journey has been a symphony of choices, each tuned to orchestrate optimal performance based on distinct </span><span><span class="kobospan" id="kobo.505.1">application needs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.506.1">However, our expedition through JVM internals doesn’t pause here. </span><span class="kobospan" id="kobo.506.2">The next chapter awaits, inviting us into the avant-garde realm of GraalVM. </span><span class="kobospan" id="kobo.506.3">Beyond the confines of traditional Java, GraalVM emerges as a revolutionary platform, blurring the boundaries between languages and unleashing new possibilities for performance, polyglot capabilities, and efficient execution. </span><span class="kobospan" id="kobo.506.4">Join us in the forthcoming chapters as we delve into the paradigm-shifting landscape of GraalVM, where the symphony of languages converges in harmony, marking a dynamic evolution in the ever-evolving tapestry of </span><span><span class="kobospan" id="kobo.507.1">JVM technologies</span><a id="_idTextAnchor119" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.508.1">.</span></span></p>
<h1 id="_idParaDest-88" class="calibre6"><a id="_idTextAnchor120" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.509.1">Questions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.510.1">Answer the following questions to test your knowledge of </span><span><span class="kobospan" id="kobo.511.1">this chapter:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.512.1">What is the primary goal of ergonomics in </span><span><span class="kobospan" id="kobo.513.1">JVM tuning?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.514.1">Minimizing code </span><span><span class="kobospan" id="kobo.515.1">compilation time</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.516.1">Automatically adjusting JVM configuration based on </span><span><span class="kobospan" id="kobo.517.1">runtime characteristics</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.518.1">Maximizing heap size for </span><span><span class="kobospan" id="kobo.519.1">all applications</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.520.1">Disabling garbage collection for </span><span><span class="kobospan" id="kobo.521.1">enhanced performance</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.522.1">Which GC is often chosen by ergonomics as the default for single-processor systems or when memory </span><span><span class="kobospan" id="kobo.523.1">is limited?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.524.1">Serial GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.525.1">Parallel GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.526.1">G1 GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.527.1">ZGC</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.528.1">In the context of garbage collection, what does “multi-mapping” </span><span><span class="kobospan" id="kobo.529.1">refer to?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.530.1">Multiple mapping of virtual memory addresses to </span><span><span class="kobospan" id="kobo.531.1">physical memory</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.532.1">The use of multiple garbage collection </span><span><span class="kobospan" id="kobo.533.1">algorithms simultaneously</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.534.1">Multithreading during </span><span><span class="kobospan" id="kobo.535.1">garbage collection</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.536.1">Allocating memory in multiple </span><span><span class="kobospan" id="kobo.537.1">regions simultaneously</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.538.1">Why might developers prefer manual GC configuration </span><span><span class="kobospan" id="kobo.539.1">over ergonomics?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.540.1">Manual tuning is </span><span><span class="kobospan" id="kobo.541.1">more cost-effective</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.542.1">Ergonomics is not compatible with modern </span><span><span class="kobospan" id="kobo.543.1">JVM versions</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.544.1">Developers have better control over </span><span><span class="kobospan" id="kobo.545.1">performance parameters</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.546.1">Manual configuration reduces the need for </span><span><span class="kobospan" id="kobo.547.1">garbage collection</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.548.1">Which GC is known for its focus on low latency and responsiveness, making it suitable for </span><span><span class="kobospan" id="kobo.549.1">real-time systems?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.550.1">Serial GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.551.1">Parallel GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.552.1">G1 GC</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.553.1">ZGC</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-89" class="calibre6"><a id="_idTextAnchor121" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.554.1">Answers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.555.1">Here are the answers to this </span><span><span class="kobospan" id="kobo.556.1">chapter’s questions:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.557.1">B. </span><span class="kobospan" id="kobo.557.2">Automatically adjusting JVM configuration based on </span><span><span class="kobospan" id="kobo.558.1">runtime characteristics</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.559.1">A. </span><span><span class="kobospan" id="kobo.560.1">Serial GC</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.561.1">A. </span><span class="kobospan" id="kobo.561.2">Multiple mapping of virtual memory addresses to </span><span><span class="kobospan" id="kobo.562.1">physical memory</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.563.1">C. </span><span class="kobospan" id="kobo.563.2">Developers have better control over </span><span><span class="kobospan" id="kobo.564.1">performance parameters</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.565.1">D. </span><span class="kobospan" id="kobo.565.2">ZGC</span></span></li>
</ol>
</div>
</body></html>