<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>So far, most of the topics covered in this book haven't dealt with the topic of security. This is an often overlooked topic that in some real-world projects only gets interest when it's already too late.</p>
<p>Developers as well as project managers see security as a necessary evil rather than as something providing big benefits to the business. Still, it's a topic that stakeholders must be made aware of.</p>
<p>Quite a few requirements have changed in the age of the cloud and distributed applications. This chapter will look into the situation of the past, as well as today's requirements. It will cover how security is realized using modern Java EE:</p>
<ul>
<li>Security lessons learned from the past</li>
<li>Enterprise security principles</li>
<li>Modern security solutions</li>
<li>How to realize security using modern Java EE</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lessons learned from the past</h1>
                </header>
            
            <article>
                
<p>In today's world IT security is quite an important aspect. Most people have realized that information technology can cause a lot of harm if misused.</p>
<p>The last half-century of computing contained a lot to learn from, in terms of security, and not only for enterprise software.</p>
<p>Let's look into a few lessons learned from the past of enterprise application development. In previous years, the biggest security issues were encryption and approaches on how to manage credentials.</p>
<p>Encrypting and signing data is an incredibly safe way of keeping secrets, if applied correctly. It solely depends on the used algorithms and the key lengths.</p>
<p>There were quite a few encryption and hashing algorithms that turned out to not be secure enough. <strong>DES</strong> is an example, as well as the often-used <strong>MD5</strong> hashing algorithm. As of writing this book, <strong>AES</strong> with 192- or 256-bit key lengths is considered secure. For the hashing algorithm, <strong>SHA-2</strong> or <strong>-3</strong> with at least 256 bits is advised.</p>
<p>User credentials that are stored as part of the application must not be stored in plain text. There have been too many security breaches in the past that especially targeted databases where the passwords resided. Also, simply hashing passwords without providing proper password<span> </span>salts<span> </span>is discouraged.</p>
<p>In general, it's highly advisable for enterprise developers not to implement security functionality themselves if they can avoid it. The idea of companies was to create their own security implementations that weren't used anywhere else and, therefore, provide<span> </span><em>security by obscurity</em>. This, however, turns out to have had the opposite effect, and, unless security experts are involved, in fact leads to, less secure solutions.</p>
<p>The vast majority of enterprise security demands don't require their own, custom implementations. Enterprise frameworks and the implementations thereof already ship with corresponding functionality that has been well-tested in numerous use cases. We will have a look at these APIs for Java Enterprise later in this chapter.</p>
<p>If the application requires the custom use of encryption, then implementations provided by runtime or third-party dependencies must be used. The Java platform offers the<span> </span><strong>Java Cryptography Extension</strong><span> </span>(<strong>JCE</strong>) for this reason. It provides implementations for modern encryption and hashing algorithms.</p>
<p>In general, applications should only process and store secure information when it's absolutely required by the business use case. In particular, for authentication and authorization, there are ways that avoid storing user credentials in multiple systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security in a modern world</h1>
                </header>
            
            <article>
                
<p>More distribution of applications leads to higher demand in securing communication. The integrity of exchanged information needs to be ensured. Similarly, people are aware of the necessity of encryption, especially when it comes to encrypting communication.</p>
<p>What possibilities do engineers have in today's enterprise world? What principles should they follow when realizing security?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security principles</h1>
                </header>
            
            <article>
                
<p>There are some basic principles that should be followed when implementing security in enterprise applications. The following list aims to give the basic ideas, and is not intended to be exhaustive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encrypt communication</h1>
                </header>
            
            <article>
                
<p>First of all, it's important to mention that external communication that happens over the internet must be encrypted. The usual way of doing this is via TLS using trusted certificates. This is possible for HTTP as well as for other communication protocols.</p>
<p>The authenticity of the certificates used must be verified at runtime by the implementation. They have to be assured by a trusted internal or external certificate authority.</p>
<p>Insecurely accepting any certificates in the application should be avoided, for production as well as other environments. This implies that properly signed certificates are being provided and used for the communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delegate security concerns</h1>
                </header>
            
            <article>
                
<p>In terms of storing user information, today's approach is to delegate authentication and authorization to security providers if possible. This means that an enterprise application doesn't store security information, but asks a third-party, a trusted security provider.</p>
<p>This is especially interesting in distributed environments, where multiple applications offer potential endpoints to the outside world. The secure information moves to a single point of responsibility.</p>
<p>Security concerns are usually not a part of the core business logic. The application will ask the trusted security provider system to validate the security of user requests. The security provider acts as a secure single point of responsibility.</p>
<p>There are decentralized security protocols, such as<span> </span><strong>OAuth</strong><span> </span>or<span> </span><strong>OpenID</strong>, that implement this approach.</p>
<p>Delegating the responsibility to a trusted security provider eliminates the need to share passwords within enterprise systems. Users identify directly against security providers. Applications that require security information about a user will be provided session tokens that do not directly contain confidential data.</p>
<p>This principle, however, mainly targets communication that includes application users as persons.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Treat user credentials properly</h1>
                </header>
            
            <article>
                
<p>If for some reason the application manages user authentication itself, it should never permanently store passwords and tokens in plain text. This introduces a severe security risk. Even if an application or database has sufficient protection from the outside world, it's important to protect the credentials from internal leaks.</p>
<p class="mce-root">Passwords that need to be managed within the application must be stored only via appropriate hashing algorithms and approaches such as <strong>salting</strong>. Doing so prevents any malicious attack, from both the inside as well the outside of the coorporation. It's advisable to consult security information organizations such as <strong>Open Web Application Security Project</strong> (<strong>OWASP</strong>). They provide the modern advice for security approaches and algorithms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoid storing credentials in version control</h1>
                </header>
            
            <article>
                
<p>For the same reason that you should not treat secure credentials poorly, developers shouldn't store clear credentials in the version-controlled project repository. Even if the repository is hosted company-internally, this introduces a security risk.</p>
<p>The credentials will be visible permanently in the repository's history.</p>
<p>As shown in<span> </span><a href="a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml">Chapter 5</a>,<span> </span><em>Container and Cloud Environments with Java EE</em>, there are features of cloud environments that inject secret configuration values into applications. This functionality can be used to provide secret credentials that are configured externally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Include tests</h1>
                </header>
            
            <article>
                
<p>The security mechanisms that are a responsibility of the application need to be system-tested properly. Any included authentication and authorization must be verified as part of the Continuous Delivery pipeline. This means that you should verify the functionality in automated tests, to not only verify it once, but continuously, after changes in the software.</p>
<p>It's especially important for security-relevant tests to include negative tests. For example, the test must verify that incorrect credentials or insufficient permissions do not allow you to perform specific application functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Possibilities and solutions</h1>
                </header>
            
            <article>
                
<p>After a few basic but important security principles, let's have a look at the possible security protocols and solutions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Encrypted communication</h1>
                </header>
            
            <article>
                
<p>Encrypted communication usually means that the communications are encrypted using <strong>TLS encryption</strong>, as part of the communication protocol in the transport layer. Certificates are used to encrypt and sign the communication. Of course, it's crucial to be able to rely on the certificates.</p>
<p>Companies often operate their own certificate authorities and pre-install their<span> </span><strong>root CA</strong><span> </span>in their computers and software. This certainly makes sense for internal networks. It reduces overhead and potential costs compared to requesting certificates for all internal services from an official authority.</p>
<p>Certificates that are<span> </span><em>publicly trusted</em><span> </span>are required to be signed by one of the official certificate authorities that come pre-installed with operating systems or platforms.</p>
<p>Encrypted communication does not authenticate users, unless individual client certificates are being used. It lays the foundation for a secure, trusted communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protocol-based authentication</h1>
                </header>
            
            <article>
                
<p>Some communication protocols come with authentication capabilities, such as HTTP with basic or digest authentication. These functionalities are part of the communication protocol and are usually well-supported in tools and frameworks.</p>
<p>They usually rely on the communication being already securely encrypted, otherwise this would make the information accessible for parties that can read it, should they intercept the communication. This is important to mention to application developers to ensure that protocol-based authentication is provided via encrypted communication.</p>
<p>The credentials for protocol-based security are usually provided directly in every message. This simplifies client calls as there is no need for several authentication steps, such as in exchanging tokens. The first client invocation can already exchange information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decentralized security</h1>
                </header>
            
            <article>
                
<p>Other approaches that do not directly include credentials in the client invocations will fetch security tokens first and issue the actual communication with the token being provided afterwards. This goes in the direction of decentralized security.</p>
<p>In order to decouple security from the application, enterprise systems can include identity providers as a central point for authentication or authorization, respectively. This delegates the security concerns from the application to a provider.</p>
<p>The identity providers authorize third parties, such as enterprise applications, without directly exchanging the credentials with them. The end users are redirected to the identity providers and don't hand the secure information to the enterprise application. Third-parties only receive the information when the access has been permitted, contained in tokens that they can verify.</p>
<p>This three-way authentication avoids concerning the enterprise application with security responsibilities. The responsibility to verify whether the information that the user provides was correct moves to the identity provider.</p>
<p>One example of this method is<span> </span><strong>single sign on</strong><span> </span>(<strong>SSO</strong>) mechanisms. They're used quite often in bigger companies to require users to authenticate only once and reuse the information in all services that are secured by an SSO. The SSO system authenticates the user and provides the required user information to the corresponding applications. Users just need to log in once.</p>
<p>Another approach is to use decentralized access delegation protocols, such as OAuth, OpenID, and OpenID Connect. They represent three-way security workflows to exchange security information between clients, third-party applications, and the identity provider. The idea is similar to single sign on mechanisms. However, these protocols enable users to decide which individual application will receive the user's information. The applications receive user access tokens, for example, in the form of<span> </span><strong>JSON Web Tokens</strong>, that are validated via the identity provider, instead of the actual credentials.</p>
<p>The decentralized access delegation protocols and their implementation are beyond the scope of this book. The responsibility for enterprise systems is to intercept and redirect the user authentication to the identity provider. Depending on the system architecture, this is the responsibility of a proxy server or the application itself.</p>
<p>There are open source solutions out there that implement decentralized security. An interesting technology is<span> </span><strong>Keycloak</strong><span> </span>which is an Identity and Access Management solution. It ships with various client adapters and supports standard protocols, such as OAuth or OpenID Connect, what makes it easy to secure applications and services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Proxies</h1>
                </header>
            
            <article>
                
<p>Proxy servers that encapsulate communication with enterprise applications can add security aspects, such as encrypting the communication. Web proxy servers, for example, support TLS encryption over HTTPS.</p>
<p>The question is whether engineers want to make a difference between network, internal and external communication. Communication in an intranet network is often unencrypted. Depending on the nature of the exchanged information, internet communication should, in most cases, be encrypted.</p>
<p>Proxy servers can be used to terminate the encryption at the network boundaries, so-called<span> </span><strong>TLS termination</strong>. The proxy server encrypts all outgoing information and decrypts all incoming information, respectively.</p>
<p>It's equally possible to re-encrypt the communication using different certificates for different networks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integration in modern environments</h1>
                </header>
            
            <article>
                
<p>Modern environments aim to support today's security needs. Container orchestration frameworks offer the provisioning of software proxy servers and gateways that expose the service; for example, Kubernetes<span> </span>ingress<span> </span>resources, as well as OpenShift<span> </span>routes<span> </span>support TLS encryption for cluster-external traffic.</p>
<p>In order to provide secret values such as credentials or private keys, orchestration frameworks offer the functionality of<span> </span>secrets. As seen previously, this enables us to separately provide secret configurations into the environment.<span> </span><a href="a24f88d4-1af2-4746-91c9-9717d077dd27.xhtml">Chapter 5</a>,<span> </span><em>Container and Cloud Environments with Java EE</em> examined how this is realized.</p>
<p>This enables applications, as well as the configuration in general, to use secret values. The secrets can be injected into the container runtimes, if needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing security in Java EE applications</h1>
                </header>
            
            <article>
                
<p>After seeing the most common security approaches of today's world, let's have a look into how security is implemented using Java EE.</p>
<p>Of all the Java versions, Java EE version 8 aimed to address security aspects. It contains a security API that simplifies and unifies the integration for developers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Transparent security</h1>
                </header>
            
            <article>
                
<p>In the simplest way, security in web applications can be implemented by proxy web servers, such as<span> </span><strong>Apache</strong><span> </span>or<span> </span><strong>nginx</strong>. In that case, the security responsibilities are transparent to the application.</p>
<p>This is often the case if the enterprise application doesn't have to deal with users as domain entities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Servlets</h1>
                </header>
            
            <article>
                
<p>In order to secure web services offered by the Java EE application, usually security on the servlet layer is used. This is the case for all technology that is built on top of servlets such as JAX-RS. Security features are configured using the servlet deployment descriptor, that is, the<span> </span><kbd>web.xml</kbd><em> </em>file.</p>
<p>This can happen in several ways such as form-based authentication, HTTP basic access authentication, or client certificates.</p>
<p>Similarly, security solutions such as Keycloak ship their own implementations of adapters and servlet filters. Developers usually just need to configure these components to use the security provider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java principals and roles</h1>
                </header>
            
            <article>
                
<p>Java security principals and roles represent identities and authorization roles, respectively. Principals and roles are usually configured in the application server in vendor-specific ways. Authenticated requests are bound to a principal during the execution.</p>
<p>One example of using the associated roles within the execution workflow is by using common security annotations such as<span> </span><kbd>@RolesAllowed</kbd>. This declarative approach checks whether the principal is authorized correctly and will otherwise result in a security exception:</p>
<pre>import javax.annotation.security.RolesAllowed;<br/><br/>@Stateless
public class CarManufacturer {

    ...

    <strong>@RolesAllowed("worker")</strong>
    public Car manufactureCar(Specification spec) {
        ...
    }

    <strong>@RolesAllowed("factory-admin")</strong>
    public void reconfigureMachine(...) {
        ...
    }</pre>
<p>Besides vendor-specific solutions, users and roles can be extended to contain domain-specific information. The<span> </span><kbd>Principal</kbd><span> </span>security type is enhanced in order to do so.</p>
<p>It is possible to inject the principal that is identified by its name and to provide a specialization. The container takes care of the user identification, for example, by using form-based authentication.</p>
<p>This approach was especially advised prior to Java EE version 8. However, modern applications will likely use identity stores to represent domain-specific user information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JASPIC</h1>
                </header>
            
            <article>
                
<p>The<span> </span><strong>Java Authentication Service Provider Interface for Containers</strong><span> </span>(<strong>JASPIC</strong>) is a standard that defines authentication service providers' interfaces. It comprises so-called <strong>Server Authentication Modules</strong> (<strong>SAM</strong>), pluggable authentication components, which are added to the application server.</p>
<p class="mce-root">This standard offers powerful and flexible ways how to implement authentication. Server vendors can ship their own implementation of SAMs. However, implementing authentication modules using the JASPIC standard is seen as quite cumbersome by a lot of developers. This is why the JASPIC standard is not widely used in enterprise projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security API</h1>
                </header>
            
            <article>
                
<p>The Security API 1.0 is shipped with Java EE 8. The idea for this standard was to provide modern security approaches that are simpler to use for developers. These are implemented in vendor-independent ways, without the need to lock in to specific solutions.</p>
<p>Let's have a look into what the Security API includes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Authentication mechanisms</h1>
                </header>
            
            <article>
                
<p>First of all, the Security API includes<span> </span><kbd>HttpAuthenticationMechanism</kbd>, which provides the features of the JASPIC standard with much less development effort needed. It's specified to be used in a servlet context.</p>
<p>Application developers are only required to define a custom<span> </span><kbd>HttpAuthenticationModule</kbd><span> </span>and to configure the authentication in the<span> </span><kbd>web.xml</kbd><span> </span>deployment descriptor. We will have a look at a custom security implementation later in this chapter.</p>
<p>The Java EE container already ships with predefined HTTP authentication mechanisms for basic, default, and custom form authentication. The developers can use this predefined functionality with minimal effort. Before we see an example, let's see how to store the user information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Identity stores</h1>
                </header>
            
            <article>
                
<p>The concept of identity stores was also added with the Security API. Identity stores provide the authentication and authorization information of users in lightweight, portable ways. They offer a unified way to access this information.</p>
<p>The<span> </span><kbd>IdentityStore</kbd><span> </span>type validates a caller's credentials and accesses its information. Similarly to HTTP authentication mechanisms, the application containers are required to provide identity stores for LDAP and database access.</p>
<p>The following shows an example using the container-provided security functionality:</p>
<pre>import javax.security.enterprise.authentication.mechanism.http.*;<br/>import javax.security.enterprise.identitystore.DatabaseIdentityStoreDefinition;<br/>import javax.security.enterprise.identitystore.IdentityStore;<br/><br/><strong>@BasicAuthenticationMechanismDefinition(</strong>realmName = "car-realm"<strong>)</strong><br/><strong>@DatabaseIdentityStoreDefinition(</strong><br/>        dataSourceLookup = "java:comp/UserDS",<br/>        callerQuery = "select password from users where name = ?",<br/>        useFor = IdentityStore.ValidationType.VALIDATE<br/><strong>)</strong>
public class SecurityConfig {
    // nothing to configure
}</pre>
<p>Application developers only need to provide this annotated class. This approach provides simple and straightforward security definitions for test purposes.</p>
<p>Usual enterprise projects arguably require more custom approaches. Organizations usually have custom ways of authentication and authorization that need to be integrated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom security</h1>
                </header>
            
            <article>
                
<p>The following shows a more sophisticated example.</p>
<p>In order to provide custom authentication, application developers implement a custom<span> </span><kbd>HttpAuthenticationMechanism</kbd>, especially the<span> </span><kbd>validateRequest()</kbd><span> </span>method. The class only has to be visible to the container as a CDI bean. The rest is done by the application container. This simplifies the security integration for developers.</p>
<p>The following shows a basic example, with<span> </span><em>pseudo code</em><span> </span>representing the actual authentication:</p>
<pre>import javax.security.enterprise.AuthenticationException;<br/>import javax.security.enterprise.authentication.mechanism.http.*;<br/>import javax.security.enterprise.credential.UsernamePasswordCredential;<br/>import javax.security.enterprise.identitystore.CredentialValidationResult;<br/>import javax.security.enterprise.identitystore.IdentityStoreHandler;<br/><br/>@ApplicationScoped
public class TestAuthenticationMechanism <strong>implements
        HttpAuthenticationMechanism</strong> {

    <strong>@Inject
    IdentityStoreHandler identityStoreHandler;</strong>

    @Override
    public <strong>AuthenticationStatus validateRequest(HttpServletRequest request,
            HttpServletResponse response,
            HttpMessageContext httpMessageContext)</strong>
            throws AuthenticationException {

        // get the authentication information
        String name = request.get...
        String password = request.get...

        if (name != null &amp;&amp; password != null) {

            <strong>CredentialValidationResult result = identityStoreHandler
                    .validate(new UsernamePasswordCredential(name,
                    password));</strong>

            <strong>return httpMessageContext.notifyContainerAboutLogin(result);</strong>
        }

        <strong>return httpMessageContext.doNothing();</strong>
    }
}</pre>
<p>The<span> </span><kbd>validateRequest()</kbd><span> </span>implementation accesses the user information contained in the HTTP request, for example via the HTTP headers. It delegates the validation to the identity store using the<span> </span><kbd>IdentityStoreHandler</kbd>. The validation result contains the result that is provided to the security HTTP message context.</p>
<p>Depending on the requirements, a custom identity handler implementation is required as well. It can provide custom authentication and authorization methods.</p>
<p>If decentralized security protocols, such as OAuth, are being used, a custom identity handler will implement the security access token validation.</p>
<p>The following shows a custom identity store:</p>
<pre>import javax.security.enterprise.identitystore.IdentityStore;<br/><br/>@ApplicationScoped
public class TestIdentityStore <strong>implements IdentityStore</strong> {

    public <strong>CredentialValidationResult validate(UsernamePasswordCredential
            usernamePasswordCredential)</strong> {

        // custom authentication or authorization
        // if valid

        return <strong>new CredentialValidationResult(username, roles)</strong>;

        // or in case of invalid credentials

        return <strong>CredentialValidationResult.INVALID_RESULT</strong>;
    }
}</pre>
<p>The<span> </span><kbd>web.xml</kbd><span> </span>servlet deployment descriptor is used to specify the secure resources. The application container takes care of the integration:</p>
<pre>&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Protected pages&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/management&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin-role&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;</pre>
<p>An HTTP authentication mechanism provides a straightforward, yet flexible, way to implement JASPIC security. Its implementation is simpler compared to a plain JASPIC approach.</p>
<p>It provides the possibility of intercepting communication flows and can integrate the application with third-party security providers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing security information</h1>
                </header>
            
            <article>
                
<p>Enterprise applications sometimes need the functionality to access information about the user authorization as part of the business logic. The Security API enables us to retrieve this information in a uniform way.</p>
<p>It contains the<span> </span><kbd>SecurityContext</kbd><span> </span>type that provides a programmatic way to retrieve information about the caller principal and its roles. The<span> </span><kbd>SecurityContext</kbd><span> </span>is injectable into any managed beans. It also integrates with the servlet authentication configuration and provides information about whether the caller is allowed to access a specific HTTP resource.</p>
<p>The following shows an example usage of the<span> </span><kbd>SecurityContext</kbd>:</p>
<pre>import javax.security.enterprise.SecurityContext;<br/><br/>@Stateless
public class CompanyProcesses {

    <strong>@Inject
    SecurityContext securityContext;</strong>

    public void executeProcess() {
        executeUserProcess();
        if (<strong>securityContext.isCallerInRole("admin")</strong>) {
            <strong>String name = securityContext.getCallerPrincipal().getName();</strong>
            executeAdminProcess(name);
        }
    }

    ...
}</pre>
<p>The idea of the Security API is that it integrates with the existing functionality from previous Java EE versions. This implies, for example, that the<span> </span><kbd>@RolesAllowed</kbd><span> </span>annotation uses the same role information as the<span> </span><kbd>SecurityContext</kbd>. Developers can continue to rely on the existing standard functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In today's world, IT security is quite an important aspect. In the past, some of the biggest security issues were weak encryption and hashing algorithms, how passwords are persisted, and home-grown security implementations. A few important security principles include encrypting the communication, using external, trusted security providers for authentication and authorization, avoiding keeping credentials under version control, and including test scenarios that verify protection.</p>
<p>Communication is usually encrypted in the transport layer using TLS. Used certificates should be signed correctly, either by a company-internal or official certificate authority. Other approaches includes using security features of the protocol layer, such as HTTP basic authentication on top of encrypted communication.</p>
<p>Decentralized security decouples authentication and authorization responsibilities from the applications by including trusted identity providers. Single sign on as well as decentralized access delegations protocols are examples for this.</p>
<p>Security in Java EE application boundaries is usually realized on top of Servlets. The Security API which was introduced in Java EE 8 aims to provide simpler, uniform approaches on how to tackle security in Java EE applications. HTTP authentication mechanisms are an example that provide easier usage of the powerful JASPIC functionality. Identity stores provide authentication and authorization information of users.</p>
<p>The idea of the Security API is to integrate with existing functionality and offer uniform access mechanisms. The included features should be sufficient to secure enterprise application on the HTTP side.</p>


            </article>

            
        </section>
    </body></html>