- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Web Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications today have some kind of web interface – either a UI that we
    can interact with via a web browser or an HTTP API that other systems can call
    to interact with our application.
  prefs: []
  type: TYPE_NORMAL
- en: In our target architecture, all communication with the outside world goes through
    adapters. So, let’s discuss how we can implement an adapter that provides such
    a web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 6**.1* gives a zoomed-in view of the architecture elements that are
    relevant to our discussion of a web adapter – the adapter itself and the ports
    through which it interacts with our application core:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – An incoming adapter talks to the application layer through dedicated
    incoming ports, which are interfaces implemented by the domain services](img/Figure_06.1_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – An incoming adapter talks to the application layer through dedicated
    incoming ports, which are interfaces implemented by the domain services
  prefs: []
  type: TYPE_NORMAL
- en: The web adapter is a “driving” or “incoming” adapter. It takes requests from
    the outside and translates them into calls to our application core, telling it
    what to do. The control flow goes from the controllers in the web adapter to the
    services in the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer provides specific ports through which the web adapter
    may communicate. Each port is what I have called a “use case” in the previous
    chapter, and it is implemented by a domain service in the application layer.
  prefs: []
  type: TYPE_NORMAL
- en: If we look closer, we notice that this is the Dependency Inversion Principle
    in action. Since the control flow goes from left to right, we could just as well
    let the web adapter call the use cases directly, as shown in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – We can remove the port interfaces and call the services directly](img/Figure_06.2_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – We can remove the port interfaces and call the services directly
  prefs: []
  type: TYPE_NORMAL
- en: So why do we add another layer of indirection between the adapter and the use
    cases? The reason is that the ports are a specification of the places where the
    outside world can interact with our application core. By having ports in place,
    we know exactly which communication with the outside world takes place, which
    is valuable information for any maintenance engineer working on your legacy code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the ports that drive the application also lets us build a test driver
    for the application. This test driver is an adapter that calls the input ports
    to simulate and test certain usage scenarios – more about testing in [*Chapter
    8*](B19916_08.xhtml#_idTextAnchor071), *Testing* *Architecture Elements*.
  prefs: []
  type: TYPE_NORMAL
- en: Having talked about the importance of input ports, one of the shortcuts we’ll
    talk about in [*Chapter 11*](B19916_11.xhtml#_idTextAnchor096), *Taking Shortcuts
    Consciously*, is just leaving the incoming ports out and calling the application
    services directly.
  prefs: []
  type: TYPE_NORMAL
- en: One question remains, though, which is relevant for highly interactive applications.
    Imagine a server application that sends real-time data to the user’s browser via
    WebSocket. How does the application core send this real-time data to the web adapter,
    which in turn sends it to the user’s browser?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scenario, we definitely need a port because, without a port, the application
    would have to depend on an adapter implementation, breaking our efforts to keep
    the application free from dependencies on the outside. This port must be implemented
    by the web adapter and called by the application core, as depicted in *Figure
    6**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – If an application must actively notify a web adapter, we need
    to go through an outgoing port to keep the dependencies in the right direction](img/Figure_06.3_B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – If an application must actively notify a web adapter, we need to
    go through an outgoing port to keep the dependencies in the right direction
  prefs: []
  type: TYPE_NORMAL
- en: The `WebSocketController` on the left implements the port interface in the `out`
    package, and services in the application core can call this port to send real-time
    data to the user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, this would be an outgoing port and make the web adapter
    an incoming and outgoing adapter. But there is no reason that the same adapter
    cannot be both at the same time. For the rest of this chapter, we’ll assume that
    the web adapter is an incoming adapter only since this is the most common case.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibilities of a web adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does a web adapter actually do? Let’s say we want to provide a REST API
    for our BuckPal application. Where do the responsibilities of the web adapter
    start and where do they end?
  prefs: []
  type: TYPE_NORMAL
- en: 'A web adapter usually does these things:'
  prefs: []
  type: TYPE_NORMAL
- en: Maps the incoming HTTP request to objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performs authorization checks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validates the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps the request objects to the input model of the use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls the use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps the output of the use case back to HTTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns the HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all, a web adapter must listen to HTTP requests that match certain
    criteria such as a URL path, HTTP method, and content type. The parameters and
    the content of a matching HTTP request must then be deserialized into objects
    we can work with.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, a web adapter then does an authentication and authorization check
    and returns an error if it fails.
  prefs: []
  type: TYPE_NORMAL
- en: The state of the incoming objects can then be validated. But haven’t we already
    discussed input validation as a responsibility of the input model to the use cases?
    Yes, the input model to the use cases should only allow input that is valid in
    the context of the use cases. But here, we’re talking about the input model to
    the web adapter. It might have a completely different structure and semantics
    from the input model to the use cases, so we might have to perform different validations.
  prefs: []
  type: TYPE_NORMAL
- en: I don’t advocate implementing the same validations in the web adapter as we
    have already done in the input model of the use cases. Instead, we should validate
    that we can transform the input model of the web adapter into the input model
    of the use cases. Anything that prevents us from doing this transformation is
    a validation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the next responsibility of a web adapter: to call a certain
    use case with the transformed input model. The adapter then takes the output of
    the use case and serializes it into an HTTP response, which is sent back to the
    caller.'
  prefs: []
  type: TYPE_NORMAL
- en: If anything goes wrong on the way and an exception is thrown, the web adapter
    must translate the error into a message that is sent back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a lot of responsibilities weighing on the shoulders of our web adapter.
    But it’s also a lot of responsibilities that the application layer should not
    be concerned with. Anything that has to do with HTTP must not leak into the application
    layer. If the application core knows that we’re dealing with HTTP on the outside,
    we have lost the option to perform the same domain logic from other incoming adapters
    that do not use HTTP. In a maintainable architecture, we want to keep options
    open.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this boundary between the web adapter and application layer comes
    naturally if we start development with the domain and application layers instead
    of with the web layer. If we implement the use cases first, without thinking about
    any specific incoming adapter, we are not tempted to blur the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most web frameworks – such as Spring MVC in the Java world – we create controller
    classes that perform the responsibilities we have discussed previously. So, do
    we build a single controller that answers all requests directed at our application?
    We don’t have to. A web adapter may certainly consist of more than one class.
  prefs: []
  type: TYPE_NORMAL
- en: We should take care, however, to put these classes into the same package hierarchy
    to mark them as belonging together, as discussed in [*Chapter 4*](B19916_04.xhtml#_idTextAnchor037),
    *Organizing Code*.
  prefs: []
  type: TYPE_NORMAL
- en: So, how many controllers do we build? I say we should rather build too many
    than too few. We should make sure that each controller implements a slice of the
    web adapter that is as narrow as possible and that shares as little as possible
    with other controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the operations on an account entity within our BuckPal application.
    A popular approach is to create a single `AccountController` that accepts requests
    for all operations that relate to accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Spring controller providing a REST API might look like the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Everything concerning the account resource is in a single class, which feels
    good. But let’s discuss the downsides of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: First, less code per class is a good thing. I have worked on a legacy project
    where the largest class had 30,000 lines of code.[1](#footnote-022) That’s no
    fun. Even if the controller only accumulates 200 lines of code over the years,
    it’s still harder to grasp than 50 lines, even when it’s cleanly separated into
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-022-backlink) 30,000 lines of code: it was actually a conscious
    architecture decision (by our predecessors, mind you) that lead to those 30,000
    lines being in a single class: to change the system at runtime, without re-deployment,
    it allowed them to upload compiled Java bytecode in a `.class` file. And it only
    allowed them to upload a single file, so this file had to contain all the code.'
  prefs: []
  type: TYPE_NORMAL
- en: The same argument is valid for test code. If the controller itself has a lot
    of code, there will be a lot of test code. And often, test code is even harder
    to grasp than production code because it tends to be more abstract. We also want
    to make the tests for a certain piece of production code to be easy to find, which
    is easier in small classes.
  prefs: []
  type: TYPE_NORMAL
- en: Equally important, however, is that putting all operations into a single controller
    class encourages the reuse of data structures. In the preceding code example,
    many operations share the `AccountResource` model class. It serves as a bucket
    for everything that is needed in any of the operations. `AccountResource` probably
    has an `id` field. This is not needed in the `create` operation and will probably
    confuse here more than it will help. Imagine that an `Account` has a one-to-many
    relationship with `User` objects. Do we include those `User` objects when creating
    or updating an account? Will the users be returned by the list operation? This
    is an easy example, but in any above-play-size project, we’ll ask these questions
    at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I advocate the approach to create a separate controller, potentially in
    a separate package, for each operation. Also, we should name the methods and classes
    as close to our use cases as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can take primitives as input, as we did with `sourceAccountId`, `targetAccountId`,
    and `amount` in the example. But each controller can also have its own input model.
    Instead of a generic model such as `AccountResource`, we might then have a model
    specific to the use case such as `CreateAccountResource` or `UpdateAccountResource`.
    Those specialized model classes may even be private to the controller’s package
    to prevent accidental reuse. Controllers may still share models, but using shared
    classes from another package makes us think about it more and perhaps we will
    find out that we don’t need half of the fields and will create our own, after
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we should think hard about the names of the controllers and services.
    Instead of `CreateAccount`, for instance, wouldn’t `RegisterAccount` be a better
    name? In our BuckPal application, the only way to create an account is for a user
    to register it. So, we use the word “register” in class names to better convey
    their meaning. There are certainly cases where the usual suspects (`Create...`,
    `Update...`, and `Delete...`) sufficiently describe a use case, but we might want
    to think twice before actually using them.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of this slicing style is that it makes parallel work on different
    operations a breeze. We won’t have merge conflicts if two developers work on different
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a web adapter to an application, we should keep in mind that we’re
    building an adapter that translates the HTTP protocol to method calls on the use
    cases of our application, translates the results back to HTTP, and does not do
    any domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: The application layer, on the other hand, should not do HTTP, so we should make
    sure not to leak HTTP details. This makes the web adapter replaceable with another
    adapter should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: When slicing web controllers, we should not be afraid to build many small classes
    that don’t share a model. They’re easier to grasp and test, and they support parallel
    work. It’s more work initially to set up such fine-grained controllers, but it
    will pay off during maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at the incoming side of our application, we’ll now take a look
    at the outgoing side and how to implement a persistence adapter.
  prefs: []
  type: TYPE_NORMAL
