- en: '*Chapter 2*: Java Object-Oriented Programming (OOP)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming** (**OOP**) was born out of the necessity for
    better control over the concurrent modification of shared data, which was the
    curse of pre-OOP programming. The core of the idea was not to allow direct access
    to data and instead, do it only through a dedicated layer of code. Since data
    needs to be passed around and modified in the process, the concept of an object
    was conceived. In the most general sense, an *object* is a set of data that can
    be passed around and accessed only through the set of methods passed along too.
    This data is said to compose an **object state**, while the methods constitute
    the **object behavior**. The object state is hidden (**encapsulated**) from direct
    access.'
  prefs: []
  type: TYPE_NORMAL
- en: Each object is constructed based on a certain template called a **class**. In
    other words, a class defines a class of objects. Each object has a certain **interface**,
    a formal definition of the way other objects can interact with it. Originally,
    one object would send a message to another object by calling its method. But this
    terminology did not hold, especially after actual message-based protocols and
    systems were introduced.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid code duplication, a parent-child relationship between objects was introduced
    – one class can inherit behavior from another class. In such a relationship, the
    first class is called a **child class**, or **subclass**, while the second is
    called a **parent**, **base class**, or **superclass**.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of relationship was defined between classes and interfaces – a
    class can *implement* an interface. Since an interface describes how you can interact
    with an object but not how an object responds to the interaction, different objects
    can behave differently while implementing the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a class can have only one direct parent but can implement many interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to behave like any of its ancestors and adhere to multiple interfaces
    is called **polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at these OOP concepts and how they are implemented
    in Java. The topics discussed include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: OOP concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overloading, overriding, and hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final variable, method, and class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record and sealed classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor that you prefer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*, of this book. The files with the code examples for this chapter are
    available in the GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch02_oop` folder.
  prefs: []
  type: TYPE_NORMAL
- en: OOP concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already stated in the introduction, the main OOP concepts are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: This defines the properties and behavior (methods) of objects that
    are created based on this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object**: This defines a state (data) as values of its properties, adds behavior
    (methods) taken from a class, and holds them together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: This propagates behavior down the chain of classes connected
    via parent-child relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: This describes how object data and behavior can be accessed.
    It isolates (abstracts) an object’s appearance from its implementations (behavior).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Encapsulation**: This hides the state and details of the implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: This allows an object to assume an appearance of implemented
    interfaces and behave like any of the ancestor classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object/class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In principle, you can create a very powerful application with minimal usage
    of classes and objects. It became even easier to do this after functional programming
    was added to Java 8, to a JDK, which allowed you to pass around behavior as a
    function. Yet passing data (state) still requires classes/objects. This means
    that the position of Java as an OOP language remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: A class defines the types of all internal object properties that hold the object
    state. A class also defines object behavior expressed by the code of the methods.
    It is possible to have a class/object without a state or behavior. Java also has
    a provision for making the behavior accessible statically – without creating an
    object. But these possibilities are no more than just additions to the object/class
    concept that was introduced for keeping the state and behavior together.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, a `Vehicle` class, for example, defines the properties
    and behavior of a vehicle in principle. Let’s make the model simple and assume
    that a vehicle has only two properties – weight and engine of a certain power.
    It also can have a certain behavior – it can reach a certain speed in a certain
    period of time, depending on the values of its two properties. This behavior can
    be expressed in a method that calculates the speed the vehicle can reach in a
    certain period of time. Every object of the `Vehicle` class will have a specific
    state (the values of its properties) and the speed calculation will result in
    a different speed in the same time period.
  prefs: []
  type: TYPE_NORMAL
- en: All Java code is contained inside methods. A **method** is a group of statements
    that have (optional) input parameters and a return a value (also optional). In
    addition, each method can have side effects – it can display a message or write
    data into the database, for example. Class/object behavior is implemented in the
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: To follow our example, speed calculations can reside in a `double calculateSpeed(float
    seconds)` method, for instance. As you can guess, the name of the method is `calculateSpeed`.
    It accepts a number of seconds (with a fractional part) as a parameter and returns
    the speed value as `double`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have mentioned already, objects can establish a parent-child relationship
    and share properties and behavior this way. For example, we can create a `Car`
    class that inherits properties (weight, for example) and behavior (speed calculation)
    of the `Vehicle` class. In addition, the `child` class can have its own properties
    (the number of passengers, for example) and car-specific behavior (soft shock
    absorption, for example). But if we create a `Truck` class as the vehicle’s child,
    its additional truck-specific property (payload, for example) and behavior (hard
    shock absorption) will be different.
  prefs: []
  type: TYPE_NORMAL
- en: It is said that each object of the `Car` or `Truck` class has a parent object
    of the `Vehicle` class. But objects of the `Car` and `Truck` class do not share
    the specific `Vehicle` object (every time a child object is created, a new parent
    object is created first). They share only the parent’s behavior. That is why all
    child objects can have the same behavior but different states. This is one way
    to achieve code reusability, but it may not be flexible enough when object behavior
    has to change dynamically. In such cases, object composition (bringing behavior
    from other classes) or functional programming is more appropriate (see [*Chapter
    13*](B18388_13_ePub.xhtml#_idTextAnchor281), *Functional Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to make a child behave differently than the inherited behavior
    would do. To achieve it, the method that captures the behavior can be re-implemented
    in the `child` class. It is said that a child can *override* inherited behavior.
    We will explain how to do it shortly (see the *Overloading, overriding, and hiding*
    section). If, for example, the `Car` class has its own method for speed calculation,
    the corresponding method of the `Vehicle` parent class is not inherited, and the
    new speed calculation, implemented in the `child` class, is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of a parent class can be inherited (but not overridden) too. However,
    class properties are typically declared private; they cannot be inherited – that’s
    the point of encapsulation. See the description of various access levels – `public`,
    `protected`, `default`, and `private` – in the *Access modifiers* section of [*Chapter
    3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*.
  prefs: []
  type: TYPE_NORMAL
- en: If the parent class inherits some behavior from another class, the `child` class
    acquires (inherits) this behavior too, unless, of course, the parent class overrides
    it. There is no limit to how long the chain of inheritance can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent-child relationship in Java is expressed using the `extends` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `A`, `B`, `C`, and `D` classes have the following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: The `D` class inherits from the `A`, `B`, and `C` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `C` class inherits from the `A` and `B` classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `B` class inherits from the `A` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All non-private methods of the `A` class are inherited (if not overridden) by
    the `B`, `C`, and `D` classes.
  prefs: []
  type: TYPE_NORMAL
- en: All non-private methods of the `B` class are inherited (if not overridden) by
    the `C` and `D` classes.
  prefs: []
  type: TYPE_NORMAL
- en: All non-private methods of the `C` class are inherited (if not overridden) by
    the `D` class.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction/interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name of a method and the list of its parameter types is called a `Car` or
    `Truck`, in our example) can be accessed. Such a description together with a `return`
    type is presented as an interface. It does not say anything about the code that
    does calculations – only about the method name, the parameters’ types, their position
    in the parameter list, and the result type. All the implementation details are
    hidden (encapsulated) within the class that *implements* this interface.
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned already, a class can implement many different interfaces.
    But two different classes (and their objects) can behave differently even when
    they implement the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to classes, interfaces can have a parent-child relationship using
    the `extends` keyword too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, the `A`, `B`, `C`, and `D` interfaces have the following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: The `D` interface inherits from the `A`, `B`, and `C` interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `C` interface inherits from the `A` and `B` interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `B` interface inherits from the `A` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All non-private methods of the `A` interface are inherited by the `B`, `C`,
    and `D` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: All non-private methods of the `B` interface are inherited by the `C` and `D`
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: All non-private methods of the `C` interface are inherited by the `D` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction/interface also reduces dependency between different sections of
    the code, thus increasing its maintainability. Each class can be changed without
    the need to coordinate it with its clients, as long as the interface stays the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Encapsulation** is often defined either as data hiding or a bundle of publicly
    accessible methods and privately accessible data. In a broad sense, encapsulation
    is controlled access to an object’s properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The snapshot of values of object properties is called an **object state**.
    This is data that is encapsulated. So, encapsulation addresses the main issue
    that motivated the creation of object-oriented programming – better management
    of concurrent access to shared data, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, to read or modify the value of the `prop` property, we cannot
    access it directly because of the `private` access modifier. Instead, we can do
    it only via the `setProp(String value)` and `getProp()`methods.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism is the ability of an object to behave as an object of a different
    class or as an implementation of a different interface. It owes its existence
    to all the concepts that have been mentioned previously – inheritance, interface,
    and encapsulation. Without them, polymorphism would not be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance allows an object to acquire or override the behaviors of all its
    ancestors. An interface hides from the client code the name of the class that
    implemented it. The encapsulation prevents exposing the object state.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will demonstrate all these concepts in action
    and look at the specific usage of polymorphism in the *Polymorphism in action*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Java program is a sequence of statements that express an executable action.
    The statements are organized in methods, and methods are organized in classes.
    One or more classes are stored in `.java` files. They can be compiled (transformed
    from the Java language into a bytecode) by the `javac` Java compiler and stored
    in `.class` files. Each `.class` file contains one compiled class only and can
    be executed by JVM.
  prefs: []
  type: TYPE_NORMAL
- en: A `java` command starts JVM and tells it which class is the `main` one, the
    class that has the method called `main()`. The `main` method has a particular
    declaration – it has to be `public static`, must return `void`, has the name `main`,
    and accepts a single parameter of an array of a `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: JVM loads the main class into memory, finds the `main()` method, and starts
    executing it, statement by statement. The `java` command can also pass parameters
    (arguments) that the `main()` method receives as an array of `String` values.
    If JVM encounters a statement that requires the execution of a method from another
    class, that class (its `.class` file) is loaded into the memory too and the corresponding
    method is executed. So, a Java program flow is all about loading classes and executing
    their methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It represents a very simple application that receives any number of parameters
    and passes them, one by one, into the `display()` method of the `AnotherClass`
    class. As JVM starts, it loads the `MyApp` class from the `MyApp.class` file first.
    Then, it loads the `AnotherClass` class from the `AnotherClass.class` file, creates
    an object of this class using the `new` operator (which we will talk about shortly),
    and calls the `display()` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `AnotherClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `display()` method is used for its side effect only – it
    prints out the passed-in value and returns nothing (`void`). The `AnotherClass`
    class has other two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `process()` method doubles the input integer, stores it in its `result`
    property, and returns the value to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getResult()` method allows you to get the result from the object at any
    time later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two methods are not used in our demo application. We have shown them just
    to show that a class can have properties (`result`, in this case) and many other
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `private` keyword makes the value accessible only from inside the class,
    from its methods. The `public` keyword makes a property or a method accessible
    by any other class.
  prefs: []
  type: TYPE_NORMAL
- en: Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have stated already, Java statements are organized as methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We have seen a few examples already. A method has a name, a set of input parameters
    or no parameters at all, a body inside `{}` brackets, and a return type or `void`
    keyword that indicates that the method does not return any value.
  prefs: []
  type: TYPE_NORMAL
- en: The method name and the list of parameter types together are called the **method
    signature**. The number of input parameters is called an **arity**.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Two methods have the same *signature* if they have the same name, the same arity,
    and the same sequence of types in the list of input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two methods have the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The code inside the methods may be different even if the signature is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two methods have different signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Just a change in the sequence of parameters makes the signature different, even
    if the method name remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Varargs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One particular type of parameter requires a mention because it is quite different
    from all the others. It is declared a type followed by three dots. It is called
    **varargs**, which stands for **variable arguments**. But, first, let’s briefly
    define what an array is in Java.
  prefs: []
  type: TYPE_NORMAL
- en: An **array** is a data structure that holds elements of the same type. The elements
    are referenced by a numerical index. That’s all we need to know, for now. We will
    talk about arrays in more detail in [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141),
    *Data Structures, Generics, and Popular Utilities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example. Let’s declare method parameters using `varargs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `someMethod` method is called, the Java compiler matches the arguments
    from left to right. Once it gets to the last `varargs` parameter, it creates an
    array of the remaining arguments and passes it to the method. Here is a demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `varargs` parameter acts like an array of the specified
    type. It can be listed as the last or the only parameter of a method. That is
    why, sometimes, you can see the `main` method declared, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an object is created, JVM uses a `0` for integral types, `0.0` for floating-point
    types, and `false` for Boolean types. For other Java reference types (see [*Chapter
    3*](B18388_03_ePub.xhtml#_idTextAnchor079), *Java Fundamentals*), the default
    value is `null`, which means that the property of a reference type is not assigned
    any value.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: When there is no constructor declared in a class, it is said that the class
    has a default constructor without parameters provided by the JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, it is possible to declare any number of constructors explicitly,
    each taking a different set of parameters to set the initial state. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If a property is not set by a constructor, the default value of the corresponding
    type is going to be assigned to it automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'When several classes are related along the same line of succession, the parent
    object is created first. If the parent object requires the setting of non-default
    initial values to its properties, its constructor must be called as the first
    line of the child constructor using the `super` keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we added two constructors to `TheChildClass`
    – one that always passes `42` to the constructor of `TheParentClass`, and another
    that accepts two parameters. Note that the `x` property is declared but not initialized
    explicitly. It is going to be set to value `0`, the default value of the `int`
    type, when an object of `TheChildClass` is created. Also, note that the `anotherProp`
    property is initialized explicitly to the value of `"abc"`. Otherwise, it would
    be initialized to the `null` value, the default value of any reference type, including
    `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically, there are three cases when an explicit definition of a constructor
    in the class is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: When neither the object nor any of its parents have properties that need to
    be initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When each property is initialized along with the type declaration (`int x =
    42`, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When default values for the properties’ initialization are good enough
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, it is possible that a constructor is still implemented even when
    all three conditions (mentioned in the list) are met. For example, you may want
    to execute some statements that initialize some external resource – a file or
    another database – that the object will need as soon as it is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as an explicit constructor is added, the default constructor is not
    provided and the following code generates an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the error, either add a constructor without parameters to `TheParentClass`
    or call an explicit constructor of the parent class as the first statement of
    the child’s constructor. The following code does not generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: One important aspect to note is that constructors, although they look like methods,
    are not methods or even members of the class. A constructor doesn’t have a return
    type and always has the same name as the class. Its only purpose is to be called
    when a new instance of the class is created.
  prefs: []
  type: TYPE_NORMAL
- en: The new operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `new` operator creates an object of a class (it also can be said that it
    **instantiates a class** or **creates an instance of a class**) by allocating
    memory for the properties of the new object and returning a reference to that
    memory. This memory reference is assigned to a variable of the same type as the
    class used to create the object or the type of its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an interesting observation. In the code, both the `ref1` and `ref2`
    object references provide access to the methods of `TheChildClass` and `TheParentClass`.
    For example, we can add methods to these classes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can call them using any of the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Note that, to access the child’s methods using the parent’s type reference,
    we had to cast it to the child’s type. Otherwise, the compiler generates an error.
    That is possible because we have assigned the reference to the child’s object
    to the parent’s type reference. That is the power of polymorphism. We will talk
    more about it in the *Polymorphism in action* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naturally, if we had assigned the parent’s object to the variable of the parent’s
    type, we would not be able to access the child’s method even with casting, as
    the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The area where memory for the new object is allocated is called **heap**. The
    JVM has a process called **garbage collection** that watches for the usage of
    this area and releases memory for usage as soon as an object is not needed anymore.
    For example, look at the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the execution of the `someMethod()` method is completed, the object
    of `SomeClass` is not accessible anymore. That’s what the garbage collector notices,
    and it releases the memory occupied by this object. We will talk about the garbage
    collection process in [*Chapter 9*](B18388_09_ePub.xhtml#_idTextAnchor205), *JVM
    Structure and Garbage Collection*.
  prefs: []
  type: TYPE_NORMAL
- en: Class java.lang.Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, all classes are children of the `Object` class by default, even if
    you do not specify it implicitly. The `Object` class is declared in the `java.lang`
    package of the standard JDK library. We will define what a *package* is in the
    *Packages, importing, and access* section and describe libraries in [*Chapter
    7*](B18388_07_ePub.xhtml#_idTextAnchor169), *Java Standard and External Libraries*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look back at the example we provided in the *Inheritance* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'All classes, `A`, `B`, `C`, and `D`, are children of the `Object` class, which
    has 10 methods that every class inherits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public String toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public int hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public boolean equals (Object obj)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public Class getClass()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected Object clone()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notify()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void notifyAll()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public void wait(long timeout, int nanos)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first three, `toString()`, `hashCode()`, and `equals()`, are the most-used
    methods and often re-implemented (overridden). The `toString()` method is typically
    used to print the state of the object. Its default implementation in JDK looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use it on the object of the `TheChildClass` class, the result will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: By the way, there is no need to call `toString()` explicitly while passing an
    object into the `System.out.println()` method and similar output methods because
    they do it inside the method anyway, and `System.out.println(ref1)`, in our case,
    produces the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you can see, such an output is not human-friendly, so it is a good idea
    to override the `toString()` method. The easiest way to do it is by using an IDE.
    For example, in IntelliJ IDEA, right-click inside `TheChildClass` code, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select and click **Generate...**, and then select and click **toString()**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The new pop-up window will enable you to select the properties you wish to
    include in the `toString()` method. Select only the properties of `TheChildClass`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After you click the **OK** button, the following code will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'If there were more properties in the class and you had selected them, more
    properties and their values would be included in the method output. If we print
    the object now, the result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: That is why the `toString()` method is often overridden and even included in
    the services of an IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the `hashCode()` and `equals()` methods in more detail in
    [*Chapter 6*](B18388_06_ePub.xhtml#_idTextAnchor141), *Data Structures, Generics,
    and Popular Utilities*.
  prefs: []
  type: TYPE_NORMAL
- en: The `getClass()` and `clone()` methods are not used as often. The `getClass()`
    method returns an object of the `Class` class that has many methods that provide
    various system information. The most used method is the one that returns the name
    of the class of the current object. The `clone()` method can be used to copy the
    current object. It works just fine as long as all the properties of the current
    object are of primitive types. But, if there is a reference type property, the
    `clone()` method has to be re-implemented so that the copy of the reference type
    can be done correctly. Otherwise, only the reference will be copied, not the object
    itself. Such a copy is called a `protected` keyword indicates that only children
    of the class can access it. See the *Packages, importing, and access* section.
  prefs: []
  type: TYPE_NORMAL
- en: The last five of the class `Object` methods are used for communication between
    threads – the lightweight processes for concurrent processing. They are typically
    not re-implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Instance and static properties and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have seen mostly methods that can be invoked only on an object (instance)
    of a class. Such methods are called `static` and invoked without creating an object.
    An example of such a method is the `main()` method. Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'This method can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Static methods can be called on an object too, but it is considered bad practice,
    as it hides the static nature of the method from a human trying to understand
    the code. Besides, it raises a compiler warning and, depending on the compiler
    implementation, may even generate a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, a property can be declared static and thus accessible without creating
    an object, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'This property can be accessed directly via class too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Having such a static property works against the idea of state encapsulation
    and may cause all the problems of concurrent data modification because it exists
    as a single copy in JVM memory, and all the methods that use it share the same
    value. That is why a static property is typically used for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To store a constant – a value that can be read but not modified (also called
    a **read-only value**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To store a stateless object that is expensive to create or that keeps read-only
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A typical example of a constant is a name of a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Note the `final` keyword in front of the static property. It tells the compiler
    and JVM that this value, once assigned, cannot change. An attempt to do it generates
    an error. It helps to protect the value and express clearly the intent to have
    this value as a constant. When a human tries to understand how the code works,
    such seemingly small details make the code easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: That said, consider using interfaces for such a purpose. Since Java 1.8, all
    the fields declared in an interface are implicitly static and final, so there
    is less chance you’ll forget to declare a value to be final. We will talk about
    interfaces shortly.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is declared a static final class property, it does not mean all
    its properties become final automatically. It only protects the property from
    assigning another object of the same type. We will discuss the complicated procedure
    of concurrent access of an object property in [*Chapter 8*](B18388_08_ePub.xhtml#_idTextAnchor187),
    *Multithreading and Concurrent Processing*. Nevertheless, programmers often use
    static final objects to store the values that are read-only just by the way they
    are used in the application. A typical example would be application configuration
    information. Once created after reading from a disk, it is not changed, even if
    it could be. Also, caching of data is obtained from an external resource.
  prefs: []
  type: TYPE_NORMAL
- en: Again, before using such a class property for this purpose, consider using an
    interface that provides more default behavior that supports a read-only functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to static properties, static methods can be invoked without creating
    an instance of the class. Consider, for example, the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the preceding method by using just a class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Abstraction/interface* section, we talked about an interface in general
    terms. In this section, we are going to describe a Java language construct that
    expresses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface presents what can be expected of an object. It hides the implementation
    and exposes only method signatures with return values. For example, here is an
    interface that declares two abstract methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a class that implements it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'An interface cannot be instantiated. An object of an interface type can be
    created only by creating an object of a class that *implements* this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: If not all of the abstract methods of the interface have been implemented, the
    class must be declared abstract and cannot be instantiated. See the *Interface
    versus abstract class* section.
  prefs: []
  type: TYPE_NORMAL
- en: An interface does not describe how the object of the class can be created. To
    discover that, you must look at the class and see what constructors it has. An
    interface also does not describe the static class methods. So, an interface is
    a public face of a class instance (object) only.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 8, an interface acquired the ability to have not just abstract methods
    (without a body) but really implemented ones. According to the Java Language Specification,
    “*the body of an interface may declare members of the interface, that is, fields,
    methods, classes, and interfaces*.” Such a broad statement brings up the question,
    what is the difference between an interface and a class? One principal difference
    that we have pointed out already is this – an interface cannot be instantiated;
    only a class can be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that a non-static method implemented inside an interface
    is declared `default` or `private`. By contrast, a `default` declaration is not
    available for the class methods.
  prefs: []
  type: TYPE_NORMAL
- en: Also, fields in an interface are implicitly public, static, and final. By contrast,
    class properties and methods are not static or final by default. The implicit
    (default) access modifier of a class itself, its fields, methods, and constructors
    are package-private, which means it is visible only within its own package.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get an idea about the function of default methods in an interface, let’s
    look at an example of an interface and a class that implements it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create an object of the `SomeClass` class and make the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `method3()` is not implemented in the `SomeClass` class, but
    it looks as if the class has it. That is one way to add a new method to an existing
    class without changing it – by adding the default method to the interface the
    class implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the `method3()` implementation to the class too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the interface implementation of `method3()` will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the default method in an interface is to provide a new method
    to the classes (that implement this interface) without changing them. But the
    interface implementation is ignored as soon as a class implements the new method
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Private methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there are several default methods in an interface, it is possible to create
    private methods accessible only by the default methods of the interface. They
    can be used to contain common functionality, instead of repeating it in every
    default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: This concept of private methods is not different from private methods in classes
    (see the *Packages, importing, and access* section). The private methods cannot
    be accessed from outside the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Static fields and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Java 8, all the fields declared in an interface are implicitly public,
    static, and final constants. That is why an interface is a preferred location
    for the constants. You do not need to add `public static final` to their declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the static methods, they function in an interface in the same way as
    in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no need to mark the interface method as `public`. All non-private
    interface methods are public by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the preceding method by using just an interface name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Interface versus abstract class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have mentioned already that a class can be declared `abstract`. It may be
    a regular class that we do not want to be instantiated, or it may be a class that
    contains (or inherits) abstract methods. In the last case, we must declare such
    a class as `abstract` to avoid a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: In many respects, an abstract class is very similar to an interface. It forces
    every `child` class that extends it to implement the abstract methods. Otherwise,
    the child cannot be instantiated and has to be declared abstract itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a few principal differences between an interface and abstract class
    make each of them useful in different situations:'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class can have a constructor, while an interface cannot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An abstract class can have a state, while an interface cannot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fields of an abstract class can be `public`, `private`, or `protected`,
    `static` or not, and `final` or not, while, in an interface, fields are always
    `public`, `static`, and `final`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods in an abstract class can be `public`, `private`, or `protected`,
    while the interface methods can be `public` or `private` only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the class you would like to amend extends another class already, you cannot
    use an abstract class, but you can implement an interface because a class can
    extend only one other class but can implement multiple interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see an example of abstract usage in the *Polymorphism in action* section.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading, overriding, and hiding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already mentioned overriding in the *Inheritance* and *Abstraction/interface*
    sections. It is a replacement of a non-static method implemented in a parent class
    with the method of the same signatures in the `child` class. The default method
    of an interface also can be overridden in the interface that extends it. Hiding
    is similar to overriding but applies only to static methods and static, as well
    as properties of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading is creating several methods with the same name and different parameters
    (thus, different signatures) in the same class or interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss all these concepts and demonstrate how they
    work for classes and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not possible to have two methods in the same interface or a class with
    the same signature. To have a different signature, the new method has to have
    either a new name or a different list of parameter types (and the sequence of
    the type does matter). Having two methods with the same name but a different list
    of parameter types constitutes overloading. Here are a few examples of a legitimate
    method of overloading in an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Note that no two of the preceding methods have the same signature, including
    the default and static methods. Otherwise, a compiler’s error would be generated.
    Neither designation as default nor static plays any role in the overloading. A
    return type does not affect the overloading either. We use `int` as a return type
    everywhere just to make the examples less cluttered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method overloading is done similarly in a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'And it does not matter where the methods with the same name are declared. The
    following method overloading is not different from the previous example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: A private non-static method can be overloaded only by a non-static method of
    the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Overloading happens when methods have the same name but a different list of
    parameter types and belong to the same interface (or class) or to different interfaces
    (or classes), one of which is an ancestor to another. A private method can be
    overloaded only by a method in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to overloading, which happens with the static and non-static methods,
    method overriding happens only with non-static methods and only when they have
    *exactly the same signature* and *belong to different interfaces (or classes)*,
    one of which is an ancestor to another.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The overriding method resides in the child interface (or class), while the overridden
    method has the same signature and belongs to one of the ancestor interfaces (or
    classes). A private method cannot be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of a method overriding an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `method()` using the `C` class instance, the result will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the usage of the `@Override` annotation. It tells the compiler
    that the programmer thinks that the annotated method overrides a method of one
    of the ancestor interfaces. This way, the compiler can make sure that the overriding
    does happen and generates an error if it doesn’t. For example, a programmer may
    misspell the name of the method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'If that happens, the compiler generates an error because there is no `metod()`
    method to override. Without the `@Overrride` annotation, this mistake may go unnoticed
    by the programmer, and the result would be quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'The same rules of overriding apply to the class instance methods. In the following
    example, the `C2` class overrides a method of the `C1` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not matter how many ancestors are between the class or interface with
    the overridden method and the class or interface with the overriding method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: The result of the preceding method’s overriding will still be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Hiding** is considered by many to be a complicated topic, but it should not
    be, and we will try to make it look simple.'
  prefs: []
  type: TYPE_NORMAL
- en: The name *hiding* came from the behavior of static properties and methods of
    classes and interfaces. Each static property or method exists as a single copy
    in the JVM’s memory because they are associated with the interface or class, not
    with an object. An interface or class exists as a single copy. That is why we
    cannot say that the child’s static property or method overrides the parent’s static
    property or method with the same name. All static properties and methods are loaded
    into the memory only once when the class or interface is loaded and stay there,
    not being copied anywhere. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create two interfaces that have a parent-child relationship and static
    fields and methods with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Please note the capital case for an identifier of an interface field. That’s
    the convention often used to denote a constant, whether it is declared in an interface
    or a class. Just to remind you, a constant in Java is a variable that, once initialized,
    cannot be re-assigned another value. An interface field is a constant by default
    because any field in an interface is *final* (see the *Final properties, methods,
    and classes* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we print `NAME` from the `B` interface and execute its `method()`, we get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: It looks very much like overriding, but, in fact, it is just that we call a
    particular property or a method associated with this particular interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, consider the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to access the static members of the `D` class using the class itself,
    we will get what we asked for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'The confusion appears only when a property or a static method is accessed using
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: The `obj` variable refers to the object of the `D` class, and the casting proves
    it, as you can see in the preceding example. But, even if we use an object, trying
    to access a static property or method brings us the members of the class that
    was used as the declared variable type. As for the instance property in the last
    two lines of the example, the properties in Java do not conform to polymorphic
    behavior, and we get the `name1` property of the parent `C` class, instead of
    the expected property of the child `D` class.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion with static members of a class, always access them using
    the class, not an object. To avoid confusion with instance properties, always
    declare them private and access them via methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the last tip, consider the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the same test for the instance properties as we did for the `C` and
    `D` classes, the result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Now, we access instance properties using methods, which are subjects for an
    overriding effect and do not have unexpected results anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude the discussion of hiding in Java, we would like to mention another
    type of hiding, namely when a local variable hides the instance or static property
    with the same name. Here is a class that does it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `name1` local variable hides the static property with the
    same name, while the `name2` local variable hides the instance property. It is
    possible still to access the static property using the class name (see `HidingProperty.name1`).
    Please note that, despite being declared `private`, it is accessible from inside
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: The instance property can always be accessed by using the `this` keyword, which
    means the **current object**.
  prefs: []
  type: TYPE_NORMAL
- en: The final variable, method, and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have mentioned a `final` property several times in relation to the notion
    of a constant in Java, but that is only one case of using the `final` keyword.
    It can be applied to any variable in general. Also, a similar constraint can be
    applied to a method and even a class too, thus preventing the method from being
    overridden and the class from being extended.
  prefs: []
  type: TYPE_NORMAL
- en: The final variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `final` keyword placed in front of a variable declaration makes this variable
    immutable after the initialization, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'The initialization can even be delayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of an `object` property, this delay can last only until the object
    is created. This means that the property can be initialized in the constructor,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Note that, even during the object construction, it is not possible to initialize
    the property twice – during declaration and in the constructor. It is also interesting
    to note that a final property has to be initialized explicitly. As you can see
    from the preceding example, the compiler does not allow the initialization of
    the final property to a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to initialize a `final` property in an initialization block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of a `static` property, it is not possible to initialize it in
    a constructor, so it has to be initialized either during its declaration or in
    a static initialization block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'In an interface, all fields are always final, even if they are not declared
    as such. Since neither a constructor nor an initialization block is not allowed
    in an interface, the only way to initialize an interface field is during declaration.
    Failing to do it results in a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Final method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method declared `final` cannot be overridden in a `child` class or hidden
    in the case of a static method. For example, the `java.lang.Object` class, which
    is the ancestor of all classes in Java, has some of its methods declared `final`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: All the private methods and uninherited methods of a `final` class are effectively
    final because you cannot override them.
  prefs: []
  type: TYPE_NORMAL
- en: Final class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `final` class cannot be extended. It cannot have children, which makes all
    the methods of the class effectively `final` too. This feature is used for security
    or when a programmer would like to make sure the class functionality cannot be
    overridden, overloaded, or hidden because of some other design considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The record class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `record` class was added to the SDK in Java 16\. It was a long-awaited
    Java feature. It allows you to avoid writing boilerplate code in a case when you
    need an immutable class (with getters only), which looks similar to the following
    `Person` class (see the `Record` class in the `ch02_oop` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the getters in the preceding above do not have the `get` prefix.
    It is done deliberately because, in the case of immutable class, there is no need
    to distinguish between getters and setters, as setters do not and should not exist
    if we want to have the class truly immutable. And that is the principal difference
    between such a class and JavaBeans, which are mutable and have both – setters
    and getters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `record` class allows you to replace the preceding implementation with
    the following one line only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: 'We can demonstrate it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to being `final` (not extendable) and immutable, `record` cannot
    extend another class because it already extends `java.lang.Record`, but it can
    implement another interface, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to add a `static` method to `record`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: A `static` method does not and cannot access instance properties and can utilize
    only the values passed into it as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '`record` can have another constructor, which can be added, for example, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, it is not possible to add another property or a setter
    to `record`, while all additional getters have to use only getters provided already
    by `record`.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `final` class cannot be extended, while a non-public class or interface has
    limited access. Yet, there are times when a class or interface needs to be accessible
    from anywhere but be extendable only by a certain class or interface, or, in the
    case of an interface, be implemented only by certain classes. That was the motivation
    for `sealed` classes and interfaces being added to the SDK in Java 17.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a `sealed` class or interface and a `final` one is that
    a `sealed` class or interface always has a `permits` keyword, followed by the
    list of the existing direct subtypes that are allowed to extend the `sealed` class
    or interface, or, in the case of the interface, implement it. Please note the
    word *existing*. The subtypes listed after the `permits` keyword must exist at
    compilation time in the same module as the sealed class or in the same package
    if in the default (unnamed) module.
  prefs: []
  type: TYPE_NORMAL
- en: A subtype of a `sealed` class must be marked either `sealed`, `final`, or `non-sealed`.
    A subtype of a `sealed` interface must be marked either `sealed` or `non-sealed`,
    since an interface cannot be `final`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a `sealed` interface first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `EngineBrand` interface extends the `Engine` interface
    and allows (permits) the `Vehicle` implementation. Alternatively, we can allow
    the `Vehicle` class to implement the `Engine` interface directly, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at an example of a `sealed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the `Car` and `Truck` permitted subtypes of
    the `Vehicle` `sealed` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'In support `sealed` classes, the Java Reflections API in Java 17 has two new
    methods, `isSealed()` and `getPermittedSubclasses()`. The following is an example
    of their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: The `sealed` interface integrates well with `record` because `record` is `final`
    and can be listed as a permittable implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is the most powerful and useful feature of OOP. It uses all the
    other OOP concepts and features we have presented so far. It is the highest conceptual
    point on the way to mastering Java programming. After discussing it, the rest
    of the book will be mostly about Java language syntax and JVM functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As we stated in the *OOP concepts* section, polymorphism is the ability of an
    object to behave as an object of different classes or as an implementation of
    different interfaces. If you search the word *polymorphism* on the internet, you
    will find that it is *the condition of occurring in several different forms*.
    Metamorphosis is *a change of the form or nature of a thing or person into a completely
    different one, by natural or supernatural means*. So, **Java polymorphism** is
    the ability of an object to behave as if going through a metamorphosis and to
    exhibit completely different behaviors under different conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We will present this concept in a practical hands-on way, using an **object
    factory** – a specific programming implementation of a factory, which is a *method
    that returns objects of a varying prototype or class* ([https://en.wikipedia.org/wiki/Factory_(object-oriented_programming](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)).
  prefs: []
  type: TYPE_NORMAL
- en: The object factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind the object factory is to create a method that returns a new
    object of a certain type under certain conditions. For example, look at the `CalcUsingAlg1`
    and `CalcUsingAlg2` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, they both implement the same interface, `CalcSomething`, but
    use different algorithms. Now, let’s say that we decided that the selection of
    the algorithm used will be done in a `property` file. Then, we can create the
    following object factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: 'The factory selects which algorithm to use based on the value returned by the
    `getAlgValueFromPropertyFile()` method. In the case of the second algorithm, it
    also uses the `getAlg2Prop1FromPropertyFile()` methods and `getAlg2Prop2FromPropertyFile()`
    to get the input parameters for the algorithm. But this complexity is hidden from
    the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: We can add new algorithm variations, and change the source for the algorithm
    parameters or the process of the algorithm selection, but the client will not
    need to change the code. And that is the power of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use inheritance to implement polymorphic behavior. Consider
    the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our factory may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: 'But the client code does not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Given a choice, an experienced programmer uses a common interface for the implementation.
    It allows for a more flexible design, as a class in Java can implement multiple
    interfaces but can extend (inherit from) one class.
  prefs: []
  type: TYPE_NORMAL
- en: The instanceof operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, life is not always that easy, and once in a while, a programmer
    has to deal with code that is assembled from unrelated classes, even coming from
    different frameworks. In such a case, using polymorphism may be not an option.
    However, you can hide the complexity of an algorithm selection and even simulate
    polymorphic behavior using the `instanceof` operator, which returns `true` when
    an object is an instance of a certain class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have two unrelated classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the classes expects as an input an object of a certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: 'And let’s assume that the method we implement receives such an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: We still use polymorphism here because we describe our input as the `Object`
    type. We can do it because the `Object` class is the base class for all Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at how the `Calculator` class is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it uses the `instanceof` operator for selecting the appropriate
    algorithm. By using the `Object` class as an input type, the `Calculator` class
    takes advantage of polymorphism too, but most of its implementation has nothing
    to do with it. Yet, from the outside, it looks polymorphic, and it is, but only
    to a degree.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the concepts of OOP and how they are implemented
    in Java. It provided an explanation of each concept and demonstrated how to use
    it in specific code examples. The Java language constructs of `class` and `interface`
    were discussed in detail. You also learned what overloading, overriding, and hiding
    are and how to use the `final` keyword to protect methods from being overridden.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Polymorphism in action* section, you learned about the powerful Java
    feature of polymorphism. This section brought all the presented material together
    and showed how polymorphism stays at the center of OOP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will become familiar with the Java language syntax,
    including packages, importing, access modifiers, reserved and restricted keywords,
    and some aspects of Java reference types. You will also learn how to use the `this`
    and `super` keywords, what widening and narrowing conversions of primitive types
    are, boxing and unboxing, primitive and reference type assignment, and how the
    `equals()` method of a reference type works.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select all the correct OOP concepts from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Pollination
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object has status.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object has behavior.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object has state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object has methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object behavior can be inherited.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object behavior can be overridden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object behavior can be overloaded.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java object behavior can be overwhelmed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java objects of different classes can have the same behavior.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java objects of different classes share a parent object state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java objects of different classes have as a parent an object of the same class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Java objects of different classes can share behavior.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method signature includes the return type.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The method signature is different if the return type is different.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The method signature changes if two parameters of the same type switch positions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The method signature changes if two parameters of different types switch positions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation hides the class name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation hides behavior.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation allows access to data only via methods.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation does not allow direct access to the state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is declared in the `.java` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The class bytecode is stored in the `.class` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The parent class is stored in the `.base` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `child` class is stored in the `.sub` file.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method defines an object state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A method defines object behavior.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A method without parameters is marked as `void`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A method can have many `return` statements.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Varargs` is declared as a `var` type.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Varargs` stands for *various arguments*.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Varargs` is a `String` array.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Varargs` can act as an array of the specified type.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A constructor is a method that creates a state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The primary responsibility of a constructor is to initialize a state.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JVM always provides a default constructor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The parent class constructor can be called using the `parent` keyword.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `new` operator allocates memory to an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `new` operator assigns default values to the object properties.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `new` operator creates a parent object first.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `new` operator creates a child object first.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Object` class belongs to the `java.base` package.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Object` class belongs to the `java.lang` package.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Object` class belongs to a package of the Java Class Library.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Object` class is imported automatically.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance method is invoked using an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A static method is invoked using a class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An instance method is invoked using a class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A static method is invoked using an object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods in an interface are implicitly `public`, `static`, and `final`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface can have methods that can be invoked without being implemented
    in a class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface can have fields that can be used without any class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface can be instantiated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default method of an interface is always invoked by default.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The private method of an interface can be invoked only by the default method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The interface static method can be invoked without being implemented in a class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The default method can enhance a class that implements the interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Abstract` class can have a default method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An `Abstract` class can be declared without an `abstract` method.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Any class can be declared abstract.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An interface is an `abstract` class without a constructor.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overloading can be done only in an interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Overloading can be done only when one class extends another.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Overloading can be done in any class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The overloaded method must have the same signature.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding can be done only in a `child` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding can be done in an interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The overridden method must have the same name.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: No method of an `Object` class can be overridden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any method can be hidden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A variable can hide a property.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A static method can be hidden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A public instance property can be hidden.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any variable can be declared final.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A public method cannot be declared final.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A protected method can be declared final.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A class can be declared protected.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select all the correct statements from the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic behavior can be based on inheritance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic behavior can be based on overloading.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic behavior can be based on overriding.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic behavior can be based on an interface.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
