<html><head></head><body>
		<div id="_idContainer067">
			<h1 id="_idParaDest-162"><em class="italic"><a id="_idTextAnchor173"/>Chapter 9</em>: Deployment and Day 2 Operations</h1>
			<p>So far, we've seen many code snippets and screenshots of our example application, the <strong class="bold">IBM Stock Trader</strong>. Now, let's learn how to deploy it to your own <strong class="bold">OpenShift Container Platform</strong> cluster or any <strong class="bold">Kubernetes</strong> platform of your choice. As important as getting it running is, it is also very important to learn how to maintain it and tune it to meet your needs.</p>
			<p>Unlike many <em class="italic">Hello World</em> samples that you might see on the internet, that either have no operator at all (just having you manually apply <strong class="source-inline">.yaml</strong> files to install), or they perhaps have a very simple operator per microservice, the <strong class="bold">IBM Stock Trader</strong> example has a <strong class="bold">composite operator</strong> that not only installs all of the microservices but also configures the connectivity to all prerequisite services, including all the credentials used for authentication.</p>
			<p>This composite operator also provides an advanced form <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>) in the OpenShift console, used both at initial deployment time to pick which of the optional pieces you want and how to configure them, and also used on <em class="italic">day 2</em> and beyond to fine-tune various values as desired. And for those who prefer a command-line or automated experience (or who use plain <strong class="bold">Kubernetes</strong> without access to the sophisticated OpenShift console), the operator works well in that situation as well, as you prepare and apply the <strong class="source-inline">.yaml</strong> file for the custom resource defined by the operator.</p>
			<p>In this chapter, we're going to cover the following main topics: </p>
			<ul>
				<li>Understanding the role of operators</li>
				<li>Installing the operator via the OpenShift console</li>
				<li>Deploying the application via the operator form UI</li>
				<li>Deploying the application via the command line</li>
				<li>Day 2 operations</li>
			</ul>
			<p>By the end of this chapter, you will be familiar with using the operator to deploy the application, either from the UI or the CLI, and how to use it to maintain the application going forward.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor174"/>Technical requirements</h1>
			<p>To use the operator as described in this section, you will need to have the following tools installed:</p>
			<ul>
				<li>A Git client – <a href="https://git-scm.com">https://git-scm.com</a></li>
				<li>A Kubernetes client (<strong class="source-inline">kubectl</strong>) – https://kubernetes.io/docs/tasks/tools/#kubectl</li>
			</ul>
			<p>In addition, you will need to have a Kubernetes cluster available. For the CLI parts of this chapter, you can use any Kubernetes distribution you prefer. But to try out the UI parts of this chapter, the Kubernetes distribution will need to be OpenShift Container Platform (OCP), since the screenshots are all from the OpenShift console. Ask your administrator how to give <strong class="source-inline">kubectl</strong> access to your cluster, and for the URL of the console if using OCP.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor175"/>Understanding the role of operators</h1>
			<p>Before diving into the specifics of the <a id="_idIndexMarker994"/>IBM Stock Trader operator, let's step back for a bit and consider what operators do and why they are a good thing. To do so, it's important to recall from <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>, that Kubernetes defines a model where there are several built-in object types, such as Deployments, Services, Ingresses, ConfigMaps, and Secrets. In the true object-oriented philosophy, such objects not only have data but have behavior; it is the operators' job to participate in and guide the full <strong class="bold">Create, Retrieve, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) life cycle of the <a id="_idIndexMarker995"/>objects they manage.</p>
			<p>One key point is that Kubernetes not only has its built-in objects, but also has an extensibility model where vendors can add to that <em class="italic">vocabulary</em>, defining additional types of objects and <a id="_idIndexMarker996"/>how they should act in the Kubernetes environment. Kubernetes calls this a <strong class="bold">CustomResourceDefinition</strong> (<strong class="bold">CRD</strong>). A CRD is <a id="_idIndexMarker997"/>essentially a schema of what fields describe the configuration for a particular instance of the <strong class="bold">CustomResource</strong> (<strong class="bold">CR</strong>). I often think of it as a <em class="italic">CR</em> is to its <em class="italic">CRD</em> as <em class="italic">XML</em> is to its <em class="italic">XSD</em>.</p>
			<p>Before the rise of <a id="_idIndexMarker998"/>operators, an earlier technology known as <strong class="bold">Helm</strong> was used to install an application in Kubernetes. It did what it was meant to – it applied the <strong class="source-inline">yaml</strong> file to each <a id="_idIndexMarker999"/>Kubernetes built-in object needed by an application, with some ability to parameterize the fields in each <strong class="source-inline">yaml</strong> file. The Stock Trader <a id="_idIndexMarker1000"/>application itself had a Helm chart (at <a href="https://github.com/IBMStockTrader/stocktrader-helm">https://github.com/IBMStockTrader/stocktrader-helm</a>), before the arrival of OpenShift version 4, which was a pretty big redesign of the OpenShift architecture with operators at the heart of it all.</p>
			<p>Though Helm worked, it was a limited technology, in that it did nothing to help with running the applications once they were installed. An operator, on the other hand, is always listening for, and ready to react to, any change to a CR of the CRD type it operates upon. Operators also can offer <em class="italic">day 2</em> operations, as we'll see later in this chapter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are different ways to write an operator, one of which is to wrap a Helm chart. The operator for the <a id="_idIndexMarker1001"/>Stock Trader application is one such Helm-based operator. Take a look at (or clone) the <a href="https://github.com/IBMStockTrader/stocktrader-operator">https://github.com/IBMStockTrader/stocktrader-operator</a> repo to browse its source <a id="_idIndexMarker1002"/>code, to open issues, or to submit <strong class="bold">pull requests</strong> (<strong class="bold">PRs</strong>) to improve the operator.</p>
			<p>Another way of thinking about it is that operators expand the kinds of objects that Kubernetes knows how to manage; for example, one managing a CRD of the <strong class="source-inline">PacktBook</strong> type would enable commands such as <strong class="source-inline">kubectl get PacktBooks</strong> or <strong class="source-inline">kubectl describe PacktBook microprofile</strong>, in the same way, you would act upon built-in Kubernetes objects such as <strong class="source-inline">Deployments</strong> or <strong class="source-inline">Services</strong>.</p>
			<p>Now let's learn how to use the operator for our Stock Trader application. We'll start with the OpenShift console UI approach, and then will look at how to use it from a CLI as well.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor176"/>Installing the operator via the OpenShift console</h1>
			<p>As a quick reminder from <a href="B17377_03_Final_SB_epub.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Introducing the IBM Stock Trader Cloud-Native Application</em>, the <strong class="bold">IBM Stock Trader</strong> application <a id="_idIndexMarker1003"/>is comprised of about a dozen microservices (many of which are optional), and about the same number of prerequisite<a id="_idIndexMarker1004"/> resources, such as databases and messaging systems. The composite operator guides you through providing all of the settings for each of those microservices and for configuring their connectivity to those various backend resources, as we can see here:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B17377_09_01.jpg" alt="Figure 9.1 – Architectural diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Architectural diagram</p>
			<p>As we can see, there are a lot of parts that need to be configured for everything to work. The operator guides us through providing such configuration information for each piece (though it does <em class="italic">NOT</em> actually install the backend resources – it just asks for the endpoint and credential details to connect to pre-existing resources, which could be running in your cluster, or accessed <a id="_idIndexMarker1005"/>from elsewhere, such as a <strong class="bold">DB2-as-a-Service</strong> (<strong class="bold">DB2aaS</strong>) out in the cloud). In the next two sections, we'll learn about OperatorHub and how to install the operator in our cluster.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor177"/>OperatorHub</h2>
			<p>The <strong class="bold">OpenShift</strong> 4.x console includes a catalog of operators called <strong class="bold">OperatorHub</strong>. There are several built-in catalog sources, and <a id="_idIndexMarker1006"/>administrators can plug in additional sources to make more operators appear in the catalog that they have purchased from vendors (such as the catalog sources for the various IBM Cloud Paks) or that their own developers have created. Let's take a look at the <strong class="bold">OperatorHub</strong> portion of the OpenShift console by clicking on <strong class="bold">Operators</strong> | <strong class="bold">OperatorHub</strong> in the left navigation menu:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B17377_09_02_new.jpg" alt="Figure 9.2 – OperatorHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – OperatorHub</p>
			<p>Here we can see we have 460 operators available, 5 of which are currently installed in our cluster. Let's learn how to install our own catalog source so that we can cause our own operator(s) to show up here:</p>
			<ol>
				<li>We'll start by clicking on <strong class="bold">Administration</strong> | <strong class="bold">Cluster Settings</strong> in the left navigation menu. </li>
				<li>Then we choose the <strong class="bold">Global Configuration</strong> tab and click on <strong class="bold">OperatorHub</strong> in the alphabetical <a id="_idIndexMarker1007"/>list as shown next (you can type something like <strong class="source-inline">Hub</strong>, in the filter field, and the list will filter to just entries containing that string):<div id="_idContainer048" class="IMG---Figure"><img src="image/B17377_09_03.jpg" alt="Figure 9.3 – Cluster Settings&#13;&#10;"/></div><p class="figure-caption">Figure 9.3 – Cluster Settings</p></li>
				<li>Then, on the resulting page, click on the <strong class="bold">Sources</strong> tab.<p>You'll see that four sources are pre-configured (all from Red Hat), and the number of operators contributed by each:</p><div id="_idContainer049" class="IMG---Figure"><img src="image/B17377_09_04.jpg" alt="Figure 9.4 – Catalog Sources&#13;&#10;"/></div><p class="figure-caption"> </p><p class="figure-caption">Figure 9.4 – Catalog Sources</p><p>If your administrator has set up your cluster to show operators beyond <a id="_idIndexMarker1008"/>the default ones, you may see more than the initial four.</p></li>
				<li>Then just click on the <strong class="bold">Create Catalog Source</strong> button to provide the details for our new source containing the operator for the <strong class="bold">IBM Stock Trader</strong> application:<div id="_idContainer050" class="IMG---Figure"><img src="image/B17377_09_05.jpg" alt="Figure 9.5 – Details for the IBM Stock Trader catalog source&#13;&#10;"/></div><p class="figure-caption">Figure 9.5 – Details for the IBM Stock Trader catalog source</p><p class="callout-heading">Note</p><p class="callout">We chose to make it a <strong class="bold">Cluster-wide catalog source</strong> so that it is available regardless of what namespace you are using in your cluster. If you prefer (or only have authority in a particular namespace), you could instead choose <strong class="bold">Namespace catalog source</strong>. Note that if you are in a really locked-down environment using an ID with limited security privileges, you might need to ask an administrator to perform this action for you.</p></li>
				<li>You can type whatever values you want in the first three fields (I chose my team's <a id="_idIndexMarker1009"/>name, <strong class="source-inline">Cloud Engagement Hub</strong>). </li>
				<li>The final field, specifying where to find the Docker image for the catalog source, is the most important and needs to be set to <strong class="source-inline">docker.io/ibmstocktrader/stocktrader-operator-catalog:v0.2.0</strong>. <p class="callout-heading">Note</p><p class="callout">Of course, you could clone the <strong class="source-inline">IBMStockTrader/stocktrader-operator</strong> GitHub repository and build your own image (per the instructions at <a href="https://github.com/IBMStockTrader/stocktrader-operator/blob/master/bundle/README.md">https://github.com/IBMStockTrader/stocktrader-operator/blob/master/bundle/README.md</a>) and push it to your own image registry and specify that here, but to keep things simple, we're <a id="_idIndexMarker1010"/>using the pre-built version we keep hosted in <strong class="bold">Docker Hub</strong> for convenience.</p></li>
				<li>Once you click the <strong class="bold">Create</strong> button, it will return you to the list of catalog sources. <p>At first, there will just be a dash for the number of operators from that new source, until OpenShift is able to download the specified Docker container image and parse its contents. Once it does, it will update to show the correct number of operators, which is just one in our case, as shown here:</p><div id="_idContainer051" class="IMG---Figure"><img src="image/B17377_09_06_new.jpg" alt="Figure 9.6 – Details for the IBM Stock Trader catalog source&#13;&#10;"/></div><p class="figure-caption">Figure 9.6 – Details for the IBM Stock Trader catalog source</p></li>
				<li>Now if you return to the <strong class="bold">OperatorHub</strong> page for your cluster (via <strong class="bold">Operators</strong> |<strong class="bold"> OperatorHub</strong> in the left <a id="_idIndexMarker1011"/>navigation menu), our new operator will appear.<p>Note that, rather than scrolling down dozens of times to find it, you can type something like <strong class="source-inline">stock</strong>, in the filter field, and then it will only show the ones containing that string:</p></li>
			</ol>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B17377_09_07.jpg" alt="Figure 9.7 – The IBM Stock Trader operator in our cluster's OperatorHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – The IBM Stock Trader operator in our cluster's OperatorHub</p>
			<p>Congratulations! You have <a id="_idIndexMarker1012"/>now made the operator for the IBM Stock Trader application available in the OperatorHub catalog. In the next section, we'll look at how to install the operator.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor178"/>Installing the operator</h2>
			<p>Now that we've made our operator available in our cluster's catalog, let's make use of it:</p>
			<ol>
				<li value="1">Just click <a id="_idIndexMarker1013"/>on the tile for the operator. Doing so will show further details about the operator that we just made available in the previous section:<div id="_idContainer053" class="IMG---Figure"><img src="image/B17377_09_08.jpg" alt="Figure 9.8 – The IBM Stock Trader operator info page&#13;&#10;"/></div><p class="figure-caption">Figure 9.8 – The IBM Stock Trader operator info page</p><p>As you can see, this shows some basic information about the operator, including its readme file. Nothing <a id="_idIndexMarker1014"/>needs to be done in this dialog – just click on the <strong class="bold">Install</strong> button.</p><div id="_idContainer054" class="IMG---Figure"><img src="image/B17377_09_09.jpg" alt="Figure 9.9 – The IBM Stock Trader operator subscription page&#13;&#10;"/></div><p class="figure-caption">Figure 9.9 – The IBM Stock Trader operator subscription page</p><p>Here we see information about how the operator will behave in our cluster; for example, we <a id="_idIndexMarker1015"/>can see that, like all OperatorHub-integrated operators that you install to work on all namespaces in your cluster, the actual namespace where the operator will run is called <strong class="bold">openshift-operators</strong>. Note that the act of <em class="italic">installing</em> an operator is technically about making a <em class="italic">subscription</em> to that operator (more on that in the <em class="italic">Deploying the application via the CLI</em> section, next).</p></li>
				<li>Once you click the <strong class="bold">Install</strong> button, you'll briefly see a dialog saying it is being installed (until its pod starts and passes its readiness check), and then it will tell you whether it has been successfully installed.</li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B17377_09_10.jpg" alt="Figure 9.10 – The IBM Stock Trader operator is installed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – The IBM Stock Trader operator is installed</p>
			<p>Congratulations! You have <a id="_idIndexMarker1016"/>now installed the operator for the <strong class="bold">IBM Stock Trader</strong> application. In the next section, we'll look at how to use that operator to deploy the application.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor179"/>Deploying the application via the operator form UI</h1>
			<p>To deploy the application, we will follow these steps:</p>
			<ol>
				<li value="1">Click on the <strong class="bold">View Operator</strong> button shown in <em class="italic">Figure 9.10</em>. You will be taken to a page showing you <a id="_idIndexMarker1017"/>information about the operator, which of course looks very similar to what we saw when we first clicked on the operator in <strong class="bold">OperatorHub</strong>.<div id="_idContainer056" class="IMG---Figure"><img src="image/B17377_09_11.jpg" alt="Figure 9.11 – The IBM Stock Trader operator Details page&#13;&#10;"/></div><p class="figure-caption">Figure 9.11 – The IBM Stock Trader operator Details page</p></li>
				<li>We can use the <strong class="bold">Create Instance</strong> link shown in <em class="italic">Figure 9.11</em> to launch into the dialog <a id="_idIndexMarker1018"/>for installing an instance of our <strong class="bold">IBM Stock Trader</strong> application:<div id="_idContainer057" class="IMG---Figure"><img src="image/B17377_09_12.jpg" alt="Figure 9.12 – The IBM Stock Trader operator form UI&#13;&#10;"/></div><p class="figure-caption">Figure 9.12 – The IBM Stock Trader operator form UI</p></li>
				<li>Next, we will provide a <strong class="bold">Name</strong> for this instance. <p>Note that you can use this operator to install as many instances as you want; for example, one instance might use a local <em class="italic">DB2</em> database, and another might use a <em class="italic">DB2aaS</em> in <a id="_idIndexMarker1019"/>the cloud. Each instance will use the <strong class="bold">Name</strong> you specify here as the prefix on all resources created; for example, if we type <strong class="source-inline">microprofile</strong> as the instance name to use here, then the portfolio deployment that gets created will be named <strong class="source-inline">microprofile-portfolio</strong>.</p><p>Since this is a composite operator – that is, one that installs the entire application, not one for just a particular microservice – it uses expandable/collapsible sections to separate the configuration settings for each microservice. It also has such a section for each service it depends upon, such as a <strong class="bold">Database</strong> section and an <strong class="bold">IBM MQ Settings</strong> section. And at the very top is a <strong class="bold">Global</strong> section, for settings that apply to all of the chosen microservices. Note that most <a id="_idIndexMarker1020"/>settings have good, reasonable defaults and only need adjusting in special scenarios. The one big exception to that is the <strong class="bold">Database</strong> section, so let's expand it and see what we need to fill in there, as this is the one mandatory prerequisite service that we can't run without:</p><div id="_idContainer058" class="IMG---Figure"><img src="image/B17377_09_13.jpg" alt="Figure 9.13 – The Database section of the IBM Stock Trader operator form UI&#13;&#10;"/></div><p class="figure-caption">Figure 9.13 – The Database section of the IBM Stock Trader operator form UI</p></li>
				<li>As you can see, standard <em class="italic">endpoint</em> type information must be provided, such as the <strong class="bold">Database Host name (or IP address)</strong> of the database server and the <strong class="bold">Database Port Number</strong> used to connect to it, as well as credential information <a id="_idIndexMarker1021"/>needed to authenticate to it. Very similar information is requested for each of the later sections, such as for <strong class="bold">Cloudant</strong>, <strong class="bold">ODM</strong>, or <strong class="bold">MQ</strong>.</li>
			</ol>
			<p>Let's expand one of the optional microservices, such as the <strong class="bold">Account microservice</strong>:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B17377_09_14.jpg" alt="Figure 9.14 – The Account microservice section of the IBM Stock Trader operator form UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – The Account microservice section of the IBM Stock Trader operator form UI</p>
			<p>Note the little true/false switch at the top, where you specify whether you want to enable this optional microservice. The rest of the settings in that section will only apply if you <a id="_idIndexMarker1022"/>choose to enable this microservice. Note also the section for specifying where the Docker container image is found for this microservice; by default, it will be prefilled with the location in <em class="italic">Docker Hub</em> where we host pre-built versions of each microservice for convenience, though you can type your own value here if you have built the microservice yourself (as described in the previous chapter) and pushed it to your own image registry.</p>
			<p>Note that the first time or two you install the application, having the form UI guide you through everything is very helpful, but over time this can get a bit old, filling in each value for each microservice and each prerequisite service they depend upon. Therefore, there is also the option to simply provide the answers to all of these questions in a <strong class="source-inline">.yaml</strong> file, which you can just drag and drop into the second tab of this form (<strong class="bold">YAML View</strong>):</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B17377_09_15.jpg" alt="Figure 9.15 – The YAML View tab of the IBM Stock Trader operator form UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – The YAML View tab of the IBM Stock Trader operator form UI</p>
			<p>Whichever way you provide the input, the same end result will occur, once you click the <strong class="bold">Create</strong> button at the bottom of the page. You should see your new instance appear in the list of <a id="_idIndexMarker1023"/>instances of the <strong class="bold">IBM Stock Trader</strong> application, with the <strong class="bold">Name</strong> you provided:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B17377_09_16.jpg" alt="Figure 9.16 – The StockTraders section of the IBM Stock Trader operator UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – The <strong class="bold">StockTraders</strong> section of the IBM Stock Trader operator UI</p>
			<p>If we click on <a id="_idIndexMarker1024"/>that name, we will see info about our newly deployed instance. There are several tabs; the <strong class="bold">Resources</strong> tab is especially useful, to see which of the Kubernetes resources discussed in <a href="B17377_07_Final_SB_epub.xhtml#_idTextAnchor146"><em class="italic">Chapter 7</em></a>, <em class="italic">MicroProfile Ecosystem with Open Liberty, Docker, and Kubernetes</em>, gets created by the operator:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B17377_09_17.jpg" alt="Figure 9.17 – The Resources tab of the IBM Stock Trader operator UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – The Resources tab of the IBM Stock Trader operator UI</p>
			<p>How much appears here depends on which microservices you chose to enable. Since it can be <a id="_idIndexMarker1025"/>a long list, there is a <strong class="bold">Filter</strong> button near the top left, which can be used to filter the list down to just certain types of Kubernetes objects:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17377_09_18.jpg" alt="Figure 9.18 – The Filter dialog of the IBM Stock Trader operator form UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – The Filter dialog of the IBM Stock Trader operator form UI</p>
			<p>Here we can <a id="_idIndexMarker1026"/>see that in this instance, we have 8 Deployments (microservices), 7 Services (one of the microservices is an MDB with no HTTP endpoint, so it has no Service), 1 ConfigMap, 1 Secret, 3 Routes, and 2 HorizontalPodAutoscalers. If we had enabled other options, such as the <strong class="bold">Istio</strong> true/false setting in the <strong class="bold">Global</strong> section of our form/yaml, then we'd have seen additional items such as <strong class="bold">Gateway</strong>, <strong class="bold">VirtualService</strong>, <strong class="bold">DestinationRule</strong>, and <strong class="bold">NetworkPolicy</strong> as non-zero. We can also view resources as usual in the OpenShift console by clicking on <strong class="bold">Workloads</strong> | <strong class="bold">Pods</strong> to see all of the running pods:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B17377_09_19.jpg" alt="Figure 9.19 – The pods for each microservice comprising the IBM Stock Trader application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – The pods for each microservice comprising the IBM Stock Trader application</p>
			<p>We've now seen <a id="_idIndexMarker1027"/>how to install the IBM Stock Trader application via the OpenShift console. In the next section, we'll look at how we would use the operator via the <strong class="source-inline">kubectl</strong> <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) instead.</p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor180"/>Deploying the application via the CLI</h1>
			<p>Sometimes you <a id="_idIndexMarker1028"/>need to do things via an approach other than using <a id="_idIndexMarker1029"/>a graphical user interface. Maybe you <a id="_idIndexMarker1030"/>just prefer using a CLI. Or, perhaps you want to automate such work as steps in a <strong class="bold">Continuous Integration / Continuous Deployment</strong> (<strong class="bold">CI / CD</strong>) pipeline. Or, maybe you are using a Kubernetes <a id="_idIndexMarker1031"/>distribution other than <strong class="bold">Red Hat OpenShift Container Platform</strong> (<strong class="bold">OCP</strong>), such as from one of the hyperscalers, such as <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) or <strong class="bold">Microsoft Azure</strong>. To deploy the <a id="_idIndexMarker1032"/>application without the benefit of the OpenShift <a id="_idIndexMarker1033"/>console, follow these steps:</p>
			<ol>
				<li value="1">The first thing you'll <a id="_idIndexMarker1034"/>need to do is to make sure that the <strong class="bold">Operator Lifecycle Manager</strong> (<strong class="bold">OLM</strong>) feature is installed in your Kubernetes cluster. This can be done via the <strong class="bold">operator-sdk</strong> (which you can install <a id="_idIndexMarker1035"/>on your Mac via <strong class="source-inline">brew install operator-sdk</strong>) by <a id="_idIndexMarker1036"/>following the instructions at <a href="https://olm.operatorframework.io/docs/getting-started/">https://olm.operatorframework.io/docs/getting-started/</a>.<p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">operator-sdk</strong> is used to produce an operator such as the one for the IBM Stock Trader application. The exact command that generated the starting point for this operator was <strong class="source-inline">operator-sdk init --plugins helm --group operators --kind StockTrader --domain ibm.com --version v1 --helm-chart ../stocktrader-helm/stocktrader-1.5.0.tgz</strong>.</p></li>
				<li>The next <a id="_idIndexMarker1037"/>step is to create the catalog source for the <strong class="bold">IBM Stock Trader</strong> application. Create a <strong class="source-inline">.yaml</strong> file with the following contents:<p class="source-code">apiVersion: operators.coreos.com/v1alpha1</p><p class="source-code">kind: CatalogSource</p><p class="source-code">metadata:</p><p class="source-code">  name: cloud-engagement-hub</p><p class="source-code">spec:</p><p class="source-code">  publisher: IBM</p><p class="source-code">  displayName: Cloud Engagement Hub</p><p class="source-code">  image: 'docker.io/ibmstocktrader/stocktrader-    operator-catalog:v0.2.0'</p><p>The only value that really matters is the <strong class="source-inline">image</strong> field – you can specify anything you want for the other fields. Name the file whatever you want, such as <strong class="source-inline">catalog-source.yaml</strong>. Make sure you are logged in to your cluster from your terminal window and then run the command <strong class="source-inline">kubectl apply -f catalog-source.yaml</strong>. After a minute or so, the catalog source will be available, just like when done via the OpenShift console.</p></li>
				<li>Next, you will <a id="_idIndexMarker1038"/>install the operator via the catalog source. Create another <strong class="source-inline">.yaml</strong> file with the following contents:<p class="source-code">apiVersion: operators.coreos.com/v1alpha1</p><p class="source-code">kind: Subscription</p><p class="source-code">metadata:</p><p class="source-code">  name: stocktrader-operator</p><p class="source-code">  namespace: openshift-operators</p><p class="source-code">spec:</p><p class="source-code">  channel: alpha</p><p class="source-code">  installPlanApproval: Automatic</p><p class="source-code">  name: stocktrader-operator</p><p class="source-code">  source: cloud-engagement-hub</p><p class="source-code">  sourceNamespace: openshift-marketplace</p><p class="source-code">  startingCSV: stocktrader-operator.v0.2.0</p><p>Name it whatever you want, such as <strong class="source-inline">subscription.yaml</strong>. Then, run <strong class="source-inline">kubectl apply -f subscription.yaml</strong>. Once this is complete, the operator will be installed and available.</p></li>
				<li>The final step is to apply the yaml for the instance you want to create of the IBM Stock Trader application. As discussed in the <em class="italic">Understanding the role of operators</em> section, an operator defines a CRD – in this case, for an object of the <strong class="source-inline">StockTrader</strong> type – and here we are creating a CR of that type.<p>The Stock Trader CR yaml has the same structure as what we saw in the OpenShift console; each expandable section maps to an indentation level in the .yaml file. For example, there's a section for every microservice, and for each prerequisite <a id="_idIndexMarker1039"/>service they depend upon. Here's a snippet of an example <strong class="source-inline">CR yaml</strong>, most of which is cut out to avoid having many pages of yaml content:</p><p class="source-code">apiVersion: operators.ibm.com/v1</p><p class="source-code">kind: StockTrader</p><p class="source-code">metadata:</p><p class="source-code">  name: microprofile</p><p class="source-code">spec:</p><p class="source-code">  global:</p><p class="source-code">    auth: basic</p><p class="source-code">    healthCheck: true</p><p class="source-code">    ingress: false</p><p class="source-code">    istio: false</p><p class="source-code">    istioNamespace: mesh</p><p class="source-code">    route: true</p><p class="source-code">    traceSpec: "*=info"</p><p class="source-code">    jsonLogging: false</p><p class="source-code">    disableLogFiles: false</p><p class="source-code">    monitoring: true</p><p class="source-code">    specifyCerts: false</p><p class="source-code">  database:</p><p class="source-code">    type: db2</p><p class="source-code">    db: BLUDB</p><p class="source-code">    host: dashdb-txn-sbox-yp-dal09-</p><p class="source-code">      08.services.dal.bluemix.net</p><p class="source-code">    id: my-id-goes-here</p><p class="source-code">    password: my-password-goes-here</p><p class="source-code">    port: 50000</p><p class="source-code">  account:</p><p class="source-code">    enabled: true</p><p class="source-code">    replicas: 1</p><p class="source-code">    autoscale: false</p><p class="source-code">    maxReplicas: 10</p><p class="source-code">    cpuThreshold: 75</p><p class="source-code">    image:</p><p class="source-code">      repository: ibmstocktrader/account</p><p class="source-code">      tag: 1.0.0</p><p class="source-code">    url: http://{{ .Release.Name }}-account-</p><p class="source-code">      service:9080/account</p><p>Any field not specified in the yaml you pass will use its default value, so you really only need to fill in fields that you want to set to a non-default value. For a full <a id="_idIndexMarker1040"/>example of a <strong class="source-inline">Stock Trader CR yaml file</strong>, you can either copy/paste what appears when you switch to the <strong class="bold">YAML View</strong> tab of the operator page (as we saw in <em class="italic">Figure 9.15</em>) or go look in GitHub at <a href="https://github.com/IBMStockTrader/stocktrader-operator/blob/master/config/samples/operators_v1_stocktrader.yaml">https://github.com/IBMStockTrader/stocktrader-operator/blob/master/config/samples/operators_v1_stocktrader.yaml</a>.</p></li>
				<li>Once you have your CR yaml file filled out, save it with whatever filename you prefer, such as <strong class="source-inline">stock-trader.yaml</strong>, and then deploying an instance of the IBM Stock Trader application is as simple as running <strong class="source-inline">kubectl apply -f stock-trader.yaml</strong>. This will take a couple of minutes to complete.<p>Once it does, you can see which pods are running for the microservices you selected by running a simple <strong class="source-inline">kubectl get pods</strong> command:</p></li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B17377_09_20.jpg" alt="Figure 9.20 – Console output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Console output</p>
			<p>Congratulations! You <a id="_idIndexMarker1041"/>have confirmed that you have deployed the IBM Stock Trader application, after creating and applying just three yaml files! Now that you've learned how to deploy the application, let's learn what we can do next via the operator.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor181"/>Understanding day 2 operations</h1>
			<p>People in the Kubernetes community often say that deployment is <em class="italic">day 1</em> and that the kinds of things you do to maintain the application afterward are <em class="italic">day 2</em> operations. Some examples of <em class="italic">day 2</em> operations include the following:</p>
			<ul>
				<li>Scaling a given microservice up or down</li>
				<li>Upgrading to a newer version of a microservice</li>
				<li>Setting a trace string to perform problem determination</li>
			</ul>
			<p>Let's look at each one of these in detail.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor182"/>Scaling a microservice</h2>
			<p>One of the benefits of a microservices architecture is that you can independently scale each microservice. Rather <a id="_idIndexMarker1042"/>than having to scale up all parts of a monolithic application at once, you can scale just the part that is experiencing the throughput or response time issues.</p>
			<p>One thing to be aware of when using resources generated by an operator is that the operator itself <em class="italic">owns</em> those resources, and won't let you change them directly. For example, if you wanted to edit the Portfolio deployment to scale the number of pods, attempting to do so might momentarily appear to work, but in reality, the operator is constantly watching and will revert any resource that gets edited outside of its purview. There is a process called <strong class="bold">reconciliation</strong> that advanced operators can use to decide whether and how to <a id="_idIndexMarker1043"/>merge the requested changes, but a simple Helm-based operator, like the one for Stock Trader, will just reject any attempt to directly edit one of the Kubernetes resources that it generated.</p>
			<p>The proper way to make such a change is to edit the CR yaml for the instance of the Stock Trader deployment instead. You can do so either via the OpenShift console or from the CLI. If using the CLI, you can pick which text editor gets used, by setting the <strong class="source-inline">KUBE_EDITOR</strong> environment variable to whatever text-based editor you want. For example, if you develop on a Mac and prefer its <strong class="source-inline">nano</strong> editor to the old-fashioned <strong class="source-inline">vi</strong> editor, just issue the command <strong class="source-inline">export KUBE_EDITOR=nano</strong>.</p>
			<p>So, if you want to scale up your Portfolio deployment from one pod to two, you can simply run <strong class="source-inline">kubectl edit StockTrader microprofile</strong>, and that will load its current yaml into the specified editor, where you would go down to the <strong class="source-inline">portfolio</strong> section and change the <a id="_idIndexMarker1044"/>value of its <strong class="source-inline">replicas</strong> field to <strong class="source-inline">2</strong>, save the file and exit, and that will cause the generated Portfolio deployment to be updated to have two pods:</p>
			<p class="source-code">  portfolio:</p>
			<p class="source-code">    <strong class="bold">replicas: 2</strong></p>
			<p class="source-code">    autoscale: false</p>
			<p class="source-code">    maxReplicas: 10</p>
			<p class="source-code">    cpuThreshold: 75</p>
			<p class="source-code">    image:</p>
			<p class="source-code">      repository: ibmstocktrader/portfolio</p>
			<p class="source-code">      tag: 1.0.0</p>
			<p class="source-code">    url: http://{{ .Release.Name }}-portfolio-      service:9080/portfolio</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Instead of hardcoding the number of replicas, you can also enable <strong class="bold">Horizontal Pod Autoscaling</strong> (<strong class="bold">HPA</strong>), which will <a id="_idIndexMarker1045"/>let Kubernetes dynamically decide how many replicas (pods) are needed, based on a specified CPU threshold and a specified maximum number of replicas. Use <strong class="source-inline">autoscale: true</strong> to enable HPA, and Kubernetes will scale up the number of pods if the threshold is met, and will scale back down when activity subsides.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor183"/>Upgrading a microservice</h2>
			<p>Another change you might want to make to a deployed Stock Trader instance is to upgrade to a newer <a id="_idIndexMarker1046"/>version of a given microservice. For example, if one of the developers built and pushed a new version of the Account microservice to your Docker image registry, you would use the operator to point at the new version. Again, you wouldn't directly edit the Account deployment, but would instead edit the <strong class="source-inline">Stock Trader CR yaml file</strong>, and then the operator would make the changes to the Account deployment on your behalf.</p>
			<p>If you had been <a id="_idIndexMarker1047"/>using the <strong class="source-inline">1.0.0</strong> tag for the image for the Account microservice, and you wanted to move up to the <strong class="source-inline">1.0.1</strong> version, you would use the aforementioned approach as you did for scaling, but this time, when you get the CR yaml into your <strong class="source-inline">nano</strong> editor, you would go down to the <strong class="bold">account</strong> section and edit the <strong class="bold">tag</strong> field to be <strong class="source-inline">1.0.1</strong>.  When you save <strong class="source-inline">CR yaml</strong> and exit the editor, the operator will update the Account deployment to use the new <strong class="source-inline">tag image</strong>. This will cause a new Account pod to be started using the <strong class="source-inline">1.0.1</strong> tag, and once it passes its readiness check, the original <strong class="source-inline">1.0.0</strong> level pod will be terminated (Kubernetes calls this a <strong class="bold">rolling upgrade</strong> since it avoids <a id="_idIndexMarker1048"/>any downtime during which no version of the application would be available):</p>
			<p class="source-code">  account:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    replicas: 1</p>
			<p class="source-code">    autoscale: false</p>
			<p class="source-code">    maxReplicas: 10</p>
			<p class="source-code">    cpuThreshold: 75</p>
			<p class="source-code">    image:</p>
			<p class="source-code">      repository: ibmstocktrader/account</p>
			<p class="source-code">      <strong class="bold">tag: 1.0.1</strong></p>
			<p class="source-code">    url: http://{{ .Release.Name }}-account-      service:9080/account</p>
			<p>By always acting upon the <strong class="source-inline">StockTrader CR yaml</strong> file as a whole, rather than having to worry about the generated yaml for each microservice, the operator keeps you focused at the level of the business application, while still giving you the flexibility to version the various pieces independently.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor184"/>Performing problem determination</h2>
			<p>Another thing you often will need to do with an application is to try to figure out what is going on when something isn't <a id="_idIndexMarker1049"/>working as expected. This process is called <strong class="bold">Problem Determination</strong> (<strong class="bold">PD</strong>), or is sometimes referred to as <strong class="bold">Root Cause Analysis</strong> (<strong class="bold">RCA</strong>) when doing a post-mortem to figure out what led to the failure. Again, the operator <a id="_idIndexMarker1050"/>can assist you here, such as by letting you turn on additional tracing in the Open Liberty container hosting each microservice.</p>
			<p>As before, you edit the CR yaml to effect such a change. There is a <strong class="source-inline">traceSpec</strong> field in the <strong class="source-inline">global</strong> section of the CR yaml that you'd edit to provide the desired trace specification. For example, if you wanted to turn on the fine-level trace for the Broker microservice, you would set the <strong class="source-inline">traceSpec</strong> field to the fully qualified class name of the Broker microservice, which is <strong class="source-inline">com.ibm.hybrid.cloud.sample.stocktrader.broker.BrokerService</strong>, to a value of <strong class="source-inline">fine</strong>. Note that you probably still want to keep <strong class="source-inline">info</strong> level trace on everything else, so you would use a colon to separate the two parts of the trace specification.</p>
			<p>Another thing you may want to do to assist with PD is to turn on JSON logging. This causes the logs to be output in a format that can be consumed by tools such as <em class="italic">ElasticSearch</em> so that you can easily filter through the logs coming from the various microservice pods in a single federated logging dashboard such as <em class="italic">Kibana</em>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The combination of <em class="italic">ElasticSearch</em>, <em class="italic">LogStash</em>, and <em class="italic">Kibana</em> is <a id="_idIndexMarker1051"/>often referred to as the <strong class="bold">ELK Stack</strong>; sometimes, <em class="italic">FluentD</em> is used instead of <em class="italic">LogStash</em>, so then the combination <a id="_idIndexMarker1052"/>is referred to as <strong class="bold">EFK</strong>; for details on <a id="_idIndexMarker1053"/>using the OperatorHub operators to set up <strong class="bold">ELK</strong>/<strong class="bold">EFK</strong> in your own cluster, see <a href="https://docs.openshift.com/container-platform/4.6/logging/cluster-logging-deploying.html">https://docs.openshift.com/container-platform/4.6/logging/cluster-logging-deploying.html</a>. Note that there are other more enterprise-quality log analysis tools too, such as <em class="italic">LogDNA</em> or <em class="italic">Instana</em>. </p>
			<p>Let's take a look at a <em class="italic">Kibana</em> dashboard:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B17377_09_21.jpg" alt="Figure 9.21 – A federated observability dashboard filtered for the IBM Stock Trader microservices&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – A federated observability dashboard filtered for the IBM Stock Trader microservices</p>
			<p>In <em class="italic">Figure 9.21</em>, we see log messages from the various microservices comprising the IBM Stock Trader application, interleaved based on the timestamp of when each JSON log message was sent. Being able <a id="_idIndexMarker1054"/>to see all of the logging coming from all of the microservices in a cloud-native appliction in one dashboard, rather than having to go and view each microservice's output separately, greatly enhances the problem determination experience.</p>
			<p>An additional benefit of JSON logging is that it gives you control over what sources send their logs to the log analysis tool for your Kubernetes cluster. In addition to choices such as HTTPS access logs or audit records, one of the choices is to send trace records there, as we just discussed with the <em class="italic">traceSpec</em> setting (otherwise, you'd have to <strong class="source-inline">kubectl cp</strong> the <strong class="source-inline">trace.log</strong> file off of the pod to investigate the trace log or mount your own <em class="italic">Persistent Volume</em> (<em class="italic">PV</em>) into the <strong class="source-inline">/logs</strong> location of the container and the trace log would go there):</p>
			<p class="source-code">  global:</p>
			<p class="source-code">    auth: basic</p>
			<p class="source-code">    healthCheck: true</p>
			<p class="source-code">    ingress: false</p>
			<p class="source-code">    istio: false</p>
			<p class="source-code">    istioNamespace: mesh</p>
			<p class="source-code">    route: true</p>
			<p class="source-code"><strong class="bold">    traceSpec: "com.ibm.hybrid.cloud.sample.stocktrader       .broker.BrokerService=fine:*=info"</strong></p>
			<p class="source-code"><strong class="bold">    jsonLogging: true</strong></p>
			<p class="source-code">    disableLogFiles: false</p>
			<p class="source-code">    monitoring: true</p>
			<p class="source-code">    specifyCerts: false</p>
			<p>There are many other <em class="italic">day 2</em> operations you can perform with the operator. But this should get the point across that the operator is the one in control of all configurations for your application, so it is used to effect any changes when needed.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor185"/>Summary</h1>
			<p>We've now explored some of the benefits of having an operator help you out with both deployment and day 2 operations of a composite application to your Kubernetes cluster. While it is possible to deploy a given microservice without the use of an operator, having one guiding you is like having a co-pilot suggesting good default values where appropriate so that you get your application deployed with optimal configuration settings. And having one in the post-deployment stage, helping you with <em class="italic">day 2</em> operations such as scaling, upgrading, and problem determination, ensures you have the best experience maintaining your application once it is in production use.</p>
			<p>We've now covered all of the core MicroProfile features and have shown them in use in a real-world microservices-based application running in a Kubernetes platform such as OCP. Going forward, the remaining chapters will cover some of the auxiliary MicroProfile features (such as reactive messaging) and will look ahead to the future of MicroProfile beyond the current 4.x state.</p>
		</div>
	</body></html>