<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Chapter 4: Best Practices for Design and Development </h1>
			<p>The developers reading this book have probably viewed the previous chapters as appetizers. If that's the case, with this chapter, we are moving on to the main course. While collecting requirements and designing the architecture are crucial steps (I cannot highlight this enough), anyone who comes from a development background will surely want to get their hands dirty with code.</p>
			<p>In this chapter, we will focus on how to implement the concepts that we have theorized so far in the source code. Of course, in the real world, the edges are not so smooth, and the architectural design (including <strong class="bold">UML</strong> or <strong class="bold">C4</strong> schemas) and requirements management will continue during the implementation phase. However, in this chapter, we will focus on some well-known techniques to translate those design ideas into working software.</p>
			<p>In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>Understanding <strong class="bold">Domain Driven Design</strong> (<strong class="bold">DDD</strong>)</li>
				<li>Introducing <strong class="bold">Test Driven Development</strong> (<strong class="bold">TDD</strong>)</li>
				<li>Exploring <strong class="bold">Behavior Driven Development</strong> (<strong class="bold">BDD</strong>)</li>
				<li>User story mapping and value slicing</li>
				<li>Case studies and examples</li>
			</ul>
			<p>After reading this chapter, you will be able to model complex use cases into elegant software concepts and define domains, objects, and patterns. You will learn how to use TDD and BDD to conduct development activities and implement meaningful use cases with each release. You will understand the concept of <strong class="bold">Minimum Viable Products</strong> (<strong class="bold">MVPs</strong>) and the technique of value slicing.</p>
			<p>But first, we'll start with DDD, which will provide a solid foundation to build upon.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Understanding Domain Driven Design</h1>
			<p>DDD takes its<a id="_idIndexMarker389"/> name from the book of the same name by Eric Evans (2003). The subtitle beautifully clarifies what the goal is—<strong class="bold">Tackling complexity in the heart of software</strong>.</p>
			<p>In this section, we will learn about the domain model, ubiquitous language, layered architecture, DDD patterns, and bounded contexts. </p>
			<p>DDD is a widely adopted modeling technique to build rich and expressive domains. It is considered to be behind modern approaches such as microservices development.</p>
			<p>The idea behind DDD is discovering how to model our software in a way that mirrors the problem we are facing in the real world. It is expected that if properly modeled, our software will be readable, will adhere to requirements, and will work properly. </p>
			<p>Of course, there is no magic recipe for that: DDD provides a toolkit of patterns, best practices, and ideas to implement this modeling. This approach works particularly well with complex domains, but it might be overkill for smaller and simpler projects. Additionally, it is true that DDD provides a lot of good ideas, and you might consider adopting it partially if that fits your needs. But first, let's begin with some considerations about the completeness of the domain model.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor091"/>The anemic domain model</h2>
			<p>In his seminal<a id="_idIndexMarker390"/> paper about this domain model, Martin Fowler defines the <strong class="bold">anemic domain model</strong> as an antipattern, which defies any basic purpose <a id="_idIndexMarker391"/>of <strong class="bold">object-oriented programming</strong>. Of course, I cannot disagree with that at all. Nevertheless, this kind of modeling is far too widespread, as it's a kind of quick and dirty way to design an application.</p>
			<p>Essentially, in the anemic domain model, each object maps with its real-world counterpart, including fields and relationships. Those are, in a way, kinds of data objects. What's missing in the anemic domain model's objects is the behavior, meaning the specific actions that are logically associated with that particular concept in the real world. Usually, the objects in an anemic domain model have getter and setter methods, and not much more. All of the behavior is codified as part of specific service objects, operating across all of the other data objects through specific methods.</p>
			<p>The issue, here, is that the domain model is simply slipping away from object-oriented programming and toward an overengineered procedural model. This could be good enough in simple scenarios and, indeed, is common in <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) applications <a id="_idIndexMarker392"/>over a relational database, where you are, more or less, exposing tables directly as an application, with very limited business logic on top.</p>
			<p>If the model is bigger, and it encompasses more complete business logic, this way of modeling starts to show some limits. The data objects become similar, and it's harder to group them and define relationships. The service objects have more and more methods, with growing complexity. You start to gain the cons of both the procedural and object-oriented methods. After all, you have very few (if any) of the pros of object-oriented modeling. DDD aims for the opposite—building rich and expressive object-oriented <a id="_idIndexMarker393"/>designs. Let's examine how to start modeling applications on DDD principles.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor092"/>Understanding ubiquitous language</h2>
			<p>Indeed, the very<a id="_idIndexMarker394"/> first concept of DDD is the principle of good collaboration. To define a good domain model, you have to use both technical language and business language.</p>
			<p>This means having a team composed of domain experts besides software developers. <em class="italic">But how will those kinds of people cooperate when they speak different languages?</em> You will require a lingua franca to ensure they work together.</p>
			<p>The concept around the ubiquitous language is simple and brilliant, that is, to define a shared dictionary for a business (for instance, analysts, domain experts, or whoever you want to include) and developers to talk together with fewer misunderstandings. However, it's a kind of abstract concept, and there is no magic recipe to achieve it. You can think about it as a shared culture built into the team. Unfortunately, no one has defined a template document or a kind of diagram that can solve the ubiquitous language challenge for everybody. </p>
			<p>Indeed, what's advised in DDD's essential literature is to use UML diagrams (especially class diagrams) and written documents (no particular format is required). However, what's essential is how you get to the shared understanding of ubiquitous language, and there is probably only one way to do this—by working together.</p>
			<p>Ubiquitous language is all about how to name the concepts in your model properly. And by concepts, we are not necessarily referring to <strong class="bold">Java</strong> classes (as they are an implementation detail), nor to business processes (as, perhaps, they are not mapped one to one in our application). We are referring to something in the middle, that is, a model that is understandable and makes sense for a business and is translatable in meaningful ways into software artifacts by developers.</p>
			<p>Of course, the model will comprehend objects, the relationships behind them, and the actions they perform. It is also essential for the team to share the meanings of each operation. Simply defining the name of each interaction might not solve any ambiguities. Once a shared understanding has been reached (it might be a recurrent effort with many cycles), then it must be strictly respected.</p>
			<p>This includes using the naming consistently in code and in all of the other artifacts produced (such as analysis documents, test plans, and more), as well as referring to things with the right name in meetings and documenting this shared understanding in some way (as I said, the format is up to you). As we discussed earlier, ubiquitous language is all about creating a shared culture in a working team across different specialties.</p>
			<p>The concept might <a id="_idIndexMarker395"/>appear abstract; nevertheless, it is essential and can be a useful tool even if you are not fully going with DDD. However, DDD also defines more concrete concepts, such as <strong class="bold">layered architecture</strong>, which we will look at in the next section.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor093"/>Getting familiar with layered architecture</h2>
			<p>When we<a id="_idIndexMarker396"/> start to define the conceptual model around our application, it's natural to wonder where this model practically fits in our implementation and how to keep it pure, regardless of the technology we are using. Think about persistence (the database), the <strong class="bold">User Interface</strong> (<strong class="bold">UI</strong>), and such. Those technologies probably have constructs that differ from our model. They might not even be object-oriented at all. And for sure, we don't want a change driven by technological reasons (such as the optimization of a query or a change in the UI) to affect our domain model. DDD tackles this concept directly by suggesting a layered architecture approach.</p>
			<p>Here, the idea is to partition the application code into different layers, loosely coupled to each other. Then, you implement your domain model into one of those layers, encapsulating the technological details in the other layers, each one with well-defined responsibilities.</p>
			<p>A simple and common example of this is with the four layers divided, as follows:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.01_B16354.jpg" alt="Figure 4.1 – Layered architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – Layered architecture</p>
			<p>As you can see, the layered<a id="_idIndexMarker397"/> architecture is divided as follows:</p>
			<ul>
				<li><strong class="bold">Presentation Layer</strong>: This layer includes all of the code required to present and collect the data for users. Additionally, this could include machine-to-machine interactions (such as in API calls).</li>
				<li><strong class="bold">Application Layer</strong>: This layer is similar to what's implemented in the <strong class="bold">Backends for Frontends</strong> pattern (we'll cover this in <a href="B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Essential Java Architectural Patterns</em>). Essentially, this layer is a proxy, stateless and without business logic, which simply coordinates the interactions between the presentation layer and the rest of the application.</li>
			</ul>
			<p>The application layer can store session data and perform basic orchestration (such as aggregating or ordering calls to the underlying layers). In my opinion, this layer can be considered optional in some kinds of applications. The risk is that if you avoid it, it will couple the presentation layer tightly to the rest of the architecture. On the other hand, if you decide to adopt it, you should be mindful of the risk of sneaking in too much business logic.</p>
			<ul>
				<li><strong class="bold">Domain Layer</strong>: This layer is, of course, the core of proper DDD. Here lies the whole business model, adherent to what we are representing, in terms of objects, their state, and their behavior. The domain layer exposes the functionalities of the higher levels and uses the underlying layer for technical matters.</li>
				<li><strong class="bold">Infrastructure Layer</strong>: This layer is a supporting layer that deals with all of the other layers. It can be defined as the glue between the layers themselves and the technological layers providing functionalities. Here, a classic feature is persistence—objects in the domain layer use features exposed by the infrastructure layer, which deals with the database (or other persistent technology) using its native protocols and libraries.</li>
			</ul>
			<p>This organization might look familiar to you, as it's described in various forms and variants in the software area (you might find some similarities with the <strong class="bold">Model-View-Controller</strong> pattern, which<a id="_idIndexMarker398"/> we will examine in <a href="B16354_06_Final_JM_ePUB.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Essential Java Architectural Patterns</em>). However, do take into account that this is mostly a way to nicely group <a id="_idIndexMarker399"/>responsibilities. It doesn't necessarily mean that each layer should be deployed on its own, as a separate process or artifact.</p>
			<p>Having discussed layered architecture, let's focus on the heart of DDD: the <strong class="bold">Domain Model</strong> and its parts.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor094"/>Learning about the domain model</h2>
			<p>The <strong class="bold">Domain Model</strong> is an<a id="_idIndexMarker400"/> elegant way to represent reality and implement it in an object-oriented way.</p>
			<p>Essentially, you can consider the domain model as the opposite of the anemic model that we looked at earlier. In the anemic model, the objects simply include data and very limited (or even absent) behavior. The domain model of DDD stresses the expressiveness of objects and their behavior.</p>
			<p>Put simply, the domain model is simply the concept of comprehending the data and behavior of an application. DDD implements this idea by defining the elements detailed in the following sections, as shown here:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.02_B16354.jpg" alt="Figure 4.2 – The domain model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The domain model</p>
			<p>We will discuss <a id="_idIndexMarker401"/>each of the sections next.</p>
			<h3>Entities</h3>
			<p>The <strong class="bold">entity</strong> is a <a id="_idIndexMarker402"/>core<a id="_idIndexMarker403"/> concept of the domain model. Essentially, it is related to modeling objects that have an identity and a history throughout the life cycle of our use case. The keyword for defining an entity is <strong class="bold">identity</strong>.</p>
			<p>If an object in our use case has a strong identity concept, it will probably map with entities. A classic example is a person: in many use cases (including the mobile payments example that we are carrying throughout this book), a person's identity is strongly defined, regardless of the values contained in its representing objects. In other words, if I have a person object, made up of the classic name, surname, and other details, having two objects with the same name and surname does not necessarily mean I am referring to the same person.</p>
			<p>Indeed, I often resort to specific identifying fields (such as a tax code or something specific to my application domain—perhaps an account number) to distinguish a person object from another one. Moreover, the identity concept will still be valid even if the object is persisted (and retrieved). In other words, if I persist (or passivate) an entity object somewhere (such as in a database), it should be clear that it will refer to the same person (in real life) when it's loaded again.</p>
			<p>As is clear, defining an entity is a cross-cutting concern between a business and the developers. It is much more than simply identifying a unique field distinguishing objects from one another. Consider bank accounts: they are usually identified by a standard code that is internationally recognized, at the very least, across Europe (IBAN code). However, you might find that a bank account changes the associated IBAN code (such as when a merger between different banks occurs). In this case, <em class="italic">do the two IBAN codes refer to the same account?</em> <em class="italic">Will the old account disappear and be replaced by a new one?</em> <em class="italic">Should I instead use a third identifier (such as a UUID) to bridge between the two entities and bypass the problem?</em></p>
			<p>Usually, the answer is that it depends. In this scenario, it depends on the domain around which your use case is modeled. The identity concept can also be different in the same application (in an extended way). Ultimately, an entity object is very much related to the point of view you are considering. However, for sure, it needs to be an object with a very well-defined <a id="_idIndexMarker404"/>identity, regardless of the value of its attributes, which <a id="_idIndexMarker405"/>links us to a different kind of object—<strong class="bold">value objects</strong>.</p>
			<h3>Value objects</h3>
			<p>Conceptually, value <a id="_idIndexMarker406"/>objects<a id="_idIndexMarker407"/> complement entity objects. Simply put, in a value object, the data inside the fields of the object is more important than the object's identity. Value objects simply transport information, and they can be shared, copied, and reused with ease. A typical example of a value object is an address (such as a city, street name, or zip code). It doesn't matter what the identity of each one is; what does matter is the data inside.</p>
			<p>Value objects should be immutable. Because they are immutable, they are simpler to use. One common example is multithreading: multiple threads can access the same object instance concurrently, and there is no need for locks, nor any risk of inconsistent value (as the value cannot be changed). It's the same with passing object instances to methods: you can be sure that whatever happens, the value of the object cannot be changed. Essentially, with immutable objects, the life cycle is just easier to manage.</p>
			<p>Value objects are usually lighter and safer to manage than entity objects. Additionally, they can be part of an entity, that is, our person entity might have a link to an address value object. However, you should balance the usage of entities and value objects. If you only resort to value objects, you will probably fall into an anemic domain. There is still an important thing to discuss regarding object content, that is, <em class="italic">where can we put the behavior that doesn't belong to either entities or value objects?</em> The answer is <strong class="bold">services</strong>.</p>
			<h3>Services</h3>
			<p>As <a id="_idIndexMarker408"/>mentioned<a id="_idIndexMarker409"/> earlier, entities and value objects are different in terms of identity. Instead, they share the grouping around a logical area, including data and behavior. In other words, both entities and value objects contain data (class attributes), the methods for manipulating it (getters and setters), and more sophisticated behavior (the business logic).</p>
			<p>What's missing in this model is the cross-cutting behavior. Indeed, there are some actions that don't feel right when placed in a particular object. That's because those actions involve more than an object type, or they are simply ambiguous. It's important to not force those actions into an unrelated object, as this will impact the expressiveness of the model. Let's think about our mobile payment example again. <em class="italic">Should we put the peer-to-peer payment functionality in the sender or receiver account?</em> </p>
			<p>For all of these scenarios, you can define a <strong class="bold">service</strong>. A service explicitly maps actions that are directly linked to the domain as a whole, rather than to a specific object type. In this way, you can nicely group similar actions together without polluting entities or value objects with behavior that doesn't belong there. It's all about keeping the domain model rationally organized, which is also the goal of the next concept: the <strong class="bold">aggregate</strong>.</p>
			<h3>Aggregates</h3>
			<p>We <a id="_idIndexMarker410"/>mentioned <a id="_idIndexMarker411"/>the concept of <strong class="bold">aggregates</strong> in <a href="B16354_02_Final_JM_ePUB.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Software Requirements – Collecting, Documenting, Managing</em>, when discussing event storming. It's worth saying that the whole idea of event storming is strictly related to DDD and one of the ways to put DDD into practice.</p>
			<p>Let's return to the concept of aggregates; it's probably one of the most widely known ideas of DDD, and it's also widely used outside of DDD. Put simply, aggregates can be seen as transactional boundaries. The basic idea is to group a set of objects (that is, entities and/or value objects) by data changes. The objects in an aggregate are considered as a whole when it comes to changes to their internal status.</p>
			<p>An aggregate has an entry point <a id="_idIndexMarker412"/>object, called a <strong class="bold">root entity</strong>. Any change to any object part of the aggregate must be carried out through the root entity, which will then perform changes on the linked entities. That's from a technical point of view rather than a domain model point of view. What you are doing is invoking operations (or, even better, actions that are as meaningful in the real world as in the domain model) in the root entity.</p>
			<p>This will also mean changing the linked objects under the hood. However, this is an implementation detail. From a logical standpoint, all of the interactions with objects in the aggregate are mediated by the root entity. For this reason, the aggregate is a core concept in DDD. It strictly maps the consistency of the model and can be easily translated into technical concepts such as database transactions. Aggregates can then be seen as a sort of <strong class="bold">super object</strong> made by the coordination of different objects. As such, the construction of an aggregate can become complex. For this reason, DDD introduces<a id="_idIndexMarker413"/> the <strong class="bold">Factory pattern</strong>.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor095"/>Glancing at DDD patterns</h2>
			<p>DDD encompasses<a id="_idIndexMarker414"/> some patterns to provide support functionalities for the domain model, such as building and managing objects (such as entities and value objects). The factory pattern is the first pattern that we will look at.</p>
			<h3>Factory</h3>
			<p>The <strong class="bold">factory</strong> pattern<a id="_idIndexMarker415"/> is not a <a id="_idIndexMarker416"/>new concept. You can refer to the <em class="italic">Design Patterns</em> book by the Gang of Four, where this has been widely explained. Simply put, if you want to programmatically control the creation of an object (or a set of objects such as an aggregate), and not rely on the logic of a constructor, you can use the factory pattern.</p>
			<p>Factory is particularly useful to instantiate an aggregate. By invoking the factory pattern on the root element, you will coordinate the creation of the root itself and all of the other objects linked to the root (entities and value objects). Additionally, you can enforce transactionality on the creation of the objects.</p>
			<p>If the creation of one of the objects fails, then you might want to abort the creation of the whole aggregate. The factory pattern can also be used to recreate objects from the database. In this scenario, rather than an instantiation from scratch, it's a retrieval of the existing root entity (and the linked subobjects). That's fine for addressing the retrieval of a known object (given its identity), <em class="italic">but how do you provide different kinds of lookups?</em> DDD suggests the usage of the <strong class="bold">Repository pattern</strong>.</p>
			<h3>Repository</h3>
			<p>A <strong class="bold">repository</strong>, in the <a id="_idIndexMarker417"/>DDD<a id="_idIndexMarker418"/> world, is a registry that is used to keep references to objects already instantiated (or persisted on a database). Simply put, a repository can be used to add, remove, and find objects. When used to find objects, typically, a repository acts as a bridge between the domain and the infrastructure layer. </p>
			<p>It helps to decouple the features and hide the implementation details of the persistence layer. You can retrieve objects using complex or vendor-specific queries in the infrastructure layer, and this is wrapped by an operation in the repository. It might even be that the infrastructure layer retrieves objects in different ways, such as invoking external web services rather than a database. Nothing will change from a repository point of view. The services exposed by the repository must have an explicit domain meaning, whereas the internal implementation might appear closer to the infrastructure logic.</p>
			<p>So far, in all of the concepts that we have examined, we have implicitly assumed that everything falls under one single domain model. Now, we will learn how to make different domains interact with each other by using the concept of a <strong class="bold">Bounded Context</strong>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Bounded Context</h2>
			<p>It is common <a id="_idIndexMarker419"/>to <a id="_idIndexMarker420"/>identify a domain model using one application. That's a hard way to delimit the model boundaries. However, that's not always the case. When dealing with large applications, it could be that different models need to coexist. This is because a unified model is impractical (that is, too big or too complex), or because of the model's conflict (that is, an object has different meanings, depending on the point of view and the use cases touching it).</p>
			<p>In those scenarios, you might need to define a border around each domain model. A bounded context, then, is the area in which ubiquitous language is valid. If a bounded context can be seen as a country, with defined borders, ubiquitous language is the official (and only) language spoken of that country.</p>
			<p>Usually, a bounded context belongs to one team, and it has some well-defined coordinates, such as a portion of the code base and other subsets of related technologies (such as a defined set of tables of the database). Two different bounded contexts cannot share objects, nor call arbitrary methods of each other. The communication must follow well-defined interfaces. In order to support the cooperation between two different bounded contexts, a context map can be used.</p>
			<p>A context map is a way to translate, when possible, concepts from one bounded context to another. There are some patterns suggested by DDD to realize context maps. These patterns include the following:</p>
			<ul>
				<li><strong class="bold">Shared kernel</strong>: This is when two bounded contexts share a subset of the domain model. While this technique is easy and intuitive, it can be hard to maintain, since the two teams managing the different bounded contexts must agree on any changes, and in any case, the risk of breaking functionalities in the other context is always present, so every change must be thoroughly tested (automatic is better).</li>
				<li><strong class="bold">Customer supplier</strong>: This is similar, in a way, to the shared kernel approach, but the relationship here is asymmetrical. One of the two bounded contexts (the supplier) will own the interface, developing and maintaining the features, while the <a id="_idIndexMarker421"/>customer <a id="_idIndexMarker422"/>will simply ask for what is needed. This simplifies the synchronization a bit between the two teams. However, it can still create issues when priorities and milestones start to clash.</li>
				<li><strong class="bold">Conformity</strong>: This shares the customer-supplier type of relationship. The difference here is that the customer domain model completely adopts and imports a subset of the supplier domain model, as it did in the shared kernel approach. However, unlike shared kernel, the relationship stays asymmetric. This means that the customer cannot change (or ask for changes in) the shared model.</li>
				<li><strong class="bold">Anti-corruption layer</strong>: This is a different approach. In this case, there is a translator layer between the two domain objects. This layer acts as a demilitarized zone, preventing objects and behaviors from sneaking from one bounded context to another. This approach is commonly used when dealing with legacy applications, more than when two bounded contexts belong to the same application.</li>
			</ul>
			<p>It is worth noting that a proper DDD implementation is not easy to follow. There are several common errors that could slip into a DDD architectural design. The first and most common is the aforementioned anemic domain model, which is the most important reason why you would want to adopt something like DDD. However, it's also common to have some technology considerations slip into the domain model.</p>
			<p>That's particularly true when it comes to the <strong class="bold">persistent layer</strong>. It is a common practice to design the domain in a way that mimics the database tables and relationships (in this case, we are using a relational database as a persistent backend). Last but not least, one common error is to design the domain model without engaging with domain experts.</p>
			<p>We could be tempted to design everything for the IT department, thinking we have a proper understanding of the world we would like to represent. Even if this is partially true, it's still worthwhile engaging with business experts, to better discuss the business jargon (please refer to the <em class="italic">Understanding ubiquitous language</em> section) and rely on their experience of the specific domain model.</p>
			<p>This section <a id="_idIndexMarker423"/>concludes our brief overview of DDD. As we have learned, DDD provides elegant ways in which to realize the ideas we have collected in the previous sections (including requirements and architectural designs) and put them into code. </p>
			<p>This starts with the concept of ubiquitous language, which we discussed at the beginning of this section and is one of the big ideas of DDD, allowing common ground between all the stakeholders involved in the application development.</p>
			<p>Following this, we moved on to the core concepts of DDD, such as the application <em class="italic">shape</em> (the layered architecture), the definition of objects and methods (the domain model and the encompassed objects), and the recommended practices (patterns) regarding how to address common concerns. A dedicated mention is needed for the concept of bounded contexts, which is a way to structure big applications into more than one <em class="italic">self-contained</em> model.</p>
			<p>As we will learn in <a href="B16354_09_Final_JM_ePUB.xhtml#_idTextAnchor230"><em class="italic">Chapter 9</em></a>, <em class="italic">Designing Cloud-Native Architectures</em>, DDD has some common ideas with microservices architectures.</p>
			<p>In the next section, we will look at another common practice to drive the implementation of our design ideas—TDD.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/>Introducing Test Driven Development</h1>
			<p>TDD is a<a id="_idIndexMarker424"/> development technique based on a simple idea, that is, no code should exist without test coverage. </p>
			<p>In order to pursue this goal, TDD inverts our point of view. Instead of developing code, and then writing a unit test to cover its testing, you should start writing a test case. Of course, initially, the test case would intentionally fail while invocating empty or incomplete functions. However, you will have a clear goal, that is, your piece of code is complete when all tests are satisfied.</p>
			<p>Starting from the end, you clearly define the boundaries of your software and the extent of its functions. Then, you run the tests, which will all fail. You keep developing the features, piece after piece, until all of the tests are satisfied. Finally, you move to the next piece of code (or class or package)—it's that simple.</p>
			<p>Remember that this approach doesn't necessarily guarantee any particular quality or elegance in your code. Having a test pass does not imply that you are using good patterns or efficient solutions. In theory, you might as well simply hardcode the expected results to get a green light.</p>
			<p>However, this technique will have a very useful byproduct, that is, you can't forget (or purposefully avoid) to prove/test your code using test cases.</p>
			<p>Anyway, there are several factors to take into account. First of all, some features might require external systems to work. You can test the interaction of such systems, simulating them with mocks, but of course, this will mean more code to write, more components (the mocks themselves), and a further degree of approximation (meaning that your test will be less representative of reality). Following this, you might need to test things that are less easy to automate, such as UIs and interactions with devices (for example, mobile devices). Yes, there are a number of solutions for this (such as automating browser navigation), but this will complicate things. </p>
			<p>Let me highlight that, even if this will require a significant amount of effort, tests cannot be ditched. Testability is a crucial requirement, and it might also be a drive to rearchitect your code base, increasing modularity and simplifying it, in order to improve testability.</p>
			<p>Moreover, you might have dependencies between the features. This means coordinating tests or, worse, having test results depend on the order in which they are running. Of course, this is not easy to maintain and, in general, is not a good idea.</p>
			<p>In this specific case, you might want to properly structure your tests, in order to provide adequate setup and teardown phases, making everything simpler and reproducible and greatly increasing the quality of what you are testing. Then, you have to think about the granularity of the tests. It can be tempting to create one generic test and slip in as many hidden features as you can. On the other hand, if your tests are simply unit tests, covering every sub-function, you'll need to aggregate them in a meaningful way, in order to track down the advancements in implementing the features. In other words, shifting your <a id="_idIndexMarker425"/>point of view away from testing specific code sections toward testing application behavior.</p>
			<p>This is the idea behind BDD.</p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor098"/>Exploring Behavior Driven Development</h1>
			<p>BDD is a<a id="_idIndexMarker426"/> technique that extends the TDD approach while also using some DDD concepts. In particular, the workflow is the same as TDD, that is, write a test, run it (initially, it will fail), and implement the feature until the test succeeds.</p>
			<p>What changes is how the test is written. Instead of focusing on single functions (or, even better, relying on the developer to pick the right granularity), BDD defines the extent of each test a bit better. In particular, as highlighted in the name of the methodology, BDD tests are focused on the expected behavior, that is, the functionality implemented by each use case.</p>
			<p>In this sense, it is an explicit suggestion to keep high-level functionalities, rather than method-by-method unit tests. BDD is also linked to DDD concepts. In particular, it is recommended that you use ubiquitous language as a way to specify each behavior. In this way, you have an explicit mapping between a business use case, expressed with ubiquitous language, translated into an automatic test case. </p>
			<p>BDD describes a way to define behaviors. In practice, each behavior is defined as a user story, with a structure given as follows:</p>
			<ul>
				<li><strong class="bold">As a</strong>: This is a person or a role.</li>
				<li><strong class="bold">I want</strong>: This is a specific functionality.</li>
				<li><strong class="bold">So that</strong>: This is when we can get some benefits from using that functionality.</li>
			</ul>
			<p>Provided that a number of scenarios are associated with the user story, each scenario is, essentially, an acceptance criterion, which can be easily translated into automated use cases:</p>
			<ul>
				<li><strong class="bold">Given</strong>: This is used for one or more initial conditions.</li>
				<li><strong class="bold">When</strong>: This is used for when something happens.</li>
				<li><strong class="bold">Then</strong>: This is used for when one or more results are expected.</li>
			</ul>
			<p>This structure is very self-explanatory. By using a similar template, and sticking to ubiquitous language, you will have a straightforward way in which to define use cases. It is a way that is meaningful for non-technical people and can be easily translated to automated use cases by technical people.</p>
			<p>Walking backward, you implement code that will gradually cover the test cases, mapping to a behavior specification that will give direct feedback to the business on which use cases are complete.</p>
			<p>This approach offers a structured way to understand what we are implementing and possibly select <a id="_idIndexMarker427"/>and prioritize the user story to approach as a development team. This is also the focus of the practice that we will look at in the next section.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Comparing DDD, TDD, and BDD</h2>
			<p>So far, we<a id="_idIndexMarker428"/> have<a id="_idIndexMarker429"/> rapidly <a id="_idIndexMarker430"/>discussed<a id="_idIndexMarker431"/> three <a id="_idIndexMarker432"/>different "Something-Driven<a id="_idIndexMarker433"/> Development" techniques. It must be clear that such practices should not necessarily be seen as alternatives, but they might have some complementarity.</p>
			<p>In particular, DDD relates more to the modeling of the application domain. In this sense, it can be observed from a more architectural point of view, defining how our application is modularized, the different layers, and even how different parts of our broader application (or, if you wish, different teams) should cooperate.</p>
			<p>Once we have designed such layers and components, both TDD and BDD can be used as a way to drive our day-to-day development, ensuring we have the right testability and feature coverage requested within our code.</p>
			<p>On the other hand, DDD is not a requirement for TDD or BDD, which can be seen as a simple technique that is also applicable to smaller applications, or to software architectures defined with approaches alternative to DDD. As you will often find in this book, those<a id="_idIndexMarker434"/> concepts<a id="_idIndexMarker435"/> can <a id="_idIndexMarker436"/>be viewed <a id="_idIndexMarker437"/>as tools, briefly introduced to give you an idea of their <a id="_idIndexMarker438"/>potentiality. It's<a id="_idIndexMarker439"/> up to you to then take what's needed for your specific project and combine it in a useful way.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor100"/>Learning about user story mapping</h1>
			<p><strong class="bold">User story mapping</strong> is a<a id="_idIndexMarker440"/> way to put user stories into context, identify what it takes to implement them, and plan accordingly. </p>
			<p>In this section, we will learn what a user story is and how it can be used as a planning method, in order to choose what features to include in each release, following a meaningful pace.</p>
			<p>The user story is the same concept that we saw as part of BDD. So, it describes a feature from the point of view of a specific persona (<strong class="bold">As a</strong>...), the functionalities required (<strong class="bold">I want to</strong>...), and the expected outcome (<strong class="bold">So that</strong>...).</p>
			<p>As you might observe, all pieces in the puzzle of those seemingly unrelated practices eventually start to match. User story mapping is often described as a <strong class="bold">product backlog</strong> on steroids. </p>
			<p>We will discuss product backlogs in the next chapter. However, for now, consider them as lists of features to implement. Features are added as long as analysis occurs (or new requirements arise). These are then prioritized and picked by the development team to be implemented.</p>
			<p>User story mapping extends this approach by giving more dimensions to the product backlog, enriching the information related to each feature, and linking it to a broader vision of the product. User stories stay on top of the mapping. They describe the high-level features that a system should provide. User stories are organized in a horizontal line and ordered by both importance and the temporal sequence in which they happen, all from the user's point of view.</p>
			<p>For each user story, a list of tasks is provided. Essentially, these are the sub-features (also known as <strong class="bold">activities</strong>) that<a id="_idIndexMarker441"/> each user story encompasses. So, we are detailing each feature, but not yet coming to a level of detail that can be directly mapped into software (at least, not easily). Each task is then attached to a list of subtasks (or task details), which are easier to<a id="_idIndexMarker442"/> map to software features. This is what user story mapping looks like:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.03_B16354.jpg" alt="Figure 4.3 – User story mapping"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – User story mapping</p>
			<p>The interesting thing about this model is that you will not have to prioritize the tasks. You just need everything included there (sooner or later); however, you can prioritize the subtasks, gradually improving the completeness of each task, release after release.</p>
			<p>This model has a series of positive outcomes. First of all, as with BDD, you have a direct mapping between the subtask the development team is working on and the user story (or activity). Essentially, it gives visibility to the business regarding the finish line toward which we are rowing. Moreover, an interesting practice is applicable to this matrix of tasks and subtasks, namely, <strong class="bold">value slicing</strong>. This <a id="_idIndexMarker443"/>means picking what to implement for each release.</p>
			<p>Given that you will have a finite number of resources (such as programmers, time, and whatever else is required to implement each subtask), you cannot, of course, deliver everything in one release. Well, you could, but it would be risky since you would have to wait a long time before receiving feedback and being able to test the software. We will elaborate more on the <strong class="bold">release early, release often approach</strong> (the well-known incremental product releases technique that is widely used in <strong class="bold">Agile</strong> and <strong class="bold">DevOps</strong>) in the next chapter. </p>
			<p>For now, what matters is that it is better to release value incrementally, by picking the subtasks that implement, at least partially, one or more tasks and then the related user stories. Here is <a id="_idIndexMarker444"/>what this would look like compared to <em class="italic">Figure 4.3</em>:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.04_B16354.jpg" alt="Figure 4.4 – Value slicing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Value slicing</p>
			<p>As you can see, the approach here is oriented toward an MVP.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor101"/>The MVP</h2>
			<p>The concept<a id="_idIndexMarker445"/> of MVP <a id="_idIndexMarker446"/>deserves some additional explanation. The term was created before the user story mapping technique and is an independent idea. It is also applicable to products that are different from the software code. The goal of the MVP is to maximize the value of the product (in terms of return of investment or, trivially, how useful, popular, and beneficial your product will be) while minimizing the risks and efforts required to build it. The perfect MVP requires a very low level of effort and risk to build, but it can become greatly popular and appreciated when used (and, optionally, sold).</p>
			<p>The purpose of an MVP is to start getting feedback on the product from potential end users (usually, a subset of early adopters). Due to this, the MVP should contain a meaningful subset of features: not too many, to avoid wasting effort in case the product is not well received by customers, but just enough in order to represent what the complete product will be like. Early feedback, in the spirit of Agile development methodologies, could also be beneficial if some steering is required in the product direction, by stressing more on one aspect or another.</p>
			<p>In this section, we learned about user story mapping, which is the final technique we will explore in this chapter. In the next section, we will examine some examples of those approaches, as applied to our mobile payments use case.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor102"/>Case studies and examples</h1>
			<p>As is easy to imagine, a complete and extensive example of DDD, TDD, BDD, and user story mapping, applied to our mobile payments case study, could easily take more than one book. For this reason, as we mentioned in <a href="B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Common Architecture Design Techniques</em>, unfortunately, we can only look at some highlights of those techniques used in our example. However, in this section, I think it is pretty useful to take a look at, even if to just practically visualize some concepts that might appear abstract so far.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/>The mobile payments domain model</h2>
			<p>In <a href="B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Common Architecture Design Techniques</em>, we<a id="_idIndexMarker447"/> looked at the basic modeling of mobile payment objects based on the UML notation. To elaborate more on this, in DDD, you will mostly have the following concepts:</p>
			<ul>
				<li>The user is an entity. This concept is pretty straightforward, that is, the identity is very well defined, and each user has a well-defined life cycle (from registration to deletion).</li>
				<li>Payment is an entity, too. Each user will want to keep track of exactly each transaction, including the time, the amount, the receiver, and more. It is also likely that there will be regulations for you to uniquely identify each payment transaction.</li>
				<li>As we've already mentioned, a peer-to-peer payment is out of place as a method, both in the sender and receiver entity. So, it is probably worth modeling a payment service that can also work as a bridge toward classical CRUD operations in the infrastructure layer.</li>
				<li>On the assumption that our application is operating on a global scale, you will need to manage transactions in different currencies. <strong class="source-inline">ExchangeRate</strong> is a typical example of a value object. It is immutable and composed of currency symbols and a number representing the exchange rate. It is a disposable object and can <a id="_idIndexMarker448"/>be easily shared between different payments, as no identity (nor state) is considered.</li>
			</ul>
			<p>Once we have defined (a very small subset of) the domain model of mobile payments, we are going to look at the layered architecture of this application.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>The layered architecture of mobile payments</h2>
			<p>If you <a id="_idIndexMarker449"/>remember <a id="_idIndexMarker450"/>the diagrams designed in <a href="B16354_01_Final_JM_ePUB.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Designing Software Architectures in Java – Methods and Styles</em>, and the C4 model drafted in <a href="B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Common Architecture Design Techniques</em>, you are already familiar with some of the technical components that implement our mobile payment architecture.</p>
			<p>There, the mapping between components was pretty much coarse-grained. This is because you would associate the mobile application with the <strong class="bold">Presentation Layer</strong>, the business logic with the <strong class="bold">Domain Layer</strong>, and so on. However, with DDD, we are progressing further with the analysis of our application. We are going one level down toward something similar to the <strong class="bold">C4 Container</strong> diagram (please refer to <em class="italic">Figure 3.8</em> in <a href="B16354_03_Final_JM_ePUB.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Common Architecture Design Techniques</em>) but from a different point of view. My idea of the layered architecture of our application looks similar to the following diagram:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.05_B16354.jpg" alt="Figure 4.5 – The DDD layered architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – The DDD layered architecture</p>
			<p>From<a id="_idIndexMarker451"/> the<a id="_idIndexMarker452"/> preceding diagram, you might observe the following:</p>
			<ul>
				<li>All of the views in the <strong class="bold">Presentation Layer</strong> are a subset of the mobile application functionalities. You will probably have more functionalities in the real world. However, it's interesting to observe how some concepts of the <strong class="bold">Domain Layer</strong> (hence, the ubiquitous language) are echoed here. Yet, this is a pretty technical layer, so it does not strictly observe the ubiquitous language.</li>
				<li>The <strong class="bold">Application Layer</strong> is a support area, decoupling the needs of the frontend with the services provided by the domain model in the <strong class="bold">Domain Layer</strong>. The relationship with the <strong class="bold">Presentation Layer</strong> is not one-to-one in this case, but that's up to you to decide according to your context. Additionally, this layer has a dependency on the <strong class="bold">Domain Layer</strong>.</li>
				<li>In the <strong class="bold">Domain Layer</strong>, we strictly map our domain model. So, the ubiquitous language here is prevalent. Also, this layer should not have a dependency on the neighboring layers in order to stay technologically independent as much as possible (for the sake of clarity, <strong class="source-inline">ExchangeRate</strong> is not represented).</li>
				<li>The <strong class="bold">Infrastructure Layer</strong> is the technological glue, providing services to other layers, and abstracting technology-specific details. So, in this case, you can see that <strong class="bold">UserRepo</strong> will mediate calls to IDM and other systems (for example, databases or CRMs), while <strong class="bold">TransactionDataAdapter</strong> abstracts calls to databases and legacy systems. Consider that in this scenario, there are no direct links between the <strong class="bold">Presentation Layer</strong> and the <strong class="bold">Infrastructure Layer</strong>, as everything <a id="_idIndexMarker453"/>is proxied by the <strong class="bold">Application Layer</strong>. However, that's <a id="_idIndexMarker454"/>not a strict requirement.</li>
			</ul>
			<p>In the next section, I will share my views on how BDD could be applied to mobile payments.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>BDD of mobile payments</h2>
			<p>As <a id="_idIndexMarker455"/>we <a id="_idIndexMarker456"/>detailed in the <em class="italic">Exploring Behavior Driven Development</em> section, BDD starts with a user story. A basic user story for mobile payments could be the following:</p>
			<p><strong class="bold">User Story</strong>: Making a payment:</p>
			<ul>
				<li><strong class="bold">As a</strong> registered user.</li>
				<li><strong class="bold">I want</strong> to make a payment to another user.</li>
				<li><strong class="bold">So that</strong> I can transfer money (and benefit from services or goods in exchange for that).</li>
			</ul>
			<p>As you might have gathered, this user story implies other user stories (such as <strong class="bold">Registration of a user</strong> and <strong class="bold">Login</strong>).</p>
			<p>The next logical step is to enumerate some scenarios (or acceptance criteria) linked to that story:</p>
			<ul>
				<li><strong class="bold">Given</strong> that I am registered.</li>
				<li><strong class="bold">And</strong> I am logged in.</li>
				<li><strong class="bold">When</strong> I select the payment feature.</li>
				<li><strong class="bold">Then</strong> I am redirected to the payment view.</li>
				<li><strong class="bold">Given</strong> that I am at the payment view.</li>
				<li><strong class="bold">And</strong> I am logged in.</li>
				<li><strong class="bold">And</strong> I enter a valid recipient.</li>
				<li><strong class="bold">And</strong> I enter a valid amount.</li>
				<li><strong class="bold">When</strong> I click on the pay button.</li>
				<li><strong class="bold">Then</strong> a payment transaction is created.</li>
				<li><strong class="bold">And</strong> a notification is sent.</li>
			</ul>
			<p>As demonstrated in the preceding examples, each user story usually corresponds to more than one acceptance criteria, which is then codified as a set of (possibly automated) test <a id="_idIndexMarker457"/>cases. Following this, you<a id="_idIndexMarker458"/> can start to iteratively implement features until each acceptance criteria is met, ultimately fully covering the related user story. Now, let's expand on this user story by means of user story mapping.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>User story mapping of mobile payments</h2>
			<p>In <a id="_idIndexMarker459"/>the <em class="italic">Learning about user story mapping</em> section, we <a id="_idIndexMarker460"/>discovered that the top-level element is the user story. So, we will start with the stories that we have just observed in the previous section.</p>
			<p>Take into account that while it can be considered as a task attached to each user story, the acceptance criterion is usually considered more like an orthogonal concept, to validate the implementation of each story. Usually, the attached tasks are simply more detailed features composing the story itself. Let's view an example:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.06_B16354.jpg" alt="Figure 4.6 – User story mapping example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – User story mapping example</p>
			<p>As you can <a id="_idIndexMarker461"/>see <a id="_idIndexMarker462"/>in the preceding (simplified) example, for each activity (mapping to a user story, as per the <em class="italic">BDD of mobile payments</em> section) there are one or more related tasks. Activities and tasks are ordered following a time (and priority) direction. Then, each task is attached to a list of subtasks.</p>
			<p>It's a logical next step to plan how to group a set of subtasks as a release, progressively delivering value to the final customer (think about MVPs). We've described this approach as value slicing, which appears as follows:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_4.07_B16354.jpg" alt="Figure 4.7 – Value slicing example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Value slicing example</p>
			<p>As you can<a id="_idIndexMarker463"/> see in<a id="_idIndexMarker464"/> the preceding diagram, we've represented a simple slicing of features as two releases. In the first release (<strong class="bold">Release 1</strong>), you will provide the bare minimum functionalities. It will be possible to create users, to <strong class="bold">Sign in</strong> (but not using a social account), and to <strong class="bold">Make a payment</strong> (but without receiving a notification).</p>
			<p>There will be no functionalities regarding lost passwords and payment disputes. In the second release (<strong class="bold">Release 2</strong>), no new features will be added to the registration activity, the <strong class="bold">Lost password</strong> task will be completed (being made of just one subtask), and the whole <strong class="bold">Dispute a payment</strong> task will be completed (in both its two subtasks).</p>
			<p>All of the other subtasks are part of the backlog, meaning they are yet to be planned (and more subtasks can then be added). Of course, each line representing a release is drawn together with business/product owners, which will define the priority and helps to aggregate subtasks in a meaningful way. With value slicing, we have completed the objectives of this chapter. Let's look at a quick recap of all the notions we have encountered.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, we looked at a set of techniques to start transforming architecture principles into working software components. DDD is a pretty complete framework that is used to define objects and the way they interact with each other. It puts a number of clever ideas down on paper, such as layered architectures, patterns, and bounded contexts.</p>
			<p>Following this, we moved on to Test Driven Design and BDD. You now understand specific ways of structuring the development of new code and mapping it to business features. Finally, we looked at user story mapping as a way to pick functionalities to implement and link them to tasks and activities.</p>
			<p>All of these techniques will be better framed in the next chapter, where we will discuss <strong class="bold">Agile</strong> methodologies, which include some of the practices that we have just discussed.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor108"/>Further reading</h1>
			<ul>
				<li><em class="italic">Anemic Domain Model</em> by Martin Fowler (<a href="https://martinfowler.com/bliki/AnemicDomainModel.html">https://martinfowler.com/bliki/AnemicDomainModel.html</a>)</li>
				<li><em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em> by Eric Evans (<a href="https://www.domainlanguage.com/">https://www.domainlanguage.com/</a>)</li>
				<li><em class="italic">Domain-Driven Design Quickly</em>, by Abel Avram and Floyd Marinescu, published by C4Media (2007)</li>
				<li><em class="italic">10 Common DDD Mistakes to Avoid</em> by Jan Stenberg (<a href="https://www.infoq.com/news/2015/07/ddd-mistakes/">https://www.infoq.com/news/2015/07/ddd-mistakes/</a>)</li>
				<li><em class="italic">Introducing BDD</em> by Dan North (<a href="https://dannorth.net/introducing-bdd/">https://dannorth.net/introducing-bdd/</a>)</li>
				<li><em class="italic">BDD in Action: Behavior-Driven Development for the Whole Software Lifecycle</em>, by John Ferguson Smart, published by Manning Publications (2004)</li>
				<li><em class="italic">User Story Mapping &amp; Value Slicing</em> by Matt Takane and Ryan DeBeasi (<a href="https://openpracticelibrary.com/practice/user-story-mapping/">https://openpracticelibrary.com/practice/user-story-mapping/</a>)</li>
				<li><em class="italic">Top 5 Biggest Challenges when Building an MVP and how to Avoid Them</em> by Ilya Matanov (<a href="https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757">https://expertise.jetruby.com/top-5-biggest-challenges-when-building-an-mvp-and-how-to-avoid-them-2969703e5757</a>)</li>
				<li><em class="italic">The New User Story Backlog is a Map</em> by Jeff Patton (<a href="https://www.jpattonassociates.com/the-new-backlog/">https://www.jpattonassociates.com/the-new-backlog/</a>)</li>
			</ul>
		</div>
	</body></html>