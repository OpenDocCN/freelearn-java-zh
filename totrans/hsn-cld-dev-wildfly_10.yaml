- en: Providing Security Using Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of distributed, token-based security.
    We will introduce Keycloak—an authentication server that can be used to secure
    distributed cloud applications. As a practical example, we will secure part of
    the API of the Petstore application.
  prefs: []
  type: TYPE_NORMAL
- en: Token-based security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keycloak uses token-based security protocols. In order to understand how they
    work, we will introduce basic information about them.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In applications that are built using the client-server architecture, the server
    is often responsible for implementing security. A client provides credentials
    to the server, which is responsible for authenticating and authorizing users.
  prefs: []
  type: TYPE_NORMAL
- en: This model doesn't work well with distributed applications that require over-the-network
    invocations between a number of independent services.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, an architecture in which each service is responsible for implementing
    security is unscalable. We would preferably like to create a server that is responsible
    for keeping the data about users and implementing authentication and authorization.
    All other services will need to rely on it whenever any security decision has
    to be made.
  prefs: []
  type: TYPE_NORMAL
- en: 'here is a diagram of how this may look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5673f5b-f1d8-4a86-ad48-b494d33c272f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This solution has a fundamental flaw: credential sharing.'
  prefs: []
  type: TYPE_NORMAL
- en: In a cloud environment, an invocation may span a number of heterogeneous services,
    and, in general, we can't assume that those services can be trusted. If at least
    one of the clients with whom the user has shared its credentials is compromised,
    then all the systems are compromised.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another, more subtle problem. In the preceding architecture,
    it is unable to distinguish between invocation by the user and invocation on behalf
    of the user. For example, let's suppose that **SERVICE B** is a disk storage service
    and **SERVICE A** needs to obtain a file from it on behalf of the user. If the
    user propagates their credentials to A, then A can do whatever the user can do
    (for example, delete all their files). This is clearly undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding problems led to the emergence of the protocols based on security
    tokens. Let's look at those in greater detail now.
  prefs: []
  type: TYPE_NORMAL
- en: A basic architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by introducing the essential concept of access tokens as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An access token is a string representing a set of authorization credentials
    issued to the client. When a client wants to perform a request on behalf of a
    user, it needs to obtain their permission to do so. The token represents such
    a permission.
  prefs: []
  type: TYPE_NORMAL
- en: An access token is created for a specific client. As a result, a user can limit
    the permissions associated with an access token and therefore the client.
  prefs: []
  type: TYPE_NORMAL
- en: An access token contains authorization information—based on the access token,
    a service can decide whether the client who performs the invocation is allowed
    to perform the given operation. An access token does not contain information about
    the user, and possession of the access token does not imply that the request is
    being performed by a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a typical flow of the distributed protocol that uses an access
    token is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1774cf9-bad2-4748-98c0-1c1e06c91cb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note the following things in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: The client wants to perform the request on **SERVICE A**, but needs user permission
    to do that. Because of this, it asks the user for that permission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user agrees, she authenticates to the authentication server (2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the authentication finishes with success, the server generates an **access
    token**, which is sent to the client (3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client can use this token to access **SERVICE A** on behalf of the user
    (4).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, the token can be propagated to other services (5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s emphasize the most important characteristics of such an architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: The authorization (no matter which method it uses) happens solely between the
    user and the authentication server. No other component gains access to any kind
    of user credentials. As a result, the authorization server is the only component
    that has to be fully trusted.
  prefs: []
  type: TYPE_NORMAL
- en: Access tokens represent permission to do something on behalf of a user and are
    generated for the individual client. Because of that, an **access token** issued
    to a given client can contain a minimal set of permissions that will allow it
    to do its job. Furthermore, if the token is propagated to a compromised client
    or is stolen, it can do much less harm than just leaking of user credentials.
    Nevertheless, to minimize the impact of such a situation, access tokens are issued
    for a short period of time. As a result, even if a token is stolen, there is only
    a small time frame in which it can be used (concrete protocols may define a way
    for the client to refresh an access token).
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, token-based security protocols allow the implementation of decentralized
    authentication and authorization: users authenticate to a trusted authentication
    server and obtain tokens that can be used to authorize access to services. This
    is especially useful in cloud architecture: based on tokens generated by a trusted
    authentication server, we can gain access to a number of heterogeneous services
    distributed across the network, providing them with the ability to perform operations
    on our behalf, ensuring that the set of permissions associated with the token
    is minimal for the services to do their job.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of protocols that standardize this type of distributed security.
    One of them is **OpenID Connect** (**OIDC**), which is the modern protocol used
    by Keycloak by default; we will use it in our examples. Let's look at it a bit
    more closely.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OIDC is built on top of the **Oauth2** protocol, which is an open standard for
    delegating access. Oauth2 specifies directly how this process, outlined in the
    preceding paragraph should be executed, which actors will take part in it, and
    how and in which order they should cooperate to obtain the access token and use
    it for authorization. The hitch is that Oauth2 specifies only that, leaving a
    very wide margin to its implementations. As a result, it can be thought of as
    a framework used to build protocols rather than as a protocol itself.
  prefs: []
  type: TYPE_NORMAL
- en: OIDC is a protocol that was created using this framework. It fills the implementation
    gaps (such as the token format) and adds authentication information, which Oauth2
    lacks. OIDC standardizes the way in which information about the user can be obtained.
  prefs: []
  type: TYPE_NORMAL
- en: The gritty details of the protocols are beyond the scope of this book. If you
    are interested in those, refer to the protocol specifications (Further reading,
    link 1,2). In this chapter, we will teach you the minimum needed for you to understand
    Keycloak configuration for the basic usage of distributed security, which we will
    be presenting in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: OIDC specifies the number of flows—procedures that describe the process of obtaining
    and using tokens in detail. In the following section, we will take a look at the
    authentication code flow, the default flow used by Keycloak.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication code flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will describe authentication code flow. This is a precise
    description, which, as you will see, will directly impact on the configuration
    of the authentication server. It assumes that client is a web application running
    inside the browser. As a result, you should interpret the terms used literally.
    For example, if we talk about a client redirecting a user to an authentication
    server, we literally mean the HTTP redirect of a browser to an address of an authentication
    server. As we've already suggested, you will see those operations later in this
    chapter, when we will finish securing the pet store application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a diagram of the flow now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b149ffe9-47be-4dc1-b843-ab539204feb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The user uses the client, which is a browser-based application. When, at some
    point, a user performs a login operation, they are automatically redirected to
    the authentication server. Authentication is performed between the authentication
    server and user. The client has nothing to do with it: the way in which it was
    performed is too opaque for it, and the client has no interaction with any credentials
    provided by the user, no matter what kind of authentication method is used. As
    a result, the credentials are provided only to one entity on the web; if it is
    not compromised, then they will not be compromised either.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the authentication process finishes with success, the authentication server
    will generate an authentication code: a very short-lived, single-use code that
    will redirect the user to the client. The client will authenticate itself to an
    authentication server using the code and its own credentials. If the client authenticates
    correctly, an authentication server will generate an access token and return it
    to a client. Why is this step necessary? As we''ve already mentioned in the preceding
    section, an access token has to be generated for the resource owner, that is,
    the client tuple. Both the user and the client have to authenticate themselves
    to the authentication server in order to generate the token. The authentication
    server knows which permissions should be delegated to the client and creates an
    authentication token accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from an access token, the user obtains an ID token and, optionally, a
    refresh token.
  prefs: []
  type: TYPE_NORMAL
- en: We have mentioned that OIDC also provides information on the authentication.
    This is true. This information is provided to the client in the ID token. An ID
    token, in contrast with the access token, which may be opaque to the client, contains
    information provided for the client, and cannot be used to gain access to resources.
    To put it in a different way, an ID token is a token that is generated for the
    client and allows them to read information about the user. We will use this capability
    in our example.
  prefs: []
  type: TYPE_NORMAL
- en: We have also mentioned that a protocol may specify the way to refresh an access
    token. OIDC does that by using a refresh token. A refresh token allows a client
    to create a new **access token**, which, as we've mentioned, is short-lived when
    the old one expires. A client can use a refresh token in order to keep their authorization
    valid for a required period without having to delegate a new access code (making
    the user authenticate again). A client should keep a refresh token confidential—even
    if the access token is compromised, it can be used only for a short period, and
    only a client would be able to obtain a new one.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see in *WildFly Swarm Keycloak adapter* section, we will be dealing
    directly with access tokens (we have to propagate them between our services),
    but not with other tokens, as their functionality is encapsulated behind APIs.
    Let's continue with the flow.
  prefs: []
  type: TYPE_NORMAL
- en: After the client obtains the access token, it sends it to the resource server
    with the request. The resource server has to verify that the token is correct,
    extract the authorization data in it, and decide whether the request should be
    allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Access tokens that we will use in the example application are bearer tokens.
    This means that any entity that possesses these token can use them in the same
    way. As a result, the tokens can be propagated to all of the microservices in
    our application (which we will take advantage of soon). On the flip side, this
    means that the leak of the token is dangerous and, as a result, a bearer token
    cannot be sent by an untrusted network (we will get to that at the end of this
    chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now introduced enough theory already and, as usual, after a harsh technical
    introduction, we will head over to the practical section: a land of milk and honey,
    where the tools do everything for us. Let''s jump into that right away!'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to secure our Petstore application, we will use Keycloak. Keycloak
    is an open source, **single sign-on** (**SSO**) identity management server, which
    supports, among others, OIDC-based security.
  prefs: []
  type: TYPE_NORMAL
- en: Keycloak is equipped with a convenient, web-based UI, which enables us to configure
    all aspect of its behavior using the graphical interface. Furthermore, services
    that we will write have to be integrated with Keycloak as well. In order to make
    this integration easy, Keycloak provides a bunch of adapters, which are components
    that can be installed into any given type of service. In the following example,
    we will discuss how to use both of those tools.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, let's outline the functionality that we will be adding to the
    pet store application.
  prefs: []
  type: TYPE_NORMAL
- en: Cart-service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until this point, all the services that we''ve implemented could be accessed
    by anonymous users. In this chapter, we will implement the cart functionality.
    Obviously, in order to add something to the cart, you have to be authenticated
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ef4a40-5fca-47a6-8302-4d2757f8d1c1.png)'
  prefs: []
  type: TYPE_IMG
- en: We will deploy the Keycloak service in our OpenShift cluster, and configure
    both customer gateway and **Cart service** so that they allow only users who can
    authorize as customers to use this part of the API. Let's start.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Keycloak
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Keycloak, we have to install it first. Keycloak is basically
    a Java application based on WildFly AS. For the purpose of cloud usage, an OpenShift
    Docker image is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The server has been configured in a way that enables it to be deployed directly
    to the OpenShift cluster. Let''s use the OpenShift web console to deploy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7434228f-e324-4188-995b-d84efd59f2f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we will see shortly, all the configuration will be performed using an admin
    console. In the configuration, we have to provide the initial admin credentials
    using Environment Variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50fa641b-cc13-4153-90d7-37394e147729.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the server will be available behind the OpenShift proxy, we have to set
    the `PROXY_ADDRESS_FORWARDING` parameter to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: After setting these parameters, we are ready to start deploying the image into
    our OpenShift cluster. We will need to click on the Create button and wait until
    the Keycloak pod starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keycloak server, as with gateway servers, has to be accessed from outside the
    cluster (by us, administrators, and `petstore-ui`). Let''s make a route, then.
    We will do this as in previous chapters: we have to click on Create a route in
    the Services menu of the web console. We should use the default parameters. After
    the route is created, we will be able to see its IP address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a7cab0-9a4c-43eb-9bfd-334d8a4b2c8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a note of this IP, as we will use it quite a bit in a configuration.
  prefs: []
  type: TYPE_NORMAL
- en: OK, we have deployed Keycloak inside our cluster. We are finally ready to take
    a route to the Keycloak web console (the one that we have just created).
  prefs: []
  type: TYPE_NORMAL
- en: Creating realm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you followed the created route, you will see the Keycloak welcome page. Click
    on the `Authentication console` link and enter the credentials that we defined
    when the Keycloak server was deployed to the cluster (admin/admin). You will see
    the Admin console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Admin console is a UI that allows you to easily configure all aspects of
    distributed security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be959fc7-0c37-4481-9e92-48c81cfe1de0.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, look at the top-left corner—the menu is titled
    Master. What does that mean? Keycloak is responsible for managing a group of users,
    their credentials, and roles and clients to whom users can delegate access to.
    Keycloak provides namespaces, which allow the grouping of those objects. Those
    namespaces are called **realms**. Realms are isolated, and each realm can only
    manage the objects that it contains. As a result, all services that communicate
    with the Keycloak server must specify which realm they are referring to.
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, we will create our own petstore realm. In order to do this,
    we have to click on Master in the top-left corner and add the new domain, called
    petstore.
  prefs: []
  type: TYPE_NORMAL
- en: Create a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the theoretical section, the authentication server must be
    aware of all the clients that user can delegate their access to. In case of our
    application, we will need to configure a client: `petstore-ui`. In order to do
    this, click on Clients in the left-hand side menu and click on the Create client
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15afb9c4-7abd-4dff-a5c4-ca00fd843f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: We have to set the new client setting `Client ID` to `petstore-ui`. Remember
    that our web application will be redirected to Keycloak whenever a login is attempted.
    After the operation is finished, the authentication server has to redirect the
    user to the client using the redirect URI sent with the request by the client.
    Keycloak validates whether the URI is trusted. As a result, we have to provide
    a list of URI on which the client may be run. We will add the localhost address
    to which the browser with the UI is running. Also, some browsers perform **Cross-Origin
    Resource Sharing** (**CORS**) policy check. Setting the Web Origins parameter
    to `+` will make Keycloak return appropriate CORS headers with the redirect URI,
    if it was validated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We have now created our realm and told Keycloak about the client that will use
    it. Let's configure users now.
  prefs: []
  type: TYPE_NORMAL
- en: Users and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of this example, we will configure a user with customer and admin
    roles. Let's start with creating the roles themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Keycloak console, we will need to click on Roles in the left-hand menu,
    click on the Add role button on the right-hand, and enter the customer role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07603102-aafa-4b48-b227-58bcb1563f41.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will need to repeat the preceding steps for the admin role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we will need to add the user in a similar way: click on the Users menu,
    then on the Add user button, and enter the name of our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9a9dd34-add6-49b4-b3db-d18f3a5fdd9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, we have to perform more configuration though. We have to create
    the password in the Credentials section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/037155f7-5a91-4995-9715-822b1ee0538e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, map the customer role to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7d14698-bf6f-44b2-968b-b7d277bf7b96.png)'
  prefs: []
  type: TYPE_IMG
- en: We have created the user tomek, and given them customer and admin roles. If
    tomek uses `petstore-ui`, should they be able to invoke request allowed for admin
    roles? No. The `petstore-ui` is meant to be used by shop customers. We mentioned
    in the theoretical section that the authentication server should create an access
    token that contains the minimal amount of permissions necessary for the client
    do their job. In this concrete example, `petstore-ui` should only be allowed to
    perform a request allowed for customers on behalf of tomek. In order to configure
    that, we will need to introduce scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keycloak scope is a tool that allows you to specify which roles will be associated
    with an access token generated for a specific client. Let's create a scope for
    the `pestore-ui` client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, you have to click on Clients in the left-hand side menu,
    choose the petstore-ui client, and click on the Scope tab below the client''s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/281f5096-1274-445c-9954-3c8dec4abfd6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you will have noticed in the preceding screenshot, each client has the full
    scope allowed parameter set to true by default. This means that each role that
    an authenticated user has will be associated with an access token created for
    that client. In order to limit the roles of the given client, we have to turn
    this option off and manually choose the roles that are allowed. In our example,
    we will need to choose the customer role and move it to assigned roles.
  prefs: []
  type: TYPE_NORMAL
- en: The admin role has not been moved. As a result, if an access token is generated
    for `petstore-ui` on behalf of tomek, it will only contain the customer role.
    As a result, tomek won't be able to perform any admin operations from within the
    `petstore-ui` client.
  prefs: []
  type: TYPE_NORMAL
- en: We have pretty much configured Keycloak.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you configure the Java services? Before finding that out, let's introduce
    the next functionality that requires user authentication—the cart service.
  prefs: []
  type: TYPE_NORMAL
- en: Cart service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's introduce the cart service implementation. First of all, we have to add
    the new resources to the customer-gateway API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter10/cart-service`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you will have noticed in the preceding code, we have added three cart methods.
    All of them identify the cart by `customerId` (we will show you how to obtain
    this in few moments) and the cart item using the `itemId` of the application.
    As in previous chapters, all the methods delegate the implementation to the gateway
    service, which in turn uses proxies to propagate the invocation to backend services.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform operations on the cart, a user has to be authenticated to
    the system. Let's secure the `GatewayResource` to make sure that an unauthorized
    user will be denied access to those methods.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly Swarm Keycloak adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will know from the theoretical section, services with a secured API will
    have to authorize their users based on authentication tokens. In order to do that,
    they have to cooperate with the Keycloak server using, in our example, the OIDC
    protocol. Obviously, we will not implement this functionality ourselves. As we've
    suggested, Keycloak provides a number of adapters for different tools. WildFly
    Swarm has its own adapter too. So, how will we install it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend customer-gateway''s `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's it—the adapter is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more thing to do. We have to configure the adapter. In order to
    do this, we have to add the `keycloak.json` file inside the Maven''s resources
    directory. The file contains a bunch of adapter configuration properties. In our
    case, it''s pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, the files tell the adapter the `auth-server`''s location, the realm,
    and the resource name. As you may recall, we were behind all of those: we created
    the route to the Keycloak server deployed on OpenShift, created the realm for
    our petstore application, and told Keycloak that we will authenticate using the
    `petstore-ui` client, which we configured.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please, note that we need to provide `KEYCLOAK_URL` as an environment variable.
    This is an URL of the keycloak proxy that we have created. You are able to configure
    this variable in the web-console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891df04f-75c0-4a05-bb41-c83ade4c344d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After this information is provided, the Keycloak adapter will be able to authorize
    users based on the access token provided by the UI. This is good, but we haven't
    protected our resources yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we have to introduce few changes to customer-gateway''s
    main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you will have noticed in the preceding code, after marking `deployment` as
    `Secured`, we are able to use a chained API that we use to specify which request
    on which resources to protect and which roles are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding code, we have made sure that only users with the `customer`
    role is able to use cart-associated methods in the customer API. Note, however,
    that the backend cart service has to be secured as well.
  prefs: []
  type: TYPE_NORMAL
- en: We will secure it to the gateway service in an analogous way, which makes sure
    that it has dependency on swarm's Keycloak adapter, adding `keycloak.json` to
    the classpath (note that the context of the file will be the same, as all the
    properties stay valid), and making deployment secure in the main function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one problem though: in the gateway service, we have relied on the UI
    to send us access token each time the request is performed by an authenticated
    user. As you may recall from the previous chapters, we use Rest Client to perform
    the invocation on the backend service, and are responsible for attaching all the
    necessary information. As a result, we also have to propagate the access token
    to backend services during the invocation. If we don''t do this, Keycloak adapter
    in the backend service will recognize the request being performed as anonymous,
    which is clearly invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to propagate the context, we will implement a simple JAX-RS client
    request filter. In our scenario, we will check whether the access token is present
    and, if true, propagate it further to the invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, JAX-RS `ClientRequestFilter` (1) filters every invocation
    performed by the client associated with it before it is propagated to the server.
    In our scenario, we will check whether the access token is present and attach
    it to each request if true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In (2), we are injecting the `SecurityContext`. If Keycloak has authorized the
    user using the access token, it creates the `SecurityContext` and attaches it
    to the request. As a result, we will inject it into the objects on the invocation
    thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SecurityContext` created by Keycloak contains the `KeycloakPrincipal` implementation
    of the principal interface (3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the principal is present, we will be able to obtain further `KeycloakSecurityContext`
    from it (5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the token can be obtained from the context and propagated further as
    a `BEARER` token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at `CartProxy` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The proxy is similar to the proxies that we created in previous chapters and
    uses the standard JAX-RS client API to create an appropriate request to the backend
    cart-service. However, we have to register the `TokenPropagationFilter` that we
    have just created for the client
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sum up what we have already done: we have extended the customer-gateway
    with cart methods, added a Keycloak adapter and its configuration to the project,
    and marked deployment as `Secured`, specifying the roles that are authorized to
    use the given methods. We did this for both customer-gateway and backend cart-service.
    In order to make sure that the access token is propagated to the backend service,
    we have implemented an appropriate filter and registered it inside our proxy.
    It seems that the authentication should work now. Let''s try it!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to find UI application in the attached code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter10/petstore-ui`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the petstore application and open the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/407336b0-d574-4968-9fe0-049ce30dcb4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, no user is logged in to the application. To obtain
    all the necessary data, the client had to perform the invocation on the items
    resource. As the resource is not protected, the invocation was successful. In
    order to log in to the cart, we have to be authenticated. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/576df6c1-a780-431f-b200-1b4ae6b61516.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Log in button redirected us to Keycloak server. After providing
    your credentials, Keycloak will authenticate you and redirect you to the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff6da6f-2519-4a22-a3f7-fad96f83d811.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you will have noticed in the preceding screenshot, we have successfully
    logged in to the UI. You can now add items to the cart and take a look at the
    cart view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9195f0f-b709-48d4-a731-b672332b7ed1.png)'
  prefs: []
  type: TYPE_IMG
- en: We have shown you the operation of the store with a valid security configuration,
    but feel free to play with the sample application in order to confirm that the
    security works correctly. You may create and remove roles from the user in the
    Keycloak console, or make the service require different roles for authorization.
    You will see that Keycloak is indeed able to correctly authorize a user; users
    with valid roles will be allowed to perform a request and users lacking valid
    roles will be forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: SSL configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, when we describe bearer tokens,
    when you use this kind of authentication in a production environment, you have
    to use encrypted connections. In this section, we will describe how WildFly Swarm
    and OpenShift support the use of secure connections.
  prefs: []
  type: TYPE_NORMAL
- en: We will separate this section into two different cases, depending on whether
    we consider our cloud environment to be secured or not.
  prefs: []
  type: TYPE_NORMAL
- en: Secured cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a scenario where the cloud environment that you are using is secure, you
    will need to configure an encrypted connection between external clients and routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2d2f1c-144e-4e50-9cc0-1be157f5b840.png)'
  prefs: []
  type: TYPE_IMG
- en: In such a case, we have to configure an Edge router. An Edge router has its
    own certificate and is able to establish secure connections with external clients.
    Before proxying traffic to the destination, the router encrypts the connection.
    As a result, in the OpenShift cluster, communication happens through unsecured
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are able to configure edge routing for each route that you create. In order
    to do so, you have to create routes in the standard way (choose the service to
    which you want the route to be established and click on Create route). Later,
    you have to choose a Secure route so, pick Edge from the TLS termination drop-down
    menu and enter your Certificate in the PEM format in the form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac9287b-a02c-4925-9549-aa1b0e75c72a.png)'
  prefs: []
  type: TYPE_IMG
- en: Unsecured cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some circumstances, you may need to configure secure connections for all
    communication, both with external services and within the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71073c02-2403-439f-8a4b-33865f8d80c9.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to do so, you have to configure a route with passthrough TLS termination
    (by creating the route in the same way as in the paragraph before and choosing
    pass-through termination).
  prefs: []
  type: TYPE_NORMAL
- en: With the pass-through termination, the router does not terminate the TLS connection
    and the encrypted traffic is propagated to the target. One of its implications
    is that targets (and all other services) need to have their security setting configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm enables you to do this easily by providing HTTP configuration. Let''s
    look at the example configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration specifies that the server will only use the secured
    connection on the `8443` port. It specifies the location of both `trustore` and
    `keystore` (classpath) and their `password`s.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've shown how you can use distributed security protocols
    to secure your cloud applications using our practical example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this chapter by introducing concepts based on distributed authentication
    and authorization: the rationale for tokens and how they can be obtained and used.
    Later, we introduced basic information about a concrete distributed security protocol:
    OpenID Connect.'
  prefs: []
  type: TYPE_NORMAL
- en: In the practical section, we used the Keycloak SSO server to secure the cart
    service in the Petstore application.
  prefs: []
  type: TYPE_NORMAL
- en: In the, we will discuss how do deal with an unreliable network problem using
    a circuit breaker pattern; specifically, the Hystrix library.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://oauth.net/2/](https://oauth.net/2/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://openid.net/developers/specs/](http://openid.net/developers/specs/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.keycloak.org/](https://www.keycloak.org/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
