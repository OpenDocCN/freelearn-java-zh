- en: Providing Security Using Keycloak
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Keycloak提供安全
- en: In this chapter, we will learn the basics of distributed, token-based security.
    We will introduce Keycloak—an authentication server that can be used to secure
    distributed cloud applications. As a practical example, we will secure part of
    the API of the Petstore application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习基于令牌的分布式安全的基础知识。我们将介绍Keycloak——一个可以用于保护分布式云应用程序的认证服务器。作为一个实际示例，我们将保护Petstore应用程序API的一部分。
- en: Token-based security
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的安全
- en: Keycloak uses token-based security protocols. In order to understand how they
    work, we will introduce basic information about them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak使用基于令牌的安全协议。为了理解它们是如何工作的，我们将介绍它们的基本信息。
- en: Rationale
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理由
- en: In applications that are built using the client-server architecture, the server
    is often responsible for implementing security. A client provides credentials
    to the server, which is responsible for authenticating and authorizing users.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用客户端-服务器架构构建的应用程序中，服务器通常负责实现安全。客户端向服务器提供凭证，服务器负责验证和授权用户。
- en: This model doesn't work well with distributed applications that require over-the-network
    invocations between a number of independent services.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型与需要在不同独立服务之间进行网络调用的分布式应用程序不太兼容。
- en: First of all, an architecture in which each service is responsible for implementing
    security is unscalable. We would preferably like to create a server that is responsible
    for keeping the data about users and implementing authentication and authorization.
    All other services will need to rely on it whenever any security decision has
    to be made.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个服务负责实现安全性的架构是不可扩展的。我们更愿意创建一个服务器，该服务器负责保存有关用户的数据并实现身份验证和授权。所有其他服务在需要做出任何安全决策时都必须依赖它。
- en: 'here is a diagram of how this may look:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个如何呈现的示例图：
- en: '![](img/b5673f5b-f1d8-4a86-ad48-b494d33c272f.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b5673f5b-f1d8-4a86-ad48-b494d33c272f.png)'
- en: 'This solution has a fundamental flaw: credential sharing.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案有一个基本的缺陷：凭证共享。
- en: In a cloud environment, an invocation may span a number of heterogeneous services,
    and, in general, we can't assume that those services can be trusted. If at least
    one of the clients with whom the user has shared its credentials is compromised,
    then all the systems are compromised.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，一个调用可能跨越多个异构服务，通常我们不能假设这些服务是可信赖的。如果至少有一个与用户共享了其凭证的客户端被破坏，那么所有系统都会被破坏。
- en: However, there is another, more subtle problem. In the preceding architecture,
    it is unable to distinguish between invocation by the user and invocation on behalf
    of the user. For example, let's suppose that **SERVICE B** is a disk storage service
    and **SERVICE A** needs to obtain a file from it on behalf of the user. If the
    user propagates their credentials to A, then A can do whatever the user can do
    (for example, delete all their files). This is clearly undesirable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个更微妙的问题。在先前的架构中，它无法区分用户发起的调用和代表用户发起的调用。例如，假设**SERVICE B**是一个磁盘存储服务，而**SERVICE
    A**需要代表用户从它那里获取文件。如果用户将他们的凭证传播到A，那么A可以做用户能做的任何事情（例如，删除所有文件）。这显然是不希望的。
- en: The preceding problems led to the emergence of the protocols based on security
    tokens. Let's look at those in greater detail now.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前述问题导致了基于安全令牌的协议的出现。现在让我们更详细地看看这些协议。
- en: A basic architecture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本架构
- en: 'Let''s start by introducing the essential concept of access tokens as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先介绍访问令牌的基本概念如下：
- en: An access token is a string representing a set of authorization credentials
    issued to the client. When a client wants to perform a request on behalf of a
    user, it needs to obtain their permission to do so. The token represents such
    a permission.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌是一个字符串，表示颁发给客户端的一组授权凭证。当客户端想要代表用户执行请求时，它需要获得这样做许可。令牌代表这样的许可。
- en: An access token is created for a specific client. As a result, a user can limit
    the permissions associated with an access token and therefore the client.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌是为特定客户端创建的。因此，用户可以限制与访问令牌关联的权限，从而限制客户端。
- en: An access token contains authorization information—based on the access token,
    a service can decide whether the client who performs the invocation is allowed
    to perform the given operation. An access token does not contain information about
    the user, and possession of the access token does not imply that the request is
    being performed by a user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌包含授权信息——基于访问令牌，服务可以决定执行调用的客户端是否被允许执行特定的操作。访问令牌不包含关于用户的信息，拥有访问令牌并不意味着请求是由用户执行的。
- en: 'For example, a typical flow of the distributed protocol that uses an access
    token is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用访问令牌的分布式协议的典型流程如下：
- en: '![](img/b1774cf9-bad2-4748-98c0-1c1e06c91cb6.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1774cf9-bad2-4748-98c0-1c1e06c91cb6.png)'
- en: 'Note the following things in the preceding example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下在先前的示例中的事项：
- en: The client wants to perform the request on **SERVICE A**, but needs user permission
    to do that. Because of this, it asks the user for that permission.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端想要在**SERVICE A**上执行请求，但需要用户权限才能这样做。因此，它请求用户给予这种权限。
- en: If the user agrees, she authenticates to the authentication server (2).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户同意，她将向身份验证服务器进行身份验证（2）。
- en: If the authentication finishes with success, the server generates an **access
    token**, which is sent to the client (3).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果身份验证成功完成，服务器将生成一个**访问令牌**，并将其发送到客户端（3）。
- en: The client can use this token to access **SERVICE A** on behalf of the user
    (4).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端可以使用此令牌代表用户访问**SERVICE A**（4）。
- en: Furthermore, the token can be propagated to other services (5).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，令牌可以被传播到其他服务（5）。
- en: 'Let''s emphasize the most important characteristics of such an architecture:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们强调这种架构最重要的特性：
- en: The authorization (no matter which method it uses) happens solely between the
    user and the authentication server. No other component gains access to any kind
    of user credentials. As a result, the authorization server is the only component
    that has to be fully trusted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 授权（无论使用哪种方法）仅发生在用户和身份验证服务器之间。没有其他组件可以访问任何类型的用户凭证。因此，授权服务器是唯一需要完全信任的组件。
- en: Access tokens represent permission to do something on behalf of a user and are
    generated for the individual client. Because of that, an **access token** issued
    to a given client can contain a minimal set of permissions that will allow it
    to do its job. Furthermore, if the token is propagated to a compromised client
    or is stolen, it can do much less harm than just leaking of user credentials.
    Nevertheless, to minimize the impact of such a situation, access tokens are issued
    for a short period of time. As a result, even if a token is stolen, there is only
    a small time frame in which it can be used (concrete protocols may define a way
    for the client to refresh an access token).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌代表代表用户执行某事的权限，并为单个客户端生成。因此，向特定客户端颁发的访问令牌可以包含一组最小的权限，允许它执行其工作。此外，如果令牌传播到受损的客户端或被盗，它造成的损害比仅泄露用户凭证要小得多。尽管如此，为了最小化这种情况的影响，访问令牌的颁发时间很短。因此，即使令牌被盗，它也只有在很短的时间内才能被使用（具体的协议可能定义客户端刷新访问令牌的方法）。
- en: 'To sum up, token-based security protocols allow the implementation of decentralized
    authentication and authorization: users authenticate to a trusted authentication
    server and obtain tokens that can be used to authorize access to services. This
    is especially useful in cloud architecture: based on tokens generated by a trusted
    authentication server, we can gain access to a number of heterogeneous services
    distributed across the network, providing them with the ability to perform operations
    on our behalf, ensuring that the set of permissions associated with the token
    is minimal for the services to do their job.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，基于令牌的安全协议允许实现去中心化的身份验证和授权：用户向受信任的身份验证服务器进行身份验证并获取可用于授权访问服务的令牌。这在云架构中特别有用：基于受信任的身份验证服务器生成的令牌，我们可以访问网络中分布的多个异构服务，并为他们提供代表我们执行操作的能力，确保与令牌关联的权限集对服务执行其工作来说是尽可能小的。
- en: There are a number of protocols that standardize this type of distributed security.
    One of them is **OpenID Connect** (**OIDC**), which is the modern protocol used
    by Keycloak by default; we will use it in our examples. Let's look at it a bit
    more closely.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多协议标准化了这种类型的分布式安全。其中之一是**OpenID Connect**（**OIDC**），这是Keycloak默认使用的现代协议；我们将在示例中使用它。让我们更详细地看看它。
- en: OpenID Connect
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID Connect
- en: OIDC is built on top of the **Oauth2** protocol, which is an open standard for
    delegating access. Oauth2 specifies directly how this process, outlined in the
    preceding paragraph should be executed, which actors will take part in it, and
    how and in which order they should cooperate to obtain the access token and use
    it for authorization. The hitch is that Oauth2 specifies only that, leaving a
    very wide margin to its implementations. As a result, it can be thought of as
    a framework used to build protocols rather than as a protocol itself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC 是建立在 **Oauth2** 协议之上的，这是一个开放标准，用于委托访问。Oauth2 直接指定了前面段落中概述的过程应该如何执行，哪些参与者将参与其中，以及他们应该如何以及按什么顺序合作以获取访问令牌并用于授权。问题是
    Oauth2 只指定了这一点，为其实现留下了很大的空间。因此，它可以被认为是一个用于构建协议的框架，而不是一个协议本身。
- en: OIDC is a protocol that was created using this framework. It fills the implementation
    gaps (such as the token format) and adds authentication information, which Oauth2
    lacks. OIDC standardizes the way in which information about the user can be obtained.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC 是一个使用此框架创建的协议。它填补了实现上的空白（例如令牌格式），并添加了 OAuth2 缺少的认证信息。OIDC 标准化了获取用户信息的方式。
- en: The gritty details of the protocols are beyond the scope of this book. If you
    are interested in those, refer to the protocol specifications (Further reading,
    link 1,2). In this chapter, we will teach you the minimum needed for you to understand
    Keycloak configuration for the basic usage of distributed security, which we will
    be presenting in the following example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的细节超出了本书的范围。如果您对此感兴趣，请参阅协议规范（进一步阅读，链接 1,2）。在本章中，我们将向您介绍您理解 Keycloak 配置以进行分布式安全基本使用所需的最少内容，我们将在以下示例中展示。
- en: OIDC specifies the number of flows—procedures that describe the process of obtaining
    and using tokens in detail. In the following section, we will take a look at the
    authentication code flow, the default flow used by Keycloak.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC 指定了流的数量——详细描述获取和使用令牌的过程的程序。在下一节中，我们将查看认证码流程，这是 Keycloak 使用的默认流程。
- en: Authentication code flow
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证码流程
- en: In this section, we will describe authentication code flow. This is a precise
    description, which, as you will see, will directly impact on the configuration
    of the authentication server. It assumes that client is a web application running
    inside the browser. As a result, you should interpret the terms used literally.
    For example, if we talk about a client redirecting a user to an authentication
    server, we literally mean the HTTP redirect of a browser to an address of an authentication
    server. As we've already suggested, you will see those operations later in this
    chapter, when we will finish securing the pet store application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述认证码流程。这是一个精确的描述，正如您将看到的，它将直接影响认证服务器的配置。它假设客户端是一个运行在浏览器内的网络应用程序。因此，您应该字面地解释所使用的术语。例如，如果我们谈论客户端将用户重定向到认证服务器，我们字面意思是浏览器将
    HTTP 重定向到认证服务器的地址。正如我们之前建议的，您将在本章的后面看到这些操作，当我们完成对宠物商店应用程序的安全保护时。
- en: 'Let''s take a look at a diagram of the flow now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下流程图：
- en: '![](img/b149ffe9-47be-4dc1-b843-ab539204feb6.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b149ffe9-47be-4dc1-b843-ab539204feb6.png)'
- en: 'The user uses the client, which is a browser-based application. When, at some
    point, a user performs a login operation, they are automatically redirected to
    the authentication server. Authentication is performed between the authentication
    server and user. The client has nothing to do with it: the way in which it was
    performed is too opaque for it, and the client has no interaction with any credentials
    provided by the user, no matter what kind of authentication method is used. As
    a result, the credentials are provided only to one entity on the web; if it is
    not compromised, then they will not be compromised either.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户使用客户端，这是一个基于浏览器的应用程序。当用户在某个时刻执行登录操作时，他们会自动重定向到认证服务器。认证是在认证服务器和用户之间进行的。客户端与此无关：它的执行方式对它来说过于晦涩，客户端不会与用户提供的任何凭证进行交互，无论使用什么类型的认证方法。因此，凭证只提供给网络上的一个实体；如果它没有被破坏，那么它们也不会被破坏。
- en: 'If the authentication process finishes with success, the authentication server
    will generate an authentication code: a very short-lived, single-use code that
    will redirect the user to the client. The client will authenticate itself to an
    authentication server using the code and its own credentials. If the client authenticates
    correctly, an authentication server will generate an access token and return it
    to a client. Why is this step necessary? As we''ve already mentioned in the preceding
    section, an access token has to be generated for the resource owner, that is,
    the client tuple. Both the user and the client have to authenticate themselves
    to the authentication server in order to generate the token. The authentication
    server knows which permissions should be delegated to the client and creates an
    authentication token accordingly.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果身份验证过程以成功结束，身份验证服务器将生成一个身份验证代码：一个非常短暂、一次性的代码，将用户重定向到客户端。客户端将使用代码和自己的凭据向身份验证服务器进行身份验证。如果客户端正确地进行了身份验证，身份验证服务器将生成一个访问令牌并将其返回给客户端。为什么这一步是必要的？正如我们在前面的部分中已经提到的，必须为资源所有者生成访问令牌，即客户端元组。用户和客户端都必须向身份验证服务器进行身份验证，以便生成令牌。身份验证服务器知道应该将哪些权限委派给客户端，并据此创建身份验证令牌。
- en: Apart from an access token, the user obtains an ID token and, optionally, a
    refresh token.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问令牌外，用户还获得一个 ID 令牌和可选的刷新令牌。
- en: We have mentioned that OIDC also provides information on the authentication.
    This is true. This information is provided to the client in the ID token. An ID
    token, in contrast with the access token, which may be opaque to the client, contains
    information provided for the client, and cannot be used to gain access to resources.
    To put it in a different way, an ID token is a token that is generated for the
    client and allows them to read information about the user. We will use this capability
    in our example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，OIDC 也提供了有关身份验证的信息。这是真的。这些信息包含在 ID 令牌中。与可能对客户端不透明的访问令牌相比，ID 令牌包含提供给客户端的信息，并且不能用来访问资源。换句话说，ID
    令牌是为客户端生成的令牌，允许他们读取有关用户的信息。我们将在我们的示例中使用这种功能。
- en: We have also mentioned that a protocol may specify the way to refresh an access
    token. OIDC does that by using a refresh token. A refresh token allows a client
    to create a new **access token**, which, as we've mentioned, is short-lived when
    the old one expires. A client can use a refresh token in order to keep their authorization
    valid for a required period without having to delegate a new access code (making
    the user authenticate again). A client should keep a refresh token confidential—even
    if the access token is compromised, it can be used only for a short period, and
    only a client would be able to obtain a new one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，一个协议可以指定刷新访问令牌的方式。OIDC 通过使用刷新令牌来实现这一点。刷新令牌允许客户端创建一个新的**访问令牌**，正如我们之前提到的，当旧的令牌过期时，新的令牌是短暂的。客户端可以使用刷新令牌来保持其授权在所需的时间内有效，而无需委派新的访问代码（使用户再次进行身份验证）。客户端应保持刷新令牌的机密性——即使访问令牌被泄露，也只能在短时间内使用，并且只有客户端才能获取新的令牌。
- en: As you will see in *WildFly Swarm Keycloak adapter* section, we will be dealing
    directly with access tokens (we have to propagate them between our services),
    but not with other tokens, as their functionality is encapsulated behind APIs.
    Let's continue with the flow.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在 *WildFly Swarm Keycloak 适配器* 部分中看到的那样，我们将直接处理访问令牌（我们必须在我们的服务之间传播它们），但不会处理其他令牌，因为它们的函数被封装在
    API 之后。让我们继续流程。
- en: After the client obtains the access token, it sends it to the resource server
    with the request. The resource server has to verify that the token is correct,
    extract the authorization data in it, and decide whether the request should be
    allowed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端获得访问令牌后，将其与请求一起发送到资源服务器。资源服务器必须验证令牌是否正确，提取其中的授权数据，并决定是否允许请求。
- en: Access tokens that we will use in the example application are bearer tokens.
    This means that any entity that possesses these token can use them in the same
    way. As a result, the tokens can be propagated to all of the microservices in
    our application (which we will take advantage of soon). On the flip side, this
    means that the leak of the token is dangerous and, as a result, a bearer token
    cannot be sent by an untrusted network (we will get to that at the end of this
    chapter).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例应用程序中我们将使用的访问令牌是携带令牌。这意味着任何拥有这些令牌的实体都可以像使用它们一样使用它们。因此，这些令牌可以传播到我们应用程序中的所有微服务（我们很快就会利用这一点）。另一方面，这也意味着令牌的泄露是危险的，因此，携带令牌不能通过不受信任的网络发送（我们将在本章末尾讨论这一点）。
- en: 'We have now introduced enough theory already and, as usual, after a harsh technical
    introduction, we will head over to the practical section: a land of milk and honey,
    where the tools do everything for us. Let''s jump into that right away!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了足够多的理论，并且，像往常一样，在艰难的技术介绍之后，我们将转向实践部分：一个充满牛奶和蜂蜜的地方，那里的工具为我们做所有事情。让我们立刻跳进去！
- en: Introducing Keycloak
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Keycloak
- en: In order to secure our Petstore application, we will use Keycloak. Keycloak
    is an open source, **single sign-on** (**SSO**) identity management server, which
    supports, among others, OIDC-based security.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的 Petstore 应用程序的安全，我们将使用 Keycloak。Keycloak 是一个开源的、**单点登录**（**SSO**）身份管理服务器，它支持基于
    OIDC 的安全，以及其他功能。
- en: Keycloak is equipped with a convenient, web-based UI, which enables us to configure
    all aspect of its behavior using the graphical interface. Furthermore, services
    that we will write have to be integrated with Keycloak as well. In order to make
    this integration easy, Keycloak provides a bunch of adapters, which are components
    that can be installed into any given type of service. In the following example,
    we will discuss how to use both of those tools.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 配备了一个方便的、基于网页的用户界面，它使我们能够使用图形界面配置其行为的各个方面。此外，我们将编写的服务也必须与 Keycloak
    集成。为了使这种集成变得简单，Keycloak 提供了一组适配器，这些适配器是可以安装到任何给定类型服务中的组件。在下面的示例中，我们将讨论如何使用这两个工具。
- en: Before we start, let's outline the functionality that we will be adding to the
    pet store application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们概述我们将添加到宠物商店应用程序中的功能。
- en: Cart-service
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车服务
- en: 'Until this point, all the services that we''ve implemented could be accessed
    by anonymous users. In this chapter, we will implement the cart functionality.
    Obviously, in order to add something to the cart, you have to be authenticated
    in the application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的所有服务都可以被匿名用户访问。在本章中，我们将实现购物车功能。显然，为了向购物车添加东西，你必须在该应用程序中进行身份验证：
- en: '![](img/40ef4a40-5fca-47a6-8302-4d2757f8d1c1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40ef4a40-5fca-47a6-8302-4d2757f8d1c1.png)'
- en: We will deploy the Keycloak service in our OpenShift cluster, and configure
    both customer gateway and **Cart service** so that they allow only users who can
    authorize as customers to use this part of the API. Let's start.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的 OpenShift 集群中部署 Keycloak 服务，并配置客户网关和 **购物车服务**，以便它们只允许可以授权为客户的用户使用该
    API 的这部分。让我们开始吧。
- en: Installing Keycloak
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Keycloak
- en: 'In order to use Keycloak, we have to install it first. Keycloak is basically
    a Java application based on WildFly AS. For the purpose of cloud usage, an OpenShift
    Docker image is provided:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Keycloak，我们必须首先安装它。Keycloak 主要是基于 WildFly AS 的 Java 应用程序。为了云的使用，提供了一个 OpenShift
    Docker 镜像：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The server has been configured in a way that enables it to be deployed directly
    to the OpenShift cluster. Let''s use the OpenShift web console to deploy it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已经配置好了，可以直接部署到 OpenShift 集群。让我们使用 OpenShift 网络控制台来部署它：
- en: '![](img/7434228f-e324-4188-995b-d84efd59f2f1.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7434228f-e324-4188-995b-d84efd59f2f1.png)'
- en: 'As we will see shortly, all the configuration will be performed using an admin
    console. In the configuration, we have to provide the initial admin credentials
    using Environment Variables:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的，所有配置都将使用管理员控制台进行。在配置中，我们必须使用环境变量提供初始管理员凭据：
- en: '![](img/50fa641b-cc13-4153-90d7-37394e147729.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50fa641b-cc13-4153-90d7-37394e147729.png)'
- en: Since the server will be available behind the OpenShift proxy, we have to set
    the `PROXY_ADDRESS_FORWARDING` parameter to `true`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器将在 OpenShift 代理后面可用，我们必须将 `PROXY_ADDRESS_FORWARDING` 参数设置为 `true`。
- en: After setting these parameters, we are ready to start deploying the image into
    our OpenShift cluster. We will need to click on the Create button and wait until
    the Keycloak pod starts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些参数后，我们就可以开始将镜像部署到我们的OpenShift集群中了。我们需要点击创建按钮，等待Keycloak pod启动。
- en: 'Keycloak server, as with gateway servers, has to be accessed from outside the
    cluster (by us, administrators, and `petstore-ui`). Let''s make a route, then.
    We will do this as in previous chapters: we have to click on Create a route in
    the Services menu of the web console. We should use the default parameters. After
    the route is created, we will be able to see its IP address, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak服务器，就像网关服务器一样，必须从集群外部（由我们，管理员和`petstore-ui`）访问。那么让我们创建一个路由吧。我们将像之前章节中做的那样进行：我们必须点击网页控制台的服务菜单中的创建路由。我们应该使用默认参数。路由创建后，我们将能够看到其IP地址，如下所示：
- en: '![](img/e8a7cab0-9a4c-43eb-9bfd-334d8a4b2c8f.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e8a7cab0-9a4c-43eb-9bfd-334d8a4b2c8f.png)'
- en: Take a note of this IP, as we will use it quite a bit in a configuration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这个IP，因为我们将在配置中大量使用它。
- en: OK, we have deployed Keycloak inside our cluster. We are finally ready to take
    a route to the Keycloak web console (the one that we have just created).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经将Keycloak部署到了我们的集群内部。我们终于准备好前往Keycloak网页控制台（我们刚刚创建的那个）了。
- en: Creating realm
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建领域
- en: If you followed the created route, you will see the Keycloak welcome page. Click
    on the `Authentication console` link and enter the credentials that we defined
    when the Keycloak server was deployed to the cluster (admin/admin). You will see
    the Admin console.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了创建的路径，你会看到Keycloak欢迎页面。点击`Authentication console`链接，并输入我们在将Keycloak服务器部署到集群时定义的凭据（admin/admin）。你将看到管理控制台。
- en: 'The Admin console is a UI that allows you to easily configure all aspects of
    distributed security:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 管理控制台是一个UI，允许你轻松配置分布式安全性的所有方面：
- en: '![](img/be959fc7-0c37-4481-9e92-48c81cfe1de0.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be959fc7-0c37-4481-9e92-48c81cfe1de0.png)'
- en: In the preceding screenshot, look at the top-left corner—the menu is titled
    Master. What does that mean? Keycloak is responsible for managing a group of users,
    their credentials, and roles and clients to whom users can delegate access to.
    Keycloak provides namespaces, which allow the grouping of those objects. Those
    namespaces are called **realms**. Realms are isolated, and each realm can only
    manage the objects that it contains. As a result, all services that communicate
    with the Keycloak server must specify which realm they are referring to.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，看看左上角——菜单的标题是Master。这意味着什么？Keycloak负责管理一组用户、他们的凭据、角色和用户可以委托访问权限的客户端。Keycloak提供命名空间，允许对这些对象进行分组。这些命名空间被称为**领域**。领域是隔离的，每个领域只能管理它包含的对象。因此，所有与Keycloak服务器通信的服务都必须指定它们引用的是哪个领域。
- en: For our purpose, we will create our own petstore realm. In order to do this,
    we have to click on Master in the top-left corner and add the new domain, called
    petstore.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将创建自己的petstore领域。为了做到这一点，我们必须点击左上角的Master，并添加新的域名，称为petstore。
- en: Create a client
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建客户端
- en: 'As mentioned in the theoretical section, the authentication server must be
    aware of all the clients that user can delegate their access to. In case of our
    application, we will need to configure a client: `petstore-ui`. In order to do
    this, click on Clients in the left-hand side menu and click on the Create client
    button:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如理论部分所述，认证服务器必须知道所有用户可以委托访问权限的客户端。在我们的应用程序中，我们需要配置一个客户端：`petstore-ui`。为了做到这一点，点击左侧菜单中的客户端，然后点击创建客户端按钮：
- en: '![](img/15afb9c4-7abd-4dff-a5c4-ca00fd843f7c.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15afb9c4-7abd-4dff-a5c4-ca00fd843f7c.png)'
- en: We have to set the new client setting `Client ID` to `petstore-ui`. Remember
    that our web application will be redirected to Keycloak whenever a login is attempted.
    After the operation is finished, the authentication server has to redirect the
    user to the client using the redirect URI sent with the request by the client.
    Keycloak validates whether the URI is trusted. As a result, we have to provide
    a list of URI on which the client may be run. We will add the localhost address
    to which the browser with the UI is running. Also, some browsers perform **Cross-Origin
    Resource Sharing** (**CORS**) policy check. Setting the Web Origins parameter
    to `+` will make Keycloak return appropriate CORS headers with the redirect URI,
    if it was validated correctly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将新的客户端设置 `Client ID` 设置为 `petstore-ui`。记住，我们的 Web 应用程序将在尝试登录时被重定向到 Keycloak。操作完成后，身份验证服务器必须使用客户端请求中发送的重定向
    URI 将用户重定向到客户端。Keycloak 验证 URI 是否可信。因此，我们必须提供一个客户端可能运行的 URI 列表。我们将添加运行具有 UI 的浏览器的本地主机地址。此外，一些浏览器执行
    **跨源资源共享**（**CORS**）策略检查。将 Web Origins 参数设置为 `+` 将使 Keycloak 在重定向 URI 被正确验证时返回适当的
    CORS 标头。
- en: We have now created our realm and told Keycloak about the client that will use
    it. Let's configure users now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了我们的领域，并告诉 Keycloak 关于将使用它的客户端。现在让我们配置用户。
- en: Users and roles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户和角色
- en: For the sake of this example, we will configure a user with customer and admin
    roles. Let's start with creating the roles themselves.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个示例，我们将配置一个具有客户和管理员角色的用户。让我们从创建角色本身开始。
- en: 'In the Keycloak console, we will need to click on Roles in the left-hand menu,
    click on the Add role button on the right-hand, and enter the customer role:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Keycloak 控制台中，我们需要在左侧菜单中点击“角色”，然后在右侧点击“添加角色”按钮，并输入客户角色：
- en: '![](img/07603102-aafa-4b48-b227-58bcb1563f41.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07603102-aafa-4b48-b227-58bcb1563f41.png)'
- en: Next, we will need to repeat the preceding steps for the admin role.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为管理员角色重复前面的步骤。
- en: 'Later, we will need to add the user in a similar way: click on the Users menu,
    then on the Add user button, and enter the name of our user:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要以类似的方式添加用户：点击“用户”菜单，然后点击“添加用户”按钮，并输入我们用户的名称：
- en: '![](img/b9a9dd34-add6-49b4-b3db-d18f3a5fdd9f.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9a9dd34-add6-49b4-b3db-d18f3a5fdd9f.png)'
- en: 'This time, we have to perform more configuration though. We have to create
    the password in the Credentials section, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们需要进行更多的配置。我们必须在凭据部分创建密码，如下所示：
- en: '![](img/037155f7-5a91-4995-9715-822b1ee0538e.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/037155f7-5a91-4995-9715-822b1ee0538e.png)'
- en: 'Then, map the customer role to the user:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将客户角色映射到用户：
- en: '![](img/a7d14698-bf6f-44b2-968b-b7d277bf7b96.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a7d14698-bf6f-44b2-968b-b7d277bf7b96.png)'
- en: We have created the user tomek, and given them customer and admin roles. If
    tomek uses `petstore-ui`, should they be able to invoke request allowed for admin
    roles? No. The `petstore-ui` is meant to be used by shop customers. We mentioned
    in the theoretical section that the authentication server should create an access
    token that contains the minimal amount of permissions necessary for the client
    do their job. In this concrete example, `petstore-ui` should only be allowed to
    perform a request allowed for customers on behalf of tomek. In order to configure
    that, we will need to introduce scopes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了用户 tomek，并赋予他们客户和管理员角色。如果 tomek 使用 `petstore-ui`，他们应该能够调用允许管理员角色的请求吗？不。`petstore-ui`
    的目的是供商店客户使用。我们在理论部分提到，身份验证服务器应该创建一个包含客户端执行其工作所需的最小权限数量的访问令牌。在这个具体的例子中，`petstore-ui`
    应该只允许代表 tomek 执行允许客户进行的请求。为了配置这一点，我们需要引入范围。
- en: Scopes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: Keycloak scope is a tool that allows you to specify which roles will be associated
    with an access token generated for a specific client. Let's create a scope for
    the `pestore-ui` client.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 范围是一个工具，允许您指定哪些角色将与为特定客户端生成的访问令牌相关联。让我们为 `pestore-ui` 客户端创建一个范围。
- en: 'In order to do this, you have to click on Clients in the left-hand side menu,
    choose the petstore-ui client, and click on the Scope tab below the client''s
    name:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您必须在左侧菜单中点击“客户端”，选择 `petstore-ui` 客户端，然后在客户端名称下点击“范围”标签：
- en: '![](img/281f5096-1274-445c-9954-3c8dec4abfd6.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/281f5096-1274-445c-9954-3c8dec4abfd6.png)'
- en: As you will have noticed in the preceding screenshot, each client has the full
    scope allowed parameter set to true by default. This means that each role that
    an authenticated user has will be associated with an access token created for
    that client. In order to limit the roles of the given client, we have to turn
    this option off and manually choose the roles that are allowed. In our example,
    we will need to choose the customer role and move it to assigned roles.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的屏幕截图中所注意到的，每个客户端默认将允许的完整范围参数设置为true。这意味着认证用户拥有的每个角色都将与为该客户端创建的访问令牌相关联。为了限制给定客户端的角色，我们必须关闭此选项并手动选择允许的角色。在我们的例子中，我们需要选择客户角色并将其移动到分配的角色。
- en: The admin role has not been moved. As a result, if an access token is generated
    for `petstore-ui` on behalf of tomek, it will only contain the customer role.
    As a result, tomek won't be able to perform any admin operations from within the
    `petstore-ui` client.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员角色尚未移动。因此，如果为tomek代表`petstore-ui`生成访问令牌，它将只包含客户角色。因此，tomek将无法从`petstore-ui`客户端执行任何管理员操作。
- en: We have pretty much configured Keycloak.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经基本配置了Keycloak。
- en: So, how do you configure the Java services? Before finding that out, let's introduce
    the next functionality that requires user authentication—the cart service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何配置Java服务？在找到答案之前，让我们介绍下一个需要用户身份验证的功能——购物车服务。
- en: Cart service
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车服务
- en: Let's introduce the cart service implementation. First of all, we have to add
    the new resources to the customer-gateway API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍购物车服务的实现。首先，我们必须将新资源添加到客户网关API中。
- en: 'Examples reference: `chapter10/cart-service`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例参考：`chapter10/cart-service`
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you will have noticed in the preceding code, we have added three cart methods.
    All of them identify the cart by `customerId` (we will show you how to obtain
    this in few moments) and the cart item using the `itemId` of the application.
    As in previous chapters, all the methods delegate the implementation to the gateway
    service, which in turn uses proxies to propagate the invocation to backend services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所注意到的，我们添加了三个购物车方法。所有这些方法都通过`customerId`（我们将在几分钟内向您展示如何获取它）和应用程序的`itemId`来识别购物车。正如前几章所做的那样，所有方法都将实现委托给网关服务，该服务反过来使用代理将调用传播到后端服务。
- en: In order to perform operations on the cart, a user has to be authenticated to
    the system. Let's secure the `GatewayResource` to make sure that an unauthorized
    user will be denied access to those methods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对购物车执行操作，用户必须对系统进行身份验证。让我们确保`GatewayResource`的安全性，以确保未经授权的用户将无法访问这些方法。
- en: WildFly Swarm Keycloak adapter
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WildFly Swarm Keycloak适配器
- en: As you will know from the theoretical section, services with a secured API will
    have to authorize their users based on authentication tokens. In order to do that,
    they have to cooperate with the Keycloak server using, in our example, the OIDC
    protocol. Obviously, we will not implement this functionality ourselves. As we've
    suggested, Keycloak provides a number of adapters for different tools. WildFly
    Swarm has its own adapter too. So, how will we install it?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从理论部分所知，具有安全API的服务必须根据身份验证令牌对其用户进行授权。为了做到这一点，它们必须与Keycloak服务器合作，在我们的例子中，使用OIDC协议。显然，我们不会自己实现此功能。正如我们建议的那样，Keycloak为不同的工具提供了一系列适配器。WildFly
    Swarm也有自己的适配器。那么，我们将如何安装它？
- en: 'Let''s extend customer-gateway''s `pom.xml`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展客户网关的`pom.xml`：
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's it—the adapter is installed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——适配器已安装。
- en: 'We have one more thing to do. We have to configure the adapter. In order to
    do this, we have to add the `keycloak.json` file inside the Maven''s resources
    directory. The file contains a bunch of adapter configuration properties. In our
    case, it''s pretty simple:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一件事要做。我们必须配置适配器。为了做到这一点，我们必须在Maven的资源目录内添加`keycloak.json`文件。该文件包含一些适配器配置属性。在我们的例子中，这相当简单：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Basically, the files tell the adapter the `auth-server`''s location, the realm,
    and the resource name. As you may recall, we were behind all of those: we created
    the route to the Keycloak server deployed on OpenShift, created the realm for
    our petstore application, and told Keycloak that we will authenticate using the
    `petstore-ui` client, which we configured.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这些文件告诉适配器`auth-server`的位置、域和资源名称。如您所回忆的那样，我们都在这些后面：我们创建了指向部署在OpenShift上的Keycloak服务器的路由，为我们的宠物商店应用程序创建了域，并告诉Keycloak我们将使用配置的`petstore-ui`客户端进行身份验证。
- en: 'Please, note that we need to provide `KEYCLOAK_URL` as an environment variable.
    This is an URL of the keycloak proxy that we have created. You are able to configure
    this variable in the web-console:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/891df04f-75c0-4a05-bb41-c83ade4c344d.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: After this information is provided, the Keycloak adapter will be able to authorize
    users based on the access token provided by the UI. This is good, but we haven't
    protected our resources yet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we have to introduce few changes to customer-gateway''s
    main class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you will have noticed in the preceding code, after marking `deployment` as
    `Secured`, we are able to use a chained API that we use to specify which request
    on which resources to protect and which roles are allowed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding code, we have made sure that only users with the `customer`
    role is able to use cart-associated methods in the customer API. Note, however,
    that the backend cart service has to be secured as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: We will secure it to the gateway service in an analogous way, which makes sure
    that it has dependency on swarm's Keycloak adapter, adding `keycloak.json` to
    the classpath (note that the context of the file will be the same, as all the
    properties stay valid), and making deployment secure in the main function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one problem though: in the gateway service, we have relied on the UI
    to send us access token each time the request is performed by an authenticated
    user. As you may recall from the previous chapters, we use Rest Client to perform
    the invocation on the backend service, and are responsible for attaching all the
    necessary information. As a result, we also have to propagate the access token
    to backend services during the invocation. If we don''t do this, Keycloak adapter
    in the backend service will recognize the request being performed as anonymous,
    which is clearly invalid.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to propagate the context, we will implement a simple JAX-RS client
    request filter. In our scenario, we will check whether the access token is present
    and, if true, propagate it further to the invocation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s analyze this code step by step:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall, JAX-RS `ClientRequestFilter` (1) filters every invocation
    performed by the client associated with it before it is propagated to the server.
    In our scenario, we will check whether the access token is present and attach
    it to each request if true.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In (2), we are injecting the `SecurityContext`. If Keycloak has authorized the
    user using the access token, it creates the `SecurityContext` and attaches it
    to the request. As a result, we will inject it into the objects on the invocation
    thread.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `SecurityContext` created by Keycloak contains the `KeycloakPrincipal` implementation
    of the principal interface (3).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the principal is present, we will be able to obtain further `KeycloakSecurityContext`
    from it (5).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the token can be obtained from the context and propagated further as
    a `BEARER` token.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at `CartProxy` now:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The proxy is similar to the proxies that we created in previous chapters and
    uses the standard JAX-RS client API to create an appropriate request to the backend
    cart-service. However, we have to register the `TokenPropagationFilter` that we
    have just created for the client
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sum up what we have already done: we have extended the customer-gateway
    with cart methods, added a Keycloak adapter and its configuration to the project,
    and marked deployment as `Secured`, specifying the roles that are authorized to
    use the given methods. We did this for both customer-gateway and backend cart-service.
    In order to make sure that the access token is propagated to the backend service,
    we have implemented an appropriate filter and registered it inside our proxy.
    It seems that the authentication should work now. Let''s try it!'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to find UI application in the attached code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '`chapter10/petstore-ui`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the petstore application and open the UI:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/407336b0-d574-4968-9fe0-049ce30dcb4a.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, no user is logged in to the application. To obtain
    all the necessary data, the client had to perform the invocation on the items
    resource. As the resource is not protected, the invocation was successful. In
    order to log in to the cart, we have to be authenticated. Let''s do it:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/576df6c1-a780-431f-b200-1b4ae6b61516.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Log in button redirected us to Keycloak server. After providing
    your credentials, Keycloak will authenticate you and redirect you to the store:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff6da6f-2519-4a22-a3f7-fad96f83d811.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'As you will have noticed in the preceding screenshot, we have successfully
    logged in to the UI. You can now add items to the cart and take a look at the
    cart view:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9195f0f-b709-48d4-a731-b672332b7ed1.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: We have shown you the operation of the store with a valid security configuration,
    but feel free to play with the sample application in order to confirm that the
    security works correctly. You may create and remove roles from the user in the
    Keycloak console, or make the service require different roles for authorization.
    You will see that Keycloak is indeed able to correctly authorize a user; users
    with valid roles will be allowed to perform a request and users lacking valid
    roles will be forbidden.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: SSL configuration
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of this chapter, when we describe bearer tokens,
    when you use this kind of authentication in a production environment, you have
    to use encrypted connections. In this section, we will describe how WildFly Swarm
    and OpenShift support the use of secure connections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: We will separate this section into two different cases, depending on whether
    we consider our cloud environment to be secured or not.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Secured cloud
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a scenario where the cloud environment that you are using is secure, you
    will need to configure an encrypted connection between external clients and routers:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e2d2f1c-144e-4e50-9cc0-1be157f5b840.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
- en: In such a case, we have to configure an Edge router. An Edge router has its
    own certificate and is able to establish secure connections with external clients.
    Before proxying traffic to the destination, the router encrypts the connection.
    As a result, in the OpenShift cluster, communication happens through unsecured
    connections.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'You are able to configure edge routing for each route that you create. In order
    to do so, you have to create routes in the standard way (choose the service to
    which you want the route to be established and click on Create route). Later,
    you have to choose a Secure route so, pick Edge from the TLS termination drop-down
    menu and enter your Certificate in the PEM format in the form, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac9287b-a02c-4925-9549-aa1b0e75c72a.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: Unsecured cloud
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some circumstances, you may need to configure secure connections for all
    communication, both with external services and within the cloud:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71073c02-2403-439f-8a4b-33865f8d80c9.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: In order to do so, you have to configure a route with passthrough TLS termination
    (by creating the route in the same way as in the paragraph before and choosing
    pass-through termination).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: With the pass-through termination, the router does not terminate the TLS connection
    and the encrypted traffic is propagated to the target. One of its implications
    is that targets (and all other services) need to have their security setting configured.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm enables you to do this easily by providing HTTP configuration. Let''s
    look at the example configuration:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding configuration specifies that the server will only use the secured
    connection on the `8443` port. It specifies the location of both `trustore` and
    `keystore` (classpath) and their `password`s.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've shown how you can use distributed security protocols
    to secure your cloud applications using our practical example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this chapter by introducing concepts based on distributed authentication
    and authorization: the rationale for tokens and how they can be obtained and used.
    Later, we introduced basic information about a concrete distributed security protocol:
    OpenID Connect.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In the practical section, we used the Keycloak SSO server to secure the cart
    service in the Petstore application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In the, we will discuss how do deal with an unreliable network problem using
    a circuit breaker pattern; specifically, the Hystrix library.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://oauth.net/2/](https://oauth.net/2/)'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[http://openid.net/developers/specs/](http://openid.net/developers/specs/)'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://www.keycloak.org/](https://www.keycloak.org/)'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
