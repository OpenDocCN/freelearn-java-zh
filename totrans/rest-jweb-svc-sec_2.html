<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The Importance of Securing Web Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The Importance of Securing Web Services</h1></div></div></div><p>Look at you; you have made it to Chapter 2; congratulations! This chapter is quite important because it is related to a concept that is implicit in software, which is <span class="strong"><strong>security</strong></span>. This is very important because<a class="indexterm" id="id38"/> software is used by companies and people like us. Sometimes, we share very important and confidential information through software, and that is why this topic becomes so important for everybody.</p><p>In this chapter, we will take you through the basic aspects related to the management of security in computer systems.</p><p>We will explore and implement each of the different security mechanisms and scenarios in which they can be used.</p><p>Also, you'll learn how to use a protocol analyzer. This will allow us to demonstrate how an attack can be performed and determine the impact of this attack when it achieves its target, in this case, our information. Also, you will be able to imagine more options to implement security in web services.</p><p>As everything needs practice, you will go through a simple example of code to learn the differences between authentication and authorization. Get ready for an interesting and useful topic.</p><p>In this chapter, we will cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the importance of security management</li><li class="listitem" style="list-style-type: disc">Exploring and implementing the different available mechanisms of security</li><li class="listitem" style="list-style-type: disc">Using a protocol analyzer to intercept requests</li><li class="listitem" style="list-style-type: disc">Understanding the difference between authentication and authorization</li></ul></div><div class="section" title="The importance of security"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The importance of security</h1></div></div></div><p>The management of security is one of the main aspects to consider when designing applications.</p><p>No matter what, neither the functionality nor the information of organizations can be exposed to all users without any kind of restriction. Consider the case of a human resource management <a class="indexterm" id="id39"/>application that allows you to consult the wages of employees, for example: if the company manager needs to know the salary of one of their employees, it is not something of great importance. However, in the same context, imagine that one of the employees wants to know the salary of their colleagues; if access to this information is completely open, it can generate problems among employees with varied salaries.</p><p>An even more critical example can be the case where the bank XYZ increases a bank balance every time a customer or a third party makes a deposit into one of their accounts using an ATM. The IT manager envisions that this functionality could be common, and decides to implement it as a web service. Right now, this functionality is limited to bank users logged in to <a class="indexterm" id="id40"/>the application that uses this web service. Suppose that the visions of the future of the IT manager come true, and this functionality is now required from an ATM; raising this requirement quickly indicates that such functionality is implemented and can be used by invoking the web service. So far, there may be no security loopholes since ATMs are likely to have a security system that controls access, and thus operating system access to the functionality of the web service is also indirectly controlled.</p><p>Now, imagine that the company ABC wants a similar functionality to increase the balance in one of its employee's bank account by an <span class="emphasis"><em>x</em></span> amount in recognition of some kind of contribution to the company. What happens to the functionality of the web service? Do you think you can again trust the application that handles its own security scheme to control access to its functionality? Even if we do trust this mechanism, what if the request is intercepted by a sniffer? Then, anyone who knows how to perform the request may increase the balance. These questions, when answered, throw in the response in quite a logical way. Exposed, these scenarios now sound quite logical so that whoever authenticates the user to have access to this functionality is the web service, and as such, should be entrusted with the management scheme security systems under all circumstances. It doesn't matter if invocations are from the organization itself or from an external institution; security control must be present in order to expose a sensitive functionality such as the one we just outlined.</p><p>When sharing existing information or functionality through web services, it is well known that we don't depend on programming languages, architectures, or system platforms to interact with. This gives us flexibility and saves us from having to rewrite the existing functionality. Going further, we should understand that these features have an impact on data confidentiality, as we are going to share information and/or functionality with entities or systems. This way, we can accomplish the business objectives and definitely prevent intruders<a class="indexterm" id="id41"/> from reading our information; or even worse, a third party not authorized has access to functionalities exposed by our services. Hence, access to them must be rigorously analyzed and our exposed services must be correctly ensured.</p></div></div>
<div class="section" title="Security management options"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Security management options</h1></div></div></div><p>Java provides some<a class="indexterm" id="id42"/> options for security management. Right now, we will explain some of them and demonstrate how to implement them. All authentication methods are practically based on credential delivery from the client to the server. There are several methods to perform this, which are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">BASIC authentication</li><li class="listitem" style="list-style-type: disc">DIGEST authentication</li><li class="listitem" style="list-style-type: disc">CLIENT CERT authentication</li><li class="listitem" style="list-style-type: disc">Using API keys</li></ul></div><p>Security management in applications built with Java, including the ones with RESTful web services, always rely on JAAS.</p><p>
<span class="strong"><strong>Java Authentication and Authorization Service</strong></span> (<span class="strong"><strong>JAAS</strong></span>) is a<a class="indexterm" id="id43"/> framework that is part of Java Platform Enterprise Edition. Hence, it is the default standard to handle an application's security in Java; it allows you to implement authorization, and it allows authentication controls over applications with the purpose of protecting resources that belong to the application. If you want to know more about JAAS, you can check out the following link:</p><p>
<a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html">http://docs.oracle.com/javase/7/docs/technotes/guides/security/jaas/tutorials/GeneralAcnOnly.html</a>
</p><p>If you don't want to use JAAS, of course it is always possible to create our own implementation to handle securities, but it would be hard. So, why don't we save ourselves some time, effort, and peace by implementing this useful technology? It is recommended to use standard implementations whenever possible. In our development exercise, we will use JAAS for the first three methods of authentication.</p><div class="section" title="Authorization and authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Authorization and authentication</h2></div></div></div><p>When you these terms, it is <a class="indexterm" id="id44"/>very easy to get confused, but<a class="indexterm" id="id45"/> they have different meanings when you have a security system approach. In order to clarify these terms, we will explain them in this section.</p><div class="section" title="Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Authentication</h3></div></div></div><p>In a nutshell, this term refers to <span class="emphasis"><em>who you are</em></span>. It is the process to identify a user, usually through their <span class="emphasis"><em>username</em></span> and <span class="emphasis"><em>password</em></span>. When we use this concept, we are trying to ensure the identity of the user and we verify the identity the user claims to be. Also, it doesn't have anything to do with the<a class="indexterm" id="id46"/> access rights the user has.</p><p>Security research has specified a list of factors that should be verified in order to achieve positive authentication. This list contains three elements, where it is very common to use two of them, but preferably we should use all of them. These elements are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Knowledge factors</strong></span>: This element implies something the user <span class="strong"><strong>knows</strong></span>, for example, a password, pass <a class="indexterm" id="id47"/>phrase, or personal identification number (PIN). Another example is challenge response, where<a class="indexterm" id="id48"/> the user must answer a question, software token, or phone serving as a software token.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Ownership factors</strong></span>: This is <a class="indexterm" id="id49"/>something the user <span class="emphasis"><em>has</em></span>, for example, a wrist band (in case of physical authentication), ID card, security<a class="indexterm" id="id50"/> token, or cell phone with a built-in hardware token.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Inherence factors</strong></span>: This is something the user <span class="emphasis"><em>is</em></span> or <span class="emphasis"><em>does</em></span>, for example, fingerprint or retinal <a class="indexterm" id="id51"/>pattern, DNA<a class="indexterm" id="id52"/> sequence, signature, face, voice, unique bio-electric signals, or other biometric identifiers.</li></ul></div></div><div class="section" title="Authorization"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Authorization</h3></div></div></div><p>In a few words, this term refers to <span class="emphasis"><em>what you can do</em></span>. It is the process of giving a user permission to do or have something. When we talk about software, we have a system administrator that is in charge of defining the system which users are allowed to access and what the privileges of use are (such as access to which file directories, access period, amount of allocated storage space, and so forth).</p><p>Authorization is<a class="indexterm" id="id53"/> often seen as both the introductory setting up of permissions by a system administrator and the checking of the permission values that have already been set up when a user is getting access.</p></div></div><div class="section" title="Access control"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Access control</h2></div></div></div><p>A very common use <a class="indexterm" id="id54"/>of authentication and authorization is access control. A computer system that is supposed to be used only by authorized users must attempt to detect and reject unauthorized users. Access is controlled by persisting on an authentication process to establish the user's identity with a certain level of confidence, also conferring privileges specified for that identity. Let's name some examples of access control involving <a class="indexterm" id="id55"/>authentication in different scenarios, such as the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calling for photo ID when a contractor first arrives at a house to do some work</li><li class="listitem" style="list-style-type: disc">Implementing captcha as a way of verification that a user is a human being and not a computer program</li><li class="listitem" style="list-style-type: disc">When using a <a class="indexterm" id="id56"/><span class="strong"><strong>One Time Password</strong></span> (<span class="strong"><strong>OTP</strong></span>) obtained on telenetwork-enabled devices such as mobile phones as an authentication password/PIN</li><li class="listitem" style="list-style-type: disc">A computer program that uses a blind credential in order to authenticate to another program</li><li class="listitem" style="list-style-type: disc">When you enter a country with a passport</li><li class="listitem" style="list-style-type: disc">When you log in to a computer</li><li class="listitem" style="list-style-type: disc">When a service uses a confirmation e-mail to verify ownership of an e-mail address</li><li class="listitem" style="list-style-type: disc">Using an Internet banking system</li><li class="listitem" style="list-style-type: disc">When you withdraw cash from an ATM</li></ul></div><p>Sometimes, the ease of access is adjusted against the strictness of access checks. For example, a small transaction usually doesn't require a signature of the authenticated person as proof of the transaction's authorization.</p><p>However, security experts argue that it is impossible to prove the user's identity with absolute certainty. It is only possible to apply a set of tests which, if passed, have been previously declared as a minimum to confirm the identity. The problem lies in how to determine which tests are enough; it depends on the company to determine this set.</p><div class="section" title="Transport layer security"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Transport layer security</h3></div></div></div><p>In this section, we highlight some of the main<a class="indexterm" id="id57"/> features of TLS:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Its predecessor is<a class="indexterm" id="id58"/> <span class="strong"><strong>Secure Sockets Layer</strong></span> (<span class="strong"><strong>SSL</strong></span>)</li><li class="listitem" style="list-style-type: disc">It is a <a class="indexterm" id="id59"/>cryptographic protocol</li><li class="listitem" style="list-style-type: disc">It provides security communication over the Internet</li><li class="listitem" style="list-style-type: disc">It authenticates the counterpart through X.509 certificates (asymmetric cryptography)</li><li class="listitem" style="list-style-type: disc">It allows client-server applications to communicate over the network and prevents eavesdropping and tampering</li><li class="listitem" style="list-style-type: disc">TLS is often implemented on top of the Transport layer protocols</li><li class="listitem" style="list-style-type: disc">It encapsulates<a class="indexterm" id="id60"/> application-specific protocols such as HTTP, FTP, SMTP, NNTP, and XMPP</li><li class="listitem" style="list-style-type: disc">The use of TLS<a class="indexterm" id="id61"/> should be delegated, especially when credentials, updates, deletions, and any kind of value transactions are performed</li><li class="listitem" style="list-style-type: disc">The overhead of TLS is very low on modern hardware, with a little increase of latency, but this represents more safety for the end user</li></ul></div></div></div><div class="section" title="Basic authentication by providing user credentials"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Basic authentication by providing user credentials</h2></div></div></div><p>Possibly, basic authentication is one of the most used techniques in all types of applications. The user, before<a class="indexterm" id="id62"/> gaining functionality over the application, is requested to enter a username and password. Both are validated in order to verify whether the credentials are correct (they belong to an application user). We are 99 percent sure you have performed this technique at least once, maybe through a customized mechanism, or if you have used the JEE platform, probably through JAAS. This kind of control is known as <span class="strong"><strong>basic authentication</strong></span>.</p><p>The main problem with this security<a class="indexterm" id="id63"/> implementation is that credentials are propagated in a plain way from the client to the server. This way, any sniffer could read the sent packages over the network. We will consider an example using a tool named Wireshark; it is a protocol analyzer that will show this problem. For installation, we can go to the <a class="indexterm" id="id64"/>link <a class="ulink" href="http://www.wireshark.org/download.html">http://www.wireshark.org/download.html</a>.</p><p>The installation is pretty basic (click on <span class="strong"><strong>Next</strong></span> all the way). For this reason, we will not show screenshots of these steps.</p><p>Now, we are going to modify the project from <a class="link" href="ch01.html" title="Chapter 1. Setting Up the Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up the Environment</em></span>, where the user tries to invoke any of the functions of the web service. The user will be requested to enter a username and password; once these are verified, the user will have access to the web service functionality.</p><p>In order to have a working example, let's start our application server JBoss AS 7; then, go to the <code class="literal">bin</code> directory and execute the file <code class="literal">add-user.bat</code> (the <code class="literal">.sh</code> file for UNIX users). Finally, we will create a new user as follows:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_01.jpg"/></div><p>The most important thing here is that you should select <code class="literal">Application User</code> in the first question and assign it an <code class="literal">admin</code> role. This will match with the information defined in the <code class="literal">web.xml</code> file, which will be explained later when we implement securities inside our application. As a result, we will have a new user in the <code class="literal">JBOSS_HOME/standalone/configuration/application - users.properties</code> file.</p><p>JBoss is already set <a class="indexterm" id="id65"/>with a default security domain called <code class="literal">other</code>; this domain uses the information stored in the file we mentioned earlier in order to authenticate. Right now, we will configure the application to use this security domain inside the folder <code class="literal">WEB-INF</code> from the <code class="literal">resteasy-examples</code> project. Let's create a file named <code class="literal">jboss-web.xml</code> with the following content:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jboss-web&gt;
  &lt;security-domain&gt;other&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre></div><p>Alright, let's configure the file <code class="literal">web.xml</code> in order to aggregate the security constraints. In the following block of code, you will see in bold what you should add:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="3.0" 
  
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
  http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"&gt;
<span class="strong"><strong>      &lt;!-- Roles --&gt;</strong></span>
<span class="strong"><strong>  &lt;security-role&gt;</strong></span>
<span class="strong"><strong>    &lt;description&gt;Any rol &lt;/description&gt;</strong></span>
<span class="strong"><strong>    &lt;role-name&gt;*&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-role&gt;</strong></span>
<span class="strong"><strong>        </strong></span>
<span class="strong"><strong>      &lt;!-- Resource / Role Mapping --&gt;</strong></span>
<span class="strong"><strong>  &lt;security-constraint&gt;</strong></span>
<span class="strong"><strong>    &lt;display-name&gt;Area secured&lt;/display-name&gt;</strong></span>
<span class="strong"><strong>    &lt;web-resource-collection&gt;</strong></span>
<span class="strong"><strong>      &lt;web-resource-name&gt;protected_resources&lt;/web-resource-name&gt;</strong></span>
<span class="strong"><strong>      &lt;url-pattern&gt;/services/*&lt;/url-pattern&gt;</strong></span>
<span class="strong"><strong>      &lt;http-method&gt;GET&lt;/http-method&gt;</strong></span>
<span class="strong"><strong>      &lt;http-method&gt;POST&lt;/http-method&gt;</strong></span>
<span class="strong"><strong>    &lt;/web-resource-collection&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-constraint&gt;</strong></span>
<span class="strong"><strong>      &lt;description&gt;User with any role&lt;/description&gt;</strong></span>
<span class="strong"><strong>      &lt;role-name&gt;*&lt;/role-name&gt;</strong></span>
<span class="strong"><strong>    &lt;/auth-constraint&gt;</strong></span>
<span class="strong"><strong>  &lt;/security-constraint&gt;</strong></span>

<span class="strong"><strong>  &lt;login-config&gt;</strong></span>
<span class="strong"><strong>    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;</strong></span>
<span class="strong"><strong>  &lt;/login-config&gt;</strong></span>
&lt;/web-app&gt;</pre></div><p>From a terminal, let's go to the home folder of the <code class="literal">resteasy-examples</code> project and execute <code class="literal">mvn jboss-as:redeploy</code>. Now, we will test our web service as we did in <a class="link" href="ch01.html" title="Chapter 1. Setting Up the Environment">Chapter 1</a>, <span class="emphasis"><em>Setting Up the Environment</em></span>, using<a class="indexterm" id="id66"/> SOAP UI. We will perform a request using the <code class="literal">POST</code> method to the URL <code class="literal">http://localhost:8080/resteasy-examples/services/person/</code> with the following XML:</p><div class="informalexample"><pre class="programlisting">&lt;person&gt;&lt;name&gt;Rene&lt;/name&gt;&lt;lastname&gt;Enriquez&lt;/lastname&gt;&lt;/person&gt;</pre></div><p>We obtain the following response:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_02.jpg"/></div><p>SOAP UI shows us the HTTP 401 error, which means that the request wasn't authorized. This is because<a class="indexterm" id="id67"/> we performed the request without delivering the credentials to the server. In order to do this, we have to click on the (<span class="strong"><strong>…</strong></span>) button that is located in the left-bottom spot of SOAP UI and enter the user's credentials we just created, as shown in the following screenshot:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_03.jpg"/></div><p>Now is the time to enable our traffic analyzer. Let's start Wireshark and set it to analyze the traffic inside the loopback address. From the <span class="strong"><strong>Main</strong></span> menu, navigate to <span class="strong"><strong>Capture</strong></span> | <span class="strong"><strong>Interfaces</strong></span>.</p><p>Check the option <span class="strong"><strong>lo0</strong></span>, as shown in the following screenshot, and then click on the <span class="strong"><strong>Start</strong></span> button. This way, all traffic that goes<a class="indexterm" id="id68"/> through the address 127.0.0.1 or its equivalent localhost will be intercepted for our analysis.</p><p>Also, in the field <code class="literal">Filter</code>, we will type <code class="literal">http</code> just to intercept the HTTP request and response, as shown in the screenshot that follows later:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_04.jpg"/></div><p>Have a look at the following screenshot:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_05.jpg"/></div><p>Once we have done this, we will perform the request operation from SOAP UI. Once again, SOAP UI shows us<a class="indexterm" id="id69"/> a HTTP 201 message; this time, the request is successfully processed. You can see the following columns of information in Wireshark:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>No</strong></span>: This column identifies the request or response in a unique way</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Time</strong></span>: This column identifies the<a class="indexterm" id="id70"/> time to execute the operation</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Source</strong></span>: This column identifies the address where requests/responses are originated</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Destination</strong></span>: This column identifies the target IP address to perform a HTTP request/response</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protocol</strong></span>: This column identifies the protocol where requests/responses are performed</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Length</strong></span>: This column identifies the request/response length</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Info</strong></span>: This column identifies information related to the request/response</li></ul></div><p>Now, it is time to watch the information traffic on Wireshark, as follows:</p><div class="mediaobject"><img alt="Basic authentication by providing user credentials" src="graphics/0109OS_02_06.jpg"/></div><p>Notice how Wireshark shows us we are performing a POST (info) operation using the protocol HTTP with an XML string (protocol) to the target address <code class="literal">127.0.0.1</code> (destination). Also, you can read the username and<a class="indexterm" id="id71"/> password. Hence, this method is not very safe for security implementation because anyone can access this information and perform a phishing attack.</p><p>You can find the source code for this chapter at the following URL:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/basic-authentication</a>
</p></div><div class="section" title="Digest access authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Digest access authentication</h2></div></div></div><p>This authentication method makes use of a hash function to encrypt the password entered by the user before sending it to the server. This, obviously, makes it much safer than the basic authentication<a class="indexterm" id="id72"/> method, in which the user's password travels in plain text that can be easily read by whoever intercepts it. To overcome such drawbacks, digest md5 authentication applies a function on the combination<a class="indexterm" id="id73"/> of the values of the username, realm of application security, and password. As a result, we obtain an encrypted string that can hardly be interpreted by an intruder.</p><p>To better understand this process, we will show you a simple explanation extracted from Wikipedia.</p><div class="section" title="An example with explanation"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>An example with explanation</h3></div></div></div><p><span class="emphasis"><em>The following example was originally given in RFC 2617 and is expanded here to show the full text expected for each request and response. Note that only the <code class="literal">auth</code> (authentication) quality of protection code is covered—at the time of writing, only the Opera and Konqueror web browsers are known to support <code class="literal">auth-int</code> (authentication with integrity protection). Although the specification mentions HTTP Version 1.1, the scheme can be successfully added to the Version 1.0 server, as shown here.</em></span></p><p><span class="emphasis"><em>This typical transaction consists of the following steps:</em></span></p><p><span class="emphasis"><em>The client asks for a page that requires authentication but does not provide a username and password. Typically, this is because the user simply entered the address or followed a link to the page.</em></span></p><p><span class="emphasis"><em>The server responds with the 401 "Unauthorized" response code, providing the authentication realm and a randomly generated, single-use value called <code class="literal">nonce</code>.</em></span></p><p><span class="emphasis"><em>At this point, the browser will present the<a class="indexterm" id="id74"/> authentication realm (typically, a description of the computer or system being accessed) to the user and prompt for a username and password. The user may decide to cancel at this point.</em></span></p><p><span class="emphasis"><em>Once a username and password have been supplied, the client resends the same request but adds an authentication header that includes the response code.</em></span></p><p><span class="emphasis"><em>In this example, the server accepts the authentication and the page is returned. If the username is invalid and/or the password is incorrect, the server might return the <span class="emphasis"><em>401</em></span> response code and the client will prompt the user again.</em></span></p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>A client may already have the <a class="indexterm" id="id75"/>required username and password without needing to prompt the user, for example, if they have previously been stored by a web browser.</p><p>If you want to know more about this mechanism, you can visit Wikipedia for the complete article following the link <a class="ulink" href="http://en.wikipedia.org/wiki/Digest_access_authentication">http://en.wikipedia.org/wiki/Digest_access_authentication</a>.</p><p>You can also read the specification RFC 2617, which is available at <a class="ulink" href="https://www.ietf.org/rfc/rfc2617.txt">https://www.ietf.org/rfc/rfc2617.txt</a>.</p></div></div><p>Now, let's test this <a class="indexterm" id="id76"/>mechanism in our example.</p><p>In order to start, we must ensure that the environment variable <code class="literal">JAVA_HOME</code> is already set and added to the <code class="literal">PATH</code> variable. So, you can ascertain this by typing the following command in a terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -version</strong></span>
</pre></div><p>This will display the information shown in the following screenshot:</p><div class="mediaobject"><img alt="An example with explanation" src="graphics/0109OS_02_07.jpg"/></div><p>This command shows us the Java version installed on our PC. In case you obtain an error instead of the previous output, you should create the environment variable <code class="literal">JAVA_HOME</code>, add it to the <code class="literal">PATH</code> variable, and repeat the verification.</p><p>Now, in order to perform <a class="indexterm" id="id77"/>what we explained before, we need to generate a password for our example user. We have to generate the password using the parameters we talked about earlier—username, realm, and password. Let's go to the directory of <code class="literal">JBOSS_HOME/modules/org/picketbox/main/</code> from a terminal and type the following:</p><p>
<code class="literal">java -cp picketbox-4.0.7.Final.jar org.jboss.security.auth.callback.RFC2617Digest username MyRealmName password</code>
</p><p>We will obtain the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>RFC2617 A1 hash: 8355c2bc1aab3025c8522bd53639c168</strong></span>
</pre></div><p>Through this process, we obtain the encrypted password and use it in our password storage file (the <code class="literal">JBOSS_HOME/standalone/configuration/application-users.properties</code> file). We must replace the password in the file, and it will be used for the user <code class="literal">username</code>. We have to<a class="indexterm" id="id78"/> replace it because the old password doesn't contain the realm name information of the application. As an alternative, you can create a new user using the file <code class="literal">add-user.sh</code>; you just have to deliver the realm information when you are requested.</p><p>In order to make our application work, we just need to make a little change in the <code class="literal">web.xml</code> file. We have to modify the <code class="literal">auth-method</code> tag, change the value <code class="literal">FORM</code> to <code class="literal">DIGEST</code>, and set the application realm name in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;login-config&gt;


  &lt;auth-method&gt;DIGEST&lt;/auth-method&gt;

  
  &lt;realm-name&gt;MyRealmName&lt;/realm-name&gt;  
&lt;/login-config&gt;</pre></div><p>Now, let's create a new security domain in JBoss so that we can manage the authentication mechanism <code class="literal">DIGEST</code>. On the <code class="literal">&lt;security-domains&gt;</code> section of the <code class="literal">JBOSS_HOME/standalone/configuration/standalone.xml</code> file, let's add the following entry:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="domainDigest" cache-type="default"&gt; &lt;authentication&gt;
    &lt;login-module code="UsersRoles" flag="required"&gt; &lt;module-option name="usersProperties" value="${jboss.server.config.dir}/application-users.properties"/&gt; &lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/application-roles.properties"/&gt; &lt;module-option name="hashAlgorithm" value="MD5"/&gt; &lt;module-option name="hashEncoding" value="RFC2617"/&gt;
      &lt;module-option name="hashUserPassword" value="false"/&gt;
      &lt;module-option name="hashStorePassword" value="true"/&gt;
      &lt;module-option name="passwordIsA1Hash" value="true"/&gt; 
      &lt;module-option name="storeDigestCallback" value="org.jboss.security.auth.callback.RFC2617Digest"/&gt; &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></div><p>Finally, in the application, change the security domain name in the file <code class="literal">jboss-web.xml</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jboss-web&gt;
  &lt;security-domain&gt;java:/jaas/domainDigest&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre></div><p>We will change the authentication method from <code class="literal">BASIC</code> to <code class="literal">DIGEST</code> in the <code class="literal">web.xml</code> file. Also, we will enter the name <a class="indexterm" id="id79"/>of the security realm. All these changes must be applied in the tag <code class="literal">login-config</code> in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;login-config&gt;
  &lt;auth-method&gt;DIGEST&lt;/auth-method&gt;
  &lt;realm-name&gt;MyRealmName&lt;/realm-name
&lt;/login-config&gt;</pre></div><p>Now, restart the application server <a class="indexterm" id="id80"/>and redeploy the application on JBoss. For this, execute the following command in the terminal command line:</p><div class="informalexample"><pre class="programlisting">mvn jboss-as:redeploy</pre></div><p>Let's enable the catching of traffic through Wireshark and test the web service again using SOAP UI. First, we should change the field <code class="literal">Authentication Type</code> from Global HTTP Settings to <span class="strong"><strong>SPNEGO/Kerberos</strong></span>. A very useful trick is to tell SOAP UI not to use the basic authentication method. Once we execute the request, Wireshark will tell us the message shown in the following screenshot:</p><div class="mediaobject"><img alt="An example with explanation" src="graphics/0109OS_02_08.jpg"/></div><p>As shown in the screenshot, let's first confirm that all the steps described earlier are performed in this authentication method. Let's keep track using the <span class="strong"><strong>No</strong></span> field in Wireshark:</p><p>In step 5, the request is performed.</p><p>In step 7, the server returns an<a class="indexterm" id="id81"/> error message code HTTP 401 with the generated <code class="literal">nonce</code> value. The <code class="literal">nonce</code> value helps to avoid replay attacks.</p><p>In step 9, the request is performed again. This time, the information required for authentication is included and all this information is encrypted in the same way we described earlier.</p><p>Finally, in step 11, we<a class="indexterm" id="id82"/> obtain the response that tells us the request has been successfully executed.</p><p>As you will notice, this is a more secure authentication method, mainly used if you don't want the overhead of full transport security through TLS/SSL encryption.</p><p>You can find the source code for this chapter at the following URL:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/digest-authentication</a>
</p></div></div><div class="section" title="Authentication through certificates"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Authentication through certificates</h2></div></div></div><p>This is a mechanism in which a trust agreement is established between the server and the client through certificates. They<a class="indexterm" id="id83"/> must be signed by an agency established to ensure that the certificate presented for authentication is legitimate, which is known as CA.</p><p>Let's imagine an application that uses this mechanism of security. When the client attempts to access a protected resource, instead of providing a username or password, it presents the certificate to the server. This is the certificate that contains the user information for authentication; in other words, the credentials, besides a unique private-public key pair. The<a class="indexterm" id="id84"/> server determines if the user is legitimate through the CA. Then, it verifies whether the user has access to the resource. Also, you should know that this authentication mechanism must use HTTPS as the communication protocol as we don't have a secure channel and anyone could steal the client's identity.</p><p>Now, we will show how to do this in our example.</p><p>In our example, we turn ourselves into the CA; they are usually companies such as VERISIGN or others. However, as we want to save you money, we will do it this way. The first thing we need is a key for the CA (which is ourselves), and we will sign the certificates for the application server and users. As the purpose of this book is to explain how this method works and not how to generate certificates, we will not include all steps required to generate them, but we include them on GitHub at the following link:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication</a>
</p><p>Alright, let's start. First, copy the <code class="literal">server.keystore</code> and <code class="literal">server.trutstore</code> files to the folder directory <code class="literal">JBOSS_HOME/standalone/configuration/</code>. You can download these files from GitHub using the following link:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/certificates</a>
</p><p>Now, as we mentioned before, this security mechanism requires our application server to use HTTPS as the communication protocol. So, we must enable HTTPS. Let's add a connector in the <code class="literal">standalone.xml</code> file; look for the following line:</p><div class="informalexample"><pre class="programlisting">&lt;connector name="http"</pre></div><p>Add the following block of code:</p><div class="informalexample"><pre class="programlisting">&lt;connector name="https" protocol="HTTP/1.1" scheme="https" socket-binding="https" secure="true"&gt;
  &lt;ssl password="changeit" 
certificate-key-file="${jboss.server.config.dir}/server.keystore" 
verify-client="want" 
ca-certificate-file="${jboss.server.config.dir}/server.truststore"/&gt;

&lt;/connector&gt;</pre></div><p>Next, we add the security domain, as shown:</p><div class="informalexample"><pre class="programlisting">&lt;security-domain name="RequireCertificateDomain"&gt;
                    &lt;authentication&gt;
    &lt;login-module code="CertificateRoles" flag="required"&gt;
                            &lt;module-option name="securityDomain" value="RequireCertificateDomain"/&gt;
                            &lt;module-option name="verifier" value="org.jboss.security.auth.certs.AnyCertVerifier"/&gt;
                            &lt;module-option name="usersProperties" value="${jboss.server.config.dir}/my-users.properties"/&gt;
                            &lt;module-option name="rolesProperties" value="${jboss.server.config.dir}/my-roles.properties"/&gt;
                        &lt;/login-module&gt;
  &lt;/authentication&gt;
  &lt;jsse keystore-password="changeit" keystore-url="file:${jboss.server.config.dir}/server.keystore" 
                        truststore-password="changeit" truststore-url="file:${jboss.server.config.dir}/server.truststore"/&gt;
                &lt;/security-domain&gt;</pre></div><p>As you can see, we need two files: <code class="literal">my-users.properties</code> and <code class="literal">my-roles.properties</code>; both are empty and located in the <code class="literal">JBOSS_HOME/standalone/configuration</code> path.</p><p>We will add the <code class="literal">&lt;user-data-constraint&gt;</code> tag in the <code class="literal">web.xml</code> file in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;security-constraint&gt;
<span class="strong"><strong>...&lt;user-data-constraint&gt;</strong></span>


  &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
  &lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;</pre></div><p>Then, change the authentication method to <code class="literal">CLIENT-CERT</code>, as shown:</p><div class="informalexample"><pre class="programlisting">  &lt;login-config&gt;
    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;
  &lt;/login-config&gt;</pre></div><p>Finally, change<a class="indexterm" id="id85"/> the security domain in the <code class="literal">jboss-web.xml</code> file in the following way:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;jboss-web&gt;
  &lt;security-domain&gt;RequireCertificateDomain&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre></div><p>Now, restart the application server and redeploy the application with Maven using the following command:</p><div class="informalexample"><pre class="programlisting">mvn jboss-as:redeploy</pre></div><p>In order to test this authentication<a class="indexterm" id="id86"/> method, we will have to first perform some configurations in SOAP UI. First, let's go to the installation directory, find the file <code class="literal">vmoptions.txt</code>, and add the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>-Dsun.security.ssl.allowUnsafeRenegotiation=true</strong></span>
</pre></div><p>Now, we will change the SSL settings of SOAP UI. For this, you have to navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Preferences</strong></span> from the principal menu.</p><p>From the pop-up window, select the <span class="strong"><strong>SSL Settings</strong></span> tab and enter the values shown in the following screenshot:</p><div class="mediaobject"><img alt="Authentication through certificates" src="graphics/0109OS_02_09.jpg"/></div><p>
<span class="strong"><strong>KeyStore</strong></span> is the place where you should have copied the <code class="literal">.pfx</code> file. Note that <span class="strong"><strong>KeyStore Password</strong></span> is <code class="literal">changeit</code> and check the option <span class="strong"><strong>requires client authentication</strong></span>.</p><p>Now, we will test the modifications we just did; so, let's enable the traffic analyzer and execute the request using SOAP UI again. Wireshark will show the information shown in the following screenshot:</p><div class="mediaobject"><img alt="Authentication through certificates" src="graphics/0109OS_02_10.jpg"/></div><p>As you can <a class="indexterm" id="id87"/>see, all information is encrypted and it can't be interpreted. So, if the packages are transmitted and they are intercepted in the network, the information is not vulnerable to attacks.</p><p>You can find the source code of this section on GitHub at the following URL:</p><p>
<a class="ulink" href="https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples">https://github.com/restful-java-web-services-security/source-code/tree/master/chapter02/client-cert-authentication/resteasy-examples</a>
</p></div></div>
<div class="section" title="API keys"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>API keys</h1></div></div></div><p>With the advent of cloud computing, it is not difficult to think of applications that integrate with many others available in the cloud. Right now, it's easy to see how applications interact with Flickr, Facebook, Twitter, Tumblr, and so on.</p><p>To enable these integrations, a new authentication mechanism has been developed using API keys. This authentication<a class="indexterm" id="id88"/> method is used primarily when we need to authenticate from another application but we do not want to access the private user data hosted in another application. On the contrary, if you want to access this information, you must use OAuth. If you are interested in this, don't worry, we will study this wonderful technology later in this book.</p><p>We want to understand how the API keys work, so let's take the case of Flickr. The important thing here is to understand how the API keys work because the same concept can be applied to<a class="indexterm" id="id89"/> companies like Google, Facebook, and so on. For those unfamiliar with Flickr, it is an application in the cloud in which we can store our photos, images, screenshots, or similar files.</p><p>To start working with this authentication model, we first obtain an API key; in our example with Flickr, you can do this using the following link:</p><p>
<a class="ulink" href="https://www.flickr.com/services/developer/api/">https://www.flickr.com/services/developer/api/</a>
</p><p>When we ask for our API key, we are asked to enter the name of the application that we will create and with which we use the API key. Once we enter the information requested and submit it, Flickr will deliver us a couple of values; they are a secret and a key. Both are displayed in the following screenshot:</p><div class="mediaobject"><img alt="API keys" src="graphics/0109OS_02_11.jpg"/></div><p>Each application we create is part of Flickr App Garden. App Garden is nothing but the set of all applications created by all Flickr members.</p><p>Keep in mind that when creating an API key, we consciously accept certain terms of use of the provider. These terms clearly detail what we can and can't do; for example, Flickr says:</p><p><span class="emphasis"><em>a. You shall:</em></span></p><p><span class="emphasis"><em>Comply with the Flickr Community Guidelines at <a class="ulink" href="http://www.flickr.com/guidelines.gne">www.flickr.com/guidelines.gne</a>, the Flickr Terms of Use at <a class="ulink" href="http://www.flickr.com/terms.gne">http://www.flickr.com/terms.gne</a>, and the Yahoo! Terms of Service at <a class="ulink" href="http://docs.yahoo.com/info/terms/">http://docs.yahoo.com/info/terms/</a>.</em></span></p><p><span class="emphasis"><em>…</em></span></p><p><span class="emphasis"><em>b. You shall not:</em></span></p><p><span class="emphasis"><em>Use Flickr APIs for any application that replicates or attempts to replace the essential user experience of Flickr.com</em></span></p><p><span class="emphasis"><em>…</em></span></p><p>Thus, by requiring that users accept the terms of use, API key providers prevent the abusive use of its APIs. So, if someone starts disrespecting agreements, the provider withdraws the API key. Flickr has a large set of<a class="indexterm" id="id90"/> methods that we can use in our applications; we will try one of them to show how they work:</p><p>The <code class="literal">flickr.photos.getRecent</code> method lists all <a class="indexterm" id="id91"/>recent photos that have been posted in Flickr, and we can invoke it as follows:</p><p>
<code class="literal">https://www.flickr.com/services/rest?method=flickr.photos.getRecent&amp;;&amp;api+key=[your_api_key_from_flicker]</code>
</p><p>Let's use the key we just generated earlier, and let's perform the request using the browser as follows:</p><div class="mediaobject"><img alt="API keys" src="graphics/0109OS_02_12.jpg"/></div><p>First notice how information travels through a secure channel (HTTPS). Then, when receiving the request, Flickr authenticates the user by reading the information from the API key with the secret key that belongs to the user. Once these validations are successful, the server delivers the response to the client. Thus, we obtain a response with all the photos that have been recently posted within Flickr. As you'll notice, this way, you can easily create applications using the provider's API. Also, the provider will allow you to authenticate, access public information, and be responsible to keep track of volume or the number of API calls you've made using the API key, in order to validate that the use complies with the agreements.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we went through all possible models of authentication. We will use all of them in the next chapter, and we will apply them to the web service functionality we just created.</p><p>Even if you had trouble with any of the examples, you can continue to the next chapter. As for your better understanding, we will go step-by-step and more in-depth into how we can leverage each available authentication model.</p><p>As you realize, it is important to choose the correct security management, otherwise information is exposed and can easily be intercepted and used by third parties.</p><p>Finally, in this chapter, we reviewed the differences between authentication and authorization. Both concepts are very important and definitely impossible to put aside in the context of security terms.</p><p>Now, we will ask you to join us to go ahead and secure our web service.</p></div></body></html>