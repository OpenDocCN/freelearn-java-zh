<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer039">
<h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor150"/>5</h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor151"/>Authentication with Spring Data</h1>
<p>In the previous chapter, we covered how to leverage Spring Security’s built-in <strong class="bold">Java DataBase Connectivity</strong> (<strong class="bold">JDBC</strong>) support. In this chapter, we will look at the Spring Data project and how to leverage <strong class="bold">Jakarta Persistence API</strong> (<strong class="bold">JPA</strong>) to perform authentication against a relational database. We will also explore how to perform authentication against a document database using <strong class="bold">MongoDB</strong>. This chapter’s sample code is based on the Spring Security setup from <a href="B21757_04.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">JDBC-based Authentication</em>, and it has been updated to refactor the need for SQL and to use ORM for all <span class="No-Break">database interactions.</span></p>
<p>During the course of this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Some of the basic concepts related to the Spring <span class="No-Break">Data project</span></li>
<li>Utilizing Spring Data JPA to authenticate against a <span class="No-Break">relational database</span></li>
<li>Utilizing Spring Data MongoDB to authenticate against a <span class="No-Break">document database</span></li>
<li>How to customize Spring Security for more flexibility when dealing with Spring <span class="No-Break">Data integration</span></li>
<li>Understanding the Spring <span class="No-Break">Data project</span></li>
</ul>
<p>The Spring Data project’s mission is to provide a familiar and consistent Spring-based programming model for data access, while still retaining the special traits of the underlying <span class="No-Break">data provider.</span></p>
<p>The following are just a few of the powerful features of this Spring <span class="No-Break">Data project:</span></p>
<ul>
<li>Powerful repository and custom <span class="No-Break">object-mapping abstractions</span></li>
<li>Dynamic query derivation from repository <span class="No-Break">method names</span></li>
<li>Implementation of domain base classes, providing <span class="No-Break">basic properties</span></li>
<li>Support for transparent auditing (created and <span class="No-Break">last changed)</span></li>
<li>The ability to integrate custom <span class="No-Break">repository code</span></li>
<li><a id="_idTextAnchor152"/>Easy Spring integration via Java-based configuration and custom <span class="No-Break">XML namespaces</span></li>
<li>Advanced integration with Spring <span class="No-Break">MVC controllers</span></li>
<li>Experimental support for <span class="No-Break">cross-store persistence</span></li>
</ul>
<p>This project simplifies the use of data access technologies, relational and non-relational databases, <strong class="source-inline">MapReduce</strong> frameworks, and cloud-based data services. This umbrella project contains many subprojects that are specific to a given database. These projects were developed by working together with many of the companies and developers that are behind these exciting technologies. There are also many community-maintained modules and other related modules, including <em class="italic">JDBC support</em> and <span class="No-Break"><em class="italic">Apache Hadoop</em></span><span class="No-Break">.</span></p>
<p>The following table describes the main modules that make up the Spring <span class="No-Break">Data project:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Module</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data Commons</span></p>
</td>
<td class="No-Table-Style">
<p>Applies core Spring concepts to all Spring <span class="No-Break">Data projects</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data Gemfire</span></p>
</td>
<td class="No-Table-Style">
<p>Provides easy configuration and access to Gemfire from <span class="No-Break">Spring applications</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data JPA</span></p>
</td>
<td class="No-Table-Style">
<p>Makes it easy to implement <span class="No-Break">JPA-based repositories</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring Data <span class="No-Break">Key Value</span></p>
</td>
<td class="No-Table-Style">
<p>Map-based repositories and SPIs, which can easily build a Spring Data module for <span class="No-Break">key-value stores</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data LDAP</span></p>
</td>
<td class="No-Table-Style">
<p>Provides Spring Data repository support for <span class="No-Break">Spring LDAP</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data MongoDB</span></p>
</td>
<td class="No-Table-Style">
<p>Spring-based, object-document support and repositories <span class="No-Break">for MongoDB</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data REST</span></p>
</td>
<td class="No-Table-Style">
<p>Exports Spring Data repositories as hypermedia-driven <span class="No-Break">RESTful resources</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring <span class="No-Break">Data Redis</span></p>
</td>
<td class="No-Table-Style">
<p>Provides easy configuration and access to Redis from <span class="No-Break">Spring applications</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring Data for <span class="No-Break">Apache Cassandra</span></p>
</td>
<td class="No-Table-Style">
<p>A Spring Data module for <span class="No-Break">Apache Cassandra</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Spring Data for <span class="No-Break">Apache Solr</span></p>
</td>
<td class="No-Table-Style">
<p>A Spring Data module for <span class="No-Break">Apache Solr</span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Main modules of the Spring Data project</p>
<p>After exploring the core modules of the Spring Data project, let’s now delve into the primary features of Spring <span class="No-Break">Data JPA.</span></p>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/omOQK"><span class="No-Break">https://packt.link/omOQK</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor153"/>Spring Data JPA</h1>
<p>The Spring Data JPA project aims to significantly improve the ORM implementation of data access layers by reducing the effort to the amount that’s actually needed. A developer only needs to write<a id="_idIndexMarker279"/> repository interfaces, including custom finder methods, and Spring will provide the <span class="No-Break">implementation automatically.</span></p>
<p>The following are just a few of the powerful features specific to the Spring Data <span class="No-Break">JPA Project:</span></p>
<ul>
<li>Sophisticated support for building repositories based on Spring <span class="No-Break">and JPA</span></li>
<li>Support for <strong class="source-inline">QueryDSL</strong> predicates and, thus, type-safe <span class="No-Break">JPA queries</span></li>
<li>Transparent auditing of <span class="No-Break">domain classes</span></li>
<li>Pagination support, dynamic query execution, and the ability to integrate custom data <span class="No-Break">access code</span></li>
<li>Validation of <strong class="source-inline">@Query</strong>-annotated queries at <span class="No-Break">bootstrap time</span></li>
<li>Support for XML based <span class="No-Break">entity mapping</span></li>
<li>The <strong class="source-inline">JavaConfig</strong> based repository configuration by <span class="No-Break">introducing </span><span class="No-Break"><strong class="source-inline">@EnableJpaRepositories</strong></span></li>
</ul>
<h2 id="_idParaDest-115"><a id="_idTextAnchor154"/>Updating our dependencies</h2>
<p>We have already included all the dependencies you need for this chapter, so you will not need to make any updates to your <strong class="source-inline">build.gradle</strong> file. However, if you are just adding Spring Data JPA support to your <a id="_idIndexMarker280"/>application, you need to add <strong class="source-inline">spring-boot- starter-data-jpa</strong> as a dependency in the <strong class="source-inline">build.gradle</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
    // JPA / ORM / Hibernate:
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
...
}</pre> <p>Notice haven’t removed the <span class="No-Break"><strong class="source-inline">spring-boot-starter-jdbc</strong></span><span class="No-Break"> dependency.</span></p>
<p>The <strong class="source-inline">spring-boot-starter-data-jpa</strong> dependency will contain all the dependencies needed to wire our domain objects to our embedded database <span class="No-Break">with JPA<a id="_idTextAnchor155"/>.</span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor156"/>Reconfiguring the database configuration</h2>
<p>Firstly, we will convert the <a id="_idIndexMarker281"/>current JBCP calendar project. Let’s begin by reconfiguring <span class="No-Break">the database.</span></p>
<p>We can begin by removing the <strong class="source-inline">DataSourceConfig.java</strong> file, as we will be leveraging Spring Boot’s built-in support for an embedded <span class="No-Break">H2 database<a id="_idTextAnchor157"/><a id="_idTextAnchor158"/>.</span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor159"/>Initializing the database</h2>
<p>We can now remove the <strong class="source-inline">src/main/resources/database</strong> directory and all contents in that directory. This <a id="_idIndexMarker282"/>directory contains several <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">sql</strong></span><span class="No-Break"> files.</span></p>
<p>Now, we need to create a <strong class="source-inline">data.sql</strong> file that will contain our seed data, <span class="No-Break">as follows:</span></p>
<ul>
<li>Take a look at the following SQL statement, depicting the password <span class="No-Break">for </span><span class="No-Break"><strong class="bold">user1</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/resources/data.sql
insert into calendar_users(id,email,password,first_name,last_name) values (0, 'user1@example.com','$2a$04$qr7RWyqOnWWC1nwotUW1nOe1RD5.mKJVHK16WZy6v49pymu1WDHmi','User','1');</pre></li> <li>Take a look at the following SQL statement, depicting the password <span class="No-Break">for </span><span class="No-Break"><strong class="bold">admin1</strong></span><span class="No-Break">:</span><pre class="source-code">
insert into calendar_users(id,email,password,first_name,last_name) values (1,'admin1@example.com','$2a$04$0CF/Gsquxlel3fWq5Ic/ZOGDCaXbMfXYiXsviTNMQofWRXhvJH3IK','Admin','1');</pre></li> <li>Take a look at the<a id="_idIndexMarker283"/> following SQL statement, depicting the password <span class="No-Break">for </span><span class="No-Break"><strong class="bold">user2</strong></span><span class="No-Break">:</span><pre class="source-code">
insert into calendar_users(id,email,password,first_name,last_name) values (2,'user2@example.com','$2a$04$PiVhNPAxunf0Q4IMbVeNIuH4M4ecySWHihyrclxW..PLArjLbg8CC','User2','2');</pre></li> <li>Take a look at the following SQL statement, depicting the <span class="No-Break">user roles:</span><pre class="source-code">
insert into role(id, name) values (0, 'ROLE_USER');
insert into role(id, name) values (1, 'ROLE_ADMIN');</pre></li> <li>Here, <strong class="bold">user1</strong> has <span class="No-Break">one role:</span><pre class="source-code">
insert into user_role(user_id,role_id) values (0, 0);</pre></li> <li>Here, <strong class="bold">admin1</strong> has <span class="No-Break">two roles:</span><pre class="source-code">
insert into user_role(user_id,role_id) values (1, 0);
insert into user_role(user_id,role_id) values (1, 1);</pre></li> <li>Take a look at the following SQL statement, <span class="No-Break">depicting events:</span><pre class="source-code">
insert into events (id,date_when,summary,description,owner,attendee) values (100,'2023-07-03 20:30:00','Birthday Party','This is going to be a great birthday',0,1);
insert into events (id,date_when,summary,description,owner,attendee) values (101,'2023-12-23 13:00:00','Conference Call','Call with the client',2,0);
insert into events (id,date_when,summary,description,owner,attendee) values (102,'2023-09-14 11:30:00','Vacation','Paragliding in Greece',1,2);</pre></li> </ul>
<p>Now, we can update the<a id="_idIndexMarker284"/> application properties to define our embedded database properties in the <strong class="source-inline">src/main/resources/application.yml</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
datasource:
  url: jdbc:h2:mem:dataSource;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
  driverClassName: org.h2.Driver
  username: sa
  password:
jpa:
  database-platform: org.hibernate.dialect.H2Dialect
  show-sql: true
  hibernate:
    ddl-auto: create-drop</pre> <p>At this point, we have removed the old database configuration and added the new configuration. The application will not work at this point, but this can still be considered a marker point before we continue to the next steps <span class="No-Break">of conversion.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar05.01-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor160"/>Refactoring from SQL to ORM</h1>
<p>Refactoring from an SQL to an ORM implementation is simpler than you might think. Most of the refactoring involves the removal <a id="_idIndexMarker285"/>of excess code in the form of an SQL. In this next section, we will refactor our SQL implementation to a <span class="No-Break">JPA implementation.</span></p>
<p>For JPA to map our domain objects to our database, we need to perfor<a id="_idTextAnchor161"/>m some mapping on our <span class="No-Break">domain ob<a id="_idTextAnchor162"/>jects.</span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor163"/>Mapping domain objects using JPA</h2>
<p>Take a look at the following <a id="_idIndexMarker286"/>steps to learn about mapping the <span class="No-Break">domain objects:</span></p>
<ol>
<li>Let’s begin by mapping our <strong class="source-inline">Event.java</strong> file so that all the domain objects will use JPA, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Event.java
@Entity
@Table(name = "events")
public class Event implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    @NotEmpty(message = "Summary is required")
    private String summary;
    @NotEmpty(message = "Description is required")
    private String description;
    @NotNull(message = "When is required")
    private Calendar dateWhen;
    @NotNull(message = "Owner is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="owner", referencedColumnName="id")
    private CalendarUser owner;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="attendee", referencedColumnName="id")
    private CalendarUser attendee;
...
}</pre></li> <li>We need to <a id="_idIndexMarker287"/>create a <strong class="source-inline">Role.java</strong> file with the <span class="No-Break">following contents:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Role.java
@Entity
@Table(name = "role")
public class Role implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    private String name;
    @ManyToMany(fetch = FetchType.EAGER, mappedBy = "roles")
    private Set&lt;CalendarUser&gt; users;
...
}</pre></li> <li>The <strong class="source-inline">Role</strong> object will be<a id="_idIndexMarker288"/> used to map authorities to our <strong class="source-inline">CalendarUser</strong> table. Let’s map our <strong class="source-inline">CalendarUser.java</strong> file, now that we have a <span class="No-Break"><strong class="source-inline">Role.java</strong></span><span class="No-Break"> file:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/CalendarUser.java
@Entity
@Table(name = "calendar_users")
public class CalendarUser implements Principal, Serializable {
    private static final long serialVersionUID = 8433999509932007961L;
    @Id
    @SequenceGenerator(name = "user_id_seq", initialValue = 1000)
    @GeneratedValue(generator = "user_id_seq")
    private Integer id;
    private String firstName;
    private String lastName;
    private String email;
    private String password;
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_role",
          joinColumns = @JoinColumn(name = "user_id"),
          inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set&lt;Role&gt; roles;
...
}</pre></li> </ol>
<p>At this point, we have mapped our domain <a id="_idIndexMarker289"/>objects with the required JPA annotation, including <strong class="source-inline">@Entity</strong> and <strong class="source-inline">@Table</strong> to define the <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>) location, as well as<a id="_idIndexMarker290"/> structural, reference, and association <span class="No-Break">mapping annotations.</span></p>
<p>At this stage, you can also <strong class="bold">remove</strong> the <span class="No-Break">following dependency:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
...
}</pre> <p>The application will not<a id="_idIndexMarker291"/> work at this point, but this can still be considered a marker point before we continue to the next steps <span class="No-Break">of conversion.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">calendar05.02-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor164"/>Spring Data repositories</h2>
<p>We will now add the required interfaces for <a id="_idIndexMarker292"/>Spring Data to map our required <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations<a id="_idIndexMarker293"/> to our embedded database, by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>We begin by adding a new interface to a new package, which will be <strong class="source-inline">com.packtpub.springsecurity.repository</strong>. The new file will be called <strong class="source-inline">CalendarUserRepository.java</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
//com/packtpub/springsecurity/repository/CalendarUserRepository.java
public interface CalendarUserRepository extends JpaRepository&lt;CalendarUser, Integer&gt; {
    CalendarUser findByEmail(String email);
}</pre></li> <li>We can now continue by adding a new interface to the same repository package, which will be <strong class="source-inline">com.packtpub.springsecurity.repository</strong>, and the new file will be <a id="_idIndexMarker294"/><span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">EventRepository.java</strong></span><span class="No-Break">:</span><pre class="source-code">
//com/packtpub/springsecurity/repository/EventRepository.java
public interface EventRepository extends JpaRepository&lt;Event, Integer&gt; {
}</pre><p class="list-inset">This will allow for standard CRUD operations such as <strong class="source-inline">find()</strong>, <strong class="source-inline">save()</strong>, and<strong class="source-inline"> delete()</strong> on our <span class="No-Break"><strong class="source-inline">Event</strong></span><span class="No-Break"> objects.</span></p></li> <li>Finally, we will add a new interface to the same repository package, which will be <strong class="source-inline">com.packtpub.springsecurity.repository</strong>, and the new file will be called <strong class="source-inline">RoleRepository.java</strong>. This <strong class="source-inline">CrudRepository</strong> interface will be used to manage the <strong class="source-inline">Role</strong> object for our security roles associated with a <span class="No-Break">given </span><span class="No-Break"><strong class="source-inline">CalendarUser</strong></span><span class="No-Break">:</span></li>
</ol>
<pre class="source-code">
//com/packtpub/springsecurity/repository/RoleRepository.java
public interface RoleRepository extends JpaRepository&lt;Role, Integer&gt; {
}</pre> <p>This will allow for standard CRUD operations such as <strong class="source-inline">find()</strong>, <strong class="source-inline">save()</strong>, and<strong class="source-inline"> delete()</strong> on our <span class="No-Break"><strong class="source-inline">Role</strong></span><span class="No-Break"> objects.</span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor165"/>Data access objects</h2>
<p>We need to refactor the <strong class="source-inline">JdbcEventDao.java</strong> file with a new name, <strong class="source-inline">JpaEventDao.java</strong>, so that <a id="_idIndexMarker295"/>we can replace the JDBC SQL code with our new Spring Data code. Let’s take a look at the <span class="No-Break">following steps:</span></p>
<ol>
<li>Specifically, we need to add the new <strong class="source-inline">EventRepository</strong> interface and replace the SQL code with the new ORM repository, as shown in the <span class="No-Break">following code:</span><pre class="source-code">
//com/packtpub/springsecurity/dataaccess/JpaEventDao.java
@Repository
public class JpaEventDao implements EventDao {
    // --- members ---
    private EventRepository repository;
    // --- constructors ---
    public JpaEventDao(EventRepository repository) {
        if (repository == null) {
            throw new IllegalArgumentException("repository cannot be null");
        }
        this.repository = repository;
    }
    // --- EventService ---
    @Override
    @Transactional(readOnly = true)
    public Event getEvent(int eventId) {
        return repository.findById(eventId).orElse(null);
    }
    @Override
    public int createEvent(final Event event) {
        if (event == null) {
            throw new IllegalArgumentException("event cannot be null");
        }
        if (event.getId() != null) {
            throw new IllegalArgumentException("event.getId() must be null when creating a new Message");
        }
        final CalendarUser owner = event.getOwner();
        if (owner == null) {
            throw new IllegalArgumentException("event.getOwner() cannot be null");
        }
        final CalendarUser attendee = event.getAttendee();
        if (attendee == null) {
            throw new IllegalArgumentException("attendee.getOwner() cannot be null");
        }
        final Calendar when = event.getDateWhen();
        if(when == null) {
            throw new IllegalArgumentException("event.getWhen() cannot be null");
        }
        Event newEvent = repository.save(event);
        return newEvent.getId();
    }
    @Override
    @Transactional(readOnly = true)
    public List&lt;Event&gt; findForUser(final int userId) {
        Event example = new Event();
        CalendarUser cu = new CalendarUser();
        cu.setId(userId);
        example.setOwner(cu);
        return repository.findAll(Example.of(example));
    }
    @Override
    @Transactional(readOnly = true)
    public List&lt;Event&gt; getEvents() {
        return repository.findAll();
    }
}</pre></li> <li>At this point, we need to refactor the DAO classes to support the new <strong class="source-inline">CrudRepository</strong> interfaces<a id="_idIndexMarker296"/> we have created. Let’s begin by refactoring the <strong class="source-inline">JdbcCalendarUserDao.java</strong> file. First, we can rename the file <strong class="source-inline">JpaCalendarUserDao.java</strong> to indicate that this uses JPA, not <span class="No-Break">standard JDBC:</span><pre class="source-code">
//com/packtpub/springsecurity/dataaccess/JpaCalendarUserDao.java
@Repository
public class JpaCalendarUserDao implements CalendarUserDao {
    private static final Logger logger = LoggerFactory
            .getLogger(JpaCalendarUserDao.class);
    // --- members ---
    private CalendarUserRepository userRepository;
    private RoleRepository roleRepository;
    // --- constructors ---
    public JpaCalendarUserDao(final CalendarUserRepository repository,
                              final RoleRepository roleRepository) {
        if (repository == null) {
            throw new IllegalArgumentException("repository cannot be null");
        }
        if (roleRepository == null) {
            throw new IllegalArgumentException("roleRepository cannot be null");
        }
        this.userRepository = repository;
        this.roleRepository = roleRepository;
    }
    // --- CalendarUserDao methods ---
    @Override
    @Transactional(readOnly = true)
    public CalendarUser getUser(final int id) {
        return userRepository.findById(id).orElse(null);
    }
    @Override
    @Transactional(readOnly = true)
    public CalendarUser findUserByEmail(final String email) {
        if (email == null) {
            throw new IllegalArgumentException("email cannot be null");
        }
        try {
            return userRepository.findByEmail(email);
        } catch (EmptyResultDataAccessException notFound) {
            return null;
        }
    }
    @Override
    @Transactional(readOnly = true)
    public List&lt;CalendarUser&gt; findUsersByEmail(final String email) {
        if (email == null) {
            throw new IllegalArgumentException("email cannot be null");
        }
        if ("".equals(email)) {
            throw new IllegalArgumentException("email cannot be empty string");
        }
        return userRepository.findAll();
    }
    @Override
    public int createUser(final CalendarUser userToAdd) {
        if (userToAdd == null) {
            throw new IllegalArgumentException("userToAdd cannot be null");
        }
        if (userToAdd.getId() != null) {
            throw new IllegalArgumentException("userToAdd.getId() must be null when creating a "+CalendarUser.class.getName());
        }
        Set&lt;Role&gt; roles = new HashSet&lt;&gt;();
        roles.add(roleRepository.findById(0).orElse(null));
        userToAdd.setRoles(roles);
        CalendarUser result = userRepository.save(userToAdd);
        userRepository.flush();
        return result.getId();
    }
}</pre><p class="list-inset">In the preceding code, the update fragments to leverage the JPA repositories have been placed in bold, so now the <strong class="source-inline">Event</strong> and <strong class="source-inline">CalendarUser</strong> objects are mapped to our <span class="No-Break">underlying RDBMS.</span></p></li> </ol>
<p>The application will not<a id="_idIndexMarker297"/> work at this point, but this can still be considered a marker point before we continue to the next steps <span class="No-Break">of conversion.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">At this point, your source code should look the same as <span class="No-Break"><strong class="source-inline">chapter05.03- calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor166"/>Application services</h1>
<p>The only thing left to do is configure Spring <a id="_idIndexMarker298"/>Security to use the <span class="No-Break">new artifacts.</span></p>
<p>We need to edit the <strong class="source-inline">DefaultCalendarService.java</strong> file and only remove the remaining code that was used to add <strong class="source-inline">USER_ROLE</strong> to any new <strong class="source-inline">User</strong> object that was created, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//com/packtpub/springsecurity/service/DefaultCalendarService.java
@Repository
public class DefaultCalendarService implements CalendarService {
... omitted for brevity ...
  public int createUser(CalendarUser user) {
    String encodedPassword = passwordEncoder.encode(user.getPassword());
    user.setPassword(encodedPassword);
    int userId = userDao.createUser(user);
    return userId;
  }
}</pre> <h1 id="_idParaDest-123"><a id="_idTextAnchor167"/>The UserDetailsService object</h1>
<p>Let’s take a look at the following <a id="_idIndexMarker299"/>steps to add the <span class="No-Break"><strong class="source-inline">UserDetailsService</strong></span><span class="No-Break"> object:</span></p>
<ol>
<li>Now, we need to add a new implementation of the <strong class="source-inline">UserDetailsService</strong> object; we will use our <strong class="source-inline">CalendarUserRepository</strong> interface to authenticate and authorize users again, with the same underlying RDBMS, but using our new JPA implementation, <span class="No-Break">as follows:</span><pre class="source-code">
//com/packtpub/springsecurity/service/ CalendarUserDetailsService.java
@Component
public class CalendarUserDetailsService implements UserDetailsService {
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    CalendarUser user = calendarUserDao.findUserByEmail(username);
    if (user == null) {
        throw new UsernameNotFoundException("Invalid username/password.");
    }
    return new CalendarUserDetails(user);
 }
}</pre></li> <li>Now, we have to configure<a id="_idIndexMarker300"/> Spring Security to use our custom <strong class="source-inline">UserDetailsService</strong> object, <span class="No-Break">as follows:</span><pre class="source-code">
//com/packtpub/springsecurity/configuration/SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
... omitted for brevity ...
    @Bean
    public AuthenticationManager authManager(HttpSecurity http) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder =
            http.getSharedObject(AuthenticationManagerBuilder.class);
        return authenticationManagerBuilder.build();
    }
  }
...
}</pre></li> <li>Start the application and try logging in to the application. Any of the configured users can now log in and create new events. You can also create a new user and will be able to log in <a id="_idIndexMarker301"/>as this new <span class="No-Break">user immediately.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">calendar05.04-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor168"/>Refactoring from an RDBMS to a document database</h2>
<p>Luckily, with the Spring <a id="_idIndexMarker302"/>Data project, once we have a Spring Data implementation, we have most of the difficult work completed. Now, there are only a few <a id="_idTextAnchor169"/>implementation-specific changes that need to <span class="No-Break">be refactored.</span></p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor170"/>Document database implementation with MongoDB</h1>
<p>We are now going to work on refactoring <a id="_idIndexMarker303"/>our RDBMS implementation—with JPA as our ORM provider—to a document database implementation, using MongoDB as our underlying database provider. MongoDB is a free and open-source <a id="_idIndexMarker304"/>cross-platform document-oriented database program. Classified as a NoSQL database program, MongoDB uses JSON-like documents with schemas. MongoDB is developed by MongoDB Inc. and is located <span class="No-Break">at </span><a href="https://github.com/mongodb/mongo"><span class="No-Break">https://github.com/mongodb/mongo</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor171"/>Updating our dependencies</h2>
<p>We have already included all of the dependencies you need for this chapter, so you will not need to make any <a id="_idIndexMarker305"/>updates to your <strong class="source-inline">build.gradle</strong> file. However, if you are just adding Spring Data JPA support to your own application, you will need to add <strong class="source-inline">spring-boot-starter-data-jpa</strong> as a dependency to the <strong class="source-inline">build.gradle</strong> file, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
// MondgoDB
implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'
implementation 'de.flapdoodle.embed:de.flapdoodle.embed.mongo.spring30x:4.9.2'
}</pre> <p>Notice that we removed the <strong class="source-inline">spring-boot-starter-jpa</strong> dependency. The <strong class="source-inline">spring-boot- starter-data-mongodb</strong> dependency will contain all the dependencies needed to wire<a id="_idIndexMarker306"/> our domain objects to our embedded MongoDB database, with a mix of Spring and <span class="No-Break">MongoDB annotations.</span></p>
<p>We also added the <strong class="source-inline">Flapdoodle</strong>-embedded MongoDB database, but this is only meant for testing and demonstration purposes. Embedded MongoDB will provide a platform-neutral way to run MongoDB in unit tests. This embedded database is located <span class="No-Break">at </span><a href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo"><span class="No-Break">https://github.com/flapdoodle-o<span id="_idTextAnchor172"/>ss/de.flapdoodle.embed.mongo</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor173"/>Reconfiguring the database configuration in MongoDB</h2>
<p>First, we will begin to convert the<a id="_idIndexMarker307"/> current JBCP calendar project. Let’s begin by reconfiguring the database to use the Flapdoodle-embedded MongoDB database. Previously, when we updated the dependencies for this <a id="_idIndexMarker308"/>project, we added a Flapdoodle dependency that gave the project an embedded MongoDB database, which we could automatically use instead of installing a full version of MongoDB installation. To stay consistent with the JBCP application, we need to change the name of our database. With Spring Data, we can change the MongoDB configuration using the YAML configuration, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/resources/application.yml
spring:
  ## Thymeleaf configuration:
  thymeleaf:
    cache: false
    mode: HTML
  # MongoDB
  data:
    mongodb:
      host: localhost
      database: dataSource
de:
  flapdoodle:
    mongodb:
      embedded:
        version: 7.0.0</pre> <p>The most important configuration for <a id="_idIndexMarker309"/>our current requirements is changing the database name to <strong class="source-inline">dataSource</strong>, which is the same name we <a id="_idIndexMarker310"/>used throughout <span class="No-Break">this book.</span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor174"/>Initializing the MongoDB database</h2>
<p>With the JPA implementation, we <a id="_idIndexMarker311"/>used the <strong class="source-inline">data.sql</strong> file to initialize the data in our database. For MongoDB implementation, we can remove the <strong class="source-inline">data.sql</strong> file and replace it with a Java configuration file, which we will <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">MongoDataInitializer.java</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ MongoDataInitializer.java
@Configuration
public class MongoDataInitializer {
    private static final Logger logger = LoggerFactory
            .getLogger(MongoDataInitializer.class);
    private RoleRepository roleRepository;
    private CalendarUserRepository calendarUserRepository;
    private EventRepository eventRepository;
    public MongoDataInitializer(RoleRepository roleRepository, CalendarUserRepository calendarUserRepository, EventRepository eventRepository) {
       this.roleRepository = roleRepository;
       this.calendarUserRepository = calendarUserRepository;
       this.eventRepository = eventRepository;
    }
    @PostConstruct
    public void setUp() {
    }
    CalendarUser user, admin, user2;
    // CalendarUsers
    {
        user = new CalendarUser(0, "user1@example.com","$2a$04$qr7RWyqOnWWC1nwotUW1nOe1RD5.mKJVHK16WZy6v49pymu1WDHmi","User","1");
        admin = new CalendarUser(1,"admin1@example.com","$2a$04$0CF/Gsquxlel3fWq5Ic/ZOGDCaXbMfXYiXsviTNMQofWRXhvJH3IK","Admin","1");
        user2 = new CalendarUser(2,"user2@example.com","$2a$04$PiVhNPAxunf0Q4IMbVeNIuH4M4ecySWHihyrclxW..PLArjLbg8CC","User2","2");
    }
    Role user_role, admin_role;
    private void seedRoles(){
        user_role = new Role(0, "ROLE_USER");
        user_role = roleRepository.save(user_role);
        admin_role = new Role(1, "ROLE_ADMIN");
        admin_role = roleRepository.save(admin_role);
    }
    private void seedEvents(){
        // Event 1
        Event event1 = new Event(
                100,
                "Birthday Party",
                "This is going to be a great birthday",
             LocalDateTime.of(2023, 6,3,6,36,00),
                user,
                admin
                );
        // Event 2
        Event event2 = new Event(
                101,
                "Conference Call",
                "Call with the client",
             LocalDateTime.of(2023, 11,23,13,00,00),
                user2,
                user
                );
        // Event 3
        Event event3 = new Event(
                102,
                "Vacation",
                "Paragliding in Greece",
             LocalDateTime.of(2023, 8,14,11,30,00),
                admin,
                user2
                );
        // save Event
        eventRepository.save(event1);
        eventRepository.save(event2);
        eventRepository.save(event3);
        List&lt;Event&gt; events = eventRepository.findAll();
        logger.info("Events: {}", events);
    }
    private void seedCalendarUsers(){
        // user1
        user.addRole(user_role);
        // admin2
        admin.addRole(user_role);
        admin.addRole(admin_role);
        // user2
        user2.addRole(user_role);
        // CalendarUser
        calendarUserRepository.save(user);
        calendarUserRepository.save(admin);
        calendarUserRepository.save(user2);
        List&lt;CalendarUser&gt; users = calendarUserRepository.findAll();
        logger.info("CalendarUsers: {}", users);
    }
}</pre> <p>This will be executed at load<a id="_idIndexMarker312"/> time and will seed the same data into our MongoDB as we did with our <span class="No-Break">H2 database.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor175"/>Mapping domain objects with MongoDB</h2>
<p>Let’s begin by mapping our <strong class="source-inline">Event.java</strong> file so that <a id="_idIndexMarker313"/>each of the domain objects is saved as a document in our <a id="_idIndexMarker314"/>MongoDB database. This can be done by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>With a document database, domain object mapping is a little different, but the same ORM concepts hold true. Let’s begin with the <strong class="source-inline">Event</strong> JPA implementation, and then we can transform our <strong class="source-inline">Entity</strong> to <span class="No-Break">document mapping:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Event.java
@Entity
@Table(name = "events")
public class Event implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Integer id;
    @NotEmpty(message = "Summary is required")
    private String summary;
    @NotEmpty(message = "Description is required")
    private String description;
    @NotNull(message = "When is required")
    private Calendar dateWhen;
    @NotNull(message = "Owner is required")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="owner", referencedColumnName="id")
    private CalendarUser owner;
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="attendee", referencedColumnName="id")
    private CalendarUser attendee;
...
}</pre></li> <li>In entity-based JPA mapping, we needed to use six different annotations to create the required mapping. Now, with document-based MongoDB mapping, we need to change all the <a id="_idIndexMarker315"/>previous mapping annotations. Here is a fully refactored example <a id="_idIndexMarker316"/>of our <span class="No-Break"><strong class="source-inline">Event.java</strong></span><span class="No-Break"> file:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Event.java
@Document(collection="events")
public class Event implements Persistable&lt;Integer&gt;, Serializable{
    @Id
    private Integer id;
    @NotEmpty(message = "Summary is required")
    private String summary;
    @NotEmpty(message = "Description is required")
    private String description;
    @NotNull(message = "When is required")
    private LocalDateTime dateWhen;
    @NotNull(message = "Owner is required")
    @DBRef
    private CalendarUser owner;
    @DBRef
    private CalendarUser attendee;
...
}</pre><p class="list-inset">In the preceding code, we can see the following <span class="No-Break">notable changes.</span></p></li> <li>First, we declare the class to be of type <strong class="source-inline">@o.s.d.mongodb.core.mapping.Document</strong> and provide a collection name for <span class="No-Break">these documents.</span></li>
<li>Next, the <strong class="source-inline">Event</strong> class must implement the <strong class="source-inline">o.s.d.domain.Persistable</strong> interface, providing the primary key type (<strong class="source-inline">Integer</strong>) for <span class="No-Break">our document.</span></li>
<li>Now, we change the annotation for our domain ID to <strong class="source-inline">@o.s.d.annotation.Id</strong>, to define the domain <span class="No-Break">primary key.</span></li>
<li>Previously, we had to map our <a id="_idIndexMarker317"/>owner and attendee <strong class="source-inline">CalendarUser</strong> object to two different <span class="No-Break">mapping annotations.</span><p class="list-inset">Now, we only have to define the two types to be of type <strong class="source-inline">@o.s.d.mongodb.core.mapping.DBRef</strong> and allow Spring Data to take care of the <span class="No-Break">underlying references.</span></p></li>
<li>The final annotation we have to add defines a specific constructor to be used for new documents to be added to our document, by using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">o.s.d.annotation.PersistenceConstructor</strong></span><span class="No-Break"> annotation.</span></li>
<li>Now that we have <a id="_idIndexMarker318"/>reviewed the changes needed to refactor from JPA to MongoDB, let’s refactor the other domain object, starting with <span class="P---Regular-Char">the</span><strong class="source-inline"> Role.java</strong> file, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/Role.java
@Document(collection="role")
public class Role  implements Persistable&lt;Integer&gt;, Serializable {
    @Id
    private Integer id;
    private String name;
...
}</pre></li> <li>The final domain object that we<a id="_idIndexMarker319"/> need to refactor is our <strong class="source-inline">CalendarUser.java</strong> file. After all, this is the<a id="_idIndexMarker320"/> most complex domain object we have in <span class="No-Break">this application:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/domain/CalendarUser.java
@Document(collection="calendar_users")
public class CalendarUser implements Persistable&lt;Integer&gt;, Serializable {
    @Id
    private Integer id;
    private String firstName;
    private String lastName;
    private String email;
    private String password;
    @DBRef(lazy = false)
    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;(5);
…
}</pre></li> </ol>
<p>As you can see, the effort to refactor our<a id="_idIndexMarker321"/> do<a id="_idTextAnchor176"/>main objects from JPA to MongoDB is fairly simple, requiring less annotation<a id="_idTextAnchor177"/> <a id="_idIndexMarker322"/>configuration than the <span class="No-Break">JPA configuration.</span></p>
<h3>Spring Data repositories of MongoDB</h3>
<p>We now have only a few<a id="_idIndexMarker323"/> changes to make to refactor from a JPA implementation to a MongoDB implementation. We will <a id="_idIndexMarker324"/>begin by refactoring our <strong class="source-inline">CalendarUserRepository.java</strong> file by changing the interface that our repository extends, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//com/packtpub/springsecurity/repository/CalendarUserRepository.java
public interface CalendarUserRepository extends MongoRepository&lt;CalendarUser, Integer&gt; {
    CalendarUser findByEmail(String email);
}
...</pre> <p>sw <strong class="source-inline">RoleRepository.java</strong> <span class="No-Break">files accordingly.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">If you need help with any of these changes, remember the source for <strong class="source-inline">chapter05.05</strong> will have the completed code available for <span class="No-Break">your reference.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor178"/>Data access objects in MongoDB</h2>
<p>In our <strong class="source-inline">EventDao</strong> interface, we are required to create a new <strong class="source-inline">Event</strong> object. With JPA, we can automatically generate <a id="_idIndexMarker325"/>our object ID. With MongoDB, there are several ways to assign primary key identifiers, but for <a id="_idIndexMarker326"/>the sake of this demonstration, we are just going to use an atomic counter, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/dataaccess/MongoEventDao.java
@Repository
public class MongoEventDao implements EventDao {
private EventRepository repository;
// Simple Primary Key Generator
private AtomicInteger eventPK = new AtomicInteger(102);
  @Override
    public int createEvent(final Event event) {
...
        // Get the next PK instance
        event.setId(eventPK.incrementAndGet());
        Event newEvent = repository.save(event);
        return newEvent.getId();
    }
...
}</pre> <p>There was technically no change to our <strong class="source-inline">CalendarUserDao</strong> object, but for consistency in this book, we renamed the implementation file to denote the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Mongo</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
@Repository
public class MongoCalendarUserDao implements CalendarUserDao {</pre> <p>There are no other <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) changes <a id="_idIndexMarker327"/>required for this <span class="No-Break">refactoring example.</span></p>
<p>Go ahead and start the application, and it <a id="_idIndexMarker328"/>will behave just <span class="No-Break">as before.</span></p>
<p>Try to log in as <strong class="bold">user1</strong> and <strong class="bold">admin1</strong>. Then <a id="_idIndexMarker329"/>test the application to ensure that both users can add new events to the system, ensuring the mapping is correct for the <span class="No-Break">entire application.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter05.05-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor179"/>Summary</h1>
<p>We have looked at the power and flexibility of the Spring Data project and explored several aspects related to application development, as well as its integration with Spring Security. In this chapter, we covered the Spring Data project and a few of its capabilities. We also saw the refactoring process to convert from legacy JDBC code using SQL to ORM with JPA, and from a JPA implementation with Spring Data to a MongoDB implementation using Spring Data. We also covered configuring Spring Security to leverage an <strong class="source-inline">ORM Entity</strong> in a relational database and a <span class="No-Break">document database.</span></p>
<p>In the next chapter, we will explore Spring Security’s built-in support for <span class="No-Break"><em class="italic">LDAP-based authentication</em></span><span class="No-Break">.</span></p>
</div>
</div></body></html>