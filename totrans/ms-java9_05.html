<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Migrating Applications to Java 9</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, <span>we took a close look at the structure of Java modules as specified by Project Jigsaw and examined how Project Jigsaw was implemented to improve the Java platform. We also reviewed key internal changes to the Java platform with specific focus on the new modular system. We started with a modular primer where we learned about Java 9's modular system in terms of benefits and requirements. Next, w</span><span>e explored how Java 9 introduced modularity to the JDK. This included a look at how the source code was reorganized for Java 9. We also explored the JDK's seven primary tool categories and learned that Java 9 modularity extends to runtime images resulting in more maintainability, better performance, and increased security. The concept of <strong>link time</strong> was introduced as an optional phase between compile-time and runtime. We concluded the chapter with a look at the <strong>Java linker</strong> and how Java 9 encapsulates internal APIs.</span></p>
<p class="mce-root">In this chapter, we will explore how to migrate our existing applications to the Java 9 platform. We will look at both manual and semi-automated migration processes. Java 9 is a major release with numerous changes to the JDK so developers should not be surprised if their Java 8 code no longer works with Java 9. This chapter aims to provide you with insights and processes to get your Java 8 code working with Java 9.</p>
<p>The topics we will cover in this chapter are:</p>
<ul>
<li>Quick review of Project Jigsaw</li>
<li>How modules fit into the Java landscape</li>
<li>Migration planning</li>
<li>Advice from Oracle</li>
<li>Useful tools</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Quick review of Project Jigsaw</h1>
                </header>
            
            <article>
                
<p>Project Jigsaw is the Java project that encompasses several change recommendations to the Java platform. As you have read in earlier chapters, Java 9's greatest changes involve modules and modularity. The initiative to move to modules in Java was driven by Project Jigsaw. The need for modularity stemmed from two major challenges with Java:</p>
<ul>
<li>Classpath</li>
<li>JDK</li>
</ul>
<p>Next, we will review both of those challenges and see how they were addressed and overcome with the new release to the Java platform, Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Classpath</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, the classpath was problematic and the source of developer anguish. This was evident in the numerous developer forums and, fortunately, Oracle was paying attention. Here are the several instances in which the classpath can be problematic; here are two primary cases:</p>
<ul>
<li>The first case involves having two or more versions of a library on your development computer. The way this was previously handled by the Java system was inconsistent. Which library was used during the class loading process was anyone's guess. This resulted in an undesired lack of specificity--not enough details regarding which library was loaded.</li>
<li>The second case is in exercising the most advanced features of the class loader. Often times, this type of class loader usage resulted in the most errors and bugs. These were not always easy to detect and resulted in a lot of extra work for developers.</li>
</ul>
<p>Classpaths, before Java 9, were almost always very lengthy. Oracle, in a recent presentation, shared a classpath that contained 110 JAR files. This type of unwieldy classpath makes it difficult to detect conflicts or even determine if anything was missing and if so, what might be missing. The re-envisioning of the Java platform as a modular system made these classpath issues a thing of the past.</p>
<div class="packt_infobox">Modules solve the pre-Java 9 classpath problem by providing reliable configuration.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The monolithic nature of the JDK</h1>
                </header>
            
            <article>
                
<p>Java has continually evolved in an impressive fashion since 1995 and with each evolutionary step, the JDK grew larger. As with Java 8, the JDK had become prohibitively large. Prior to Java 9, there were several problematic issues stemming from the monolithic nature of the JDK, including:</p>
<ul>
<li>Because the JDK is so large, it does not fit on very small devices. In some development sectors this is enough reason to find a non-Java solution for software engineering problems.</li>
<li>The oversized JDK resulted in waste. It was wasteful in terms of processing and memory when running on devices, networks, and the cloud. This stems from the fact that the entire JDK is loaded, even when only a small subset of the JDK is required.</li>
<li>While the Java platform has great performance when running, the startup performance, in terms of load and launch times, leaves much to be desired.</li>
<li>The vast number of internal APIs has also been a pain point. Because so many internal APIs existed and were used by developers, the system has been difficult to evolve.</li>
<li>The existence of internal APIs has made it difficult to make the JDK secure and scalable. With so many internal dependencies, isolating security and scalability issues has been overly problematic.</li>
</ul>
<p>The answer to the monolithic woes of the JDK is the module. Java 9 introduced the module and its own modular system. One of the great updates to the platform is that only the modules needed are compiled, as opposed to the entire JDK. This modular system is covered throughout this book.</p>
<div class="packt_infobox">Modules solve the pre-Java 9 JDK monolithic issue by providing strong encapsulation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How modules fit into the Java landscape</h1>
                </header>
            
            <article>
                
<p>As you can see from the following illustration, packages are comprised of classes and interfaces, and modules are comprised of packages. Modules are a container of packages. This is the basic premise, at a very high level, of Java 9's new modular system. It is important to view modules as part of the modular system and not simply as a new level of abstraction above packages, as the illustration might suggest.</p>
<div class="CDPAlignCenter CDPAlign"><img height="96" width="144" src="assets/89681376-2954-4ed2-a21d-1be3e4e0654b.png"/></div>
<p>So, modules are new to Java 9 and they, as you would expect, require declaration before they can be used. A module's declaration includes names of other modules in which it has a dependency. It also exports packages for other modules that have dependencies to it. Modular declarations are arguably the most important modular issue to address as you start developing with Java 9. Here is an example:</p>
<pre>    module com.three19.irisScan <br/>    {<br/>      // modules that com.three19.irisScan depends upon<br/>      requires com.three19.irisCore;<br/>      requires com.three19.irisData;<br/><br/>      // export packages for other modules that are dependent<br/>         upon com.three19.irisScan<br/>      exports com.three19.irisScan.biometric;<br/>    }</pre>
<p>When programming a Java 9 application, your module declarations will be placed in a <kbd>module-info.java</kbd> file. Once this file is completed, you simply run <kbd>javac</kbd>, the Java Compiler, to generate the <kbd>module-info.class</kbd> Java class file. You accomplish this task in the same manner that you currently compile your <kbd>.java</kbd> files into <kbd>.class</kbd> files.</p>
<p>You can also create modular JAR files that have your <kbd>module-info.class</kbd> file at its root. This represents a great level of flexibility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Base module</h1>
                </header>
            
            <article>
                
<p>When programming Java 9 applications, or porting existing applications programmed with older versions of Java, the base module (<kbd>java.base</kbd>) must be used. Every module requires the <kbd>java.base</kbd> module because it defines the critical, or foundational, Java platform APIs. Here are the contents of the <kbd>java.base</kbd> <span>module:</span></p>
<pre>    module java.base <br/>    {<br/>      exports java.io;<br/>      exports java.lang;<br/>      exports java.lang.annotation;<br/>      exports java.lang.invoke;<br/>      exports java.lang.module;<br/>      exports java.lang.ref;<br/>      exports java.lang.reflect;<br/>      exports java.math;<br/>      exports java.net;<br/>      exports java.net.spi;<br/>      exports java.nio;<br/>      exports java.nio.channels;<br/>      exports java.nio.channels.spi;<br/>      exports java.nio.charset;<br/>      exports java.nio.charset.spi;<br/>      exports java.nio.file;<br/>      exports java.nio.file.attribute;<br/>      exports java.nio.file.spi;<br/>      exports java.security;<br/>      exports java.security.aci;<br/>      exports java.security.cert;<br/>      exports java.security.interfaces;<br/>      exports java.security.spec;<br/>      exports java.text;<br/>      exports java.text.spi;<br/>      exports java.time;<br/>      exports java.time.chrono;<br/>      exports java.time.format;<br/>      exports java.time.temporal;<br/>      exports java.time.zone;<br/>      exports java.util;<br/>      exports java.util.concurrent;<br/>      exports java.util.concurrent.atomic;<br/>      exports java.util.concurrent.locks;<br/>      exports java.util.function;<br/>      exports java.util.jar;<br/>      exports java.util.regex;<br/>      exports java.util.spi;<br/>      exports java.util.stream;<br/>      exports java.util.zip;<br/>      exports java.crypto;<br/>      exports java.crypto.interfaces;<br/>      exports java.crytpo.spec;<br/>      exports java.net;<br/>      exports java.net,ssi;<br/>      exports java.security.auth;<br/>      exports java.security.auth.callbak;<br/>      exports java.security.auth.login;<br/>      exports java.security.auth.spi;<br/>      exports java.security.auth.x500;<br/>      exports java.security.cert;<br/>    }</pre>
<p>As you can see, the <kbd>java.base</kbd> module does not require any modules and it exports numerous packages. It can be useful to have a list of these exports handy so you know what is available to you as you start creating applications using the new Java platform, Java 9.</p>
<p>You will notice that in the previous section, we did not include the <kbd>requires java.base;</kbd> line of code in our declaration of our <kbd>com.three19.irisScan</kbd> module. The updated code is provided as follows and now includes the <kbd>requires java.base;</kbd> line of code:</p>
<pre>    module com.three19.irisScan <br/>    {<br/>      // modules that com.three19.irisScan depends upon<br/>      requires java.base; // optional inclusion <br/>      requires com.three19.irisCore;<br/>      requires com.three19.irisData;<br/><br/>      // export packages for other modules that are dependent<br/>         upon com.three19.irisScan<br/>      exports com.three19.irisScan.biometric;<br/>    }</pre>
<p>If you do not include the <kbd>requires java.base;</kbd> line of code in your module declarations, the Java Compiler will automatically include it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reliable configuration</h1>
                </header>
            
            <article>
                
<p>As suggested earlier in this chapter, modules provide a reliable configuration of our Java 9 applications that solves the classpath problem in earlier versions of the Java platform.</p>
<p>Java reads and interprets modular declarations making the modules readable. These readable modules permit the Java platform to determine if any modules are missing, if there are duplicate libraries declared, or there are any other conflicts. In Java 9, very specific error messages will be generated and output by the compiler or at runtime. Here is an example of a compile-time error:</p>
<pre><strong>src/com.three19.irisScan/module-info.java: error: module not found: com.three19.irisScan </strong><br/><strong>requires com.three19.irisCore;</strong><br/><strong>         ^</strong><br/><strong>1 error</strong></pre>
<p>Here is an example of a runtime error that would occur if the module <kbd>com.three19.isrisCore</kbd> was not found, but required by the <kbd>com.three19.irisScan</kbd> app:</p>
<pre><strong>Error occurred during initialization of VM</strong><br/><strong>java.lang.module.ResolutionException: Module com.three19.irisCore not found, required by com.three19.irisScan app</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Strong encapsulation</h1>
                </header>
            
            <article>
                
<p>Earlier in this chapter, you read that Java 9's strong encapsulation remedied the monolithic JDK issue. Encapsulation, in Java 9, is driven by the information in the <kbd>module-info.java</kbd> file. The information in this file lets Java know what modules are dependent upon others and what each of them exports. This underscores the importance of ensuring our <kbd>module-info-java</kbd> files are properly configured. Let's look at an example written with standard Java code, nothing new in Java 9 in the way this was coded:</p>
<div class="CDPAlignCenter CDPAlign"><img height="219" width="658" src="assets/241204f0-a964-45ce-b51c-f605109382a9.png"/></div>
<p>In the preceding example, the <kbd>com.three19.irisScan</kbd> module has an <kbd>irisScanner</kbd> package intended for internal use and an <kbd>irisScanResult</kbd> class. If the <kbd>com.three19.access</kbd> application tries to import and use the <kbd>irisScanResult</kbd> class, the following error message will be produced by the Java Compiler:</p>
<pre><strong>src/com.three19.access/com/three19/access/Main.java: error: irisScanResult is not accessible because package com.three19.irisScanner.internal is not exported</strong><br/><strong>  private irisSanResult scan1 = new irisScanResult();</strong><br/><strong>                                     ^</strong><br/><strong>1 error</strong></pre>
<p>If for some reason the compiler does not catch this error, although it would be very unlikely, the following runtime error would occur:</p>
<pre><strong>Exception in thread "main" java.lang.IllegalAccessError: class com.three19.access.Main (in module: com.three19.access) cannot access class com.three19.irisScanner.internal.irisScanResult (in module: com.three19.irisScan), com.three19.irisScanner.internal is not exported to com.three19.access.</strong></pre>
<p>The detailed error messages will make debugging and troubleshooting much easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migration planning</h1>
                </header>
            
            <article>
                
<p>The changes to the Java platform are significant and Java 9 is considered a major release. It would be naive to think our current Java applications will work seamlessly on Java 9. While that might be the case, at least for simple programs, it is prudent to plan ahead and consider the issues you are most likely to encounter. Before we look at these issues, let's test a simple Java application in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing a simple Java application</h1>
                </header>
            
            <article>
                
<p>The following code consists of a single Java class, <kbd>GeneratePassword.</kbd> This class prompts the user for a desired password length and then generates a password based on the user's requested length. If the user asks for a length shorter than 8, the default length of 8 will be used. This code was written with the Java SE 1.7 JRE System Library:</p>
<pre>    /*<br/>    * This is a simple password generation app <br/>    */<br/><br/>    import java.util.Scanner;<br/><br/>    public class GeneratePassword <br/>    {<br/>      public static void main(String[] args) <br/>      { <br/>        // passwordLength int set up to easily change the schema <br/>        int passwordLength = 8; //default value<br/> <br/>        Scanner in = new Scanner(System.in); <br/>        System.out.println("How long would you like your<br/>         password (min 8)?"); <br/>        int desiredLength; <br/>        desiredLength = in.nextInt(); <br/><br/>        // Test user input <br/>        if (desiredLength &gt;8) <br/>        { <br/>          passwordLength = desiredLength; <br/>        } <br/><br/>        // Generate new password <br/>        String newPassword = createNewPassword(passwordLength); <br/><br/>        // Prepare and provide output <br/>        String output = "\nYour new " + passwordLength <br/>         + "-character password is: "; <br/>        System.out.println(output + newPassword); <br/>      }<br/><br/>      public static String createNewPassword(int lengthOfPassword) <br/>      { <br/>        // Start with an empty String <br/>        String newPassword = "";<br/> <br/>        // Populate password  <br/>        for (int i = 0; i &lt; lengthOfPassword; i++) <br/>        { <br/>          newPassword = newPassword + randomizeFromSet(<br/>            "aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ<br/>             0123456789+-*/?!@#$%&amp;"); <br/>        } <br/><br/>        return newPassword; <br/>      }<br/> <br/>      public static String randomizeFromSet(String characterSet) <br/>      { <br/>        int len = characterSet.length();<br/>        int ran = (int)(len * Math.random());<br/>        return characterSet.substring(ran, ran + 1);<br/>      }<br/>    }</pre>
<p>In the following screenshot, we test the <kbd>GeneratePassword</kbd> app on a Mac running Java 8. As you can see, we start by querying Java to verify the current version. In this test, Java <kbd>1.8.0_121</kbd> was used. Next, we compile the <kbd>GeneratePassword</kbd> Java file using the <kbd>javac</kbd> utility. Lastly, we run the app:</p>
<div class="CDPAlignCenter CDPAlign"><img height="219" width="498" src="assets/2028cdc6-0fd5-4b97-a1b0-098212dd72f6.png"/></div>
<p>As you can see from the preceding test, <kbd>GeneratePassword.java</kbd> was successfully compiled with the <kbd>GeneratePassword.class</kbd> file resulting. The application was run using the <kbd>java GeneratePassword</kbd> command. The user was prompted for a desired password length and <kbd>32</kbd> was entered. The application then successfully generated a 32-character random password and provided the appropriate output.</p>
<p>This test demonstrated the example application works successfully using JDK 1.8. Next, let's test the same application using JDK 9.</p>
<p>We start with the <kbd>java -version</kbd> command to show that we are using JDK 9 on this computer. The following screenshot shows that we successfully compiled the <kbd>.java</kbd> file to a <kbd>.class</kbd> file. When the application was run, it functioned as expected and provided the proper results:</p>
<div class="CDPAlignCenter CDPAlign"><img height="246" width="489" src="assets/b7818208-6821-45d3-8543-275953546fe3.png"/></div>
<p>As you can see, we clearly demonstrated that a pre-Java 9 application has the potential to successfully run on Java 9 without having to make any modifications. This is a simple case study and featured a very basic Java program. This is, of course, the best case scenario, and cannot be assumed. You will want to test your applications to ensure they run as expected on the Java 9 platform.</p>
<p>In the next section, we will review some potential issues you might encounter when testing your pre-Java 9 applications using the new Java platform with JDK 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Potential migration issues</h1>
                </header>
            
            <article>
                
<p>The potential migration issues featured in this section include direct access to the JRE, access to internal APIs, accessing internal JARs, JAR URL depreciation, the extension mechanism, and the JDK's modularization. Let's look at each of these potential migration issues.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JRE</h1>
                </header>
            
            <article>
                
<p>Creating the Java 9's modular system resulted in some simplification in respect to the number and location of development and utility tools. One such example is the JDK's consumption of the JRE. In all pre-Java 9 versions, the Java platform included the JDK and JRE as two separate components. In Java 9, these components have been combined. This is a significant change and one that developers should be keenly aware of. If you have an application that specifically points to the JRE directory, you will need to make changes to avoid problems. The JRE contents are shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="149" width="645" src="assets/ca4dce21-485e-43cc-9627-bab90e65decd.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Access to internal APIs</h1>
                </header>
            
            <article>
                
<p>The Java 9 platform has encapsulated internal APIs to increase security of the platform and applications written in Java. Applications that you program in Java 9 will not have default access to the JDK's internal APIs, unlike with previous versions of the Java platform. Oracle has identified some internal APIs as critical; those APIs remain accessible via the <kbd>jdk.unsupported</kbd> JDK module.</p>
<p>The aforementioned critical APIs (internal to the JDK) are:</p>
<ul>
<li><kbd>sun.misc</kbd></li>
<li><kbd>sun.misc.Unsafe</kbd></li>
<li><kbd>sun.reflect.Reflection</kbd></li>
<li><kbd>sun.reflect.ReflectionFactory.newConstrutorForSerialization</kbd></li>
</ul>
<p>If you have pre-Java 9 applications that implement any <kbd>sun.*</kbd> or <kbd>com.sun.*</kbd> package, you will likely run into problems migrating your applications to Java 9. In order to address this issue, you should review your class files for use of <kbd>sun.*</kbd> and <kbd>com.sun.*</kbd> packages. Alternatively, you can use the Java dependency analysis tool, <kbd>jdeps</kbd>, to help determine if your Java program has any dependencies on JDK internal APIs.</p>
<div class="packt_infobox">The <kbd>jdeps</kbd> tool is the Java dependency analysis tool, that can be used to help determine if your Java program has any dependencies on JDK internal APIs.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing internal JARs</h1>
                </header>
            
            <article>
                
<p>Java 9 does not permit access to internal JARs such as <kbd>lib/ant-javax.jar</kbd>, <kbd>lib/dt.jar</kbd>, and others listed in the <kbd>lib</kbd> directory shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="245" width="148" src="assets/07a317a6-bc1c-40cf-93df-2d0e548ce833.png"/></div>
<p>The key thing to note here is that if you have Java applications that are dependent on one of these tools residing in the <kbd>lib</kbd> folder, you will need to modify your code accordingly.</p>
<div class="packt_tip">It is recommended that you test your IDE once you start using Java 9 to ensure the IDE is updated and officially supports Java 9. If you use more than one IDE for Java development, test each one to avoid surprises.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JAR URL depreciation</h1>
                </header>
            
            <article>
                
<p>JAR file URLs were, prior to Java 9, used by some APIs to identify specific files in the runtime image. These URLs contain a <kbd>jar:file:</kbd> prefix with two paths; one to the <kbd>jar</kbd> and one to the specific resource file within the <kbd>jar</kbd>. Here is the syntax for the pre-Java 9 JAR URL:</p>
<pre>    jar:file:&lt;path-to-jar&gt;!&lt;path-to-file-in-jar&gt;</pre>
<p><span>With the advent of Java 9's modular system, containers will house resource files instead of individual JARs. The new syntax for accessing resource files is as follows:</span></p>
<pre>    jrt:/&lt;module-name&gt;/&lt;path-to-file-in-module&gt;</pre>
<p>A new URL schema, <kbd>jrt</kbd>, is now in place for naming resources within a runtime image. These resources include classes and modules. The new schema allows for the identification of a resource without introducing a security risk to the runtime image. This increased security ensures that the runtime image's form and structure remain concealed. Here is the new schema:</p>
<pre>    jrt:/[$MODULE[/$PATH]]</pre>
<p>Interestingly, a <kbd>jrt</kbd> URL's structure determines its meaning, suggesting that the structure can take one of several forms. Here are three examples of different <kbd>jrt</kbd> URL structures:</p>
<ul>
<li><kbd>jrt:/$MODULE/$PATH</kbd>: This structure provides access to the resource file, identified with the <kbd>$PATH</kbd> parameter, within the module specified with the <kbd>$MODULE</kbd> parameter</li>
<li><kbd>jrt:/$MODULE</kbd>: This structure provides reference to all resource files within the module specified with the <kbd>$MODULE</kbd> parameter</li>
<li><kbd>jrt:/</kbd>: This structure provides reference to all resource files in the runtime image</li>
</ul>
<p>If you have preexisting code that uses URL instances, returned by APIs, you should not have any problems. On the other hand, if your code is dependent on the <kbd>jar</kbd> URL structure, you will have problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extension mechanism</h1>
                </header>
            
            <article>
                
<p>The Java platform previously had an extension mechanism that gave developers the ability to make custom APIs available to all applications. As you can see in the following illustration, extensions are plugins of sorts, or add-ons to the Java platform. The APIs and classes in each extension are, by default, automatically available:</p>
<div class="CDPAlignCenter CDPAlign"><img height="313" width="417" src="assets/d7fd1ca1-b597-4197-88eb-f338871ba25a.png"/></div>
<p>As the illustration suggests, Java applications have access both to the Java platform and extensions without requiring classpaths. This feature was depreciated in Java 8 and no longer exists in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JDK's modularization</h1>
                </header>
            
            <article>
                
<p>By now, you have a firm appreciation of Java 9's modularization. The old adage in Java, and other object-oriented programming language, is <em>everything is a class</em>. Now, with Java 9, <em>everything is a module</em> is the new adage. There are three type of modules as explained as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Module type</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>Automatic</td>
<td>When a JAR is placed on a new module path, modules are automatically created</td>
</tr>
<tr>
<td>Explicit/Named</td>
<td>These modules are manually defined by editing the <kbd>module-info.java</kbd> file</td>
</tr>
<tr>
<td>Unnamed</td>
<td>When a JAR is placed on a classpath, unnamed modules are created</td>
</tr>
</tbody>
</table>
<p> </p>
<p>When you migrate your applications to Java 9, your application and its libraries become unnamed modules. So, you will need to ensure all the modules are in the module path.</p>
<p>Another thing to be aware of is that your runtime image will not contain the entire JDK. Instead, it will only contain the modules your application requires. It is worth reviewing how the JDK is modularized in Java 9. The following table contains the API specification for the JDK in Java 9:</p>
<table>
<tbody>
<tr>
<td><kbd>jdk.accessibility</kbd></td>
<td><kbd>jdk.attach</kbd></td>
<td><kbd>jdk.charsets</kbd></td>
<td><kbd>jdk.compiler</kbd></td>
</tr>
<tr>
<td><kbd>jdk.crypto.cryptoki</kbd></td>
<td><kbd>jdk.crypto.ec</kbd></td>
<td><kbd>jdk.dynalink</kbd></td>
<td><kbd>jdk.editpad</kbd></td>
</tr>
<tr>
<td><kbd>jdk.hotspot.agent</kbd></td>
<td><kbd>jdk.httpserver</kbd></td>
<td><kbd>jdk.incubator.httpclient</kbd></td>
<td><kbd>jdk.jartool</kbd></td>
</tr>
<tr>
<td><kbd>jdk.javadoc</kbd></td>
<td><kbd>jdk.jcmd</kbd></td>
<td><kbd>jdk.jconsole</kbd></td>
<td><kbd>jdk.jdeps</kbd></td>
</tr>
<tr>
<td><kbd>jdk.jdi</kbd></td>
<td><kbd>jdk.jdwp.agent</kbd></td>
<td><kbd>jdk.jlink</kbd></td>
<td><kbd>jdk.jshell</kbd></td>
</tr>
<tr>
<td><kbd>jdk.jsobject</kbd></td>
<td><kbd>jdk.jstatd</kbd></td>
<td><kbd>jdk.localedata</kbd></td>
<td><kbd>jdk.management</kbd></td>
</tr>
<tr>
<td><kbd>jdk.management.agent</kbd></td>
<td><kbd>jdk.naming.dns</kbd></td>
<td><kbd>jdk.naming.rmi</kbd></td>
<td><kbd>jdk.net</kbd></td>
</tr>
<tr>
<td><kbd>jdk.pack</kbd></td>
<td><kbd>jdk.packager.services</kbd></td>
<td><kbd>jdk.policytool</kbd></td>
<td><kbd>jdk.rmic</kbd></td>
</tr>
<tr>
<td><kbd>jdk.scripting.nashorn</kbd></td>
<td><kbd>jdk.sctp</kbd></td>
<td><kbd>jdk.security.auth</kbd></td>
<td><kbd>jdk.security.jgss</kbd></td>
</tr>
<tr>
<td><kbd>jdk.snmp</kbd></td>
<td><kbd>jdk.xml.dom</kbd></td>
<td><kbd>jdk.zipfs</kbd></td>
<td/>
</tr>
</tbody>
</table>
<p>The following table contains the API specification for Java SE in Java 9:</p>
<table>
<tbody>
<tr>
<td><kbd>java.activation</kbd></td>
<td><kbd>java.base</kbd></td>
<td><kbd>java.compiler</kbd></td>
<td><kbd>java.cobra</kbd></td>
</tr>
<tr>
<td><kbd>java.datatransfer</kbd></td>
<td><kbd>java.desktop</kbd></td>
<td><kbd>java.instrument</kbd></td>
<td><kbd>java.logging</kbd></td>
</tr>
<tr>
<td><kbd>java.management</kbd></td>
<td><kbd>java.management.rmi</kbd></td>
<td><kbd>java.naming</kbd></td>
<td><kbd>java.prefs</kbd></td>
</tr>
<tr>
<td><kbd>java.rmi</kbd></td>
<td><kbd>java.scripting</kbd></td>
<td><kbd>java.se</kbd></td>
<td><kbd>java.se.ee</kbd></td>
</tr>
<tr>
<td><kbd>java.security.jgss</kbd></td>
<td><kbd>java.security.sasi</kbd></td>
<td><kbd>java.sql</kbd></td>
<td><kbd>java.sql.rowset</kbd></td>
</tr>
<tr>
<td><kbd>java.transaction</kbd></td>
<td><kbd>java.xml</kbd></td>
<td><kbd>java.xml.bind</kbd></td>
<td><kbd>java.xml.crypto</kbd></td>
</tr>
<tr>
<td><kbd>java.xml.ws</kbd></td>
<td><kbd>java.xml.ws</kbd></td>
<td><kbd>java.xml.ws.annotation</kbd></td>
<td/>
</tr>
</tbody>
</table>
<div class="packt_tip">Remember, all applications will have access to <kbd>java.base</kbd> as it is in the module path by default.</div>
<p>The following table contains the API specification for JavaFX in Java 9:</p>
<table>
<tbody>
<tr>
<td><kbd>javafx.base</kbd></td>
<td><kbd>javafx.controls</kbd></td>
<td><kbd>javafx.fxml</kbd></td>
<td><kbd>javafx.graphics</kbd></td>
</tr>
<tr>
<td><kbd>javafx.media</kbd></td>
<td><kbd>javafx.swing</kbd></td>
<td><kbd>javafx.web</kbd></td>
<td/>
</tr>
</tbody>
</table>
<p> </p>
<p>There are two additional modules:</p>
<ul>
<li><kbd>java.jnlp</kbd> defines the API for <strong>JNLP</strong> (<strong>Java Network Launch Protocol</strong>)</li>
<li><kbd>java.smartcardio</kbd> defines the API for the Java Smart Card Input/Output</li>
</ul>
<div class="packt_tip">For details on any of these modules, visit Oracle's <em>Java® Platform, Standard Edition &amp; Java Development Kit Version 9 API Specification</em> website: <a href="http://download.java.net/java/jdk9/docs/api/overview-summary.html">http://download.java.net/java/jdk9/docs/api/overview-summary.html</a>.<a href="http://download.java.net/java/jdk9/docs/api/overview-summary.html"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Advice from Oracle</h1>
                </header>
            
            <article>
                
<p>Oracle has done a great job in bringing us this major update, version 9, to the Java platform. Their insights into getting ready for Java 9 and how to migrate to the new JDK is worth reviewing. In this section, we will look at preparatory steps, breaking encapsulation, changes to the runtime image, components such as tools and APIs that have been removed, changes to garbage collection, and deployment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparatory steps</h1>
                </header>
            
            <article>
                
<p>Oracle provides a five-step process to help developers migrate their Java applications to version 9. These steps are listed as follows and then covered in subsequent sections:</p>
<ol>
<li>Get the JDK 9 early access build.</li>
<li>Run your program before recompiling.</li>
<li>Update third-party libraries and tools.</li>
<li>Compile your application.</li>
<li>Run <kbd>jdeps</kbd> on your code.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the JDK 9 early access build</h1>
                </header>
            
            <article>
                
<p>If you are reading this book before Java 9 is officially released, then you can obtain a JDK 9 early access build from here--<a href="http://jdk.java.net/9/">http://jdk.java.net/9/</a>. Early release builds are available for Windows (32 and 64), macOS (64), Linux (32 and 64) and various Linux ARM, Solaris, and Alpine Linux versions.</p>
<p>Taking the time to test your applications for Java 9 and get them migrated before Java 9 is officially released, helps ensure you will not experience any downtime for services that rely on your Java applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running your program before recompiling</h1>
                </header>
            
            <article>
                
<p>As indicated earlier in this chapter, there is a chance that your existing Java applications will run without modification on the Java 9 platform. So, before you make any changes, try running your current application on the Java 9 platform. If your application works fine on Java 9, that is great, but your work is not complete. Review the next three sections on updating third-party libraries and tools, compiling your application, and running <kbd>jdeps</kbd> on your code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating third-party libraries and tools</h1>
                </header>
            
            <article>
                
<p>Third-party libraries and tools can help extend our applications and shorten development time. For Java 9 compatibility, it is important to ensure that each third-party library and tool you use is compatible with and supports version 9 of the JDK. Running your application on Java 9 will not provide you with the level of insight you need to ensure you do not have compatibility issues down the road. It is recommended that you review the official website for each library and tool to verify compatibility with and support of JDK 9.</p>
<p>If a library or tool that you use does have a version that supports JDK 9, download and install it. If you find one that does not yet support JDK 9, consider finding a replacement for it.</p>
<p>In our context, tools includes <strong>Integrated Development Environments</strong> (<strong>IDE</strong>). NetBeans, Eclipse, and IntelliJ all have IDE versions that support JDK 9. Links to those sites are provided as follows:</p>
<ul>
<li><strong>NetBeans</strong>: <a href="http://bits.netbeans.org/download/trunk/nightly/latest/">http://bits.netbeans.org/download/trunk/nightly/latest/</a></li>
<li><strong>Eclipse</strong>: <a href="https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php">https://www.eclipse.org/community/eclipse_newsletter/2015/june/article4.php</a></li>
<li><strong>IntelliJ</strong>: <a href="https://www.jetbrains.com/idea/nextversion/">https://www.jetbrains.com/idea/nextversion/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling your application</h1>
                </header>
            
            <article>
                
<p>Your next step is to compile your application using JDK 9's <kbd>javac</kbd>. This is important, even if your app works fine on JDK 9. You might not receive compiler errors, but watch for warnings too. Here are the most common reasons your applications might not compile with JDK 9, assuming they compiled fine prior to Java 9.</p>
<p>First, as indicated earlier in this chapter, most of the JDK 9 internal APIs are not accessible by default. Your indication will be an <kbd>IllegalAccessErrors</kbd> error at runtime or compile time. You will need to update your code so that you are using accessible APIs.</p>
<p>A second reason your pre-Java 9 applications might not compile with JDK 9 is if you use the underscore character as a single character identifier. According to Oracle, this practice generates a warning in Java 8 and an error in Java 9. Let's look at an example. The following Java class instantiates an Object named <kbd>_</kbd> and prints a singular message to the console:</p>
<pre><span>    public</span> <span>class</span> Underscore <br/>    {<span class="Apple-tab-span"> <br/></span><span>      public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <br/>      {<br/>        Object <span>_</span> = <span>new</span> Object();<br/><span>        System.</span><span>out</span><span>.println(</span>"This ran successfully."<span>);<br/></span>      }<br/>    }</pre>
<p>When we compile this program with Java 8, we receive a warning that <span>use of '<kbd>_</kbd>' as an identifier might not be supported in releases after Java SE 8:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="135" width="496" src="assets/439330e1-2220-4844-8d86-5a62ac66b26d.png"/></div>
<p><span>As you can see in the following screenshot, that is just a warning and the application runs fine:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="90" width="303" src="assets/289ba83c-97b4-4ab1-8970-5bfdd03c2a26.png"/></div>
<p>Now, let's try compiling the same class using JDK 9:</p>
<div class="CDPAlignCenter CDPAlign"><img height="188" width="559" src="assets/ab44bf56-f1d9-42db-b913-348fcead1715.png"/></div>
<p>As you can see, use of the underscore as a single character identifier still only resulted in a warning and not an error. The application ran successfully. This test was run when JDK 9 was still in early release. It is assumed that running this test once JDK 9 has been officially released will result in an error instead of just a warning. The error that would likely be thrown is as follows:</p>
<pre><strong>Underscore.java:2: error: as of release 9, '_' is a keyword, and may not be used as a legal identifier.</strong></pre>
<p>Even if this issue is not resolved with the formal release of JDK 9, use of an underscore as a single character identifier is not good programming practice, so you should steer away from using it.</p>
<p>A third potential reason for your pre-Java 9 programmed application not to compile with JDK 9 is if you are using the <kbd>-source</kbd> and <kbd>-target</kbd> compiler options. Let's take a look at the <kbd>-source</kbd> and <kbd>-target</kbd> compiler options pre-Java 9 and with Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-Java 9 -source and -target options</h1>
                </header>
            
            <article>
                
<p>The <kbd>-source</kbd> option specifies the Java SE version and has the following acceptable values:</p>
<table>
<tbody>
<tr>
<td><strong>Value</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>1.3</td>
<td><kbd>javac</kbd> does not support features introduced after Java SE 1.3.</td>
</tr>
<tr>
<td>1.4</td>
<td><kbd>javac</kbd> accepts code with language features introduced in Java SE 1.4.</td>
</tr>
<tr>
<td>1.5 or 5</td>
<td><kbd>javac</kbd> accepts code with languages features introduced in Java SE 1.5.</td>
</tr>
<tr>
<td>1.6 or 6</td>
<td><kbd>javac</kbd> reports encoding errors as errors instead of warnings. Of note, no new language features were intruded with Java SE 1.6.</td>
</tr>
<tr>
<td>1.7 or 7</td>
<td><kbd>javac</kbd> accepts code with language features introduced in Java SE 1.7. This is the default value if the <kbd>-source</kbd> option is not used.</td>
</tr>
</tbody>
</table>
<p>The <kbd>-target</kbd> option tells <kbd>javac</kbd> what version of the JVM to target. The acceptable values for the <kbd>-target</kbd> option are--<kbd>1.1</kbd>, <kbd>1.2</kbd>, <kbd>1.3</kbd>, <kbd>1.4</kbd>, <kbd>1.5</kbd> or <kbd>5</kbd>, <kbd>1.6</kbd> or <kbd>6</kbd> and <kbd>1.7</kbd> or <kbd>7</kbd>. If the <kbd>-target</kbd> option is not used, the default JVM target is dependent on the value used with the <kbd>-source</kbd> option. Here is a table of <kbd>-source</kbd> values with their associated <kbd>-target</kbd>:</p>
<table>
<tbody>
<tr>
<td><strong>-source value</strong></td>
<td><strong>default -target</strong></td>
</tr>
<tr>
<td>unspecified</td>
<td>1.7</td>
</tr>
<tr>
<td>1.2</td>
<td>1.4</td>
</tr>
<tr>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td>1.4</td>
<td>1.4</td>
</tr>
<tr>
<td>1.5 or 5</td>
<td>1.7</td>
</tr>
<tr>
<td>1.6 or 6</td>
<td>1.7</td>
</tr>
<tr>
<td>1.7</td>
<td>1.7</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java 9 -source and -target options</h1>
                </header>
            
            <article>
                
<p>In Java 9, the supported values are shown as follows:</p>
<table>
<tbody>
<tr>
<td><strong>Supported values</strong></td>
<td><strong>Remarks</strong></td>
</tr>
<tr>
<td>9</td>
<td>This is the default, should no value be specified</td>
</tr>
<tr>
<td>8</td>
<td>Sets support to 1.8</td>
</tr>
<tr>
<td>7</td>
<td>Sets support to 1.7</td>
</tr>
<tr>
<td>6</td>
<td>Sets support to 1.6 and generates a warning (not an error) to indicate JDK 6 is depreciated</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running jdeps on your code</h1>
                </header>
            
            <article>
                
<p>The <kbd>jdeps</kbd> class dependency analysis tool is not new to Java 9, but perhaps has never been as important to developers with the advent of Java 9. An important step to migrating your applications to Java 9 is to run the <kbd>jdeps</kbd> tool to determine the dependencies your applications and its libraries have. The <kbd>jdeps</kbd> tool does a great job of suggesting replacements if your code has dependencies on any internal APIs.</p>
<p>The following screenshot shows the options available to you when using the <kbd>jdeps</kbd> analyzer:</p>
<div class="CDPAlignCenter CDPAlign"><img height="686" width="693" src="assets/dd824bf6-231e-4035-b54e-26d71097801e.png"/></div>
<p>Let's take a look at an example. Here is a simple Java class called <kbd>DependencyTest</kbd>:</p>
<pre><span>    import</span> <span>sun.misc.BASE64Encoder</span>;<br/><br/><span>    public</span> <span>class</span> DependencyTest <br/>    {<br/>     <span class="Apple-tab-span"> </span><span>public</span> <span>static</span> <span>void</span> main(String[] <span>args</span>) <span>throws<br/></span>       InstantiationException, IllegalAccessException <br/><span class="Apple-tab-span"> </span>     {<br/>  <span class="Apple-tab-span">     </span> <span>BASE64Encoder</span>.<span>class</span>.newInstance();<br/><span>        System.</span><span>out</span><span>.println(</span>"This Java app ran successfully."<span>);<br/></span>      }<br/>    }</pre>
<p>Now, let's use <kbd>javac</kbd> to compile this class using Java 8:</p>
<div class="CDPAlignCenter CDPAlign"><img height="193" width="524" src="assets/87c5c505-99ed-4534-a92f-93e4f211c8fd.png"/></div>
<p>As you can see, Java 8 successfully compiled the class and the application ran. The compiler did give us a <kbd>DependencyTest.java:6: warning: BASE64Encoder is internal proprietary API and may be removed in a future release</kbd> warning. Now, let's see what happens when we try to compile this class using Java 9:</p>
<div class="CDPAlignCenter CDPAlign"><img height="146" width="516" src="assets/e8692a45-1e67-4647-96f6-4978636aa766.png"/></div>
<p>In this case, with Java 9, the compiler gave us two warnings instead of one. The first warning is for the <kbd>import sun.misc.BASE64Encoder;</kbd> statement and the second for the <kbd>BASE64Encoder.class.newInstance();</kbd> method call. As you can see, these are just warnings and not errors, so the <kbd>DependencyTest.java</kbd> class file is successfully compiled. Next, let's run the application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2d882662-f769-4857-abdc-a2c57a9777a3.png"/></div>
<p>Now, we can clearly see that Java 9 will not allow us to run the application. Next, let's run a dependency test using the <kbd>jdeps</kbd> analyzer tool. We will use the following command line syntax--<kbd>jdeps DependencyTest.class</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fb0f1506-75b5-4f58-bb41-b78f8e94ca12.png"/></div>
<p>As you can see, we have three dependencies: <kbd>java.io</kbd>, <kbd>java.lang</kbd>, and <kbd>sun.misc</kbd>. Here we are given the suggestion to replace our <kbd>sun.misc</kbd> dependency with <kbd>rt.jar</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Breaking encapsulation</h1>
                </header>
            
            <article>
                
<p>The Java 9 platform is more secure than its predecessor versions due to, in part, the increased encapsulation that resulted from the modular reorganization. That being said, you might have a requirement to break through the modular system's encapsulation. Breaking through these access control boundaries is permitted by Java 9.</p>
<p>As you read earlier in this chapter, most internal APIs are strongly encapsulated. As previously suggested, you might look for replacement APIs when updating your source code. Of course, that is not always feasible. There are three additional approaches you can take--using the <kbd>--add-opens</kbd> option at runtime; employing the <kbd>--add-exports</kbd> option; and <kbd>--permit-illegal-access</kbd> command-line option. Let's look at each of those options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The --add-opens option</h1>
                </header>
            
            <article>
                
<p>You can use the <kbd>--add-opens</kbd> runtime option to allow your code to access non-public members. This can be referred to as deep reflection. Libraries that do this deep reflection are able to access all members, private and public. To grant this type of access to your code, you use the <kbd>--add-opens</kbd> option. Here is the syntax:</p>
<pre>    --add-opens module/package=target-module(,target-module)*</pre>
<p>This allows the given module to open the specified package. The compiler will not produce any errors or warnings when this is used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The --add-exports option</h1>
                </header>
            
            <article>
                
<p>You can use <kbd>--add-exports</kbd> to break encapsulation so that you can use an internal API whose default is to be inaccessible. Here is the syntax:</p>
<pre>    --add-exports &lt;source-module&gt;/&lt;package&gt;=&lt;target-module&gt;(<br/>     ,&lt;target-module&gt;)*</pre>
<p>This command-line option gives code in the <kbd>&lt;target-module&gt;</kbd> access to types in the <kbd>&lt;source-module&gt;</kbd> package.</p>
<p>Another method of breaking encapsulation is with a JAR file's manifest. Here is an example:</p>
<pre>    --add-exports:java.management/sun.management</pre>
<div class="packt_tip">The <kbd>--add-exports</kbd> command-line option should only be used if deemed absolutely necessary. It is not advisable to use this option except for short-term solutions. The danger of using it routinely is that any updates to referenced Internal APIs could result in your code not working properly.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The --permit-illegal-access option</h1>
                </header>
            
            <article>
                
<p>A third option for breaking encapsulation is to use the <kbd>--permit-illegal-access</kbd> option. Of course, it is prudent to check with third-party library creators to see if they have an updated version. If that is not an option, you use <kbd>--permit-illegal-access</kbd> to gain illegal access to operations to be implemented on the classpath. Due to the significantly illegal operation here, you will receive warnings each time one of these operations occurs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Runtime image changes</h1>
                </header>
            
            <article>
                
<p>Java 9 represents a major change to the JDK and the JRE. Much of these changes are related to modularity and have been covered in other chapters. There are still a few more things you should consider.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java version schema</h1>
                </header>
            
            <article>
                
<p>With Java 9, the way the Java platform's version is displayed has changed. Here is an example of a pre-Java 9 version format:</p>
<div class="CDPAlignCenter CDPAlign"><img height="96" width="325" src="assets/32aa88c3-fa5a-4ea8-96d7-0fe0dacc39aa.png"/></div>
<p>Now, let's look at how Java 9 reports its version:</p>
<div class="CDPAlignCenter CDPAlign"><img height="112" width="365" src="assets/5e01176c-5184-4f4b-b6a7-503e01a856c9.png"/></div>
<p>As you can see, with Java 9, the version schema is now <kbd>$MAJOR.$MINOR.$SECURITY.$PATCH</kbd>. This is markedly different than with previous versions of Java. This will only impact your applications if you have code that parses the string returned by the <kbd>java -version</kbd> command and option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JDK and JRE layout</h1>
                </header>
            
            <article>
                
<p>How files are organized in the JDK and the JRE have changed in the new version of Java. It is worth your time to familiarize yourself with the new filesystem layout. The following screenshot shows the file structure of the JDK's <kbd>/bin</kbd> folder:</p>
<div class="CDPAlignCenter CDPAlign"><img height="593" width="266" src="assets/42a9d7d0-cc34-485c-b8c8-2a6938ed2662.png"/></div>
<p>Here is the layout of the <kbd>\lib</kbd> folder:</p>
<div class="CDPAlignCenter CDPAlign"><img height="633" width="403" src="assets/80dcb041-4f86-4a76-a085-7fcee1a85af4.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What has been removed</h1>
                </header>
            
            <article>
                
<p>Another area of change for the new version of the Java platform is that many platform components have been removed. The following sections represent the most significant components.</p>
<p>Notably, the <kbd>rt.jar</kbd> and <kbd>tools.jar</kbd> and <kbd>dt.jar</kbd> have been removed. These JAR files contained class and other resources files and all resided in the <kbd>/lib</kbd> directory.</p>
<p>The e<em>ndorsed standards override mechanism</em> has been removed. In Java 9, both <kbd>javac</kbd> and <kbd>java</kbd> will exit if they detect that mechanism. The mechanism was used for application servers to override some JDK components. In Java 9, you can use upgradeable modules to achieve the same result.</p>
<p>As previously covered in this chapter, the e<em>xtension mechanism</em> has also been removed.</p>
<p>The following listed APIs were previously depreciated and have been removed and are not accessible in Java 9. Removal of these APIs is the result of the modularization of the Java platform:</p>
<ul>
<li><kbd>apple.applescript</kbd></li>
<li><kbd>com.apple.concurrent</kbd></li>
<li class="mce-root"><kbd><span class="apiname">com.sun.image.codec.jpeg</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.awt.dnd.peer</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.awt.peer</span></kbd></li>
<li><kbd>java.rmi.server.disableHttp</kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.logging.LogManager.addPropertyChangeListener</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.logging.LogManager.removePropertyChangeListener</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.jar.Pack200.Packer.addPropertyChangeListener</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.jar.Pack200.Packer.removePropertyChangeListener</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.jar.Pack200.Unpacker.addPropertyChangeListener</span></kbd></li>
<li class="mce-root"><kbd><span class="apiname">java.util.jar.Pack200.Unpacker.removePropertyChangeListener</span></kbd></li>
<li><kbd>javax.management.remote.rmi.RMIIIOPServerImpl</kbd></li>
<li><kbd>sun.misc.BASE64Encoder</kbd></li>
<li><kbd>sun.misc.BASE64Decoder</kbd></li>
<li><kbd><kbd>sun.rmi.transport.proxy.connectTimeout</kbd></kbd></li>
<li><kbd>sun.rmi.transport.proxy.eagerHttpFallback</kbd></li>
<li><kbd>sun.rmi.transport.proxy.logLevel</kbd></li>
<li><kbd>sun.rmi.transport.tcp.proxy</kbd></li>
</ul>
<p>The following listed tools have been removed. In each case, the tool was previously depreciated or its functionality superseded by better alternatives:</p>
<ul>
<li><kbd>hprof</kbd></li>
<li><kbd>java-rmi.cgi</kbd></li>
<li><kbd>java-rmi.exe</kbd></li>
<li><kbd>JavaDB</kbd></li>
<li><kbd>jhat</kbd></li>
<li><kbd>native2ascii</kbd></li>
</ul>
<p>Two additional things that have been removed in Java 9 are:</p>
<ul>
<li>AppleScript engine. This engine was deemed as unusable and is dropped without replacement.</li>
<li>Windows 32-bit client virtual machine. JDK 9 does support a 32-bit server JVM, but not a 32-bit client VM. This change was made to focus on the increased performance of 64-bit systems.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updated garbage collection</h1>
                </header>
            
            <article>
                
<p>Garbage collection has been one of Java's great claims to fame. In Java 9, the <strong>Garbage-First</strong> (<strong>G1</strong>) garbage collector is now the default garbage collector on both 32- and 64-bit servers. In Java 8, the default garbage collector was the parallel garbage collector. Oracle reports that there are three garbage collection combinations that will prohibit your application from starting in Java 9. Those combinations are:</p>
<ul>
<li>DefNew + CMS</li>
<li>Incremental CMS</li>
<li>ParNew + SerialOld</li>
</ul>
<p>We will take an in-depth look at Java 9 garbage collection in <a href="d29f6411-3e8f-4bd3-8ee9-1dc0314d8e75.xhtml" target="_blank">Chapter 7</a>, <em>Leveraging the New Default G1 Garbage Collector</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>There are three issues that you should be aware of, in the context of migrating to Java 9, when you are deploying your applications. These issues are JRE version selection, serialized applets, and the update to the JNLP.</p>
<div class="packt_infobox"><strong>JNLP</strong> is the acronym for <strong>Java Network Launch Protocol</strong> and is covered in a later section of this chapter.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JRE version selection</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, developers could request a JRE version other than the version being launched when launching an application. This could be accomplished with a command-line option or with a proper JAR file manifest configuration. This feature has been removed in JDK 9 because of the way we typically deploy applications. Here are the three primary methods:</p>
<ul>
<li>Active installers</li>
<li><strong>Java Web Start</strong> using JNLP</li>
<li>Native OS packaging systems</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Serialized applets</h1>
                </header>
            
            <article>
                
<p>Java 9 does not support the ability to deploy applets as serialized objects. In the past, applets were deployed as serialized objects to compensate for slow compression and JVM performance issues. With Java 9, compression techniques are advanced and the JVM has great performance.</p>
<p>If you attempt to deploy your applets as serialized objects, your object attributes and parameter tags will simply be ignored when your applet launches. Starting with Java 9, you can deploy your applets using standard deployment strategies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JNLP update</h1>
                </header>
            
            <article>
                
<p>The JNLP is used for launching applications on a desktop client using resources located on a web server. JNLP clients include Java Web Start and Java Plug-in software because they are able to launch applets that are remotely hosted. This protocol is instrumental in launching RIAs.</p>
<p><strong>RIAs</strong> are <strong>Rich Internet Applications</strong> and when launched with JNLP have access to the various JNLP APIs that, with user permission, can access the user's desktop.</p>
<p>In Java 9, the JNLP specification has been updated. There are four specific updates as detailed in the next sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nested resources</h1>
                </header>
            
            <article>
                
<p>The ability to use component extensions with nest resources in Java or j2se elements was previously supported, but not documented in the specification. The specification has now been updated to reflect this support. The previous specification read:</p>
<div class="packt_quote"><span>No java elements can be specified as part of the resources.</span></div>
<p>The updated specification for Java 9 now reads:</p>
<div class="packt_quote"><span>A java element in a component extension will not govern what version of java is used, but may be used containing nested resource elements, and then those resources may be used only when using a Java version that matches the given version as specified in section 4.6</span></div>
<p>This specific change ensures that extension JLP files must have <kbd>java</kbd> or <kbd>j2se</kbd> resources and those resources will not dictate what JRE is used. Nested resources are permitted when using the specified version.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">FX XML extension</h1>
                </header>
            
            <article>
                
<p>When using the <span>JNLP</span>, you create a JNLP file. Here is an example:</p>
<pre class="mce-root">    &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>    &lt;jnlp spec="1.0+" codebase="" href=""&gt;<br/>      &lt;information&gt;<br/>        &lt;title&gt;Sample/title&gt;<br/>        &lt;vendor&gt;The Sample Vendor&lt;/vendor&gt;<br/>        &lt;icon href="sample-icon.jpg"/&gt;<br/>        &lt;offline-allowed/&gt;<br/>     &lt;/information&gt;<br/>     &lt;resources&gt;<br/>       &lt;!-- Application Resources --&gt;<br/>       &lt;j2se version="1.6+"  <br/>        href="http://java.sun.com/products/autodl/j2se"/&gt;<br/>       &lt;jar href="Sample-Set.jar" main="true" /&gt;<br/>     &lt;/resources&gt;<br/>     &lt;application-desc<br/>       name="Sample Application"<br/>       main-class="com.vendor.SampleApplication" <br/>       width="800" <br/>       height="500"&gt;<br/>       &lt;argument&gt;Arg1&lt;/argument&gt;<br/>       &lt;argument&gt;Arg2&lt;/argument&gt;<br/>       &lt;argument&gt;Arg3&lt;/argument&gt;<br/>     &lt;/application-desc&gt;<br/>     &lt;update check="background"/&gt;<br/>    &lt;/jnlp&gt;</pre>
<p>Two changes have been made to the <kbd>&lt;application-desc&gt;</kbd> element. First, the optional <kbd>type</kbd> attribute has been added so the type of application can be annotated. The default type is <kbd>Java</kbd>, so if your program is a Java app, you need not include the <kbd>type</kbd> attribute. Alternatively, you can specify <kbd>Java</kbd> as your type as follows:</p>
<pre>    &lt;application-desc <br/>      name="Another Sample Application"<br/>      type="Java" main-class="com.vendor.SampleApplication2" <br/>      width="800" <br/>      height="500"&gt;<br/>      &lt;argument&gt;Arg1&lt;/argument&gt;<br/>      &lt;argument&gt;Arg2&lt;/argument&gt;<br/>      &lt;argument&gt;Arg3&lt;/argument&gt;<br/>    &lt;/application-desc&gt;</pre>
<p>We can indicate other application types to include <kbd>JavaFX</kbd> as shown here:</p>
<pre>    &lt;application-desc <br/>      name="A Great JavaFX Application"<br/>      type="JavaFX" main-class="com.vendor.GreatJavaFXApplication" <br/>      width="800" <br/>      height="500"&gt;<br/>      &lt;argument&gt;Arg1&lt;/argument&gt;<br/>      &lt;argument&gt;Arg2&lt;/argument&gt;<br/>      &lt;argument&gt;Arg3&lt;/argument&gt;<br/>    &lt;/application-desc&gt;</pre>
<div class="packt_tip">If you indicate an application type that is not supported by the JNLP client, your application launch will fail. For more information about JNLP, you can consult the official documentation: <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html">http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html</a>.<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/javaws/developersguide/faq.html"/></div>
<p>The second change to the <kbd>&lt;application-desc&gt;</kbd> element in Java 9 is the addition of the <kbd>param</kbd> sub-element. This allows us to provide the name of parameters along with their value using the <kbd>value</kbd> attribute. Here is an example of how an <kbd>&lt;application-desc&gt;</kbd> element of a JNLP file looks with the <kbd>param</kbd> sub-element and the <kbd>value</kbd> attribute included. This example shows three sets of parameters:</p>
<pre>    &lt;application-desc<br/>      name="My JRuby Application"<br/>      type="JRuby"<br/>      main-class="com.vendor.JRubyApplication" <br/>      width="800" <br/>      height="500"&gt;<br/>      &lt;argument&gt;Arg1&lt;/argument&gt;<br/>      &lt;argument&gt;Arg2&lt;/argument&gt;<br/>      &lt;argument&gt;Arg3&lt;/argument&gt;<br/>      &lt;param name="Parameter1" value="Value1"/&gt;<br/>      &lt;param name="Parameter2" value="Value2"/&gt;<br/>      &lt;param name="Parameter3" value="Value3"/&gt;<br/>    &lt;/application-desc&gt;</pre>
<div class="packt_infobox">If the application <kbd>type</kbd> is Java, then any <kbd>param</kbd> sub-elements you use will be ignored.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JNLP file syntax</h1>
                </header>
            
            <article>
                
<p>JNLP file syntax is now in complete compliance with XML specifications. Prior to Java 9, you could use <kbd>&amp;</kbd> to create complex comparisons. That is not supported with standard XML. You can still create complex comparisons in JNLP files. Now you will use <kbd>&amp;amp;</kbd> instead of <kbd>&amp;</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Numeric version comparison</h1>
                </header>
            
            <article>
                
<p>The JNLP specification has been changed to reflect how numeric version elements were compared against non-numeric version elements. Previous to the change, version elements were compared lexicographically by ASCII value. With Java 9 and this JNLP specification change, elements are still compared lexicographically by ASCII value. The change is evident when the two strings have different lengths. In new comparisons, the shorter string will be padded with leading zeros to match the length of the longer string.</p>
<div class="packt_infobox">Lexicographical comparisons use a mathematical model that is based on alphabetical order.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Useful tools</h1>
                </header>
            
            <article>
                
<p>The first thing you will need to do before migrating your applications to Java 9 is to download JDK 9. You can download the early access builds at this URL--<a href="http://jdk.java.net/9/">http://jdk.java.net/9/</a>. You will need to accept the license agreement and then select which build to download. As you can see in the following screenshot, there are several options based on your operating system:</p>
<div class="CDPAlignCenter CDPAlign"><img height="243" width="475" src="assets/7507f25b-438a-4b0d-83de-7175d486d28d.png"/></div>
<p>Now that you have JDK 9 installed on your development computer, let's look at a couple of tools that can help facilitate migrating your applications to Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Java environment - jEnv</h1>
                </header>
            
            <article>
                
<p>If you develop on a computer with Linux or macOS, you might consider using <kbd>jEnv</kbd>, an open source Java environment management tool. This is a command-line tool, so do not expect a GUI. You can download the tool at this URL--<a href="https://github.com/gcuisinier/jenv">https://github.com/gcuisinier/jenv</a>.<a href="https://github.com/gcuisinier/jenv"/></p>
<p>Here is the installation command for Linux:</p>
<pre><strong>$ git clone https://github.com/gcuisinier/jenv.git ~/.jenv</strong></pre>
<p>To download using macOS with Homebrew, use this command:</p>
<pre><strong>$ brew install jenv</strong></pre>
<p>You can also install on Linux or macOS using <kbd>Bash</kbd> as follows:</p>
<pre><strong>$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profile</strong><br/><strong>$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile</strong></pre>
<p>Alternatively, you can install on Linux or macOS using <kbd>Zsh</kbd> as follows:</p>
<pre><strong>$ echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.zshrc</strong><br/><strong>$ echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zshrc</strong></pre>
<p>After you have <kbd>jEnv</kbd> installed, you will need to configure it on your system as shown here. You will need to modify the script to reflect your actual path:</p>
<pre><strong>$ jenv add /Library/Java/JavaVirtualMachines/jdk17011.jdk/Contents/Home</strong></pre>
<p>You will want to repeat the <kbd>jenv add</kbd> command for each version of the JDK on your system. With each <kbd>jenv add</kbd> command, you will receive confirmation that the specific JDK version was added to <kbd>jEnv</kbd> as follows:</p>
<div class="span9">
<pre class="code"><strong>$ jenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
  oracle64-1.6.0.39 added
$ jenv add /Library/Java/JavaVirtualMachines/jdk17011.jdk/Contents/Home
  oracle64-1.7.0.11 added</strong></pre></div>
<p>You can check to see what JDK versions you have added to your <kbd>jEnv</kbd> by using <kbd>$ jenv versions</kbd> at the Command Prompt. This will result in an output list.</p>
<p>Here are three additional <kbd>jEnv</kbd> commands:</p>
<ul>
<li><kbd>jenv global &lt;version&gt;</kbd>: this sets the global version</li>
<li><kbd>jenv local &lt;version&gt;</kbd>: this sets the local version</li>
<li><kbd>jenv shell &lt;version&gt;</kbd>: this sets the instance version for the shell</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Maven</h1>
                </header>
            
            <article>
                
<p>Maven is an open source tool that can be used for building and managing Java-based projects. It already supports Java 9 and is part of the <em>Apache Maven Project</em>. If you are not already using Maven and you do a lot of Java development you might be enticed by the following Maven objectives:</p>
<ul>
<li>Making the build process easy</li>
<li>Providing a uniform build system</li>
<li>Providing quality project information</li>
<li>Providing guidelines for best practices development</li>
<li>Allowing transparent migration to new features</li>
</ul>
<p>You can read more specifics about each of the Maven objectives at this site--<a href="https://maven.apache.org/what-is-maven.html">https://maven.apache.org/what-is-maven.html</a>. To download Maven, visit this site--<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>. Installation instructions for Windows, macOS, Linux, and Solaris are available here--<a href="https://maven.apache.org/install.html">https://maven.apache.org/install.html</a>.</p>
<p>Maven can be integrated with Eclipse (M2Eclipse), JetBrains IntelliJ IDEA, and the Netbeans IDE. The M2Eclipse IDE, as an example, provides rich integration with Apache Maven and boasts the following features:</p>
<ul>
<li>You can launch Maven builds from within Eclipse</li>
<li>Manage your dependencies for the Eclipse build path</li>
<li>Easily resolve Maven dependencies (you can do this directly from Eclipse and not have to install a local Maven repository)</li>
<li>Automatically download required dependencies (from remote Maven repositories)</li>
<li>Use software wizards to create new Maven projects, create <kbd>pom.xml</kbd> files, and to enable Maven support for your plain Java projects</li>
<li>Rapid dependency search of Maven remote repositories</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Obtaining the M2Eclipse IDE</h1>
                </header>
            
            <article>
                
<p>To obtain the M2Eclipse IDE, you must first have Eclipse installed. Here are the steps:</p>
<ol>
<li>Start by opening your current Eclipse IDE. Next, select <span class="packt_screen">Preferences</span> | <span class="packt_screen">Install/Update</span> | <span class="packt_screen">Available Software Sites</span> as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="461" width="676" src="assets/7f69ad92-4013-4224-9d5a-23b2338ec88b.png"/></div>
<ol start="2">
<li>The next task is to add the M2Eclipse repository site to your list of <span class="packt_screen">Available Software Sites</span>. To accomplish this, click the <span class="packt_screen">Add</span> button and enter values in the <span class="packt_screen">Name</span> and <span class="packt_screen">Location</span> text input boxes. For <span class="packt_screen">Name</span>, enter something to help you remember that M2Eclipse is available at this site. For <span class="packt_screen">Location</span>, enter the URL--<kbd>http://download.eclipse.org/technology/m2e/releases</kbd>. Then, click the <span class="packt_screen">OK</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="124" width="336" src="assets/14158242-e84c-4793-8764-6c47ab9bad73.png"/></div>
<ol start="3">
<li>You should now see the <span class="packt_screen">M2Eclipse</span> site listed in your list of <span class="packt_screen">Available Software Sites</span> as shown in the following screenshot. Your final step is to click the <span class="packt_screen">OK</span> button:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="308" width="452" src="assets/b9a4b28f-f954-4a32-b675-5297cdb5fd85.png"/></div>
<ol start="4">
<li>Now, when you start a new project, you will see <kbd>Maven Project</kbd> as an option:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img height="407" width="427" src="assets/3a6add9c-c10f-431a-88ae-98f5e2a1fed8.png"/></div>
<p>Maven is a proven tool for Java developers. You might consider obtaining additional information on Maven with one of the following resources:</p>
<ul>
<li><em>Apache Maven Project</em>: <a href="https://maven.apache.org/index.html">https://maven.apache.org/index.html</a></li>
<li><em>Apache Maven Cookbook</em>: <a href="https://www.packtpub.com/application-development/apache-maven-cookbook">https://www.packtpub.com/application-development/apache-maven-cookbook</a></li>
<li><em>Apache Maven 3.o Cookbook</em>: <a href="https://www.packtpub.com/application-development/apache-maven-3-cookbook">https://www.packtpub.com/application-development/apache-maven-3-cookbook</a></li>
<li><em>Getting Started with Apache Maven [Video]</em>: <a href="https://www.packtpub.com/application-development/getting-started-apache-maven-video">https://www.packtpub.com/application-development/getting-started-apache-maven-video</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored potential issues involved in migrating our existing applications to the Java 9 platform. We looked at both manual and semi-automated migration processes. This chapter provided you with insights and processes to get your Java 8 code working with Java 9. Specifically, we conducted a q<span>uick review of Project Jigsaw, looked at how modules fit into the Java landscape, provided tips for</span> migration <span>planning, shared advice from</span> Oracle <span>regarding migration, and shared tools that you can use to help you as you get started with Java 9.</span></p>
<p>In the next chapter, we will take a close look at the Java shell and the JShell API. We demonstrate the JShell API and the JShell tool's ability to interactively evaluate declarations, statements, and expressions of the Java programming language. We will demonstrate features and use of this command-line tool.</p>


            </article>

            
        </section>
    </body></html>