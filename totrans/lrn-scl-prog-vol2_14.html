<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing in Scala</h1>
                
            
            <article>
                
<div class="packt_quote">"Change is the end result of all the true learning."</div>
<div class="packt_quote1">- Leo Buscaglia</div>
<p class="calibre2">Software development is an ever transforming process. We have seen in recent decades that many patterns have been discovered/rediscovered. These programming techniques/paradigms have become an important part and have changed the way we approach programming. One of them is <strong class="calibre1">Test-Driven Development </strong>(<strong class="calibre1">TDD</strong>). In the TDD approach, we first specify the requirement for our application through new tests. Then, one by one, we write concrete code to pass all those tests. In this manner, we complete our requirements by writing new test cases, implementing code to pass them, and end up building an application that runs as expected. Scala provides many frameworks for testing (for example, <strong class="calibre1">ScalaTest</strong><em class="calibre18">,</em> <strong class="calibre1">Specs2</strong>, and so on) and <span>we have </span><strong class="calibre1">Mockito</strong><span> and </span><strong class="calibre1">ScalaMock</strong><em class="calibre18"> </em>for mocking objects<em class="calibre18">.</em> Testing, in a way, is a small concept with a vast number of explanations possible. In this chapter, we'll focus on understanding the TDD approach and the way we can follow this approach to successfully apply it in Scala. For that, we'll go through:</p>
<ul class="calibre7">
<li class="calibre8">The why and what of TDD
<ul class="calibre28">
<li class="calibre8">The process of TDD</li>
<li class="calibre8"><strong class="calibre1">Behavior-driven development</strong> (<strong class="calibre1">BDD</strong>)</li>
</ul>
</li>
<li class="calibre8">ScalaTest</li>
<li class="calibre8">ScalaCheck</li>
</ul>
<p class="calibre2">So, let's start with why this rocket called TDD is flying so high in the software development space nowadays.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The why and what of TDD</h1>
                
            
            <article>
                
<p class="calibre2">To write expected and well-designed software, we tend to clarify the requirements before starting the development process. With agile practices in place, we translate our requirements to what we call user/functional stories. Transforming these stories into a simple specification of what we're going to implement adds an advantage. That's where writing test cases comes in handy. We specify our program's behavior in the form of test cases and then implement those behaviors.</p>
<p class="calibre2">There are some advantages to this approach. Writing test cases first and then providing the implementation drives the design of our program. It means that as we approach toward implementing the behavior, we can think of our design and code for that. If one of your classes, <kbd class="calibre11">A</kbd>, is dependent on another class, <kbd class="calibre11">B</kbd>, we can make sure that <em class="calibre18">B</em> is injected into <em class="calibre18">A.</em> In a way, we can make it a practice to follow these ways, for example, inject dependencies from other classes. Apart from driving the design of your application, TDD also helps us think about the use cases and the way in which users of our application might use it. It helps us think clearly about the interface the user is going to get so that we can code accordingly.</p>
<p class="calibre2">In TDD, just because we tend to write test cases first, we cover almost all lines of our software implementation. This provides automatic code coverage to us. Let's take a look at the process of TDD.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The process of TDD</h1>
                
            
            <article>
                
<p class="calibre2">As per the approach, we can break down the process of TDD into the following steps. The process can be included in your development workflow:</p>
<ol class="calibre13">
<li value="1" class="calibre8">Write a test that will fail.</li>
<li value="2" class="calibre8">Write some code to pass the failing test.</li>
<li value="3" class="calibre8">Refactor your code to improve quality without any changes in the behavior.</li>
<li value="4" class="calibre8">Repeat <em class="calibre18">steps 1</em> to <em class="calibre18">3.</em></li>
</ol>
<p class="calibre2">We broke down the process into these steps. Let's take a look at each of these steps to better understand the reasoning behind each of these.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step 1 - write a test that will fail</h1>
                
            
            <article>
                
<p class="calibre2">Writing to fail is not something we feel confident about, but that's how TDD works. After we've determined what's needed from our application and are sure about a certain functionality, we can write a test case for functionality in the way we want it to work. We want to make sure that we run this test case and that it fails. The failure of our test case is expected because we have not implemented any code yet to make it successful. The initial failure we mean<span> is step one of TDD.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step 2 - write code to pass the failing test</h1>
                
            
            <article>
                
<p class="calibre2">The best thing about this step is to know <span>how we have to pass a failing test case</span>. For that, we'll implement a functionality. In this step, we'll have to write some code. We can try to implement a function, not in the best way possible, but enough to pass the failing test. Passing a test guarantees the particular behavior of a functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step 3 - refactor the code to improve the quality</h1>
                
            
            <article>
                
<p class="calibre2">Now that we are confident that our functionality is working, we can go ahead and improve the code quality. If the functionality isn't too big, then this step can be a part of the previous one. It's logical to have a review of our code once the functionality is working. This might improve the quality of our code. After the refactor, we should ensure that the feature/functionality is in a working state and is intact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Step 4 - repeat steps 1 to 3</h1>
                
            
            <article>
                
<p class="calibre2">Now, for this particular functionality, for which we wrote test cases and implemented code, we have ensured <span>t</span><span>hat </span>it's working and <span>t</span><span>he </span>code quality is proper. We are done with this particular feature/functionality and now can write another test case and repeat the process steps.</p>
<p class="calibre2">We can visualize <span>t</span><span>he working of TDD</span> as follows:</p>
<div class="cdpaligncenter"><img src="../images/00076.jpeg" class="calibre82"/></div>
<p class="calibre2">From the previous diagram, it's clear that TDD is a repetitive process, where you specify a use case and write code for it.</p>
<p class="calibre2">One of the benefits of TDD is that our tests serve as a documentation. Library/framework developers tend to write test cases <span>t</span><span>hat</span> serve <span>t</span><span>he</span> purpose of documentation too. How? By making use of DSL or, let's say, English-like sentences for designing our test suites. A test suite consists of multiple test cases for our program. Let's take a look at the scenario we have used in a couple of our chapters. The example we will be using is where we will read Football player's data from a CSV file named <kbd class="calibre11">football.csv</kbd>, convert those to <kbd class="calibre11">Player</kbd> objects, and further use the data to display the player's information or perform some analytics based on the information. How would we want to proceed with the test cases for such a scenario, or at least, how should it look when we say "English-like sentences" for our specifications?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Scenario</h1>
                
            
            <article>
                
<p class="calibre2">Read the player data and showcase that on the console:</p>
<pre class="calibre19">"PlayerService" should { 
    "return a Player object." in {//some code} 
    "return an empty collection if there's no data." in {//some code} 
    "return a Nothing on call to getPlayer method with right player string." in {//some code} 
    "return a Some Player instance on call to getPlayer method with right player string." in {//some code} 
    "print a Player's information on console." in {//some code} 
} </pre>
<p class="calibre2">In the given example scenario, we specified a service and named it <kbd class="calibre11">PlayerService</kbd>. Now, this service should have the methods that perform the specified cases. These cases are not too complicated, but each case expects our service to provide a simple functionality. This example is for explanation purposes, since we've already seen the code. We'll also try and implement the same using the TDD approach.</p>
<p class="calibre2">The point worth nothing about the preceding test specification is that before even trying to code, we are sure about certain things:</p>
<ul class="calibre7">
<li class="calibre8">There should be a <kbd class="calibre11">PlayerService</kbd> service.</li>
<li class="calibre8">In <kbd class="calibre11">PlayerService</kbd><em class="calibre18">,</em> we should have a <kbd class="calibre11">Player</kbd> entity<em class="calibre18">.</em></li>
<li class="calibre8">In <kbd class="calibre11">PlayerService</kbd><em class="calibre18">,</em> we should have a functionality to read the player's data. It has to be a collection; when the source can't be read or the source contains no data, the functionality should return an empty collection.</li>
<li class="calibre8">In <kbd class="calibre11">PlayerService</kbd><em class="calibre18">,</em> there should be a <kbd class="calibre11">getPlayer</kbd> functionality that expects us to provide some data to it and return a concrete <kbd class="calibre11">Player</kbd> entity. When we provide wrong data (as in the format), the functionality doesn't throw an exception, but specifies that it couldn't create a concrete <kbd class="calibre11">Player</kbd> entity.</li>
<li class="calibre8">In <kbd class="calibre11">PlayerService</kbd><em class="calibre18">,</em> there should be a <kbd class="calibre11">getPlayer</kbd> functionality which expects us to provide some data to it and return a concrete <em class="calibre18">Player</em> entity on receiving correct data.</li>
<li class="calibre8">In <kbd class="calibre11">PlayerService</kbd><em class="calibre18">,</em> there should be a <kbd class="calibre11">showPlayers</kbd> functionality which expects us to provide a collection of <kbd class="calibre11">Player</kbd> entities and print the player's information on the console.</li>
</ul>
<p class="calibre2">The fact that the preceding points and specifications we mentioned are similar in semantic meaning and that we can use one of these to write test cases makes TDD fun. These test specifications are too close to real-world test specs that we'll be writing. Take a closer look at the specification we just described; nowhere does it state about the programming language choice we had to make. We didn't get any hint about the language specifications, so these test cases will work in any language if the programming language we use can support such <strong class="calibre1">domain-specific language</strong> (<strong class="calibre1">DSL</strong>) lookalike mechanisms.</p>
<p class="calibre2">This specification does not limit you to write test cases only in a specified format, but you can choose your own style of writing them. This is one of the conventions that emerged from TDD, and it's called <strong class="calibre1">behavior-driven development</strong> (<strong class="calibre1">BDD</strong>). This term BDD drives itself by specifying behaviors in order to start the development of any functionality. It also serves as documentation to our program. If you see the specification we wrote, in a way, we documented the way we can use functionalities. If these specs were written in Scala, we could have provided the method names according to the functionalities.</p>
<p class="calibre2">Let's discuss a bit about this way of driving development by specifying the behaviors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Behavior driven development (BDD)</h1>
                
            
            <article>
                
<p class="calibre2">We already saw the <em class="calibre18">should ... in</em> way of specifying the behavior of our functionality. There are other ways to specify the behaviors, or let's say, ensure the validity of our functionality. One of the example is <em class="calibre18">given</em><em class="calibre18">... when</em><em class="calibre18">... then</em><em class="calibre18">....</em></p>
<p class="calibre2">Here, we specify the following:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">Given</strong>: This is what is available at the time of executing some functionality</li>
<li class="calibre8"><strong class="calibre1">When</strong><em class="calibre18">:</em> We confront a condition that is based on the data that's given</li>
<li class="calibre8"><strong class="calibre1">Then</strong><em class="calibre18">:</em> Execute the part which is expected to happen</li>
</ul>
<p class="calibre2">In this way, we validate the behavior of our functionality. One of the best practices when we write test cases for one of the functionalities is to specify all the possible scenarios (ideally, that's not possible, but we try our best to include all possibilities we can think of). These scenarios include the <em class="calibre18">empty case</em>, <em class="calibre18">unit case</em>, and <em class="calibre18">failure case</em>. Finally, we cover all the conditional possibilities. With these, we ensure the specifications are valid and that our implementations are too. These specifications serve as acceptance criteria for our functionality. There are lesser chances of you slipping past some important case. It's important to know that there's no hard and fast rule to describe our test cases.</p>
<p class="calibre2">One of the benefits of behavior-driven development is that instead of talking in terms of tests, we talk in terms of specifications or scenarios. Hence, not just developers, but most of the business stakeholders and domain experts can also specify the requirements for an application.</p>
<p class="calibre2">Now, talking about Scala's offering for frameworks or toolkits provided for testing, there are a bunch of them. <strong class="calibre1">ScalaTest</strong>, <strong class="calibre1">ScalaCheck</strong>, and <strong class="calibre1">Specs2</strong> are a few that developers are using to write tests for their code. We'll go through one of the mostly widely used testing tools, ScalaTest, and try to see the way specs are implemented using examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ScalaTest</h1>
                
            
            <article>
                
<p class="calibre2">ScalaTest, as we mentioned, is famous for multiple styles provided to write specifications. Not just multiple styles, this kit also serves as a testing tool for <strong class="calibre1">Scala.js</strong> and even Java classes. ScalaTest covers most of the Scala ecosystem and allows you to choose different ways to write specifications based on the behavior of your functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up for testing</h1>
                
            
            <article>
                
<p class="calibre2">To use ScalaTest, let's go through some of the basic steps. We can create a fresh SBT project and add a dependency for <strong class="calibre1">ScalaTest</strong> via the <kbd class="calibre11">build.sbt</kbd> file or use Lightbend's tech hub to download a simple Scala project. Let's try out the second approach as it'll give us ScalaTest already added as a dependency in our <kbd class="calibre11">build.sbt</kbd> file. Let's follow these steps:</p>
<ol class="calibre13">
<li value="1" class="calibre8">In your favorite browser, open: <a href="https://developer.lightbend.com" class="calibre10">https://developer.lightbend.com</a>.</li>
<li value="2" class="calibre8">Click on the <span>START A PROJECT</span> button:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00077.jpeg" class="calibre83"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Choose <span>Scala</span> from project types:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00078.jpeg" class="calibre84"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre8">You can name the project and click on <span>CREATE A PROJECT FOR ME!</span><em class="calibre18">:</em></li>
</ol>
<div class="cdpaligncenter"><img src="../images/00079.jpeg" class="calibre85"/></div>
<p class="calibre37">This will download a compressed file for you with the name you specified. Extract the compressed file to a specific location and open it in the IntelliJ IDE.</p>
<p class="calibre2">We can open <kbd class="calibre11">build.sbt</kbd> to check the dependencies and project settings specified. Our <kbd class="calibre11">sbtbuild</kbd> file should look like as follows:</p>
<pre class="calibre19">import Dependencies._ 
 
lazy val root = (project in file(".")). 
  settings( 
    inThisBuild(List( 
      organization := "com.example", 
      scalaVersion := "2.12.4", 
      version      := "0.1.0-SNAPSHOT" 
    )), 
    name := "Hello", 
    libraryDependencies += scalaTest % Test 
  ) </pre>
<p class="cdpalignleft1">Here, in the <kbd class="calibre11">libraryDependencies</kbd> settings, <kbd class="calibre11">scalaTest</kbd> is specified. Hence, we can use that. The sample project comes with some source code and test covering it. So, we'll first try to run the test case. If you can see the <kbd class="calibre11">scalatest</kbd> library in the external dependencies directory, as shown in the following diagram, then we're ready to execute tests:</p>
<div class="cdpaligncenter"><img src="../images/00080.jpeg" class="calibre86"/></div>
<p class="calibre2">If these libraries are not shown in your project structure, we can fire the <kbd class="calibre11">sbt update</kbd> command so that SBT can download all the dependencies specified. There're a few more SBT commands that we will use to run our test cases. Let's take a look at them:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">sbt test</kbd>: SBT assumes that test sources for Scala are located in the <kbd class="calibre11">src/test/scala</kbd> directory and resources like the configurations for test sources are located in the <kbd class="calibre11">src/test/resources</kbd> directory</li>
</ul>
<p class="calibre87">Based on previously described assumptions, when we fire a command described in the preceding text, SBT compiles all test files present in the respective locations and tests all of them. What if you're only concerned about specific test cases?</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">sbt testOnly</kbd>: Based on similar assumptions that we had for the <kbd class="calibre11">sbt test</kbd> command, when we fire the <kbd class="calibre11">testOnly</kbd> command, SBT compiles and tests only test cases that we specified along with the command. Consider the following example:</li>
</ul>
<pre class="calibre19">        sbt testOnly example.HelloSpec</pre>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">sbt testQuick</kbd>: Based on similar assumptions that we had for the <kbd class="calibre11">sbt test</kbd> command, when we fire the <kbd class="calibre11">testQuick</kbd> <span>command, </span>SBT compiles and tests only those test cases that fulfil the following conditions:
<ul class="calibre28">
<li class="calibre8">Failing tests from the previous runs</li>
<li class="calibre8">Tests that have not run yet</li>
<li class="calibre8">Tests with transitive dependencies</li>
</ul>
</li>
</ul>
<p class="calibre2">These are a few Scala commands we use to test our cases. Also, while testing our specs, we'll use triggered execution. We initiate triggered execution by putting <kbd class="calibre11">~</kbd> before our test command. With this, SBT expects a save change, and saving the file again triggers a test execution. So with this, try out this command, assuming that we have the SBT shell opened (open the project directory, where <kbd class="calibre11">build.sbt</kbd> is located and the trigger <kbd class="calibre11">sbt</kbd> command) in the command prompt of our choice. Let's locate our project in the SBT shell and fire the following command:</p>
<div class="cdpaligncenter"><img src="../images/00081.jpeg" class="calibre88"/></div>
<p class="calibre2">There's this <kbd class="calibre11">HelloSpec</kbd> class<em class="calibre18">,</em> located in the test directory of the project we downloaded. If everything works right, as it should, we'll get our tests passed and you'll start loving the <em class="calibre18">green</em> color. But if the code is red, this means it has failed. So, we're ready to delve into <kbd class="calibre11">ScalaTest</kbd><em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing in style using ScalaTest</h1>
                
            
            <article>
                
<p class="calibre2">We've tested the <kbd class="calibre11">HelloSpec</kbd> class<em class="calibre18">,</em> so we'll take a look at the test, and the way it's written. So, we can open the file <kbd class="calibre11">Hello</kbd> located in <kbd class="calibre11">src/test/scala/example</kbd><em class="calibre18">.</em> The source code looks as follows:</p>
<pre class="calibre19">package example 
 
import org.scalatest._ 
 
 
class HelloSpec extends FlatSpec with Matchers { 
  "The Hello object" should "say hello" in { 
    Hello.greeting shouldEqual "hello" 
  } 
} </pre>
<p class="calibre2">Taking a look at the code sample, we can observe a few points:</p>
<ul class="calibre7">
<li class="calibre8">We've imported <kbd class="calibre11">org.scalatest._</kbd> to bring all the traits we want to use.</li>
<li class="calibre8">The class definition named <kbd class="calibre11">HelloSpec</kbd> extends <kbd class="calibre11">FlatSpec</kbd> along with the mix-in <kbd class="calibre11">Matchers</kbd> class. It's a convention to name our test specifications as class name followed by <kbd class="calibre11">Spec</kbd>.</li>
<li class="calibre8">The definition consists of only one <em class="calibre18">specification.</em> The specification states that "<span>there's an object named Hello that says hello in the specified code snippet</span>". That's how cool it is—the specification is written in a way any English sentence can be written.</li>
<li class="calibre8">The specification is written in a DSL-like manner. The language looks natural, and further down, the specification states that there's going to be a method call that returns a string equal to <kbd class="calibre11">hello</kbd>.</li>
<li class="calibre8">The call to <kbd class="calibre11">shouldEqual</kbd> is a <kbd class="calibre11">Matcher</kbd><em class="calibre18">.</em> The job of a <kbd class="calibre11">Matcher</kbd> is to match the left operand with the right operand. There are several other ways to write such <kbd class="calibre11">Matchers</kbd>, but we'll talk about those in subsequent sections.</li>
</ul>
<p class="calibre2">That's very simple and everything's good till now. Now, let's take a look at the corresponding code file written in the location <kbd class="calibre11">src/main/scala/example</kbd><em class="calibre18">.</em> Let's look at the file named <kbd class="calibre11">Hello.scala</kbd>:</p>
<pre class="calibre19">package example 
 
object Hello extends Greeting with App { 
  println(greeting) 
} 
 
trait Greeting { 
  lazy val greeting: String = "hello" 
} </pre>
<p class="calibre2">There's this object named <kbd class="calibre11">Hello</kbd> according to our specification. We can make a call to <kbd class="calibre11">greeting</kbd><em class="calibre18">,</em> which does nothing but print this string, <kbd class="calibre11">hello</kbd><em class="calibre18">.</em> Well, this example was already available for us to observe, hence we didn't follow TDD. But we'll try writing something similar to this using the <em class="calibre18">test first approach</em> by specifying the behavior.</p>
<p class="calibre2">Before writing the first spec on our own, let's follow some convention or one of the good practices and create an abstract class that extends <kbd class="calibre11">FlatSpec</kbd>  with <kbd class="calibre11">Matchers</kbd> by default so that we don't have to extend those in every spec we write. We can do this by creating a spec file, and let's name it <kbd class="calibre11">SomeSpec</kbd> and save it in the <kbd class="calibre11">src/test/scala/example/</kbd> directory. It should look like this:</p>
<pre class="calibre19">package example 
 
import org.scalatest._ 
 
abstract class SomeSpec(toBeTested: String) extends FlatSpec with Matchers </pre>
<p class="calibre2">Now that we've created some abstract class that extends the <kbd class="calibre11">FlatSpec</kbd> and <kbd class="calibre11">Matchers</kbd> classes, we are ready to follow our first step in TDD to write one failing test spec. Our <kbd class="calibre11">SomeSpec</kbd> abstract class takes a parameter named <kbd class="calibre11">toBeTested</kbd>, which is nothing but the name of the functionality.</p>
<p class="calibre2">Let's create another test spec, name it <kbd class="calibre11">PlayerSpec</kbd>, and save it as <kbd class="calibre11">src/test/scala/example</kbd>:</p>
<pre class="calibre19">package example 
 
class PlayerSpec extends SomeSpec("PlayerService") { 
 
  it should "compile" in { 
  """PlayerService.Player("Cristiano Ronaldo", "Portuguese", 32, "Real Madrid")""" should compile 
  } 
 
 
} </pre>
<p class="calibre2">The preceding test spec is written in DSL. The <kbd class="calibre11">it</kbd> keyword corresponds to the argument we passed to <kbd class="calibre11">SomeSpec</kbd><em class="calibre18">.</em> In our case, it's the functionality under test, that is, <kbd class="calibre11">PlayerService</kbd>. So the spec states the code snippet compiles, that is, we can create <kbd class="calibre11">Player</kbd> instances<em class="calibre18">.</em> When we try to run the test case, it's going to fail as expected, because we have not written the  <kbd class="calibre11">Player</kbd> class till now:</p>
<pre class="calibre19">&gt; testOnly example.PlayerSpec 
[info] PlayerSpec: 
[info] - should compile *** FAILED *** 
[info] Expected no compiler error, but got the following type error: "not found: value Player", for code: Player("Cristiano Ronaldo", "Portuguese", 32, "Real Madrid") (PlayerSpec.scala:6) 
[info] Run completed in 281 milliseconds. 
[info] Total number of tests run: 1 
[info] Suites: completed 1, aborted 0 
[info] Tests: succeeded 0, failed 1, canceled 0, ignored 0, pending 0 
[info] *** 1 TEST FAILED *** 
[error] Failed tests: 
[error]  example.PlayerSpec 
[error] (test:testOnly) sbt.TestsFailedException: Tests unsuccessful </pre>
<p class="calibre2">Let's write the Player case class:</p>
<pre class="calibre19">// src/main/scala/example/PlayerService.scala<br class="title-page-name"/><br class="title-page-name"/>object PlayerService extends App { 
 
 
  case class Player(name: String, nationality: String, age: Int, league: String) 
 
} </pre>
<p class="calibre2">With this code, we can save the file, and as our test is running in the <em class="calibre18">triggered mode,</em> we can see that the test case passes:</p>
<pre class="calibre19">[info] PlayerSpec: 
[info] - should compile 
[info] Run completed in 199 milliseconds. 
[info] Total number of tests run: 1 
[info] Suites: completed 1, aborted 0 
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0 
[info] All tests passed. 
[success] Total time: 1 s, completed </pre>
<p class="calibre2">We'll follow the same steps again. So, let's write a few more test cases:</p>
<pre class="calibre19">package example 
 
class PlayerSpec extends SomeSpec("PlayerService") { 
 
  it should "compile" in { 
    """PlayerService.Player("Cristiano Ronaldo", "Portuguese", 32, "Real Madrid")""" should compile 
    } 
 
  it should "throw an exception when source is wrong" in { 
    val src = "some source" 
    assertThrows[java.io.FileNotFoundException](PlayerService.readPlayerDataFromSource(src)) 
  } 
 
  it should "return collection of String when data is read from correct source" in { 
    val src = "/Users/vika/Documents/LSProg/LSPWorkspace/First_Proj_Testing/src/main/scala/example/football_stats.csv" 
    PlayerService.readPlayerDataFromSource(src) should not be empty 
  } 
 
  it should "return None while parsing wrong player string data into player instance" in { 
    val data = "some wrong player string" 
    PlayerService.parseToPlayer(data) shouldBe None 
  } 
 
  it should "return Some Player while parsing player string data into player instance" in { 
    val data = """1,1,2,1,2,Cristiano Ronaldo,Portugal,Real Madrid,Spain,32,4829,40,4789,124,63""" 
    val player = PlayerService.Player("Cristiano Ronaldo", "Portugal", 32, "Real Madrid") 
     
    PlayerService.parseToPlayer(data) shouldBe Some(player) 
  } 
 
} </pre>
<p class="calibre2">As we are clear about the behavior of our functionality, we wrote a few more test cases. Now, our spec includes more test clauses. We have used a few <kbd class="calibre11">Matchers</kbd> available to us. Let's see how our tests work:</p>
<ol class="calibre13">
<li value="1" class="calibre8">After checking for our code, it should compile. In the next clause, we specified that our code should throw <kbd class="calibre11">FileNotFoundException</kbd> when we try to access the wrong file path. We used an assertion <kbd class="calibre11">assertThrows</kbd> to specify such behavior. Here, we didn't have to specify any <kbd class="calibre11">Matchers</kbd> since specifying an <em class="calibre18">Assertion</em> was enough.</li>
<li value="2" class="calibre8">In the next clause, we mentioned that the result of <kbd class="calibre11">readPlayerDataFromSource</kbd> should not be empty, empty as in a collection.</li>
<li value="3" class="calibre8">The next spec clause expects to return <kbd class="calibre11">None</kbd> when we try to call <kbd class="calibre11">parseToPlayer</kbd> with the wrong formatted data to a <kbd class="calibre11">Player</kbd> instance.</li>
<li value="4" class="calibre8">Finally, we expect the <kbd class="calibre11">parseToPlayer</kbd> method to return a player object when we call it with data in the correct format.</li>
</ol>
<p class="calibre2">It's clear from our specification and clauses mentioned what we exactly want from our functionality. When we try to run the test case, it doesn't compile because we don't have our methods <kbd class="calibre11">readPlayerDataFromSource</kbd> and <kbd class="calibre11">parseToPlayer</kbd>. We can define all these methods and the corresponding code. The code should look like this:</p>
<pre class="calibre19">package example 
 
import scala.util.Try 
import scala.util.{Failure, Success} 
 
object PlayerService extends App { 
 
  def readPlayerDataFromSource(src: String): List[String] = { 
    val source = io.Source.fromFile(src) 
 
    val list: List[String] = source.getLines().toList 
 
    source.close() 
    list 
  } 
 
  def parseToPlayer(string: String): Option[Player] = { 
    Try { 
      val columns = string.split((",")).map(_.trim) 
      Player(columns(5), columns(6), columns(9).toInt, columns(7)) 
    } match { 
      case Success(value) =&gt; Some(value) 
      case Failure(excep) =&gt; None 
    } 
  } 
 
  case class Player(name: String, nationality: String, age: Int, league: String) 
 
} </pre>
<p class="calibre2">After writing the code, we can refactor it if needed. In our case, we've already refactored the code. We may try to run the test cases if you have placed the corresponding file in the right path. All our test cases will pass successfully, meaning that they will all be green:</p>
<pre class="calibre19">[info] PlayerSpec: 
[info] - should compile 
[info] - should throw an exception when source is wrong 
[info] - should return collection of String when data is read from correct source 
[info] - should return None while parsing wrong player string data into player instance 
[info] - should return Some Player while parsing player string data into player instance 
[info] Run completed in 324 milliseconds. 
[info] Total number of tests run: 5 
[info] Suites: completed 1, aborted 0 
[info] Tests: succeeded 5, failed 0, canceled 0, ignored 0, pending 0 
[info] All tests passed. </pre>
<p class="calibre2">Now, we have a some idea about the toolkit and the way TDD makes it fun to write software. We have used <kbd class="calibre11">FlatSpec</kbd> in our example. There are more of these; some of the frequently used Specs are as follows:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">FunSpec</kbd></li>
<li class="calibre8"><kbd class="calibre11">WordSpec</kbd></li>
<li class="calibre8"><kbd class="calibre11">FreeSpec</kbd></li>
<li class="calibre8"><kbd class="calibre11">PropSpec</kbd></li>
<li class="calibre8"><kbd class="calibre11">FeatureSpec</kbd></li>
</ul>
<p class="calibre2">These styles only differ in the way they look. If we consider our test specs written in an English-like language, we can say these styles consist of different ways in which we can write/speak our sentences. We've already seen <kbd class="calibre11">FlatSpec</kbd><em class="calibre18">.</em> The <kbd class="calibre11">FunSpec</kbd> Spec uses nested clauses with keywords like <kbd class="calibre11">describe</kbd> and <kbd class="calibre11">it</kbd>. Let's take a few examples of all of these Spec styles:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">FunSpec</kbd></li>
</ul>
<pre class="calibre19">    describe("In PlayerService object"){<br class="title-page-name"/>        it("should compile") {<br class="title-page-name"/>            assertCompiles("""PlayerService.Player (<br class="title-page-name"/>                                  "Cristiano Ronaldo", <br class="title-page-name"/>                                  "Portuguese", 32, <br class="title-page-name"/>                                  "Real Madrid")""")<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">WordSpec</kbd></li>
</ul>
<pre class="calibre19">    "PlayerService.Player.parseToPlayer" when {<br class="title-page-name"/>        "wrong parsing data passed" should {<br class="title-page-name"/>            "return None" in {<br class="title-page-name"/>                PlayerService.parseToPlayer("some wrog data") shouldBe None<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">FreeSpec</kbd></li>
</ul>
<pre class="calibre19">    "PlayerService.Player.parseToPlayer" - {<br class="title-page-name"/>        "wrong parsing data passed" - {<br class="title-page-name"/>            "return None" in {<br class="title-page-name"/>                PlayerService.parseToPlayer("some wrog data") shouldBe None<br class="title-page-name"/>            }<br class="title-page-name"/>        }<br class="title-page-name"/>    }</pre>
<p class="calibre2">These are a few styles that we can use to write our test specs in <kbd class="calibre11">ScalaTest</kbd>. You should definitely check out <kbd class="calibre11">ScalaTest</kbd>'s documentation (<a href="http://www.scalatest.org/user_guide" target="_blank" class="calibre10">http://www.scalatest.org/user_guide</a>) to learn more about these styles.</p>
<p class="calibre2">We've seen the way we made assertions and used <kbd class="calibre11">Matchers</kbd> to check for test clause validity. Let's learn more about these. We'll start with the <em class="calibre18">Assertions</em> trait<em class="calibre18">.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Assertions</h1>
                
            
            <article>
                
<p class="calibre2">The trait<em class="calibre18"> Assertions</em> contains assertions that we can make while specifying behaviors for our test cases. There are three default assertions available in all the style specs. These assertions are as follows:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">assert</kbd></li>
<li class="calibre8"><kbd class="calibre11">assertResult</kbd></li>
<li class="calibre8"><kbd class="calibre11">assertThrows</kbd></li>
</ul>
<p class="calibre2">We've already used <kbd class="calibre11">assertThrows</kbd>, and the other two can also be used in a similar fashion. The <kbd class="calibre11">assertResult</kbd> assertion expects us to provide a value that is going to be the result of some calculation we specify. Similarly, <kbd class="calibre11">assert</kbd> expects us to provide a Boolean predicate, which has left and right parts. Some equality checks can be performed on some conditions, which result in a Boolean value, based on which the test clause passes.</p>
<p class="calibre2">Apart from these, there are more assertions available. A few of them are <kbd class="calibre11">fail</kbd>, <kbd class="calibre11">cancel</kbd>, <kbd class="calibre11">succeed</kbd>, <kbd class="calibre11">intercept</kbd>, <kbd class="calibre11">assertCompiles</kbd>, <kbd class="calibre11">assertDoesNotCompile</kbd>, and so on. Apart from these assertions, we can also use <kbd class="calibre11">Matchers</kbd> to check for the validity of our test specifications. We've used <kbd class="calibre11">Matchers</kbd> along with keywords in a few of our example clauses.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matchers</h1>
                
            
            <article>
                
<p class="calibre2">We've already seen a few <kbd class="calibre11">Matchers</kbd> in place when we were going through our example. These <kbd class="calibre11">Matchers</kbd> are DSL's way of writing assertions. <kbd class="calibre11">ScalaTest</kbd> provides a rich set of assertions that work with Strings to collections. We can also write <kbd class="calibre11">Matchers</kbd> for custom classes. With these <kbd class="calibre11">Matchers</kbd>, we can perform the most basic assertions like equality checks to custom ones, where we have to deal with aggregations and sequencing.</p>
<p class="calibre2">These <kbd class="calibre11">Matchers</kbd> are cool, because of native language-like methods. Consider the following example:</p>
<pre class="calibre19">someCollection should have length 7 
someString should include ("world") 
twenty should be &gt; 10 
number shouldBe odd 
sequence should contain ("thisvalue")  </pre>
<p class="calibre2">There are so many ways in which you can speak a particular sentence to convey the same information. Similarly, using <kbd class="calibre11">ScalaTest</kbd>'s <kbd class="calibre11">Matchers</kbd>, we can specify some clause using different methods. <kbd class="calibre11">Matchers</kbd> come in handy for this.</p>
<p class="calibre2">We also know that sometimes, while writing software, we get to create mock objects to pass as arguments. For that, we don't have to write mock objects ourselves, but, there're libraries that do this for us. Let's take a look at one of them available in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ScalaMock – a native library to mock objects</h1>
                
            
            <article>
                
<p class="calibre2">As we discussed, at instances where we need some other services that we are yet to define or it's harder to create their instances since using them is a matter of complexity, we tend to use some Mocking framework.</p>
<p class="calibre2"><strong class="calibre1">ScalaMock</strong> is a native framework available in Scala. To include ScalaMock in our project, we'll add a dependency for it in our <kbd class="calibre11">build.sbt</kbd> file. Let's do that. We'll add the following line in the build file:</p>
<pre class="calibre19">libraryDependencies += "org.scalamock" %% "scalamock" % "4.0.0" % Test </pre>
<p class="calibre2">We've specified the test scope, because we're sure that <kbd class="calibre11">scalamock</kbd> is only going to be used in our test cases. After writing this dependency, we'll perform an <kbd class="calibre11">sbt update</kbd> command by calling the <kbd class="calibre11">sbt update</kbd> command in the SBT shell<em class="calibre18">.</em> This update is going to add the <kbd class="calibre11">scalamock</kbd> dependency to our project. We can ensure this by taking a look at the external sources folder. There's going to be a dependency with the <kbd class="calibre11">scalamock</kbd> name. If that's available there, we are ready to mock some services:</p>
<div class="cdpaligncenter"><img src="../images/00082.jpeg" class="calibre89"/></div>
<p class="calibre2">We'll try to mock our <kbd class="calibre11">PlayerService</kbd> object in our application where we want to show a list of a few players. Let's specify a spec for that:</p>
<pre class="calibre19">import org.scalamock.scalatest.MockFactory 
 
class PlayerAppSpec extends SomeSpec("PlayerAppSpec") with MockFactory { 
 
  it should "give us a collection of 2 players" in { 
 
    val mockPlayer = mock[PlayerService.Player] 
 
    val list = List(mockPlayer, mockPlayer) 
    list should have length 2 
  } 
 
} </pre>
<p class="calibre2">The preceding code snippet is a very simple example of a mock object for a class. All we had to do is import the <kbd class="calibre11">scalamock</kbd> dependency, the <kbd class="calibre11">MockFactory</kbd> trait in the scope, all by importing the dependencies and calling the <kbd class="calibre11">mock</kbd> method, specifying which type of object to create as a mock. It's as simple as that. We can also mock functions and set some expectations to that mocked function. Let's see the following example:</p>
<pre class="calibre19">val someStringToIntFunc  = mockFunction[String, Int] 
someStringToIntFunc expects ("Some Number") returning 1 </pre>
<p class="calibre2">Now, we can perform some test case execution, which includes a call to this mocked function. Our test case has to somehow call this function at least once in order for it to pass. Mocking of objects is a usual practice we do while writing test cases. It relieves us of the burden of manually writing instances of several classes/functions, letting us concentrate on what matters, that is, validating our program's behavior upfront. And that's why we have such frameworks available, making our lives easier as developers. With this, we've come to the end of the final chapter of this book. Let's summarize whatever you've learned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter never seemed like the last one; it was fun. After going through several Scala programming constructs and frameworks, you learned how to ensure the validity of our programs. We knew that testing the code we write is essential, but this new TDD style of programming was a different experience. We understood what TDD actually is—a design scheme driven by specifying the behaviors at the beginning, rather than after we complete our code. We talked about why this approach is good. Then, we started with the testing tools available in Scala, and learned about <kbd class="calibre11">ScalaTest</kbd><em class="calibre18">.</em> We wrote the specifications and then coded for the same. Finally, we also took a look at the mocking framework available in Scala named ScalaMock.</p>
<p class="calibre2">Though this is the last chapter, we can think of what more we can do to  make our understanding of this language better. One of the best ways is to practice more; this will help us understand the concepts well, and we'll also be well versed with the constructs. But we'll get the real insight when we go about learning functional programming, because that's where all the magic is. Trying to think in a functional way, where we do not mutate stuff it, is one of the most important aspects. Finally, let's thank the wonderful and ever growing Scala community. Join the community, ask questions, and contribute in your own way.</p>


            </article>

            
        </section>
    </body></html>