- en: Transformers and Custom Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In RxJava, there are ways to implement your own custom operators using the `compose()`
    and `lift()` methods, which exist on both `Observable` and `Flowable`. Most of
    the time, you will likely want to compose existing RxJava operators to create
    a new operator. But on occasion, you may find yourself needing an operator that
    must be built from scratch. The latter is a lot more work, but we will cover how
    to do both of these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Composing new operators with existing operators using `compose()` and Transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `to()` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing operators from scratch with `lift()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RxJava2-Extras and RxJava2Extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with RxJava, you may find yourself wanting to reuse pieces of an
    `Observable` or `Flowable` chain and somehow consolidate these operators into
    a new operator. Good developers find opportunities to reuse code, and RxJava provides
    this ability using `ObservableTransformer` and `FlowableTransformer`, which you
    can pass to the `compose()` operator.
  prefs: []
  type: TYPE_NORMAL
- en: ObservableTransformer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bring back [*Google Guava*](http://search.maven.org/#artifactdetails%7Ccom.google.guava%7Cguava%7C21.0%7Cbundle)
    as a dependency. In [Chapter 3](de58a40c-f55f-442f-b12e-7c022e08644e.xhtml), *Basic
    Operators*, we covered the `collect()` operator and used it to turn  `Observable<T>`
    into a `Single<ImmutableList<T>>`. Effectively, we want to collect `T` emissions
    into a Google Guava `ImmutableList<T>`. Suppose we do this operation enough times
    until it starts to feel redundant. Here, we use this `ImmutableList` operation
    for two different `Observable` subscriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at this part of the Observable chain used in two places above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit redundant to invoke twice, so is it possible that we can compose
    these operators into a single operator that collects emissions into an `ImmutableList`?
    As a matter of fact, yes! To target an `Observable<T>`, you can implement `ObservableTransformer<T,R>`.
    This type has an `apply()` method that accepts an `Observable<T>` upstream and
    returns an `Observable<R>` downstream. In your implementation, you can return
    an `Observable` chain that adds on any operators to the upstream, and after those
    transformations, it returns an `Observable<R>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will target any generic type `T` for a given `Observable<T>`,
    and `R` will be an `ImmutableList<T>` emitted through an `Observable<ImmutableList<T>>`.
    We will package all of this up in an `ObservableTransformer<T,ImmutableList<T>>`
    implementation, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since `collect()` returns a `Single`, we will invoke `toObservable()` on it
    since `ObservableTransformer` expects an `Observable`, not `Single`, to be returned.
    It is not uncommon for Transformers to be delivered through static factory methods,
    so that is what we did here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since there is only one single abstract method in `ObservableTransformer`,
    we can streamline this more using a lambda instead. This reads a bit easier, as
    it reads left-to-right/top-to-bottom and expresses *for a given upstream Observable,
    return it with these operators added to the downstream*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke a Transformer into an `Observable` chain, you pass it to the `compose()`
    operator. When called on an `Observable<T>`, the `compose()` operator accepts
    an `ObservableTransformer<T,R>` and returns the transformed `Observable<R>`. This
    allows you to reuse Rx logic and invoke it in multiple places, and now we can
    call `compose(toImmutableList())` on both of our `Observable` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is common for APIs to organize Transformers in a static factory class. In
    a real-world application, you may store your `toImmutableList()` Transformer inside
    a `GuavaTransformers` class. Then, you can invoke it by calling `compose(GuavaTransformers.toImmutableList())`
    in your `Observable` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note for this example, we could actually make the `toImmutableList()` a reusable
    singleton since it does not take any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create Transformers that target specific emission types and accept
    arguments. For example, you can create a `joinToString()` Transformer that accepts
    a separator argument and concatenates `String` emissions with that separator.
    Usage of this `ObservableTransformer` will only compile when invoked on an `Observable<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Transformers are a great way to reuse a series of operators that perform a common
    task, and leveraging them can greatly increase your Rx code reusability. Usually,
    you will get the most flexibility and speed by implementing them through static
    factory methods, but you can also extend `ObservableTransformer` onto your own
    class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As we will learn in [Chapter 12](42947483-7be8-4693-a7e4-2527ad9f180b.xhtml),
    *Using RxJava with Kotlin*, the Kotlin language enables powerful language features
    that streamline RxJava even more. Instead of using Transformers, you can leverage
    extension functions to add operators to the `Observable` and `Flowable` types
    without inheritance. We will learn more about this later.
  prefs: []
  type: TYPE_NORMAL
- en: FlowableTransformer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you implement your own `ObservableTransformer`, you might want to create
    a `FlowableTransformer` counterpart as well. This way, you can use your operator
    on both Observables and Flowables.
  prefs: []
  type: TYPE_NORMAL
- en: The `FlowableTransformer` is not much different from `ObservableTransformer`.
    Of course, it will support backpressure since it is composed with Flowables. Otherwise,
    it is pretty much the same in its usage except that you obviously pass it to `compose()`
    on a `Flowable`, not `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we take our `toImmutableList()` method returning an `ObservableTransformer` and
    implement it as `FlowableTransformer` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You should be able to make a similar conversion to `FlowableTransformer` for
    our `joinToString()` example as well.
  prefs: []
  type: TYPE_NORMAL
- en: You might consider creating separate static utility classes to store your `FlowableTransformers`
    and `ObservableTransformers` separately to prevent name clashes. Our `FlowableTransformer`
    and `ObservableTransformer` variants of `toImmutableList()` cannot exist in the
    same static utility class unless they have different method names. But it might
    be cleaner to put them in separate classes, such as `MyObservableTransformers`
    and `MyFlowableTransformers`. You could also have them in separate packages with
    the same class name, `MyTransformers`, one for Observables and the other for Flowables.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding shared state with Transformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start creating your own Transformers and custom operators (covered
    later), an easy way to shoot yourself in the foot is to share states between more
    than one subscription. This can quickly create unwanted side effects and buggy
    applications and is one of the reasons you have to tread carefully as you create
    your own operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, you want to create an `ObservableTransformer<T,IndexedValue<T>>`, which
    pairs each emission with its consecutive index starting at 0\. First, you create
    an `IndexedValue<T>` class to simply pair each `T` value with an `int index`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you create an `ObservableTransformer<T,IndexedValue<T>>` that uses an `AtomicInteger`
    to increment and attach an integer to each emission. But there is something wrong
    with our implementation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'See anything wrong yet? Try to run this `Observable` operation, which has two
    Observers and uses this `withIndex()` Transformer. Look at the output carefully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that a single instance of  `AtomicInteger` was shared between both subscriptions,
    which means its state was shared as well. On the second subscription, instead
    of starting over at `0`, it picks up at the index left by the previous subscription
    and starts at index `5` since the previous subscription ended at `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you have some stateful behaviors you are deliberately implementing, this
    is probably an unwanted side-effect that can result in maddening bugs. Constants
    are usually fine, but a mutable shared state between subscriptions is often something
    you want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick and easy way to create a new resource (such as `AtomicInteger`) for
    each subscription is to wrap everything in `Observable.defer()`, including the
    `AtomicInteger` instance. This way, a new `AtomicInteger` is created each time
    with the returned indexing operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also create an `AtomicInteger` within `Observable.fromCallable()` and
    use `flatMap()` on it to the `Observable` that uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular example, you can also use `Observable.zip()` or `zipWith()`
    with `Observable.range()`. Since this is a pure Rx approach as well, no state
    will be shared between multiple subscribers, and this will also solve our problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Again, inadvertent shared state and side-effects are dangerous in Rx! Whatever
    implementation you use to create your Transformer, it is better to rely on pure
    Rx factories and operators in your implementation if possible. Avoid creating
    imperative states and objects that risk being shared across subscriptions unless
    you are fulfilling some strange business requirement where a shared state is explicitly
    wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Using to() for fluent conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On rare occasions, you may find yourself having to pass an `Observable` to another
    API that converts it into a proprietary type. This can be done simply by passing
    an `Observable` as an argument to a factory that does this conversion. However,
    this does not always feel fluent, and this is where the `to()` operator comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, JavaFX has a `Binding<T>` type that houses a mutable value of
    type `T`, and it will notify affected user interface elements to update when it
    changes. RxJavaFX has `JavaFxObserver.toBinding()` and `JavaFxSubscriber.toBinding()`
    factories, which can turn an `Observable<T>` or `Flowable<T>` into a JavaFX `Binding<T>`.
    Here is a simple JavaFX `Application` that uses `Binding<String>` built-off `Observable<String>`,
    which is used to bind to a `textProperty()` operator of `label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have gotten so used to fluent programming with RxJava, would it not
    be nice to make the conversion of the `Observable<String>` to a `Binding<String>`
    part of the `Observable` chain too? This way, we do not have to break our fluent
    style and save intermediary variables. That can be done with the `to()` operator,
    which simply accepts an `Function<Observable<T>,R>` to turn an `Observable<T>`
    into any arbitrary `R` type. In this case, we can turn our `Observable<String>` into
    a `Binding<String>`at the end of our `Observable` chain using `to()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Simple but helpful, right? When you are dealing with proprietary non-Rx types
    that can be built off Rx Observabes and Flowables, this is a handy utility to
    maintain the fluent Rx style, especially when interoperating with binding frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you will rarely get to a point where you need to build your own operator
    from scratch by implementing `ObservableOperator` or `FlowableOperator`. `ObservableTransformer`
    and `FlowableTransformer` will hopefully satisfy most cases where you can use
    existing operators to compose new ones, and this is usually the safest route.
    But on occasion, you may find yourself having to do something that the existing
    operators cannot do or not do easily. After you exhaust all other options, you
    may have to create an operator that manipulates each `onNext()`, `onComplete()`,
    and `onError()` event between the upstream and the downstream.
  prefs: []
  type: TYPE_NORMAL
- en: Before you go out and create your own operator, try to use existing operators
    first with `compose()` and a Transformer. After that fails, it is recommended
    that you post a question on StackOverflow and ask the RxJava community whether
    such an operator exists or can be composed easily. The RxJava community is very
    active on StackOverflow and they will likely provide a solution and only escalate
    the complexity of the solution as required.
  prefs: []
  type: TYPE_NORMAL
- en: Note that David Karnok's [*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions)
    and Dave Moten's [*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)
    have many useful Transformers and operators to augment RxJava as well. You should
    check out these libraries to see whether they fulfill your needs.
  prefs: []
  type: TYPE_NORMAL
- en: If it is determined that there are no existing solutions, then proceed carefully
    to build your own operator. Again, it is recommended that you solicit help from
    StackOverflow first. Building a native operator is no easy task, and getting insight
    and experience from an Rx expert is highly valuable and most likely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ObservableOperator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing your own `ObservableOperator` (as well as `FlowableTransformer`)
    is more involved than creating an `ObservableTransformer`. Instead of composing
    a series of existing operators, you intercept the `onNext()`, `onComplete()`,
    `onError()`, and `onSubscribe()` calls from the upstream by implementing your
    own `Observer` instead. This `Observer` will then logically pass the `onNext()`,
    `onComplete()`, and `onError()` events to the downstream `Observer` in a way that
    fulfills the desired operation.
  prefs: []
  type: TYPE_NORMAL
- en: Say, you want to create your own `doOnEmpty()` operator that will execute an `Action`
    when `onComplete()` is called and no emissions have occurred. To create your own
    `ObservableOperator<Downstream,Upstream>` (where `Upstream` is the upstream emission
    type and `Downstream` is the downstream emission type), you will need to implement
    its `apply()` method. This accepts an `Observer<Downstream>` `observer` argument and
    returns an `Observer<Upstream>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use this `ObservableOperator` by calling it in the `lift()` operator
    in your `Observable` chain, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Inside `apply()`, you take the passed `Observer` that accepts events for the
    downstream. You create another `Observer` (in this case, we should use a `DisposableObserver`
    that handles disposal requests for us) to receive emissions and events from the
    upstream and relay them to the downstream `Observer`. You can manipulate the events
    to execute the desired logic as well as add any side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we simply passed the events from the upstream to the downstream
    untampered but track whether `onNext()` was called to flag if emissions were present.
    When `onComplete()` is called and no emissions are present, it will execute the
    user-specified action within `onComplete()`. It is usually a good idea to wrap
    any code that could throw runtime errors in `try-catch` and pass those captured
    errors to `onError()`.
  prefs: []
  type: TYPE_NORMAL
- en: With `ObservableOperator`, it may seem odd that you get the downstream as an
    input and have to produce an `Observer` for the upstream as the output. With the
    `map()` operator, for example, the function receives the upstream value and returns
    the value to be emitted toward the downstream. The reason for this is that code
    from an `ObservableOperator` gets executed at subscription time where the call
    travels from the end `Observer` (downstream) toward the source `Observable` (upstream).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is a single abstract method class, you can also express your `ObservableOperator`
    implementation as a lambda, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just like `Transformers`, be mindful when creating custom operators to not share
    states between subscriptions unless you absolutely mean to. This is a relatively
    simple operator because it is a simple reactive building block, but operators
    can be made enormously complex. This is especially the case when the operators
    deal with concurrency (for example, `observeOn()` and `subscribeOn()`) or share
    states between subscriptions (for example, `replay()`). The implementations of
    `groupBy()`, `flatMap()`, and `window()` are complicated and intricate as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of rules in the `Observable` contract you must follow when
    calling the three events. Never call `onComplete()` after `onError()` has occurred
    (or vice versa). Do not call `onNext()` after `onComplete()` or `onError()` is
    called, and do not call any events after disposal. Breaking these rules can have
    unintended consequences downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that needs to be pointed out is that `onNext()`, `onComplete()`,
    and `onError()` calls can be manipulated and mixed as needed. For example, `toList()`
    does not pass an `onNext()`call downstream for every `onNext()`it receives from
    the upstream. It will keep collecting these emissions in an internal list. When
    `onComplete()` is called from the upstream, it will call `onNext()` on the downstream
    to pass that list before it calls `onComplete()`. Here, we implement our own `myToList()`
    operator to understand how `toList()` could work, even though in normal circumstances,
    we should use `collect()` or `toList()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before you start getting ambitious in creating your own operators, it might
    be good to study the source code of RxJava or other libraries, such as RxJava2-Extras.
    Operators can be difficult to implement correctly as you need to have a good understanding
    of how to build reactive patterns from imperative ones. You will also want to
    test the heck out of it (which we will cover in [Chapter 10](ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml), *Testing
    and Debugging*) in order to ensure that it behaves correctly before putting it
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: FlowableOperator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create your own `ObservableOperator`, you will most likely want to
    create a `FlowableOperator` counterpart as well. This way, your operator can be
    used for both Observables and Flowables. Thankfully, `FlowableOperator` is implemented
    in a similar manner to `ObservableOperator`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of Observers, we used Subscribers, which hopefully is not surprising
    at this point. The `Subscriber` passed via `apply()` receives events for the downstream,
    and the implemented `Subscriber` receives events from the upstream, which it relays
    to the downstream (just as we used `DisposableObserver`, we use `DisposableSubscriber`
    to handle disposal/unsubscription for us). Just like earlier, `onComplete()` will
    verify that no emissions occurred and run the specified action if that is the
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'And of course, you can express your `FlowableOperator`as a lambda too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, be studious and thorough when you start implementing your own operators,
    especially as they pass a threshold of complexity. Strive to use existing operators
    to compose Transformers, and hit StackOverflow or the RxJava community to see
    whether others can point out an obvious solution first. Implementing operators
    is something you should be conservative about and only pursue when all other options
    have been exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Transformers and operators for Singles, Maybes, and Completables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are Transformer and operator counterparts for `Single`, `Maybe`, and `Completable`.
    When you want to create an `Observable` or `Flowable` operator that yields `Single`,
    you might find it easier to convert it back into an `Observable`/`Flowable` by
    calling its `toObservable()` or `toFlowable()` operators. This also applies to
    `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: If on some rare occasion you need to create a Transformer or operator specifically
    to take a `Single` and transform it into another `Single`, you will want to use `SingleTransformer`
    or `SingleOperator`. `Maybe` and `Completable` will have counterparts with `MaybeTransformer`/`MaybeOperator`
    and `CompletableTransformer`/`CompletableOperator`, respectively. The implementation
    of `apply()` for all of these should largely be the same experience, and you will
    use `SingleObserver`, `MaybeObserver`, and `CompletableObserver` to proxy the
    upstream and downstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `SingleTransformer` that takes `Single<Collection<T>>`
    and maps the emitted `Collection` to an unmodifable collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using RxJava2-Extras and RxJava2Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in learning about additional operators beyond what RxJava
    provides, it may be worthwhile to explore the [*RxJava2-Extras*](https://github.com/davidmoten/rxjava2-extras)
    and [*RxJava2Extensions*](https://github.com/akarnokd/RxJava2Extensions) libraries.
    While neither of these libraries are at a 1.0 version, useful operators, Transformers,
    and `Observable`/`Flowable` factories are continually added as an ongoing project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two useful operators are `toListWhile()` and `collectWhile()`. These will buffer
    emissions into a list or collection while they meet a certain condition. Because
    a `BiPredicate` passes both the list/collection and the next `T` item as lamda
    input parameters, you can use this to buffer items but cut off the moment something
    changes about the emissions. Here, we keep collecting strings into a list but
    push that list forward when the length changes (kind of like `distinctUntilChanged()`).
    We also will qualify a list being empty, as that is the start of the next buffer,
    as well as sample an item from the list to compare lengths with the next emission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Spend some quality time with RxJava2-Extras and RxJava2Extensions to learn about
    their custom operators. This way, you will not have to reinvent something that
    may already be done, and there are already many powerful factories and operators.
    One of my personal favorites is a resettable `cache()` operator, which works like
    the cache we studied in [Chapter 5](4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml), *Multicasting*,
    but it can be cleared and then resubscribed to the source at any time. It can
    also clear the cache at fixed time intervals or periods of no activity, preventing
    stale caches from persisting.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got our feet wet by creating our own operators. It is preferable
    to use `ObservableTransformer` and `FlowableTransformer` to compose existing operators
    together to create new ones, and even with that, you need to be cautious when
    introducing stateful resources that cause undesirable side-effects. When all else
    fails, you can create your own `ObservableOperator` or `FlowableOperator` and
    create an operator at a low level that intercepts and relays each emission and
    event. This can be tricky and you should exhaust all other options, but with careful
    study and testing, creating operators can be a valuable advanced skill to have.
    Just be careful to not reinvent the wheel and seek guidance from the Rx community
    as you start dabbling in custom operators.
  prefs: []
  type: TYPE_NORMAL
- en: If you truly are interested in implementing your own operators (at a low level,
    not with Transformers), definitely study existing operators in RxJava and other
    reputable RxJava extension libraries. It is easy to hack an operator together
    and believe nothing will go wrong, when in fact there are a lot of complications
    you can overlook. Your operator needs to be serialized, cancellable, concurrent,
    and handle re-entrancy (which occurs when an emission invokes a request on the
    same thread). Of course, some operators are simpler than others, but you should
    never assume without committed study first.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the different strategies to do unit
    testing against RxJava APIs and utilities. Whether you create your own custom
    operators or you have an Rx project at work, automated testing is something you
    will want to be proficient in. We will also learn how to debug RxJava applications,
    which is not always easy, but it can be done effectively.
  prefs: []
  type: TYPE_NORMAL
