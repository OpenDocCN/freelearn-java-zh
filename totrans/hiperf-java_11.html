<html><head></head><body>
		<div id="_idContainer028">
			<h1 class="chapter-number" id="_idParaDest-190"><a id="_idTextAnchor189"/>11</h1>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor190"/>Hypertext Transfer Protocols</h1>
			<p><strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) is the foundational protocol used<a id="_idIndexMarker522"/> for information exchange on the web. It empowers communication between client computers and servers. HTTP’s applicability to Java is primarily due to Java <span class="No-Break">web applications.</span></p>
			<p>This chapter starts with an introduction to HTTP within the context of Java. Once the fundamentals have been addressed, the chapter moves on to a practical approach to using built-in and third-party HTTP-related libraries. Using HTTP for API integrations is also covered. The chapter also looks at security concerns with using HTTP and touches on the use of HTTPS. The concluding section focuses on performance optimizations for our Java applications when employing HTTP. By the end of this chapter, you should have a firm understanding of how HTTP impacts performance in Java applications and be comfortable with your future <span class="No-Break">HTTP implementations.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Introduction <span class="No-Break">to HTTP</span></li>
				<li>Java <span class="No-Break">web applications</span></li>
				<li>Using HTTP <span class="No-Break">in Java</span></li>
				<li><span class="No-Break">API integration</span></li>
				<li><span class="No-Break">Security considerations</span></li>
				<li><span class="No-Break">Performance optimization</span></li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor191"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need to have the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Peeking </em><em class="italic">I</em><em class="italic">nside the Java Virtual </em><span class="No-Break"><em class="italic">Machine (JVM)</em></span><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor192"/>Introduction to HTTP</h1>
			<p>HTTP was released around 1990, so you are likely familiar<a id="_idIndexMarker523"/> with at least the basic concept of enabling client and server communication. The World Wide Web was built on HTTP, and HTTP is still the foundation for the web today.. Understanding this protocol is important if you plan to build a web application, especially in Java. We will explore HTTP in the context of Java in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor193"/>HTTP core components</h2>
			<p>HTTP is a stateless protocol<a id="_idIndexMarker524"/> that uses<a id="_idIndexMarker525"/> a communication model called <strong class="bold">request-response</strong>. Each request-response exchange is independent of all others, making this a very simple protocol. Today’s web services rely heavily <span class="No-Break">on HTTP.</span></p>
			<p class="callout-heading">Stateless protocol</p>
			<p class="callout">A stateless protocol is one where the receiver<a id="_idIndexMarker526"/> does not need to retain or track information about the information being sent. No session information <span class="No-Break">is saved.</span></p>
			<p>There are four basic components <span class="No-Break">of HTTP:</span></p>
			<ul>
				<li>First is the <strong class="bold">request and response pair</strong>. This pair represents the core<a id="_idIndexMarker527"/> of all web communication. A client sends a request for information, such as loading a web page, and the server sends back either a response with the requested information or another action result such as <span class="No-Break">an error.</span></li>
				<li>Both the requests<a id="_idIndexMarker528"/> and responses contain <strong class="bold">headers</strong> that provide metadata. This HTTP component includes information such as the type of content being sent, what was requested, authentication details, and <span class="No-Break">other</span><span class="No-Break"><a id="_idIndexMarker529"/></span><span class="No-Break"> information.</span></li>
				<li>A third HTTP component is <strong class="bold">status codes</strong>. When servers respond<a id="_idIndexMarker530"/> to a client’s request, they provide a status code to characterize the outcome of the request. These codes are categorized by a numbered series as indicated in the table <span class="No-Break">that follows:</span></li>
			</ul>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-5">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Category</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Type </strong><span class="No-Break"><strong class="bold">of response</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">100 series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Informational responses</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">100 Continue</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">200 series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Successful responses</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">200 OK</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">300 series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Redirection messages</span></p>
						</td>
						<td class="No-Table-Style">
							<p>301 <span class="No-Break">Moved permanently</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">400 series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Client errors</span></p>
						</td>
						<td class="No-Table-Style">
							<p>404 <span class="No-Break">Not found</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">500 series</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Server errors</span></p>
						</td>
						<td class="No-Table-Style">
							<p>500 Internal <span class="No-Break">server error</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.1 – HTTP status codes and examples</p>
			<ul>
				<li>The fourth HTTP component is <strong class="bold">methods</strong>. There are several request<a id="_idIndexMarker531"/> methods that HTTP uses to perform required actions. Here is a list<a id="_idIndexMarker532"/> of the most common <span class="No-Break">HTTP methods:</span></li>
			</ul>
			<table class="No-Table-Style _idGenTablePara-1" id="table002">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Method</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Functionality</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">DELETE</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deletes <span class="No-Break">a resource</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">GET</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves <span class="No-Break">a resource</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">HEAD</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Retrieves a <span class="No-Break">resource’s header</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">POST</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Submits data to <span class="No-Break">a resource</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">PUT</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Updates <span class="No-Break">a resource</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 11.2 – HTTP methods</p>
			<p>Now that we have a fundamental understanding of HTTP, let’s examine the significance of this protocol to <span class="No-Break">Java developers.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor194"/>Java and HTTP</h2>
			<p>There are a plethora<a id="_idIndexMarker533"/> of libraries and <strong class="bold">Application Programming Interfaces</strong> (<strong class="bold">APIs</strong>) to help us manage how our apps<a id="_idIndexMarker534"/> use HTTP. <strong class="source-inline">HttpClient</strong>, for example, helps simplify our use of HTTP<a id="_idIndexMarker535"/> operations. Learning how to use available APIs and libraries is important, especially when we are concerned with how our Java <span class="No-Break">applications perform.</span></p>
			<p>One of the reasons HTTP knowledge is so important is that most API integrations involve HTTP communications. This requires us to understand how to formulate an HTTP request, how to handle response status codes, and how to parse <span class="No-Break">the responses.</span></p>
			<p>Java developers should also master HTTP when developing web applications. HTTP is the underlying protocol used for client-server communications. This underscores the importance of HTTP knowledge for <span class="No-Break">Java developers.</span></p>
			<p>Another reason why Java developers should seek to fully understand HTTP is that it plays a significant role in overall program performance. HTTP lacks complexity but is nevertheless a critical protocol for developing web apps, microservices, applets, and other <span class="No-Break">application types.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor195"/>Java web applications</h1>
			<p>A Java web application is a server-side application<a id="_idIndexMarker536"/> used to create dynamic websites. We create websites that interact with Java web applications to dynamically generate content based on user input. Common examples<a id="_idIndexMarker537"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">E-commerce platforms</span></li>
				<li><span class="No-Break">Enterprise applications</span></li>
				<li><span class="No-Break">Online banking</span></li>
				<li>Information <span class="No-Break">management systems</span></li>
				<li>Social <span class="No-Break">media platforms</span></li>
				<li><span class="No-Break">Cloud-based applications</span></li>
				<li><span class="No-Break">Educational platforms</span></li>
				<li><span class="No-Break">Healthcare applications</span></li>
				<li><span class="No-Break">Gaming servers</span></li>
				<li><strong class="bold">Internet of Things</strong> (<span class="No-Break"><strong class="bold">IoT</strong></span><span class="No-Break">) applications</span></li>
			</ul>
			<p>These examples demonstrate<a id="_idIndexMarker538"/> the versatility of using Java to develop and deploy high-performance web applications. As you might expect, HTTP is a foundational component of these Java <span class="No-Break">web applications.</span></p>
			<p>Let’s next review the basic architecture for Java web applications, so we can understand <span class="No-Break">HTTP’s role.</span></p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor196"/>Java web application architecture</h2>
			<p>Most Java web applications<a id="_idIndexMarker539"/> are comprised of four tiers, making it a <span class="No-Break">multi-tier architecture:</span></p>
			<ul>
				<li><strong class="bold">Client tier</strong>: The client tier is what the user sees, normally<a id="_idIndexMarker540"/> via a web browser. These<a id="_idIndexMarker541"/> web pages<a id="_idIndexMarker542"/> usually<a id="_idIndexMarker543"/> consist of <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>), <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>), and <span class="No-Break"><strong class="bold">JavaScript</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JS</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Web tier (or server tier)</strong>: This tier receives and processes the HTTP<a id="_idIndexMarker544"/> requests. We can use<a id="_idIndexMarker545"/> several technologies such as <strong class="bold">JavaServer Pages</strong> (<strong class="bold">JSP</strong>) to <span class="No-Break">accomplish this.</span></li>
				<li><strong class="bold">Business tier</strong>: The business tier is where our application<a id="_idIndexMarker546"/> logic resides. This is where data is processed, computations are performed, and logic-based decisions are made. The link between this tier<a id="_idIndexMarker547"/> and the web tier <span class="No-Break">is extensive.</span></li>
				<li><strong class="bold">Data tier</strong>: The data tier is a critical part of the backend<a id="_idIndexMarker548"/> system. This tier is responsible for managing databases and ensuring data security <span class="No-Break">and persistence.</span></li>
			</ul>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor197"/>Key technologies</h2>
			<p>Key technologies worth<a id="_idIndexMarker549"/> mentioning are serverlets, JSPs, Spring Framework, and <span class="No-Break">Jarkata EE:</span></p>
			<ul>
				<li><strong class="bold">Serverlets</strong>: Java programs that run on web servers<a id="_idIndexMarker550"/> are referred to as serverlets. This specialty software sits between the client’s HTTP requests and the applications and/or databases on the <span class="No-Break">web servers.</span></li>
				<li><strong class="bold">JSP</strong>: JSPs are text documents used to execute<a id="_idIndexMarker551"/> on the server and generate content for dynamic web pages. JSPs are typically used in conjunction <span class="No-Break">with serverlets.</span></li>
				<li><strong class="bold">Spring Framework</strong>: Spring is a Java application<a id="_idIndexMarker552"/> framework that is commonly used for developing Java <span class="No-Break">web applications.</span></li>
				<li><strong class="bold">Jakarta EE</strong>: <strong class="bold">Jakarta Enterprise Edition</strong> (<strong class="bold">Jakarta EE</strong>) is a set of application<a id="_idIndexMarker553"/> specifications that<a id="_idIndexMarker554"/> extend the Java <strong class="bold">Standard Edition</strong> (<strong class="bold">SE</strong>). It includes specifications<a id="_idIndexMarker555"/> for web services and <span class="No-Break">distributed computing.</span></li>
			</ul>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor198"/>Steps for creating a simple Java web application</h2>
			<p>There are six basic steps to creating<a id="_idIndexMarker556"/> Java web applications. Please note that this is an abbreviated approach and will vary based on your application needs, such as the need for databases, APIs, and <span class="No-Break">so on:</span></p>
			<ol>
				<li>The first step is to establish your development environment. This<a id="_idIndexMarker557"/> will consist of an <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) such as Visual Studio Code, the most recent <strong class="bold">Java Software Development Kit</strong> (<strong class="bold">JDK</strong>), and a web server such as<a id="_idIndexMarker558"/> <span class="No-Break">Apache Tomcat.</span></li>
				<li>The next step is to create a new web application project in your IDE. This step includes creating the project’s file <span class="No-Break">directory structure.</span></li>
				<li>Next, we will write the code for our Java serverlet to handle HTTP requests. During this step, we will also define the routes that our serverlets will respond to. This is often defined <span class="No-Break">using URLs.</span></li>
				<li>Next, we will be creating the JSP pages or templates we plan to use to generate HTML content. This is the content we will send back to <span class="No-Break">the client.</span></li>
				<li>Next, we will create the business logic to implement at the core of our application. We can accomplish this through a series of <span class="No-Break">Java classes.</span></li>
				<li>Lastly, we package<a id="_idIndexMarker559"/> our application<a id="_idIndexMarker560"/> into a <strong class="bold">Web Application Archive</strong> (<strong class="bold">WAR</strong>), which is like a <strong class="bold">Java Application Archive</strong> (<strong class="bold">JAR</strong>) but for web applications, and <span class="No-Break">deploy it.</span></li>
			</ol>
			<p>When developing Java web applications, we should create them with distinct boundaries between the presentation, business, and data access layers. This approach will help with modularity, scalability, and maintainability. It is also advisable to use frameworks such as Spring and Jakarta EE. Doing so can simplify our development efforts and provide inherent support for web <span class="No-Break">application development.</span></p>
			<p>Dynamic web pages are the norm<a id="_idIndexMarker561"/> and expected by users, so embracing Java web application technologies is important for all <span class="No-Break">Java developers.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor199"/>Using HTTP in Java</h1>
			<p>As Java developers, we can use HTTP<a id="_idIndexMarker562"/> to create dynamic web<a id="_idIndexMarker563"/> applications. These will use HTTP to communicate between the browser and server. Java includes <strong class="source-inline">HttpClient</strong>, a Java library that makes working with HTTP requests and processing responses efficient. Let’s look at <span class="No-Break">an example.</span></p>
			<p>The preceding code employs the <strong class="source-inline">HttpClient</strong> library to create a <strong class="source-inline">GET</strong> request, which retrieves data from a specific resource (simulated in <span class="No-Break">our example):</span></p>
			<pre class="source-code">
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
public class GetRequestExample {
  public static void main(String[] args) {
    HttpClient client = HttpClient.newHttpClient();
    HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create("https://api.not-real-just-
         an-example.com/data"))
        .GET()
        .build();
    try {
      HttpResponse&lt;String&gt; response = client.send(request,
      HttpResponse.BodyHandlers.ofString());
      System.out.println("Status Code: " +
      response.statusCode());
      System.out.println("Response Body: \n" + response.body());
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    }
  }
}</pre>			<p>The preceding example sends a <strong class="source-inline">GET</strong> request to a simulated URL and prints both the status code and the body of <span class="No-Break">the response.</span></p>
			<p>Next, let’s look at a method<a id="_idIndexMarker564"/> for making a <strong class="source-inline">POST</strong> request. This type of request<a id="_idIndexMarker565"/> can be used to submit data to a specific resource using JSON. In our example, this will be a <span class="No-Break">simulated resource:</span></p>
			<pre class="source-code">
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.http.HttpHeaders;
import java.nio.charset.StandardCharsets;
public class PostRequestExample {
  public static void main(String[] args) {
    HttpClient client = HttpClient.newHttpClient();
    String json = "{\"name\":\"Neo
    Anderson\",\"email\":\"neo.anderson@thematrix.com\"}";
    HttpRequest request = HttpRequest.newBuilder()
        .uri(URI.create("https://api.not-real-just-an-
        example.com/users"))
        .header("Content-Type", "application/json")
        .POST(HttpRequest.BodyPublishers.ofString(json,
        StandardCharsets.UTF_8))
        .build();
    try {
      HttpResponse&lt;String&gt; response = client.send(request,
      HttpResponse.BodyHandlers.ofString());
      System.out.println("Status Code: " +
      response.statusCode());
      System.out.println("Response Body: \n" +
      response.body());
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    }
  }
}</pre>			<p>This example simply sends a <strong class="source-inline">POST</strong> request to a simulated URL with a JSON package that contains <span class="No-Break">user information.</span></p>
			<p>Making use of the <strong class="source-inline">HttpClient</strong> library can simplify<a id="_idIndexMarker566"/> the process of developing code<a id="_idIndexMarker567"/> that interacts with <span class="No-Break">web services.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor200"/>API integration</h1>
			<p>When we build Java web <a id="_idIndexMarker568"/>applications, we can integrate with external APIs to extend the functionality of our applications. An example would be a weather service API that can be used to display the local temperature on a site. For this section, we will<a id="_idIndexMarker569"/> focus on the <strong class="bold">Representational State Transfer</strong> (<strong class="bold">RESTful</strong>) services because those are the most common type of <span class="No-Break">web API.</span></p>
			<p>The RESTful APIs use standard HTTP methods, such as the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> examples from the previous section. As you would expect, RESTful APIs communicate primarily through HTTP data exchanges using JSON and <span class="No-Break">XML formats.</span></p>
			<p>When we implement an API, we first learn what its required request methods are, as well as the prescribed format for requests and responses. It is increasingly common for APIs to require authentication, so that might be something you will need to contend with using API keys or other <span class="No-Break">authorization techniques.</span></p>
			<p>The example that follows demonstrates<a id="_idIndexMarker570"/> a simple application that implements a <span class="No-Break">weather API:</span></p>
			<pre class="source-code">
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
public class WeatherApiExample {
  public static void main(String[] args) {
    HttpClient client = HttpClient.newHttpClient();
    String apiKey = "your_api_key_here";
    String city = "Florence";
    String uri = String.format("https://api.fakeweatherapi.com/v1/
    current.json?key=%s&amp;q=%s", apiKey, city);
    HttpRequest request = HttpRequest.newBuilder()
      .uri(URI.create(uri))
      .GET()
      .build();
    try {
      HttpResponse&lt;String&gt; response = client.send(request, 
      HttpResponse.BodyHandlers.ofString());
      System.out.println("Weather Data: \n" + response.body());
    } catch (IOException | InterruptedException e) {
        e.printStackTrace();
    }
  }
}</pre>			<p>Our example sends a <strong class="source-inline">GET</strong> request to an API, passing the city as a query parameter. The JSON response would contain the applicable weather data, which is printed on the <span class="No-Break">system’s display.</span></p>
			<p>API integration can be considered<a id="_idIndexMarker571"/> a core component of many Java web applications based on its <span class="No-Break">wide applicability.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor201"/>Security considerations</h1>
			<p>Whenever we add functionality<a id="_idIndexMarker572"/> to our Java applications that sends information external to our application or receives information from external sources, security becomes a paramount concern. This is especially true when we integrate APIs and HTTP into our Java applications. Let’s look at nine best practices that we can use to help ensure our HTTP communications are secure as well as when working <span class="No-Break">with APIs:</span></p>
			<ul>
				<li><strong class="bold">Use HTTPS instead of HTTP</strong>: If your Java web application handles sensitive, protected, or private<a id="_idIndexMarker573"/> information, you should use <strong class="bold">HTTP Secure</strong> (<strong class="bold">HTTPS</strong>) instead of HTTP when transmitting requests and responses. This will help prevent tampering and data interception. This<a id="_idIndexMarker574"/> will require you to obtain <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificates for <span class="No-Break">your servers.</span></li>
				<li><strong class="bold">Do not trust input</strong>: We should always validate input to our systems to include user input and data passed to our applications programmatically. We should not assume that this data is in the right format. After we validate the data, we may have to clean it so it can be used in our application. This approach can help mitigate<a id="_idIndexMarker575"/> nefarious operations such as <span class="No-Break"><strong class="bold">SQL injections</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Authenticate</strong>: Whenever possible, identify the users and systems that your application interacts with. The previously mentioned API keys come into <span class="No-Break">play here.</span></li>
				<li><strong class="bold">Authorize</strong>: Once a user or system has been authenticated, we should ensure that they have permission to perform specific operations in your application. Not every user will have the same level <span class="No-Break">of authority.</span></li>
				<li><strong class="bold">Protect API keys</strong>: We have already mentioned the importance of API keys and their applicability to addressing security concerns. API keys are like passwords; we must protect them from exploitation. We do not want to hardcode these keys in our applications; instead, we should store them in encrypted configuration files, so they are protected from <span class="No-Break">unauthorized eyes.</span></li>
				<li><strong class="bold">Use security headers</strong>: We have the option of using <strong class="bold">HTTP security headers</strong>. Here are <span class="No-Break">some</span><span class="No-Break"><a id="_idIndexMarker576"/></span><span class="No-Break"> details:</span><ul><li><strong class="bold">Content Security Policy</strong> (<strong class="bold">CSP</strong>): This helps prevent XSS attacks<a id="_idIndexMarker577"/> by explicitly identifying resources that are permitted to <span class="No-Break">be loaded</span></li><li><strong class="bold">HTTP Strict Transport Security</strong> (<strong class="bold">HSTS</strong>): This can be used to enforce<a id="_idIndexMarker578"/> secure <span class="No-Break">server connections</span></li></ul></li>
				<li><strong class="bold">Treat sensitive data carefully</strong>: This should go without saying, but sensitive data deserves special attention. For example, never transmit sensitive data in URLs, because they can be logged and then leaked. Also, ensure that sensitive data (such as passwords) is encrypted or hashed when you store it. Additionally, use a technique such as <strong class="bold">tokenization</strong> to securely handle <span class="No-Break">payment</span><span class="No-Break"><a id="_idIndexMarker579"/></span><span class="No-Break"> information.</span></li>
				<li><strong class="bold">Update dependencies</strong>: We should periodically check that our dependencies and Java libraries are up to date. We do not want to use older versions of components that might have <span class="No-Break">known vulnerabilities.</span></li>
				<li><strong class="bold">Log and monitor</strong>: As with all of our software, we want to ensure we implement proper logging and then monitor operations to ensure the logs do not contain <span class="No-Break">sensitive information.</span></li>
			</ul>
			<p>Security should always be at the forefront<a id="_idIndexMarker580"/> of developers’ minds. It is especially important when working with HTTP and external APIs. Adhering to the nine best practices discussed in this section is a good start to developing a security strategy for your Java <span class="No-Break">web applications.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor202"/>Performance optimization</h1>
			<p>Now that we have sufficiently covered<a id="_idIndexMarker581"/> what HTTP is, its applicability to Java, and some techniques and best practices, let’s consider performance-related issues specific to using HTTP with Java. Our goals for looking at performance issues are to enhance the user experience and improve our application’s scalability, resilience, <span class="No-Break">and maintainability.</span></p>
			<p>Let’s look at seven specific areas regarding performance optimization when using HTTP in our <span class="No-Break">Java applications:</span></p>
			<ul>
				<li>The first area focuses on the <strong class="bold">HTTP client</strong>. When using HTTP clients, we<a id="_idIndexMarker582"/> want to use them efficiently. Here are three techniques for <span class="No-Break">doing that:</span><ul><li>We discussed connection pooling in <a href="B21942_10.xhtml#_idTextAnchor172"><em class="italic">Chapter 10</em></a>, <em class="italic">Connection Pooling</em>, and can apply those same principles to HTTP connections. This can help reduce the computational overhead and improve performance. The <strong class="source-inline">HttpClient</strong> library includes support for <span class="No-Break">connection pooling.</span></li><li>We can use <strong class="source-inline">HTTP Keep-Alive</strong> to keep connections open for multiple requests to a common host. This will reduce the number of communication handshakes and <span class="No-Break">improve latency.</span></li><li>We can often leverage asynchronous requests (that is, API calls) to improve <span class="No-Break">application flow.</span></li></ul></li>
				<li><strong class="bold">Caching</strong> is another area to look at to help optimize<a id="_idIndexMarker583"/> performance. There are a few caching strategies that can be used to <span class="No-Break">improve performance:</span><ul><li>Cache at the application level for frequently accessed data. The specifics depend on your application and what data it uses. There are even caching frameworks such as Caffeine that can <span class="No-Break">be used.</span></li><li>Using HTTP caching headers (that is, Cache-Control) can help you control <span class="No-Break">response caching.</span></li><li>If your Java web application deals<a id="_idIndexMarker584"/> with static content (that is, images), you can consider using <strong class="bold">Content Delivery Networks</strong> (<strong class="bold">CDNs</strong>) to cache your content closer to your users (i.e., storing data on servers in specific geographic areas). This approach can significantly shorten load times <span class="No-Break">for users.</span></li></ul></li>
				<li>A third area to consider is <strong class="bold">optimizing data transfers</strong>. There are two specific approaches to improving<a id="_idIndexMarker585"/> data transfers<a id="_idIndexMarker586"/> that are <span class="No-Break">worth considering:</span><ul><li>To the fullest possible extent, we should minimize data requests. Obviously, the fewer data requests there are, the better our applications will perform. Achieving this takes a purposeful approach to API integration design. We can use specific API endpoints to only obtain data necessary for the task instead of a <span class="No-Break">bloated package.</span></li><li>There are data compression tools we can use to decrease the size of the HTTP responses. This approach<a id="_idIndexMarker587"/> has become commonplace, so your web server is apt to support this type <span class="No-Break">of compression.</span></li></ul></li>
				<li><strong class="bold">API performance</strong> is a fourth area of concern. Here are two<a id="_idIndexMarker588"/> techniques for optimizing <span class="No-Break">API performance:</span><ul><li>When possible and applicable, implement rate limitations on your APIs. This can help prevent abuse and denial of service attacks. It can also help maintain <span class="No-Break">service quality.</span></li><li>If your application and APIs support batch requests, it is worth implementing. This can have a profound impact on <span class="No-Break">system performance.</span></li></ul></li>
				<li><strong class="bold">Code optimization</strong> is a fifth area of concern. Profiling tools<a id="_idIndexMarker589"/> such as VisualVM and JProfiler can be employed to help identify performance bottlenecks. The tools can be used to target memory and CPU operations. See <a href="B21942_14.xhtml#_idTextAnchor250"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">Profiling Tools</em>, for <span class="No-Break">more information.</span></li>
				<li><strong class="bold">SQL optimization</strong> is another area of concern. SQL queries<a id="_idIndexMarker590"/> can be optimized to reduce database load and execution time. A thorough review of database schemas can help identify additional opportunities for optimization. See <a href="B21942_15.xhtml#_idTextAnchor288"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">Optimizing Databases and SQL Queries</em>, for <span class="No-Break">additional information.</span></li>
				<li>Our last area of performance concern when dealing<a id="_idIndexMarker591"/> with HTTP in Java is <strong class="bold">scalability</strong>. The two major techniques in this area are load balancing to help improve application availability and microservices architecture for <span class="No-Break">better performance.</span></li>
			</ul>
			<p>Optimizing every aspect of our Java applications<a id="_idIndexMarker592"/> is important if we are to achieve our goal of developing high-performance applications. Working with HTTP in Java represents a unique set of challenges and opportunities <span class="No-Break">for optimization.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor203"/>Summary</h1>
			<p>This chapter highlighted the role that HTTP plays in Java web application development. The purpose of HTTP was stated as being to facilitate dynamic web applications. Our coverage of this topic showed that HTTP can be used efficiently and securely. We also looked at Java web applications, API integrations, security, and performance optimization strategies. Since the fields of HTTP and Java web application development are so vibrant, it is important to be aware of changes and updates as they <span class="No-Break">become available.</span></p>
			<p>The next chapter, <a href="B21942_12.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Frameworks for Optimization</em>, introduces strategies for using asynchronous input/output, buffered input/output, and batch operations to create high-performance Java applications. The chapter also covers frameworks for microservices and <span class="No-Break">cloud-native applications.</span></p>
		</div>
	

		<div class="Content" id="_idContainer029">
			<h1 id="_idParaDest-205" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor204"/>Part 4: Frameworks, Libraries, and Profiling</h1>
			<p>Leveraging the right frameworks and libraries can greatly enhance application performance. This part examines various frameworks designed for optimization and introduces performance-focused libraries that can be integrated into Java projects. Additionally, it provides a guide to using profiling tools for the identification and resolution of performance bottlenecks. The chapters in this section are designed to equip you with the tools and knowledge needed to fine-tune your applications for <span class="No-Break">maximum efficiency.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21942_12.xhtml#_idTextAnchor205"><em class="italic">Chapter 12</em></a>, <em class="italic">Frameworks for Optimization</em></li>
				<li><a href="B21942_13.xhtml#_idTextAnchor227"><em class="italic">Chapter 13</em></a>, <em class="italic">Performance-Focused Libraries</em></li>
				<li><a href="B21942_14.xhtml#_idTextAnchor250"><em class="italic">Chapter 14</em></a>, <em class="italic">Profiling Tools</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer030">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer031">
			</div>
		</div>
	</body></html>