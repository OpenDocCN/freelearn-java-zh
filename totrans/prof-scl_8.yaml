- en: Chapter 8. Domain Specific Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the core concepts of functional programming
    such as pure functions, immutability, and higher-order functions. We introduced
    some of the design patterns that are prevalent in large functional programs. Finally,
    we covered two popular functional programming libraries called Cats and Doobie
    and used them to write some interesting programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover how Scala makes it possible to write powerful
    DSLs by providing a few interesting language features. We'll have a brief look
    at what DSLs are in general terms. We'll also cover a DSL that you'll very likely
    be using if you're going to work with Scala professionally. Finally, you will
    implement your own DSL.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrates how Scala makes it possible to write powerful Domain
    Specific Languages (DSLs) by providing a few interesting language features.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the use of Domain Specific Languages (DSLs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the DSL `ScalaTest`, a popular testing library for Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your own DSLs in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the additional libraries and tools that will be useful beyond this
    book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSLs and Types of DSLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A domain specific language is, as the name suggests, a language that's specialized
    for a specific domain. Contrast that with a language like Scala, which is a general-purpose
    language in the sense that it's applicable across a broad range of domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'By restricting the domain, you''d hope to make a language that''s less comprehensive
    but better suited to solving a specific set of problems within a domain. A well-constructed
    DSL will make it easy to solve problems within a domain and make it hard for the
    user to make mistakes. DSLs come in many different shapes and sizes, but you can
    roughly separate them into two groups: external DSLs and internal DSLs.'
  prefs: []
  type: TYPE_NORMAL
- en: External DSLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: External DSLs are written "outside" of the host language (the language that's
    used to implement the DSL is called the host language). That means you'll have
    to parse the text, evaluate it, and so on, just as if you were creating a general-purpose
    programming language. We won't be creating an external DSL, so we won't cover
    the topic much further.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of an external DSL is `DOT`, which is used to describe graphs.
    Here''s an example of a simple `DOT` program, which produces the graph you see
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![External DSLs](img/8_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code that can be written to implement the graph above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, `DOT` is specialized for the domain of describing graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on `DOT`, please refer to [https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)).
  prefs: []
  type: TYPE_NORMAL
- en: Internal DSLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Internal DSLs are embedded in the host language and can be separated into two
    groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shallow:** Operations directly use the host language''s operations (for example,
    `+` uses Scala''s `+`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep:** You build up your abstract syntax tree (AST) and evaluate it just
    as you would with an external DSL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll be writing an internal shallow DSL in this chapter, which is also, in
    my experience, the most common type of DSL you'll encounter when you're using
    various Scala libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '`ScalaTest` is a very popular testing library for Scala. It has a set of different
    DSLs for writing your test specifications. We''ll look at `ScalaTest` in depth
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: You now have a very basic understanding of what DSLs are and how they can be
    grouped into internal/external and shallow/deep. In the next section, we'll look
    at `ScalaTest` and how that library uses DSLs to make it easy to write test specifications.
  prefs: []
  type: TYPE_NORMAL
- en: ScalaTest – A Popular DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ScalaTest` was introduced in [Chapter 1](ch01.html "Chapter 1. Setting up
    the Development Environment"), *Setting up the Development Environment*, but as
    we''ll use it extensively in this lecture, we''ll do a little recap here and make
    sure that everyone has a working `ScalaTest` environment.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll have a look at a popular library for testing your Scala
    programs, `ScalaTest`, and see how the library uses DSLs to allow its users to
    write readable tests in various styles.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of looking at `ScalaTest` is twofold. First off, `ScalaTest` is
    a widely used testing library for Scala projects, so you're likely to end up using
    it when you're using Scala professionally. Secondly, it's a good example of how
    to use DSLs to make your code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, you should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify how to use `ScalaTest` in your own projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the various styles that `ScalaTest` offers and be able to pick the
    one that's relevant to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write `ScalaTest` tests using the `F``latSpec` style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding ScalaTest to Your Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ScalaTest` is a Scala library like any other, so you simply add it as a library
    dependency to your project. As we''re using SBT in this book, we''ll use that
    as an example here. Create a new SBT project with the following `build.sbt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, refer to the installation section ([http://www.scalatest.org/install](http://www.scalatest.org/install))
    from the documentation if you want to see how to use it outside of SBT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple test and place it in your `src/test/scala/com/example/ExampleSpec.scala`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that your setup is correct, start an SBT session in the root of your
    project and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ll be writing a few tests using `ScalaTest` in the following section,
    it''s important that you have a correctly configured SBT project that you can
    use for the exercises. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new SBT project using the previous `build.sbt` definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new test file at `src/test/scala/com/example/ExampleSpec.scala` with
    the previous contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests using the `sbt test` command and make sure that it has detected
    the tests and that they pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've seen how to add `ScalaTest` to your Scala project and how to run the
    tests using SBT. You should now have a correctly configured Scala project that
    you can use for the remainder of the exercises in this chapter. In the next section,
    we'll have a look at the various styles of tests you can write using `ScalaTest`.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of ScalaTest Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ScalaTest offers a selection of different styles that you can use when you're
    writing your tests. What style to use depends on your team's experience and preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''ll have a look at some of the different styles so you
    can get a feeling for what style you prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FunSuite** is a simple style that will be familiar to most people:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FlatSpec** is very similar to `FunSuite` but it focuses more on Behavior-Driven
    Design (BDD) by forcing you to name your tests in a manner that reads more like
    a specification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FunSpec** is a good general-purpose style for writing specification-style
    tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FreeSpec** focuses on specification-style testing but doesn''t enforce any
    structure upon your tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**PropSpec** is for if you want to write tests exclusively in terms of property
    checks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FeatureSpec** is primarily intended for acceptance testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: `FunSuite`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the test case we created in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are two internal DSLs in action here. The first one is used to write your
    test specifications in the readable form of `"X" should "Y" in { <code> }`. This
    style is made available by extending `FlatSpec`. The other DSL is used to write
    your assertions in the form of `<expression> should be <expression>`, which is
    made available by extending `Matchers`.
  prefs: []
  type: TYPE_NORMAL
- en: The DSLs are implemented as a combination of classes and extension methods,
    but we'll look into that in greater detail when we implement our own little DSL
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing ScalaTest Styles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to get a feeling for the different styles is to use them. Select
    three of the styles from the previous list and convert the following test to those
    styles.
  prefs: []
  type: TYPE_NORMAL
- en: Continue using the Scala project you created in the previous activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file for each style you've selected. If you picked `FunSpec`, then
    create a `FunSpecExample.scala` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each style, convert the following test into a test that uses that style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've seen the different styles that `ScalaTest` offers and have a rough feeling
    for the difference between them.
  prefs: []
  type: TYPE_NORMAL
- en: '`ScalaTest` is a testing library that uses DSLs to make it possible to write
    very readable tests. We have seen how you can add it to your own Scala projects,
    we got an overview of the different styles that it supports, and we have written
    a few tests using different styles. In the next section, we''ll look at the Scala
    features that Scala provides which make it possible to write DSLs in Scala.'
  prefs: []
  type: TYPE_NORMAL
- en: Language Features for Writing DSLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at the Scala features that make it easy to write
    small DSLs:'
  prefs: []
  type: TYPE_NORMAL
- en: Flexible syntax for method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By-name parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension methods and `Value` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use all of these features in the next section when we create our own DSL
    in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible Syntax for Method Invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scala has a flexible syntax for method invocations that makes it possible to,
    in some cases, omit the dot ( `.`) and parentheses ( `()`) when invoking methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For methods that are of arity-`0`, meaning they don't take any parameters, the
    parentheses can be omitted and you can use the postfix notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For methods with an arity of `1` or more, meaning they take one or more parameters,
    it's possible to write the method using infix notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of using infix notation when invoking `filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And here's an example of omitting the parentheses when invoking `toUpperCase:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This allows you to write code that reads more like prose, which is a nice option
    to have when you're creating your DSL.
  prefs: []
  type: TYPE_NORMAL
- en: By-Name Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By-name parameters make it possible to specify that a parameter that''s passed
    to a function shouldn''t be evaluated until it''s actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that both the `condition` and `body` parameter types have a `=>` prepended.
    That's how you specify that a parameter is a by-name parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use by-name parameters to enable the user to write the `… in { … code
    … }` blocks for the tests cases when we're writing our own DSL later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that by-name parameters are evaluated every time they're
    referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Extension Methods and Value Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extension methods are a technique for adding new methods to already existing
    Scala classes. `Value` Classes is a Scala feature that, among other things, makes
    it possible to create extension methods without incurring any allocation overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example of a `Value` class that adds an extension method to `String:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With this definition, there will be an implicit conversion from `String` to
    `StringExtension`, which allows you to invoke `repeat` on a string as if it had
    always been there (note the use of the postfix notation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll use extension methods and Value classes to add the `should` method to
    `String` when we're writing our own DSL later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how Scala's features make it possible to write nice internal DSLs
    in Scala. We'll now see how to write a custom DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Small DSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll reimplement some `FlatSpec` `ScalaTest` DSLs in order
    to see how to implement DSLs in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll have a look at a simple way to model test cases in Scala using
    case classes. Then, we'll have a look at how to create a little DSL for creating
    those test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Test Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can create a DSL, we need to have something to create a DSL for.
    In our case, we want to create a DSL for specifying tests, so let''s have a look
    at how we could model tests using case classes in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create an algebraic data type that represents the result of running
    a test case. The result can either be a failure that contains a message regarding
    the failure, or a `TestSuccess` that simply indicates that the test passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, we define two simple case classes. `TestDescription` contains the description
    of a test case, whereas `TestCase` has such a description and a `run` function
    that can be used to invoke the test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this simple model, we can describe a test case like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `TestResult.wrap` is a method with the signature `def wrap(body: => Unit):
    () => TestResult`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this looks nothing like the nice test cases we wrote in the previous section
    using the `FlatSpec` DSL, so let's have a look at how we can create a DSL that
    creates a `TestCase` like the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: DSL for TestCase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by looking at the part of the DSL that makes it possible to write
    the test specification, that is, the part of the DSL shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From the last section, it should be clear that this is using an extension method
    `should` on `String` that''s invoked using infix notation. So, we''ll add an extension
    method to `String` to create `TestDescription` using the little DSL from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implicit value class in scope, we can create a `TestDescription`
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This reduces our `TestCase` creation to the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is slightly better, but far from ideal. Let''s continue. Now, let''s focus
    on the remaining part of the DSL, the part that makes it possible to write the
    actual test case. It''s the part of the DSL shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, in the previous section, we saw that we could write such expressions
    in Scala using infix notation and by-name parameters. Now, to allow the creation
    of `TestCase` instances using the DSL, we''ll have to add a method to `TestDescription`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, we can now write our test case using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And, with that, we're done with creating our little DSL for writing test case
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: We're not trying to create a full-featured testing library here, but it would
    be fun to be able to run the tests, so let's have a look at how to implement a
    test runner.
  prefs: []
  type: TYPE_NORMAL
- en: As we've modeled our test cases using Scala classes, it's quite simple to create
    a test runner that runs the tests and prints a nice little report.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ve seen how to use some of Scala''s features to very easily write a DSL
    to create test cases. By using the flexible syntax for method invocation, by-name
    parameters, and extension methods (through Value classes), you''ve managed to
    create an internal DSL that makes it possible to convert this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity: Creating a DSL to Specify Assertions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our DSL makes it possible to write `TestCase` instances easily. However, the
    assertions in our test cases don''t look very nice. Create a DSL to specify assertions.
    It should support the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Hint**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by modeling assertions using case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see the final result in the code for this chapter in `dsl/src/main/scala/com/example/Assertion.scala`
    and the usage in `dsl/src/main/scala/com/example/Assertion.scala/Main.scala.`
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Beyond This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will help you get a better overview of the Scala ecosystem and
    help guide your self-study after the book has ended, so you can continue to improve
    your Scala skills.
  prefs: []
  type: TYPE_NORMAL
- en: Various Scala Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this topic is to briefly introduce a couple of different Scala
    libraries for solving problems in different domains so that you can study the
    ones that are interesting to you after the book.
  prefs: []
  type: TYPE_NORMAL
- en: Akka
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first library we'll look at is one of the most popular libraries in the
    Scala ecosystem. It has been around for a long time—the first public release of
    the library was in 2010—and it's used in production by a large number of big organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its main abstractions are `Actor` and `Streams`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Actors` are a way to model concurrency without resorting to locks. You might
    have heard about them before if you''ve read about the programming language `Erlang`.
    An Actor is an entity that can receive and react to messages, spawn new `actors`,
    and send messages to other `actors`. Thus, you model your programs as a set of
    `actors` that communicate to each other by sending messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find more information about `Actors` here: [https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala](https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have to deal with streaming data, you can use Akka `Streams` to model
    your programs as transformations over data flowing from sources into sinks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about `Streams` here: [https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala](https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to build a distributed system in Scala, it is highly recommended
    to use Akka.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about Akka on its website: [https://akka.io/](https://akka.io/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apache Spark
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apache Spark is a library for processing large Scala datasets. Apache Spark
    was initially developed at UC Berkeley in 2009, and in 2013 it was donated to
    the Apache Software Foundation and is now a Top-Level Apache Project with more
    than 1,000 contributors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write Spark programs in Java, Scala, Python, and R. You can write your
    own custom data analytics programs using the Spark API, or you can use one of
    the high-level APIs: Spark SQL for SQL and structured data processing, MLlib for
    machine learning, GraphX for graph processing, and Spark Streaming.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in big data processing, take a look at Spark.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about Spark on its website: [https://spark.apache.org/](https://spark.apache.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Shapeless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shapeless is a type class and dependent type-based generic programming library
    for Scala. It was initially written in 2011 by Miles Sabin and is now used by
    many companies to write type-safe code. It is also used internally by many libraries.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major features of Shapeless is that it enables automatic derivation
    of type classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Shapeless, you can get the compiler to type-check things that you might
    not have thought possible. Some examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: Heterogeneous lists, that is, lists where each element can be of different types
    and where the Scala compiler keeps track of the types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the compiler check that collections are of a given length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we''ve seen three different Scala libraries that can be used
    to solve problems in the following domains:'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uncovered Language Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of this topic is to briefly introduce you to some of the language
    features that we haven''t covered, and show you where to go if you want to learn
    more about these topics. These features are:'
  prefs: []
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Macros are a programming language feature that makes it possible to write functions
    that take the AST of their arguments as input and produce a new AST, effectively
    allowing you to write programs that generate other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Macros come in many shapes and sizes. In this section, we'll have a look at
    how to use macros in Scala. Experimental support for Scala macros was shipped
    with Scala 2.10, and, since then, they have been improved with every release.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the official documentation for macros on the Scala documentation
    website here: [https://docs.scala-lang.org/overviews/macros/overview.html.](https://docs.scala-lang.org/overviews/macros/overview.html.)'
  prefs: []
  type: TYPE_NORMAL
- en: Def Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Def macros are macros that are defined as Scala functions which reference a
    macro implementation. Let''s have a look at a very simple macro that takes a `String`
    and returns an uppercase version of that string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uppercase` method is how the macro is exposed to the users of the macro.
    The actual macro implementation is `uppercaseImpl`, which has two parameter lists.
    The first parameter contains a single argument, the `Context`, which contains
    information collected by the compiler at the call site of the macro. The second
    parameter contains the Scala abstract syntax trees of the expression of type `String`
    that the macro was invoked with. Let''s see how to invoke this macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This looks very much like a normal Scala method invocation; however, the uppercasing
    of the argument happens at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the macro as implemented here only works with `String` literals; if
    you invoke it with anything else, you'll crash the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implicit macros make it possible to reference a macro in the implementation
    of an implicit method. One use case of this is to write macros that can generate
    an instance of a given type class, given any type `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of writing individual type class instances for all of your types,
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You could instead define an implicit macro that can generate an instance of
    the type class for any given type `T`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Quasiquotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible for you to use Scala''s powerful String Interpolation feature
    to make it to write ASTs inside of Strings, so you don''t have to construct the
    ASTs by hand. That is, you can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have very likely used reflection in other programming languages, such as
    Java or Python. Reflection makes it possible for a program to inspect and sometimes
    modify itself. You can think of macros as compile-time reflection and of the reflections
    we'll look at now as runtime reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'With runtime reflection, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the types of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate new objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access or invoke members of an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example of how to inspect types at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This example uses `scala.reflect.runtime.universe` to implement a method that,
    for a given object of type `T,` will get the `TypeTag` for that type. Given the
    `TypeTag,` we can access `Type` through `tpe` and then get the list of the members
    of the type through `decls`. The example then filters out any member whose name
    is shorter than five ``characters and prints their `name` and `type`.``
  prefs: []
  type: TYPE_NORMAL
- en: '`Note`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Reflection can in some cases incur a non-negligible runtime overhead. If you''re
    using it in performance-sensitive places, make sure to benchmark the results.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`In this subsection, we''ve briefly covered two interesting Scala language
    features and provided multiple links for further study of these features so that
    you can improve your Scala skills after this book.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Resources to Keep You Updated`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`In this subsection, we''ll have a look at how you can keep up to date with
    the development of the Scala programming language, as well as its ecosystem.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scala Improvement Process`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`The Scala Improvement Process (SIP) and Scala Platform Process (SPP) are how
    changes are made to the Scala Programming Language and The Scala Standard Library,
    respectively. If you want to make a change to either, you can make a proposal
    for the change, which will then be reviewed and potentially accepted.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Note`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`You can find a list of all the current SIPs here: [https://docs.scala-lang.org/sips/all.html](https://docs.scala-lang.org/sips/all.html).`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scala Times`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`The Scala Times is a weekly newsletter that features interesting blog posts
    about Scala and gives a short recap of the various Scala libraries that have been
    released in the previous week.`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Note`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`You can read more about it and subscribe to the newsletter here: [http://scalatimes.com/](http://scalatimes.com/)`'
  prefs: []
  type: TYPE_NORMAL
- en: '``# Summary    In this chapter, we covered how Scala makes it possible to write
    powerful Domain Specific Languages (DSLs) by providing a few interesting language
    features. We had a brief look at what DSLs are in general terms. We have also
    covered a DSL that you''ll very likely be using if you''re going to work with
    Scala professionally. Finally, we have implemented our own DSL.    We now come
    to the end of this book. In this book, we covered all the professional concepts
    of the Scala language, from setting up the development environment to writing
    your own custom DSLs. We covered the object-oriented and functional programming
    aspects of the Scala language. We also covered some useful libraries that are
    used in Scala, such as `Cats` and `Doobie`. Finally, we covered the additional
    resources and tools that will help you to stay up to date in the industry.``'
  prefs: []
  type: TYPE_NORMAL
