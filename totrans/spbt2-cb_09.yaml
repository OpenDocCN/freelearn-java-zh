- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery using Spring Cloud Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Netflix—Feign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery using Spring Cloud Netflix—Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Cloud Netflix—Hystrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we have learned how to create an application, configure
    RESTful services, do testing, integrate metrics and other management components,
    and handle packaging and deployment, among other things. Now, the time has come
    to look at the world outside the application—the ubiquitous cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to make applications cloud-friendly, how
    to deal with the dynamic nature of the distributed applications running in the
    cloud, how to make our applications visible to the world, how to discover other
    service endpoints, how to call them, and how to handle various error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Cloud family of projects provides integration extensions for Spring
    Boot of various frameworks, which offer functionality for distributed service
    discovery, configuration, routing, service invocation, and more. Through the use
    of uniform API, we can add these concepts to our applications and later have the
    flexibility to change the specific implementation if such a need arises without
    making deep-cutting changes to our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by enhancing our `BookPub` project with base Spring Cloud modules
    by adding them to the main build configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `build.gradle` file located at the root of
    the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the application has been started, even though it seems like nothing new
    has happened, if we open our browser at `http://localhost:8081/actuator/env` (the
    management endpoint for environment), we will see new property sources appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `bootstrap.properties` file under the `src/main/resources` directory
    from the root of our project with the following content (the same properties should
    be commented out inside `application.properties` at this point):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Start the application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the application has been started, open our browser at `http://localhost:8081/env`
    and we will see new property sources appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive under the hood of how things work, let''s review the changes
    that we have made to our project. The first step was to enhance the `build.gradle`
    build configuration by importing a **Bill of Material** (**BOM**) declaration
    for a Spring Cloud release train—`mavenBom ''org.springframework.cloud:spring-cloud-dependencies:
    Finchley.BUILD-SNAPSHOT''`. While we could have selectively imported explicitly-defined
    versions of the `spring-cloud-context` and `spring-cloud-commons` libraries, by
    relying on a packaged BOM, we are sure that we will be using the correct versions
    of different artifacts that have been tested for compatibility with each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Specific versions of each Spring Cloud modules that are included in a particular
    Release Train can be seen at [http://cloud.spring.io/](http://cloud.spring.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by adding dependencies on the `spring-cloud-context` and `spring-cloud-commons`
    libraries, to illustrate the basic common facilities Spring Cloud provides, before
    diving into a specific starter integration such as `spring-cloud-netflix` or `spring-cloud-consul`.
    Those basic libraries provide a foundation of interfaces and common functionality
    that is being used to build upon in all the different cloud-specific integrations.
    Here is what their purpose is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-cloud-commons`: This provides a collection of shared common interfaces
    and base classes that define the notions of service discovery, service routing,
    load balancing, circuit breaking, feature capabilities, and some basic configuration.
    For example, this is the library that autoconfigures the environment with the `springCloudClientHostInfo`
    property source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-context`: This is the base foundation that is responsible for
    bootstrapping and configuring the various integrations, such as a specific implementation
    of service discovery like Consul, or a specific implementation of circuit breaker
    like **Hystrix**. This is achieved by creating an isolated Bootstrap application
    context, which is responsible for loading and configuring all the components before
    the main application is started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap application context gets created early on in the application start
    cycle and it is configured by a separate file—`bootstrap.properties` (a YAML variant
    is also supported). Since it is very typical for an application running in the
    cloud to rely on many external sources of configuration, service lookup, and so
    on, the purpose of the Bootstrap context is to configure those functions and obtain
    all of the necessary configuration from outside.
  prefs: []
  type: TYPE_NORMAL
- en: To clearly separate application configuration from Bootstrap, we put things
    that describe the application, or configure external configs, or other environmental
    variants like where to call for service discovery, into `bootstrap.properties`
    instead of `application.properties`. In our example, we have placed `spring.application.name`
    config into `bootstrap.properties`, because that information will be needed during
    the Bootstrap phase; it could be used to look up configuration from a remote config
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Since Bootstrap application context is indeed a real Spring application context,
    there exists a parent-child relationship between the two, where Bootstrap application
    context becomes the parent of the Spring Boot application context. This means
    that all the beans and the property sources defined in the Bootstrap context become
    available for consumption from within the application context as well.
  prefs: []
  type: TYPE_NORMAL
- en: When Spring Cloud is added to the application, it automatically provides the
    integration framework for specific Spring Cloud modules, like Spring Cloud Consul,
    to be plugged in via the use of the by now well-known `spring.factories` configuration
    declarations. The annotations provided inside `spring-cloud-commons`, namely `@SpringCloudApplication`,
    `@EnableDiscoveryClient`, `@EnableCircuitBreaker`, and the `@BootstrapConfiguraion`
    and `PropertySourceLocator` interfaces provided by the `spring-cloud-context`
    library, are designed to define the integration points to be used to self-configure
    specific components such as discovery clients like Consul, circuit breakers like
    Hystrix, or remote configuration sources like **ZooKeeper**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine those in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@SpringCloudApplication`: This annotation is like `@SpringBootApplication`, meta-annotation
    in nature, except it also wraps the `@EnableDiscoveryClient` and `@EnableCircuitBreaker`
    annotations in addition to also being meta-annotated with `@SpringBootApplication`.
    It is a good idea to use this annotation when you want to enable both the discovery
    client and the circuit breaker functionality in your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableDiscoveryClient`: This annotation is used to indicate that Spring Cloud
    should initialize the provided discovery client for service registry, depending
    on the included integration library, such as Consul, Eureka, ZooKeeper, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableCircuitBreaker`: This annotation is used to indicate that Spring Cloud
    should initialize the circuit breaker capabilities, based on the specific dependency
    of the integration library, such as Hystrix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropertySourceLocator`: This is used by the integration libraries to implement
    specific functionality of how to extract remote configuration from the provided
    datastore. Each integration module, providing ability to load remote configuration,
    would register an implementing bean of this type that exposes an implementation
    of `PropertySource` that is backed by the integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@BootstrapConfiguration`: This annotation is like the `@ManagementContextConfiguration`
    annotation, and is (mostly) a marker annotation geared to identify the key inside
    the `spring.factories` descriptor to indicate which configuration classes should
    be loaded during the Spring Cloud Bootstrap process and be part of the Bootstrap
    application context. Those configurations are read by `BootstrapApplicationListener`
    during startup and initialize the specified configurations. Typically, this is
    where the configuration classes, which define and expose `PropertySourceLocator`—implementing
    beans, are configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery using Spring Cloud Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a world of distributed computing, it is very common for services to become
    a disposable commodity. The typical life cycle of a service could be measured
    in days, if not in hours, and it is not unheard of for an instance to just crash
    for whatever reason, only to have a new one come up automatically seconds later.
    When the state of applications is so ephemeral, it becomes really hard to maintain
    a statically-connected architecture, with services knowing where exactly their
    dependent services are located, as the topology is always changing.
  prefs: []
  type: TYPE_NORMAL
- en: To help with this problem, the service discovery layer comes into play, maintaining
    a centralized and distributed state of service registrations, ready to reply on
    demand with the most current information. Applications register themselves upon
    startup, providing information about their location and possibly about their capabilities,
    level of service, health check status, and even more.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the book, in [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml),
    *Application Packaging and Deployment*, we were introduced to Consul, and used
    it for external application configuration consumption. In this recipe, we will
    continue to look further into the capabilities of Consul and will learn about
    how to use the `spring-cloud-consul` modules to automatically register our application
    with Consul.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following steps to set up service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `spring-cloud-commons` and `spring-cloud-context` modules with `spring-cloud-starter-consul-all`
    by modifying the `build.gradle` file located in the root of our project with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With Consul dependencies added, we will proceed with enabling our application
    to automatically register with the local agent upon startup by modifying the `BookPubApplication.java`
    file located under the `src/main/java/com/example/bookpub` directory from the
    root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that Consul was successfully installed using the steps described in the *Setting
    up Consul* recipe in [Chapter 6](c2ad0549-f6af-458f-8043-3fb5227a1e50.xhtml),
    *Application Packaging and Deployment*, we should be able to start it by running
    `consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul` and our Terminal
    window should display the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the Consul agent is up and running successfully, we will proceed by starting
    our application by running `./gradlew clean bootRun`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we watch the startup logs scroll by, there are a couple of interesting entries
    that indicate the application is interacting with the agent, so watch for the
    following content in the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just to verify that our application has registered and is in communication with
    the local Consul agent, let's open `http://localhost:8081/actuator/consul` in
    the browser to see the Consul agent information, as shown in the following screenshot:![](img/8cb7c381-b98e-44d9-b5c1-744a19fd90d9.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we added `spring-cloud-starter-consul-all` as a build dependency, it automatically
    pulled all the necessary components to enable Consul functionality for our application.
    We automatically got the `spring-cloud-consul-binder`, `spring-cloud-consul-core`,
    `spring-cloud-consul-config`, and `spring-cloud-consul-discovery` artifacts added
    to our classpath. Let''s take a look at the them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-cloud-consul-core`: This artifact provides base autoconfiguration to
    expose generic `ConsulProperties`, as well as the `ConsulClient` initialization
    and setting of the `/consul` management endpoint, if the Spring Boot Actuator
    functionality is enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-consul-config`: This provides the `ConsulPropertySourceLocator`
    implementation, used during Bootstrap, to configure the `ConsulPropertySource`
    bean, which allows remote configuration consumption from the Consul key/value
    store. It also sets up a `ConfigWatch` change observer, which fires `RefreshEvent`
    to the application context, if a configuration key value changes in Consul key/value
    store while the application is running. This allows for a possible configuration
    properties reload without having to redeploy and restart the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-consul-discovery`: This provides all the functionality and implementations
    needed for service discovery, service registration, and service invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-consul-binder`: This provides integration of Consul event functionality
    with Spring Cloud Stream Framework, enabling it to send and receive events from
    Consul and respond to them within the application. While outside of the scope
    of this chapter, more information can be obtained from [http://cloud.spring.io/spring-cloud-stream/](http://cloud.spring.io/spring-cloud-stream/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While addition of `spring-cloud-consul-config` to the classpath will automatically
    register `ConsulPropertySource`, it is not so for the `spring-cloud-consul-discovery`
    module. The service discovery functionality is more intrusive and thus requires
    an additional step of acknowledgement from the developers to indicate that it
    is indeed wanted. This is accomplished by adding the `@EnableDiscoveryClient`
    annotation to the main application class; in our case it is `BookPubApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `@EnableDiscoveryClient` annotation is added, Spring Cloud (`EnableDiscoveryClientImportSelector`
    class from the `spring-cloud-commons` module, to be more precise) scans all `spring.factories`
    files for the presence of the `org.springframework.cloud.client.discovery.EnableDiscoveryClient`
    key, and loads all the associated configurations into the main application context.
    If we look inside the `spring.factories` file located in the `spring-cloud-consul-discovery` JAR
    under the `META-INF/` directory, we will see the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that when the discovery client is enabled, `ConsulDiscoveryClientConfiguration`
    will be consumed and all of its defining beans will be added to the application
    context.
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach can be used if a custom service discovery mechanism is being
    used. One will need to create a custom configuration class, exposing a custom
    implementation of the `DiscoveryClient` interface, and configure it in the `spring.factories` file
    bundled within the archive. Once that JAR gets loaded, the configuration will
    be automatically consumed if discovery client functionality is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Consul libraries provide very fine-grained ability to configure
    and pick and choose the selected functions, if not all apply for a particular
    use-case. For detailed information about various configuration and usage options
    see [http://cloud.spring.io/spring-cloud-consul/](http://cloud.spring.io/spring-cloud-consul/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Netflix – Feign
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how to enable service discovery capability
    for our application in order to be able to register our service with the world
    as well as to know what other services exist and where they are located. This
    recipe will help us better interact with that information and consume those services
    without having to explicitly code any logic to handle service discovery and all
    of the related concerns that come with it.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this goal, we will look at another Spring Cloud integration, provided
    by the Spring Cloud Netflix module family—Netflix Feign. Feign, which makes writing
    Java HTTP clients easier. Its purpose is to simplify the process of binding service
    API calls to their corresponding HTTP API counterparts. It provides automatic
    service mapping and discovery, ability to translate Java types to HTTP request
    URL paths, parameters and response payloads, as well as error handling.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, in this recipe, we will be creating a `Client` controller,
    which will act as an external client of our `BookPub` application service, calling
    our APIs via Feign-annotated Java service interfaces, relying on Consul to provide
    service discovery functionality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by adding Netflix Feign module dependencies to our project. Let''s
    modify our `build.gradle` file located in the root of our project with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the dependency added, our next step is to create a Java API interface describing
    how we want to define our interaction with the `BookPub` service. Let's create
    an `api` package under the `src/main/java/com/example/bookpub` directory from
    the root of our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the newly-created `api` package, let''s create our API class file named
    `BookPubClient.java` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have defined the API, it is time to tell our application that we want
    to enable Feign support. We will do that by making a change to the `BookPubApplication.java`
    file located under the `src/main/java/com/example/bookpub directory` from the
    root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create a client controller to invoke `BookPubClient` by making
    a new file named `ClientController.java` under the `src/main/java/com/example/bookpub/controllers`
    directory from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With everything set and done, let's start the application by executing the `./gradlew
    clean bootRun` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the Consul agent is also running in the background, otherwise
    service registration will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is up and running, let's open `http://localhost:8080/client/book/978-1-78528-415-1`
    in the browser to see the Consul agent information, as shown in the following
    screenshot:![](img/42791c29-c531-46b3-bcda-be2db8c760a9.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we look at the application console logs, we will also see entries indicating
    that our Feign client is initialized and functioning. You should see something
    similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'One last thing that we should do is to get our tests to work with all the newly
    added frameworks. Because Spring Cloud does not add itself to the test life cycle,
    we should explicitly disable any reliance on beans created by Spring Cloud libraries
    during tests. To do so let''s add to our `application.properties` file located
    under the `src/test/resources` directory from the root of the project of the following
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add a Mock dependency on `BookPubClient` into the `JpaAuthorRepositoryTests.java`
    and `WebMvcBookControllerTests.java` files located under the `src/test/java/com/example/bookpub`
    directory from the root of the project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to what we saw in the previous recipe, the use of the `@EnableFeignClients`
    annotation on the main application class, `BookPubApplication`, explicitly tells
    Spring Cloud that it should scan for all the interfaces annotated with `@FeignClient`
    and create service client implementations based on their definitions. The `@EnableFeignClients`
    annotation is similar in nature to the `@ComponentScan` one, providing attributes
    to control which packages to scan for the `@FeignClient` annotated classes or
    explicitly list the API classes that should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, all Feign client implementations are configured using components
    defined in the `FeignClientsConfiguration` class, but one can provide alternative
    configuration classes using the `defaultConfiguration` attribute of the `@EnableFeignClients`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, every interface definition, annotated with `@FeignClient`, gets
    a service implementation consisting of a Java dynamic proxy object, which handles
    all the interface method calls (usually using `FeignInvocationHandler` to handle
    all the requests). The invocation handler is responsible for doing a few things.
  prefs: []
  type: TYPE_NORMAL
- en: Once any method is invoked, first the service instances are located using the
    provided discovery client (in our case it is `ConsulDiscoveryClient`) based on
    the `name` attribute of the `@FeignClient` annotation. In our example, we have
    declared the value of `name` attribute to be `http://BookPub-ch9`, so all the
    service instances from the registry which have their name set to `BookPub-ch9` will
    be returned as possible candidates. This name can be just a service name itself,
    or, as we did in our example, an optional protocol can be specified. This is a
    useful feature, as not all service discovery providers support ability to specify
    exactly how the service should be called, so if we want to make a secure call
    using HTTPS, we can explicitly specify the protocol to help Feign make the right
    call.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other configuration attributes available on the annotation,
    for example, to tell Feign to make a direct call to a specified URL instead of
    doing a service lookup, there is a `url` attribute that can be configured.
  prefs: []
  type: TYPE_NORMAL
- en: To see a complete list of possible attributes and their use-cases, go to [https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-feign).
  prefs: []
  type: TYPE_NORMAL
- en: The list of instances for a given service gets wrapped with an internal load
    balancer, provided by another Netflix library—Ribbon. It uses a specified algorithm
    to rotate between the instances of a service as well as to take the bad instances
    out of circulation if the discovery client says they are unhealthy.
  prefs: []
  type: TYPE_NORMAL
- en: To see a complete list of possible configuration options for things like load
    balancing rules, and other settings, go to [https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon](https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-ribbon).
  prefs: []
  type: TYPE_NORMAL
- en: When a specific instance has been determined, an HTTP request gets created,
    using the standard Spring `HttpMessageConverter` beans to transform the method
    arguments into HTTP request path variables and query parameters. After all that
    is done, the request gets sent using a configured HTTP client and the response
    gets converted into a return type declared on the API interface using the same
    converters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what `@FeignClient` annotation is all about and what happens
    under the hood once an API-defined method gets invoked, let's take a look at how
    to annotate the interface methods that should be translated into remote service
    calls. Conveniently, and done so on purpose, we can use exactly the same annotations
    as we are already used to, when declaring controller mappings inside the `@Controller`
    annotated classes. Each method in our API interface, which we want to map to a
    remote service, should be annotated with the `@RequestMapping` annotation. The
    `path` attribute corresponds to a URL path of the remote service we want to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we want to call our `BookController.getBook(...)` method, which
    translates to the `/books/{isbn}` URL path. This is exactly what we put as a value
    for the `path` attribute, and make sure we also annotate the `isbn` argument in
    our `findBookByIsbn(...)` method with `@PathVariable("isbn")` to link it to a
    `{isbn}` placeholder in the mapping template.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule of thumb, the `@RequestMapping` annotation functions exactly
    the same as if it were used in a controller, except the configuration relates
    to an outgoing request instead of an inbound one. It might be especially confusing
    when configuring the `consumes` attribute of the annotation, that is, `consumes
    = "application/json"`, because it indicates that it is a remote side that expects
    JSON as a content-type of the payload.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery using Spring Cloud Netflix – Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how to do service discovery using HashiCorp Consul and integrate
    it with our application. This recipe will go over an alternative, and a very popular
    service discovery framework from Netflix-Eureka. Eureka was developed by Netflix
    to help solve the problem of service discovery, health checking, and load balancing
    for their RESTful services in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Consul, Eureka is solely focused on the task of service discovery, and
    does not provide many additional functionalities, such as key/value store service
    or event delivery. It is, however, very good at what it does and should be considered
    a viable candidate for a service discovery solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get to the steps to add Eureka to our application, we need to get
    the Eureka service itself up and running. Thankfully, the Spring Cloud folks have
    been awesome enough to provide a sample project that makes creating an instance
    of Eureka server and running it a breeze. Let''s take a look at the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To get things up and running just go to [https://github.com/spring-cloud-samples/eureka](https://github.com/spring-cloud-samples/eureka)
    and git clone the `git@github.com:spring-cloud-samples/eureka.git` repository
    to your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that''s done, run `./gradlew clean bootRun` to start the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the server is up and running, we need to add the following dependencies
    to the `build.gradle` file located at the root of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Ironically, that’s all we had to do, at this point, we just restart our application
    by executing the `./gradlew clean bootRun` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the Eureka server is running in the background, otherwise, though
    the application will start, the `BookPubClient` calls will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Once the application is up and running, let's open `http://localhost:8080/client/book/978-1-78528-415-1` in
    the browser and we should see exactly the same response as in our previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just to see that our application did indeed register with Eureka, we can open
    the browser at the `http://localhost:8761` URL and we should see our service listed
    under instances list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a596791-b096-4a3a-9a67-1ed2ea7f1a73.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a seemingly effortless change, we have switched one service discovery provider,
    Consul, for another, Eureka. What looked like not much of a change on the outside
    actually did quite a bit of work under the hood. The reason we were able to do
    it so easily is the common set of APIs provided by the `spring-cloud-commons`
    and `spring-cloud-context` foundational libraries. Automated module loading support
    via the `spring.factores` descriptor allowed for transparent substitution in the
    initialization of a different service discovery provider. As long as we retained
    the `@EnableDiscoveryClient` annotation on our `BookPubApplication` class, Spring
    Cloud did the heavy lifting, taking care of loading the appropriate autoconfiguration
    files and setting up all the right beans to get our application working with Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: We had to remove the Consul dependency from our classpath at the very first
    step of the recipe, and that had to be done in order to disambiguate the `DiscoveryClient`
    implementation. Without doing so, our application context would have ended up
    with two different implementations of the `DiscoveryClient` interface, which in
    itself would not be bad, except that Spring Cloud would have to disambiguate and
    choose one, and might not choose the one we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we leave the `spring-cloud-starter-consul-all` dependency in our `build.gradle`
    file, and attempt to run the application, it will fail during startup and in the
    logs we will see the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the exception, Spring autowiring can't decide which one
    of the service registries should be used. This is because both Eureka and Consul
    automatically have created an instance of `Registration`, and the autowiring wants
    only one.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is a hard requirement for only having one registry, it is best not
    to configure multiple discovery client dependency libraries to avoid errors. If,
    for some reason, multiple libraries have to reside in the classpath, one should
    use configuration properties to explicitly enable/disable a specific client implementation.
    For example, both Consul and Eureka provide configuration to toggle the state.
    We can set `spring.cloud.consul.discovery.enabled=true` and `eureka.client.enabled=false`
    in `application.properties` if we prefer to use Consul to provide service discovery
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Cloud Netflix – Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we have looked at all the aspects that apply to having
    a successful microservice application running in the cloud environment. We have
    learned about how to integrate better into a dynamically changing ecosystem, consuming
    remote configuration properties, registering service, and discovering and calling
    other services. In this recipe, we will take a look at another very important
    aspect of operating in a distributed, highly-volatile cloud environment circuit
    breakers.
  prefs: []
  type: TYPE_NORMAL
- en: The particular implementation of circuit breaker functionality which we are
    going to look at is Netflix Hystrix. It provides a very powerful and convenient
    way to annotate our service calls and handle things like remote service failures,
    queue backups, overloads, timeouts, and so on. By having circuit breakers in an
    application, developers can ensure overall application stability if a particular
    service endpoint becomes overloaded by requests, or experiences an outage of any
    kind.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with Hystrix we need to add the `spring-cloud-starter-hystrix`
    library to our project. Let''s modify our `build.gradle` file located in the root
    of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the Hystrix dependency, we need to enable Hystrix for our application.
    Similar to how we enabled service discovery, we will do that by making a change
    to the `BookPubApplication.java` file located under the `src/main/java/com/example/bookpub`
    directory from the root of our project with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make a few changes to `BookController.java`, located under the `src/main/java/com/example/bookpub/controllers`
    directory from the root of our project, with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to Hystrix internal functionality, we also need to modify our entity models
    to have them eager-load the relational associations. In the `Author.java`, `Book.java`,
    and `Publisher.java` files located under the `src/main/java/com/example/bookpub/entity`
    directory from the root of our project, let''s make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Author.java`, make the following change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Book.java`, make the following change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Publisher.java`, make the following change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are ready to restart our application by executing the `./gradlew
    clean bootRun` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the application has started, let''s open `http://localhost:8080/books`
    in the browser and we should see an empty JSON list as a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fbec377-9b90-4f43-a942-f7665ff8c7bd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we have done three things after adding the Hystrix dependency
    library to our project. So, let''s take a look at each step in detail to learn
    what exactly happens:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableCircuitBreaker` annotation, similar to `@EnableDiscoveryClient`,
    or `@EnableFeignClients`, which explicitly indicates that we want Spring Cloud
    to load appropriate configurations from `spring.factories` from all the libraries
    which have the `org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker`
    key defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of Hystrix, it will load `HystrixCircuitBreakerConfiguration`, which
    provides the necessary configuration to enable the Hystrix functionality within
    the application. One of the beans it creates, is the `HystrixCommandAspect` class.
    It's purpose is to detect all the methods which are annotated with the `@HystrixCommand`
    annotation and wrap them with a handler to detect errors, timeouts, and other
    ill-behaviors, and deal with them appropriately, based on configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This `@HystrixCommand` annotation, provided by the Hystrix library, is designed
    to mark methods which represent `Hystrix-guarded commands`, that is, methods which
    we want to protect using Hystrix against cascading failures and overloads. This
    annotation has a number of attributes and can be configured in a variety of different
    ways, depending on the desired behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example we have used the most typical attribute—`fallbackMethod`, which
    allows us to configure an alternative method, with matching signature, which can
    be automatically called if the real method fails the invocation for whatever reason.
    This is the prime use-case, and it provides the ability to specify graceful degradation
    of service, using sensible defaults, if possible, instead of blowing up exceptions
    up the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used it to direct failed calls to the `getEmptyBooksList()` method, which
    returns a static empty list. This way, when the real `getAllBooks()` method fails,
    we gracefully degrade and return an empty collection, which renders nicely as
    a response JSON. In the situations when we do indeed desire a particular type
    of exception to be propagated up the stack, we can configure those explicitly
    using the `ignoreExceptions` attribute and set it to the desired exception classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure the circuit breaker behavior of a particular command, we can set
    a number of different options using the `commandProperties` or `threadPoolProperties`
    attributes. There we can set things like execution timeouts, size of backup queues,
    and many others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of available properties, see [https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration](https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing to discuss is the modifications we made to our entity models
    to set the relational association annotations to use `fetch = FetchType.EAGER`.
    The reason we had to do so is due to the way Hibernate handles association loading.
    By default, those are loaded using the `FetchType.LAZY` setup, meaning that Hibernate
    is only going to establish the relationship, but the loading of the data will
    not happen until the getter methods are invoked. With Hystrix, by default, this
    could cause an error that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is due to the fact that Hystrix uses `ThreadPool` to execute method calls
    by default, and because the lazy-loaded data needs to access the datastore at
    the time of invocation, Hibernate requires an active session to be present in
    order to handle the request. Since Hibernate stores the session in `ThreadLocal`,
    it is obviously not present in the pooled executor thread that Hystrix is using
    during the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we changed the fetching to be eager, all the data is loaded during the
    repository interaction in the original Hibernate thread. We could, alternatively,
    configure our `@HystrixCommand` annotation to use the same executing thread by
    using the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While Hystrix strongly recommends to use the default `THREAD` strategy, in situations
    when we absolutely need to be residing in the same caller thread, `SEMAPHORE`
    is there to help us.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can set the same configuration in our `application.properties`
    file using `hystrix.command.default.execution.isolation.strategy=SEMAPHORE`, or,
    if we want to be specific to only configure particular `@HystrixCommand`, we can
    use the value of the `commandKey` attribute, which is the name of the annotated
    method by default, instead of the default section of the property name. For our
    specific example from the `BookController` instrumented method, the configuration
    key would look like `hystrix.command.getAllBooks.execution.isolation.strategy=SEMAPHORE`.
    This is possible thanks to the Spring Cloud-Netflix Archaius bridge, which makes
    all Spring environment properties visible to the Archaius configuration manager,
    thus accessible by all of the Netflix components.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud Hystrix integration also provides a `/hystrix.stream` actuator
    endpoint, which can be consumed by the Hystrix dashboard for visualizing the state
    of all the circuit breakers in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the dashboard running quickly, Spring Cloud provides a sample application
    which can be seen at [https://github.com/spring-cloud-samples/hystrix-dashboard](https://github.com/spring-cloud-samples/hystrix-dashboard):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b47abbbb-d147-4ab5-b21d-bb38b8293a01.png)'
  prefs: []
  type: TYPE_IMG
- en: The same stream can also be fed into **Netflix Turbine Stream Aggregator**,
    downloadable at [https://github.com/Netflix/Turbine](https://github.com/Netflix/Turbine),
    for data aggregation across multiple instances, which can later be visualized
    using the same dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: One can also use the `spring-cloud-starter-turbine` dependency library and the `@EnableTurbine`
    annotation on a basic Spring Boot application, similar to the Hystrix dashboard
    sample.
  prefs: []
  type: TYPE_NORMAL
