- en: Reactive Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the concepts and implementations of
    reactive patterns, looking at how we can use them to implement a better application.
    We will also cover reactive programming concepts, focusing on how they can aid
    application development. After reading this chapter, we will be able to use reactive
    patterns using the best practices of Java EE 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be explored in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of an event in CDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an event in CDI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of an asynchronous EJB method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an asynchronous EJB method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the concept of an asynchronous REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an asynchronous REST service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a long time, applications processed all requests in a synchronous manner.
    In a synchronous process, the users request a resource and wait for its response.
    When this type of process begins, each step is executed right after the previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we can see the process of the workflow when it is
    executed in a synchronous manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6530aad-ab8b-4374-8128-de18020ab36d.png)'
  prefs: []
  type: TYPE_IMG
- en: In a synchronous process, each call to a function or resource works in a step-by-step,
    sequential manner. However, some tasks take longer to execute, thus blocking this
    process for a long time. An example of a task that can take a long time to execute
    is an I/O request when the application reads data from a disk or data source.
  prefs: []
  type: TYPE_NORMAL
- en: With the growth of web application access, several web applications needed to
    become able to receive and process a large number of requests in order to respond
    to these requests. With this, synchronous processing began to encounter problems
    with responding to large volumes of requests and building a response to the requests
    quickly. To solve this, web applications began working through asynchronous processes,
    making it possible for the applications to build a response quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In an asynchronous process, calls to functions or resources can be carried out
    in a parallel manner without having to wait for a task to end in order to execute
    the next one. Because of this, executing an I/O request will not delay the next
    task's execution—they can proceed at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is a style of programming that develops applications in
    a functional form. Here, the development occurs in an asynchronous data stream
    that is sent by a requester. Furthermore, we can have a resource that reacts with
    this data stream as the data flow is received. Each task then works as a function
    and does not handle variables outside of its scope, making it possible for this
    function to execute several times in a parallel manner without having any collateral
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In reactive programming, we have elements that react to events, then when a
    user requests a resource, it starts an event that operates a data stream. When
    this event begins, an element or task reacts to the data stream and processes
    its algorithm. This makes it possible for the web application to process a large
    amount of data and scale it without difficulty. This paradigm works with the following
    four concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic**: This reacts to demands. Applications can use multicore and multiple
    servers to process the requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: This reacts to faults. Applications can react to and recover
    from faults and errors in software, hardware, and networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message-driven**: This reacts to events. Applications are composed of event
    managers that are asynchronous and nonblocking, as opposed to being composed of
    multiple synchronous threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Responsive**: This reacts to users. Applications offer rich iterations in
    real time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java EE 8 has tools that permit developers to use reactive programming in their
    applications. Some of these tools are events in CDI, asynchronous EJB methods,
    and asynchronous rest services.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of an event in CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As reactive programming grew in the development environment, the Java language
    and Java EE needed to create tools to permit developers to develop systems using
    reactive programming. On Java EE, some solutions were introduced that made it
    possible to use the style function and to create processes asynchronously. One
    of these solutions is Event in CDI; this solution could launch a synchronous and
    blocking event, or an asynchronous and nonblocking event using CDI.
  prefs: []
  type: TYPE_NORMAL
- en: In CDI, Event is a solution that Java EE built using the observer pattern, making
    it possible to develop and launch an event to separate components doing the processing,
    working as a synchronous and blocking or asynchronous and nonblocking process.
    This separate task is an observer that reacts to an event launched with its data.
    In this chapter, we will focus on asynchronous CDI, using Event in CDI to launch
    asynchronous events.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an event in CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of implementing an event in CDI, we think about asynchronous
    CDI and imagine a scene in which we want to create an application that makes it
    possible to upload three types (or extensions) of file—this includes ZIP, JPG,
    and PDF extensions. Depending on the extension received at the request, it is
    intended that one event is launched and one observer will save its file on a disk
    using an asynchronous process. Each extension will have an observer, which will
    have an algorithm making it possible to save the file on a disk. To develop this
    example, we have the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileUploadResource`: This is a class that represents the resource that receives
    all the requests in order to upload and launches respective events according to
    the file extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileEvent`: This is a bean that contains the file data and is sent to an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileHandler`: This is an interface of all the observers. In this example,
    all classes that react to `FileEvent` need to implement `FileHandler`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpgHandler`: This is an implementation of FileHandler that saves a JPG file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a JPG file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PdfHandler`: This is an implementation of `FileHandler` that saves a PDF file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a PDF file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipHandler`: This is an implementation of `FileHandler` that saves a ZIP file
    on a disk. This class is an observer that reacts with `FileEvent` launched to
    a ZIP file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jpg`: This is a qualifier used to establish that the `JpgHandler` observers
    need to react to an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pdf`: This is a qualifier used to establish that the `PdfHandler` observer
    needs to react to an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zip`: This is a qualifier used to establish that the `ZipHandler` observer
    needs to react to an event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSystemUtils`: This is a utility class to treat issues on a filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the FileUploadResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FileUploadResource` is a resource class that uses JAX-RS to create a RESTful
    service to upload a file with JPG, PDF, and ZIP extensions. In the following code,
    we have the code of qualifiers that are used to select the correct observer to
    react to an event as well as the code for `FileUploadResource`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bean sent on the event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FileEvent` is a bean that is sent to the event—the observers will receive
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Qualifier to select the JpgHandler observer to react to an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we have the `Jpg` qualifier, used to define the correct
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Qualifier to select the PdfHandler observer to react to an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we have the `Pdf` qualifier, used to define the correct
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Qualifier to select the ZipHandler observer to react to an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code, we have the `Zip` qualifier, used to define the correct
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The FIleUploadResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code block, we have the `JFileUploadResource` class, which
    uses JAX-RS and is a REST service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to establish the correct event to launch is to use the qualifier
    at the point where the object is injected using `@Inject`, but this way, the event
    becomes static and all events launched by the `Event` object are of the same type.
    Using the `select (Annotation... var)` method, we can launch a dynamic event as
    well as other event types. The following is an example of `Event` with a static event
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `pdfEvent` will always launch an event to an observer
    that processes an event marked by the `@Pdf` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch an asynchronous event, we need to call the `fireAsync(U var)` method, which
    returns `CompletionStage`. In the following code block, we have a snippet that
    calls this method and prepares a callback function to execute when the process
    is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implementing observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an event is launched by a launcher, some elements will react to this event
    and process a task with the data given on an event. These elements are called
    **observers** and work as observer patterns, which create a one-to-many relationship
    between objects.
  prefs: []
  type: TYPE_NORMAL
- en: This occurs when one object is the subject and the other objects are the observers.
    Then, when the subject object is updated, all observer objects that are related
    to this subject-object are updated too.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDI has a mechanism for creating observers that will react with its events.
    In our example, we will launch an event, create observers to react to these events,
    and process a task. To do this, we will create handlers that represent our observer
    and process tasks. These handlers will be classes that implement the `FileHandler`
    interface as well as methods, called `handle(FileEvent file)`. Note that the parameter
    of the `handler(FileEvent file)` method is a `FileEvent` type. This is the same
    type of data as sent to the event in the preceding example. In the following example,
    we have the code for the `FileHandler` interface and its implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we have the `JpgHandler` class, which is an implementation
    of `FileHandler`. This is responsible for saving the JPG files on a filesystem.
    This observer is called when an event is launched to the `@Jpg` qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have the method handler, which has an `@ObservesAsync` annotation as
    well as `@Jpg`. This is a CDI annotation that configures this method to observe
    the `FileEvent` file, as well as the Qualifier, to configure the observer to react
    only to the event launched to the `@Jpg` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have the `PdfHandler` class, which is an implementation
    of `FileHandler` responsible for persisting PDF files on a filesystem. This observer
    is called when an event is launched to a `@Pdf` qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a handler method with an `@ObservesAsync` annotation as
    well as a `@Pdf.` This is a CDI annotation that configures the `handle(FileEvent
    file)` method to observe the `FileEvent` file, and the `Qualifier` to configure
    the observer to react only to an event launched to the `@Pdf` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have the `ZipHandler` class, which is an implementation
    of `FileHandler` responsible for saving ZIP files on a filesystem. This observer
    is called when an event is launched to a `@Zip` qualifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the handler method, which has an `@ObservesAsync` and
    a `@Zip` annotation. This is a CDI annotation that configures this method to observe
    the `FileEvent` file, and the Qualifier to configure this observer to react only
    to events launched to the `@Zip` qualifier.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the concept of an asynchronous EJB method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launching events to elements that react to these events is a good mechanism
    for solving many kinds of problems during development. However, sometimes it is
    necessary to call a class method without blocking the process until this method
    completes the execution.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous EJB method is a mechanism of EJB that allows the client to call
    a method and receive its return as soon as the method is invoked. The return of
    a method is in control of the asynchronous call represented by the `Future<T>`
    object. The client can control the execution of the asynchronous method. These
    actions can cancel the invocation method, check whether the invocation is completed,
    check whether the invocation has launched an exception, and check whether the
    invocation was cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: Difference between an asynchronous EJB method and an event in CDI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An event in CDI and an asynchronous EJB method have the similar characteristic
    of making a nonblocking call to a task. Furthermore, the client can cancel and
    monitor the invocation of an asynchronous process. However, an asynchronous EJB
    method and an event in CDI don't share all the same characteristics. The principal
    difference between them is that the asynchronous EJB method works on a one-to-one
    basis between the caller and the called. This is because when this method is invoked,
    it will only process the task and the client knows what the method is that will
    be processed. On the event in CDI, the relationship between the caller and the
    called is one-to-many. This is because the caller launches an event, and one or
    more observers can react to this. Another difference between the asynchronous
    EJB method and an event in CDI is that, in CDI, the event works with the observer
    pattern and makes it possible to apply a callback method to be executed at another
    time. The asynchronous EJB method doesn't work with the observer pattern and doesn't
    have the ability to apply a callback method.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an asynchronous EJB method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our implementation example, we will use the same scenario as in the example
    of an Event in CDI. Here, we will create an application that makes it possible
    to upload three types (or extensions) of files—ZIP, JPG, and PDF extensions. Depending
    on the type of extension received, the file received will be saved on the filesystem
    at its respective directory. To develop this example, we will use the following
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileUploadResource`: This is a class that represents the resource to receive
    all request to upload, and calls the respective EJB according to the file extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpgHandler`: This is an EJB with an asynchronous method to treat the process
    save of a JPG file on disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PdfHandler`: This is an EJB with an asynchronous method to treat the process
    save of a PDF file on disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipHandler`: This is an EJB with an asynchronous method to treat the process
    save of a ZIP file on disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSystemUtils`: This is a utility class intended to handle issues with the
    filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing EJBs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use an asynchronous EJB method, we need to create a session bean and configure
    it to have asynchronous methods. In the following code, we have an example of
    the implementation of a session bean called `PdfHandler`, which is responsible
    for saving PDF files on a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have the `PdfHandler` class, which contains
    a `handler(FileBean file)` method. This method is annotated with `@Asynchronous`
    to configure it as an asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the configuration of the `handle(FileBean file)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This method needs to return `Future<T>`. In our example, we return `AsyncResult`,
    which is an implementation of the `Future` interface. In our example, the data
    returned with the `Future` object contains the information of the path to the
    file on the filesystem. In the following code, we have an example of a `Future`
    return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have an example of the implementation of a
    session bean called `JpgHandler`, which is responsible for saving JPG files on
    the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This method works as the `PdfHandler` method, but saves the file at another
    directory and with another filename pattern. In our example, the data returned
    with the `Future` object is the path to the file on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have an example of an implementation of the session
    bean called `JpgHandler`, which is responsible for saving JPG files on the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method works as the `PdfHandler` and `JpgHandler` methods, but saves the
    file at another directory and with another filename pattern. In our example, the
    data returned with the `Future` object is the path to the file on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FileUploadResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FileUploadResource` is a resource class that uses JAX-RS to create a RESTful
    service to upload a file with JPG, PDF, and ZIP extensions. The following code
    contains the `FileUploadResource` resource class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, the EJB''s `PdfHandler`, `JpgHandler`, and `ZipHandler`
    are injected with the `@Inject` annotation from CDI. In the following example,
    we have the injection code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When a request is sent to an application, the method responsible for processing
    a request gets the file and builds a `FileBean`. This method calls an asynchronous
    EJB method to process this task. In the following code blocks, we have examples
    of calling the asynchronous EJB method.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an asynchronous EJB method to save a PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the following ways to call the asynchronous EJB method. The following
    code block demonstrates the saving of a PDF file by calling the EJB method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Calling an asynchronous EJB method to save a JPG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code block demonstrates the saving of a JPG file by calling the
    asynchronous EJB method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Calling an asynchronous EJB method to save a ZIP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code block demonstrates the saving of a ZIP file by calling the
    asynchronous EJB method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Explaining the concept of an asynchronous REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, the number of REST applications has grown and many APIs have been
    created to serve various kinds of services in many environments. In the same way
    as other applications, some REST applications need asynchronous processes and
    work with nonblocking processes.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous REST service is an asynchronous process that makes it easier
    to process threads. In contrast, in a request sent to a server, a new thread can
    be called to process a nonblocking task, such as operations on a filesystem. JAX-RS
    supports asynchronous processing in a client API and server API, but the asynchronous
    rest service is implemented at the server API. This is because it is the server
    API that provides services. The client API consumes the services and, as a result,
    we refer to the asynchronous processing in a client API as the asynchronous REST
    consume.
  prefs: []
  type: TYPE_NORMAL
- en: The client API can be completed through asynchronous invocation, which returns
    a `Future<T>` object as soon as the request is done, allowing the client to control
    this invocation and apply actions to it. This can be done through reactive programming
    and it can return a `CompletionState<T>` object as soon as the request is done.
    This means that it is possible to control the invocation and choose a callback
    method, executed depending on the stage. In the implementation example covered
    in the next topic, we will use the invocation with reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an asynchronous REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example of implementing an asynchronous REST service, we will use the
    same scenario used in the example of the event in the CDI and the asynchronous
    EJB method. Here, we will create an application that makes it possible to upload
    three types (or extensions) of files—ZIP, JPG, and PDF extensions. Depending on
    the extension received, we want the file received to be kept in its respective
    directory on the filesystem. To develop this example, we have the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileUploadResource`: This is a class that represents the resource that works
    with asynchronous processes to receive all requests to upload, and calls the respective
    EJB according to the file extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpgHandler`: This is an EJB with an available method for saving a JPG file
    on a disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PdfHandler`: This is an EJB with an available method for saving a PDF file
    on a disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipHandler`: This is an EJB with an available method for saving a ZIP file
    on a disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileSystemUtils`: This is a utility class that deals with issues within the
    filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileUploadClient`: This is a client API implemented through JAX-RS that makes
    asynchronous calls to the REST service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the EJBs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we will implement `PdfHandler`, `JpgHandler`, and `ZipHandler`,
    which are the EJBs responsible for dealing with the logic to save its files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we have `PdfHandler`, which is responsible for saving
    PDF files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have `JpgHandler`, which is responsible for
    saving JPG files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have `ZipHandler`, which is responsible for
    saving ZIP files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the FileUploadResource class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FileUploadResource` is a resource designed to allow clients to upload files
    to a server through an asynchronous request using REST. This class uses the JAX-RS
    to create a REST resource and, depending on the file extension, this resource
    delegates the task of saving a file to its respective EJB. In the following code
    block, we have the `FileUploadResource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, this class consists of three methods that receive a request, prepare
    the `FileBean`, and send it to an EJB to process a task that saves the files.
    In the following code block, we have the `uploadPdf(File file)` method, which
    is responsible for processing all the requests to upload PDF files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the client API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in order to send an asynchronous request using the reactive programming,
    we create an example of the JAX-RS client API. In the following code, we can see
    an example of the client API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](9e35e298-1a91-43b8-ace1-805997b2b89e.xhtml), *Microservice Patterns*,
    we explored the reactive programming paradigm and how it is implemented using
    Java EE 8 mechanisms. We also demonstrated how we can make asynchronous calls
    using Java EE 8 mechanisms, and how to control these calls and apply actions to
    them via asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: Event in CDI is a mechanism of the CDI specification that can be used in all
    tiers of an application. However, using this mechanism is recommended when working
    with a presentation tier. This is because CDI has a major focus on the presentation
    tier and its scopes are directly related to the HTTP interaction and HTTP session.
    Furthermore, we could launch an event with various elements that react to this
    event.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous EJB method doesn't use the reactive programming paradigm but
    is an asynchronous process that makes it possible to decrease the time it takes
    to respond to the client. This is an EJB mechanism and it is recommended to use
    it at the business tier. The benefit of using this mechanism is that we can also
    use other EJB mechanisms, such as the transactions control.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous REST service is a mechanism of the JAX-RS specification that
    is able to create a REST service that can do asynchronous processing. With this
    mechanism, the control of the process is returned as soon as a request is sent,
    and the client, therefore, doesn't need to wait a long time to process other tasks.
    This mechanism is always implemented in the presentation tier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover microservice patterns and how to implement
    them. We will also look at the aggregator pattern, proxy pattern, chained pattern,
    branch pattern, and asynchronous messaging pattern.
  prefs: []
  type: TYPE_NORMAL
