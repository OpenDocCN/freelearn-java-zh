<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;SDK Game Development Hub"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. SDK Game Development Hub</h1></div></div></div><p>This chapter contains the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a project</li><li class="listitem" style="list-style-type: disc">Importing a model</li><li class="listitem" style="list-style-type: disc">Using the Scene Composer</li><li class="listitem" style="list-style-type: disc">Modifying heightmaps with Terrain Editor</li><li class="listitem" style="list-style-type: disc">Adding a sky box and lighting</li><li class="listitem" style="list-style-type: disc">Adding water using a filter</li><li class="listitem" style="list-style-type: disc">Adding some ambient audio</li><li class="listitem" style="list-style-type: disc">Creating bitmap fonts with Font Creator</li><li class="listitem" style="list-style-type: disc">Retrieving an attachment node</li><li class="listitem" style="list-style-type: disc">Using ParticleEmitter—Soaring Birds</li><li class="listitem" style="list-style-type: disc">An advanced ParticleEmitter class</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Introduction</h1></div></div></div><p>Welcome to the first chapter of this book! In this chapter, we'll go through various functions of the SDK. These are the features that make the development process accessible to people other than programmers. You can also, in many cases, get quick visual results by just tweaking values and without having to launch an application. In short, it's a development hub because you will return and use these functions from time to time in your project. On the difficulty scale, these recipes lean towards the easy side, with little or no programming. The exception is the last part of the chapter where modifying the core packages is necessary to achieve the results we want.</p></div></div>
<div class="section" title="Setting up a project"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Setting up a project</h1></div></div></div><p>The jMonkeyEngine SDK is based around the NetBeans environment. Users familiar with <a id="id0" class="indexterm"/>the NetBeans environment will probably have little trouble <a id="id1" class="indexterm"/>finding their way around the jMonkeyEngine SDK. For those with no previous experience, some pointers on how to get started might be in place. In this recipe, we'll create a project that can access the jMonkeyEngine test-data library. By doing so, we will have some assets available from the start that can be used to try out many of the recipes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Getting ready</h2></div></div></div><p>Before <a id="id2" class="indexterm"/>setting up a project, we need to download the SDK. Doing so is as easy as going to <a class="ulink" href="http://hub.jmonkeyengine.org/downloads/">http://hub.jmonkeyengine.org/downloads/</a> and selecting a suitable package for your operating system.</p><p>After downloading and installing the package, we're ready to go!</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How to do it...</h2></div></div></div><p>We can set up a project by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First of all, find the <span class="strong"><strong>Projects</strong></span> window.</li><li class="listitem">Right-click somewhere inside it and select <span class="strong"><strong>New Project</strong></span>.</li><li class="listitem">In the window that appears, select <span class="strong"><strong>JME3</strong></span> from <span class="strong"><strong>Categories</strong></span> and <span class="strong"><strong>BasicGame</strong></span> from <span class="strong"><strong>Projects</strong></span>.</li><li class="listitem">On the next screen, choose a suitable name for the project and click on <span class="strong"><strong>Finish</strong></span> to create it.</li><li class="listitem">The project should now appear in the <span class="strong"><strong>Projects</strong></span> window. Right-click on it and select <span class="strong"><strong>Properties</strong></span> from the menu.</li><li class="listitem">Select the <span class="strong"><strong>Libraries</strong></span> option, click on the <span class="strong"><strong>Add Library…</strong></span> button, and find the <code class="literal">jme3-test-data</code> library from the list.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>How it works...</h2></div></div></div><p>When the project is created, it sets up the basic necessities for a jMonkeyEngine project. You will get a <span class="strong"><strong>Project Assets</strong></span> folder where any content can be placed in its subfolders. It also creates the <code class="literal">Main.java</code> file based on the <code class="literal">SimpleApplication</code> class. This is the starting point for your application.</p></div></div>
<div class="section" title="Importing a model"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Importing a model</h1></div></div></div><p>Let's start off with a pretty basic scenario. We have this model, which we've exported from <a id="id3" class="indexterm"/>a 3D modeling package, and we would like to use it for our<a id="id4" class="indexterm"/> game. The first thing we need to do is convert it to the format that jMonkeyEngine 3 uses internally (<code class="literal">.j3o</code>). The recommended format to use is <code class="literal">.blend</code> coming from the open source modeling package Blender for which the SDK has extensive support. Another common format is <code class="literal">.obj</code> for static models and Ogre-mesh XML files.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How to do it…</h2></div></div></div><p>We can import a model by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go to the <span class="strong"><strong>File</strong></span> menu and select <span class="strong"><strong>Import Model</strong></span>.</li><li class="listitem">Next, we need to choose the project we would like to import.</li><li class="listitem">After selecting the actual model to be imported, we get to preview the model and can make sure that all the assets are properly used.</li><li class="listitem">Finally, we select where to place it in the <span class="strong"><strong>Project Assets</strong></span> folder structure.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How it works…</h2></div></div></div><p>The importer <a id="id5" class="indexterm"/>converts the model to the internal <code class="literal">.j3o</code> format. This is a binary format, which means it becomes nonreadable (compare it with a <code class="literal">.obj</code> file, which can be edited in Notepad). The compactness of a binary file is necessary to keep memory consumption low. It becomes impossible to edit externally, though, so keeping the original files organized is a good idea!</p></div></div>
<div class="section" title="Using Scene Composer"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Using Scene Composer</h1></div></div></div><p>Here, we'll go<a id="id6" class="indexterm"/> through the basics of using Scene Composer in<a id="id7" class="indexterm"/> the SDK. Scene Composer is a place where we can preview objects, prepare them for in-game usage, and combine them to form scenes. Further usage includes viewing a model's skeleton and bones setup or playing animations. You can also apply materials, lighting, and set some basic geometry data.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Getting ready</h2></div></div></div><p>Having some models to play around with will be useful if you want to create an interesting scene. We will use the Jaime model from the test-data library. You can find it in the <span class="strong"><strong>Jaime</strong></span> folder inside <span class="strong"><strong>Models</strong></span> and copy it to your project.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it…</h2></div></div></div><p>Let's start by creating a scene we can use to test our recipes later.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <span class="strong"><strong>Scenes</strong></span> folder inside <span class="strong"><strong>Project Assets</strong></span>, select <span class="strong"><strong>New</strong></span>, and then select <span class="strong"><strong>Empty jME3 Scene</strong></span>. The scene will open automatically in the <span class="strong"><strong>SceneComposer</strong></span> window.</li><li class="listitem">A scene is just an empty node, and needs to be populated to be useful. To have <a id="id8" class="indexterm"/>something to look at, let's add the Jaime model<a id="id9" class="indexterm"/> to the scene. Find it in the folder structure, right-click on <span class="strong"><strong>Jaime.j3o</strong></span>, and select <span class="strong"><strong>Link in SceneComposer</strong></span>. The <span class="strong"><strong>SceneComposer</strong></span> window looks as follows:<div class="mediaobject"><img src="graphics/6478OS_01_01.jpg" alt="How to do it…"/></div></li><li class="listitem">Now, most likely, all we can see is a blue, wire-frame box. This is because there are no lights in the scene. At the top-left part of the screen, there is a button with a light bulb on it.</li><li class="listitem">By clicking on it, we should get <span class="strong"><strong>PointLight</strong></span> following the camera; it is not part of the scene, however.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Linking versus adding</strong></span>
</p><p>Adding <a id="id10" class="indexterm"/>means you add an instance of the object itself to the<a id="id11" class="indexterm"/> scene. This can then be modified separately to the original object.</p><p>Linking means you add a reference to the object in the scene. Apart from making the scene smaller, any modifications to the original object will also affect the objects in the scene.</p></div></div></li><li class="listitem">Basic camera orientation in the scene includes dragging with the left mouse button to rotate the camera. Dragging with the right mouse button pressed moves the camera sideways, up, and down. The mouse wheel zooms in and out.</li><li class="listitem">The second icon in the top bar of the <span class="strong"><strong>SceneComposer</strong></span> window is the Move icon. By clicking on it, you will see three different colored planes by Jaime. These will be highlighted as you move your mouse over them. If you press the left mouse button while they're highlighted, you will move the object in the dimensions of that plane.<div class="mediaobject"><img src="graphics/6478OS_01_02.jpg" alt="How to do it…"/></div></li><li class="listitem">The same rules apply to the next icon, Rotation. Note, though, that scaling is uniform across all the axes.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If you want to have total control over your transformations, you can use the <span class="strong"><strong>Properties</strong></span> window to set the exact values for translation, rotation, and scale.</p><p>If you'd like to have an in-depth knowledge of the SDK, have a look at the videos on <a class="ulink" href="http://hub.jmonkeyengine.org">http://hub.jmonkeyengine.org</a>.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>Scene<a id="id12" class="indexterm"/> Composer runs an instance of a jME application <a id="id13" class="indexterm"/>and what you see is very much what you will get when watching the scene in the game (minus the camera light). Use it to preview and tweak your assets before bringing them inside your application.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>There's more…</h2></div></div></div><p>Now that we have a scene, what's needed to load it into an application? Just the following lines of code are needed, really:</p><div class="informalexample"><pre class="programlisting">Spatial scene = assetManager.loadModel("Scenes/TestScene.j3o");
rootNode.attachChild(scene);</pre></div><p>Add the preceding code in the <code class="literal">simpleInitApp()</code> method of <code class="literal">Main.java</code>.</p></div></div>
<div class="section" title="Modifying heightmaps with Terrain Editor"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Modifying heightmaps with Terrain Editor</h1></div></div></div><p>In <a id="id14" class="indexterm"/>Terrain Editor, we find a number <a id="id15" class="indexterm"/>of functions that let us modify <a id="id16" class="indexterm"/>a heightmap-based terrain, something which is used in many games.</p><p>A heightmap, in<a id="id17" class="indexterm"/> its simplest form, is a 2D array (the dimensions representing <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinates) usually storing floats that represent height values. These can be saved as grayscale images where brighter areas correspond to higher ground and, reversibly, darker areas correspond to lower ground.</p><p>The terrain fields of jMonkeyEngine have much more information to help you create a visually appealing terrain. Things like vertex normal data and color and texture data are available for modification through the API, for daring programmers.</p><div class="mediaobject"><img src="graphics/6478OS_01_08.jpg" alt="Modifying heightmaps with Terrain Editor"/><div class="caption"><p>A heightmap</p></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it...</h2></div></div></div><p>We will begin by creating a terrain for the scene before exploring how to modify it. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we either create a new scene or load a scene we've worked with previously.</li><li class="listitem">In the <span class="strong"><strong>SceneExplorer</strong></span> window, right-click on the main scene node and select <span class="strong"><strong>Add Spatial</strong></span> and then <span class="strong"><strong>Terrain..</strong></span>.</li><li class="listitem">To edit the terrain, we have to find the scene j3o file in the <span class="strong"><strong>Projects</strong></span> window. It should be present in the <span class="strong"><strong>Scenes</strong></span> folder inside <span class="strong"><strong>Project Assets</strong></span>. Right-click on the scene file and select <span class="strong"><strong>Edit Terrain</strong></span>.</li><li class="listitem">Now, we have a flat and nice terrain. While it's perfectly functional, let's explore the functions in the <span class="strong"><strong>TerrainEditor</strong></span> window. These functions are shown in the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_01_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Next <a id="id18" class="indexterm"/>to the Add Terrain icon, you have the raise/lower terrain icon. This icon uses the values of <span class="strong"><strong>Radius</strong></span> and <span class="strong"><strong>Height/Weight</strong></span> sliders to modify the terrain. Try it out and see <a id="id19" class="indexterm"/>how it can be used to create <a id="id20" class="indexterm"/>hills and valleys. The Level terrain icon can be used to create flat areas in the terrain. It works by right-clicking on an area, the height of which you would like to have as a reference, and then holding the left mouse button and flattening out the terrain at the selected height, creating plateaus.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>If you're going to use this as a test bed for the other chapters, try to keep the area just around Jaime at the default height, for now. This is because we don't have any logic to keep it at the actual ground level, and we would like to see what is going on in the recipes.</p></div></div></li><li class="listitem">While the terrain comes with basic texturing, we might want to do something more interesting. First of all, we need to add another texture layer. This is done with the icon that looks like a plane with a plus sign on top (the Add another texture layer icon).</li><li class="listitem">After clicking on it, there should be another row in the <span class="strong"><strong>Painting</strong></span> window, below it. Clicking on the <span class="strong"><strong>Texture</strong></span> field will bring up a selector with all the textures available<a id="id21" class="indexterm"/> to the project. Select a suitable texture among the available ones.</li><li class="listitem">Now, to paint, click on the button with a spray can on it. You can now paint by holding the left mouse button over the terrain, and erase by pressing the right mouse button. Like most of the other functions in the <span class="strong"><strong>TerrainEditor</strong></span> window, it uses the <span class="strong"><strong>Radius</strong></span> and <span class="strong"><strong>Height/Weight</strong></span> values.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>When painting a terrain by hand, it is a good idea to have a reference image of the terrain type at hand. That way we can, for example, see how grass grows on slopes, or snow gathers on mountains, and produce more realistic results. Always start by painting in broad strokes, gradually painting with smaller and smaller brushes.</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How it works...</h2></div></div></div><p>The function of most of the buttons is pretty self-explanatory, but let's look at what happens when either of them are applied.</p><p>A <a id="id22" class="indexterm"/>little bit of smoothing is something<a id="id23" class="indexterm"/> that might be needed after generating a<a id="id24" class="indexterm"/> heightmap using an automated tool. In such a case, you most likely won't use a brush, though, but rather a filter that will apply it evenly across the whole of the heightmap. The brush might instead be used to smooth out an area where a game character is supposed to move to make it a better game experience. It might also be that the ground of an area is of a type that would most likely be smoother than the surroundings, like a beach among rocky cliffs.</p><p>Level terrain has similar uses. If we need sufficient space to place a large building for example, it is the best way to ensure that no part of the building ends up floating or submerged beneath the ground.</p></div></div>
<div class="section" title="Adding a sky box and lighting"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Adding a sky box and lighting</h1></div></div></div><p>Sky <a id="id25" class="indexterm"/>boxes or sky domes are small pieces of every day magic in<a id="id26" class="indexterm"/> games. They're used to create a mood-setting backdrop<a id="id27" class="indexterm"/> for scenes and are excellent for making areas seem larger <a id="id28" class="indexterm"/>than they are.</p><p>Sky boxes consist of six textures, rendered on the inside of a cube, much like wallpapers. Perceived as enclosing the world, they actually don't need to be very big since they are rendered first in the queue. This means everything else will be drawn on top of them.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it…</h2></div></div></div><p>The recipe will consist of two sections, where the first section will create a sky box from six textures. After this, we will add sun-like light using <span class="strong"><strong>Directional Light</strong></span>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <span class="strong"><strong>SceneExplorer</strong></span> window, right-click on your scene and select <span class="strong"><strong>Add Spatial..</strong></span> and then <span class="strong"><strong>Skybox..</strong></span>.</li><li class="listitem">There are two options here: either we can load six independent textures or one texture with all the six textures prebaked. This particular recipe uses the six <code class="literal">Lagoon</code> textures from the <code class="literal">test-data/Textures/Sky</code> folder.</li><li class="listitem">After this, we should now see a moody, watery scene surrounding the terrain.</li><li class="listitem">The terrain and skybox don't blend together very well. First and foremost the lighting is wrong. The only light in the scene is a white light coming from the camera's origin. To get a more natural light in this outdoor scene, we can add <span class="strong"><strong>Directional Light</strong></span>.</li><li class="listitem">Again, right-click on the scene in the <span class="strong"><strong>SceneExplorer</strong></span> window. Now, select <span class="strong"><strong>Add Light..</strong></span> and then select <span class="strong"><strong>Directional Light</strong></span>. Things just got a lot brighter! It doesn't look better, however. We need to adjust the light to suit the scene.</li><li class="listitem">We can see the <span class="strong"><strong>DirectionalLight</strong></span> element in the <span class="strong"><strong>SceneExplorer</strong></span> window. Select it and bring up the <span class="strong"><strong>Properties</strong></span> window. There are just two settings: <code class="literal">Color</code> and <code class="literal">Direction</code>.</li><li class="listitem">By<a id="id29" class="indexterm"/> clicking on the box next to the color values, we <a id="id30" class="indexterm"/>see several options to set the color. We can<a id="id31" class="indexterm"/> use an image editor and the colorpicker function<a id="id32" class="indexterm"/> near the sun to get a suitable color. Grab the RGB values and insert them in that tab. This way, we know that we get a color that matches the scene's sun.</li><li class="listitem">Turning off the camera light (the light bulb in the top-left corner) will help us see the blue-tinted color from the light we just added.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>It's often a good rule of thumb to have a little less tint than what might first seem like a suitable one. It usually feels more natural in the end. Show it to someone else and see if they think it's "too much". As a developer, your judgment can be "tainted", as you get used to a scene, and it's easy to overdo things like lighting.</p></div></div></li><li class="listitem">There's one more thing to do to make the scene and sky box blend better together. The shadows on the terrain are at wrong places in relation to the sun in the scene. The default setting for <span class="strong"><strong>Directional Light</strong></span> is to shine in from the southwest direction and about 45 degrees downwards. This particular sky box has the main source of light coming from the northeast direction. Flipping the minus sign on the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>z</em></span> values in the <span class="strong"><strong>Direction</strong></span> property seems to make the shadows look more natural.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>What you see of a sky box can alter the perception of immersion, greatly. Generally, the player should not see anything below the horizon for it to look believable. You will notice this if you zoom in and out of the scene. As you're close to the ground, it will feel much more natural.</p></div></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How it works...</h2></div></div></div><p>The reason sky boxes work is because of how the rendering of the scenegraph happens. Objects can be sorted into different lists or buckets, to help the rendered in drawing. A sky box is sorted into the <code class="literal">Bucket.Sky</code> list, which is drawn first in every rendering cycle. This is why everything else (normally in the <code class="literal">Bucket.Opaque</code> list) appears to be in front of it. You can achieve the same effect for any object by calling <code class="literal">Geometry.setQueueBucket (Bucket.Sky)</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>You can achieve the same effect on other objects by changing the <code class="literal">QueueBucket</code> renderers as follows:</p><div class="informalexample"><pre class="programlisting">Geometry.setQueueBucket(Bucket.Sky);</pre></div></div></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>There's more…</h2></div></div></div><p>If you<a id="id33" class="indexterm"/> look closely at Jaime (or any other object you added to the scene) with <a id="id34" class="indexterm"/>the camera light turned off, you will notice that the <a id="id35" class="indexterm"/>side not facing the light will be completely dark. Unless this is <a id="id36" class="indexterm"/>a place devoid of atmosphere, radiance, diffusion, and reflection of other surfaces, one should have given all sides some basic lighting. This is emulated in games by using ambient lighting. It lights all the faces evenly and is added by selecting the scene in the <span class="strong"><strong>SceneExplorer</strong></span> window and choosing <span class="strong"><strong>Add Light</strong></span>.</p><p>You can select the same color as <span class="strong"><strong>Directional Light</strong></span>, but make it much darker to get something that will look natural. If you're really serious, and have a somewhat uniform ground color, you can try to blend in a little bit of the ground color, as well.</p></div></div>
<div class="section" title="Adding water using a filter"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Adding water using a filter</h1></div></div></div><p>When<a id="id37" class="indexterm"/> it <a id="id38" class="indexterm"/>comes <a id="id39" class="indexterm"/>to bang-for-the-buck visuals in jMonkeyEngine, there is little that trumps using a water filter. It is very impressive and yet easy to do. Having water in the scene will greatly enhance the mood of our test scene. You can view the great looking water with little efforts in the following screenshot:</p><div class="mediaobject"><img src="graphics/6478OS_01_06.jpg" alt="Adding water using a filter"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Getting ready</h2></div></div></div><p>The scene used should have some height differences (or we will end up with all water or all ground). If no terrain is available or if it needs adjustments, check out the <span class="emphasis"><em>Modifying heightmaps with Terrain Editor</em></span> recipe in this chapter.</p><p>If there<a id="id40" class="indexterm"/> isn't already an <span class="strong"><strong>Effects</strong></span> folder in your <span class="strong"><strong>Projects Assets</strong></span> folder, add it.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it…</h2></div></div></div><p>We can <a id="id41" class="indexterm"/>add water using a filter by performing the following <a id="id42" class="indexterm"/>steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <span class="strong"><strong>Effects</strong></span> folder under <span class="strong"><strong>Project Assets</strong></span>, select <span class="strong"><strong>New</strong></span>, and then select <span class="strong"><strong>Empty FilterPostProcessor file</strong></span>. You might have to select <span class="strong"><strong>New</strong></span>, <span class="strong"><strong>Other...</strong></span>, and then click on <span class="strong"><strong>Filters</strong></span> to find it.</li><li class="listitem">Name it <code class="literal">Water</code> and click on <span class="strong"><strong>Finish</strong></span>.</li><li class="listitem">Right-click on the newly created <span class="strong"><strong>Water.j3f</strong></span> file and open it.</li><li class="listitem">We are now moved to the <span class="strong"><strong>FilterExplorer</strong></span> window. From here, we can create, add, and modify scene-wide effects, choosing from a number of premade ones. Right-click on the <span class="strong"><strong>Water</strong></span> filter and select <span class="strong"><strong>Add Filter</strong></span> and then <span class="strong"><strong>Water</strong></span>.</li><li class="listitem">To see filters in the <span class="strong"><strong>SceneComposer</strong></span> window, we need to click on the Eye icon shown in the following screenshot. This should give the scene a whole new look. Do it and see the scene transform.<div class="mediaobject"><img src="graphics/6478OS_01_04.jpg" alt="How to do it…"/></div></li><li class="listitem">A few properties need to be modified in order to make the water appear smoothly. The <span class="strong"><strong>Properties</strong></span> window for the <span class="strong"><strong>WaterFilter</strong></span> element can seem a bit overwhelming. For now, let's change the <span class="strong"><strong>Water Height</strong></span> parameter. The filter will create foam wherever it meets the land and finds a good separation or where the shore height is essential. The sweet spot is dependent on the scene <a id="id43" class="indexterm"/>but starts out with -2 units. Changing the following<a id="id44" class="indexterm"/> values will affect the appearance <a id="id45" class="indexterm"/>along the shoreline:<div class="mediaobject"><img src="graphics/6478OS_01_09.jpg" alt="How to do it…"/></div></li><li class="listitem">There are also <span class="strong"><strong>Light Direction</strong></span> and <span class="strong"><strong>Light Color</strong></span> properties in there. Let's copy the values from our <span class="strong"><strong>Directional Light</strong></span> element here to make them match. You will find them by moving to the <span class="strong"><strong>SceneExplorer</strong></span> window, selecting the <span class="strong"><strong>Directional Light</strong></span> element, and looking in the <span class="strong"><strong>Properties</strong></span> window.</li><li class="listitem">Lastly, we need to add the following lines to the <code class="literal">simpleInit</code> method of our test application:<div class="informalexample"><pre class="programlisting">FilterPostProcessor processor = (FilterPostProcessor) assetManager.loadAsset("Effects/Water.j3f");
viewPort.addProcessor(processor);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>Post filters are rendered last as a screen effect in the rendering stage and applied to the entire scene. There are many ready-made filter variants made by the jME team and community that you can use to change how a scene appears. Filter Explorer is a great way to set up and test these<a id="id46" class="indexterm"/> before applying them to your <a id="id47" class="indexterm"/>game.</p></div></div>
<div class="section" title="Adding some ambient audio"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Adding some ambient audio</h1></div></div></div><p>Audio is <a id="id48" class="indexterm"/>an extremely important moodsetter in games, and<a id="id49" class="indexterm"/> any other cross-media product, which is often overlooked. Bad audio can just as easily break immersion as good audio can improve it.</p><p>We're going to add some ambient audio to our scene to help set the mood. Since the sky box we use is a rather gloomy and watery scene, we're going to add the sound of ocean waves crashing against the shore.</p><p>Ambient sounds can either be sounds you hear throughout a whole scene, such as the buzzing of traffic in a city, or local to a specific place, the sound of a waterfall, and so on. In this case, we can picture our scene as a small island, and thus the waves should be heard wherever you go.</p><p>As it happens, there is a suitable <code class="literal">.ogg</code> file in the <span class="strong"><strong>Environments</strong></span> folder inside <code class="literal">Sound</code>. If we have added the <code class="literal">jme3-test-data</code> library to our project, we can access it easily.</p><p>The SDK can handle both <code class="literal">.ogg</code> or uncompressed <code class="literal">.wav</code> files. The <code class="literal">.ogg</code> format is open and free, meaning <a id="id50" class="indexterm"/>you won't need any license to use it. This is not necessarily the case with other compression types.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>How to do it…</h2></div></div></div><p>If we've made the previous recipes, we might already have seen the audio node. The following steps will help show us how to add one to the scene:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We can find the audio node by right-clicking on a spatial, in this case the main scene node, and selecting <span class="strong"><strong>Add Spatial</strong></span> and then <span class="strong"><strong>Audio Node</strong></span>.</li><li class="listitem">Next, select it and look at the <span class="strong"><strong>Properties</strong></span> window.</li><li class="listitem">The first important thing to look at is the <span class="strong"><strong>Audio Data</strong></span> parameter. In the drop-down menu, the SDK will automatically show the files in the <span class="strong"><strong>Sounds</strong></span> folder under <span class="strong"><strong>Project Assets</strong></span>, so we should see <span class="strong"><strong>Ocean Waves.ogg</strong></span> here. Unchecking the <span class="strong"><strong>Positional</strong></span> checkbox means there will be no falloff in volume as you move around.</li><li class="listitem">Also check the <span class="strong"><strong>Looping</strong></span> box to make sure the sound doesn't end when it's finished playing one time.</li><li class="listitem">It's currently not possible to hear the sound in the SDK itself, so we need to start an application to do so. Fortunately, only one line of code is needed to start the sound in our <code class="literal">simpleInitApp</code> method. The<a id="id51" class="indexterm"/> only catch here is that we need to cast the <code class="literal">scene</code> object in an <code class="literal">AudioNode</code> instance first. After having loaded the scene, add the following lines of code:<div class="informalexample"><pre class="programlisting">Node scene = (Node) assetManager.loadModel
("Scenes/TestScene.j3o");
rootNode.attachChild(scene);
((AudioNode)scene.getChild("AudioNode")).play();</pre></div></li><li class="listitem">The sound we added is a very powerful sound and may be a bit overwhelming <a id="id52" class="indexterm"/>for our scene. Playing with the <code class="literal">Volume</code> property of the <code class="literal">AudioNode</code> element can be used to tone down the effect a bit.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can<a id="id53" class="indexterm"/> download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>How it works...</h2></div></div></div><p>The <code class="literal">AudioNode</code> element has a position in the 3D world since it extends <code class="literal">Spatial</code> and can hence be<a id="id54" class="indexterm"/> made to be heard only from certain places. It can also <a id="id55" class="indexterm"/>easily be made to follow objects around. In addition to volume and falloff, audio <a id="id56" class="indexterm"/>can also be modified during runtime by area effects such as reverb.</p><p>To learn more about how effects can be used to modify audio, check out <a class="link" href="ch09.html" title="Chapter 9. Taking Our Game to the Next Level">Chapter 9</a>, <span class="emphasis"><em>Taking Our Game to the Next Level</em></span>.</p></div></div>
<div class="section" title="Creating bitmap fonts with Font Creator"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Creating bitmap fonts with Font Creator</h1></div></div></div><p>The Font Creator plugin is a really nifty tool for any game creator and is easily overlooked unless mentioned. By using it, you can create a bitmap font using any system font you<a id="id57" class="indexterm"/> have<a id="id58" class="indexterm"/> available. Refer to the <span class="emphasis"><em>Downloading the plugins</em></span> section in <a class="link" href="apa.html" title="Appendix A. Information Fragments">Appendix</a>, <span class="emphasis"><em>Information Fragments</em></span>, to know<a id="id59" class="indexterm"/> how to download a plugin.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it…</h2></div></div></div><p>We can create bitmap fonts with Font Creator by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right-click on the <span class="strong"><strong>Fonts</strong></span> folder under <span class="strong"><strong>Interface</strong></span> in our <span class="strong"><strong>Project Assets</strong></span> folder. Select <span class="strong"><strong>New</strong></span> and then select <span class="strong"><strong>Other...</strong></span>. <span class="strong"><strong>Font</strong></span> is located in the GUI folder.</li><li class="listitem">Next, we choose the font we would like to use from the available system fonts.</li><li class="listitem">In the <span class="strong"><strong>Configure Font</strong></span> part, we can make adjustments before actually creating the bitmap. It's recommended to use a power-of-two number for the size.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>A higher resolution will make the text more detailed, but it will at the same time take up more memory, not only for the bitmap image itself but also for the text generated. Consider the application requirements or do some testing. You can also try to adjust the size of the font to fit the bitmap.</p></div></div></li><li class="listitem">Once <a id="id60" class="indexterm"/>we have our font, there are <a id="id61" class="indexterm"/>a couple of ways we can use it. First of all, if we want to replace the default font used by the application, we have to name the font <code class="literal">Default.fnt</code> and make sure it's placed inside the <span class="strong"><strong>Fonts</strong></span> folder under <span class="strong"><strong>Interface</strong></span>. This is what the application is looking for during startup.</li><li class="listitem">Another way to use the custom font is to load it in the application by using the following code:<div class="informalexample"><pre class="programlisting">BitmapFont myFont = assetManager.loadFont("Interface/Fonts/MyFont.fnt");</pre></div></li><li class="listitem">It can then be used to create text that can be placed anywhere on the screen, as shown in the following code:<div class="informalexample"><pre class="programlisting">BitmapText text = new BitmapText(myFont, false);
hudText.setText("Text!");
hudText.setColor(ColorRGBA.Red);
guiNode.attachChild(hudText);</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How it works...</h2></div></div></div><p>The <a id="id62" class="indexterm"/>
<code class="literal">BitmapText</code> class is spatial, and needs <a id="id63" class="indexterm"/>to be attached to a node in order to be displayed. The most common node is probably the <code class="literal">guiNode</code>. Spatials added to the <code class="literal">guiNode</code> will be positioned according to the screen space and projected without depth. For this reason, using the <code class="literal">guiNode</code> is <a id="id64" class="indexterm"/>suitable for <span class="strong"><strong>HUD</strong></span> items. Setting the <code class="literal">localTranslation</code> parameter to <code class="literal">(0, 0, 0)</code> will make the text appear in the bottom-left corner of the screen. Instead of using (<code class="literal">screenWidth, 0,</code> <code class="literal">screenHeight</code>), we will place it in the top-right corner.</p></div></div>
<div class="section" title="Retrieving an attachment node"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Retrieving an attachment node</h1></div></div></div><p>In many <a id="id65" class="indexterm"/>games, the characters can be customized<a id="id66" class="indexterm"/> to carry different equipment or clothes. In these situations, jMonkeyEngine's Attachments node is extremely useful. It lets us choose a bone and creates a node for us that will follow that particular bone's movement and rotation, without any further work from our side.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>Getting ready</h2></div></div></div><p>We'll need a rigged model with <code class="literal">SkeletonControl</code>. Fortunately, the Jaime model is already rigged and animated. We'll also need something to attach to it. What goes well with monkeys if not bananas?</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the model in the <span class="strong"><strong>SceneComposer</strong></span> window by right-clicking on it in <span class="strong"><strong>Projects</strong></span> and selecting <span class="strong"><strong>Edit</strong></span> in <span class="strong"><strong>SceneComposer</strong></span>.</li><li class="listitem">Expand the <code class="literal">SkeletonControl</code> class. Located under <code class="literal">Root</code> is a Bone called <code class="literal">IKhand.R</code>, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/6478OS_01_10.jpg" alt="How to do it…"/></div></li><li class="listitem">Right-click on <span class="strong"><strong>IKhand.R</strong></span> and select <span class="strong"><strong>Get attachment Node</strong></span>.</li><li class="listitem">We should now see a node called <span class="strong"><strong>IKhand.R_attachnode</strong></span> created at the top level of the hierarchy. Attach the banana to the node by dragging it into the <span class="strong"><strong>SceneExplorer</strong></span> window. The banana should now appear in Jaime's hand.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>The banana will not fit perfectly in this recipe. To achieve a perfect fit, the best way will be to create an actual bone, just for attachments, in the modeling program of our choice. Since the attached item is attached using the model's center point, we can expect to have to tweak the position of the items as well.</p></div></div></li><li class="listitem">To prove that the banana will actually follow the movement of the model, we can play an animation. Select <span class="strong"><strong>AnimControl</strong></span> in the <span class="strong"><strong>SceneExplorer</strong></span> window and look at the <span class="strong"><strong>Properties</strong></span> window. Choose an animation from the drop-down menu.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works...</h2></div></div></div><p>When we first call <code class="literal">getAttachmentsNode</code> on a <code class="literal">Bone</code> object, it will create a new node. It will then keep track of it and update its translation, rotation, and scale according to the values <a id="id67" class="indexterm"/>of the <code class="literal">Bone</code> object. It works as a regular node in<a id="id68" class="indexterm"/> most regards, with the difference being that it follows the <code class="literal">IKhand.R</code> bone's movements during animations. It is very handy, isn't it?</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec32"/>There's more…</h2></div></div></div><p>All this is, of course, possible to do using code as well. Just like in the SDK, we use the following<a id="id69" class="indexterm"/> <code class="literal">SkeletonControl</code> class to achieve this:</p><div class="informalexample"><pre class="programlisting">mySpatial.getControl(SkeletonControl.class).getAttachmentsNode("my   bone");</pre></div></div></div>
<div class="section" title="Using ParticleEmitter &#x2013; Soaring Birds"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec19"/>Using ParticleEmitter – Soaring Birds</h1></div></div></div><p>Particle Emitters, in general, are good in order to create an atmosphere in the games. The most<a id="id70" class="indexterm"/> common case is probably for smoke or fire and explosions. Particles <a id="id71" class="indexterm"/>can, however, be used for many interesting things. In this recipe, we're going to explore that by tuning a ParticleEmitter to create birds sailing through the sky.</p><p>The particles are still sprites, 2D images, so they will work best either far up in the sky, or below us.</p><p>The recipe will be divided into two parts. The first one contains setting up the <code class="literal">ParticleEmitter</code> class in the SDK and writing the <code class="literal">ParticleInfluencer</code> interface. The second part includes changing the way the <code class="literal">ParticleEmitter</code> class behaves and extending our <code class="literal">ParticleInfluencer</code> interface to take advantage of this:</p><div class="mediaobject"><img src="graphics/6478OS_01_05.jpg" alt="Using ParticleEmitter – Soaring Birds"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec33"/>Getting ready</h2></div></div></div><p>First of all, we<a id="id72" class="indexterm"/> need a suitable bird texture. There's one supplied with the project in the <span class="strong"><strong>Birds</strong></span> folder inside <span class="strong"><strong>Textures</strong></span>, which will be fine if the birds are supposed to be far away. Up close, it will not suffice though.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How to do it…</h2></div></div></div><p>The first <a id="id73" class="indexterm"/>section will describe how to set up a material we can use. This consists of the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We're going to start by creating a material to supply to the <code class="literal">ParticleEmitter</code> class. Create a new material in the <span class="strong"><strong>Materials</strong></span> folder by right-clicking and selecting <span class="strong"><strong>New…</strong></span> and then <span class="strong"><strong>Empty Material File</strong></span>.</li><li class="listitem">Rename it to something suitable, for example, <code class="literal">Birds.j3m</code>.</li><li class="listitem">Now, we can open it and are automatically moved to the <span class="strong"><strong>Material Editor</strong></span> window.</li><li class="listitem">Here, we set the <span class="strong"><strong>Material Definition</strong></span> value to <code class="literal">Common/Matdefs/Misc/Unshaded.j3md</code>.</li><li class="listitem">The only thing we need to change is the <span class="strong"><strong>ColorMap</strong></span> value, which should be pointed to our birds texture.</li></ol></div><p>Now, we come to the configuration of the <code class="literal">ParticleEmitter</code> class. This section consists of the following<a id="id74" class="indexterm"/> steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's begin by creating a new scene and opening it in the <span class="strong"><strong>SceneExplorer</strong></span> window. Right-click and select <span class="strong"><strong>Add Spatial..</strong></span> and then <span class="strong"><strong>Particle Emitter</strong></span>. A default smoke puffing the <code class="literal">ParticleEmitter</code> object is created.</li><li class="listitem">Now, we can bring up the <span class="strong"><strong>Properties</strong></span> window and start tweaking it.</li><li class="listitem">First of all, we set the material to our newly created material for the birds. Don't worry if it looks terrible!</li><li class="listitem">Looking at the <code class="literal">Images X</code> property, we can see that it's set to <span class="strong"><strong>15</strong></span> by default. This is the amount of horizontal "frames" in the texture. If we look at the birds texture, we can see that it's only four frames, so let's change that value. The particles are already looking better.</li><li class="listitem"><code class="literal">High Life</code> and <code class="literal">Low Life</code> define the maximum or minimum lifespan of a particle. We <a id="id75" class="indexterm"/>can assume that the birds should soar across <a id="id76" class="indexterm"/>the sky for a while, so let's change it to <span class="strong"><strong>30</strong></span> and <span class="strong"><strong>25</strong></span> respectively.</li><li class="listitem">There are an awful lot of birds now. Setting <code class="literal">Num Particles</code> to <span class="strong"><strong>50</strong></span> will make more sense.</li><li class="listitem"><code class="literal">Start Size</code> and <code class="literal">End Size</code> affect the size of the particles over time. These should be set to <span class="strong"><strong>1</strong></span> for our birds. They shouldn't inflate.</li><li class="listitem">For now, let's increase the radius of the emitter to get a better view. It's a sphere by default and the last value is the radius. Set it to <span class="strong"><strong>30</strong></span>.</li><li class="listitem">If we take a look at the birds now, they still just float in space. This is very unbird-like.</li><li class="listitem">Let's scroll down a bit to the <code class="literal">ParticleInfluencer</code> class. The <code class="literal">ParticleInfluencer</code> class has an opportunity to alter a particle's velocity when<a id="id77" class="indexterm"/> it's created, decreasing uniformity. The <code class="literal">DefaultParticleInfluencer</code> class can set an initial velocity, and a variation, from 0 to 1.</li><li class="listitem">Set the <code class="literal">InitialVelocity</code> parameter to <code class="literal">3.0, 0.0, 0.0</code> and the <code class="literal">VelocityVariation</code> to <code class="literal">1.0</code> to give the particles some individuality.</li><li class="listitem">To make the birds look in the direction they're flying, check the <span class="strong"><strong>Facing Velocity</strong></span> box.</li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>New settings won't take effect immediately, but only when a new particle is generated. If you want to speed up the process, click on the "<span class="strong"><strong>Emit All</strong></span>" button to emit all the new particles with the new settings.</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec35"/>How it works...</h2></div></div></div><p>A ParticleEmitter can be described as a cheap way to draw many identical or near-identical bitmaps. Particle Emitters have a single mesh that stores all its particles. As opposed to drawing each particle individually, it renders them all at once. This is considerably cheaper. The drawback is, of course, that they all look the same.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec36"/>There's more…</h2></div></div></div><p>There is<a id="id78" class="indexterm"/> another thing we can do to improve the appearance <a id="id79" class="indexterm"/>of the generated birds. Since we are expecting to look at them from either above or below, it makes sense to flatten the shape of the emitter to be more of a plane. Let's revisit the <code class="literal">Emitter Shape</code> property and make a box instead of a sphere, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">[Box, -30.0, -1.0, -30.0, 30.0, 1.0, 30.0]</pre></div><p>The numbers define the extremes of a box, that is, <span class="emphasis"><em>X</em></span>
<sup><span class="emphasis"><em>min</em></span></sup>, <span class="emphasis"><em>Y</em></span>
<sup><span class="emphasis"><em>min</em></span></sup>, <span class="emphasis"><em>Z</em></span>
<sup><span class="emphasis"><em>min</em></span></sup> and <span class="emphasis"><em>X</em></span>
<sup><span class="emphasis"><em>max</em></span></sup>, <span class="emphasis"><em>Y</em></span>
<sup><span class="emphasis"><em>max</em></span></sup>, and <span class="emphasis"><em>Z</em></span>
<sup><span class="emphasis"><em>max</em></span></sup>. In other words, we have created a box that is 60 units wide and long and only 2 units high.</p></div></div>
<div class="section" title="An advanced ParticleEmitter class"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec20"/>An advanced ParticleEmitter class</h1></div></div></div><p>Soaring birds <a id="id80" class="indexterm"/>are nice but it's easy to feel that the result of the <a id="id81" class="indexterm"/>previous recipe could have been much better if the birds were better animated. If you've worked with the <code class="literal">ParticleEmitter</code> class before or have been observant of the birds, you will know that particles can actually be animated although they only cycle through every frame once per lifetime. This is much too slow for the birds.</p><p>In this recipe, we're going to look at what's needed to make the birds flap their wings. It's not as simple as it sounds and requires modifying the <code class="literal">ParticleEmitter</code> code and writing our own <code class="literal">ParticleInfluencer</code> class.</p><p>If we have a look at the <code class="literal">ParticleEmitter</code> class to see what we need to do, we can see that there is an <code class="literal">updateParticle</code> method that seems like a good place to start. This is called for every particle in each update cycle. One thing that is less obvious at first is that since <a id="id82" class="indexterm"/>we have the same <code class="literal">ParticleInfluencer</code> instance affecting all particles, it also needs to be updated separately for each frame. To achieve the latter, we can use a control.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>To be able to modify the <code class="literal">ParticleEmitter</code> class, we need the source. This means we have to check it out from the repository. If you're not comfortable with this, you can still do the first part and learn more about the <code class="literal">ParticleInfluencer</code> instance.</p><p>After having checked out the source code for jMonkeyEngine from the repository, it should be opened as a project in the SDK.</p><p>Build it <a id="id83" class="indexterm"/>and then change the reference in the properties<a id="id84" class="indexterm"/> for this project to use the <code class="literal">.jar</code> files from the source code project instead of the supplied <code class="literal">jMonkeyEngine.jar</code> files.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it…</h2></div></div></div><p>In the first <a id="id85" class="indexterm"/>section, we'll create a new <code class="literal">ParticleInfluencer</code> instance. This consists of the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The first thing we'll do is create a new class called <code class="literal">BirdParticleInfluencer</code> and have it extend the <code class="literal">DefaultParticleInfluencer</code> class. Since the flat particles point in the direction they're flying, it sometimes looks weird when they have a Y-velocity. We're going to fix that by not allowing the particles to have any velocity in the <span class="emphasis"><em>y</em></span> axis. We override the <code class="literal">influenceParticle</code> method and set the Y-velocity to <code class="literal">0</code>. After this we need to normalize the velocity, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void influenceParticle(Particle particle, EmitterShape emitterShape) {
  super.influenceParticle(particle, emitterShape);
  particle.velocity.setY(0);
  particle.velocity.normalizeLocal();
}</pre></div></li><li class="listitem">We can now replace the <code class="literal">ParticleInfluencer</code> interface in the <code class="literal">ParticleEmitter</code> element's <span class="strong"><strong>Property</strong></span> window with our own.</li><li class="listitem">That was the easy part, and that's how far we get without modifying the engine. In the next section, we will extend the current <code class="literal">ParticleEmitter</code> instance to animate particles continuously. This will consist of the following steps:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's start by making our <code class="literal">ParticleInfluencer</code> interface ready to update the particles in every frame. Let's start by making our <code class="literal">ParticleInfluencer</code> interface ready to update the particles in every frame. We're going to add two methods to it. The first one is for updating the particle, and the second one is for updating the influencer itself, as shown in the following code:<div class="informalexample"><pre class="programlisting">public void influenceRealtime(Particle particle, float tpf);
public void update(float tpf);</pre></div></li><li class="listitem">In our <code class="literal">BirdParticleInfluencer</code> class, we're going to need some new fields. The <code class="literal">maxImages</code> property keeps track of how many<a id="id86" class="indexterm"/> images there are in a cycle. The <code class="literal">animationFps</code> property defines how fast the animation should<a id="id87" class="indexterm"/> run. These two properties should <a id="id88" class="indexterm"/>be added to the class's read/write/clone methods as well to ensure that they're saved<a id="id89" class="indexterm"/> properly. The <code class="literal">time</code> and <code class="literal">increaseFrames</code> are runtime properties only:<div class="informalexample"><pre class="programlisting">private int maxImages = 1;
private float animationFps = 10f;
   private float time = 0f;
   private int increaseFrames;</pre></div></li><li class="listitem">Now, let's go to our <code class="literal">update</code> method. This is the method that runs<a id="id90" class="indexterm"/> once every frame. We add functionality to check whether it's time to change the frame in the particle or not. The logic goes like this: when the current passed time is larger than the time between frames, increase the frame index by one. Using<a id="id91" class="indexterm"/> a <code class="literal">while</code> loop rather than an <code class="literal">if</code> statement<a id="id92" class="indexterm"/> allows us to compensate for low frame rate, by skipping several frames, if necessary, to keep up with the frames per second:<div class="informalexample"><pre class="programlisting">public void update(float tpf){
  super.update(tpf);
  float timeBetweenFrames = 1f /  animationFps;
  time += tpf;
  increaseFrames = 0;
  while (time &gt; timeBetweenFrames){
    increaseFrames++;
    time -= interval;
  }
}</pre></div></li><li class="listitem">In <code class="literal">influenceRealtime</code>, which is the method that is run once per particle and frame, all we do is tell it to increase the <code class="literal">imageIndex</code> value if needed, making sure not to exceed the maximum images in the cycle:<div class="informalexample"><pre class="programlisting">public void influenceRealtime(Particle particle, float tpf) {
  super.influenceRealtime(particle, tpf);
  if(increaseFrames &gt; 0){
    particle.imageIndex = (particle.imageIndex + increaseFrames) % maxImages;
  }
}</pre></div></li><li class="listitem">That's the influencer part. Let's make sure <code class="literal">influenceRealtime</code> is called from the <code class="literal">ParticleEmitter</code> class. At the end of the <code class="literal">updateParticle</code> method, add the following code:<div class="informalexample"><pre class="programlisting">particleInfluencer.influenceRealtime(p, tpf);</pre></div></li></ol></div></li></ol></div><p>Unfortunately, we also need to comment out the following line:</p><div class="informalexample"><pre class="programlisting">//p.imageIndex = (int) (b * imagesX * imagesY);</pre></div><p>In the<a id="id93" class="indexterm"/> last section of the recipe, we will create a control that <a id="id94" class="indexterm"/>will update the <code class="literal">ParticleInfluencer</code> class. This consists of the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We create a new class called <code class="literal">BirdParticleEmitterControl</code> and make it extend <code class="literal">AbstractControl</code>. The important bit here is the <code class="literal">controlUpdate</code> method<a id="id95" class="indexterm"/> where we in turn call the <code class="literal">update</code> method of the <code class="literal">ParticleEmitter</code> instance:<div class="informalexample"><pre class="programlisting">public void controlUpdate(float tpf){
  super.update(tpf);
  if(spatial != null &amp;&amp; spatial instanceof ParticleEmitter){
    ((ParticleEmitter)spatial).getParticleInfluencer().update(tpf);
  }
}</pre></div></li><li class="listitem">Apart from that, we also need to add the following code for it to work properly:<div class="informalexample"><pre class="programlisting">public Control cloneForSpatial(Spatial spatial) {
  return new BirdParticleEmitterControl();
}</pre></div></li><li class="listitem">To affect the birds by our changes, we need to do a few more things. First, we need to open the birds scene in the <span class="strong"><strong>SceneComposer</strong></span> window.</li><li class="listitem">Selecting the <span class="strong"><strong>Emitter</strong></span> element, we need to choose <span class="strong"><strong>Add Control..</strong></span> and then select <span class="strong"><strong>Custom Control</strong></span>. Our newly created control should be available in the list.</li><li class="listitem">Now, we need to load the scene inside an application. We just load the scene and move it up into the sky by using the following code:<div class="informalexample"><pre class="programlisting">public void simpleInitApp() {
  Node scene = (Node) assetManager.loadModel("Scenes/ParticleTest.j3o");
  scene.setLocalTranslation(0, 60, 0);
  rootNode.attachChild(scene);
}</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>Particle emitters are normally limited in what control you have over the particles. The <code class="literal">ParticleInfluencer</code> class<a id="id96" class="indexterm"/> gives us some basic control during particle creation.</p><p>Since the birds are flat planes, they look best when viewed straight on. This creates a problem when we have said that they should always point in the direction they're flying if they're moving along the <span class="emphasis"><em>y</em></span> axis.</p><p>The<a id="id97" class="indexterm"/> <code class="literal">influenceParticle</code> method is a method implemented from the <code class="literal">ParticleInfluencer</code> interface and it is called upon the creation of every new particle. Since the <code class="literal">DefaultParticleInfluencer</code> instance is already applying a velocity with variation, we just needed to remove any Y-velocity.</p><p>In<a id="id98" class="indexterm"/> the <code class="literal">ParticleEmitter</code> class, we commented out a<a id="id99" class="indexterm"/> line in the <code class="literal">update</code> method. That's the current animation logic that will override our changes every time. A workaround would be to let the <code class="literal">ParticleInfluencer</code> class keep track of the current frame, but that would make all the birds have the same frame. Another alternative would be to move it to one of the other <code class="literal">ParticleInfluencer</code> classes.</p><p>By using the control pattern to update the <code class="literal">ParticleInfluencer</code> class, we can offset some code and keep minimum changes in the <code class="literal">ParticleEmitter</code> class.</p><p>Unfortunately, the changes we made to the <code class="literal">ParticleEmitter</code> class won't be picked up by Scene Composer, as it uses its own compiled classes. So to see it, we had to start an application and load the scene there.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec40"/>There's more…</h2></div></div></div><p>The birds now continuously flap their wings like many small birds do when flying. Larger birds tend to glide more, with only an occasional flap. They also fly in straight lines.</p><p>The <code class="literal">influenceRealtime</code> method<a id="id100" class="indexterm"/> we created opens up new possibilities to create better looking particles.</p><p>An additional touch would be to implement logic to have the birds both soar and flap interchangeably, and circle around a point or change their direction. Are you up for it?</p></div></div></body></html>