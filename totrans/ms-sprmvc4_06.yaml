- en: Chapter 6. Securing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to secure our web application and also how
    to cope with the security challenges of modern, distributed web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be broken up into five parts:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will set up basic HTTP authentication in a few minutes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will design a form-based authentication for the web pages, keeping
    the basic authentication for the RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will allow the users to sign up via the Twitter OAuth API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will leverage Spring Session to make sure our application can scale
    using a distributed session mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will configure Tomcat to use a secured connection through SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest possible authentication mechanism is basic authentication ([http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication)).
    In a nutshell, our pages will not be available without username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Our server will indicate our resources are secured by sending the `401 Not Authorized`
    HTTP status code and generate a `WWW-Authenticate` header.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully pass the security check, the client must send an `Authorization`
    header containing the `Basic` value followed by a base 64 encoding of the `user:password`
    string. A browser window will prompt the user for a username and a password, granting
    them access to the secured pages if authentication is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add Spring Security to our dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Relaunch your application and navigate to any URL in your application. You
    will be prompted for a username and a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic authentication](img/2117_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you fail to authenticate, you will see that a `401` error is thrown. The
    default username is `user`. The correct password for authentication will be randomly
    generated each time the application launches and will be displayed in the server
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By default, Spring Security secures every resource except a handful of classic
    routes such as `/css/`, `/js/`, `/images/`, and `**/favicon.ico`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to configure the default credentials, you can add the following
    properties to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Authorized users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having only one user in our application does not allow fine-grained security.
    If we wanted more control over the user credentials, we could add the following
    `SecurityConfiguration` class in the `config` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This snippet will set up an in-memory system containing our application's users
    as well as their roles. It will override the security name and password previously
    defined in the application's properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableGlobalMethodSecurity` annotation will allow us to annotate our application's
    method and classes to define their security level.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that only the administrators of our application can
    access the user API. In this case, we just have to add the `@Secured` annotation
    to our resource to allow access only to ADMIN roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can easily test that with httpie by using the `-a` switch to use basic authentication
    and the `-p=h` switch, which will only display the response headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this with a user without the admin profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also notice that Spring Security automatically added some common security
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cache Control`: This prevents the user from caching secured resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`: This tells the browser to block what looks like CSS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Frame-Options`: This disallows our site from being embedded in an IFrame'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Content-Type-Options`: This prevents browsers from guessing the MIME types
    of malicious resources used to forge XSS attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A comprehensive list of these headers is available at [http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#headers).
  prefs: []
  type: TYPE_NORMAL
- en: Authorized URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotating our controller is very easy but isn't always the most viable option.
    Sometimes, we just want total control over our authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `@Secured` annotation; we will come up with something better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what Spring Security will allow us to do by modifying the `SecurityConfiguration`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code sample, we configured our application's security policy
    by using Spring Security's fluent API.
  prefs: []
  type: TYPE_NORMAL
- en: This API allows us to configure Spring Security globally by invoking methods
    associated with different security concerns and chaining with the `and()` method.
  prefs: []
  type: TYPE_NORMAL
- en: What we just defined is a basic authentication, without CSRF protection. Requests
    on `/login` and `/logout` will be allowed for all users. `GET` requests on the
    API will only be permitted for users with the `USER` role, whereas `POST`, `PUT`,
    and `DELETE` requests on the API will only be accessible to users with the ADMIN
    roles. Finally, every other request will require authentication with any role.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF stands for **Cross Site Request Forgery** and refers to an attack where
    a malicious website would display a form on its website and post the form data
    on yours. If the user of your site is not signed out, the `POST` request would
    retain the user cookies and would therefore be authorized.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF protection will generate short-lived tokens that will be posted along with
    the form data. We will see how to properly enable it in the next section; for
    now, let's just disable it. See [http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#csrf)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the authorize request API, have a look at [http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authorize-requests](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authorize-requests).
  prefs: []
  type: TYPE_NORMAL
- en: Thymeleaf security tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to display data coming from the authentication layer,
    for example the user's name and roles, or hide and display part of a web page
    according to users' authorities. The `thymeleaf-extras-springsecurity` module
    will allow us to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this library, we can add a little block under our navigation bar in `layout/default.html`
    to display the logged-in user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the new namespace in the HTML declaration and the `sec:authentication`
    attributes. It allows access to the properties of the `org.springframework.security.core.Authentication`
    object, which represents the user who is currently logged in, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Thymeleaf security tags](img/2117_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't click on the logout link just yet as it doesn't work with basic authentication.
    We will get it to work in the next part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lib` tag also has a handful of other tags, such as the one to check user
    authorizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to the documentation available at [https://github.com/thymeleaf/thymeleaf-extras-springsecurity](https://github.com/thymeleaf/thymeleaf-extras-springsecurity)
    to learn more about the library.
  prefs: []
  type: TYPE_NORMAL
- en: The login form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic authentication is good for our RESTful API, but we would rather have a
    login page carefully designed by our team to improve the web experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security allows us to define as many `WebSecurityConfigurerAdapter`
    classes as we need. We will split our `SecurityConfiguration` class into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApiSecurityConfiguration`: This will be configured first. This will secure
    the RESTful endpoints with basic authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebSecurityConfiguration`: This will then configure login form for the rest
    of our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can remove or rename `SecurityConfiguration` and create `ApiSecurityConfiguration`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `@Order(1)` annotation, which will ensure that this configuration
    is executed before the other one. Then, create a second configuration for the
    web, called `WebSecurityConfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result of this code is that anything matching `/api/**` will be secured
    with basic authentication, without CSRF protection. Then, the second configuration
    will be loaded. It will secure anything else. Everything in this part of the application
    requires the client to be authenticated, except requests on WebJars and on the
    login page (this will avoid the redirection loop).
  prefs: []
  type: TYPE_NORMAL
- en: If an unauthenticated user tries to access a protected resource, they will automatically
    be redirected to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the login URL is `GET /login`. The default login will be posted
    via a `POST /login` request that will contain three values: a user name (`username`),
    a password (`password`) and a CSRF token (`_csrf`). If the login is unsuccessful,
    the user will be redirected to `/login?error`. The default logout page is a `POST
    /logout` request with a CSRF token.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you try to navigate on your application, this form will be generated
    automatically!
  prefs: []
  type: TYPE_NORMAL
- en: If you are already logged in from a previous attempt, close your browser; this
    will clear up the session.
  prefs: []
  type: TYPE_NORMAL
- en: '![The login form](img/2117_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can now log in and out of our application!
  prefs: []
  type: TYPE_NORMAL
- en: 'This is lovely but we can do a lot better with very little effort. First, we
    will define a login page on `/login` in the `WebSecurityConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us create our own login page. To do that, we will need a very
    simple controller to handle the `GET login` request. You can create one in the
    `authentication` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger the display of the `login.html` page located in the template
    directory. Let''s create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we handle the error message and that we post a CSRF token. We also
    use the default username and password input names, but those are configurable
    if needed. The result looks much better already!
  prefs: []
  type: TYPE_NORMAL
- en: '![The login form](img/2117_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see right away that Spring Security assigns anonymous credentials to
    all non-authenticated users by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shouldn''t show the sign-out button to an anonymous user so we can wrap
    the corresponding HTML part in `sec:authorize="isAuthenticated()"` to display
    it to authenticated users only, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Twitter authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is strongly integrated with Twitter, so it seems logical that
    we would allow authentication through Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going further, make sure that you have enabled Twitter sign in on your
    app on Twitter ([https://apps.twitter.com](https://apps.twitter.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Twitter authentication](img/2117_6_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up social authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spring social enables authentication through an OAuth provider such as Twitter
    through a signin/signup scenario. It will intercept a `POST` request on `/signin/twitter`.
    If the user is not known to the `UsersConnectionRepository` interface, the `signup`
    endpoint will be called. It will allow us to take the necessary measures to register
    the user on our system and maybe ask them for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get to work. The first thing we need to do is to add the `signin/**`
    and `/signup` URLs as publicly available resources. Let''s modify our `WebSecurityConfiguration`
    class, changing the `permitAll` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To enable the signin/signup scenario, we also need a `SignInAdapter` interface,
    a simple listener that will be called when an already known user signs in again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create an `AuthenticatingSignInAdapter` class right next to our `LoginController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this handler is called at the perfect time to allow user authentication
    with Spring Security. We''ll come back to that in just a moment. For now, we need
    to define our `SignupController` class in the same package, the one in charge
    of first-time visiting users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, this controller retrieves the current connection from the session. Then,
    it authenticates the user through the same method as before. Lastly, it will trigger
    the `doPostSignUp` event, which will allow Spring Social to store information
    relative to our user in the `UsersConnectionRepository` interface that we mentioned
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is add a triumphant "login with twitter" button
    to our login page, right below the previous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Setting up social authentication](img/2117_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user clicks on the **CONNECT WITH TWITTER** button, they will be redirected
    to a Twitter sign in page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up social authentication](img/2117_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Explanation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn't much code, but it is a bit tricky to understand all the parts. The
    first step to getting what's going on is to have a look at the `SocialWebAutoConfiguration`
    class of Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SocialAutoConfigurationAdapter` class declared in this class contains
    the following bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProviderSignInController` class will automatically be set up if one `ProviderSignInController`
    class is detected in our configuration. This controller is the cornerstone of
    the sign-in process. Have a look at what it does (I will only summarize the important
    parts):'
  prefs: []
  type: TYPE_NORMAL
- en: It will handle the `POST /signin/{providerId}` from our connect button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will redirect the user to the appropriate sign-in URL of our identification
    provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be notified of the OAuth token by a `GET /signin/{providerId}` from
    the identification provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will then handle the sign in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is not found in the `UsersConnectionRepository` interface, it will
    use a `SessionStrategy` interface to store the pending login request and will
    then redirect to the `signupUrl` page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is found, the `SignInAdapter` interface is called and the user is
    redirected to the `postSignupUrl` page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two important components of this identification are the `UsersConnectionRepository`
    interface in charge of storing and retrieving users from some kind of storage
    and the `SessionStrategy` interface that will temporarily store the user connection
    so it can be retrieved from the `SignupController` class.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring Boot creates an `InMemoryUsersConnectionRepository` interface
    for each authentication provider, which means that our user connection data will
    be stored in memory. If we restart the server, the user will become unknown and
    will go through the sign-up process again.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProviderSignInController` class defaults to `HttpSessionSessionStrategy`,
    which will store the connection in the HTTP session. The `ProviderSignInUtils`
    class that we use in our `SignupController` class also uses this strategy by default.
    If we were distributing our application on multiple servers, this would be problematic
    because the session would likely not be available on every server.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy enough to override these defaults by providing a custom `SessionStrategy`
    interface to both the `ProviderSignInController` and `ProviderSignInUtils` classes
    to store data somewhere other than in the HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, we can use another kind of storage for our user connection data by
    providing another implementation of the `UsersConnectionRepository` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Social provides a `JdbcUsersConnectionRepository` interface that will
    automatically save authenticated users in a `UserConnection` table in your database.
    This won''t be covered in this book extensively, but you should be able to configure
    it easily by adding the following bean to your configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out this article [http://geowarin.github.io/spring/2015/08/02/social-login-with-spring.html](http://geowarin.github.io/spring/2015/08/02/social-login-with-spring.html)
    on my blog for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the preceding section, there are several moments when Spring
    Social stores things in the HTTP session. Our user profile is also stored in the
    session. This is a classical approach to keeping things in memory as long as a
    user is navigating the site.
  prefs: []
  type: TYPE_NORMAL
- en: However, this can prove troublesome if we want to scale our application and
    distribute the load to multiple backend servers. We have now entered the cloud
    era, and [Chapter 8](ch08.html "Chapter 8. Optimizing Your Requests"), *Optimizing
    Your Requests* will be about deploying our application to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our session work in a distributed environment, we have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: We could use sticky sessions. This will ensure that a specific user will always
    be redirected to the same server and keep its session. It requires additional
    configuration for the deployment and isn't a particularly elegant approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor our code to put data in a database instead of the session. We can then
    load the user's data from the database if we associate it with a cookie or a token
    sent by the client with each request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Spring Session project to transparently use a distributed database such
    as Redis as the underlying session provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will see how to set up the third approach. It is really
    easy to set up and provides the amazing benefit that it can be turned off without
    impacting the functionality of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to install Redis. To install it on Mac, use
    the `brew` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For other platforms, follow the instructions at [http://redis.io/download](http://redis.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then start the server by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following dependencies to your `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new configuration file next to `application.properties` called `application-redis.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Spring Boot provides a convenient way of associating configuration files with
    a profile. In this case, the `application-redis.properties` file will only be
    loaded if the Redis profile is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, create a `RedisConfig` class in the `config` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this configuration will only be active if the `redis` profile
    is on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re done! We can now launch our app with the following flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also generate the JAR with `gradlew build` and launch it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can launch it with Gradle in Bash, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can also simply set it up as a JVM option in the run configuration of your
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! You now have a server storing the details of your logged-in users.
    This means that we can scale and have multiple servers for our web resources and
    our users won't notice. And we didn't have to write any code on our side.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that you will keep your session even if you restart your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that it works, connect to Redis with the `redis-cli` command. At the
    beginning, it will not contain any keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to your app and start putting things in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can consult the list of available commands at [http://redis.io/commands](http://redis.io/commands).
  prefs: []
  type: TYPE_NORMAL
- en: SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Secure Sockets Layer** (**SSL**) is a security protocol in which data is
    encrypted and sent to a trusted party via a certificate. In this part, I will
    show you the different ways to create a secured connection with Spring Boot. The
    completion of these steps is not mandatory to start the next chapter. They are
    included for completeness, so feel free to skip them if you are in a hurry to
    deploy your application to the cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](ch09.html "Chapter 9. Deploying Your Web Application to the Cloud"),
    *Deploying Your Web Application to the Cloud*, we will see that most cloud platforms
    already handle SSL so we don't have to configure it at our end.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a self-signed certificate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, X.509 certificates are delivered by a Certificate Authority. They
    generally bill you for the service, so for testing purposes, we can create our
    own self-signed keystore file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JDK comes with a binary called keytool, which is used to manage certificates.
    With it, you can create a keystore and import certificates into an existing keystore.
    You can issue the following command inside your project root to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a keystore named `masterspringmvc` with the RSA algorithm
    and will store it in a keystore in `src/main/resources`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not push the keystore to your repository. It can be brute-forced, which would
    void the security of your website. You should also generate keystores with strong,
    randomly generated passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The easy way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If all you care about is having one secure https channel and no http channel,
    it is as easy as it gets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not push your passwords to your repository. Use the `${}` notation to import
    environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The dual way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to have both the http and the https channels available in your
    application, you should add this kind of configuration to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will load the previously generated keystore to create an additional channel
    on port 8443 in addition to port 8080.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Spring Security to automatically redirect connections from `http`
    to `https` with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Behind a secured server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most convenient way to secure your application with SSL is often to put
    it behind an SSL-enabled web server such as Apache or CloudFlare. These will often
    use de facto headers to indicate that the connection was previously initiated
    with SSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot can understand this protocol if you tell it what the correct headers
    are in your `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the documentation here for more details at [http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-use-tomcat-behind-a-proxy-server](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-use-tomcat-behind-a-proxy-server).
  prefs: []
  type: TYPE_NORMAL
- en: The check point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we added three pieces of configuration: `ApiSecurityConfiguration`,
    which configures our REST API to use basic HTTP authentication; `WebSecurityConfiguration`,
    which sets up a login form for our web users to sign in with either an account
    or with Twitter; and `RedisConfig`, which allows our sessions to be stored and
    retrieved from a Redis server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the authentication package, we added a `LoginController` class that redirects
    to our login page, a `SignupController` class that will be called the first time
    a user signs up with Twitter, and an `AuthenticatingSignInAdapater` class that
    will be called on every login with Twitter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The check point](img/2117_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing our web application with Spring is really simple. The possibilities
    are endless, and advanced configurations such as social sign in are at your fingertips.
    Distributing sessions and scaling also take a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to test our application and ensure it never
    regresses.
  prefs: []
  type: TYPE_NORMAL
