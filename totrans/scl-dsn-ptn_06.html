<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creational Design Patterns</h1>
                </header>
            
            <article>
                
<p class="mce-root">From this chapter onward, we will be delving into the actual design patterns that are out there. We have already mentioned the importance of knowing and being able to properly make use of the different design patterns that exist.</p>
<p>Design patterns can be thought of as best practices or even templates that can be used in solving specific problems. The number of problems that a developer will have to tackle is endless, and in many cases, different design patterns have to be combined. However, based on the aspects of a program on which a piece of code is written to solve a problem, we can split design patterns into the following main groups:</p>
<ul>
<li>Creational</li>
<li>Structural</li>
<li>Behavioral</li>
</ul>
<p>This chapter will focus on the <strong>creational design patterns</strong>, and of course, we will look at them from the point of view of the Scala programming language. We will go through the following topics:</p>
<ul>
<li>What are creational design patterns</li>
<li>The factory method</li>
<li>The abstract factory</li>
<li>Other factory design patterns</li>
<li>Lazy initialization</li>
<li>The singleton</li>
<li>The builder</li>
<li>The prototype</li>
</ul>
<p>After formally defining the creational design patterns, we will look at each one of them separately in greater detail. We will focus on when and how to use them, when to avoid some patterns, and of course, show some relevant examples.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What are creational design patterns?</h1>
                </header>
            
            <article>
                
<p>Creational design patterns, as the name suggests, deal with object creation. In some cases, creating objects in a program could involve some extra complexities, and creational design patterns hide these complexities in order to make the use of software components easier. The object creation complexity could be caused by any of the following:</p>
<ul>
<li>The number of initialization parameters</li>
<li>Required validation</li>
<li>The complexity of acquiring the required parameters</li>
</ul>
<p>The preceding list could possibly be expanded even more and in many cases, these factors are present not just individually, but in combinations.</p>
<p>We will be focusing on the aspects of creational design patterns in the following sections of this chapter and hopefully, you will have a good understanding of why they are needed and how to use them in real life.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The factory method design pattern</h1>
                </header>
            
            <article>
                
<p>The factory method design pattern exists in order to encapsulate an actual class instantiation. It simply provides an interface to create an object, and then the subclasses of the factory decide which concrete class to instantiate. This design pattern could become useful in cases where we want to create different objects during the runtime of the application. This design pattern is also helpful when object creation would otherwise require extra parameters to be passed by the developer.</p>
<p>Everything will become clearer with an example, and we will provide one in the following subsections.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>For the factory method, we will be showing an example with databases. To keep things simple (just because the actual <kbd>java.sql.Connection</kbd> has a lot of methods), we will define our own <kbd>SimpleConnection</kbd> and it will have concrete implementations for <kbd>MySQL</kbd> and <kbd>PostgreSQL</kbd>.</p>
<p>The diagram for the connection classes looks like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6dbbcc16-bab6-4f54-864c-03829f38fca5.png" style="width:36.92em;height:15.83em;" width="992" height="425"/></div>
<p>Now, creating these connections will depend on the database we want to use. However, using them will be exactly the same because of the interface they provide. The actual creation might also involve some extra computations that we want to hide from the user and which will be relevant if we're talking about a different constant for each database. That's why we use a factory method design pattern. The following diagram shows how the rest of our code will be structured:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d77563c5-434b-4bfa-8a2d-8c148cc88e29.png" style="width:37.08em;height:12.83em;" width="1028" height="354"/></div>
<p>In the preceding figure, <strong>MysqlClient</strong> and <strong>PgsqlClient</strong> are the concrete implementations of the <strong>DatabaseClient</strong>. The factory method is <strong>connect</strong> and it returns a different connection in different clients. Since we override, the signature in the code still shows that the method returns a <strong>SimpleConnection</strong>, but the actual types are concrete. In the diagram, for clarity, we have chosen to show the actual returned type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>From the preceding diagram, it is clear that depending on the database client we use, a different connection will be used and created. Now, let's have a look at the code representation for the preceding diagrams. First is the <kbd>SimpleConnection</kbd> with its concrete implementations:</p>
<pre><span>trait </span>SimpleConnection {<br/>  <span>def </span><span>getName</span>(): <span>String<br/></span><span><br/></span><span>  </span><span>def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit<br/></span>}<br/><br/><span>class </span>SimpleMysqlConnection <span>extends </span>SimpleConnection {<br/>  <span>override def </span><span>getName</span>(): <span>String </span>= <span>"SimpleMysqlConnection"<br/></span><span><br/></span><span>  </span><span>override def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Executing the query '</span><span>$</span>query<span>' the MySQL way."</span>)<br/>  }<br/>}<br/><br/><span>class </span>SimplePgSqlConnection <span>extends </span>SimpleConnection {<br/>  <span>override def </span><span>getName</span>(): <span>String </span>= <span>"SimplePgSqlConnection"<br/></span><span><br/></span><span>  </span><span>override def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"Executing the query '</span><span>$</span>query<span>' the PgSQL way."</span>)<br/>  }<br/>}</pre>
<p>We use these implementations in our factory method, called <kbd>connect</kbd>. The following code snippet shows how we can take advantage of <kbd>connect</kbd> and how we can implement it in specific database clients:</p>
<pre><span>abstract class </span>DatabaseClient {<br/>  <span>def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit </span>= {<br/>    <span>val </span>connection = connect()<br/>    connection.executeQuery(query)<br/>  }<br/><br/>  <span>protected def </span><span>connect</span>(): SimpleConnection<br/>}<br/><br/><span>class </span>MysqlClient <span>extends </span>DatabaseClient {<br/>  <span>override protected def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimpleMysqlConnection<br/>}<br/><br/><span>class </span>PgSqlClient <span>extends </span>DatabaseClient {<br/>  <span>override protected def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimplePgSqlConnection<br/>}</pre>
<p>Using our database clients is then straightforward, as shown here:</p>
<pre><span>object </span>Example {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>clientMySql: DatabaseClient = <span>new </span>MysqlClient<br/>    <span>val </span>clientPgSql: DatabaseClient = <span>new </span>PgSqlClient<br/>    clientMySql.executeQuery(<span>"SELECT * FROM users"</span>)<br/>    clientPgSql.executeQuery(<span>"SELECT * FROM employees"</span>)<br/>  }<br/>}</pre>
<p>The preceding code example will produce the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/01845756-d26d-4581-be6d-33d30b57588e.png" width="724" height="91"/></div>
<p>We saw how the factory method design pattern works. If we need to add another database client, then we can just extend <kbd>DatabaseClient</kbd> and return a class that extends <kbd>SimpleConnection</kbd> when we implement the <kbd>connect</kbd> method.</p>
<div class="packt_infobox">The preceding choice to use an abstract class for the <kbd>DatabaseClient</kbd> and a trait for the <kbd>SimpleConnection</kbd> was just random. We could, of course, change the abstract class with a trait.</div>
<p>In other cases, the objects created by the factory method might require parameters in their constructor and these parameters could depend on some specific state or functionality of the object that owns the factory method. This is where this design pattern could actually shine.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala alternatives</h1>
                </header>
            
            <article>
                
<p>As with anything in software engineering, this design pattern could also be achieved using different approaches. Which one to use really boils down to the requirements and specific features of the application and objects being created. Some possible alternatives include the following:</p>
<ul>
<li>Passing the needed components to the class that needs them in the constructor (object composition). This, however, would mean that these components will be specific instances rather than new ones, every time a request for them is made.</li>
<li>Passing a function that will create the objects we need.</li>
</ul>
<p>Using the richness of Scala, we can avoid this design pattern or we can just be smarter about how we create the objects that we will be using or exposing whatever the factory method will be creating. There is no right or wrong way in the end. There is, however, a way that would make things simpler, both in terms of usage and maintenance, and it should be chosen by considering the specific requirements.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>As with other factories, the details of object creation are hidden. This means that if we change the way a specific instance has to be created, we would have to change only the factory methods that create it (this might involve a lot of creators though, depending on the design). The factory method allows us to use the abstract version of a class and defer the object creation to subclasses.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>In the preceding examples, we might quickly run into issues if we have more than one factory method. This would first require the programmer to implement many more methods, but more importantly, it could lead to the returned objects being incompatible. Let's see this in a short example. First, we will declare another trait called <kbd>SimpleConnectionPrinter</kbd>, which will have one method that prints something when called:</p>
<pre><span>trait </span>SimpleConnectionPrinter {<br/>  <span>def </span><span>printSimpleConnection</span>(connection: SimpleConnection): <span>Unit<br/></span>}</pre>
<p>Now, we want to change our <kbd>DatabaseClient</kbd> and name it differently (<kbd>BadDatabaseClient</kbd>). It will look like the following:</p>
<pre><span>abstract class </span>BadDatabaseClient {<br/>  <span>def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit </span>= {<br/>    <span>val </span>connection = connect()<br/>    <span>val </span>connectionPrinter = getConnectionPrinter()<br/>    connectionPrinter.printSimpleConnection(connection)<br/>    connection.executeQuery(query)<br/>  }<br/><br/>  <span>protected def </span><span>connect</span>(): SimpleConnection<br/><br/>  <span>protected def </span><span>getConnectionPrinter</span>(): SimpleConnectionPrinter<br/>}</pre>
<p>The only difference here to our original example is that we have another factory method, that we will also call when executing a query. Similar to the <kbd>SimpleConnection</kbd> implementations, let's now create two more for MySQL and PostgreSQL for our <kbd>SimpleConnectionPrinter</kbd>:</p>
<pre><span>class </span>SimpleMySqlConnectionPrinter <span>extends </span>SimpleConnectionPrinter {<br/>  <span>override def </span><span>printSimpleConnection</span>(connection: SimpleConnection): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"I require a MySQL connection. It is: '</span><span>$</span>{connection.getName()}<span>'"</span>)<br/>  }<br/>}<br/><br/><span>class </span>SimplePgSqlConnectionPrinter <span>extends </span>SimpleConnectionPrinter {<br/>  <span>override def </span><span>printSimpleConnection</span>(connection: SimpleConnection): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"I require a PgSQL connection. It is: '</span><span>$</span>{connection.getName()}<span>'"</span>)<br/>  }<br/>}</pre>
<p>We can now apply the factory design pattern and create MySQL and PostgreSQL clients, as shown here:</p>
<pre><span>class </span>BadMySqlClient <span>extends </span>BadDatabaseClient {<br/>  <span>override protected def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimpleMysqlConnection<br/><br/>  <span>override protected def </span><span>getConnectionPrinter</span>(): SimpleConnectionPrinter = <span>new </span>SimpleMySqlConnectionPrinter<br/>}<br/><br/><span>class </span>BadPgSqlClient <span>extends </span>BadDatabaseClient {<br/>  <span>override protected def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimplePgSqlConnection<br/><br/>  <span>override protected def </span><span>getConnectionPrinter</span>(): SimpleConnectionPrinter = <span>new </span>SimpleMySqlConnectionPrinter<br/>}</pre>
<p>The preceding implementations are completely valid. We can now use them in an example:</p>
<pre><span>object </span>BadExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>clientMySql: BadDatabaseClient = <span>new </span>BadMySqlClient<br/>    <span>val </span>clientPgSql: BadDatabaseClient = <span>new </span>BadPgSqlClient<br/>    clientMySql.executeQuery(<span>"SELECT * FROM users"</span>)<br/>    clientPgSql.executeQuery(<span>"SELECT * FROM employees"</span>)<br/>  }<br/>}</pre>
<p>This example will have the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/1f6a5228-b54e-49d0-a92c-29502f749cd1.png" width="722" height="128"/></div>
<p>What happened in the preceding example is that we got a logical error, and nothing notifies us about this. When the number of methods to implement grows, this could become a problem and mistakes could be easily made. For example, our code didn't throw an exception, but this pitfall could lead to runtime errors that could be really hard to discover and debug.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The abstract factory</h1>
                </header>
            
            <article>
                
<p>The abstract factory is another design pattern from the family of <em>factory</em> patterns. The purpose is the same as all factory design patterns—to encapsulate the object creation logic and hide it from the user. The difference is how it is implemented.</p>
<p>The abstract factory design pattern relies on object composition in contrast to inheritance, which is used by the factory method. Here, we have a separate object, which provides an interface to create instances of the classes we need.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>Let's keep using the preceding <kbd>SimpleConnection</kbd> example here. The following diagram shows how the abstract factory is structured:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/130a3617-d23d-450b-81e8-0f4eb758362c.png" style="width:38.00em;height:12.25em;" width="992" height="319"/></div>
<p>As we can see from the preceding diagram, now we have a hierarchy of factories rather than a method inside our database client. We will be using the abstract <strong>DatabaseConnectorFactory</strong> in our application and it will be returning the right objects, depending on the actual instance type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Let's have a look at our example from the source point of view. The following code listing shows the factory hierarchy:</p>
<pre><span>trait </span>DatabaseConnectorFactory {<br/>  <span>def </span><span>connect</span>(): SimpleConnection<br/>}<br/><br/><span>class </span>MySqlFactory <span>extends </span>DatabaseConnectorFactory {<br/>  <span>override def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimpleMysqlConnection<br/>}<br/><br/><span>class </span>PgSqlFactory <span>extends </span>DatabaseConnectorFactory {<br/>  <span>override def </span><span>connect</span>(): SimpleConnection = <span>new </span>SimplePgSqlConnection<br/>}</pre>
<p>We can then use our factory by passing it to a class, that will call the required methods. Here is an example similar to the one we showed for the factory method design pattern:</p>
<pre><span>class </span>DatabaseClient(connectorFactory: DatabaseConnectorFactory) {<br/>  <span>def </span><span>executeQuery</span>(query: <span>String</span>): <span>Unit </span>= {<br/>    <span>val </span>connection = connectorFactory.connect()<br/>    connection.executeQuery(query)<br/>  }<br/>}</pre>
<p>Let's see an example that uses our database client:</p>
<pre><span>object </span>Example {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>clientMySql: DatabaseClient = <span>new </span>DatabaseClient(<span>new </span>MySqlFactory)<br/>    <span>val </span>clientPgSql: DatabaseClient = <span>new </span>DatabaseClient(<span>new </span>PgSqlFactory)<br/>    clientMySql.executeQuery(<span>"SELECT * FROM users"</span>)<br/>    clientPgSql.executeQuery(<span>"SELECT * FROM employees"</span>)<br/>  }<br/>}</pre>
<p>The following screenshot shows the output of this program:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/dc32b2bc-2570-48a4-a908-8ef4858124a3.png" width="722" height="93"/></div>
<p>This is how the abstract factory design pattern works. If we need to add another database client to our application, we can achieve this by adding another class that extends <kbd>DatabaseConnectionFactory</kbd>. This is nice because it makes refactoring and extending easy.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala alternatives</h1>
                </header>
            
            <article>
                
<p>This design pattern can also be achieved using different approaches. The fact that we use object composition to pass a factory to our class indicates that we can do something else—we can simply pass a function, just because in Scala they are a part of unification and they are treated the same way as objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>As with all factories, the details of object creation are hidden. The abstract factory design pattern is particularly useful when we want to expose families of objects (for example, database connectors). The clients then become decoupled from the concrete classes. This pattern is commonly shown as an example in different UI toolkits, where elements differ for different operating systems. It is also quite testable because we can provide mocks instead of an actual factory to the clients.</p>
<p>Even though the incompatibility problem that we mentioned previously is still present here, it is somewhat harder to encounter now. This is mainly because here, the client will actually just pass one single factory as a parameter, and in the case where we provide the user with concrete factories, everything was already taken care of when these factories were written.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>It could be problematic if the objects and methods we are using (<kbd>SimpleConnection</kbd>, in our case) change signatures. In some cases, this pattern could also complicate our code unnecessarily and make it unreadable and hard to follow.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Other factory design patterns</h1>
                </header>
            
            <article>
                
<p>There are some different variations of the factory design patterns. In all cases though, the purpose is generally the same—hide creation complexity. In the <span><span>following</span></span> subsections, we will briefly mention two of the other factory design patterns—<strong>static factory</strong> and <strong>simple factory</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The static factory</h1>
                </header>
            
            <article>
                
<p>The static factory could be represented as a static method, which is a part of the base class. It is called to create concrete instances, which extend the base class. One of the biggest drawbacks here, however, is that if another extension of the base class is added, the base class (because of the static method) also has to be edited. Let's show a simple example from the world of animals:</p>
<pre><span>trait </span>Animal<br/><span>class </span>Bird <span>extends </span>Animal<br/><span>class </span>Mammal <span>extends </span>Animal<br/><span>class </span>Fish <span>extends </span>Animal<br/><br/><span>object </span>Animal {<br/>  <span>def </span><span>apply</span>(animal: <span>String</span>): Animal = animal.toLowerCase <span>match </span>{<br/>    <span>case </span><span>"bird" </span>=&gt; <span>new </span>Bird<br/>    <span>case </span><span>"mammal" </span>=&gt; <span>new </span>Mammal<br/>    <span>case </span><span>"fish" </span>=&gt; <span>new </span>Fish<br/>    <span>case </span>x: <span>String </span>=&gt; <span>throw new </span>RuntimeException(<span>s"Unknown animal: </span><span>$</span>x<span>"</span>)<br/>  }<br/>}</pre>
<p>Here, every time we add a new extension of <kbd>Animal</kbd>, we would have to change the <kbd>apply</kbd> method to account for it, especially if we want to account for the new types.</p>
<div class="packt_infobox">The preceding example uses the special apply method of the <kbd>Animal</kbd> companion object. We could have different versions of it and it would provide us with a syntactic sugar that allows us to simply use <kbd>Animal("mammal")</kbd>. This makes it even more convenient to use the factory, as its existence will be indicated by the good IDEs because of the base class.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The simple factory</h1>
                </header>
            
            <article>
                
<p>The simple factory is better than the static factory, because the actual factory functionality is in another class. This removes the requirement for the base class to be modified every time a new extension is added. This is similar to the abstract factory, but the difference is that here we don't have a base factory class, we use a concrete one instead. Usually, one starts with a simple factory, which evolves to abstract with time and project evolution.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Factory combinations</h1>
                </header>
            
            <article>
                
<p>Of course, it is possible to combine different types of factories together. This, however, needs to be done with caution and only if necessary. Otherwise, overusing the design pattern could lead to bad code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Lazy initialization</h1>
                </header>
            
            <article>
                
<p>Lazy initialization in software engineering is when we delay the instantiation of an object or a variable until the first time we need it. The idea behind this is to defer or even avoid some expensive operations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>In other languages, such as Java, lazy initialization is often used in conjunction with the factory method design pattern. This method usually checks whether the object/variable we want to use is initialized; if not, it initializes the object and finally returns it. In consecutive uses, the already initialized object/variable is returned.</p>
<p>The Scala programming language has built-in support for lazy initialization. It makes use of the <kbd>lazy</kbd> keyword. That's why providing a class diagram in this case is pointless.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>Let's see how lazy initialization works in Scala and also prove that it is indeed lazy. We will look at an example that calculates a circle area. As we know, the formula is <kbd>pi * r<sup>2</sup></kbd>. Programming languages have support for mathematical constants and this is not how we will do it in real life. However, the example is still relevant if we're talking about a different constant that is not widely known, or a constant that usually fluctuates around a value, but could be different every day.</p>
<p>At school, we've been taught that pi is equal to 3.14. This is true, however, there are many extra digits after that and if we really care about precision, we will need to account for them as well. For example, pi with 100 digits looks like this:</p>
<pre>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679</pre>
<p>So, let's create a utility that will return the area when given a circle radius. We will have our basic pi as a variable in our utility class, but we will also allow the users to decide if they want a precise area or not. If they do, we will read the 100-digit pi from a configuration file:</p>
<pre><span>import java.util.Properties<br/><br/>object </span>CircleUtils {<br/>  <span>val </span><span>basicPi </span>= <span>3.14<br/></span><span>  </span><span>lazy val </span><span>precisePi</span>: <span>Double </span>= {<br/>    System.<span>out</span>.println(<span>"Reading properties for the precise PI."</span>)<br/>    <span>val </span>props = <span>new </span>Properties()<br/>    props.load(getClass.getResourceAsStream(<span>"pi.properties"</span>))<br/>    props.getProperty(<span>"pi.high"</span>).toDouble<br/>  }<br/><br/>  <span>def </span><span>area</span>(radius: <span>Double, </span>isPrecise: <span>Boolean </span>= <span>false</span>): <span>Double </span>= {<br/>    <span>val </span>pi: <span>Double </span>= <span>if </span>(isPrecise) <span>precisePi </span><span>else </span><span>basicPi<br/></span><span>    </span>pi * Math.<span>pow</span>(radius<span>, </span><span>2</span>)<br/>  }<br/>}</pre>
<p>The preceding code does exactly what we said. Depending on precision, we will use a different version of pi. The lazy initialization here is useful because we might never ever need a precise area, or we could need it sometimes, but not others. Moreover, reading from a configuration file is an I/O operation, which is considered to be slow and it could have a negative effect when done multiple times. Let's see how we use our utility:</p>
<pre><span>object </span>Example {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>s"The basic area for a circle with radius 2.5 is </span><span>$</span>{CircleUtils.area (<span>2.5</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The precise area for a circle with radius 2.5 is </span><span>$</span>{CircleUtils.area (<span>2.5</span><span>, </span><span>true</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The basic area for a circle with radius 6.78 is </span><span>$</span>{CircleUtils.area (<span>6.78</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The precise area for a circle with radius 6.78 is </span><span>$</span>{CircleUtils.area (<span>6.78</span><span>, </span><span>true</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of this program will be the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ce5f3f84-1ff5-49bf-9d0e-51427e29de4a.png" width="723" height="145"/></div>
<p>We can have a few observations from our example output. First, the precision really matters and there are industries out there including financial institutions, space industry, and so on where precision is taken really seriously. Second, in the lazy initialization block, we used a <kbd>print</kbd> statement and it is printed when we used the precise implementation for the first time. Normal values get initialized when the instance is created. This shows that indeed, lazy initialization in Scala defers it until the variable is used for the first time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>Lazy initialization is particularly useful when initializing an object or variable that would take too long or might not even be needed. Some might say that we can simply use methods, and this is partly true. However, imagine a case where we might need to access a lazily initialized variable/object from multiple methods in different calls to our object. In this case, it is useful to store the result somewhere and just reuse it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>In languages other than Scala, some special care needs to be taken when lazy initialization is used in a multithreaded setting. In Java, for example, you need to do initialization in a <kbd>synchronized</kbd> block. In order to provide even better safety, <em>double-checked locking</em> is preferred. There is no such danger in Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The singleton design pattern</h1>
                </header>
            
            <article>
                
<p>The singleton design pattern ensures that a class has only one object instance in the entire application. It introduces a global state in the applications it is used in.</p>
<p>A singleton object can be initialized using different strategies—lazy initialization or eager initialization. This all depends on the intended use, the time it takes an object to be initialized, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>Singletons are another example of design patterns, which are supported out of the box by the Scala programming language syntax. We achieve this by using the object keyword. In this case, again, providing a class diagram is not necessary, so we will step right into the example in the next subsection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>The aim of this example is to show how to create singleton instances in Scala and have an understanding of when exactly instances are created in Scala. We will look at a class called <kbd>StringUtils</kbd>, that provides different utility methods related to strings:</p>
<pre><span>object </span>StringUtils {<br/>  <span>def </span><span>countNumberOfSpaces</span>(text: <span>String</span>): <span>Int </span>= text.split(<span>"</span><span>\\</span><span>s+"</span>).length - <span>1<br/></span>}</pre>
<p>Using this class is then straightforward. Scala takes care of creating the object, thread safety, and so on:</p>
<pre><span>object </span>UtilsExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>sentence = <span>"Hello there! I am a utils example."<br/></span><span>    </span>System.<span>out</span>.println(<br/>      <span>s"The number of spaces in '</span><span>$</span>sentence<span>' is: </span><span>$</span>{StringUtils.countNumberOfSpaces(sentence)}<span>"<br/></span><span>    </span>)<br/>  }<br/>}</pre>
<p>The output from this program will be the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/9771e011-9d3c-4492-acbf-30cc6c4e4d03.png" width="722" height="73"/></div>
<p>The preceding example is clear and even though the <kbd>StringUtils</kbd> object will be a singleton instance, it more resembles a class with static methods. This is actually how static methods are defined in Scala. It would be more interesting to add some state to a singleton class. The following example shows exactly this:</p>
<pre><span>object </span>AppRegistry {<br/>  System.<span>out</span>.println(<span>"Registry initialization block called."</span>)<br/>  <span>private val </span><span>users</span>: <span>Map</span>[<span>String</span><span>, </span><span>String</span>] = TrieMap.empty<br/><br/>  <span>def </span><span>addUser</span>(id: <span>String</span><span>, </span>name: <span>String</span>): <span>Unit </span>= {<br/>    <span>users</span>.put(id<span>, </span>name)<br/>  }<br/><br/>  <span>def </span><span>removeUser</span>(id: <span>String</span>): <span>Unit </span>= {<br/>    <span>users</span>.remove(id)<br/>  }<br/><br/>  <span>def </span><span>isUserRegistered</span>(id: <span>String</span>): <span>Boolean </span>= <span>users</span>.contains(id)<br/><br/>  <span>def </span><span>getAllUserNames</span>(): <span>List</span>[<span>String</span>] = <span>users</span>.map(_._2).toList<br/>}</pre>
<p>The <kbd>AppRegistry</kbd> contains a concurrent map of all the users currently using the application. This is our global state and we have methods that allow us to manipulate it. We also have a <kbd>println</kbd> statement, which will be executed when the singleton instance is created. We can use our registry in the following application:</p>
<pre><span>object </span>AppRegistryExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    System.<span>out</span>.println(<span>"Sleeping for 5 seconds."</span>)<br/>    Thread.<span>sleep</span>(<span>5000</span>)<br/>    System.<span>out</span>.println(<span>"I woke up."</span>)<br/>    AppRegistry.addUser(<span>"1"</span><span>, </span><span>"Ivan"</span>)<br/>    AppRegistry.addUser(<span>"2"</span><span>, </span><span>"John"</span>)<br/>    AppRegistry.addUser(<span>"3"</span><span>, </span><span>"Martin"</span>)<br/>    System.<span>out</span>.println(<span>s"Is user with ID=1 registered? </span><span>$</span>{AppRegistry.isUserRegistered(<span>"1"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>"Removing ID=2"</span>)<br/>    AppRegistry.removeUser(<span>"2"</span>)<br/>    System.<span>out</span>.println(<span>s"Is user with ID=2 registered? </span><span>$</span>{AppRegistry.isUserRegistered(<span>"2"</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"All users registered are: </span><span>$</span>{AppRegistry.getAllUserNames().mkString (<span>","</span>)}<span>"</span>)<br/>  }<br/>}</pre>
<p>Let's run this example and see what the final output will be:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c22edb63-6a1a-4530-a5e7-b991915f526e.png" style="width:50.17em;height:12.67em;" width="721" height="182"/></div>
<p>Now, our example presents a proper singleton instance, which contains a global state. This state will be accessible from all the application classes while the instance runs. From the example code and our output, we can make a few conclusions:</p>
<ul>
<li>Singletons in Scala are lazily initialized</li>
<li>While creating a singleton instance, we cannot provide dynamic parameters to the singleton class instance</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>In Scala, the singleton design pattern and static methods are implemented the same way. That's why singletons are useful for creating utility classes that have no state. Singletons in Scala can also be used to build ADTs, which we talked about in the previous chapters.</p>
<p>Another thing that is strictly valid for Scala is that in Scala, singletons are created in a thread-safe way out of the box and without the need to take any special care.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>Often, the singleton design pattern is actually considered an anti-pattern. Many people say that global state should not exist the way it does with singleton classes. Some say that if you have to use singletons, you should try and refactor your code. While this is true in some cases, there is sometimes a good use for singletons. Generally, the rule of thumb is—if you can avoid them, then do.</p>
<p>Another thing that could be pointed out specifically for Scala singletons is that they can really have only one instance. While this is the actual definition of the pattern, with other languages, we could have a predefined number of more than just one singleton object and have some control on this using custom logic.</p>
<p>This does not really affect Scala but it is still worth mentioning. In the case where a singleton is initialized lazily in an application, in order to provide thread safety, you need to rely on locking mechanisms, for example, the double-checked locking mentioned in the previous section. Accessing the singletons in an application, no matter if it's Scala or not, also needs to be done in a thread-safe way or the singleton should take care of this internally.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The builder design pattern</h1>
                </header>
            
            <article>
                
<p>The builder design pattern helps to create instances of classes using class methods rather than the class constructors. It is particularly useful in cases where a class might need multiple versions of its constructor in order to allow different usage scenarios.</p>
<p>Moreover, in some cases, it might not even be possible to define all combinations or they might not be known. The builder design pattern uses an extra object, called <kbd>builder</kbd>, in order to receive and store initialization parameters before building the final version of an object.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>In this subsection, we will provide a class diagram for the builder pattern the way it was classically defined and the way it looks in other languages, including Java. Later, we will present different versions of the code on the basis of them being more appropriate for Scala and of the observations and discussions we will have around them.</p>
<p>Let's have a <kbd>Person</kbd> class with different parameters—<kbd>firstName</kbd>, <kbd>lastName</kbd>, <kbd>age</kbd>, <kbd>departmentId</kbd>, and so on. We will show the actual code for it in the next subsection. Creating a concrete constructor, especially if those fields might not always be known or required, might take too much time. It would also make the code extremely hard to maintain in the future.</p>
<p>A builder pattern seems like a good idea and the class diagram for it will look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7d5f9ce8-7791-4b38-abed-7a3184484666.png" style="width:32.92em;height:34.58em;" width="744" height="780"/></div>
<p>As we already mentioned, this is how the builder pattern looks in purely object-oriented languages (not Scala). There could be different representations of it where the builder is abstracted, and then there are concrete builders. The same is true for the product that is being built. In the end, they all aim to get to the same point—make object creation easier.</p>
<p>In the next subsection, we will provide code implementations that will show exactly how to use and write the builder design pattern in Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>There are actually three main ways in which we can represent the builder design pattern in Scala:</p>
<ul>
<li>The classical way, as shown in the preceding diagram, is like other object-oriented languages. This way is actually not recommended, even though it is possible in Scala. It uses mutability in order to work, which contradicts the immutability principle of the language. We will show it here for completeness and in order to point out how much easier it is to achieve the builder design pattern using simple features of Scala.</li>
<li>Using case classes with default parameters. We will see two versions—one that validates the parameters and another one that doesn't.</li>
<li>Using generalized type constraints.</li>
</ul>
<p>We will focus on these in the next few subsections. In order to keep things short and simple, we will have fewer fields in our classes; however, it has to be noted that the builder design pattern really shines when there is a large number of fields. You can experiment by adding more fields to the code examples that are provided in this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A Java-like implementation</h1>
                </header>
            
            <article>
                
<p>This implementation directly reflects what we have in the previous diagram. First, let's see what our <kbd>Person</kbd> class will look like:</p>
<pre><span>class </span>Person(builder: PersonBuilder) {<br/>  <span>val </span><span>firstName </span>= builder.firstName<br/>  <span>val </span><span>lastName </span>= builder.lastName<br/>  <span>val </span><span>age </span>= builder.age<br/>}</pre>
<p>As we can see in the preceding code, it takes a builder and uses the values set in the builder for initialization of its fields. The builder code will look like the following:</p>
<pre><span>class </span>PersonBuilder {<br/>  <span>var </span><span>firstName </span>= <span>""<br/></span><span>  </span><span>var </span><span>lastName </span>= <span>""<br/></span><span>  </span><span>var </span><span>age </span>= <span>0<br/></span><span><br/></span><span>  </span><span>def </span><span>setFirstName</span>(firstName: <span>String</span>): PersonBuilder = {<br/>    <span>this</span>.<span>firstName </span>= firstName<br/>    <span>this<br/></span><span>  </span>}<br/><br/>  <span>def </span><span>setLastName</span>(lastName: <span>String</span>): PersonBuilder = {<br/>    <span>this</span>.<span>lastName </span>= lastName<br/>    <span>this<br/></span><span>  </span>}<br/><br/>  <span>def </span><span>setAge</span>(age: <span>Int</span>): PersonBuilder = {<br/>    <span>this</span>.<span>age </span>= age<br/>    <span>this<br/></span><span>  </span>}<br/><br/>  <span>def </span><span>build</span>(): Person = <span>new </span>Person(<span>this</span>)<br/>}</pre>
<p>Our builder has methods that can set each corresponding field of the <kbd>Person</kbd> class. These methods return the same instance of the builder and this allows us to chain many calls together. Here is how we can use our builder:</p>
<pre><span>object </span>PersonBuilderExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>person: Person = <span>new </span>PersonBuilder()<br/>      .setFirstName(<span>"Ivan"</span>)<br/>      .setLastName(<span>"Nikolov"</span>)<br/>      .setAge(<span>26</span>)<br/>      .build()<br/>    System.<span>out</span>.println(<span>s"Person: </span><span>$</span>{person.firstName} <span>$</span>{person.lastName}<span>. Age: </span><span>$</span>{person.age}<span>."</span>)<br/>  }<br/>}</pre>
<p>This is how to use the builder design pattern. Now, we can create a <kbd>Person</kbd> object and provide whatever data we have for it—even if we have a subset of all possible fields, we can specify them and the rest will have a default value. There is no need to create new constructors if other fields are being added to the <kbd>Person</kbd> class. They just need to be made available through the <kbd>PersonBuilder</kbd> class.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementation with a case class</h1>
                </header>
            
            <article>
                
<p>The preceding builder design pattern looks nice and clear, but it requires writing some extra code and creating boilerplate. Moreover, it requires us to have mutable fields in the <kbd>PersonBuilder</kbd> class, which is against some of the principles in Scala.</p>
<div class="packt_tip"><span class="packt_screen">Preferring immutability</span><br/>
<br/>
Immutability is an important principle in Scala and it should be preferred. The builder design pattern with case classes uses immutable fields and this is considered a good practice.</div>
<p>Scala has case classes, which make the implementation of the builder pattern much simpler. Here is what it will look like:</p>
<pre><span>case class </span>Person(<br/>  firstName: <span>String </span>= <span>""</span><span>,<br/></span><span>  </span>lastName: <span>String </span>= <span>""</span><span>,<br/></span><span>  </span>age: <span>Int </span>= <span>0<br/></span>)</pre>
<p>The use of this case class is similar to how the preceding builder design pattern is used:</p>
<pre><span>object </span>PersonCaseClassExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>person1 = Person(<br/>      firstName = <span>"Ivan"</span><span>,<br/></span><span>      </span>lastName = <span>"Nikolov"</span><span>,<br/></span><span>      </span>age = <span>26<br/></span><span>    </span>)<br/>    <span>val </span>person2 = Person(<br/>      firstName = <span>"John"<br/></span><span>    </span>)<br/>    System.<span>out</span>.println(<span>s"Person 1: </span><span>$</span>{person1}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Person 2: </span><span>$</span>{person2}<span>"</span>)<br/>  }<br/>}</pre>
<p>The preceding code is much shorter and easier to maintain than the first version. It allows the developer to do absolutely the same as the original builder pattern, but with a shorter and cleaner syntax. It also keeps the fields of the <kbd>Person</kbd> class immutable, which is a good practice to follow in Scala.</p>
<div class="packt_infobox"><span class="packt_screen">Choosing default values</span><br/>
<br/>
The choice of default values for the builder design pattern is entirely up to the developer. Some would prefer to use <kbd>Option</kbd> and put <kbd>None</kbd> when there is no value specified. Others might assign some different special values. This choice can be dictated by personal choice, the problem that is being solved, the style guides employed by an engineering team, and more.</div>
<p>One drawback of the preceding two approaches is that there is no validation. What if some components depended on each other and there are specific variables that require initialization? In the cases that use the preceding two approaches, we could run into runtime exceptions. The next subsection will show us how to make sure that validation and requirement satisfactions are implemented.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using generalized type constraints</h1>
                </header>
            
            <article>
                
<p>In many cases in which we create objects in software engineering, we have dependencies. We either need to have something initialized in order to use a third component, or we require a specific order of initialization, and so on. Both builder pattern implementations we looked at earlier lack the capability to make sure something is or isn't initialized. This way, we need to create some extra validation around the builder design pattern in order to make sure everything will work as expected, yet we will see whether it is safe to create an object only during runtime.</p>
<p>Using some of the techniques we already looked at earlier in this book, we can create a builder that validates whether all requirements are satisfied during compile time. This is called a <strong>type-safe builder</strong>, and in the next example, we will present this pattern.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Changing the Person class</h1>
                </header>
            
            <article>
                
<p>First of all, we start with the same classes as we have in the example where we showed the way in which Java uses the builder pattern. Now, let's put a constraint on the example and say that every person must have at least <kbd>firstName</kbd> and <kbd>lastName</kbd> specified. In order to make the compiler aware that fields are being set, this needs to be encoded as a type. We will be using ADTs for this purpose. Let's define the following:</p>
<pre><span>sealed trait </span>BuildStep<br/><span>sealed trait </span>HasFirstName <span>extends </span>BuildStep<br/><span>sealed trait </span>HasLastName <span>extends </span>BuildStep</pre>
<p>The preceding abstract data types define the different steps of the build progress. Now, let's make some refactoring to the builder class and the <kbd>Person</kbd> class:</p>
<pre><span>class </span>Person(<br/>  <span>val </span>firstName: <span>String</span><span>,<br/></span><span>  </span><span>val </span>lastName: <span>String</span><span>,<br/></span><span>  </span><span>val </span>age: <span>Int<br/></span>)</pre>
<p>We will use the full constructor for the <kbd>Person</kbd> class rather than passing a builder. This is to show another way of building instances and keeping the code simpler in the later steps. The change would require the <kbd>build</kbd> method in the <kbd>PersonBuilder</kbd> to change as well to:</p>
<pre><span>def </span><span>build</span>(): Person = <span>new </span>Person(<br/>  firstName<span>,</span><span><br/></span><span>  </span>lastName<span>,</span><span><br/></span><span>  </span>age<br/>)</pre>
<p>This would require all the methods we have, which returned <kbd>PersonBuilder</kbd> before, to return <kbd>PersonBuilder[PassedStep]</kbd> now. Also, this would make it impossible to create a builder using the <kbd>new</kbd> keyword because the constructor is now private. Let's add some more constructor overloads:</p>
<pre><span>protected def this</span>() = <span>this</span>(<span>""</span><span>,</span><span>""</span><span>,</span><span>0</span>)<br/><span>protected def this</span>(pb: PersonBuilder[_]) = <span>this</span>(<br/>  pb.firstName<span>,</span><span><br/></span><span>  </span>pb.lastName<span>,</span><span><br/></span><span>  </span>pb.age<br/>)</pre>
<p>We will see how these overloads are used later. We need to allow our users to create a builder using another method, since all constructors are invisible to the outside world. That's why we should add a companion object, as shown here:</p>
<pre><span>object </span>PersonBuilder {<br/>  <span>def </span><span>apply</span>() = <span>new </span>PersonBuilder[BuildStep]()<br/>}</pre>
<p>The companion object uses one of the constructors we previously defined and it also makes sure the object returned is at the right build step.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding generalized type constraints to the required methods</h1>
                </header>
            
            <article>
                
<p>What we have so far, however, is still not going to satisfy our requirements regarding what every <kbd>Person</kbd> object should have initialized. We would have to change some methods in the <kbd>PersonBuilder</kbd> class. These methods are <kbd>setFirstName</kbd>, <kbd>setLastName</kbd>, and <kbd>build</kbd>. Here are the changes to the set methods:</p>
<pre><span>def </span><span>setFirstName</span>(firstName: <span>String</span>): PersonBuilder[HasFirstName] = {<br/>  <span>this</span>.firstName = firstName<br/>  <span>new </span>PersonBuilder[HasFirstName](<span>this</span>)<br/>}<br/><br/><span>def </span><span>setLastName</span>(lastName: <span>String</span>): PersonBuilder[HasLastName] = {<br/>  <span>this</span>.lastName = lastName<br/>  <span>new </span>PersonBuilder[HasLastName](<span>this</span>)<br/>}</pre>
<p>The interesting part comes with the <kbd>build</kbd> method. Let's have a look at the following initial implementation:</p>
<pre><span>def </span><span>build</span>()(<span>implicit </span>ev: PassedStep =:= HasLastName): Person =<br/>  <span>new </span>Person(<br/>    firstName<span>,</span><span><br/></span><span>    </span>lastName<span>,</span><span><br/></span><span>    </span>age<br/>  )</pre>
<p>The preceding syntax sets a generalized type constraint and says that <kbd>build</kbd> can only be called on a builder, which has passed the <kbd>HasLastName</kbd> step. It seems like we are coming close to what we wanted to achieve, but now <kbd>build</kbd> will only work if <kbd>setLastName</kbd> was the last of those four methods called on the builder, and it will still not validate the other fields. Let's use a similar approach for the <kbd>setFirstName</kbd> and <kbd>setLastName</kbd> methods and chain them up so that each one will require the previous one to be called before. Here is what the final code for our <kbd>PersonBuilder</kbd> class looks like (notice the other implicits in the set methods):</p>
<pre><span>class </span>PersonBuilder[<span>PassedStep </span>&lt;: BuildStep] <span>private</span>(<br/>  <span>var </span>firstName: <span>String</span><span>,<br/></span><span>  </span><span>var </span>lastName: <span>String</span><span>,<br/></span><span>  </span><span>var </span>age: <span>Int<br/></span>) {<br/>  <span>protected def this</span>() = <span>this</span>(<span>""</span><span>, </span><span>""</span><span>, </span><span>0</span>)<br/><br/>  <span>protected def this</span>(pb: PersonBuilder[_]) = <span>this</span>(<br/>    pb.firstName<span>,<br/></span><span>    </span>pb.lastName<span>,<br/></span><span>    </span>pb.age<br/>  )<br/><br/>  <span>def </span><span>setFirstName</span>(firstName: <span>String</span>): PersonBuilder[HasFirstName] = {<br/>    <span>this</span>.firstName = firstName<br/>    <span>new </span>PersonBuilder[HasFirstName](<span>this</span>)<br/>  }<br/><br/>  <span>def </span><span>setLastName</span>(lastName: <span>String</span>)(<span>implicit </span>ev: <span>PassedStep </span>=:= HasFirstName): PersonBuilder[HasLastName] = {<br/>    <span>this</span>.lastName = lastName<br/>    <span>new </span>PersonBuilder[HasLastName](<span>this</span>)<br/>  }<br/><br/>  <span>def </span><span>setAge</span>(age: <span>Int</span>): PersonBuilder[<span>PassedStep</span>] = {<br/>    <span>this</span>.age = age<br/>    <span>this<br/></span><span>  </span>}<br/><br/>  <span>def </span><span>build</span>()(<span>implicit </span>ev: <span>PassedStep </span>=:= HasLastName): Person =<br/>    <span>new </span>Person(<br/>      firstName<span>,<br/></span><span>      </span>lastName<span>,<br/></span><span>      </span>age<br/>    )<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using the type-safe builder</h1>
                </header>
            
            <article>
                
<p>We can now use the builder to create a <kbd>Person</kbd> object:</p>
<pre><span>object </span>PersonBuilderTypeSafeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>person = PersonBuilder()<br/>      .setFirstName(<span>"Ivan"</span>)<br/>      .setLastName(<span>"Nikolov"</span>)<br/>      .setAge(<span>26</span>)<br/>      .build()<br/>    System.<span>out</span>.println(<span>s"Person: </span><span>$</span>{person.firstName} <span>$</span>{person.lastName}<span>. Age: </span><span>$</span>{person.age}<span>."</span>)<br/>  }<br/>}</pre>
<p>If we omit one of our two required methods or rearrange them in some way, we will get a compilation error similar to the following (the error is for the missing first name):</p>
<pre>Error:(<span>103</span><span>, </span><span>23</span>) Cannot prove that com.ivan.nikolov.creational.builder.<br/>type_safe.BuildStep =:=<br/>com.ivan.nikolov.creational.builder.type_safe.HasFirstName.<br/>    .setLastName(<span>"Nikolov"</span>)<br/>                       ^</pre>
<p>The order requirement could be considered a slight drawback, especially if it's not needed.</p>
<div class="packt_infobox">Here are some observations about our type-safe builder:
<ul>
<li><span>Using a type-safe builder, we can require a specific call order and certain fields to be initialized.</span></li>
<li><span>When we require multiple fields, we have to chain them, which makes the order of calls important. This could make the library hard to use in some cases.</span></li>
<li><span>Compiler messages, when the builder is not used correctly, are not really informative.</span></li>
<li><span>The code looks pretty much similar to how it would be implemented in Java.</span></li>
<li><span>The similarity in code with Java leads to relying on mutability, which is not recommended.</span></li>
</ul>
</div>
<p>Scala allows us to have a nice and clean implementation of a builder design pattern, which also has requirements for order and what is initialized. This is a good feature, even though sometimes it could be tedious and limiting in terms of how exactly methods are being used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using require statements</h1>
                </header>
            
            <article>
                
<p>The type-safe builder we showed previously is nice, but it has some drawbacks:</p>
<ul>
<li>Complexity</li>
<li>Mutability</li>
<li>A predefined order of initialization</li>
</ul>
<p>However, it could be quite useful because it allows us to write code that will be checked for correct usage as soon as we compile it. Sometimes, compile-time validation is not required, though. If this is the case, we can make things extremely simple and get rid of the entire complexity using the already known case classes and the <kbd>require</kbd> statements:</p>
<pre><span>case class </span>Person(<br/>  firstName: <span>String </span>= <span>""</span><span>,<br/></span><span>  </span>lastName: <span>String </span>= <span>""</span><span>,<br/></span><span>  </span>age: <span>Int </span>= <span>0<br/></span>) {<br/>  <span>require</span>(firstName != <span>""</span><span>, </span><span>"First name is required."</span>)<br/>  <span>require</span>(lastName != <span>""</span><span>, </span><span>"Last name is required."</span>)<br/>}</pre>
<p>If the preceding Boolean conditions are not satisfied, our code will throw an <kbd>IllegalArgumentException</kbd> with the correct message. We can use our class the same way as we would normally use a case class:</p>
<pre><span>object </span>PersonCaseClassRequireExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>person1 = Person(<br/>      firstName = <span>"Ivan"</span><span>,<br/></span><span>      </span>lastName = <span>"Nikolov"</span><span>,<br/></span><span>      </span>age = <span>26<br/></span><span>    </span>)<br/>    System.<span>out</span>.println(<span>s"Person 1: </span><span>$</span>{person1}<span>"</span>)<br/>    <span>try </span>{<br/>      <span>val </span>person2 = Person(<br/>        firstName = <span>"John"<br/></span><span>      </span>)<br/>      System.<span>out</span>.println(<span>s"Person 2: </span><span>$</span>{person2}<span>"</span>)<br/>    } <span>catch </span>{<br/>      <span>case </span>e: <span>Throwable </span>=&gt;<br/>        e.printStackTrace()<br/>    }<br/>  }<br/>}</pre>
<p>As we can see, things here are much simpler, fields are immutable, and we don't actually have any special order of initialization. Moreover, we can put meaningful messages that could help us diagnose potential issues. As long as compile-time validation is not required, this should be the preferred method.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>The builder design pattern is really good for cases in which we need to create a complex object and would otherwise have to define many constructors. It makes the creation of objects easier and somewhat cleaner and more readable using a step-by-step approach.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>As we saw in our type-safe builder example, adding more advanced logic and requirements could involve quite a bit of work. Without this possibility, the developer will risk the users of their classes making more mistakes. Also, the builder contains quite a lot of seemingly duplicate code, especially when it is implemented using a Java-like code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The prototype design pattern</h1>
                </header>
            
            <article>
                
<p>The prototype design pattern is a creational design pattern that involves creating objects by cloning them from existing ones. Its purpose is related to performance and keeping it high by trying to avoid expensive calls.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">An example class diagram</h1>
                </header>
            
            <article>
                
<p>In languages such as Java, we usually see a class that implements an interface with a <kbd>clone</kbd> method, which returns a new instance of the class. Consider the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/77c11047-0f87-40e1-ba8d-9143de8f0591.png" style="width:12.67em;height:14.33em;" width="283" height="319"/></div>
<p>In the next section, we will provide a code example of the prototype design pattern from the point of view of Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A code example</h1>
                </header>
            
            <article>
                
<p>The prototype design pattern is really easy to implement in Scala. We can just use one of the language features. Since the prototype design pattern really resembles how cells in biology divide, let's use a cell as an example:</p>
<pre><span>/**<br/></span><span>  * Represents a bio cell<br/></span><span>  */<br/></span><span>case class </span>Cell(dna: <span>String</span><span>, </span>proteins: <span>List</span>[<span>String</span>])</pre>
<p>In Scala, all case classes have a <kbd>copy</kbd> method, which returns a new instance that is cloned from the original one. It can also change some of the original properties while copying. Here is some example usage of our cell:</p>
<pre><span>object </span>PrototypeExample {<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>initialCell = Cell(<span>"abcd"</span><span>, </span><span>List</span>(<span>"protein1"</span><span>, </span><span>"protein2"</span>))<br/>    <span>val </span>copy1 = initialCell.copy()<br/>    <span>val </span>copy2 = initialCell.copy()<br/>    <span>val </span>copy3 = initialCell.copy(dna = <span>"1234"</span>)<br/>    System.<span>out</span>.println(<span>s"The prototype is: </span><span>$</span>{initialCell}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Cell 1: </span><span>$</span>{copy1}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Cell 2: </span><span>$</span>{copy2}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"Cell 3: </span><span>$</span>{copy3}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"1 and 2 are equal: </span><span>$</span>{copy1 == copy2}<span>"</span>)<br/>  }<br/>}</pre>
<p>The output of this example will be this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/b6aa7488-2eef-49c4-8ffe-a5305f62f39a.png" width="723" height="145"/></div>
<p>As you can see, using <kbd>copy</kbd>, we acquired different instances of our prototype cell.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is good for?</h1>
                </header>
            
            <article>
                
<p>The prototype design pattern is useful when performance is important. Using the <kbd>copy</kbd> method, we can get instances that otherwise take time to create. The slowness could be caused by some calculations performed during creation, a database call that retrieves data, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What it is not so good for?</h1>
                </header>
            
            <article>
                
<p>Mistakes and side effects could be caused using shallow copies of objects, where the actual references point to the original instances. Also, avoiding constructors could lead to bad code. The prototype design pattern should be really used in cases where there might be a massive performance impact without it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This was the first chapter of this book that focused on some specific design patterns. We looked at the following creational design patterns—factory method, abstract factory, lazy initialization, singleton, builder, and prototype. Wherever relevant, we presented a diagram that visually showed class relationships. Also, we gave typical examples and went through the possible pitfalls and recommendations about when to use them.</p>
<p>In real-life software engineering, design patterns are usually combined together rather than being used in an isolated manner. Some examples include a prototype that is being supplied by a singleton instance, abstract factories that can store different prototypes and supply copies when objects are created, factories that can use builders to create instances, and so on. In some cases, design patterns could be interchangeable depending on the use case. For example, lazy initialization could be enough to lower the performance impact and could be chosen instead of a prototype design pattern.</p>
<p>In the next chapter, we will continue our journey into design patterns; this time, we will focus on the <em>structural design patterns</em> family.</p>


            </article>

            
        </section>
    </div>



  </body></html>