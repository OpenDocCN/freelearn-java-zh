- en: Chapter 3. Object Relational Mapping with JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any non-trivial Java EE application will persist data to a relational database.
    In this chapter, we will cover how to connect to a database and perform **CRUD**
    operations (**Create**, **Read**, **Update**, **Delete**).
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Persistence API** (**JPA**) is the standard Java EE **Object Relational
    Mapping** (**ORM**) tool. We will discuss this API in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data into a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data in a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data in a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building queries programmatically through the JPA Criteria API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating data validation through JPA 2.0's Bean Validation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CustomerDB database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Examples in this chapter will use a database called `CUSTOMERDB`. This database
    contains tables to track customer and order information for a fictitious store.
    The database uses JavaDB for its **Relational Database Management System** (**RDBMS**)
    since it comes bundled with GlassFish.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script is included with this book''s code download to create this database
    and prepopulate some of its tables. Instructions on how to execute the script
    and add a connection pool and datasource to access it are included in the download
    as well. The schema for the `CUSTOMERDB` database is depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CustomerDB database](img/6886EN_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the preceding diagram, the database contains tables to store
    customer information such as name, address, and e-mail address. It also contains
    tables to store order and item information.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADDRESS_TYPES` table will store values such as "Home", "Mailing", and "Shipping"
    to distinguish the type of address in the `ADDRESSES` table; similarly, the `TELEPHONE_TYPES`
    table stores the values "Cell", "Home", and "Work". These two tables are prepopulated
    when creating the database as well as the `US_STATES` table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity, our database only deals with US addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Java Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JPA was introduced to Java EE in Version 5 of the specification. As its name
    implies, it is used to persist data to an RDBMS. JPA is a replacement for Entity
    Beans that were used in J2EE. JPA Entities are regular Java classes; the Java
    EE container recognizes these classes as JPA entities. Let''s look at an Entity
    mapping to the `CUSTOMER` table in the `CUSTOMERDB` database, shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `@Entity` annotation lets GlassFish (or, for that
    matter, any other application server that is compliant with Java EE) know that
    this class is an entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Table(name = "CUSTOMERS")` annotation lets the application server know
    what table to map the entity to. The value of the `name` element contains the
    name of the database table that the entity maps to. This annotation is optional;
    if the name of the class is the same as the name of the database table, then it
    isn't necessary to specify what table the entity maps to.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation indicates that the `customerId` field is the primary key
    (unique identifier) for our Entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Column` annotation maps each field to a column in the table. If the name
    of the field matches the name of the database column, then this annotation is
    not needed. This is the reason why the `email` field is not annotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EntityManager` class (`EntityManager` is actually an interface; each Java
    EE compliant application server provides its own implementation) is used to persist
    Entities to a database. The following example illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The CDI named bean in the preceding code obtains an instance of a class implementing
    the `javax.persistence.EntityManager` interface via dependency injection. This
    is done by decorating the `EntityManager` variable with the `@PersistenceContext`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a class implementing the `javax.transaction.UserTransaction`
    interface is then injected via the `@Resource` annotation. This object is necessary
    since without it, invoking calls to persist Entities to the database would result
    in the code throwing a `javax.persistence.TransactionRequiredException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `EntityManager` class performs many database-related tasks such as finding
    entities in the database, updating them, and deleting them.
  prefs: []
  type: TYPE_NORMAL
- en: Since JPA Entities are **Plain Old Java Objects** (**POJOs**), they can be instantiated
    via the `new` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: POJOs are Java objects that do not need to extend any specific parent class
    or implement any specific interface
  prefs: []
  type: TYPE_NORMAL
- en: The call to the `setCustomerId()` method takes advantage of autoboxing, a feature
    added to the Java language in JDK 1.5\. Note that the method takes an instance
    of `java.lang.Long` as its parameter, but we are using long primitives. The code
    compiles and executes properly thanks to this feature..
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `persist()` method on `EntityManager` must be in a transaction;
    therefore, it is necessary to start one by calling the `begin()` method on `UserTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: We then insert two new rows to the `CUSTOMERS` table by calling the `persist()`
    method on `entityManager` for the two instances of the `Customer` class we populated
    earlier in the code.
  prefs: []
  type: TYPE_NORMAL
- en: After persisting the data contained in the `customer` and `customer2` objects,
    we search the database for a row in the `CUSTOMERS` table with a primary key of
    `4`. We do this by invoking the `find()` method on `entityManager`. This method
    takes the class of the Entity we are searching for as its first parameter and
    the primary key of the row corresponding to the object we want to obtain. This
    method is roughly equivalent to the `findByPrimaryKey()` method on an Entity Bean's
    home interface.
  prefs: []
  type: TYPE_NORMAL
- en: The primary key we set for the `customer2` object was `4`; therefore, what we
    have now is a copy of this object. The last name for this customer was misspelled
    when we originally inserted his data into the database; we now correct Mr. Johnson's
    last name by invoking the `setLastName()` method on `customer3` and then update
    the information in the database by invoking `entityManager.persist()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then delete the information for the `customer` object by invoking `entityManager.remove()`
    and passing the `customer` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we commit the changes to the database by invoking the `commit()` method
    on `userTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for our code to work as expected, an XML configuration file named
    `persistence.xml` must be deployed in the WAR file containing `JPADemoBean`. This
    file must be placed in the `WEB-INF/classes/META-INF/` directory inside the WAR
    file. The contents of this file corresponding to our code are shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `persistence.xml` file must contain at least one `<persistence-unit>` element.
    Each `<persistence-unit>` element must provide a value for its `name` attribute
    and must contain a `<jta-data-source>` child element whose value is the JNDI name
    of the datasource to be used for the persistence unit.
  prefs: []
  type: TYPE_NORMAL
- en: More than one `<persistence-unit>` element is allowed because an application
    may access more than one database. A `<persistence-unit>` element is required
    for each database the application will access. If the application defines more
    than one `<persistence-unit>` element, then the `@PersistenceContext` annotation
    used to inject `EntityManager` must provide a value for its `unitName` element.
    The value for this element must match the `name` attribute of the corresponding
    `<persistence-unit>` element in `persistence.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cannot persist the detached object exception**'
  prefs: []
  type: TYPE_NORMAL
- en: An application will frequently retrieve a JPA entity via the `EntityManager.find()`
    method and then pass this entity to a business or user interface layer, where
    it will potentially be modified. Later, the database data corresponding to the
    entity will be updated. In cases like this, invoking `EntityManager.persist()`
    will result in an exception. In order to update JPA entities this way, we need
    to invoke `EntityManager.merge()`. This method takes an instance of the JPA entity
    as its single argument and updates the corresponding row in the database with
    the data stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: Entity relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how to retrieve, insert, update, and delete
    single entities from the database. Entities are rarely isolated; in the vast majority
    of cases, they are related to other entities.
  prefs: []
  type: TYPE_NORMAL
- en: Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CustomerDB` database, for example, there is a one-to-one relationship
    between the `LOGIN_INFO` table and the `CUSTOMERS` tables. This means that each
    customer has exactly one corresponding row in the `LOGIN_INFO` table. There is
    also a one-to-many relationship between the `CUSTOMERS` table and the `ORDERS`
    table. This is because a customer can place many orders, but each order belongs
    only to a single customer. Additionally, there is a many-to-many relationship
    between the `ORDERS` table and the `ITEMS` table. This is because an order can
    contain many items and an item can be in many orders.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we discuss how to establish relationships between
    JPA entities.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One-to-one relationships occur when an instance of an entity can have zero or
    one corresponding instance of another entity.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one entity relationships can be bidirectional (each entity is aware of
    the relationship) or unidirectional (only one of the entities is aware of the
    relationship). In the `CustomerDB` example database, the one-to-one mapping between
    the `LOGIN_INFO` and the `CUSTOMERS` tables is unidirectional. This is because
    the `LOGIN_INFO` table has a foreign key to the `CUSTOMERS` table, but not the
    other way around. As we will soon see, this fact does not stop us from creating
    a bidirectional one-to-one relationship between the `Customer` entity and the
    `LoginInfo` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the `LoginInfo` entity, which maps to the `LOGIN_INFO`
    table, can be seen next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code for this entity is very similar to the code for the `Customer` entity;
    it defines fields that map to database columns. Each field whose name does not
    match the database column name is decorated with the `@Column` annotation; in
    addition to that, the primary key is decorated with the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code gets interesting in the declaration of the `customer` field. As can
    be seen in the code, the `customer` field is decorated with the `@OneToOne` annotation.
    This lets the application server (GlassFish) know that there is a one-to-one relationship
    between this entity and the `Customer` entity. The `customer` field is also decorated
    with the `@JoinColumn` annotation. This annotation lets the container know what
    column in the `LOGIN_INFO` table is the foreign key corresponding to the primary
    key on the `CUSTOMER` table. Since `LOGIN_INFO`, the table that the `LoginInfo`
    entity maps to, has a foreign key to the `CUSTOMER` table, the `LoginInfo` entity
    owns the relationship. If the relationship was unidirectional, we wouldn''t have
    to make any changes to the `Customer` entity. However, since we would like to
    have a bidirectional relationship between these two entities, we need to add a
    `LoginInfo` field to the `Customer` entity, along with the corresponding getter
    and setter methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only change we need to make to the `Customer` entity to make the one-to-one
    relationship bidirectional is to add a `LoginInfo` field to it, along with the
    corresponding setter and getter methods. The `LoginInfo` field is decorated with
    the `@OneToOne` annotation. Since the `Customer` entity does not own the relationship
    (the table it maps to does not have a foreign key to the corresponding table),
    the `mappedBy` element of the `@OneToOne` annotation needs to be added. This element
    specifies what field in the corresponding entity has the other end of the relationship.
    In this particular case, the `customer` field in the `LoginInfo` entity corresponds
    to the other end of this one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java class illustrates the use of the preceding entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create an instance of the `LoginInfo` entity and populate
    it with some data. We then obtain an instance of the `Customer` entity from the
    database by invoking the `find()` method of `EntityManager` (the data for this
    entity was inserted into the `CUSTOMERS` table in one of the previous examples).
    We then invoke the `setCustomer()` method on the `LoginInfo` entity, passing the
    customer object as a parameter. Finally, we invoke the `EntityManager.persist()`
    method to save the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes, the `CUSTOMER_ID` column of the `LOGIN_INFO` table gets populated
    with the primary key of the corresponding row in the `CUSTOMERS` table. This can
    be easily verified by querying the `CUSTOMERDB` database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the call to `EntityManager.find()` to obtain the customer entity
    is inside the same transaction where we call `EntityManager.persist()`. This must
    be the case; otherwise the database will not be updated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JPA one-to-many entity relationships can be bidirectional (one entity contains
    a many-to-one relationship and the corresponding entity contains an inverse one-to-many
    relationship).
  prefs: []
  type: TYPE_NORMAL
- en: With SQL, one-to-many relationships are defined by foreign keys in one of the
    tables. The "many" part of the relationship is the one containing a foreign key
    to the "one" part of the relationship. One-to-many relationships defined in an
    RDBMS are typically unidirectional, since making them bidirectional usually results
    in denormalized data.
  prefs: []
  type: TYPE_NORMAL
- en: Just as when defining a unidirectional one-to-many relationship in an RDBMS,
    in JPA, the "many" part of the relationship is the one that has a reference to
    the "one" part of the relationship; therefore, the annotation used to decorate
    the appropriate setter method is `@ManyToOne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CUSTOMERDB` database, there is a unidirectional one-to-many relationship
    between customers and orders. We define this relationship in the `Order` entity,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to define a unidirectional many-to-one relationship between the
    `Orders` entity and the `Customer` entity, we wouldn''t need to make any changes
    to the `Customer` entity. To define a bidirectional one-to-many relationship between
    the two entities, a new field decorated with the `@OneToMany` annotation needs
    to be added to the `Customer` entity, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this version of the `Customer` entity and the previous
    one is the addition of the `orders` field and related getter and setter methods.
    Of special interest is the `@OneToMany` annotation decorating this field. The
    `mappedBy` attribute must match the name of the corresponding field in the entity
    corresponding to the "many" part of the relationship. In simple terms, the value
    of the `mappedBy` attribute must match the name of the field decorated with the
    `@ManyToOne` annotation in the bean at the other side of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code illustrates how to persist one-to-many relationships
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty similar to the previous example. It instantiates
    two instances of the `Order` entity, populates them with some data; then, an instance
    of the `Customer` entity is located in a transaction and used as the parameter
    of the `setCustomer()` method of both instances of the `Order` entity. We then
    persist both `Order` entities by invoking `EntityManager.persist()` for each one
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Just as when dealing with one-to-one relationships, behind the scenes, the `CUSTOMER_ID`
    column of the `ORDERS` table in the `CUSTOMERDB` database is populated with the
    primary key corresponding to the related row in the `CUSTOMERS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Since the relationship is bidirectional, we can obtain all orders related to
    a customer by invoking the `getOrders()` method on the `Customer` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `CUSTOMERDB` database, there is a many-to-many relationship between
    the `ORDERS` table and the `ITEMS` table. We can map this relationship by adding
    a new `Collection<Item>` field to the `Order` entity and decorating it with the
    `@ManyToMany` annotation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, in addition to being decorated with the
    `@ManyToMany` annotation, the `items` field is also decorated with the `@JoinTable`
    annotation. As its name suggests, this annotation lets the application server
    know what table is used as a join table to create the many-to-many relationship
    between the two entities. This annotation has three relevant elements: the `name`
    element, which defines the name of the join table, and the `joinColumns` and `inverseJoinColumns`
    elements, which define the columns that serve as foreign keys in the join table
    pointing to the entities'' primary keys. Values for the `joinColumns` and `inverseJoinColumns`
    elements are yet another annotation, the `@JoinColumn` annotation. This annotation
    has two relevant elements: the `name` element, which defines the name of the column
    in the join table, and the `referencedColumnName` element, which defines the name
    of the column in the entity table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Item` entity is a simple entity mapping to the `ITEMS` table in the `CUSTOMERDB`
    database, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just like one-to-one and one-to-many relationships, many-to-many relationships
    can be unidirectional or bidirectional. Since we would like the many-to-many relationship
    between the `Order` and `Item` entities to be bidirectional, we added a `Collection<Order>`
    field and decorated it with the `@ManyToMany` annotation. Since the corresponding
    field in the `Order` entity already has the join table defined, it is not necessary
    to do it again here. The entity containing the `@JoinTable` annotation is said
    to own the relationship. In a many-to-many relationship, either entity can own
    the relationship. In our example, the `Order` entity owns it, since its `Collection<Item>`
    field is decorated with the `@JoinTable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the one-to-one and one-to-many relationships, the `@ManyToMany`
    annotation in the non-owning side of a bidirectional many-to-many relationship
    must contain a `mappedBy` element indicating what field in the owning entity defines
    the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the changes necessary to establish a bidirectional many-to-many
    relationship between the `Order` and `Item` entities, we can see the relationship
    in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two instances of the `Item` entity and populates
    them with some data. It then adds these two instances to a collection. A transaction
    is then started. The two `Item` instances are persisted to the database. Then,
    an instance of the `Order` entity is retrieved from the database. The `setItems()`
    method of the `Order` entity instance is then invoked, passing the collection
    containing the two `Item` instances as a parameter. The `Customer` instance is
    then persisted into the database. At this point, two rows are created behind the
    scenes in the `ORDER_ITEMS` table, which is the join table between the `ORDERS`
    and `ITEMS` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Composite primary keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most tables in the `CUSTOMERDB` database have a column that exists for the sole
    purpose of serving as a primary key (this type of primary key is sometimes referred
    to as a surrogate primary key or as an artificial primary key). However, some
    databases are not designed this way; instead, a column in the database that is
    known to be unique across rows is used as the primary key. If there is no column
    whose value is not guaranteed to be unique across rows, then a combination of
    two or more columns is used as the table's primary key. It is possible to map
    this kind of primary key to JPA entities using a primary key class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one table in the `CUSTOMERDB` database that does not have a surrogate
    primary key; this table is the `ORDER_ITEMS` table. This table serves as a join
    table between the `ORDERS` table and the `ITEMS` table. In addition to having
    foreign keys for these two tables, the `ORDER_ITEMS` table has an additional column
    called `ITEM_QTY` that stores the quantity of each item in an order. Since this
    table does not have a surrogate primary key, the JPA entity mapping to it must
    have a custom primary key class. In this table, the combination of the `ORDER_ID`
    and `ITEM_ID` columns must be unique. Therefore, this is a good combination for
    a composite primary key, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A custom primary key class must satisfy the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The class must be `public`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must implement `java.io.Serializable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a `public` constructor that takes no arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its fields must be `public` or `protected`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its field names and types must match those of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must override the default `hashCode()` and `equals()` methods defined in
    the `java.lang.Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OrderItemPK` class in the preceding code meets all of these requirements.
    It also has a convenient constructor that takes two `Long` objects meant to initialize
    its `orderId` and `itemId` fields. This constructor was added for convenience
    and is not a requirement for the class to be used as a primary key class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an entity uses a custom primary key class, it must be decorated with the
    `@IdClass` annotation. Since the `OrderItem` class uses `OrderItemPK` as its custom
    primary key class, it must be decorated with the said annotation, as shown in
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are two differences between this entity and entities we have seen previously.
    The first difference is that this entity is decorated with the `@IdClass` annotation,
    indicating the primary key class corresponding to it. The second difference is
    that this entity has more than one field decorated with the `@Id` annotation.
    Since this entity has a composite primary key, each field that is part of the
    primary key must be decorated with this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining a reference of an entity with a composite primary key is not very
    different from obtaining a reference to an entity with a primary key consisting
    of a single field. The following example demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in this example, the only difference between locating an entity
    with a composite primary key and an entity with a primary key consisting of a
    single field is that an instance of the custom primary key class must be passed
    as the second argument of the `EntityManager.find()` method; fields for this instance
    must be populated with the appropriate values for each field that is part of the
    primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Java Persistence Query Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of our examples that obtain entities from the database so far have conveniently
    assumed that the primary key for the entity is known ahead of time. We all know
    that, frequently, this is not the case. Whenever we need to search for an entity
    by a field other than the entity's primary key, we must use the **Java Persistence
    Query Language** (**JPQL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'JPQL is a SQL-like language used for retrieving, updating, and deleting entities
    in a database. The following example illustrates how to use JPQL to retrieve a
    subset of states from the `US_STATES` table in the `CUSTOMERDB` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code invokes the `EntityManager.createQuery()` method, passing
    a string containing a JPQL query as a parameter. This method returns an instance
    of `javax.persistence.Query`. The query retrieves all `UsState` entities whose
    names start with the string `"New"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding code, JPQL is similar to SQL. However there
    are some differences that may confuse readers with SQL knowledge. The equivalent
    SQL code for the query in the code will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first difference between JPQL and SQL is that in JPQL, we always use entity
    names, whereas in SQL table names are used. The `s` after the entity name in the
    JPQL query is an alias for the entity. Table aliases are optional in SQL, but
    entity aliases are required in JPQL. Keeping these differences in mind, the JPQL
    query should now be a lot less confusing.
  prefs: []
  type: TYPE_NORMAL
- en: The `:name` parameter in the query is a named parameter; named parameters are
    meant to be substituted with actual values. This is done by invoking the `setParameter()`
    method in the instance of `javax.persistence.Query` returned by the call to `EntityManager.createQuery()`.
    A JPQL query can have multiple named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: To actually run the query and retrieve the entities from the database, the `getResultList()`
    method must be invoked in the instance of `javax.persistence.Query` obtained from
    `EntityManager.createQuery()`. This method returns an instance of a class implementing
    the `java.util.List` interface. This list contains the entities matching the query
    criteria. If no entities match the criteria, then an empty list is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If we are certain that the query will return exactly one entity, then the `getSingleResult()`
    method may be alternatively called on `Query`; this method returns an object that
    must be cast to the appropriate entity.
  prefs: []
  type: TYPE_NORMAL
- en: Our example uses the `LIKE` operator to find entities whose names start with
    the string `"New"`. This is accomplished by substituting the query's named parameter
    with the value `"New%"`. The percent sign at the end of the parameter value means
    that any number of characters after the word `"New"` will match the expression.
    The percent sign can be used anywhere in the parameter value; for example, a value
    of `"%Dakota"` would match any entities whose name end in `"Dakota"` and a value
    of `"A%a"` would match any states whose name start with an uppercase `"A"` and
    end with a lowercase `"a"`. There can be more than one percent sign in a parameter
    value. The underscore sign (`_`) can be used to match a single character; all
    the rules for the percent sign apply to the underscore as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `LIKE` operator, there are other operators that can be used
    to retrieve entities from the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `=` operator will retrieve entities whose field to the left of the operator
    exactly match the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>` operator will retrieve entities whose field to the left of the operator
    is greater than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<` operator will retrieve entities whose field to the left of the operator
    is less than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>=` operator will retrieve entities whose field to the left of the operator
    is greater than, or equal to, the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<=` operator will retrieve entities whose field to the left of the operator
    is less than, or equal to, the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding operators work the same way as the equivalent operators
    in SQL. Just as in SQL, the preceding operators can be combined with the `AND`
    and `OR` operators. Conditions combined with the `AND` operator match if both
    conditions are true, and conditions combined with the `OR` operator match if at
    least one of the conditions are true.
  prefs: []
  type: TYPE_NORMAL
- en: If we intend to use a query many times, it can be stored in a named query. Named
    queries can be defined by decorating the relevant entity class with the `@NamedQuery`
    annotation. This annotation has two elements, a name element used to set the name
    of the query and a query element that defines the query itself. To execute a named
    query, the `createNamedQuery()` method must be invoked in an instance of `EntityManager`.
    This method takes a string of type `String` containing the query name as its sole
    parameter and returns an instance of `javax.persistence.Query`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to retrieving entities, JPQL can be used to modify or delete entities.
    However, entity modification and deletion can be done programmatically via the
    `EntityManager` interface too; doing so results in code that tends to be more
    readable than when using JPQL. Because of this, we will not cover entity modification
    and deletion via JPQL. Readers interested in writing JPQL queries to modify and
    delete entities, as well as readers wishing to know more about JPQL are encouraged
    to review the Java Persistence 2.1 specification. This specification can be downloaded
    from [http://jcp.org/en/jsr/detail?id=338](http://jcp.org/en/jsr/detail?id=338).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Criteria API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main additions to JPA in Version 2.0 was the introduction of the
    Criteria API. The Criteria API is meant as a complement to the JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: Although JPQL is very flexible, it has some problems that make working with
    it more difficult than necessary. For starters, JPQL queries are stored as strings,
    and the compiler has no way of validating JPQL syntax. Additionally, JPQL is not
    type safe; we could write a JPQL query in which our `where` clause could have
    a string value for a numeric property and our code would compile and deploy just
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: To get around the JPQL limitations described in the previous paragraph, the
    Criteria API was introduced in JPA in Version 2.0 of the specification. The Criteria
    API allows us to write JPA queries programmatically, without having to rely on
    JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how to use the Criteria API in our Java
    EE applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This example is equivalent to the JPQL example we saw earlier in this chapter.
    This example, however, takes advantage of the Criteria API instead of relying
    on JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code using the Criteria API, the first thing we need to do is obtain
    an instance of a class implementing the `javax.persistence.criteria.CriteriaBuilder`
    interface. As we can see in our example, we need to obtain the said instance by
    invoking the `getCriteriaBuilder()` method on our `EntityManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: From our `CriteriaBuilder` implementation, we need to obtain an instance of
    a class implementing the `javax.persistence.criteria.CriteriaQuery` interface.
    We do this by invoking the `createQuery()` method in our `CriteriaBuilder` implementation.
    Note that `CriteriaQuery` is generically typed. The generic type argument dictates
    the type of result that our `CriteriaQuery` implementation will return upon execution.
    By taking advantage of generics in this way, the Criteria API allows us to write
    type-safe code.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained a `CriteriaQuery` implementation, from it we can obtain
    an instance of a class implementing the `javax.persistence.criteria.Root` interface.
    The `Root` implementation dictates what JPA Entity we will be querying from. It
    is analogous to the `FROM` query in JPQL (and SQL).
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines in our example take advantage of another new addition to
    the JPA specification, the **Metamodel API**. In order to take advantage of the
    Metamodel API, we need to obtain an implementation of the `javax.persistence.metamodel.Metamodel`
    interface by invoking the `getMetamodel()` method on our `EntityManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: From our `Metamodel` implementation, we can obtain a generically typed instance
    of the `javax.persistence.metamodel.EntityType` interface. The generic type argument
    indicates the JPA entity our `EntityType` implementation corresponds to. The `EntityType`
    interface implementation allows us to browse the persistent attributes of our
    JPA entities at runtime, which is exactly what we do in the next line in our example.
    In our case, we are getting an instance of `SingularAttribute`, which maps to
    a simple, singular attribute in our JPA entity. The `EntityType` interface implementation
    has methods to obtain attributes that map to collections, sets, lists, and maps.
    Obtaining these types of attributes is very similar to obtaining `SingularAttribute`;
    therefore, we won't be covering those in depth. Please refer to the Java EE 7
    API documentation at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in our example, `SingularAttribute` contains two generic type
    arguments. The first argument dictates the JPA entity we are working with, and
    the second one indicates the type of the attribute. We obtain our `SingularAttribute`
    implementation by invoking the `getDeclaredSingularAttribute()` method on our
    `EntityType` interface implementation and passing the attribute name (as declared
    in our JPA entity) as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained our `SingularAttribute` implementation, we need to obtain
    a `javax.persistence.criteria.Path` implementation by invoking the `get()` method
    in our `Root` instance and passing `SingularAttribute` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will get a list of all the states in the United States whose
    names start with the string `"New"`. This, of course, is a job for the `like`
    condition. We can do this with the criteria API by invoking the `like()` method
    on our `CriteriaBuilder` implementation. The `like()` method takes our `Path`
    implementation as its first parameter and the value to search for as its second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `CriteriaBuilder` interface implementation has a number of methods that
    are analogous to SQL and JPQL clauses such as `equals()`, `greaterThan()`, `lessThan()`,
    `and()`, `or()`, and so on and so forth (for the complete list, refer to the Java
    EE 7 documentation at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/)).
    These methods can be combined to create complex queries via the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: The `like()` method in `CriteriaBuilder` returns an implementation of the `javax.persistence.criteria.Predicate`
    interface, which we need to pass to the `where()` method in our `CriteriaQuery`
    implementation. This method returns a new instance of `CriteriaBuilder`, which
    we assign to our `CriteriaBuilder` variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are ready to build our query. When working with the Criteria
    API, we deal with the `javax.persistence.TypedQuery` interface, which can be thought
    of as a type-safe version of the `Query` interface we use with JPQL. We obtain
    an instance of `TypedQuery` by invoking the `createQuery()` method in `EntityManager`
    and passing our `CriteriaQuery` implementation as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain our query results as a list, we simply invoke `getResultList()` on
    our `TypedQuery` implementation. It is worth reiterating that the Criteria API
    is type safe; therefore, attempting to assign the results of `getResultList()`
    to a list of the wrong type would result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with the Criteria API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the JPA Criteria API was initially added to JPA 2.0, it only supported
    selecting data from the database. Modifying existing data was not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA 2.1, introduced in Java EE 7, adds support for updating database data via
    the `CriteriaUpdate` interface; the following example illustrates how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What this example is actually doing is finding all of the database rows with
    a city `"New Yorc"` (a typo) and replacing the value with the correct spelling,
    `"New York"`.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the previous example, we obtain an instance of a class implementing
    the `CriteriaBuilder` interface by invoking the `getCriteriaBuilder()` method
    on our `EntityManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain an instance of a class implementing `CriteriaUpdate` by invoking
    `createCriteriaUpdate()` on our `CriteriaBuilder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to obtain an instance of a class implementing `Root` by invoking
    the `from()` method on our `CriteriaUpdate` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then invoke the `set()` method on `CriteriaUpdate` to specify the new values
    our rows will have after they have been updated. The first parameter of the `set()`
    method must be a string matching the property name in the `Entity` class, and
    the second parameter must be the new value.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we build the `where` clause by invoking the `where()` method
    on `CriteriaUpdate` and passing the `Predicate` returned by the `equal()` method
    invoked in `CriteriaBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we get a `Query` implementation by invoking `createQuery()` on `EntityManager`
    and passing our `CriteriaUpdate` instance as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we execute our query, as usual, by invoking `executeUpdate()` on our
    `Query` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with the Criteria API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to adding support for data update via the Criteria API, JPA 2.1
    added the ability to bulk-delete database rows with the new `CriteriaDelete` interface.
    The following code snippet illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To use `CriteriaDelete`, we first obtain an instance of `CriteriaBuilder` as
    usual, and then invoke the `createCriteriaDelete()` method on our `CriteriaBuilder`
    instance to obtain an implementation of `CriteriaDelete`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `CriteriaDelete`, we build the `where` clause as
    it is usually done with the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built our `where` clause, we obtain an implementation of the `Query`
    interface and invoke `executeUpdate()` on it as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another feature introduced in JPA 2.0 is support for JSR 303, Bean Validation.
    Bean Validation support allows us to annotate our JPA entities with Bean Validation
    annotations. These annotations allow us to easily validate user input and perform
    data sanitation.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of Bean Validation is very simple. All we need to do is annotate
    our JPA Entity fields or getter methods with any of the validation annotations
    defined in the `javax.validation.constraints` package. Once our fields are annotated
    as needed, the `EntityManager` will prevent non-validated data from being persisted.
  prefs: []
  type: TYPE_NORMAL
- en: The following code example is a modified version of the `Customer` JPA entity
    we saw earlier in this chapter. It has been modified to take advantage of Bean
    Validation in some of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `@NotNull` annotation to prevent `firstName` and
    `lastName` of our entity from being persisted with `null` values. We also used
    the `@Size` annotation to restrict the minimum and maximum length of these fields.
  prefs: []
  type: TYPE_NORMAL
- en: That is all we need to do to take advantage of Bean Validation in JPA. If our
    code attempts to persist or update an instance of our entity that does not pass
    the declared validation, an exception of type `javax.validation.ConstraintViolationException`
    will be thrown, and the entity will not be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Bean Validation pretty much automates data validation, freeing
    us from having to manually write validation code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two annotations discussed in the previous example, the `javax.validation.constraints`
    package contains several additional annotations we can use to automate validation
    on our JPA entities. Please refer to the Java EE 7 API documentation at [http://docs.oracle.com/javaee/7/api/](http://docs.oracle.com/javaee/7/api/)
    for the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Final notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples of this chapter, we showed how a database is accessed directly
    from CDI named beans serving as controllers. We did this to get the point across
    without bogging ourselves down with details. In general, accessing the database
    directly from controllers is not a good practice. Database access code should
    be encapsulated in **Data Access Objects** (**DAOs**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the DAO design pattern, see [http://www.oracle.com/technetwork/java/dao-138818.html](http://www.oracle.com/technetwork/java/dao-138818.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Named beans typically assume the role of controllers and/or models when using
    the Model-View-Controller (MVC) design pattern: a practice so common that it has
    become the de facto standard for Java EE applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the MVC design pattern, see [http://www.oracle.com/technetwork/java/mvc-140477.html](http://www.oracle.com/technetwork/java/mvc-140477.html).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we chose not to show any user interface code in our examples since
    it is irrelevant to the topic at hand; however, the code downloads for this chapter
    includes JSF pages that invoke the named beans in this chapter and display a confirmation
    page once the named bean invocation finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to access data in a database via JPA.
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to mark a Java class as a JPA entity by decorating it with the
    `@Entity` annotation. Additionally, we covered how to map an entity to a database
    table via the `@Table` annotation. We also covered how to map entity fields to
    database columns via the `@Column` annotation, as well as how to declare an entity's
    primary key via the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `javax.persistence.EntityManager` interface to find, persist, and
    update JPA entities was also covered.
  prefs: []
  type: TYPE_NORMAL
- en: Defining both unidirectional and bidirectional one-to-one, one-to-many, and
    many-to-many relationships between JPA entities was covered as well.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we covered how to use JPA composite primary keys by developing
    custom primary key classes.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to cover how to retrieve entities from a database by using the
    JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed additional JPA features, such as the Criteria API, which allows
    us to build JPA queries programmatically; the Metamodel API, which allows us to
    take advantage of Java's type safety when working with JPA; and Bean Validation,
    which allows us to easily validate input by simply annotating our JPA entity fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover **Enterprise JavaBeans** (**EJBs**).
  prefs: []
  type: TYPE_NORMAL
