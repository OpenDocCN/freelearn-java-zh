- en: Chapter 8.  Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"A distributed system is one in which the failure of a computer you
    didn''t even know existed can render your own computer unusable."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Leslie Lamport* |'
  prefs: []
  type: TYPE_TB
- en: Throughout this book, we have concentrated on many different abstractions for
    concurrent programming. Most of these abstractions assume the presence of shared
    memory. Futures and promises, concurrent data structures, and software transactional
    memory, are best suited to shared-memory systems. While the shared-memory assumption
    ensures that these facilities are efficient, it also limits them to applications
    running on a single computer. In this chapter, we consider a programming model
    that is equally applicable to a shared-memory machine or a distributed system,
    namely, the **actor model**. In the actor model, the program is represented by
    a large number of entities that execute computations independently, and communicate
    by passing messages. These independent entities are called **actors**.
  prefs: []
  type: TYPE_NORMAL
- en: The actor model aims to resolve issues associated with using shared memory,
    such as data races or synchronization, by eliminating the need for shared memory
    altogether. *Mutable* state is confined within the boundaries of one actor, and
    is potentially modified when the actor receives a message. Messages received by
    the actor are handled serially, one after another. This ensures that the mutable
    state within the actor is never accessed concurrently. However, separate actors
    can process the received messages concurrently. In a typical actor-based program,
    the number of actors can be orders of magnitude greater than the number of processors.
    This is similar to the relationship between processors and threads in multi-threaded
    programs. The actor model implementation decides when to assign processor time
    to specific actors, to allow them to process messages.
  prefs: []
  type: TYPE_NORMAL
- en: The true advantage of the actor model becomes apparent when we start distributing
    the application across multiple computers. Implementing programs that span across
    multiple machines and devices that communicate through a computer network is called
    **distributed programming**. The actor model allows you to write programs that
    run inside a single process, multiple processes on the same machine, or on multiple
    machines that are connected to a computer network. Creating actors and sending
    messages is oblivious to, and independent of, the location of the actor. In distributed
    programming, this is called **location transparency**. Location transparency allows
    you to design distributed systems without having the knowledge about the relationships
    in the computer network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use the Akka `actor` framework to learn about the
    actor concurrency model. Specifically, we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring actor classes and creating actor instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling actor state and complex actor behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating the actor hierarchy and the lifecycle of an actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different message-passing patterns used in actor communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error recovery using the built-in actor supervision mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using actors to transparently build concurrent and distributed programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by studying the important concepts and terminology in the actor
    model, and learning the basics of the actor model in Akka.
  prefs: []
  type: TYPE_NORMAL
- en: Working with actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the actor programming model, the program is run by a set of concurrently
    executing entities called actors. Actor systems resemble human organizations,
    such as companies, governments, or other large institutions. To understand this
    similarity, we consider the example of a large software company.
  prefs: []
  type: TYPE_NORMAL
- en: In a software company such as Google, Microsoft, Amazon, or Typesafe, there
    are many goals that need to be achieved concurrently. Hundreds or thousands of
    employees work toward achieving these goals, and are usually organized in a hierarchical
    structure. Different employees work at different positions. A team leader makes
    important technical decisions for a specific project, a software engineer implements
    and maintains various parts of a software product, and a system administrator
    makes sure that the personal workstations, servers, and various equipment are
    functioning correctly. Many employees, such as the team leader, delegate their
    own tasks to other employees who are lower in the hierarchy than themselves. To
    be able to work and make decisions efficiently, employees use e-mails to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: When an employee comes to work in the morning, he inspects his e-mail client
    and responds to the important messages. Sometimes, these messages contain work
    tasks that come from his boss, or requests from other employees. When an e-mail
    is important, the employee must compose the answer right away. While the employee
    is busy answering one e-mail, additional e-mails can arrive, and these e-mails
    are enqueued in his e-mail client. Only once the employee is done with one e-mail
    is he able to proceed to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding scenario, the workflow of the company is divided into a number
    of functional components. It turns out that these components closely correspond
    to different parts of an actor framework. We will now identify these similarities
    by defining the parts of an actor system, and relating them to their analogs in
    the software company.
  prefs: []
  type: TYPE_NORMAL
- en: An **actor system** is a hierarchical group of actors that share common configuration
    options. An actor system is responsible for creating new actors, locating actors
    within the actor system, and logging important events. An actor system is an analog
    of the software company itself.
  prefs: []
  type: TYPE_NORMAL
- en: An **actor class** is a template that describes a state internal to the actor,
    and how the actor processes the messages. Multiple actors can be created from
    the same actor class. An actor class is an analogy for a specific position within
    the company, such as a software engineer, a marketing manager, or a recruiter.
  prefs: []
  type: TYPE_NORMAL
- en: An **actor instance** is an entity that exists at runtime and is capable of
    receiving messages. An actor instance might contain mutable state, and can send
    messages to other actor instances. The difference between an actor class and an
    actor instance directly corresponds to the relationship between a class and an
    object instance of that class in object-oriented programming. In the context of
    the software company example, an actor instance is analogous to a specific employee.
  prefs: []
  type: TYPE_NORMAL
- en: A **message** is a unit of communication that actors use to communicate. In
    Akka, any object can be a message. Messages are analogous to e-mails sent within
    the company. When an actor sends a message, it does not wait until some other
    actor receives the message. Similarly, when an employee sends an e-mail, he does
    not wait until the e-mail is received or read by the other employees. Instead,
    he proceeds with his own work; an employee is too busy to wait. Multiple e-mails
    might be sent to the same person concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The **mailbox** is a part of memory that is used to buffer messages, specific
    to each actor instance. This buffer is necessary, as an actor instance can process
    only a single message at a time. The mailbox corresponds to an e-mail client used
    by an employee. At any point, there might be multiple unread e-mails buffered
    in the e-mail client, but the employee can only read and respond to them one at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: An **actor reference** is an object that allows you to send messages to a specific
    actor. This object hides information about the location of the actor from the
    programmer. An actor might run within separate processes or on different computers.
    The actor reference allows you to send a message to an actor irrespective of where
    the actor is running. From the software-company perspective, an actor reference
    corresponds to the e-mail address of a specific employee. The e-mail address allows
    us to send an e-mail to an employee, without knowing anything about the physical
    location of the employee. The employee might be in his office, on a business trip,
    or on vacation, but the e-mail will eventually reach him no matter where he goes.
  prefs: []
  type: TYPE_NORMAL
- en: A **dispatcher** is a component that decides when actors are allowed to process
    messages, and lends them computational resources to do so. In Akka, every dispatcher
    is, at the same time, an execution context. The dispatcher ensures that actors
    with non-empty mailboxes eventually get run by a specific thread, and that these
    messages are handled serially. A dispatcher is best compared to the e-mail answering
    policy in the software company. Some employees, such as the technical support
    specialists, are expected to answer e-mails as soon as they arrive. Software engineers
    sometimes have more liberty-they can choose to fix several bugs before inspecting
    their e-mails. The janitor spends his day working around the office building,
    and only takes a look at his e-mail client in the morning.
  prefs: []
  type: TYPE_NORMAL
- en: To make these concepts more concrete, we start by creating a simple actor application.
    This is the topic of the following section, in which we learn how to create actor
    systems and actor instances.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actor systems and actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating an object instance in an object-oriented language, we start by
    declaring a class, which can be reused by multiple object instances. We then specify
    arguments for the constructor of the object. Finally, we instantiate an object
    using the `new` keyword and obtain a reference to the object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an actor instance in Akka roughly follows the same steps as creating
    an object instance. First, we need to define an actor class, which defines the
    behavior of the actor. Then, we need to specify the configuration for a specific
    actor instance. Finally, we need to tell the actor system to instantiate the actor
    using the given configuration. The actor system then creates an actor instance
    and returns an actor reference to that instance. In this section, we will study
    these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: An actor class is used to specify the behavior of an actor. It describes how
    the actor responds to messages and communicates with other actors, encapsulates
    actor state, and defines the actor's startup and shutdown sequences. We declare
    a new actor class by extending the `Actor` trait from the `akka.actor` package.
    This trait comes with a single abstract method, `receive`. The `receive` method
    returns a partial function object of the type `PartialFunction[Any, Unit]`. This
    partial function is used when an actor receives a message of the `Any` type. If
    the partial function is not defined for the message, the message is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to defining how an actor receives messages, the actor class encapsulates
    references to objects used by the actor. These objects comprise the actor's state.
    Throughout this chapter, we use Akka's `Logging` object to print to the standard
    output. In the following code, we declare a `HelloActor` actor class, which reacts
    to a `hello` message specified with the `hello` constructor argument. The `HelloActor`
    class contains a `Logging` object, `log`, as part of its state. The `Logging`
    object is created using the `context.system` reference to the current actor system,
    and the `this` reference to the current actor. The `HelloActor` class defines
    a partial function in the `receive` method, which determines if the message is
    equal to the `hello` string argument, or to some other object called `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an actor defined by the `HelloActor` class receives a `hello` string message,
    it prints the message using the `Logging` object `log`. Otherwise, it prints that
    it received an unexpected message, and stops by calling the `context.stop` method
    on the actor reference `self`, which represents the current actor. This is shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Declaring an actor class does not create a running actor instance. Instead,
    the actor class serves as a blueprint for creating actor instances. The same actor
    class can be shared by many actor instances. To create an actor instance in Akka,
    we need to pass information about the actor class to the actor system. However,
    an actor class such as `HelloActor` is not sufficient for creating an actor instance;
    we also need to specify the `hello` argument. To bundle the information required
    for creating an actor instance, Akka uses objects called **actor configurations**.
  prefs: []
  type: TYPE_NORMAL
- en: An actor configuration contains information about the actor class, its constructor
    arguments, mailbox, and dispatcher implementation. In Akka, an actor configuration
    is represented with the `Props` class. A `Props` object encapsulates all the information
    required to create an actor instance, and can be serialized or sent over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `Props` objects, it is recommended practice to declare Factory methods
    in the companion object of the actor class. In the following companion object,
    we declare two Factory methods, called `props` and `propsAlt`, which return `Props`
    objects for the `HelloActor` class, given the `hello` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `props` method uses an overload of the `Props.apply` factory method, which
    takes a block of code by creating the `HelloActor` class. This block of code is
    invoked every time an actor system needs to create an actor instance. The `propsAlt`
    method uses another `Props.apply` overload, which creates an actor instance from
    the `Class` object of the actor class, and a list of constructor arguments. The
    two declarations are semantically equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `Props.apply` method overload takes a closure that calls the actor
    class constructor. If we are not careful, the closure can easily catch references
    to the enclosing scope. When this happens, these references become a part of the
    `Props` object. Consider the `defaultProps` method in the following utility class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sending the `Props` object that is returned by the `defaultProps` method over
    the network requires sending the enclosing `HelloActorUtils` object captured by
    the closure, incurring additional network costs.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is particularly dangerous to declare a `Props` object within
    an actor class, as it can catch a `this` reference to the enclosing actor instance.
    It is safer to create the `Props` objects exactly as they were shown in the `propsAlt`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid creating the `Props` objects within actor classes to prevent accidentally
    capturing the actor's `this` reference. Wherever possible, declare `Props` inside
    factory methods in top-level singleton objects.
  prefs: []
  type: TYPE_NORMAL
- en: The third overload of the `Props.apply` method is a convenience method that
    can be used with actor classes with zero-argument constructors. If `HelloActor`
    defines no constructor arguments, we can write `Props[HelloActor]` to create a
    `Props` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate an actor, we pass an actor configuration to the `actorOf` method
    of the actor system. Throughout this chapter, we will use our custom actor system
    instance called `ourSystem`. We define the `ourSystem` variable using the `ActorSystem.apply`
    factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can now create and run the `HelloActor` class by calling the `actorOf` method
    on the actor system. When creating a new actor, we can specify a unique name for
    the actor instance with the `name` argument. Without explicitly specifying the
    `name` argument, the actor system automatically assigns a unique name to the new
    actor instance. The `actorOf` method does not return an instance of the `HelloActor`
    class. Instead, it returns an actor reference object of the `ActorRef` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a `HelloActor` instance `hiActor`, which recognizes the `hi`
    messages, we send it a message, `hi`. To send a message to an Akka actor, we use
    the `!` operator (pronounced as *tell* or *bang*). For clarity, we then pause
    the execution for one second by calling `sleep`, and give the actor some time
    to process the message. We then send another message, `hola`, and wait one more
    second. Finally, we terminate the actor system by calling its `shutdown` method.
    This is shown in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Upon running this program, the `hiActor` instance first prints that it received
    a `hi` message. After one second, it prints that it received a `hola` string as
    a message, an unexpected message, and terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Managing unhandled messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `receive` method in the `HelloActor` example was able to handle any kind
    of message. When the message was different from the pre-specified `hello` argument,
    such as `hi`, used previously, the `HelloActor` actor reported this in the default
    case. Alternatively, we could have left the default case unhandled. When an actor
    receives a message that is not handled by its `receive` method, the message is
    wrapped into an `UnhandledMessage` object and forwarded to the actor system's
    event stream. Usually, the actor system's event stream is used for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override this default behavior by overriding the `unhandled` method
    in the actor class. By default, this method publishes the unhandled messages on
    the actor system''s event stream. In the following code, we declare a `DeafActor`
    actor class, whose `receive` method returns an empty partial function. An empty
    partial function is not defined for any type of message, so all the messages sent
    to this actor get passed to the `unhandled` method. We override it to output the
    `String` messages to the standard output. We pass all other types of message to
    the actor system''s event stream by calling the `super.unhandled` method. The
    following code snippet shows the `DeafActor` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test a `DeafActor` class in an example. The following program creates
    a `DeafActor` instance named `deafy`, and assigns its actor reference to the value
    `deafActor`. It then sends the two messages, `deafy` and `1234`, to `deafActor`,
    and shuts down the actor system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running this program shows that the first message, the `deafy` string, is caught
    and printed by the `unhandled` method. The `1234` message is forwarded to the
    actor system's event stream, and is never shown on the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'An attentive reader might have noticed that we could have avoided the `unhandled`
    call by moving the case into the `receive` method, as shown in the following `receive`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This definition of the `receive` method is more concise, but is inadequate for
    more complex actors. In the preceding example, we have fused the treatment of
    unhandled messages together with how the actor handles regular messages. Stateful
    actors often change the way they handle regular messages, and it is essential
    to separate the treatment of unhandled messages from the normal behavior of the
    actor. We will study how to change the actor behavior in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Actor behavior and state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an actor changes its state, it is often necessary to change the way it
    handles incoming messages. The way that the actor handles regular messages is
    called the **behavior** of the actor. In this section, we will study how to manipulate
    actor behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have previously learned that we define the initial behavior of the actor
    by implementing the `receive` method. Note that the `receive` method must always
    return the same partial function. It is not correct to return different partial
    functions from the `receive` method depending on the current state of the actor.
    Let''s assume we want to define a `CountdownActor` actor class, which decreases
    its `n` integer field every time it receives a `count` message, until it reaches
    zero. After the `CountdownActor` class reaches zero, it should ignore all subsequent
    messages. The following definition of the `receive` method is not allowed in Akka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To correctly change the behavior of the `CountdownActor` class after it reaches
    zero, we use the `become` method on the actor's `context` object. In the correct
    definition of the `CountdownActor` class, we define two methods, `counting` and
    `done`, which return two different behaviors. The `counting` behavior reacts to
    the `count` messages and calls `become` to change to the `done` behavior once
    the `n` field is zero. The `done` behavior is just an empty partial function,
    which ignores all the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following implementation of the `CountdownActor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `receive` method defines the initial behavior of the actor, which must be
    the `counting` behavior. Note that we are using the type alias `Receive` from
    the Actor companion object, which is just a shorthand for the `PartialFunction[Any,
    Unit] type`.
  prefs: []
  type: TYPE_NORMAL
- en: When modeling complex actors, it is helpful to think of them as **state machines**.
    A state machine is a mathematical model that represents a system with some number
    of states and transitions between these states. In an actor, each behavior corresponds
    to a state in the state machine. A transition exists between two states if the
    actor potentially calls the `become` method when receiving a certain message.
    In the following figure, we illustrate the state machine corresponding to the
    `CountdownActor` class. The two circles represent the states corresponding to
    the behaviors `counting` and `done`. The initial behavior is **counting**, so
    we draw an arrow pointing to the corresponding state. We represent the transitions
    between the states with arrows starting and ending at a state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the actor receives the **count** message and the **n** field is larger
    than **1**, the behavior does not change. However, when the actor receives the
    **count** message and the **n** field is decreased to `0`, the actor changes its
    behavior to **done**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actor behavior and state](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following short program tests the correctness of our actor. We use the
    actor system to create a new `countdown` actor, and send it 20 `count` messages.
    The actor only reacts to the first 10 messages, before switching to the `done`
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Whenever an actor responds to the incoming messages differently depending on
    its current state, you should decompose different states into partial functions
    and use the `become` method to switch between states. This is particularly important
    when actors get more complex, and ensures that the actor logic is easier to understand
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a stateful actor needs to change its behavior, declare a separate partial
    function for each of its behaviors. Implement the `receive` method to return the
    method corresponding to the initial behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We now consider a more refined example, in which we define an actor that checks
    if a given word exists in a dictionary and prints it to the standard output. We
    want to be able to change the dictionary that the actor is using during runtime.
    To set the dictionary, we send the actor an `Init` message with the path to the
    dictionary. After that, we can check if a word is in the dictionary by sending
    the actor the `IsWord` message. Once we're done using the dictionary, we can ask
    the actor to unload the dictionary by sending it the `End` message. After that,
    we can initialize the actor with some other dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following state machine models this logic with two behaviors, called `uninitialized`
    and `initialized`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actor behavior and state](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is a recommended practice to define the datatypes for the different messages
    in the companion object of the actor class. In this case, we add the case classes
    `Init`, `IsWord`, and `End` to the companion object of the `DictionaryActor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We next define the `DictionaryActor` actor class. This class defines a private
    `Logging` object `log`, and a `dictionary` mutable set, which is initially empty
    and can be used to store words. The `receive` method returns the `uninitialized`
    behavior, which only accepts the `Init` message type. When an `Init` message arrives,
    the actor uses its `path` field to fetch the dictionary from a file, load the
    words, and call `become` to switch to the `initialized` behavior. When an `IsWord`
    message arrives, the actor checks if the word exists and prints it to the standard
    output. If an `End` message arrives, the actor clears the dictionary and switches
    back to the `uninitialized` behavior. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have overridden the `unhandled` method in the `DictionaryActor`
    class. In this case, using the `unhandled` method reduces code duplication, and
    makes the `DictionaryActor` class easier to maintain, as there is no need to list
    the `default` case twice in both the `initialized` and `uninitialized` behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a Unix system, you can load the list of words, separated by
    a newline character, from the file in the `/usr/share/dict/words` location. Alternatively,
    download the source code for this book and find the `words.txt` file, or create
    a dummy file with several words, and save it to the `src/main/resources/org/learningconcurrency/`
    directory. You can then test the correctness of the `DictionaryActor` class using
    the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first message sent to the actor results in an error message. We cannot
    send an `IsWord` message before initializing the actor. After sending the `Init`
    message, we can check if words are present in the dictionary. Finally, we send
    an `End` message and shut down the actor system, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Having learned about actor behaviors, we will study how actors are organized
    into a hierarchy in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Akka actor hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In large organizations, people are assigned roles and responsibilities for different
    tasks in order to reach a specific goal. The CEO of the company chooses a specific
    goal, such as launching a software product. He then delegates parts of the work
    tasks to various teams within the company-the marketing team investigates potential
    customers for the new product, the design team develops the user interface of
    the product, and the software engineering team implements the logic of the software
    product. Each of these teams can be further decomposed into sub-teams with different
    roles and responsibilities, depending on the size of the company. For example,
    the software engineering team can be composed into two developer sub-teams, responsible
    for implementing the backend of the software product, such as the server-side
    code, and the frontend, such as the website or a desktop UI.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, sets of actors can form hierarchies in which actors that are closer
    to the root work on more general tasks and delegate work items to more specialized
    actors lower in the hierarchy. Organizing parts of the system into hierarchies
    is a natural and systematic way to decompose a complex program into its basic
    components. In the context of actors, a correctly chosen actor hierarchy can also
    guarantee better scalability of the application, depending on how the work is
    balanced between the actors. Importantly, a hierarchy between actors allows isolating
    and replacing parts of the system that fail more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Akka, actors implicitly form a hierarchy. Every actor can have some number
    of child actors, and it can create or stop child actors using the `context` object.
    To test this relationship, we will define two actor classes to represent the parent
    and child actors. We start by defining the `ChildActor` actor class, which reacts
    to the `sayhi` messages by printing the reference to its parent actor. The reference
    to the parent is obtained by calling the `parent` method on the `context` object.
    Additionally, we will override the `postStop` method of the `Actor` class, which
    is invoked after the actor stops. By doing this, we will be able to see precisely
    when a child actor is stopped. The `ChildActor` template is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define an actor class called `ParentActor`, which can accept the messages
    `create`, `sayhi`, and `stop`. When `ParentActor` receives a `create` message,
    it creates a new child by calling `actorOf` on the `context` object. When the
    `ParentActor` class receives a `sayhi` message, it forwards the message to its
    children by traversing the `context.children` list, and resending the message
    to each child. Finally, when the `ParentActor` class receives a `stop` message,
    it stops itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the actor classes `ParentActor` and `ChildActor` in the following program.
    We first create the `ParentActor` instance, `parent`, and then send two `create`
    messages to `parent`. The `parent` actor prints that it created a child actor
    twice. We then send a `sayhi` message to `parent`, and witness how the child actors
    output a message after the parent forwards the `sayhi` message to them. Finally,
    we send a `stop` message to stop the `parent` actor. This is shown in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By studying the standard output, we find that each of the two child actors output
    a `sayhi` message immediately after the `parent` actor prints that it is about
    to stop. This is the normal behavior of Akka actors-a child actor cannot exist
    without its parent. As soon as the parent actor stops, its child actors are stopped
    by the actor system as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an actor is stopped, its child actors are also automatically stopped.
  prefs: []
  type: TYPE_NORMAL
- en: If you ran the preceding example program, you might have noticed that printing
    an actor reference reflects the actor's position in the actor hierarchy. For example,
    printing the child actor reference shows the `akka://OurExampleSystem/user/parent/$a`
    string. The first part of this string, `akka://`, denotes that this reference
    points to a local actor. The `OurExampleSystem` part is the name of the actor
    system that we are using in this example. The `parent/$a` part reflects the name
    of the parent actor and the automatically generated name `$a` of the child actor.
    Unexpectedly, the string representation of the actor reference also contains a
    reference to an intermediate actor, called `user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Akka, an actor that resides at the top of the actor hierarchy is called
    the **guardian actor**, which exists to perform various internal tasks, such as
    logging and restarting user actors. Every top-level actor created in the application
    is placed under the `user` predefined guardian actor. There are other guardian
    actors. For example, actors internally used by the actor system are placed under
    the `system` guardian actor. The actor hierarchy is shown in the following figure,
    where the guardian actors `user` and `system` form two separate hierarchies in
    the actor system called `OurExampleSystem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Akka actor hierarchy](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, we saw that Akka actors form a hierarchy, and learned about
    the relationships between actors in this hierarchy. Importantly, we learned how
    to refer to immediate neighbors of an actor using the `parent` and `children`
    methods of the `context` object. In the following section, we will see how to
    refer to an arbitrary actor within the same actor system.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we learned that actors are organized in a hierarchical
    tree, in which every actor has a parent and some number of children. Thus, every
    actor lies on a unique path from the root of this hierarchy, and can be assigned
    a unique sequence of actor names on this path. The `parent` actor was directly
    beneath the `user` guardian actor, so its unique sequence of actor names is `/user/parent`.
    Similarly, the unique sequence of actor names for the `parent` actor's child actor
    is `$a` is `/user/parent/$a`. An **actor path** is a concatenation of the protocol,
    the actor system name, and the actor names on the path from the top guardian actor
    to a specific actor. The actor path of the `parent` actor from the previous example
    is `akka://OurExampleSystem/user/parent`.
  prefs: []
  type: TYPE_NORMAL
- en: Actor paths closely correspond to file paths in a filesystem. Every file path
    uniquely designates a file location, just as an actor path uniquely designates
    the location of the actor in the hierarchy. Just as a file path in a filesystem
    does not mean that a file exists, an actor path does not imply that there is an
    actor on that file path in the actor system. Instead, an actor path is an identifier
    used to obtain an actor reference if one exists. Also, parts of the names in the
    actor path can be replaced with wildcards and the `..` symbol, similar to how
    parts of filenames can be replaced in a shell. In this case, we obtain a **path
    selection**. For example, the path selection `..` references the parent of the
    current actor. The selection `../*` references the current actor and all its siblings.
  prefs: []
  type: TYPE_NORMAL
- en: Actor paths are different from actor references; we cannot send a message to
    an actor using its actor path. Instead, we must first use the actor path to identify
    an actor on that actor path. If we successfully find an actor reference behind
    an actor path, we can send messages to it.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain an actor reference corresponding to an actor path, we call the `actorSelection`
    method on the context object of an actor. This method takes an actor path, or
    a path selection. Calling the `actorSelection` method might address zero actors
    if no actors correspond to the actor path. Similarly, it might address multiple
    actors if we use a path selection. Thus, instead of returning an `ActorRef` object,
    the `actorSelection` method returns an `ActorSelection` object, which might represent
    zero, one, or more actors. We can use the `ActorSelection` object to send messages
    to these actors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `actorSelection` method on the `context` object to communicate with
    arbitrary actors in the actor system.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare the `ActorRef` object to a specific e-mail address, an `ActorSelection`
    object can be compared to a mailing list address. Sending an e-mail to a valid
    e-mail address ensures that the e-mail reaches a specific person. On the other
    hand, when we send an e-mail to a mailing list, the e-mail might reach zero, one,
    or more people, depending on the number of mailing list subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: An `ActorSelection` object does not tell us anything about the concrete paths
    of the actors, in a similar way to how a mailing list does not tell us anything
    about its subscribers. For this purpose, Akka defines a special type of message
    called `Identify`. When an Akka actor receives an `Identify` message, it will
    automatically reply by sending back an `ActorIdentity` message with its `ActorRef`
    object. If there are no actors in the actor selection, the `ActorIdentity` message
    is sent back to the sender of `Identify` without an `ActorRef` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Send `Identify` messages to the `ActorSelection` objects to obtain actor references
    of arbitrary actors in the actor system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define a `CheckActor` actor class, which describes
    actors that check and print actor references whenever they receive a message with
    an actor path. When the actor of type `CheckActor` receives a string with an actor
    path or a path selection, it obtains an `ActorSelection` object and sends it an
    `Identify` message. This message is forwarded to all actors in the selection,
    which then respond with an `ActorIdentity` message. The `Identify` message also
    takes a `messageId` argument. If an actor sends out multiple `Identify` messages,
    the `messageId` argument allows disambiguating between the different `ActorIdentity`
    responses. In our example, we use the `path` string as the `messageId` argument.
    When `CheckActor` receives an `ActorIdentity` message, it either prints the actor
    reference or reports that there is no actor on the specified path. The `CheckActor`
    class is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we instantiate a `checker` actor of the `CheckActor` class, and send
    it the path selection, `../*`. This references all the child actors of the `checker`
    parent-the `checker` actor itself and its siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not instantiate any top-level actors besides the `checker` actor, so
    checker receives only a single `ActorIdentity` message and prints its own actor
    path. Next, we try to identify all the actors one level above the `checker` actor.
    Recall the earlier figure. Since `checker` is a top-level actor, this should identify
    the guardian actors in the actor system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the `checker` actor prints the actor paths of the `user` and `system`
    guardian actors. We are curious to learn more about the system-internal actors
    from the `system` guardian actor. This time, we send an absolute path selection
    to `checker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checker` actor prints the actor paths of the internal actors `log1-Logging`
    and `deadLetterListener`, which are used for logging and for processing unhandled
    messages, respectively. We next try identifying a non-existing actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There are no actors named `checker2`, so `checker` receives an `ActorIdentity`
    message with the `ref` field set to `None` and prints that it cannot find an actor
    on that path.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `actorSelection` method and the `Identify` message is the fundamental
    method for discovering unknown actors in the same actor system. Note that we will
    always obtain an actor reference, and never obtain a pointer to the actor object
    directly. To better understand the reasons for this, we will study the lifecycle
    of actors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The actor lifecycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that the `ChildActor` class from the previous section overrode the `postStop`
    method to produce some logging output when the actor is stopped. In this section,
    we investigate when exactly the `postStop` method gets called, along with the
    other important events that comprise the lifecycle of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why the actor lifecycle is important, we consider what happens
    if an actor throws an exception while processing an incoming message. In Akka,
    such an exception is considered abnormal behavior, so top-level user actors that
    throw an exception are by default restarted. Restarting creates a fresh actor
    object, and effectively means that the actor state is reinitialized. When an actor
    is restarted, its actor reference and actor path remain the same. Thus, the same
    `ActorRef` object might refer to many different physical actor objects during
    the logical existence of the same actor. This is one of the reasons why an actor
    must never allow its `this` reference to leak. Doing so allows other parts of
    the program to refer to an old actor object, consequently invalidating the transparency
    of the actor reference. Additionally, revealing the `this` reference of the actor
    can reveal the internals of the actor implementation, or even cause data corruption.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never pass an actor's `this` reference to other actors, as it breaks actor encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine the complete actor lifecycle. As we have learned, a logical actor
    instance is created when we call the `actorOf` method. The `Props` object is used
    to instantiate a physical actor object. This object is assigned a mailbox, and
    can start receiving input messages. The `actorOf` method returns an actor reference
    to the caller, and the actors can execute concurrently. Before the actor starts
    processing messages, its `preStart` method is called. The `preStart` method is
    used to initialize the logical actor instance.
  prefs: []
  type: TYPE_NORMAL
- en: After creation, the actor starts processing messages. At some point, an actor
    might need to be restarted due to an exception. When this happens, the `preRestart`
    method is first called. All the child actors are then stopped. Then, the `Props`
    object, previously used in order to create the actor with the `actorOf` method,
    is reused to create a new actor object. The `postRestart` method is called on
    the newly created actor object. After `postRestart` returns, the new actor object
    is assigned the same mailbox as the old actor object, and it continues to process
    messages that were in the mailbox before the restart.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `postRestart` method calls the `prestart` method. In some cases,
    we want to override this behavior. For example, a database connection might need
    to be opened only once during `preStart`, and closed when the logical actor instance
    is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the logical actor instance needs to stop, the `postStop` method gets called.
    The actor path associated with the actor is released, and returned to the actor
    system. By default, the `preRestart` method calls the `postStop` method. The complete
    actor lifecycle is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The actor lifecycle](img/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that, during the actor lifecycle, the rest of the actor system observes
    the same actor reference, regardless of how many times the actor restarts. Actor
    failures and restarts occur transparently for the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment with the lifecycle of an actor, we declare two actor classes,
    `StringPrinter` and `LifecycleActor`. The `StringPrinter` actor prints a logging
    statement for each message that it receives. We override its `preStart` and `postStop`
    methods to precisely track when the actor has started and stopped, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LifecycleActor` class maintains a `child` actor reference to a `StringPrinter`
    actor. The `LifecycleActor` class reacts to the `Double` and `Int` messages by
    printing them, and to the `List` messages by printing the first element of the
    list. When it receives a `String` message, the `LifecycleActor` instance forwards
    it to the `child` actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We now override different lifecycle hooks. We start with the `preStart` method
    to output a logging statement and instantiate the `child` actor. This ensures
    that the `child` reference is initialized before the actor starts processing any
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we override the `preRestart` and `postRestart` methods. In the `preRestart`
    and `postRestart` methods, we log the exception that caused the failure. The `postRestart`
    method calls the `preStart` method by default, so the new actor object gets initialized
    with a new `child` actor after a restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we override the `postStop` method to track when the actor is stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create an instance of the `LifecycleActor` class called `testy`, and
    send a `math.Pi` message to it. The actor prints that it is about to start in
    its `preStart` method, and creates a new `child` actor. It then prints that it
    received the value `math.Pi`. Importantly, the `child about to start` logging
    statement is printed after the `math.Pi` message is received. This shows that
    actor creation is an asynchronous operation-when we call `actorOf`, creating the
    actor is delegated to the actor system, and the program immediately proceeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then send a string message to `testy`. The message is forwarded to the `child`
    actor, which prints a logging statement, indicating that it received the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we send a `Nil` message to `testy`. The `Nil` object represents an
    empty list, so `testy` throws an exception when attempting to fetch the `head`
    element. It reports that it needs to restart. After that, we witness that the
    `child` actor prints the message that it needs to stop; recall that the child
    actors are stopped when an actor is restarted. Finally, `testy` prints that it
    is about to restart, and the new `child` actor is instantiated. These events are
    caused by the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Testing the actor lifecycle revealed an important property of the `actorOf`
    method. When we call the `actorOf` method, the execution proceeds without waiting
    for the actor to fully initialize itself. Similarly, sending a message does not
    block execution until the message is received or processed by another actor; we
    say that message sends are asynchronous. In the following section, we will examine
    various communication patterns that address this asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned that actors communicate by sending messages. While actors running
    on the same machine can access shared parts of memory in the presence of proper
    synchronization, sending messages allows isolating the actor from the rest of
    the system and ensures location transparency. The fundamental operation that allows
    you to send a message to an actor is the `!` operator.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that the `!` operator is a non-blocking operation-sending a
    message does not block the execution of the sender until the message is delivered.
    This way of sending messages is sometimes called the **fire-and-forget** pattern,
    because it does not wait for a reply from the message receiver, nor does it ensure
    that the message is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages in this way improves the throughput of programs built using
    actors, but can be limiting in some situations. For example, we might want to
    send a message and wait for the response from the target. In this section, we
    learn about patterns used in actor communication that go beyond fire-and-forget.
  prefs: []
  type: TYPE_NORMAL
- en: While the fire-and-forget pattern does not guarantee that the message is delivered,
    it guarantees that the message is delivered **at most once**. The target actor
    never receives duplicate messages. Furthermore, the messages are guaranteed to
    be ordered for a given pair of sender and receiver actors. If an actor **A** sends
    messages **X** and **Y** in that order, the actor **B** will receive no duplicate
    messages, only the message **X**, only the message **Y**, or the message **X**,
    followed by the message **Y**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown on the left in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communication between actors](img/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, the delivery order is not ensured for a group of three or more actors.
    For example, as shown on the right in the preceding figure, actor **A** performs
    the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Sends a message **X** to the actor **B**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends a message **Y** to another actor, **C**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor **C** sends a message **Z** to the actor **B** after having received **Y**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this situation, the delivery order between messages **X** and **Z** is not
    guaranteed. The actor **B** might receive the messages **X** and **Z** in any
    order. This property reflects the characteristics of most computer networks, and
    is adopted to allow actors to run transparently on network nodes that may be remote.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order in which an actor **B** receives messages from an actor **A** is the
    same as the order in which these messages are sent from the actor **A**.
  prefs: []
  type: TYPE_NORMAL
- en: Before we study various patterns of actor communication, note that the `!` operator
    was not the only non-blocking operation. The methods `actorOf` and `actorSelection`
    are also non-blocking. These methods are often called while an actor is processing
    a message. Blocking the actor while the message is processed prevents the actor
    from processing subsequent messages in the mailbox and severely compromises the
    throughput of the system. For these reasons, most of the actor API is non-blocking.
    Additionally, we must never start blocking the operations from third-party libraries
    from within an actor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Messages must be handled without blocking indefinitely. Never start an infinite
    loop and avoid long-running computations in the `receive` block, the `unhandled`
    method, and within actor lifecycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The ask pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not being able to block from within an actor prevents the request-respond communication
    pattern. In this pattern, an actor interested in certain information sends a request
    message to another actor. It then needs to wait for a response message from the
    other actor. In Akka, this communication pattern is also known as the *ask pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: The `akka.pattern` package defines the use of convenience methods in actor communication.
    Importing its contents allows us to call the `?` operator (pronounced ask) on
    actor references. This operator sends a message to the target actor, such as the
    tell operator. Additionally, the ask operator returns a future object with the
    response from the target actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the usage of the ask pattern, we will define two actors that
    play ping pong with each other. A `Pingy` actor will send a `ping` request message
    to another actor, of type `Pongy`. When the `Pongy` actor receives the `ping`
    message, it sends a `pong` response message to the sender. We start by importing
    the `akka.pattern` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We first define the `Pongy` actor class. To respond to the `ping` incoming
    message, the `Pongy` actor needs an actor reference of the sender. While processing
    a message, every actor can call the `sender` method of the `Actor` class to obtain
    the actor reference of the sender of the current message. The `Pongy` actor uses
    the `sender` method to send `ping` back to the `Pingy` actor. The `Pongy` implementation
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `Pingy` actor class, which uses the ask operator to send
    a request to the `Pongy` actor. When the `Pingy` class receives a `pongyRef` actor
    reference of `Pongy`, it creates an implicit `Timeout` object set to two seconds.
    Using the ask operator requires an implicit `Timeout` object in scope; the future
    is failed with an `AskTimeoutException` exception if the response message does
    not arrive within the given timeframe. Once `Pingy` class sends the `ping` message,
    it is left with an `f` future object. The `Pingy` actor uses the special `pipeTo`
    combinator that sends the value in the future to the sender of the `pongyRef`
    actor reference, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The message in the future object can be manipulated using the standard future
    combinators seen in [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming
    with Futures and Promises"), *Asynchronous Programming with Futures and Promises*.
    However, the following definition of the `Pingy` actor would not be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Although it is perfectly legal to call the `onComplete` on the `f` future, the
    subsequent asynchronous computation should not access any mutable actor state.
    Recall that the actor state should be visible only to the actor, so concurrently
    accessing it opens the possibility of data races and race conditions. The `log`
    object should only be accessed by the actor that owns it. Similarly, we should
    not call the `sender` method from within the `onComplete` handler. By the time
    the future is completed with the response message, the actor might be processing
    a different message with a different sender, so the `sender` method can return
    arbitrary values.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When starting an asynchronous computation from within the `receive` block, the
    `unhandled` method, or a lifecycle hook, never let the closure capture any mutable
    actor state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test `Pingy` and `Pongy` in action, we define the `Master` actor class that
    instantiates them. Upon receiving the `start` message, the `Master` actor passes
    the `pongy` reference to the `pingy` reference. Once the `pingy` actor returns
    a `pong` message from `pongy`, the `Master` actor stops. This is shown in the
    following `Master` actor template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The ask pattern is useful because it allows you to send requests to multiple
    actors and obtain futures with their responses. Values from multiple futures can
    be combined within `for` comprehensions to compute a value from several responses.
    Using the fire-and-forget pattern when communicating with multiple actors requires
    changing the actor behavior, and is a lot more cumbersome than the ask pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The forward pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some actors exist solely to forward messages to other actors. For example, an
    actor might be responsible for load-balancing request messages between several
    worker actors, or it might forward the message to its mirror actor to ensure better
    availability. In such cases, it is useful to forward the message without changing
    the `sender` field of the message. The `forward` method on actor references serves
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we use the `StringPrinter` actor from the previous section
    to define a `Router` actor class. A `Router` actor instantiates four child `StringPrinter`
    actors and maintains an `i` field with the index of the list child it forwarded
    the message to. Whenever it receives a message, it forwards the message to a different
    `StringPrinter` child before incrementing the `i` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we create a `Router` actor and test it by sending it
    two messages. We can observe that the messages are printed to the standard output
    by two different `StringPrinter` actors, denoted with actors on the actor paths
    `/user/router/$b` and `/user/router/$a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The forward pattern is typically used in router actors, which use specific knowledge
    to decide about the destination of the message; replicator actors, which send
    the message to multiple destinations; or load balancers, which ensure that the
    workload is spread evenly between a set of worker actors.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping actors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have stopped different actors by making them call `context.stop`.
    Calling the `stop` method on the `context` object terminates the actor immediately
    after the current message is processed. In some cases, we want to have more control
    over how an actor gets terminated. For example, we might want to allow the actor
    to process its remaining messages or wait for the termination of some other actors.
    In Akka, there are several special message types that assist us in doing so, and
    we study them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we do not want to terminate an actor instance, but simply restart
    it. We have previously learned that an actor is automatically restarted when it
    throws an exception. An actor is also restarted when it receives the `Kill` message-when
    we send a `Kill` message to an actor, the actor automatically throws an `ActorKilledException`
    and fails.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `Kill` message to restart the target actor without losing the messages
    in the mailbox.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `stop` method, the `Kill` message does not terminate the actor, but
    only restarts it. In some cases, we want to terminate the actor instance, but
    allow it to process the messages from its mailbox. Sending a `PoisonPill` message
    to an actor has the same effect as calling `stop`, but allows the actor to process
    the messages that were in the mailbox before the `PoisonPill` message arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `PoisonPill` message to stop the actor, but allow it to process the
    messages received before the `PoisonPill` message.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, allowing the actor to process its message using `PoisonPill`
    is not enough. An actor might have to wait for other actors to terminate before
    terminating itself. An orderly shutdown is important in some cases, as actors
    might be involved in sensitive operations, such as writing to a file on the disk.
    We do not want to forcefully stop them when we end the application. A facility
    that allows an actor to track the termination of other actors is called **DeathWatch**
    in Akka.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the earlier example with the `Pingy` and `Pongy` actors. Let's say that
    we want to terminate the `Pingy` actor, but only after the `Pongy` actor has already
    been terminated. We define a new `GracefulPingy` actor class for this purpose.
    The `GracefulPingy` actor class calls the `watch` method on the `context` object
    when it gets created. This ensures that, after `Pongy` actor terminates and its
    `postStop` method completes, `GracefulPingy` actor receives a `Terminated` message
    with the actor reference to `Pongy` actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon receiving the `Terminated` message, `GracefulPingy` stops itself, as shown
    in the following `GracefulPingy` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Whenever we want to track the termination of an actor from inside an actor,
    we use DeathWatch, as in the previous example. When we need to wait for the termination
    of an actor from outside an actor, we use the *graceful stop pattern*. The `gracefulStop`
    method from the `akka.pattern` package takes an actor reference, a timeout, and
    a shutdown message. It returns a future and asynchronously sends the shutdown
    message to the actor. If the actor terminates within the allotted timeout, the
    future is successfully completed. Otherwise, the future fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we create a `GracefulPingy` actor instance and call
    the `gracefulStop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We typically use DeathWatch inside the actors, and the graceful stop pattern
    in the main application thread. The graceful stop pattern can be used within actors
    as well, as long as we are careful that the callbacks on the future returned by
    the `gracefulStop` method do not capture actor state. Together, DeathWatch and
    the graceful stop pattern allow safely shutting down actor-based programs.
  prefs: []
  type: TYPE_NORMAL
- en: Actor supervision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When studying the actor lifecycle, we said that top-level user actors are by
    default restarted when an exception occurs. We now take a closer inspection at
    how this works. In Akka, every actor acts as a supervisor for its children. When
    a child fails, it suspends the processing messages, and sends a message to its
    parent to decide what to do about the failure. The policy that decides what happens
    to the parent and the child after the child fails is called the **supervision
    strategy**. The parent might decide to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Restart the actor, indicated with the `Restart` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resume the actor without a restart, indicated with the `Resume` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permanently stop the actor, indicated with the `Stop` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fail itself with the same exception, indicated with the `Escalate` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the `user` guardian actor comes with a supervision strategy that
    restarts the failed children actors. User actors stop their children by default.
    Both supervision strategies can be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the default supervision strategy in user actors, we override the
    `supervisorStrategy` field of the `Actor` class. In the following code, we define
    a particularly troublesome actor class called `Naughty`. When the `Naughty` class
    receives a `String` type message, it prints a logging statement. For all other
    message types, it throws the `RuntimeException`, as shown in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare a `Supervisor` actor class, which creates a child actor of
    the `Naughty` type. The `Supervisor` actor does not handle any messages, but overrides
    the default supervision strategy. If a `Supervisor` actor''s child actor fails
    because of throwing an `ActorKilledException`, it is restarted. However, if its
    child actor fails with any other exception type, the exception is escalated to
    the `Supervisor` actor. We override the `supervisorStrategy` field with the value
    `OneForOneStrategy`, a supervision strategy that applies fault handling specifically
    to the actor that failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the new supervisor strategy by creating an actor instance, `super`,
    of the `Supervisor` actor class. We then create an actor selection for all the
    children of `super`, and send them a `Kill` message. This fails the `Naughty`
    actor, but `super` restarts it due to its supervision strategy. We then apologize
    to the `Naughty` actor by sending it a `String` message. Finally, we convert a
    `String` message to a list of characters, and send it to the `Naughty` actor,
    which then throws a `RuntimeException`. This exception is escalated by `super`,
    and both actors are terminated, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we saw how the `OneForOneStrategy` works. When an actor fails,
    that specific actor is resumed, restarted, or stopped, depending on the exception
    that caused it to fail. The alternative `AllForOneStrategy` applies the fault-handling
    decision to all the children. When one of the child actors stops, all the other
    children are resumed, restarted, or stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Recall our minimalistic web browser implementation from [Chapter 6](ch06.html
    "Chapter 6. Concurrent Programming with Reactive Extensions"), *Concurrent Programming
    with Reactive Extensions*. A more advanced web browser requires a separate subsystem
    that handles concurrent file downloads. Usually, we refer to such a software component
    as a download manager. We now consider a larger example, in which we apply our
    knowledge of actors in order to implement the infrastructure for a simple download
    manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The download manager will be implemented as an actor, represented by the `DownloadManager`
    actor class. The two most important tasks of every download manager are to download
    the resources at the requested URL, and to track the downloads that are currently
    in progress. To be able to react to download requests and download completion
    events, we define the message types `Download` and `Finished` in the `DownloadManager`
    companion object. The `Download` message encapsulates the URL of the resource
    and the destination file for the resource, while the `Finished` message encodes
    the destination file where the resource is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `DownloadManager` actor will not execute the downloads itself. Doing so
    would prevent it from receiving any messages before the download completes. Furthermore,
    this will serialize different downloads and prevent them from executing concurrently.
    Thus, the `DownloadManager` actor must delegate the task of downloading the files
    to different actors. We represent these actors with the `Downloader` actor class.
    A `DownloadManager` actor maintains a set of `Downloader` children, and tracks
    which children are currently downloading a resource. When a `DownloadManager`
    actor receives a `Download` message, it picks one of the non-busy `Downloader`
    actors, and forwards the `Download` message to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the download is complete, the `Downloader` actor sends a `Finished` message
    to its parent. This is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actor supervision](img/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We first show the implementation of the `Downloader` actor class. When a `Downloader`
    actor receives a `Download` message, it downloads the contents of the specified
    URL and writes them to a destination file. It then sends the `Finished` message
    back to the sender of the `Download` message, as shown in the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `DownloadManager` actor class needs to maintain state to track which of
    its `Downloader` actors is currently downloading a resource. If there are more
    download requests than there are available `Downloader` instances, the `DownloadManager`
    actor needs to enqueue the download requests until a `Downloader` actor becomes
    available. The `DownloadManager` actor maintains a `downloaders` queue with actor
    references to non-busy `Downloader` actors. It maintains another queue, the `pendingWork`
    queue, with `Download` requests that cannot be assigned to any `Downloader` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, it maintains a map called `workItems` that associates actor references
    of the busy `Downloader` instances with their `Download` requests. This is shown
    in the following `DownloadManager` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `checkDownloads` private method maintains the `DownloadManager` actor's
    invariant-the `pendingWork` and the `downloaders` queue cannot be non-empty at
    the same time. As soon as both the queues become non-empty, a `Downloader` actor
    reference `dl` is dequeued from `downloaders` and a `Download` request item is
    dequeued from the `pendingWork` queue. The `item` value is then sent as a message
    to the `dl` actor, and the `workItems` map is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the `DownloadManager` actor receives a `Download` message, it adds
    it to the `pendingWork` queue and calls the `checkDownloads` method. Similarly,
    when the `Finished` message arrives, the `Downloader` actor is removed from the
    `workItems` queue and enqueued on the `downloaders` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the `DownloadManager` actor is created with the specified number
    of `Downloader` child actors, we override the `preStart` method to create the
    `Downloaders` list and add their actor references to the `downloaders` queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we must override the `supervisorStrategy` field of the `DownloadManager`
    actor. We use the `OneForOneStrategy` field again, but specify that the actor
    can be restarted or resumed only up to 20 times within a two-second interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'We expect that some URLs might be invalid, in which case the actor fails with
    a `FileNotFoundException`. We need to remove such an actor from the `workItems`
    collection and add it back to the `downloaders` queue. It does not make sense
    to restart the `Downloader` actors, because they do not contain any state. Instead
    of restarting, we simply resume a `Downloader` actor that cannot resolve a URL.
    If the `Downloader` instances fail due to any other messages, we escalate the
    exception and fail the `DownloadManager` actor, as shown in the following `supervisorStrategy`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the download manager, we create a `DownloadManager` actor with four
    download slots, and send it several `Download` messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'An extra copy of the URL specification cannot hurt, so we download it to our
    computer. The download manager logs that there are only three download slots left.
    Once the download completes, the download manager logs that there are four remaining
    download slots again. We then decide that we would like to contribute to the Scala
    programming language, so we download the `README` file from the official Scala
    repository. Unfortunately, we enter an invalid URL, and observe a warning from
    the download manager saying that the resource cannot be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The simple implementation of the basic actor-based download manager illustrates
    both how to achieve concurrency by delegating work to child actors, and how to
    treat failures in child actors. Delegating work is important, both for decomposing
    the program into smaller, isolated components, and to achieve better throughput
    and scalability. Actor supervision is the fundamental mechanism for handling failures
    in isolated components implemented in separate actors.
  prefs: []
  type: TYPE_NORMAL
- en: Remote actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have mostly concentrated on writing programs on a single
    computer. Concurrent programs are executed within a single process on one computer,
    and they communicate using shared memory. Seemingly, actors described in this
    chapter communicate by passing messages. However, the message passing used throughout
    this chapter is implemented by reading and writing to shared memory under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we study how the actor model ensures location transparency
    by taking existing actors and deploying them in a distributed program. We take
    two existing actor implementations, namely, `Pingy` and `Pongy`, and deploy them
    inside different processes. We will then instruct the `Pingy` actor to send a
    message to the `Pongy` actor, as before, and wait until the `Pingy` actor returns
    the `Pongy` actor's message. The message exchange will occur transparently, although
    the `Pingy` and `Pongy` actor's were previously implemented without knowing that
    they might exist inside separate processes, or even different computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Akka actor framework is organized into several modules. To use the part
    of Akka that allows communicating with actors in remote actor systems, we need
    to add the following dependency to our build definition file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Before creating our ping-pong actors inside two different processes, we need
    to create an actor system that is capable of communicating with remote actors.
    To do this, we create a custom actor system configuration string. The actor system
    configuration string can be used to configure a range of different actor system
    properties; we are interested in using a custom `ActorRef` factory object called
    `RemoteActorRefProvider`. The `ActorRef` factory object allows the actor system
    to create actor references that can be used to communicate over the network. Furthermore,
    we configure the actor system to use the **Netty** networking library with the
    TCP network layer and the desired TCP port number. We declare the `remotingConfig`
    method for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define a `remotingSystem` factory method that creates an actor system
    object using the given name and port. We use the `remotingConfig` method, defined
    earlier, to produce the configuration object for the specified network port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to create the `Pongy` actor system. We declare an application
    called `RemotingPongySystem`, which instantiates an actor system called `PongyDimension`
    using the network port `24321`. We arbitrarily picked a network port that was
    free on our machine. If the creation of the actor system fails because the port
    is not available, you can pick a different port in the range `1024` to `65535`.
    Make sure that you don't have a firewall running, as it can block the network
    traffic for arbitrary applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RemotingPongySystem` application is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `RemotingPongySystem` application creates a `Pongy` actor and shuts down
    after 15 seconds. After we start it, we will only have a short time to start another
    application running the `Pingy` actor. We will call this second application `RemotingPingySystem`.
    Before we implement it, we create another actor called `Runner`, which will instantiate
    `Pingy`, obtain the `Pongy` actor's reference, and give it to the `Pingy` actor;
    recall that the ping-pong game from the earlier section starts when the `Pingy`
    actor obtains the `Pongy` actor's reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `Runner` actor receives a `start` message, it constructs the actor
    path for the `Pongy` actor. We use the `akka.tcp` protocol and the name of the
    remote actor system, along with its IP address and port number. The `Runner` actor
    sends an `Identify` message to the actor selection in order to obtain the actor
    reference to the remote `Pongy` instance. The complete `Runner` implementation
    is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `Runner` actor sends the `Pongy` actor reference to `Pingy`, the game
    of remote ping pong can begin. To test it, we declare the `RemotingPingySystem`
    application, which starts the `Runner` actor and sends it a `start` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We now need to start the `RemotingPongySystem` application, and the `RemotingPingySystem`
    application after that; we only have 15 seconds until the `RemotingPongySystem`
    application shuts itself down. The easiest way to do this is to start two SBT
    instances in your project folder and run the two applications at the same time.
    After the `RemotingPingySystem` application starts, we soon observe a `pong` message
    from another dimension.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the actor system configuration and the `Runner` actor
    were responsible for setting up the network communication, and were not location-transparent.
    This is typically the case with distributed programs; a part of the program is
    responsible for initializing and discovering actors within remote actor systems,
    while the application-specific logic is confined within separate actors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In larger actor programs, separate deployment logic from application logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, remote actor communication requires the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an actor system with an appropriate remoting configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting two actor systems in separate processes or on separate machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using actor path selection to obtain actor references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using actor references to transparently send messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first three steps are not location-transparent, the application logic
    is usually confined within the fourth step, as we saw in this section. This is
    important, as it allows separating the deployment logic from the application semantics
    and building distributed systems that can be deployed transparently to different
    network configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what actors are and how to use them to build concurrent
    programs. Using the Akka actor framework, we studied how to create actors, organize
    them into hierarchies, manage their lifecycle, and recover them from errors. We
    examined important patterns in actor communication and learned how to model actor
    behavior. Finally, we saw how the actor model can ensure location transparency,
    and serve as a powerful tool to seamlessly build distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there are many Akka features that we omitted in this chapter. Akka comes
    with detailed online documentation, which is one of the best sources of information
    on Akka. To obtain an in-depth understanding of distributed programming, we recommend
    the books *Distributed Algorithms*, *Nancy A. Lynch*, published by Elsevier and
    *Introduction to Reliable and Secure Distributed Programming*, *Christian Cachin*,
    *Rachid Guerraoui, Luis Rodrigues*, published by Springer.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will summarize the different concurrency libraries
    we learned about in this book, examine the typical use cases for each of them,
    and see how they work together in larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following exercises test your understanding of the actor programming model,
    and distributed programming in general. The first few exercises are straightforward,
    and deal with the basics of the actor API in Akka. Subsequent exercises are more
    involved, and go deeper into the territory of fault-tolerant distributed programming.
    Try to solve these exercises by first assuming that no machines fail, and then
    consider what happens if some of the machines fail during the execution of the
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the timer actor with the `TimerActor` class. After receiving a `Register`
    message containing the `t` timeout in milliseconds, the timer actor sends a `Timeout`
    message back after `t` milliseconds. The timer must accept multiple `Register`
    messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recall the bank account example from [Chapter 2](ch02.html "Chapter 2. Concurrency
    on the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*. Implement different bank accounts as separate actors, represented by the
    `AccountActor` class. When an `AccountActor` class receives a `Send` message,
    it must transfer the specified amount of money to the target actor. What will
    happen if either of the actors receives a `Kill` message at any point during the
    money transaction?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `SessionActor` class for actors that control access to other
    actors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `SessionActor` instance receives the `StartSession` message with the
    correct password, it forwards all the messages to the actor reference `r`, until
    it receives the `EndSession` message. Use behaviors to model this actor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use actors to implement the `ExecutionContext` interface, described in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `FailureDetector` actor, which sends `Identify` messages to the
    specified actors every `interval` seconds. If an actor does not reply with any
    `ActorIdentity` messages within `threshold` seconds, the `FailureDetector` actor
    sends a `Failed` message to its parent actor, which contains the actor reference
    of the failed actor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A distributed hash map is a collection distributed across multiple computers,
    each of which contains part of the data, called a **shard**. When there are `2^n`
    shards, the first `n` bits of the hash code of the key are used to decide which
    shard a key-value pair should go to. Implement the distributed hash map with the
    `DistributedMap` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `DistributedMap` class takes a list of actor references to the `ShardActor`
    instances, whose actor template you also need to implement. You might assume that
    the length of the `shards` list is a power of two. The `update` and `get` methods
    are asynchronous, and return the result in a future object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement an abstract `BroadcastActor` class, which defines the `broadcast`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `broadcast` method sends the `msg` message to all the actors specified
    in the `refs` list. The actor invoking the `broadcast` method might, for reasons
    such as power loss, fail at any point during the execution of the `broadcast`
    method. Nevertheless, the `broadcast` method must have **reliable delivery**:
    if at least one actor from the `refs` list receives the `msg` message, then all
    the actors from the `refs` list must eventually receive `msg`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement a `FlowRateActor` class for an actor that forwards incoming messages
    to a target actor. This actor must ensure that the number of messages forwarded
    per second does not exceed a rate specified in its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `Sequencer` actor, which forwards messages to the target actor.
    If the message is a two-element tuple where the first element is a `Long` value,
    then the `Long` value is interpreted as a sequence number. All such messages must
    be forwarded in the proper sequence number order, starting from number `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `MasterWorker[T]` actor that, given a number of worker parameters,
    creates a set of worker actors and forwards task messages of type `() => T` to
    those workers. When the worker actors complete a task, they send the result back
    to the `MasterWorker` actor, which sends the reply back to the client actor that
    originally sent the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
