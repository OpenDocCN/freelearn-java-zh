- en: Chapter 8.  Actors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。演员
- en: '|   | *"A distributed system is one in which the failure of a computer you
    didn''t even know existed can render your own computer unusable."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"一个分布式系统是这样的，即使你不知道有一台计算机存在，它的故障也可能使你的计算机无法使用。" |   |'
- en: '|   | --*Leslie Lamport* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*莱斯利·兰波特* |'
- en: Throughout this book, we have concentrated on many different abstractions for
    concurrent programming. Most of these abstractions assume the presence of shared
    memory. Futures and promises, concurrent data structures, and software transactional
    memory, are best suited to shared-memory systems. While the shared-memory assumption
    ensures that these facilities are efficient, it also limits them to applications
    running on a single computer. In this chapter, we consider a programming model
    that is equally applicable to a shared-memory machine or a distributed system,
    namely, the **actor model**. In the actor model, the program is represented by
    a large number of entities that execute computations independently, and communicate
    by passing messages. These independent entities are called **actors**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们集中讨论了许多并发编程的不同抽象。其中大部分抽象假设存在共享内存。未来和承诺、并发数据结构和软件事务内存，最适合共享内存系统。虽然共享内存假设确保了这些设施的高效性，但它也限制了它们只能应用于运行在单台计算机上的应用程序。在本章中，我们考虑了一种适用于共享内存机器或分布式系统的编程模型，即**演员模型**。在演员模型中，程序由大量独立执行计算并通过传递消息进行通信的实体表示。这些独立实体被称为**演员**。
- en: The actor model aims to resolve issues associated with using shared memory,
    such as data races or synchronization, by eliminating the need for shared memory
    altogether. *Mutable* state is confined within the boundaries of one actor, and
    is potentially modified when the actor receives a message. Messages received by
    the actor are handled serially, one after another. This ensures that the mutable
    state within the actor is never accessed concurrently. However, separate actors
    can process the received messages concurrently. In a typical actor-based program,
    the number of actors can be orders of magnitude greater than the number of processors.
    This is similar to the relationship between processors and threads in multi-threaded
    programs. The actor model implementation decides when to assign processor time
    to specific actors, to allow them to process messages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型旨在通过完全消除共享内存的需要来解决与使用共享内存相关的问题，例如数据竞争或同步。*可变*状态被限制在一个演员的边界内，并且当演员收到消息时可能会被修改。演员接收到的消息是按顺序处理的，一个接一个。这确保了演员内部的可变状态永远不会被并发访问。然而，不同的演员可以并发地处理接收到的消息。在一个典型的基于演员的程序中，演员的数量可以比处理器的数量多几个数量级。这类似于多线程程序中处理器和线程之间的关系。演员模型实现决定何时将处理器时间分配给特定的演员，以便他们处理消息。
- en: The true advantage of the actor model becomes apparent when we start distributing
    the application across multiple computers. Implementing programs that span across
    multiple machines and devices that communicate through a computer network is called
    **distributed programming**. The actor model allows you to write programs that
    run inside a single process, multiple processes on the same machine, or on multiple
    machines that are connected to a computer network. Creating actors and sending
    messages is oblivious to, and independent of, the location of the actor. In distributed
    programming, this is called **location transparency**. Location transparency allows
    you to design distributed systems without having the knowledge about the relationships
    in the computer network.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始将应用程序分布到多台计算机上时，演员模型的真正优势才显现出来。实现跨越多台计算机和通过计算机网络通信的设备的程序被称为**分布式编程**。演员模型允许你编写在单个进程中运行的程序，在同一台机器上的多个进程中运行，或者在连接到计算机网络的多台机器上运行。创建演员和发送消息与演员的位置无关，并且是独立的。在分布式编程中，这被称为**位置透明性**。位置透明性允许你设计分布式系统，而无需了解计算机网络中的关系。
- en: 'In this chapter, we will use the Akka `actor` framework to learn about the
    actor concurrency model. Specifically, we cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Akka `actor` 框架来了解演员并发模型。具体来说，我们将涵盖以下主题：
- en: Declaring actor classes and creating actor instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明演员类和创建演员实例
- en: Modeling actor state and complex actor behaviors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟演员状态和复杂的演员行为
- en: Manipulating the actor hierarchy and the lifecycle of an actor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作演员层次结构和演员的生命周期
- en: The different message-passing patterns used in actor communication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员通信中使用的不同消息传递模式
- en: Error recovery using the built-in actor supervision mechanism
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的演员监督机制进行错误恢复
- en: Using actors to transparently build concurrent and distributed programs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用演员透明地构建并发和分布式程序
- en: We will start by studying the important concepts and terminology in the actor
    model, and learning the basics of the actor model in Akka.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究演员模型中的重要概念和术语，并学习Akka中演员模型的基础知识。
- en: Working with actors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与演员一起工作
- en: In the actor programming model, the program is run by a set of concurrently
    executing entities called actors. Actor systems resemble human organizations,
    such as companies, governments, or other large institutions. To understand this
    similarity, we consider the example of a large software company.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在演员编程模型中，程序由一组并发执行的实体运行，这些实体被称为演员。演员系统类似于人类组织，例如公司、政府或其他大型机构。为了理解这种相似性，我们考虑一个大型软件公司的例子。
- en: In a software company such as Google, Microsoft, Amazon, or Typesafe, there
    are many goals that need to be achieved concurrently. Hundreds or thousands of
    employees work toward achieving these goals, and are usually organized in a hierarchical
    structure. Different employees work at different positions. A team leader makes
    important technical decisions for a specific project, a software engineer implements
    and maintains various parts of a software product, and a system administrator
    makes sure that the personal workstations, servers, and various equipment are
    functioning correctly. Many employees, such as the team leader, delegate their
    own tasks to other employees who are lower in the hierarchy than themselves. To
    be able to work and make decisions efficiently, employees use e-mails to communicate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在像谷歌、微软、亚马逊或Typesafe这样的软件公司中，有许多需要同时实现的目标。数百或数千名员工致力于实现这些目标，通常组织成一种分层结构。不同的员工在不同的职位上工作。团队领导为特定项目做出重要的技术决策，软件工程师实现并维护软件产品的各个部分，系统管理员确保个人工作站、服务器和各种设备正常运行。许多员工，如团队领导，将他们的任务委托给比他们级别低的员工。为了能够高效地工作和做出决策，员工使用电子邮件进行沟通。
- en: When an employee comes to work in the morning, he inspects his e-mail client
    and responds to the important messages. Sometimes, these messages contain work
    tasks that come from his boss, or requests from other employees. When an e-mail
    is important, the employee must compose the answer right away. While the employee
    is busy answering one e-mail, additional e-mails can arrive, and these e-mails
    are enqueued in his e-mail client. Only once the employee is done with one e-mail
    is he able to proceed to the next one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当员工早上来上班时，他会检查他的电子邮件客户端并回复重要的消息。有时，这些消息包含来自老板的工作任务或其他员工的要求。当一封电子邮件很重要时，员工必须立即撰写回复。当员工忙于回复一封电子邮件时，其他电子邮件可以到达，并且这些电子邮件会在他的电子邮件客户端中排队。只有当员工完成一封电子邮件后，他才能继续处理下一封。
- en: In the preceding scenario, the workflow of the company is divided into a number
    of functional components. It turns out that these components closely correspond
    to different parts of an actor framework. We will now identify these similarities
    by defining the parts of an actor system, and relating them to their analogs in
    the software company.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的场景中，公司的业务流程被划分为若干个功能组件。结果证明，这些组件与演员框架的不同部分紧密对应。现在，我们将通过定义演员系统的各个部分，并将它们与软件公司中的类比联系起来，来识别这些相似之处。
- en: An **actor system** is a hierarchical group of actors that share common configuration
    options. An actor system is responsible for creating new actors, locating actors
    within the actor system, and logging important events. An actor system is an analog
    of the software company itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员系统**是一组具有共同配置选项的演员的分层组。演员系统负责创建新的演员、在演员系统中定位演员以及记录重要事件。演员系统是软件公司本身的类比。'
- en: An **actor class** is a template that describes a state internal to the actor,
    and how the actor processes the messages. Multiple actors can be created from
    the same actor class. An actor class is an analogy for a specific position within
    the company, such as a software engineer, a marketing manager, or a recruiter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员类**是一个模板，描述了演员内部的状态以及演员如何处理消息。可以从相同的演员类创建多个演员。演员类是公司中特定职位的类比，例如软件工程师、市场营销经理或招聘人员。'
- en: An **actor instance** is an entity that exists at runtime and is capable of
    receiving messages. An actor instance might contain mutable state, and can send
    messages to other actor instances. The difference between an actor class and an
    actor instance directly corresponds to the relationship between a class and an
    object instance of that class in object-oriented programming. In the context of
    the software company example, an actor instance is analogous to a specific employee.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员实例**是在运行时存在并且能够接收消息的实体。演员实例可能包含可变状态，并且可以向其他演员实例发送消息。演员类与演员实例之间的区别直接对应于面向对象编程中类与该类对象实例之间的关系。在软件公司示例的上下文中，演员实例类似于特定员工。'
- en: A **message** is a unit of communication that actors use to communicate. In
    Akka, any object can be a message. Messages are analogous to e-mails sent within
    the company. When an actor sends a message, it does not wait until some other
    actor receives the message. Similarly, when an employee sends an e-mail, he does
    not wait until the e-mail is received or read by the other employees. Instead,
    he proceeds with his own work; an employee is too busy to wait. Multiple e-mails
    might be sent to the same person concurrently.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**是演员用来通信的单位。在Akka中，任何对象都可以是消息。消息类似于公司内部发送的电子邮件。当演员发送消息时，它不会等待其他演员接收消息。同样，当员工发送电子邮件时，他不会等待电子邮件被接收或被其他员工阅读。相反，他继续自己的工作；员工太忙了，不能等待。可能同时向同一个人发送多个电子邮件。'
- en: The **mailbox** is a part of memory that is used to buffer messages, specific
    to each actor instance. This buffer is necessary, as an actor instance can process
    only a single message at a time. The mailbox corresponds to an e-mail client used
    by an employee. At any point, there might be multiple unread e-mails buffered
    in the e-mail client, but the employee can only read and respond to them one at
    a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**邮箱**是内存的一部分，用于缓冲特定于每个演员实例的消息。这个缓冲区是必要的，因为演员实例一次只能处理一个消息。邮箱对应于员工使用的电子邮件客户端。在任何时候，电子邮件客户端中可能会有多个未读电子邮件被缓冲，但员工一次只能阅读和回复它们。'
- en: An **actor reference** is an object that allows you to send messages to a specific
    actor. This object hides information about the location of the actor from the
    programmer. An actor might run within separate processes or on different computers.
    The actor reference allows you to send a message to an actor irrespective of where
    the actor is running. From the software-company perspective, an actor reference
    corresponds to the e-mail address of a specific employee. The e-mail address allows
    us to send an e-mail to an employee, without knowing anything about the physical
    location of the employee. The employee might be in his office, on a business trip,
    or on vacation, but the e-mail will eventually reach him no matter where he goes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**演员引用**是一个对象，它允许你向特定的演员发送消息。此对象隐藏了演员位置的信息，不让程序员知道。演员可能运行在单独的进程或不同的计算机上。演员引用允许你向无论演员在哪里运行的演员发送消息。从软件公司的角度来看，演员引用对应于特定员工的电子邮件地址。电子邮件地址允许我们向员工发送电子邮件，而不必知道员工的物理位置。员工可能在他的办公室、出差或在度假，但无论他去哪里，电子邮件最终都会到达他那里。'
- en: A **dispatcher** is a component that decides when actors are allowed to process
    messages, and lends them computational resources to do so. In Akka, every dispatcher
    is, at the same time, an execution context. The dispatcher ensures that actors
    with non-empty mailboxes eventually get run by a specific thread, and that these
    messages are handled serially. A dispatcher is best compared to the e-mail answering
    policy in the software company. Some employees, such as the technical support
    specialists, are expected to answer e-mails as soon as they arrive. Software engineers
    sometimes have more liberty-they can choose to fix several bugs before inspecting
    their e-mails. The janitor spends his day working around the office building,
    and only takes a look at his e-mail client in the morning.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**调度器**是一个组件，它决定何时允许演员处理消息，并为他们提供计算资源以进行处理。在Akka中，每个调度器同时也是一个执行上下文。调度器确保具有非空邮箱的演员最终由特定的线程运行，并且这些消息是按顺序处理的。调度器最好与软件公司的电子邮件回复策略相比较。一些员工，如技术支持专家，期望他们一收到电子邮件就立即回复。软件工程师有时有更多的自由——他们可以选择在检查电子邮件之前修复几个错误。清洁工整天在办公楼周围工作，只在早上查看他的电子邮件客户端。'
- en: To make these concepts more concrete, we start by creating a simple actor application.
    This is the topic of the following section, in which we learn how to create actor
    systems and actor instances.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些概念更加具体，我们首先创建一个简单的演员应用程序。这是下一节的主题，我们将学习如何创建演员系统和演员实例。
- en: Creating actor systems and actors
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建演员系统和演员
- en: When creating an object instance in an object-oriented language, we start by
    declaring a class, which can be reused by multiple object instances. We then specify
    arguments for the constructor of the object. Finally, we instantiate an object
    using the `new` keyword and obtain a reference to the object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言中创建对象实例时，我们首先声明一个类，该类可以被多个对象实例重用。然后，我们指定对象的构造函数参数。最后，我们使用`new`关键字实例化一个对象，并获取对该对象的引用。
- en: Creating an actor instance in Akka roughly follows the same steps as creating
    an object instance. First, we need to define an actor class, which defines the
    behavior of the actor. Then, we need to specify the configuration for a specific
    actor instance. Finally, we need to tell the actor system to instantiate the actor
    using the given configuration. The actor system then creates an actor instance
    and returns an actor reference to that instance. In this section, we will study
    these steps in more detail.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中创建演员实例大致遵循创建对象实例相同的步骤。首先，我们需要定义一个演员类，该类定义了演员的行为。然后，我们需要指定特定演员实例的配置。最后，我们需要告诉演员系统使用给定的配置实例化演员。然后演员系统创建一个演员实例，并返回对该实例的演员引用。在本节中，我们将更详细地研究这些步骤。
- en: An actor class is used to specify the behavior of an actor. It describes how
    the actor responds to messages and communicates with other actors, encapsulates
    actor state, and defines the actor's startup and shutdown sequences. We declare
    a new actor class by extending the `Actor` trait from the `akka.actor` package.
    This trait comes with a single abstract method, `receive`. The `receive` method
    returns a partial function object of the type `PartialFunction[Any, Unit]`. This
    partial function is used when an actor receives a message of the `Any` type. If
    the partial function is not defined for the message, the message is discarded.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 演员类用于指定演员的行为。它描述了演员如何响应消息并与其他演员通信，封装演员状态，并定义演员的启动和关闭序列。我们通过扩展`akka.actor`包中的`Actor`特质来声明一个新的演员类。这个特质包含一个抽象方法`receive`。`receive`方法返回一个类型为`PartialFunction[Any,
    Unit]`的部分函数对象。当演员接收到`Any`类型的消息时，使用这个部分函数。如果部分函数未定义该消息，则该消息将被丢弃。
- en: In addition to defining how an actor receives messages, the actor class encapsulates
    references to objects used by the actor. These objects comprise the actor's state.
    Throughout this chapter, we use Akka's `Logging` object to print to the standard
    output. In the following code, we declare a `HelloActor` actor class, which reacts
    to a `hello` message specified with the `hello` constructor argument. The `HelloActor`
    class contains a `Logging` object, `log`, as part of its state. The `Logging`
    object is created using the `context.system` reference to the current actor system,
    and the `this` reference to the current actor. The `HelloActor` class defines
    a partial function in the `receive` method, which determines if the message is
    equal to the `hello` string argument, or to some other object called `msg`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义演员如何接收消息外，演员类还封装了演员使用的对象引用。这些对象构成了演员的状态。在本章中，我们使用Akka的`Logging`对象将输出打印到标准输出。在下面的代码中，我们声明了一个`HelloActor`演员类，该类对`hello`构造函数参数指定的`hello`消息做出反应。`HelloActor`类包含一个`Logging`对象`log`，作为其状态的一部分。`Logging`对象使用`context.system`对当前演员系统的引用和`this`对当前演员的引用来创建。`HelloActor`类在`receive`方法中定义了一个部分函数，该函数确定消息是否等于`hello`字符串参数，或者等于其他称为`msg`的对象。
- en: 'When an actor defined by the `HelloActor` class receives a `hello` string message,
    it prints the message using the `Logging` object `log`. Otherwise, it prints that
    it received an unexpected message, and stops by calling the `context.stop` method
    on the actor reference `self`, which represents the current actor. This is shown
    in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当由`HelloActor`类定义的演员接收到`hello`字符串消息时，它使用`Logging`对象`log`打印该消息。否则，它打印出它接收到了一个意外的消息，并通过在表示当前演员的演员引用`self`上调用`context.stop`方法来停止，这如以下代码片段所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declaring an actor class does not create a running actor instance. Instead,
    the actor class serves as a blueprint for creating actor instances. The same actor
    class can be shared by many actor instances. To create an actor instance in Akka,
    we need to pass information about the actor class to the actor system. However,
    an actor class such as `HelloActor` is not sufficient for creating an actor instance;
    we also need to specify the `hello` argument. To bundle the information required
    for creating an actor instance, Akka uses objects called **actor configurations**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个演员类并不会创建一个正在运行的演员实例。相反，演员类作为创建演员实例的蓝图。相同的演员类可以被许多演员实例共享。要在 Akka 中创建一个演员实例，我们需要将有关演员类的信息传递给演员系统。然而，像
    `HelloActor` 这样的演员类不足以创建一个演员实例；我们还需要指定 `hello` 参数。为了打包创建演员实例所需的信息，Akka 使用称为 **演员配置**
    的对象。
- en: An actor configuration contains information about the actor class, its constructor
    arguments, mailbox, and dispatcher implementation. In Akka, an actor configuration
    is represented with the `Props` class. A `Props` object encapsulates all the information
    required to create an actor instance, and can be serialized or sent over the network.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 演员配置包含有关演员类、其构造函数参数、邮箱和调度器实现的信息。在 Akka 中，演员配置用 `Props` 类表示。`Props` 对象封装了创建演员实例所需的所有信息，可以序列化或通过网络发送。
- en: 'To create `Props` objects, it is recommended practice to declare Factory methods
    in the companion object of the actor class. In the following companion object,
    we declare two Factory methods, called `props` and `propsAlt`, which return `Props`
    objects for the `HelloActor` class, given the `hello` argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `Props` 对象，建议在演员类的伴生对象中声明工厂方法。在以下伴生对象中，我们声明了两个工厂方法，分别称为 `props` 和 `propsAlt`，它们根据
    `hello` 参数返回 `HelloActor` 类的 `Props` 对象：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `props` method uses an overload of the `Props.apply` factory method, which
    takes a block of code by creating the `HelloActor` class. This block of code is
    invoked every time an actor system needs to create an actor instance. The `propsAlt`
    method uses another `Props.apply` overload, which creates an actor instance from
    the `Class` object of the actor class, and a list of constructor arguments. The
    two declarations are semantically equivalent.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`props` 方法使用 `Props.apply` 工厂方法的另一个重载，通过创建 `HelloActor` 类来获取代码块。每当演员系统需要创建一个演员实例时，都会调用此代码块。`propsAlt`
    方法使用另一个 `Props.apply` 重载，它从演员类的 `Class` 对象和一个构造函数参数列表创建演员实例。这两个声明在语义上是等价的。'
- en: 'The first `Props.apply` method overload takes a closure that calls the actor
    class constructor. If we are not careful, the closure can easily catch references
    to the enclosing scope. When this happens, these references become a part of the
    `Props` object. Consider the `defaultProps` method in the following utility class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `Props.apply` 方法重载接受一个调用演员类构造函数的闭包。如果我们不小心，闭包可以轻易捕获封装作用域的引用。当这种情况发生时，这些引用成为
    `Props` 对象的一部分。考虑以下实用类中的 `defaultProps` 方法：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sending the `Props` object that is returned by the `defaultProps` method over
    the network requires sending the enclosing `HelloActorUtils` object captured by
    the closure, incurring additional network costs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过网络发送由 `defaultProps` 方法返回的 `Props` 对象需要发送由闭包捕获的封装 `HelloActorUtils` 对象，这会产生额外的网络成本。
- en: Furthermore, it is particularly dangerous to declare a `Props` object within
    an actor class, as it can catch a `this` reference to the enclosing actor instance.
    It is safer to create the `Props` objects exactly as they were shown in the `propsAlt`
    method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在演员类中声明 `Props` 对象尤其危险，因为它可以捕获封装的演员实例的 `this` 引用。按照 `propsAlt` 方法所示创建 `Props`
    对象更安全。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid creating the `Props` objects within actor classes to prevent accidentally
    capturing the actor's `this` reference. Wherever possible, declare `Props` inside
    factory methods in top-level singleton objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在演员类中创建 `Props` 对象，以防止意外捕获演员的 `this` 引用。 wherever possible，在顶级单例对象的工厂方法中声明
    `Props`。
- en: The third overload of the `Props.apply` method is a convenience method that
    can be used with actor classes with zero-argument constructors. If `HelloActor`
    defines no constructor arguments, we can write `Props[HelloActor]` to create a
    `Props` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Props.apply` 方法的第三次重载是一个便利方法，它可以与具有零参数构造函数的演员类一起使用。如果 `HelloActor` 没有定义构造函数参数，我们可以编写
    `Props[HelloActor]` 来创建一个 `Props` 对象。'
- en: 'To instantiate an actor, we pass an actor configuration to the `actorOf` method
    of the actor system. Throughout this chapter, we will use our custom actor system
    instance called `ourSystem`. We define the `ourSystem` variable using the `ActorSystem.apply`
    factory method:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个 Actor，我们将 Actor 配置传递给 Actor 系统的 `actorOf` 方法。在本章中，我们将使用我们自定义的名为 `ourSystem`
    的 Actor 系统实例。我们使用 `ActorSystem.apply` 工厂方法定义 `ourSystem` 变量：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can now create and run the `HelloActor` class by calling the `actorOf` method
    on the actor system. When creating a new actor, we can specify a unique name for
    the actor instance with the `name` argument. Without explicitly specifying the
    `name` argument, the actor system automatically assigns a unique name to the new
    actor instance. The `actorOf` method does not return an instance of the `HelloActor`
    class. Instead, it returns an actor reference object of the `ActorRef` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在 Actor 系统上调用 `actorOf` 方法来创建和运行 `HelloActor` 类。在创建一个新的 Actor 时，我们可以使用
    `name` 参数为 Actor 实例指定一个唯一的名称。如果没有明确指定 `name` 参数，Actor 系统会自动为新 Actor 实例分配一个唯一的名称。`actorOf`
    方法不返回 `HelloActor` 类的实例。相反，它返回一个 `ActorRef` 类型的 Actor 引用对象。
- en: 'After creating a `HelloActor` instance `hiActor`, which recognizes the `hi`
    messages, we send it a message, `hi`. To send a message to an Akka actor, we use
    the `!` operator (pronounced as *tell* or *bang*). For clarity, we then pause
    the execution for one second by calling `sleep`, and give the actor some time
    to process the message. We then send another message, `hola`, and wait one more
    second. Finally, we terminate the actor system by calling its `shutdown` method.
    This is shown in the following program:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个能够识别 `hi` 消息的 `HelloActor` 实例 `hiActor` 之后，我们向它发送了一个消息，`hi`。要向 Akka Actor
    发送消息，我们使用 `!` 操作符（发音为 *tell* 或 *bang*）。为了清晰起见，我们随后通过调用 `sleep` 暂停执行一秒，给 Actor
    一些时间来处理消息。然后我们发送另一个消息，`hola`，并再等待一秒。最后，我们通过调用其 `shutdown` 方法来终止 Actor 系统。这在上面的程序中有所展示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Upon running this program, the `hiActor` instance first prints that it received
    a `hi` message. After one second, it prints that it received a `hola` string as
    a message, an unexpected message, and terminates.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序后，`hiActor` 实例首先打印出它接收到了一个 `hi` 消息。一秒后，它打印出它接收到了一个 `hola` 字符串作为消息，一个意外的消息，然后终止。
- en: Managing unhandled messages
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理未处理的消息
- en: The `receive` method in the `HelloActor` example was able to handle any kind
    of message. When the message was different from the pre-specified `hello` argument,
    such as `hi`, used previously, the `HelloActor` actor reported this in the default
    case. Alternatively, we could have left the default case unhandled. When an actor
    receives a message that is not handled by its `receive` method, the message is
    wrapped into an `UnhandledMessage` object and forwarded to the actor system's
    event stream. Usually, the actor system's event stream is used for logging purposes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `HelloActor` 示例中，`receive` 方法能够处理任何类型的消息。当消息与预先指定的 `hello` 参数不同时，例如之前使用的 `hi`，`HelloActor`
    Actor 会将此报告在默认情况下。或者，我们也可以不处理默认情况。当一个 Actor 收到其 `receive` 方法无法处理的消息时，该消息会被封装成一个
    `UnhandledMessage` 对象，并转发到 Actor 系统的事件流中。通常，Actor 系统的事件流用于日志记录目的。
- en: 'We can override this default behavior by overriding the `unhandled` method
    in the actor class. By default, this method publishes the unhandled messages on
    the actor system''s event stream. In the following code, we declare a `DeafActor`
    actor class, whose `receive` method returns an empty partial function. An empty
    partial function is not defined for any type of message, so all the messages sent
    to this actor get passed to the `unhandled` method. We override it to output the
    `String` messages to the standard output. We pass all other types of message to
    the actor system''s event stream by calling the `super.unhandled` method. The
    following code snippet shows the `DeafActor` implementation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Actor 类中重写 `unhandled` 方法来覆盖这个默认行为。默认情况下，此方法会将未处理的消息发布到 Actor 系统的事件流中。在下面的代码中，我们声明了一个
    `DeafActor` Actor 类，其 `receive` 方法返回一个空的偏函数。空的偏函数没有为任何类型的消息定义，所以所有发送给这个 Actor
    的消息都会传递到 `unhandled` 方法。我们重写它以将 `String` 消息输出到标准输出。我们通过调用 `super.unhandled` 方法将所有其他类型的消息传递到
    Actor 系统的事件流中。下面的代码片段展示了 `DeafActor` 的实现：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s test a `DeafActor` class in an example. The following program creates
    a `DeafActor` instance named `deafy`, and assigns its actor reference to the value
    `deafActor`. It then sends the two messages, `deafy` and `1234`, to `deafActor`,
    and shuts down the actor system:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个例子中测试一个`DeafActor`类。以下程序创建了一个名为`deafy`的`DeafActor`实例，并将它的actor引用赋值给`deafActor`。然后它向`deafActor`发送两条消息，`deafy`和`1234`，然后关闭actor系统：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this program shows that the first message, the `deafy` string, is caught
    and printed by the `unhandled` method. The `1234` message is forwarded to the
    actor system's event stream, and is never shown on the standard output.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序表明，第一条消息，即`deafy`字符串，被`unhandled`方法捕获并打印出来。`1234`消息被转发到actor系统的event流中，并且永远不会显示在标准输出上。
- en: 'An attentive reader might have noticed that we could have avoided the `unhandled`
    call by moving the case into the `receive` method, as shown in the following `receive`
    implementation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者可能会注意到，我们可以通过将case移动到`receive`方法中来避免`unhandled`调用，如下面的`receive`实现所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This definition of the `receive` method is more concise, but is inadequate for
    more complex actors. In the preceding example, we have fused the treatment of
    unhandled messages together with how the actor handles regular messages. Stateful
    actors often change the way they handle regular messages, and it is essential
    to separate the treatment of unhandled messages from the normal behavior of the
    actor. We will study how to change the actor behavior in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`receive`方法的定义更加简洁，但对于更复杂的actor来说是不够的。在先前的例子中，我们将未处理消息的处理方式与actor处理常规消息的方式合并在一起。有状态actor通常会改变它们处理常规消息的方式，因此将未处理消息的处理与actor的正常行为分开是至关重要的。我们将在下一节研究如何改变actor的行为。
- en: Actor behavior and state
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Actor行为和状态
- en: When an actor changes its state, it is often necessary to change the way it
    handles incoming messages. The way that the actor handles regular messages is
    called the **behavior** of the actor. In this section, we will study how to manipulate
    actor behavior.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当actor改变其状态时，通常需要改变它处理传入消息的方式。actor处理常规消息的方式被称为actor的**行为**。在本节中，我们将研究如何操纵actor行为。
- en: 'We have previously learned that we define the initial behavior of the actor
    by implementing the `receive` method. Note that the `receive` method must always
    return the same partial function. It is not correct to return different partial
    functions from the `receive` method depending on the current state of the actor.
    Let''s assume we want to define a `CountdownActor` actor class, which decreases
    its `n` integer field every time it receives a `count` message, until it reaches
    zero. After the `CountdownActor` class reaches zero, it should ignore all subsequent
    messages. The following definition of the `receive` method is not allowed in Akka:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经了解到，我们通过实现`receive`方法来定义actor的初始行为。请注意，`receive`方法必须始终返回相同的偏函数。从`receive`方法返回不同的偏函数，取决于actor的当前状态是不正确的。让我们假设我们想要定义一个`CountdownActor`actor类，每次接收到`count`消息时，它都会减少其`n`整数字段，直到为零。在`CountdownActor`类达到零后，它应该忽略所有后续消息。以下`receive`方法的定义在Akka中是不允许的：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To correctly change the behavior of the `CountdownActor` class after it reaches
    zero, we use the `become` method on the actor's `context` object. In the correct
    definition of the `CountdownActor` class, we define two methods, `counting` and
    `done`, which return two different behaviors. The `counting` behavior reacts to
    the `count` messages and calls `become` to change to the `done` behavior once
    the `n` field is zero. The `done` behavior is just an empty partial function,
    which ignores all the messages.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`CountdownActor`类达到零后正确地改变其行为，我们使用actor的`context`对象上的`become`方法。在`CountdownActor`类的正确定义中，我们定义了两个方法，`counting`和`done`，它们返回两种不同的行为。`counting`行为对`count`消息做出反应，并在`n`字段为零时调用`become`以转换为`done`行为。`done`行为只是一个空的偏函数，它忽略所有消息。
- en: 'This is shown in the following implementation of the `CountdownActor` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下`CountdownActor`类的实现中得到了展示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `receive` method defines the initial behavior of the actor, which must be
    the `counting` behavior. Note that we are using the type alias `Receive` from
    the Actor companion object, which is just a shorthand for the `PartialFunction[Any,
    Unit] type`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`receive`方法定义了actor的初始行为，这必须是`counting`行为。请注意，我们正在使用来自Actor伴随对象的类型别名`Receive`，它只是`PartialFunction[Any,
    Unit]`类型的简写。'
- en: When modeling complex actors, it is helpful to think of them as **state machines**.
    A state machine is a mathematical model that represents a system with some number
    of states and transitions between these states. In an actor, each behavior corresponds
    to a state in the state machine. A transition exists between two states if the
    actor potentially calls the `become` method when receiving a certain message.
    In the following figure, we illustrate the state machine corresponding to the
    `CountdownActor` class. The two circles represent the states corresponding to
    the behaviors `counting` and `done`. The initial behavior is **counting**, so
    we draw an arrow pointing to the corresponding state. We represent the transitions
    between the states with arrows starting and ending at a state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟复杂演员时，将其视为 **状态机** 是有帮助的。状态机是一个数学模型，它表示具有一些状态和这些状态之间转换的系统。在演员中，每种行为对应于状态机中的一个状态。如果演员在接收到特定消息时可能调用
    `become` 方法，则存在两个状态之间的转换。在以下图中，我们展示了对应于 `CountdownActor` 类的状态机。两个圆圈代表对应于行为 `counting`
    和 `done` 的状态。初始行为是 **counting**，所以我们画了一条指向相应状态的箭头。我们用指向状态的箭头来表示状态之间的转换。
- en: 'When the actor receives the **count** message and the **n** field is larger
    than **1**, the behavior does not change. However, when the actor receives the
    **count** message and the **n** field is decreased to `0`, the actor changes its
    behavior to **done**:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当演员接收到 **count** 消息且 **n** 字段大于 **1** 时，行为不会改变。然而，当演员接收到 **count** 消息且 **n**
    字段减少到 `0` 时，演员的行为将变为 **done**：
- en: '![Actor behavior and state](img/image_08_001.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![演员行为和状态](img/image_08_001.jpg)'
- en: 'The following short program tests the correctness of our actor. We use the
    actor system to create a new `countdown` actor, and send it 20 `count` messages.
    The actor only reacts to the first 10 messages, before switching to the `done`
    behavior:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的程序测试了我们演员的正确性。我们使用演员系统创建一个新的 `countdown` 演员并发送 20 个 `count` 消息。演员只对前 10
    个消息做出反应，然后切换到 `done` 行为：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whenever an actor responds to the incoming messages differently depending on
    its current state, you should decompose different states into partial functions
    and use the `become` method to switch between states. This is particularly important
    when actors get more complex, and ensures that the actor logic is easier to understand
    and maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当演员根据其当前状态对传入的消息做出不同的响应时，你应该将不同的状态分解为偏函数，并使用 `become` 方法在状态之间切换。这在演员变得更加复杂时尤为重要，并确保演员逻辑更容易理解和维护。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a stateful actor needs to change its behavior, declare a separate partial
    function for each of its behaviors. Implement the `receive` method to return the
    method corresponding to the initial behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个有状态的演员需要改变其行为时，为每种行为声明一个单独的偏函数。实现 `receive` 方法以返回对应初始行为的函数。
- en: We now consider a more refined example, in which we define an actor that checks
    if a given word exists in a dictionary and prints it to the standard output. We
    want to be able to change the dictionary that the actor is using during runtime.
    To set the dictionary, we send the actor an `Init` message with the path to the
    dictionary. After that, we can check if a word is in the dictionary by sending
    the actor the `IsWord` message. Once we're done using the dictionary, we can ask
    the actor to unload the dictionary by sending it the `End` message. After that,
    we can initialize the actor with some other dictionary.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑一个更精细的例子，在这个例子中，我们定义了一个演员，该演员检查给定的单词是否存在于字典中，并将其打印到标准输出。我们希望在运行时能够更改演员使用的字典。为了设置字典，我们向演员发送一个包含字典路径的
    `Init` 消息。之后，我们可以通过向演员发送 `IsWord` 消息来检查单词是否在字典中。一旦我们完成对字典的使用，我们可以通过向演员发送 `End`
    消息来请求卸载字典。之后，我们可以用其他字典初始化演员。
- en: 'The following state machine models this logic with two behaviors, called `uninitialized`
    and `initialized`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下状态机模型使用两种行为来表示这种逻辑，称为 `uninitialized` 和 `initialized`：
- en: '![Actor behavior and state](img/image_08_002.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![演员行为和状态](img/image_08_002.jpg)'
- en: 'It is a recommended practice to define the datatypes for the different messages
    in the companion object of the actor class. In this case, we add the case classes
    `Init`, `IsWord`, and `End` to the companion object of the `DictionaryActor` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在演员类的伴随对象中为不同的消息定义数据类型是一种推荐的做法。在这种情况下，我们将案例类 `Init`、`IsWord` 和 `End` 添加到 `DictionaryActor`
    类的伴随对象中：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We next define the `DictionaryActor` actor class. This class defines a private
    `Logging` object `log`, and a `dictionary` mutable set, which is initially empty
    and can be used to store words. The `receive` method returns the `uninitialized`
    behavior, which only accepts the `Init` message type. When an `Init` message arrives,
    the actor uses its `path` field to fetch the dictionary from a file, load the
    words, and call `become` to switch to the `initialized` behavior. When an `IsWord`
    message arrives, the actor checks if the word exists and prints it to the standard
    output. If an `End` message arrives, the actor clears the dictionary and switches
    back to the `uninitialized` behavior. This is shown in the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `DictionaryActor` actor 类。这个类定义了一个私有的 `Logging` 对象 `log` 和一个 `dictionary`
    可变集合，该集合最初为空，可以用来存储单词。`receive` 方法返回 `uninitialized` 行为，它只接受 `Init` 消息类型。当 `Init`
    消息到达时，actor 使用其 `path` 字段从文件中获取字典，加载单词，并调用 `become` 切换到 `initialized` 行为。当 `IsWord`
    消息到达时，actor 检查单词是否存在并将其打印到标准输出。如果到达 `End` 消息，actor 清除字典并切换回 `uninitialized` 行为。这在上面的代码片段中显示：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we have overridden the `unhandled` method in the `DictionaryActor`
    class. In this case, using the `unhandled` method reduces code duplication, and
    makes the `DictionaryActor` class easier to maintain, as there is no need to list
    the `default` case twice in both the `initialized` and `uninitialized` behaviors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `DictionaryActor` 类中重写了 `unhandled` 方法。在这种情况下，使用 `unhandled` 方法减少了代码重复，并使得
    `DictionaryActor` 类更容易维护，因为不需要在 `initialized` 和 `uninitialized` 行为中都列出 `default`
    情况两次。
- en: 'If you are using a Unix system, you can load the list of words, separated by
    a newline character, from the file in the `/usr/share/dict/words` location. Alternatively,
    download the source code for this book and find the `words.txt` file, or create
    a dummy file with several words, and save it to the `src/main/resources/org/learningconcurrency/`
    directory. You can then test the correctness of the `DictionaryActor` class using
    the following program:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Unix 系统，你可以从 `/usr/share/dict/words` 位置加载由换行符分隔的单词列表文件。或者，下载本书的源代码并找到
    `words.txt` 文件，或者创建一个包含几个单词的虚拟文件，并将其保存到 `src/main/resources/org/learningconcurrency/`
    目录。然后，你可以使用以下程序测试 `DictionaryActor` 类的正确性：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The first message sent to the actor results in an error message. We cannot
    send an `IsWord` message before initializing the actor. After sending the `Init`
    message, we can check if words are present in the dictionary. Finally, we send
    an `End` message and shut down the actor system, as shown in the following code
    snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到 actor 的第一条消息会导致错误消息。在初始化 actor 之前，我们不能发送 `IsWord` 消息。在发送 `Init` 消息后，我们可以检查字典中是否存在单词。最后，我们发送
    `End` 消息并关闭 actor 系统，如以下代码片段所示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having learned about actor behaviors, we will study how actors are organized
    into a hierarchy in the following section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 actor 行为之后，我们将在下一节研究 actor 如何组织成层次结构。
- en: Akka actor hierarchy
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Akka actor 层次结构
- en: In large organizations, people are assigned roles and responsibilities for different
    tasks in order to reach a specific goal. The CEO of the company chooses a specific
    goal, such as launching a software product. He then delegates parts of the work
    tasks to various teams within the company-the marketing team investigates potential
    customers for the new product, the design team develops the user interface of
    the product, and the software engineering team implements the logic of the software
    product. Each of these teams can be further decomposed into sub-teams with different
    roles and responsibilities, depending on the size of the company. For example,
    the software engineering team can be composed into two developer sub-teams, responsible
    for implementing the backend of the software product, such as the server-side
    code, and the frontend, such as the website or a desktop UI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型组织中，人们被分配不同的任务角色和责任，以实现特定的目标。公司的 CEO 选择一个特定的目标，例如推出一个软件产品。然后，他将部分工作任务委托给公司内部的不同团队——市场营销团队调查新产品的潜在客户，设计团队开发产品的用户界面，软件工程团队实现软件产品的逻辑。根据公司的规模，每个团队都可以进一步分解为具有不同角色和责任的子团队。例如，软件工程团队可以组成两个开发者子团队，负责实现软件产品的后端，如服务器端代码，以及前端，如网站或桌面
    UI。
- en: Similarly, sets of actors can form hierarchies in which actors that are closer
    to the root work on more general tasks and delegate work items to more specialized
    actors lower in the hierarchy. Organizing parts of the system into hierarchies
    is a natural and systematic way to decompose a complex program into its basic
    components. In the context of actors, a correctly chosen actor hierarchy can also
    guarantee better scalability of the application, depending on how the work is
    balanced between the actors. Importantly, a hierarchy between actors allows isolating
    and replacing parts of the system that fail more easily.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，演员的集合可以形成层次结构，其中靠近根部的演员处理更通用的任务，并将工作项委托给层次结构中较低级别的更专业化的演员。将系统的部分组织成层次结构是将复杂程序分解为其基本组件的自然和系统化方法。在演员的上下文中，正确选择的演员层次结构还可以根据演员之间工作平衡的情况保证应用程序更好的可伸缩性。重要的是，演员之间的层次结构允许隔离和替换系统中更容易失败的部件。
- en: 'In Akka, actors implicitly form a hierarchy. Every actor can have some number
    of child actors, and it can create or stop child actors using the `context` object.
    To test this relationship, we will define two actor classes to represent the parent
    and child actors. We start by defining the `ChildActor` actor class, which reacts
    to the `sayhi` messages by printing the reference to its parent actor. The reference
    to the parent is obtained by calling the `parent` method on the `context` object.
    Additionally, we will override the `postStop` method of the `Actor` class, which
    is invoked after the actor stops. By doing this, we will be able to see precisely
    when a child actor is stopped. The `ChildActor` template is shown in the following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Akka中，演员隐式地形成一个层次结构。每个演员都可以有一些子演员，并且可以使用`context`对象创建或停止子演员。为了测试这种关系，我们将定义两个演员类来表示父演员和子演员。我们首先定义`ChildActor`演员类，该类通过打印其父演员的引用来响应`sayhi`消息。父演员的引用是通过在`context`对象上调用`parent`方法获得的。此外，我们还将覆盖`Actor`类的`postStop`方法，该方法在演员停止后被调用。通过这样做，我们能够精确地看到子演员何时停止。`ChildActor`模板如下代码片段所示：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now define an actor class called `ParentActor`, which can accept the messages
    `create`, `sayhi`, and `stop`. When `ParentActor` receives a `create` message,
    it creates a new child by calling `actorOf` on the `context` object. When the
    `ParentActor` class receives a `sayhi` message, it forwards the message to its
    children by traversing the `context.children` list, and resending the message
    to each child. Finally, when the `ParentActor` class receives a `stop` message,
    it stops itself:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个名为`ParentActor`的演员类，它可以接受`create`、`sayhi`和`stop`消息。当`ParentActor`收到`create`消息时，它通过在`context`对象上调用`actorOf`来创建一个新的子演员。当`ParentActor`类收到`sayhi`消息时，它通过遍历`context.children`列表将消息转发给其子演员，并将消息重新发送给每个子演员。最后，当`ParentActor`类收到`stop`消息时，它停止自己：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We test the actor classes `ParentActor` and `ChildActor` in the following program.
    We first create the `ParentActor` instance, `parent`, and then send two `create`
    messages to `parent`. The `parent` actor prints that it created a child actor
    twice. We then send a `sayhi` message to `parent`, and witness how the child actors
    output a message after the parent forwards the `sayhi` message to them. Finally,
    we send a `stop` message to stop the `parent` actor. This is shown in the following
    program:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下程序中测试了`ParentActor`和`ChildActor`演员类。我们首先创建`ParentActor`实例`parent`，然后向`parent`发送两个`create`消息。`parent`演员打印出它创建了两个子演员。然后我们向`parent`发送一个`sayhi`消息，并观察子演员在父演员将`sayhi`消息转发给它们之后输出消息。最后，我们向`parent`发送`stop`消息来停止父演员。这如下面的程序所示：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By studying the standard output, we find that each of the two child actors output
    a `sayhi` message immediately after the `parent` actor prints that it is about
    to stop. This is the normal behavior of Akka actors-a child actor cannot exist
    without its parent. As soon as the parent actor stops, its child actors are stopped
    by the actor system as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究标准输出，我们发现两个子演员在父演员打印它即将停止的消息后立即输出一个`sayhi`消息。这是Akka演员的正常行为——子演员不能没有父演员而存在。一旦父演员停止，其子演员也会被演员系统停止。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When an actor is stopped, its child actors are also automatically stopped.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个演员停止时，其子演员也会自动停止。
- en: If you ran the preceding example program, you might have noticed that printing
    an actor reference reflects the actor's position in the actor hierarchy. For example,
    printing the child actor reference shows the `akka://OurExampleSystem/user/parent/$a`
    string. The first part of this string, `akka://`, denotes that this reference
    points to a local actor. The `OurExampleSystem` part is the name of the actor
    system that we are using in this example. The `parent/$a` part reflects the name
    of the parent actor and the automatically generated name `$a` of the child actor.
    Unexpectedly, the string representation of the actor reference also contains a
    reference to an intermediate actor, called `user`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了前面的示例程序，你可能已经注意到打印演员引用反映了演员在演员层次结构中的位置。例如，打印子演员引用显示 `akka://OurExampleSystem/user/parent/$a`
    字符串。这个字符串的前一部分，`akka://` 表示这个引用指向一个本地演员。`OurExampleSystem` 部分是我们在这个例子中使用的演员系统名称。`parent/$a`
    部分反映了父演员的名称和子演员自动生成的名称 `$a`。出人意料的是，演员引用的字符串表示还包含对中间演员的引用，称为 `user`。
- en: 'In Akka, an actor that resides at the top of the actor hierarchy is called
    the **guardian actor**, which exists to perform various internal tasks, such as
    logging and restarting user actors. Every top-level actor created in the application
    is placed under the `user` predefined guardian actor. There are other guardian
    actors. For example, actors internally used by the actor system are placed under
    the `system` guardian actor. The actor hierarchy is shown in the following figure,
    where the guardian actors `user` and `system` form two separate hierarchies in
    the actor system called `OurExampleSystem`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Akka 中，位于演员层次结构顶部的演员被称为**守护者演员**，它存在以执行各种内部任务，例如日志记录和重启用户演员。在应用程序中创建的每个顶级演员都被放置在预定义的
    `user` 守护者演员之下。还有其他守护者演员。例如，由演员系统内部使用的演员被放置在 `system` 守护者演员之下。演员层次结构在以下图中显示，其中守护者演员
    `user` 和 `system` 在名为 `OurExampleSystem` 的演员系统中形成两个独立的层次结构：
- en: '![Akka actor hierarchy](img/image_08_003.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Akka演员层次结构](img/image_08_003.jpg)'
- en: In this section, we saw that Akka actors form a hierarchy, and learned about
    the relationships between actors in this hierarchy. Importantly, we learned how
    to refer to immediate neighbors of an actor using the `parent` and `children`
    methods of the `context` object. In the following section, we will see how to
    refer to an arbitrary actor within the same actor system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到 Akka 演员形成一个层次结构，并了解了该层次结构中演员之间的关系。重要的是，我们学习了如何使用 `context` 对象的 `parent`
    和 `children` 方法来引用演员的邻近演员。在下一节中，我们将看到如何引用同一演员系统内的任意演员。
- en: Identifying actors
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别演员
- en: In the previous section, we learned that actors are organized in a hierarchical
    tree, in which every actor has a parent and some number of children. Thus, every
    actor lies on a unique path from the root of this hierarchy, and can be assigned
    a unique sequence of actor names on this path. The `parent` actor was directly
    beneath the `user` guardian actor, so its unique sequence of actor names is `/user/parent`.
    Similarly, the unique sequence of actor names for the `parent` actor's child actor
    is `$a` is `/user/parent/$a`. An **actor path** is a concatenation of the protocol,
    the actor system name, and the actor names on the path from the top guardian actor
    to a specific actor. The actor path of the `parent` actor from the previous example
    is `akka://OurExampleSystem/user/parent`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到演员被组织成一个层次树，其中每个演员都有一个父演员和一些子演员。因此，每个演员都位于从层次结构根节点到该演员的唯一路径上，并且可以在该路径上分配一个唯一的演员名称序列。`parent`
    演员直接位于 `user` 守护者演员之下，因此其唯一的演员名称序列是 `/user/parent`。同样，`parent` 演员的子演员的唯一演员名称序列是
    `$a` 是 `/user/parent/$a`。**演员路径**是协议、演员系统名称以及从顶级守护者演员到特定演员的路径上演员名称的连接。上一个例子中 `parent`
    演员的演员路径是 `akka://OurExampleSystem/user/parent`。
- en: Actor paths closely correspond to file paths in a filesystem. Every file path
    uniquely designates a file location, just as an actor path uniquely designates
    the location of the actor in the hierarchy. Just as a file path in a filesystem
    does not mean that a file exists, an actor path does not imply that there is an
    actor on that file path in the actor system. Instead, an actor path is an identifier
    used to obtain an actor reference if one exists. Also, parts of the names in the
    actor path can be replaced with wildcards and the `..` symbol, similar to how
    parts of filenames can be replaced in a shell. In this case, we obtain a **path
    selection**. For example, the path selection `..` references the parent of the
    current actor. The selection `../*` references the current actor and all its siblings.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 演员路径与文件系统中的文件路径紧密对应。每个文件路径唯一指定了一个文件位置，就像演员路径唯一指定了演员在层次结构中的位置一样。就像文件系统中的文件路径并不意味着文件存在一样，演员路径也不意味着在演员系统中该文件路径上存在演员。相反，演员路径是一个标识符，用于在存在的情况下获取演员引用。此外，演员路径中的名称部分可以用通配符和
    `..` 符号替换，类似于在shell中替换文件名部分。在这种情况下，我们获得一个**路径选择**。例如，路径选择 `..` 引用当前演员的父级。选择 `../*`
    引用当前演员及其所有兄弟。
- en: Actor paths are different from actor references; we cannot send a message to
    an actor using its actor path. Instead, we must first use the actor path to identify
    an actor on that actor path. If we successfully find an actor reference behind
    an actor path, we can send messages to it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 演员路径与演员引用不同；我们不能使用演员路径向演员发送消息。相反，我们必须首先使用演员路径在该路径上识别一个演员。如果我们成功找到演员路径后面的演员引用，我们就可以向其发送消息。
- en: To obtain an actor reference corresponding to an actor path, we call the `actorSelection`
    method on the context object of an actor. This method takes an actor path, or
    a path selection. Calling the `actorSelection` method might address zero actors
    if no actors correspond to the actor path. Similarly, it might address multiple
    actors if we use a path selection. Thus, instead of returning an `ActorRef` object,
    the `actorSelection` method returns an `ActorSelection` object, which might represent
    zero, one, or more actors. We can use the `ActorSelection` object to send messages
    to these actors.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与演员路径对应的演员引用，我们调用演员的上下文对象上的 `actorSelection` 方法。此方法接受一个演员路径或路径选择。调用 `actorSelection`
    方法可能不会针对任何演员，如果没有演员与演员路径相对应。同样，如果使用路径选择，它可能针对多个演员。因此，而不是返回一个 `ActorRef` 对象，`actorSelection`
    方法返回一个 `ActorSelection` 对象，该对象可能代表零、一个或多个演员。我们可以使用 `ActorSelection` 对象向这些演员发送消息。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `actorSelection` method on the `context` object to communicate with
    arbitrary actors in the actor system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `context` 对象上的 `actorSelection` 方法与演员系统中的任意演员进行通信。
- en: If we compare the `ActorRef` object to a specific e-mail address, an `ActorSelection`
    object can be compared to a mailing list address. Sending an e-mail to a valid
    e-mail address ensures that the e-mail reaches a specific person. On the other
    hand, when we send an e-mail to a mailing list, the e-mail might reach zero, one,
    or more people, depending on the number of mailing list subscribers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `ActorRef` 对象与特定的电子邮件地址进行比较，那么 `ActorSelection` 对象可以与邮件列表地址进行比较。向有效的电子邮件地址发送电子邮件可以确保电子邮件到达特定的人。另一方面，当我们向邮件列表发送电子邮件时，电子邮件可能会到达零、一个或多个订阅者，具体取决于邮件列表订阅者的数量。
- en: An `ActorSelection` object does not tell us anything about the concrete paths
    of the actors, in a similar way to how a mailing list does not tell us anything
    about its subscribers. For this purpose, Akka defines a special type of message
    called `Identify`. When an Akka actor receives an `Identify` message, it will
    automatically reply by sending back an `ActorIdentity` message with its `ActorRef`
    object. If there are no actors in the actor selection, the `ActorIdentity` message
    is sent back to the sender of `Identify` without an `ActorRef` object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与邮件列表不告诉我们其订阅者信息的方式类似，`ActorSelection` 对象也不会告诉我们演员的具体路径。为此，Akka 定义了一种特殊类型的消息，称为
    `Identify`。当一个 Akka 演员收到 `Identify` 消息时，它将自动回复，发送一个包含其 `ActorRef` 对象的 `ActorIdentity`
    消息。如果没有演员在演员选择中，则 `ActorIdentity` 消息将不带 `ActorRef` 对象发送回 `Identify` 的发送者。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Send `Identify` messages to the `ActorSelection` objects to obtain actor references
    of arbitrary actors in the actor system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `ActorSelection` 对象发送 `Identify` 消息以获取演员系统中任意演员的演员引用。
- en: 'In the following example, we define a `CheckActor` actor class, which describes
    actors that check and print actor references whenever they receive a message with
    an actor path. When the actor of type `CheckActor` receives a string with an actor
    path or a path selection, it obtains an `ActorSelection` object and sends it an
    `Identify` message. This message is forwarded to all actors in the selection,
    which then respond with an `ActorIdentity` message. The `Identify` message also
    takes a `messageId` argument. If an actor sends out multiple `Identify` messages,
    the `messageId` argument allows disambiguating between the different `ActorIdentity`
    responses. In our example, we use the `path` string as the `messageId` argument.
    When `CheckActor` receives an `ActorIdentity` message, it either prints the actor
    reference or reports that there is no actor on the specified path. The `CheckActor`
    class is shown in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了一个 `CheckActor` 角色类，它描述了在接收到带有角色路径的消息时检查并打印角色引用的角色。当 `CheckActor`
    类型的角色接收到一个带有角色路径的字符串或路径选择时，它获取一个 `ActorSelection` 对象并发送一个 `Identify` 消息。此消息被转发到选择中的所有角色，然后它们响应一个
    `ActorIdentity` 消息。`Identify` 消息还带有一个 `messageId` 参数。如果一个角色发送多个 `Identify` 消息，`messageId`
    参数允许区分不同的 `ActorIdentity` 响应。在我们的示例中，我们使用 `path` 字符串作为 `messageId` 参数。当 `CheckActor`
    接收到一个 `ActorIdentity` 消息时，它会打印角色引用或者报告在指定路径上没有找到角色。`CheckActor` 类在下面的代码片段中显示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we instantiate a `checker` actor of the `CheckActor` class, and send
    it the path selection, `../*`. This references all the child actors of the `checker`
    parent-the `checker` actor itself and its siblings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化了一个 `CheckActor` 类的 `checker` 角色并给它发送了路径选择，`../*`。这引用了 `checker` 父角色的所有子角色——`checker`
    角色本身及其兄弟角色：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We did not instantiate any top-level actors besides the `checker` actor, so
    checker receives only a single `ActorIdentity` message and prints its own actor
    path. Next, we try to identify all the actors one level above the `checker` actor.
    Recall the earlier figure. Since `checker` is a top-level actor, this should identify
    the guardian actors in the actor system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `checker` 角色之外，我们没有实例化任何顶级角色，所以 `checker` 只接收到一个 `ActorIdentity` 消息并打印出其自身的角色路径。接下来，我们尝试识别
    `checker` 角色上方的所有角色。回想一下之前的图示。由于 `checker` 是一个顶级角色，这应该会识别出角色系统中的守护者角色：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As expected, the `checker` actor prints the actor paths of the `user` and `system`
    guardian actors. We are curious to learn more about the system-internal actors
    from the `system` guardian actor. This time, we send an absolute path selection
    to `checker`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`checker` 角色打印了 `user` 和 `system` 守护者角色的角色路径。我们很想知道从 `system` 守护者角色那里了解更多关于系统内部角色的信息。这次，我们向
    `checker` 发送了一个绝对路径选择：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `checker` actor prints the actor paths of the internal actors `log1-Logging`
    and `deadLetterListener`, which are used for logging and for processing unhandled
    messages, respectively. We next try identifying a non-existing actor:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`checker` 角色打印了内部角色 `log1-Logging` 和 `deadLetterListener` 的角色路径，分别用于日志记录和处理未处理的消息。接下来，我们尝试识别一个不存在的角色：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are no actors named `checker2`, so `checker` receives an `ActorIdentity`
    message with the `ref` field set to `None` and prints that it cannot find an actor
    on that path.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有名为 `checker2` 的角色，所以 `checker` 接收到一个 `ActorIdentity` 消息，其中 `ref` 字段设置为 `None`，并打印出它无法在该路径上找到角色。
- en: Using the `actorSelection` method and the `Identify` message is the fundamental
    method for discovering unknown actors in the same actor system. Note that we will
    always obtain an actor reference, and never obtain a pointer to the actor object
    directly. To better understand the reasons for this, we will study the lifecycle
    of actors in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `actorSelection` 方法和 `Identify` 消息是发现同一角色系统中的未知角色的基本方法。请注意，我们总是会获得一个角色引用，而永远不会直接获得角色对象的指针。为了更好地理解这样做的原因，我们将在下一节研究角色的生命周期。
- en: The actor lifecycle
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色生命周期
- en: Recall that the `ChildActor` class from the previous section overrode the `postStop`
    method to produce some logging output when the actor is stopped. In this section,
    we investigate when exactly the `postStop` method gets called, along with the
    other important events that comprise the lifecycle of the actor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在上一节中，`ChildActor` 类覆盖了 `postStop` 方法，在角色停止时产生一些日志输出。在本节中，我们将研究 `postStop`
    方法何时被调用，以及其他构成角色生命周期的其他重要事件。
- en: To understand why the actor lifecycle is important, we consider what happens
    if an actor throws an exception while processing an incoming message. In Akka,
    such an exception is considered abnormal behavior, so top-level user actors that
    throw an exception are by default restarted. Restarting creates a fresh actor
    object, and effectively means that the actor state is reinitialized. When an actor
    is restarted, its actor reference and actor path remain the same. Thus, the same
    `ActorRef` object might refer to many different physical actor objects during
    the logical existence of the same actor. This is one of the reasons why an actor
    must never allow its `this` reference to leak. Doing so allows other parts of
    the program to refer to an old actor object, consequently invalidating the transparency
    of the actor reference. Additionally, revealing the `this` reference of the actor
    can reveal the internals of the actor implementation, or even cause data corruption.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解演员生命周期的重要性，我们考虑如果演员在处理传入消息时抛出异常会发生什么。在Akka中，这样的异常被视为异常行为，因此默认情况下，抛出异常的顶级用户演员会被重启。重启创建了一个新的演员对象，实际上意味着演员状态被重新初始化。当演员重启时，其演员引用和演员路径保持不变。因此，同一个逻辑演员在存在期间可能对应多个不同的物理演员对象。这是演员永远不允许其`this`引用泄漏的原因之一。这样做允许程序的其它部分引用旧的演员对象，从而破坏演员引用的透明性。此外，泄露演员的`this`引用可能会暴露演员实现的内部细节，甚至导致数据损坏。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never pass an actor's `this` reference to other actors, as it breaks actor encapsulation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将演员的`this`引用传递给其他演员，因为这会破坏演员封装。
- en: Let's examine the complete actor lifecycle. As we have learned, a logical actor
    instance is created when we call the `actorOf` method. The `Props` object is used
    to instantiate a physical actor object. This object is assigned a mailbox, and
    can start receiving input messages. The `actorOf` method returns an actor reference
    to the caller, and the actors can execute concurrently. Before the actor starts
    processing messages, its `preStart` method is called. The `preStart` method is
    used to initialize the logical actor instance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查完整的演员生命周期。正如我们所学的，当我们调用`actorOf`方法时，会创建一个逻辑演员实例。`Props`对象用于实例化一个物理演员对象。该对象被分配一个邮箱，并可以开始接收输入消息。`actorOf`方法返回一个演员引用给调用者，演员可以并发执行。在演员开始处理消息之前，会调用其`preStart`方法。`preStart`方法用于初始化逻辑演员实例。
- en: After creation, the actor starts processing messages. At some point, an actor
    might need to be restarted due to an exception. When this happens, the `preRestart`
    method is first called. All the child actors are then stopped. Then, the `Props`
    object, previously used in order to create the actor with the `actorOf` method,
    is reused to create a new actor object. The `postRestart` method is called on
    the newly created actor object. After `postRestart` returns, the new actor object
    is assigned the same mailbox as the old actor object, and it continues to process
    messages that were in the mailbox before the restart.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，演员开始处理消息。在某个时刻，由于异常，演员可能需要重启。当这种情况发生时，首先调用`preRestart`方法。然后停止所有子演员。接着，之前用于通过`actorOf`方法创建演员的`Props`对象被重新使用来创建一个新的演员对象。在新创建的演员对象上调用`postRestart`方法。`postRestart`返回后，新的演员对象被分配与旧演员对象相同的邮箱，并继续处理重启前邮箱中的消息。
- en: By default, the `postRestart` method calls the `prestart` method. In some cases,
    we want to override this behavior. For example, a database connection might need
    to be opened only once during `preStart`, and closed when the logical actor instance
    is terminated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`postRestart`方法会调用`prestart`方法。在某些情况下，我们可能想要覆盖这种行为。例如，数据库连接可能需要在`preStart`期间只打开一次，并在逻辑演员实例终止时关闭。
- en: 'Once the logical actor instance needs to stop, the `postStop` method gets called.
    The actor path associated with the actor is released, and returned to the actor
    system. By default, the `preRestart` method calls the `postStop` method. The complete
    actor lifecycle is illustrated in the following figure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦逻辑演员实例需要停止，就会调用`postStop`方法。与演员关联的演员路径被释放，并返回给演员系统。默认情况下，`preRestart`方法会调用`postStop`方法。完整的演员生命周期在以下图中展示：
- en: '![The actor lifecycle](img/image_08_004.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![演员生命周期](img/image_08_004.jpg)'
- en: Note that, during the actor lifecycle, the rest of the actor system observes
    the same actor reference, regardless of how many times the actor restarts. Actor
    failures and restarts occur transparently for the rest of the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在actor的生命周期中，actor系统的其余部分观察到的actor引用是相同的，无论actor重启多少次。actor的失败和重启对系统的其余部分来说是透明的。
- en: 'To experiment with the lifecycle of an actor, we declare two actor classes,
    `StringPrinter` and `LifecycleActor`. The `StringPrinter` actor prints a logging
    statement for each message that it receives. We override its `preStart` and `postStop`
    methods to precisely track when the actor has started and stopped, as shown in
    the following snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验actor的生命周期，我们声明了两个actor类，`StringPrinter`和`LifecycleActor`。`StringPrinter`actor为它接收到的每个消息打印一个日志语句。我们重写它的`preStart`和`postStop`方法，以精确跟踪actor何时启动和停止，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `LifecycleActor` class maintains a `child` actor reference to a `StringPrinter`
    actor. The `LifecycleActor` class reacts to the `Double` and `Int` messages by
    printing them, and to the `List` messages by printing the first element of the
    list. When it receives a `String` message, the `LifecycleActor` instance forwards
    it to the `child` actor:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`LifecycleActor`类维护一个指向`StringPrinter`actor的`child`actor引用。`LifecycleActor`类通过打印消息来响应`Double`和`Int`消息，并通过打印列表的第一个元素来响应`List`消息。当它接收到一个`String`消息时，`LifecycleActor`实例将其转发到`child`actor：'
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We now override different lifecycle hooks. We start with the `preStart` method
    to output a logging statement and instantiate the `child` actor. This ensures
    that the `child` reference is initialized before the actor starts processing any
    messages:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重写不同的生命周期钩子。我们首先从`preStart`方法开始，输出一个日志语句并实例化`child`actor。这确保了在actor开始处理任何消息之前，`child`引用已经被初始化：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we override the `preRestart` and `postRestart` methods. In the `preRestart`
    and `postRestart` methods, we log the exception that caused the failure. The `postRestart`
    method calls the `preStart` method by default, so the new actor object gets initialized
    with a new `child` actor after a restart:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重写`preRestart`和`postRestart`方法。在`preRestart`和`postRestart`方法中，我们记录导致失败的异常。默认情况下，`postRestart`方法会调用`preStart`方法，因此重启后新的actor对象会初始化一个新的`child`actor：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we override the `postStop` method to track when the actor is stopped:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写`postStop`方法以跟踪actor何时停止：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now create an instance of the `LifecycleActor` class called `testy`, and
    send a `math.Pi` message to it. The actor prints that it is about to start in
    its `preStart` method, and creates a new `child` actor. It then prints that it
    received the value `math.Pi`. Importantly, the `child about to start` logging
    statement is printed after the `math.Pi` message is received. This shows that
    actor creation is an asynchronous operation-when we call `actorOf`, creating the
    actor is delegated to the actor system, and the program immediately proceeds:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建了一个名为`testy`的`LifecycleActor`类实例，并向它发送一个`math.Pi`消息。actor在其`preStart`方法中打印出它即将启动，并创建一个新的`child`actor。然后它打印出它接收到了`math.Pi`的值。重要的是，在接收到`math.Pi`消息之后，打印出`child
    about to start`的日志语句。这表明actor的创建是一个异步操作——当我们调用`actorOf`时，创建actor的任务被委托给了actor系统，程序立即继续执行：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then send a string message to `testy`. The message is forwarded to the `child`
    actor, which prints a logging statement, indicating that it received the message:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们向`testy`发送一个字符串消息。消息被转发到`child`actor，它打印出一个日志语句，表明它接收到了消息：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we send a `Nil` message to `testy`. The `Nil` object represents an
    empty list, so `testy` throws an exception when attempting to fetch the `head`
    element. It reports that it needs to restart. After that, we witness that the
    `child` actor prints the message that it needs to stop; recall that the child
    actors are stopped when an actor is restarted. Finally, `testy` prints that it
    is about to restart, and the new `child` actor is instantiated. These events are
    caused by the following statement:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向`testy`发送一个`Nil`消息。`Nil`对象代表一个空列表，因此当尝试获取`head`元素时，`testy`会抛出一个异常。它报告说需要重启。之后，我们看到`child`actor打印出它需要停止的消息；回想一下，当actor重启时，child
    actors会被停止。最后，`testy`打印出它即将重启，并且一个新的`child`actor被实例化。这些事件是由以下语句引起的：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Testing the actor lifecycle revealed an important property of the `actorOf`
    method. When we call the `actorOf` method, the execution proceeds without waiting
    for the actor to fully initialize itself. Similarly, sending a message does not
    block execution until the message is received or processed by another actor; we
    say that message sends are asynchronous. In the following section, we will examine
    various communication patterns that address this asynchronous behavior.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 测试演员生命周期揭示了`actorOf`方法的一个重要特性。当我们调用`actorOf`方法时，执行会继续进行，而无需等待演员完全初始化。同样，发送消息不会阻塞执行，直到消息被接收或由另一个演员处理；我们说消息发送是非同步的。在下一节中，我们将检查解决这种异步行为的各种通信模式。
- en: Communication between actors
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员之间的通信
- en: We have learned that actors communicate by sending messages. While actors running
    on the same machine can access shared parts of memory in the presence of proper
    synchronization, sending messages allows isolating the actor from the rest of
    the system and ensures location transparency. The fundamental operation that allows
    you to send a message to an actor is the `!` operator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到演员通过发送消息进行通信。虽然运行在同一台机器上的演员在适当的同步下可以访问共享的内存部分，但发送消息允许将演员从系统的其余部分隔离出来，并确保位置透明性。允许你向演员发送消息的基本操作是`!`操作符。
- en: We have learned that the `!` operator is a non-blocking operation-sending a
    message does not block the execution of the sender until the message is delivered.
    This way of sending messages is sometimes called the **fire-and-forget** pattern,
    because it does not wait for a reply from the message receiver, nor does it ensure
    that the message is delivered.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到`!`操作符是一个非阻塞操作——发送消息不会阻塞发送者的执行，直到消息被送达。这种发送消息的方式有时被称为**fire-and-forget**模式，因为它不会等待消息接收者的回复，也不确保消息被送达。
- en: Sending messages in this way improves the throughput of programs built using
    actors, but can be limiting in some situations. For example, we might want to
    send a message and wait for the response from the target. In this section, we
    learn about patterns used in actor communication that go beyond fire-and-forget.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式发送消息可以提高使用演员构建的程序的性能，但在某些情况下可能会有限制。例如，我们可能想要发送消息并等待目标响应。在本节中，我们将了解用于演员通信的超越fire-and-forget模式的模式。
- en: While the fire-and-forget pattern does not guarantee that the message is delivered,
    it guarantees that the message is delivered **at most once**. The target actor
    never receives duplicate messages. Furthermore, the messages are guaranteed to
    be ordered for a given pair of sender and receiver actors. If an actor **A** sends
    messages **X** and **Y** in that order, the actor **B** will receive no duplicate
    messages, only the message **X**, only the message **Y**, or the message **X**,
    followed by the message **Y**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然fire-and-forget模式不能保证消息被送达，但它保证消息最多只被送达一次。目标演员永远不会收到重复的消息。此外，对于给定的发送者和接收者演员对，消息是有序的。如果一个演员**A**按照顺序发送消息**X**和**Y**，演员**B**将不会收到重复的消息，只会收到消息**X**，只有消息**Y**，或者消息**X**，随后是消息**Y**。
- en: 'This is shown on the left in the following figure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中的左侧有所展示：
- en: '![Communication between actors](img/image_08_005.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![演员之间的通信](img/image_08_005.jpg)'
- en: 'However, the delivery order is not ensured for a group of three or more actors.
    For example, as shown on the right in the preceding figure, actor **A** performs
    the following actions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于三个或更多演员的组，不能保证交付顺序。例如，如图中右侧所示，演员**A**执行以下操作：
- en: Sends a message **X** to the actor **B**
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向演员**B**发送消息**X**
- en: Sends a message **Y** to another actor, **C**
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向另一个演员，**C**发送消息**Y**
- en: Actor **C** sends a message **Z** to the actor **B** after having received **Y**
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员**C**在收到**Y**后向演员**B**发送消息**Z**
- en: In this situation, the delivery order between messages **X** and **Z** is not
    guaranteed. The actor **B** might receive the messages **X** and **Z** in any
    order. This property reflects the characteristics of most computer networks, and
    is adopted to allow actors to run transparently on network nodes that may be remote.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息**X**和**Z**之间的交付顺序不能保证。演员**B**可能会以任何顺序收到消息**X**和**Z**。这一特性反映了大多数计算机网络的特点，并被采用以允许演员在可能远程的网络节点上透明地运行。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The order in which an actor **B** receives messages from an actor **A** is the
    same as the order in which these messages are sent from the actor **A**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: actor **B** 从actor **A** 接收消息的顺序与这些消息从actor **A** 发送的顺序相同。
- en: Before we study various patterns of actor communication, note that the `!` operator
    was not the only non-blocking operation. The methods `actorOf` and `actorSelection`
    are also non-blocking. These methods are often called while an actor is processing
    a message. Blocking the actor while the message is processed prevents the actor
    from processing subsequent messages in the mailbox and severely compromises the
    throughput of the system. For these reasons, most of the actor API is non-blocking.
    Additionally, we must never start blocking the operations from third-party libraries
    from within an actor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究actor通信的各种模式之前，请注意，`!`操作符并不是唯一的不阻塞操作。`actorOf`和`actorSelection`方法也是不阻塞的。这些方法通常在actor处理消息时被调用。在处理消息时阻塞actor会阻止actor处理邮箱中的后续消息，并严重降低系统的吞吐量。因此，大多数actor
    API都是非阻塞的。此外，我们绝不能在actor内部开始阻塞第三方库的操作。
- en: Tip
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Messages must be handled without blocking indefinitely. Never start an infinite
    loop and avoid long-running computations in the `receive` block, the `unhandled`
    method, and within actor lifecycle hooks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 消息必须在非阻塞的情况下处理。永远不要启动无限循环，并避免在`receive`块、`unhandled`方法以及actor生命周期钩子中进行长时间运行的计算。
- en: The ask pattern
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ask模式
- en: Not being able to block from within an actor prevents the request-respond communication
    pattern. In this pattern, an actor interested in certain information sends a request
    message to another actor. It then needs to wait for a response message from the
    other actor. In Akka, this communication pattern is also known as the *ask pattern*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在actor内部阻塞阻止了请求-响应通信模式。在这种模式中，对某些信息感兴趣的actor向另一个actor发送请求消息。然后它需要等待来自另一个actor的响应消息。在Akka中，这种通信模式也称为*ask模式*。
- en: The `akka.pattern` package defines the use of convenience methods in actor communication.
    Importing its contents allows us to call the `?` operator (pronounced ask) on
    actor references. This operator sends a message to the target actor, such as the
    tell operator. Additionally, the ask operator returns a future object with the
    response from the target actor.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`akka.pattern` 包定义了在actor通信中使用便利方法。导入其内容允许我们在actor引用上调用`?`操作符（发音为ask）。此操作符向目标actor发送消息，例如tell操作符。此外，ask操作符返回一个包含目标actor响应的未来对象。'
- en: 'To illustrate the usage of the ask pattern, we will define two actors that
    play ping pong with each other. A `Pingy` actor will send a `ping` request message
    to another actor, of type `Pongy`. When the `Pongy` actor receives the `ping`
    message, it sends a `pong` response message to the sender. We start by importing
    the `akka.pattern` package:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明ask模式的使用，我们将定义两个actor，它们相互进行乒乓球游戏。一个`Pingy` actor将向另一个actor发送`ping`请求消息，该actor的类型为`Pongy`。当`Pongy`
    actor收到`ping`消息时，它向发送者发送`pong`响应消息。我们首先导入`akka.pattern`包：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We first define the `Pongy` actor class. To respond to the `ping` incoming
    message, the `Pongy` actor needs an actor reference of the sender. While processing
    a message, every actor can call the `sender` method of the `Actor` class to obtain
    the actor reference of the sender of the current message. The `Pongy` actor uses
    the `sender` method to send `ping` back to the `Pingy` actor. The `Pongy` implementation
    is shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`Pongy` actor类。为了响应`ping`传入的消息，`Pongy` actor需要一个发送者的actor引用。在处理消息时，每个actor都可以调用`Actor`类的`sender`方法来获取当前消息发送者的actor引用。`Pongy`
    actor使用`sender`方法向`Pingy` actor发送`ping`。`Pongy`的实现如下代码片段：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we define the `Pingy` actor class, which uses the ask operator to send
    a request to the `Pongy` actor. When the `Pingy` class receives a `pongyRef` actor
    reference of `Pongy`, it creates an implicit `Timeout` object set to two seconds.
    Using the ask operator requires an implicit `Timeout` object in scope; the future
    is failed with an `AskTimeoutException` exception if the response message does
    not arrive within the given timeframe. Once `Pingy` class sends the `ping` message,
    it is left with an `f` future object. The `Pingy` actor uses the special `pipeTo`
    combinator that sends the value in the future to the sender of the `pongyRef`
    actor reference, as shown in the following code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `Pingy` 角色类，它使用询问操作符向 `Pongy` 角色发送请求。当 `Pingy` 类接收到 `Pongy` 的 `pongyRef`
    角色引用时，它创建一个设置为两秒的隐式 `Timeout` 对象。使用询问操作符需要一个作用域内的隐式 `Timeout` 对象；如果响应消息在给定时间内没有到达，未来将因
    `AskTimeoutException` 异常而失败。一旦 `Pingy` 类发送了 `ping` 消息，它将留下一个 `f` 未来对象。`Pingy`
    角色使用特殊的 `pipeTo` 组合子，将未来中的值发送到 `pongyRef` 角色引用的发送者，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The message in the future object can be manipulated using the standard future
    combinators seen in [Chapter 4](ch04.html "Chapter 4.  Asynchronous Programming
    with Futures and Promises"), *Asynchronous Programming with Futures and Promises*.
    However, the following definition of the `Pingy` actor would not be correct:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的对象中的消息可以使用在 [第4章](ch04.html "第4章。使用未来和承诺进行异步编程") 中看到的标准未来组合子进行操作，*使用未来和承诺进行异步编程*。然而，以下对
    `Pingy` 角色的定义是不正确的：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although it is perfectly legal to call the `onComplete` on the `f` future, the
    subsequent asynchronous computation should not access any mutable actor state.
    Recall that the actor state should be visible only to the actor, so concurrently
    accessing it opens the possibility of data races and race conditions. The `log`
    object should only be accessed by the actor that owns it. Similarly, we should
    not call the `sender` method from within the `onComplete` handler. By the time
    the future is completed with the response message, the actor might be processing
    a different message with a different sender, so the `sender` method can return
    arbitrary values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `f` 未来上调用 `onComplete` 是完全合法的，但后续的异步计算不应访问任何可变角色状态。回想一下，角色状态应该只对角色可见，所以并发访问它可能会打开数据竞争和竞争条件。`log`
    对象应由拥有它的角色访问。同样，我们不应在 `onComplete` 处理程序中调用 `sender` 方法。当未来完成并带有响应消息时，角色可能正在处理来自不同发送者的不同消息，因此
    `sender` 方法可以返回任意值。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When starting an asynchronous computation from within the `receive` block, the
    `unhandled` method, or a lifecycle hook, never let the closure capture any mutable
    actor state.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `receive` 块内启动异步计算时，`unhandled` 方法或生命周期钩子永远不要让闭包捕获任何可变角色状态。
- en: 'To test `Pingy` and `Pongy` in action, we define the `Master` actor class that
    instantiates them. Upon receiving the `start` message, the `Master` actor passes
    the `pongy` reference to the `pingy` reference. Once the `pingy` actor returns
    a `pong` message from `pongy`, the `Master` actor stops. This is shown in the
    following `Master` actor template:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `Pingy` 和 `Pongy` 的实际运行情况，我们定义了一个 `Master` 角色类来实例化它们。在接收到 `start` 消息后，`Master`
    角色将 `pongy` 引用传递给 `pingy` 引用。一旦 `pingy` 角色从 `pongy` 返回一个 `pong` 消息，`Master` 角色就会停止。这可以通过以下
    `Master` 角色模板展示：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The ask pattern is useful because it allows you to send requests to multiple
    actors and obtain futures with their responses. Values from multiple futures can
    be combined within `for` comprehensions to compute a value from several responses.
    Using the fire-and-forget pattern when communicating with multiple actors requires
    changing the actor behavior, and is a lot more cumbersome than the ask pattern.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 询问模式很有用，因为它允许你向多个角色发送请求并获取它们的响应的未来。多个未来的值可以在 `for` 推导式中组合，以从多个响应中计算出一个值。在与多个角色通信时使用“发射并遗忘”模式需要更改角色行为，并且比询问模式复杂得多。
- en: The forward pattern
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向模式
- en: Some actors exist solely to forward messages to other actors. For example, an
    actor might be responsible for load-balancing request messages between several
    worker actors, or it might forward the message to its mirror actor to ensure better
    availability. In such cases, it is useful to forward the message without changing
    the `sender` field of the message. The `forward` method on actor references serves
    this purpose.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 actor 仅用于将消息转发到其他 actor。例如，一个 actor 可能负责在几个工作 actor 之间进行负载均衡请求消息，或者它可能将消息转发到其镜像
    actor 以确保更好的可用性。在这种情况下，在不更改消息的 `sender` 字段的情况下转发消息是有用的。actor 引用上的 `forward` 方法就为此目的服务。
- en: 'In the following code, we use the `StringPrinter` actor from the previous section
    to define a `Router` actor class. A `Router` actor instantiates four child `StringPrinter`
    actors and maintains an `i` field with the index of the list child it forwarded
    the message to. Whenever it receives a message, it forwards the message to a different
    `StringPrinter` child before incrementing the `i` field:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用上一节中的 `StringPrinter` actor 来定义一个 `Router` actor 类。一个 `Router` actor
    实例化了四个子 `StringPrinter` actor 并维护一个 `i` 字段，该字段表示它将消息转发到列表子项的索引。每当它收到一个消息时，它都会在增加
    `i` 字段之前将消息转发到一个不同的 `StringPrinter` 子 actor：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the following code, we create a `Router` actor and test it by sending it
    two messages. We can observe that the messages are printed to the standard output
    by two different `StringPrinter` actors, denoted with actors on the actor paths
    `/user/router/$b` and `/user/router/$a`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们创建了一个 `Router` actor 并通过发送两个消息来测试它。我们可以观察到，消息被两个不同的 `StringPrinter`
    actor 打印到标准输出，这些 actor 在 actor 路径上分别表示为 `/user/router/$b` 和 `/user/router/$a`：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The forward pattern is typically used in router actors, which use specific knowledge
    to decide about the destination of the message; replicator actors, which send
    the message to multiple destinations; or load balancers, which ensure that the
    workload is spread evenly between a set of worker actors.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前转模式通常用于路由 actor，这些 actor 使用特定的知识来决定消息的目的地；复制 actor，这些 actor 将消息发送到多个目的地；或者负载均衡器，这些确保工作负载在一系列工作
    actor 之间均匀分布。
- en: Stopping actors
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止 actor
- en: So far, we have stopped different actors by making them call `context.stop`.
    Calling the `stop` method on the `context` object terminates the actor immediately
    after the current message is processed. In some cases, we want to have more control
    over how an actor gets terminated. For example, we might want to allow the actor
    to process its remaining messages or wait for the termination of some other actors.
    In Akka, there are several special message types that assist us in doing so, and
    we study them in this section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过让它们调用 `context.stop` 来停止不同的 actor。在 `context` 对象上调用 `stop` 方法会在处理完当前消息后立即终止
    actor。在某些情况下，我们可能希望对 actor 的终止有更多的控制。例如，我们可能希望允许 actor 处理其剩余的消息或等待其他 actor 的终止。在
    Akka 中，有一些特殊的消息类型可以帮助我们做到这一点，我们将在本节中研究它们。
- en: In many cases, we do not want to terminate an actor instance, but simply restart
    it. We have previously learned that an actor is automatically restarted when it
    throws an exception. An actor is also restarted when it receives the `Kill` message-when
    we send a `Kill` message to an actor, the actor automatically throws an `ActorKilledException`
    and fails.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们不想终止 actor 实例，而只是重新启动它。我们之前已经了解到，当 actor 抛出异常时，actor 会自动重启。当 actor
    接收到 `Kill` 消息时，actor 也会重启——当我们向 actor 发送 `Kill` 消息时，actor 会自动抛出 `ActorKilledException`
    并失败。
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `Kill` message to restart the target actor without losing the messages
    in the mailbox.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Kill` 消息来重新启动目标 actor，而不会丢失邮箱中的消息。
- en: Unlike the `stop` method, the `Kill` message does not terminate the actor, but
    only restarts it. In some cases, we want to terminate the actor instance, but
    allow it to process the messages from its mailbox. Sending a `PoisonPill` message
    to an actor has the same effect as calling `stop`, but allows the actor to process
    the messages that were in the mailbox before the `PoisonPill` message arrives.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `stop` 方法不同，`Kill` 消息不会终止 actor，而只是重新启动它。在某些情况下，我们可能想要终止 actor 实例，但允许它处理其邮箱中的消息。向
    actor 发送 `PoisonPill` 消息的效果与调用 `stop` 相同，但允许 actor 处理在 `PoisonPill` 消息到达之前邮箱中的消息。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the `PoisonPill` message to stop the actor, but allow it to process the
    messages received before the `PoisonPill` message.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PoisonPill` 消息来停止 actor，但允许它在接收到 `PoisonPill` 消息之前处理收到的消息。
- en: In some cases, allowing the actor to process its message using `PoisonPill`
    is not enough. An actor might have to wait for other actors to terminate before
    terminating itself. An orderly shutdown is important in some cases, as actors
    might be involved in sensitive operations, such as writing to a file on the disk.
    We do not want to forcefully stop them when we end the application. A facility
    that allows an actor to track the termination of other actors is called **DeathWatch**
    in Akka.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，仅允许演员使用`PoisonPill`来处理其消息是不够的。一个演员可能必须等待其他演员终止后才能终止自身。在某些情况下，有序关闭很重要，因为演员可能参与敏感操作，例如在磁盘上写入文件。我们不希望在结束应用程序时强制停止它们。允许演员跟踪其他演员终止的设施在Akka中被称为**DeathWatch**。
- en: Recall the earlier example with the `Pingy` and `Pongy` actors. Let's say that
    we want to terminate the `Pingy` actor, but only after the `Pongy` actor has already
    been terminated. We define a new `GracefulPingy` actor class for this purpose.
    The `GracefulPingy` actor class calls the `watch` method on the `context` object
    when it gets created. This ensures that, after `Pongy` actor terminates and its
    `postStop` method completes, `GracefulPingy` actor receives a `Terminated` message
    with the actor reference to `Pongy` actor.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前关于`Pingy`和`Pongy`演员的例子。假设我们想要终止`Pingy`演员，但只有在`Pongy`演员已经被终止之后。为此，我们定义了一个新的`GracefulPingy`演员类。当`GracefulPingy`演员被创建时，它会调用`context`对象的`watch`方法。这确保了在`Pongy`演员终止并完成其`postStop`方法之后，`GracefulPingy`演员会收到一个带有`Pongy`演员引用的`Terminated`消息。
- en: 'Upon receiving the `Terminated` message, `GracefulPingy` stops itself, as shown
    in the following `GracefulPingy` implementation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到`Terminated`消息后，`GracefulPingy`演员会停止自身，如下面的`GracefulPingy`实现所示：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whenever we want to track the termination of an actor from inside an actor,
    we use DeathWatch, as in the previous example. When we need to wait for the termination
    of an actor from outside an actor, we use the *graceful stop pattern*. The `gracefulStop`
    method from the `akka.pattern` package takes an actor reference, a timeout, and
    a shutdown message. It returns a future and asynchronously sends the shutdown
    message to the actor. If the actor terminates within the allotted timeout, the
    future is successfully completed. Otherwise, the future fails.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要在演员内部跟踪一个演员的终止时，我们使用DeathWatch，就像之前的例子一样。当我们需要从演员外部等待一个演员的终止时，我们使用优雅的停止模式。`akka.pattern`包中的`gracefulStop`方法接受一个演员引用、一个超时时间和一个关闭消息。它返回一个future，并异步地向演员发送关闭消息。如果演员在分配的超时时间内终止，future将成功完成。否则，future将失败。
- en: 'In the following code, we create a `GracefulPingy` actor instance and call
    the `gracefulStop` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们创建了一个`GracefulPingy`演员实例并调用了`gracefulStop`方法：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We typically use DeathWatch inside the actors, and the graceful stop pattern
    in the main application thread. The graceful stop pattern can be used within actors
    as well, as long as we are careful that the callbacks on the future returned by
    the `gracefulStop` method do not capture actor state. Together, DeathWatch and
    the graceful stop pattern allow safely shutting down actor-based programs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常在演员内部使用DeathWatch，并在主应用程序线程中使用优雅的停止模式。只要我们小心确保`gracefulStop`方法返回的future上的回调没有捕获演员状态，优雅的停止模式也可以在演员内部使用。DeathWatch和优雅的停止模式共同允许安全地关闭基于演员的程序。
- en: Actor supervision
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员监督
- en: 'When studying the actor lifecycle, we said that top-level user actors are by
    default restarted when an exception occurs. We now take a closer inspection at
    how this works. In Akka, every actor acts as a supervisor for its children. When
    a child fails, it suspends the processing messages, and sends a message to its
    parent to decide what to do about the failure. The policy that decides what happens
    to the parent and the child after the child fails is called the **supervision
    strategy**. The parent might decide to do the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究演员生命周期时，我们提到当发生异常时，顶级用户演员默认会重启。我们现在更详细地看看这是如何工作的。在Akka中，每个演员都充当其子演员的监督者。当一个子演员失败时，它会暂停消息处理，并发送一个消息给其父演员以决定如何处理这个失败。决定子演员失败后父演员和子演员如何处理的策略被称为**监督策略**。父演员可能会决定以下操作：
- en: Restart the actor, indicated with the `Restart` message
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`Restart`消息重启演员
- en: Resume the actor without a restart, indicated with the `Resume` message
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不重启恢复演员，用`Resume`消息表示
- en: Permanently stop the actor, indicated with the `Stop` message
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久停止演员，用`Stop`消息表示
- en: Fail itself with the same exception, indicated with the `Escalate` message
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Escalate`消息以相同的异常失败
- en: By default, the `user` guardian actor comes with a supervision strategy that
    restarts the failed children actors. User actors stop their children by default.
    Both supervision strategies can be overridden.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`user`守护者演员带有重启失败子演员的监督策略。用户演员默认停止其子演员。两种监督策略都可以被覆盖。
- en: 'To override the default supervision strategy in user actors, we override the
    `supervisorStrategy` field of the `Actor` class. In the following code, we define
    a particularly troublesome actor class called `Naughty`. When the `Naughty` class
    receives a `String` type message, it prints a logging statement. For all other
    message types, it throws the `RuntimeException`, as shown in the following implementation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖用户演员中的默认监督策略，我们覆盖了`Actor`类的`supervisorStrategy`字段。在下面的代码中，我们定义了一个特别麻烦的演员类，称为`Naughty`。当`Naughty`类接收到`String`类型的消息时，它会打印一条日志语句。对于所有其他消息类型，它会抛出`RuntimeException`，如下面的实现所示：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we declare a `Supervisor` actor class, which creates a child actor of
    the `Naughty` type. The `Supervisor` actor does not handle any messages, but overrides
    the default supervision strategy. If a `Supervisor` actor''s child actor fails
    because of throwing an `ActorKilledException`, it is restarted. However, if its
    child actor fails with any other exception type, the exception is escalated to
    the `Supervisor` actor. We override the `supervisorStrategy` field with the value
    `OneForOneStrategy`, a supervision strategy that applies fault handling specifically
    to the actor that failed:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个`Supervisor`演员类，它创建了一个`Naughty`类型的子演员。`Supervisor`演员不处理任何消息，但覆盖了默认的监督策略。如果一个`Supervisor`演员的子演员因为抛出`ActorKilledException`而失败，它会被重启。然而，如果其子演员以任何其他异常类型失败，异常会被升级到`Supervisor`演员。我们使用值`OneForOneStrategy`覆盖`supervisorStrategy`字段，这是一个专门应用于失败演员的故障处理策略：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We test the new supervisor strategy by creating an actor instance, `super`,
    of the `Supervisor` actor class. We then create an actor selection for all the
    children of `super`, and send them a `Kill` message. This fails the `Naughty`
    actor, but `super` restarts it due to its supervision strategy. We then apologize
    to the `Naughty` actor by sending it a `String` message. Finally, we convert a
    `String` message to a list of characters, and send it to the `Naughty` actor,
    which then throws a `RuntimeException`. This exception is escalated by `super`,
    and both actors are terminated, as shown in the following code snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建`Supervisor`演员类的实例，`super`，来测试新的监督策略。然后我们为`super`的所有子演员创建一个演员选择，并发送一个`Kill`消息。这导致`Naughty`演员失败，但由于其监督策略，`super`重新启动了它。然后我们通过发送一个`String`消息向`Naughty`演员道歉。最后，我们将一个`String`消息转换为字符列表，并发送给`Naughty`演员，然后它抛出一个`RuntimeException`。这个异常被`super`升级，并且两个演员都被终止，如下面的代码片段所示：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this example, we saw how the `OneForOneStrategy` works. When an actor fails,
    that specific actor is resumed, restarted, or stopped, depending on the exception
    that caused it to fail. The alternative `AllForOneStrategy` applies the fault-handling
    decision to all the children. When one of the child actors stops, all the other
    children are resumed, restarted, or stopped.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了`OneForOneStrategy`是如何工作的。当一个演员失败时，根据导致它失败异常的具体情况，该演员会被恢复、重启或停止。另一种`AllForOneStrategy`将故障处理决策应用于所有子演员。当一个子演员停止时，所有其他子演员都会被恢复、重启或停止。
- en: Recall our minimalistic web browser implementation from [Chapter 6](ch06.html
    "Chapter 6. Concurrent Programming with Reactive Extensions"), *Concurrent Programming
    with Reactive Extensions*. A more advanced web browser requires a separate subsystem
    that handles concurrent file downloads. Usually, we refer to such a software component
    as a download manager. We now consider a larger example, in which we apply our
    knowledge of actors in order to implement the infrastructure for a simple download
    manager.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第6章](ch06.html "第6章。使用反应式扩展进行并发编程")中实现的简约式网络浏览器，*使用反应式扩展进行并发编程*。一个更高级的网络浏览器需要一个单独的子系统来处理并发文件下载。通常，我们称这样的软件组件为下载管理器。现在我们考虑一个更大的例子，在这个例子中，我们应用我们对演员的知识来实现简单下载管理器的基础设施。
- en: 'The download manager will be implemented as an actor, represented by the `DownloadManager`
    actor class. The two most important tasks of every download manager are to download
    the resources at the requested URL, and to track the downloads that are currently
    in progress. To be able to react to download requests and download completion
    events, we define the message types `Download` and `Finished` in the `DownloadManager`
    companion object. The `Download` message encapsulates the URL of the resource
    and the destination file for the resource, while the `Finished` message encodes
    the destination file where the resource is saved:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 下载管理器将被实现为一个演员，由`DownloadManager`演员类表示。每个下载管理器的两个最重要的任务是下载请求的URL上的资源，以及跟踪正在进行的下载。为了能够对下载请求和下载完成事件做出反应，我们在`DownloadManager`伴随对象中定义了消息类型`Download`和`Finished`。`Download`消息封装了资源的URL和资源的目标文件，而`Finished`消息编码了资源保存的目标文件：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `DownloadManager` actor will not execute the downloads itself. Doing so
    would prevent it from receiving any messages before the download completes. Furthermore,
    this will serialize different downloads and prevent them from executing concurrently.
    Thus, the `DownloadManager` actor must delegate the task of downloading the files
    to different actors. We represent these actors with the `Downloader` actor class.
    A `DownloadManager` actor maintains a set of `Downloader` children, and tracks
    which children are currently downloading a resource. When a `DownloadManager`
    actor receives a `Download` message, it picks one of the non-busy `Downloader`
    actors, and forwards the `Download` message to it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadManager`演员将不会自己执行下载。这样做将阻止它在下载完成之前接收任何消息。此外，这将序列化不同的下载，并阻止它们并发执行。因此，`DownloadManager`演员必须将下载文件的任务委托给不同的演员。我们用`Downloader`演员类来表示这些演员。一个`DownloadManager`演员维护一组`Downloader`子演员，并跟踪哪些子演员正在下载资源。当一个`DownloadManager`演员接收到一个`Download`消息时，它会选择一个非忙碌的`Downloader`演员，并将`Download`消息转发给它。'
- en: 'Once the download is complete, the `Downloader` actor sends a `Finished` message
    to its parent. This is illustrated in the following figure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，`Downloader`演员向其父演员发送一个`Finished`消息。这如下面的图所示：
- en: '![Actor supervision](img/image_08_006.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![演员监督](img/image_08_006.jpg)'
- en: 'We first show the implementation of the `Downloader` actor class. When a `Downloader`
    actor receives a `Download` message, it downloads the contents of the specified
    URL and writes them to a destination file. It then sends the `Finished` message
    back to the sender of the `Download` message, as shown in the following implementation:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示了`Downloader`演员类的实现。当一个`Downloader`演员接收到一个`Download`消息时，它会下载指定URL的内容并将它们写入目标文件。然后，它将`Finished`消息发送回`Download`消息的发送者，如下面的实现所示：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `DownloadManager` actor class needs to maintain state to track which of
    its `Downloader` actors is currently downloading a resource. If there are more
    download requests than there are available `Downloader` instances, the `DownloadManager`
    actor needs to enqueue the download requests until a `Downloader` actor becomes
    available. The `DownloadManager` actor maintains a `downloaders` queue with actor
    references to non-busy `Downloader` actors. It maintains another queue, the `pendingWork`
    queue, with `Download` requests that cannot be assigned to any `Downloader` instances.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadManager`演员类需要维护状态以跟踪其`Downloader`演员中哪个正在下载资源。如果有更多的下载请求，而没有足够的`Downloader`实例，`DownloadManager`演员需要将下载请求排队，直到一个`Downloader`演员变得可用。`DownloadManager`演员维护一个包含非忙碌`Downloader`演员引用的`downloaders`队列。它还维护另一个队列，即`pendingWork`队列，其中包含无法分配给任何`Downloader`实例的`Download`请求。'
- en: 'Finally, it maintains a map called `workItems` that associates actor references
    of the busy `Downloader` instances with their `Download` requests. This is shown
    in the following `DownloadManager` implementation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它维护一个名为`workItems`的映射，将忙碌的`Downloader`实例的演员引用与它们的`Download`请求关联起来。这如下面的`DownloadManager`实现所示：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `checkDownloads` private method maintains the `DownloadManager` actor's
    invariant-the `pendingWork` and the `downloaders` queue cannot be non-empty at
    the same time. As soon as both the queues become non-empty, a `Downloader` actor
    reference `dl` is dequeued from `downloaders` and a `Download` request item is
    dequeued from the `pendingWork` queue. The `item` value is then sent as a message
    to the `dl` actor, and the `workItems` map is updated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkDownloads`私有方法维护`DownloadManager` actor的不变性质——`pendingWork`和`downloaders`队列不能同时为空。一旦两个队列都为空，就会从`downloaders`队列中出队一个`Downloader`
    actor引用`dl`，并从`pendingWork`队列中出队一个`Download`请求项。然后，将`item`值作为消息发送给`dl` actor，并更新`workItems`映射。'
- en: Whenever the `DownloadManager` actor receives a `Download` message, it adds
    it to the `pendingWork` queue and calls the `checkDownloads` method. Similarly,
    when the `Finished` message arrives, the `Downloader` actor is removed from the
    `workItems` queue and enqueued on the `downloaders` list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时`DownloadManager` actor收到`Download`消息，它都会将其添加到`pendingWork`队列并调用`checkDownloads`方法。同样，当`Finished`消息到达时，`Downloader`
    actor将从`workItems`队列中移除并排队到`downloaders`列表中。
- en: 'To ensure that the `DownloadManager` actor is created with the specified number
    of `Downloader` child actors, we override the `preStart` method to create the
    `Downloaders` list and add their actor references to the `downloaders` queue:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`DownloadManager` actor以指定的`Downloader`子actor数量创建，我们重写`preStart`方法来创建`Downloaders`列表并将它们的actor引用添加到`downloaders`队列中：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, we must override the `supervisorStrategy` field of the `DownloadManager`
    actor. We use the `OneForOneStrategy` field again, but specify that the actor
    can be restarted or resumed only up to 20 times within a two-second interval.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须重写`DownloadManager` actor的`supervisorStrategy`字段。我们再次使用`OneForOneStrategy`字段，但指定actor只能在两秒内重启或恢复最多20次。
- en: 'We expect that some URLs might be invalid, in which case the actor fails with
    a `FileNotFoundException`. We need to remove such an actor from the `workItems`
    collection and add it back to the `downloaders` queue. It does not make sense
    to restart the `Downloader` actors, because they do not contain any state. Instead
    of restarting, we simply resume a `Downloader` actor that cannot resolve a URL.
    If the `Downloader` instances fail due to any other messages, we escalate the
    exception and fail the `DownloadManager` actor, as shown in the following `supervisorStrategy`
    implementation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计一些URL可能无效，在这种情况下，actor会因`FileNotFoundException`而失败。我们需要将这样的actor从`workItems`集合中移除，并将其重新添加到`downloaders`队列中。重新启动`Downloader`
    actors没有意义，因为它们不包含任何状态。而不是重新启动，我们简单地恢复一个无法解析URL的`Downloader` actor。如果`Downloader`实例由于其他任何消息而失败，我们将升级异常并使`DownloadManager`
    actor失败，如下面的`supervisorStrategy`实现所示：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To test the download manager, we create a `DownloadManager` actor with four
    download slots, and send it several `Download` messages:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试下载管理器，我们创建了一个具有四个下载槽位的`DownloadManager` actor，并向它发送了几个`Download`消息：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'An extra copy of the URL specification cannot hurt, so we download it to our
    computer. The download manager logs that there are only three download slots left.
    Once the download completes, the download manager logs that there are four remaining
    download slots again. We then decide that we would like to contribute to the Scala
    programming language, so we download the `README` file from the official Scala
    repository. Unfortunately, we enter an invalid URL, and observe a warning from
    the download manager saying that the resource cannot be found:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 多一份URL规范副本不会造成伤害，所以我们将其下载到我们的电脑上。下载管理器记录说只剩下三个下载槽位。一旦下载完成，下载管理器再次记录说有四个剩余的下载槽位。然后我们决定我们想要为Scala编程语言做出贡献，所以我们从官方Scala仓库下载了`README`文件。不幸的是，我们输入了一个无效的URL，并观察到下载管理器发出警告说找不到资源：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The simple implementation of the basic actor-based download manager illustrates
    both how to achieve concurrency by delegating work to child actors, and how to
    treat failures in child actors. Delegating work is important, both for decomposing
    the program into smaller, isolated components, and to achieve better throughput
    and scalability. Actor supervision is the fundamental mechanism for handling failures
    in isolated components implemented in separate actors.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基于actor的基本下载管理器的简单实现说明了如何通过将工作委托给子actors来实现并发，以及如何处理子actors中的失败。委托工作对于将程序分解成更小、更独立的组件，以及实现更好的吞吐量和可伸缩性都至关重要。Actor监督是处理在单独actors中实现的独立组件中的失败的基本机制。
- en: Remote actors
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程actors
- en: So far in this book, we have mostly concentrated on writing programs on a single
    computer. Concurrent programs are executed within a single process on one computer,
    and they communicate using shared memory. Seemingly, actors described in this
    chapter communicate by passing messages. However, the message passing used throughout
    this chapter is implemented by reading and writing to shared memory under the
    hood.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们主要关注在单台计算机上编写程序。并发程序在单台计算机的一个进程中执行，并且使用共享内存进行通信。表面上，本章中描述的演员通过传递消息进行通信。然而，本章中使用的消息传递是通过在底层读取和写入共享内存来实现的。
- en: In this section, we study how the actor model ensures location transparency
    by taking existing actors and deploying them in a distributed program. We take
    two existing actor implementations, namely, `Pingy` and `Pongy`, and deploy them
    inside different processes. We will then instruct the `Pingy` actor to send a
    message to the `Pongy` actor, as before, and wait until the `Pingy` actor returns
    the `Pongy` actor's message. The message exchange will occur transparently, although
    the `Pingy` and `Pongy` actor's were previously implemented without knowing that
    they might exist inside separate processes, or even different computers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究演员模型如何通过将现有演员部署到分布式程序中来确保位置透明性。我们采用两个现有的演员实现，即 `Pingy` 和 `Pongy`，并将它们部署在不同的进程中。然后，我们将指示
    `Pingy` 演员向 `Pongy` 演员发送消息，就像之前一样，并等待 `Pingy` 演员返回 `Pongy` 演员的消息。消息交换将透明进行，尽管
    `Pingy` 和 `Pongy` 演员之前是在不知道它们可能存在于不同的进程，甚至不同的计算机中而实现。
- en: 'The Akka actor framework is organized into several modules. To use the part
    of Akka that allows communicating with actors in remote actor systems, we need
    to add the following dependency to our build definition file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Akka 演员框架组织成几个模块。为了使用允许与远程演员系统中的演员通信的 Akka 部分，我们需要在我们的构建定义文件中添加以下依赖项：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Before creating our ping-pong actors inside two different processes, we need
    to create an actor system that is capable of communicating with remote actors.
    To do this, we create a custom actor system configuration string. The actor system
    configuration string can be used to configure a range of different actor system
    properties; we are interested in using a custom `ActorRef` factory object called
    `RemoteActorRefProvider`. The `ActorRef` factory object allows the actor system
    to create actor references that can be used to communicate over the network. Furthermore,
    we configure the actor system to use the **Netty** networking library with the
    TCP network layer and the desired TCP port number. We declare the `remotingConfig`
    method for this task:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个不同的进程中创建我们的乒乓演员之前，我们需要创建一个能够与远程演员通信的演员系统。为此，我们创建一个自定义的演员系统配置字符串。演员系统配置字符串可以用来配置一系列不同的演员系统属性；我们感兴趣的是使用一个名为
    `RemoteActorRefProvider` 的自定义 `ActorRef` 工厂对象。`ActorRef` 工厂对象允许演员系统创建可以用于网络通信的演员引用。此外，我们配置演员系统使用
    **Netty** 网络库，TCP 网络层和所需的 TCP 端口号。我们声明 `remotingConfig` 方法来完成这项任务：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We then define a `remotingSystem` factory method that creates an actor system
    object using the given name and port. We use the `remotingConfig` method, defined
    earlier, to produce the configuration object for the specified network port:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `remotingSystem` 的远程系统工厂方法，该方法使用给定的名称和端口创建一个演员系统对象。我们使用之前定义的 `remotingConfig`
    方法来生成指定网络端口的配置对象：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now we are ready to create the `Pongy` actor system. We declare an application
    called `RemotingPongySystem`, which instantiates an actor system called `PongyDimension`
    using the network port `24321`. We arbitrarily picked a network port that was
    free on our machine. If the creation of the actor system fails because the port
    is not available, you can pick a different port in the range `1024` to `65535`.
    Make sure that you don't have a firewall running, as it can block the network
    traffic for arbitrary applications.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好创建 `Pongy` 演员系统。我们声明一个名为 `RemotingPongySystem` 的应用程序，该程序使用网络端口 `24321`
    实例化一个名为 `PongyDimension` 的演员系统。我们随意选择了一个在我们机器上空闲的网络端口。如果演员系统的创建失败，因为端口不可用，您可以在
    `1024` 到 `65535` 的范围内选择不同的端口。确保您没有运行防火墙，因为它可能会阻止任意应用程序的网络流量。
- en: 'The `RemotingPongySystem` application is shown in the following example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `RemotingPongySystem` 应用程序：
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `RemotingPongySystem` application creates a `Pongy` actor and shuts down
    after 15 seconds. After we start it, we will only have a short time to start another
    application running the `Pingy` actor. We will call this second application `RemotingPingySystem`.
    Before we implement it, we create another actor called `Runner`, which will instantiate
    `Pingy`, obtain the `Pongy` actor's reference, and give it to the `Pingy` actor;
    recall that the ping-pong game from the earlier section starts when the `Pingy`
    actor obtains the `Pongy` actor's reference.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemotingPongySystem`应用程序创建了一个`Pongy`演员，并在15秒后关闭。启动它后，我们将只有很短的时间来启动另一个运行`Pingy`演员的应用程序。我们将这个第二个应用程序称为`RemotingPingySystem`。在我们实现它之前，我们创建了一个名为`Runner`的另一个演员，它将实例化`Pingy`，获取`Pongy`演员的引用，并将其传递给`Pingy`演员；回想一下，从早先章节中的乒乓游戏开始，当`Pingy`演员获取到`Pongy`演员的引用时。'
- en: 'When the `Runner` actor receives a `start` message, it constructs the actor
    path for the `Pongy` actor. We use the `akka.tcp` protocol and the name of the
    remote actor system, along with its IP address and port number. The `Runner` actor
    sends an `Identify` message to the actor selection in order to obtain the actor
    reference to the remote `Pongy` instance. The complete `Runner` implementation
    is shown in the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Runner`演员收到一个`start`消息时，它为`Pongy`演员构造演员路径。我们使用`akka.tcp`协议、远程演员系统的名称，以及它的IP地址和端口号。`Runner`演员向演员选择发送一个`Identify`消息，以获取远程`Pongy`实例的演员引用。完整的`Runner`实现如以下代码片段所示：
- en: '[PRE54]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Once the `Runner` actor sends the `Pongy` actor reference to `Pingy`, the game
    of remote ping pong can begin. To test it, we declare the `RemotingPingySystem`
    application, which starts the `Runner` actor and sends it a `start` message:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Runner`演员将`Pongy`演员引用发送给`Pingy`，远程乒乓游戏的比赛就可以开始了。为了测试它，我们声明了`RemotingPingySystem`应用程序，它启动了`Runner`演员并发送了一个`start`消息：
- en: '[PRE55]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We now need to start the `RemotingPongySystem` application, and the `RemotingPingySystem`
    application after that; we only have 15 seconds until the `RemotingPongySystem`
    application shuts itself down. The easiest way to do this is to start two SBT
    instances in your project folder and run the two applications at the same time.
    After the `RemotingPingySystem` application starts, we soon observe a `pong` message
    from another dimension.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要启动`RemotingPongySystem`应用程序，然后启动`RemotingPingySystem`应用程序；我们只有15秒钟的时间，`RemotingPongySystem`应用程序就会自行关闭。最简单的方法是在你的项目文件夹中启动两个SBT实例，并同时运行这两个应用程序。在`RemotingPongySystem`应用程序启动后，我们很快就会观察到来自另一个维度的`pong`消息。
- en: In the previous example, the actor system configuration and the `Runner` actor
    were responsible for setting up the network communication, and were not location-transparent.
    This is typically the case with distributed programs; a part of the program is
    responsible for initializing and discovering actors within remote actor systems,
    while the application-specific logic is confined within separate actors.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，演员系统配置和`Runner`演员负责设置网络通信，并且不是位置透明的。这通常是分布式程序的情况；程序的一部分负责初始化和发现远程演员系统中的演员，而应用程序特定的逻辑则局限于单独的演员中。
- en: Tip
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In larger actor programs, separate deployment logic from application logic.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的演员程序中，将部署逻辑与应用程序逻辑分开。
- en: 'To summarize, remote actor communication requires the following steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，远程演员通信需要以下步骤：
- en: Declaring an actor system with an appropriate remoting configuration
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明具有适当远程配置的演员系统
- en: Starting two actor systems in separate processes or on separate machines
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的进程或不同的机器上启动两个演员系统
- en: Using actor path selection to obtain actor references
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用演员路径选择来获取演员引用
- en: Using actor references to transparently send messages
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用演员引用透明地发送消息
- en: While the first three steps are not location-transparent, the application logic
    is usually confined within the fourth step, as we saw in this section. This is
    important, as it allows separating the deployment logic from the application semantics
    and building distributed systems that can be deployed transparently to different
    network configurations.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前三个步骤不是位置透明的，但应用程序逻辑通常局限于第四步，正如我们在本节中看到的。这很重要，因为它允许将部署逻辑与应用程序语义分离，并构建可以透明地部署到不同网络配置的分布式系统。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what actors are and how to use them to build concurrent
    programs. Using the Akka actor framework, we studied how to create actors, organize
    them into hierarchies, manage their lifecycle, and recover them from errors. We
    examined important patterns in actor communication and learned how to model actor
    behavior. Finally, we saw how the actor model can ensure location transparency,
    and serve as a powerful tool to seamlessly build distributed systems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了演员是什么以及如何使用它们来构建并发程序。使用Akka演员框架，我们研究了如何创建演员，将它们组织成层次结构，管理它们的生命周期，并在出错时恢复它们。我们检查了演员通信中的重要模式，并学习了如何模拟演员行为。最后，我们看到了演员模型如何确保位置透明性，并作为构建分布式系统的强大工具。
- en: Still, there are many Akka features that we omitted in this chapter. Akka comes
    with detailed online documentation, which is one of the best sources of information
    on Akka. To obtain an in-depth understanding of distributed programming, we recommend
    the books *Distributed Algorithms*, *Nancy A. Lynch*, published by Elsevier and
    *Introduction to Reliable and Secure Distributed Programming*, *Christian Cachin*,
    *Rachid Guerraoui, Luis Rodrigues*, published by Springer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们在这个章节中省略了许多Akka特性。Akka提供了详细的在线文档，这是关于Akka信息来源的最好之一。为了深入理解分布式编程，我们推荐Elsevier出版的书籍*分布式算法*，作者Nancy
    A. Lynch，以及Springer出版的*可靠和安全的分布式编程导论*，作者Christian Cachin，Rachid Guerraoui，Luis
    Rodrigues。
- en: In the following chapter, we will summarize the different concurrency libraries
    we learned about in this book, examine the typical use cases for each of them,
    and see how they work together in larger applications.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结本书中我们学习到的不同并发库，检查每个库的典型用例，并看看它们如何在更大的应用程序中协同工作。
- en: Exercises
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following exercises test your understanding of the actor programming model,
    and distributed programming in general. The first few exercises are straightforward,
    and deal with the basics of the actor API in Akka. Subsequent exercises are more
    involved, and go deeper into the territory of fault-tolerant distributed programming.
    Try to solve these exercises by first assuming that no machines fail, and then
    consider what happens if some of the machines fail during the execution of the
    program:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习测试你对演员编程模型以及分布式编程的一般理解。前几个练习比较直接，涉及Akka中演员API的基础。随后的练习更加复杂，深入到容错分布式编程的领域。首先假设没有机器失败，然后考虑在程序执行过程中如果某些机器失败会发生什么：
- en: Implement the timer actor with the `TimerActor` class. After receiving a `Register`
    message containing the `t` timeout in milliseconds, the timer actor sends a `Timeout`
    message back after `t` milliseconds. The timer must accept multiple `Register`
    messages.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`TimerActor`类实现计时器演员。在接收到包含`t`毫秒超时的`Register`消息后，计时器演员在`t`毫秒后发送一个`Timeout`消息。计时器必须接受多个`Register`消息。
- en: Recall the bank account example from [Chapter 2](ch02.html "Chapter 2. Concurrency
    on the JVM and the Java Memory Model"), *Concurrency on the JVM and the Java Memory
    Model*. Implement different bank accounts as separate actors, represented by the
    `AccountActor` class. When an `AccountActor` class receives a `Send` message,
    it must transfer the specified amount of money to the target actor. What will
    happen if either of the actors receives a `Kill` message at any point during the
    money transaction?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想[第2章](ch02.html "第2章。JVM和Java内存模型上的并发")中的银行账户示例，*JVM和Java内存模型上的并发*。将不同的银行账户作为单独的演员实现，由`AccountActor`类表示。当`AccountActor`类接收到`Send`消息时，它必须将指定金额的钱转账给目标演员。如果在任何时刻，任何一个演员接收到`Kill`消息，会发生什么？
- en: 'Implement the `SessionActor` class for actors that control access to other
    actors:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现控制其他演员访问的`SessionActor`类。
- en: '[PRE56]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After the `SessionActor` instance receives the `StartSession` message with the
    correct password, it forwards all the messages to the actor reference `r`, until
    it receives the `EndSession` message. Use behaviors to model this actor.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SessionActor`实例接收到带有正确密码的`StartSession`消息后，它将所有消息转发到演员引用`r`，直到接收到`EndSession`消息。使用行为来模拟这个演员。
- en: Use actors to implement the `ExecutionContext` interface, described in [Chapter
    3](ch03.html "Chapter 3. Traditional Building Blocks of Concurrency"), *Traditional
    Building Blocks of Concurrency*.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用演员来实现[第3章](ch03.html "第3章。并发传统的构建块")中描述的`ExecutionContext`接口，*并发的传统构建块*。
- en: Implement the `FailureDetector` actor, which sends `Identify` messages to the
    specified actors every `interval` seconds. If an actor does not reply with any
    `ActorIdentity` messages within `threshold` seconds, the `FailureDetector` actor
    sends a `Failed` message to its parent actor, which contains the actor reference
    of the failed actor.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `FailureDetector` 演员类，每隔 `interval` 秒向指定的演员发送 `Identify` 消息。如果一个演员在 `threshold`
    秒内没有回复任何 `ActorIdentity` 消息，则 `FailureDetector` 演员向其父演员发送一个 `Failed` 消息，其中包含失败演员的演员引用。
- en: 'A distributed hash map is a collection distributed across multiple computers,
    each of which contains part of the data, called a **shard**. When there are `2^n`
    shards, the first `n` bits of the hash code of the key are used to decide which
    shard a key-value pair should go to. Implement the distributed hash map with the
    `DistributedMap` class:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式哈希表是一个分布在不同计算机上的集合，每台计算机包含部分数据，称为 **shard**。当有 `2^n` 个 shard 时，键的哈希码的前 `n`
    位用于决定键值对应该去哪个 shard。使用 `DistributedMap` 类实现分布式哈希表：
- en: '[PRE57]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `DistributedMap` class takes a list of actor references to the `ShardActor`
    instances, whose actor template you also need to implement. You might assume that
    the length of the `shards` list is a power of two. The `update` and `get` methods
    are asynchronous, and return the result in a future object.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DistributedMap` 类接受一个指向 `ShardActor` 实例的演员引用列表，你还需要实现其演员模板。你可能假设 `shards`
    列表的长度是 2 的幂。`update` 和 `get` 方法是异步的，并返回一个未来对象的结果。'
- en: 'Implement an abstract `BroadcastActor` class, which defines the `broadcast`
    method:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个抽象的 `BroadcastActor` 类，它定义了 `broadcast` 方法：
- en: '[PRE58]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `broadcast` method sends the `msg` message to all the actors specified
    in the `refs` list. The actor invoking the `broadcast` method might, for reasons
    such as power loss, fail at any point during the execution of the `broadcast`
    method. Nevertheless, the `broadcast` method must have **reliable delivery**:
    if at least one actor from the `refs` list receives the `msg` message, then all
    the actors from the `refs` list must eventually receive `msg`.'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`broadcast` 方法将 `msg` 消息发送到 `refs` 列表中指定的所有演员。调用 `broadcast` 方法的演员可能在执行 `broadcast`
    方法的过程中因电源故障等原因失败。尽管如此，`broadcast` 方法必须具有 **可靠投递**：如果 `refs` 列表中的至少一个演员接收到了 `msg`
    消息，那么 `refs` 列表中的所有演员最终都必须接收到 `msg`。'
- en: Implement a `FlowRateActor` class for an actor that forwards incoming messages
    to a target actor. This actor must ensure that the number of messages forwarded
    per second does not exceed a rate specified in its constructor.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `FlowRateActor` 类，用于将传入的消息转发给目标演员。此演员必须确保每秒转发的消息数量不超过其构造函数中指定的速率。
- en: Implement a `Sequencer` actor, which forwards messages to the target actor.
    If the message is a two-element tuple where the first element is a `Long` value,
    then the `Long` value is interpreted as a sequence number. All such messages must
    be forwarded in the proper sequence number order, starting from number `0`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `Sequencer` 演员类，它将消息转发给目标演员。如果消息是一个包含两个元素的元组，其中第一个元素是一个 `Long` 值，则该 `Long`
    值被解释为序列号。所有这样的消息都必须按照正确的序列号顺序转发，从数字 `0` 开始。
- en: Implement a `MasterWorker[T]` actor that, given a number of worker parameters,
    creates a set of worker actors and forwards task messages of type `() => T` to
    those workers. When the worker actors complete a task, they send the result back
    to the `MasterWorker` actor, which sends the reply back to the client actor that
    originally sent the task.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 `MasterWorker[T]` 演员类，给定一些工作参数，创建一组工作演员，并将类型为 `() => T` 的任务消息转发给这些工作演员。当工作演员完成任务时，它们将结果发送回
    `MasterWorker` 演员类，该类将回复发送回最初发送任务的客户演员。
