- en: Chapter 1. Key Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a quick introduction about what Apache Camel is, this chapter will introduce
    the key features provided by Camel. It provides just an overview of these features;
    the details will come in dedicated chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In an enterprise, you see a lot of different software and systems in the IT
    ecosystem. In order to consolidate the data and sync the systems, the enterprise
    would want to implement communication and integration of these systems. This communication
    or integration is not so easy, as we have to deal with the specifications on each
    system the protocol and the message's data format are different most of the time,
    so we have to transform and adapt to each system.
  prefs: []
  type: TYPE_NORMAL
- en: Using point-to-point communication is one option. However, the problem with
    this approach is that we tighten the integration of a couple of systems. Changing
    to other systems or protocols requires refactoring of the implementation. Moreover,
    dealing with multiple systems is not so easy with point-to-point.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of point-to-point, we use mediation. Mediation reduces complexity
    and provides a more flexible approach by adding and using a tier between the systems
    (man in the middle). The purpose is to facilitate the information flow and integration
    of the systems.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Camel is a mediation framework.
  prefs: []
  type: TYPE_NORMAL
- en: What is Apache Camel?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Camel originated in Apache ServiceMix. Apache ServiceMix 3 was powered
    by the Spring framework and implemented in the JBI specification. The **Java Business
    Integration** (**JBI**) specification proposed a Plug and Play approach for integration
    problems. JBI was based on WebService concepts and standards. For instance, it
    directly reuses the **Message Exchange Patterns** (**MEP**) concept that comes
    from **WebService Description Language** (**WSDL**).
  prefs: []
  type: TYPE_NORMAL
- en: Camel reuses some of these concepts, for instance, you will see that we have
    the concept of MEP in Camel.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JBI suffered mostly from two issues:'
  prefs: []
  type: TYPE_NORMAL
- en: In JBI, all messages between endpoints are transported in the **Normalized Messages
    Router** (**NMR**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the NMR, a message has a standard XML format. As all messages in the NMR
    have the same format, it's easy to audit messages and the format is predictable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, the JBI XML format has an important drawback for performances: it
    needs to marshall and unmarshall the messages. Some protocols (such as REST or
    RMI) are not easy to describe in XML.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For instance, REST can work in stream mode. It doesn't make sense to marshall
    streams in XML.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Camel is payload-agnostic. This means that you can transport any kind of messages
    with Camel (not necessary XML formatted).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: JBI describes a packaging. We distinguish the binding components (responsible
    for the interaction with the system outside of the NMR and the handling of the
    messages in the NMR), and the service engines (responsible for transforming the
    messages inside the NMR).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it's not possible to directly deploy the endpoints based on these components.
    JBI requires a service unit (a ZIP file) per endpoint, and for each package in
    a service assembly (another ZIP file). JBI also splits the description of the
    endpoint from its configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It does not result in a very flexible packaging: with definitions and configurations
    scattered in different files, not easy to maintain. In Camel, the configuration
    and definition of the endpoints are gathered in a simple URI. It''s easier to
    read.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Moreover, Camel doesn't force any packaging; the same definition can be packaged
    in a simple XML file, OSGi bundle, and regular JAR file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to JBI, another foundation of Camel is the book *Enterprise Integration
    Patterns by Gregor Hohpe and Bobby Woolf*.
  prefs: []
  type: TYPE_NORMAL
- en: This book describes design patterns answering classical problems while dealing
    with enterprise application integration and message oriented middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The book describes the problems and the patterns to solve them. Camel strives
    to implement the patterns described in the book to make them easy to use and let
    the developer concentrate on the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what Camel is: an open source framework that allows you to integrate
    systems and that comes with a lot of connectors and **Enterprise Integration Patterns**
    (**EIP**) components out of the box. And if that is not enough, one can extend
    and implement custom components.'
  prefs: []
  type: TYPE_NORMAL
- en: Components and bean support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Camel ships with a wide variety of components out of the box; currently,
    there are more than 100 components available.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see:'
  prefs: []
  type: TYPE_NORMAL
- en: The connectivity components that allow exposure of endpoints for external systems
    or communicate with external systems. For instance, the FTP, HTTP, JMX, WebServices,
    JMS, and a lot more components are connectivity components. Creating an endpoint
    and the associated configuration for these components is easy, by directly using
    a URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal components applying rules to the messages internally to Camel.
    These kinds of components apply validation or transformation rules to the inflight
    message. For instance, validation or XSLT are internal components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to this, Camel brings a very powerful connectivity and mediation framework.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it's pretty easy to create new custom components, allowing you to
    extend Camel if the default components set doesn't match your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: It's also very easy to implement complex integration logic by creating your
    own processors and reusing your beans. Camel supports beans frameworks (IoC),
    such as Spring or Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Predicates and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will see later, most of the EIP need a rule definition to apply a routing
    logic to a message. The rule is described using an expression.
  prefs: []
  type: TYPE_NORMAL
- en: It means that we have to define expressions or predicates in the Enterprise
    Integration Patterns. An expression returns any kind of value, whereas a predicate
    returns true or false only.
  prefs: []
  type: TYPE_NORMAL
- en: Camel supports a lot of different languages to declare expressions or predicates.
    It doesn't force you to use one, it allows you to use the most appropriate one.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Camel supports xpath, mvel, ognl, python, ruby, PHP, JavaScript,
    SpEL (Spring Expression Language), Groovy, and so on as expression languages.
    It also provides native Camel prebuilt functions and languages that are easy to
    use such as header, constant, or simple languages.
  prefs: []
  type: TYPE_NORMAL
- en: Data format and type conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel is payload-agnostic. This means that it can support any kind of message.
    Depending on the endpoints, it could be required to convert from one format to
    another. That's why Camel supports different data formats, in a pluggable way.
    This means that Camel can marshall or unmarshall a message in a given format.
    For instance, in addition to the standard JVM serialization, Camel natively supports
    Avro, JSON, protobuf, JAXB, XmlBeans, XStream, JiBX, SOAP, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the endpoints and your need, you can explicitly define the data
    format during the processing of the message. On the other hand, Camel knows the
    expected format and type of endpoints. Thanks to this, Camel looks for a type
    converter, allowing to implicitly transform a message from one format to another.
  prefs: []
  type: TYPE_NORMAL
- en: You can also explicitly define the type converter of your choice at some points
    during the processing of the message. Camel provides a set of ready-to-use type
    converters, but, as Camel supports a pluggable model, you can extend it by providing
    your own type converters. It's a simple POJO to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Easy configuration and URI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel uses a different approach based on URI. The endpoint itself and its configuration
    are on the URI.
  prefs: []
  type: TYPE_NORMAL
- en: The URI is human readable and provides the details of the endpoint, which is
    the endpoint component and the endpoint configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As this URI is part of the complete configuration (which defines what we name
    a route, as we will see later), it's possible to have a complete overview of the
    integration logic and connectivity in a row. We will cover this in detail in [Chapter
    2](ch02.html "Chapter 2. Core Concepts"), *Core Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and different deployment topologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Camel itself is very light. The Camel core is only around 2 MB, and contains
    everything required to run Camel. As it's based on a pluggable architecture, all
    Camel components are provided as external modules, allowing you to install only
    what you need, without installing superfluous and needlessly heavy modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw, Camel is based on simple POJO, which means that the Camel core doesn''t
    depend on other frameworks: it''s an atomic framework and is ready to use. All
    other modules (components, DSL, and so on) are built on top of this Camel core.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, Camel is not tied to one container for deployment. Camel supports
    a wide range of containers to run. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A J2EE application server such as WebSphere, WebLogic, JBoss, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Web container such as Apache Tomcat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OSGi container such as Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A standalone application using frameworks such as Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel gives a lot of flexibility, allowing you to embed it into your application
    or to use an enterprise-ready container.
  prefs: []
  type: TYPE_NORMAL
- en: Quick prototyping and testing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any integration project, it''s typical that we have some part of the integration
    logic not yet available. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: The application to integrate with has not yet been purchased or not yet ready
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remote system to integrate with has a heavy cost, not acceptable during
    the development phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple teams work in parallel, so we may have some kinds of deadlocks between
    the teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a complete integration framework, Camel provides a very easy way to prototype
    part of the integration logic. Even if you don't have the actual system to integrate,
    you can simulate this system (mock), as it allows you to implement your integration
    logic without waiting for dependencies. The mocking support is directly part of
    the Camel core and doesn't require any additional dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Along the same lines, testing is also crucial in an integration project. In
    such a kind of project, a lot of errors can happen and most are unforeseen. Moreover,
    a small change in an integration process might impact a lot of other processes.
    Camel provides the tools to easily test your design and integration logic, allowing
    you to integrate this in a continuous integration platform.
  prefs: []
  type: TYPE_NORMAL
- en: Management and monitoring using JMX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apache Camel uses the Java Management Extension (JMX) standard and provides
    a lot of insights into the system using MBeans (Management Beans), providing a
    detailed view of the following current system:'
  prefs: []
  type: TYPE_NORMAL
- en: The different integration processes with the associated metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different components and endpoints with the associated metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, these MBeans provide more insights than metrics. They also provide
    the operations to manage Camel. For instance, the operations allow you to stop
    an integration process, to suspend an endpoint, and so on. Using a combination
    of metrics and operations, you can configure a very agile integration solution.
  prefs: []
  type: TYPE_NORMAL
- en: Active community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Apache Camel community is very active. This means that potential issues
    are identified very quickly and a fix is available soon after. However, it also
    means that a lot of ideas and contributions are proposed, giving more and more
    features to Camel.
  prefs: []
  type: TYPE_NORMAL
- en: Another big advantage of an active community is that you will never be alone;
    a lot of people are active on the mailing lists who are ready to answer your question
    and provide advice.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Camel is an enterprise integration solution used in many large organizations
    with enterprise support available through RedHat or Talend.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter briefly introduced Camel and where it's come from. It mainly introduced
    Camel's key features. In the next chapter, before dealing with some of these features
    in detail, we will introduce the Camel core concepts, which will help you easily
    understand the further chapters.
  prefs: []
  type: TYPE_NORMAL
