["```java\n  val backendDeps = Seq (\n    \"io.argonaut\" %% \"argonaut\" % \"6.0.4\",\n    \"org.json4s\" %% \"json4s-native\" % \"3.2.10\",\n    \"io.spray\" %%  \"spray-json\" % \"1.3.2\",\n    \"com.typesafe.play\" %% \"play-json\" % \"2.4.0\"\n  )\n```", "```java\n  val json = \"\"\"{\n    \"id\": 1,\n    \"title\": \"The Title\",\n    \"content\": \"This is the data to create a new task\",\n    \"assignedTo\": {\n      \"name\": \"pietje\"\n    },\n    \"notes\": [],\n    \"status\": {\n      \"status\": \"New\"\n    }\n  }\"\"\"\n```", "```java\n> chapter07/run-main chapter7.json.PlayJson\n> chapter07/run-main chapter7.json.Argonaut\n> chapter07/run-main chapter7.json.Json4S\n> chapter07/run-main chapter7.json. SprayJson\n\n```", "```java\n  val parsedJson = parse(json);\n```", "```java\nJObject(List((id,JInt(1)), (title,JString(The Title)), (content,JString(This is the data to create a new task)), (assignedTo,JObject(List((name,JString(pietje))))), (notes,JArray(List())), (status,JObject(List((status,JString(New)))))))\n```", "```java\n  pretty(render(parsedJson)); // or compact\n```", "```java\n{\n  \"id\":1,\n  \"title\":\"The Title\",\n  \"content\":\"This is the data to create a new task\",\n  \"assignedTo\":{\n    \"name\":\"pietje\"\n  },\n  \"notes\":[],\n  \"status\":{\n    \"status\":\"New\"\n  }\n}\n```", "```java\nval notesList = Seq[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\"))\n  val jsonManually =\n    (\"id\" -> 1) ~\n    (\"title\" -> \"title\") ~\n    (\"content\" -> \"the content\") ~\n    (\"assignedTo\" ->\n      (\"name\" -> \"pietje\")) ~\n    (\"notes\" ->\n      notesList.map { note =>\n            ((\"id\" -> note.id) ~\n             (\"content\" -> note.content))}) ~\n    (\"status\" ->\n      (\"status\" -> \"new\"))\n```", "```java\n{\"id\":1,\"title\":\"title\",\"content\":\"the content\",\"assignedTo\":{\"name\":\"pietje\"},\"notes\":[{\"id\":1,\"content\":\"Note 1\"},{\"id\":2,\"content\":\"Note 2\"}],\"status\":{\"status\":\"new\"}}\n```", "```java\n  println(jsonManually \\\\ \"content\") // all the content\n  println(jsonManually \\ \"assignedTo\" \\ \"name\") // single name\n\n  // allows unboxing\n\n  println(jsonManually \\\\ \"id\" \\\\ classOf[JInt])\n```", "```java\nJObject(List((content,JString(the content)), (content,JString(Note 1)), (content,JString(Note 2))))\nJString(pietje)\nList(1, 1, 2)\n```", "```java\n  implicit val formats = DefaultFormats\n  val task = jsonManually.extract[Task]\n```", "```java\n  import org.json4s.native.Serialization\n  import org.json4s.native.Serialization.{read, write}\n  implicit val autoFormat = Serialization.formats(NoTypeHints)\n\n  val taskAsJson: String = write(task)\n  val backToTask: Task = read[Task](taskAsJson)\n}\n```", "```java\n val parsed = json.parse // returns a scalaz disjunction\n val parsedValue = parsed | jString(\"Error parsing\")\n```", "```java\n\\/-({\"id\":1,\"status\":{\"status\":\"New\"},\"content\":\"This is the data to create a new task\",\"notes\":[],\"title\":\"The Title\",\"assignedTo\":{\"name\":\"pietje\"}})\n```", "```java\n  println(parsedValue.spaces4)\n```", "```java\n{\n    \"id\" : 1,\n    \"status\" : {\n        \"status\" : \"New\"\n    },\n    \"content\" : \"This is the data to create a new task\",\n    \"notes\" : [\n\n    ],\n    \"title\" : \"The Title\",\n    \"assignedTo\" : {\n        \"name\" : \"pietje\"\n    }\n}\n```", "```java\n  val notesList = List[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\"))\n  val jsonObjectBuilderWithCodec: Json =\n      (\"status\" := Json(\"status\" := \"New\")) ->:\n      (\"notes\" := notesList.map(\n                  note => Json(\"id\" := note.id, \n                               \"content\" := note.content)) ) ->:\n      (\"assignedTo\" := Json(\"name\" := \"Someone\")) ->:\n      (\"content\" := \"This is the content\") ->:\n      (\"title\" := \"The Title\") ->:\n      (\"id\" := 1) ->: jEmptyObject\n```", "```java\nval innerKey2StringLens = jObjectPL >=>   \n    jsonObjectPL(\"notes\") >=>          \n      jArrayPL >=>                      \n      jsonArrayPL(0) >=>            \n        jObjectPL >=>              \n        jsonObjectPL(\"id\") >=>         \n          jStringPL\n```", "```java\nval res = innerKey2StringLens.get(jsonObjectBuilderWithCodec))\n```", "```java\nobject Encodings {\n\n    implicit def StatusCodecJson: CodecJson[Status] =\n      casecodec1(Status.apply, Status.unapply)(\"status\")\n    implicit def NoteCodecJson: CodecJson[Note] =\n      casecodec2(Note.apply, Note.unapply)(\"id\", \"content\")\n    implicit def PersonCodecJson: CodecJson[Person] =\n      casecodec1(Person.apply, Person.unapply)(\"name\")\n    implicit def TaskCodecJson: CodecJson[Task] =\n      casecodec6(Task.apply, Task.unapply)(\"id\", \"title\", \n                    \"content\", \"assignedTo\", \"notes\", \"status\")\n  }\n\n  import Encodings._\n```", "```java\n  val task = new Task(\n    1, \"This is the title\", \"This is the content\",\n    Some(Person(\"Me\")),\n    List[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\")), Status(\"new\"))\n\n  val taskAsJson: Json = task.asJson\n\n  val taskBackAgain: Task =\n               Parse.decodeOption[Task](taskAsJson.spaces4)\n```", "```java\n  import spray.json._\n\n  val parsed = json.parseJson\n```", "```java\n{\"id\":1,\"status\":{\"status\":\"New\"},\"content\":\"This is the data to create a new task\",\"notes\":[],\"title\":\"The Title\",\"assignedTo\":{\"name\":\"pietje\"}}\n```", "```java\nprintln(parsed.prettyPrint) // or .compactPrint\n```", "```java\n{\n  \"id\": 1,\n  \"status\": {\n    \"status\": \"New\"\n  },\n  \"content\": \"This is the data to create a new task\",\n  \"notes\": [],\n  \"title\": \"The Title\",\n  \"assignedTo\": {\n    \"name\": \"pietje\"\n  }\n}\n```", "```java\nval notesList = Seq[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\"))\n  val manually = JsObject(\n    \"id\" -> JsNumber(1),\n    \"title\" -> JsString(\"title\"),\n    \"content\" -> JsString(\"the content\"),\n    \"assignedTo\" -> JsObject(\"name\" -> JsString(\"person\")),\n    \"notes\" -> JsArray(\n      notesList.map({ note =>\n        JsObject(\n        \"id\" -> JsNumber(note.id),\n        \"content\" -> JsString(note.content)\n        )\n      }).toVector),\n   \"status\" -> JsObject(\"status\" -> JsString(\"new\"))\n  )\n```", "```java\n{\"id\":1,\"status\":{\"status\":\"new\"},\"content\":\"the content\",\"notes\":[{\"id\":1,\"content\":\"Note 1\"},{\"id\":2,\"content\":\"Note 2\"}],\"title\":\"title\",\"assignedTo\":{\"name\":\"person\"}}\n```", "```java\nprintln(manually.getFields(\"id\"));\nprintln(manually.fields)\n```", "```java\nval task = new Task(\n    1, \"This is the title\", \"This is the content\", \n    Some(Person(\"Me\")),\n    List[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\")), Status(\"new\"))\n\n  object MyJsonProtocol extends DefaultJsonProtocol {\n    implicit val noteFormat = jsonFormat2(Note)\n    implicit val personFormat = jsonFormat1(Person)\n    implicit val statusFormat = jsonFormat1(Status)\n    implicit val taskFormat = jsonFormat6(Task)\n  }\n\n  import MyJsonProtocol._\n  val taskAsString = task.toJson\n\n  // and back to a task again\n  val backToTask = taskAsString.convertTo[Task]\n```", "```java\nimport play.api.libs.json._\nimport play.api.libs.functional.syntax._\n\nval fromJson = Json.parse(json)\n```", "```java\n{\"id\":1,\"title\":\"The Title\",\"content\":\"This is the data to create a new task\",\"assignedTo\":{\"name\":\"pietje\"},\"notes\":[],\"status\":{\"status\":\"New\"}}\n```", "```java\nprintln(Json.prettyPrint(fromJson))\n```", "```java\n{\n  \"id\" : 1,\n  \"title\" : \"The Title\",\n  \"content\" : \"This is the data to create a new task\",\n  \"assignedTo\" : {\n    \"name\" : \"pietje\"\n  },\n  \"notes\" : [ ],\n  \"status\" : {\n    \"status\" : \"New\"\n  }\n}\n```", "```java\n// 3\\. Create JSON object by hand.\nval notesList = Seq[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\"))\nval manually = JsObject(Seq(\n  \"id\" -> JsNumber(1),\n  \"title\" -> JsString(\"title\"),\n  \"content\" -> JsString(\"the content\"),\n  \"assignedTo\" -> JsObject(Seq(\"name\" -> JsString(\"person\"))),\n  \"notes\" -> JsArray(\n    notesList.map({ note =>\n      JsObject(Seq(\n        \"id\" -> JsNumber(note.id),\n        \"content\" -> JsString(note.content)\n      ))\n    })),\n  \"status\" -> JsObject(Seq(\"status\" -> JsString(\"new\")))\n))\n```", "```java\nprintln(manually \\\\ \"content\")\nprintln(manually \\ \"assignedTo\" \\ \"name\")\nprintln((manually \\\\ \"id\" )(2))\n```", "```java\nList(\"the content\", \"Note 1\", \"Note 2\")\nJsDefined(\"person\")\n2\n```", "```java\nobject Formats {\n  implicit val noteFormat = Json.format[Note]\n  implicit val statusFormat = Json.format[Status]\n  implicit val personFormat = Json.format[Person]\n  implicit val taskFormat = Json.format[Task]\n}\n```", "```java\nimport Formats._\n\nval task = new Task(\n  1, \"This is the title\", \"This is the content\", Some(Person(\"Me\")),\n  List[Note](Note(1,\"Note 1\"), Note(2, \"Note 2\")), Status(\"new\"))\n\nval toJson = Json.toJson(task)\nval andBackAgain = Json.fromJson[Task](toJson)\n```", "```java\n{\n  \"_links\" : [ {\n    \"rel\" : \"self\",\n    \"href\" : \"/tasks/123\",\n    \"media-type\" : \"application/vnd.restwithscala.task+json\"\n  }, {\n    \"rel\" : \"add\",\n    \"href\" : \"/project/123/note\",\n    \"media-type\" : \"application/vnd.restwithscala.note+json\"\n  } ],\n  \"id\" : 1,\n  \"title\" : \"This is the title\",\n  \"content\" : \"This is the content\",\n  \"assignedTo\" : {\n    \"name\" : \"Me\"\n  },\n  \"notes\" : [ {\n    \"id\" : 1,\n    \"content\" : \"Note 1\"\n  }, {\n    \"id\" : 2,\n    \"content\" : \"Note 2\"\n  } ],\n  \"status\" : {\n    \"status\" : \"new\"\n  }\n}\n```", "```java\nsbt runCH07-Finch\nsbt runCH07-Unfiltered\nsbt runCH07-Scalatra\nsbt runCH07-akkahttp\nsbt runCH07-play\n\n```", "```java\n  val MediaType = \"application/vnd.restwithscala.task+json\"\n  val filter = new SimpleFilter[HttpRequest, HttpResponse] {\n    def apply(req: HttpRequest, \n              service: Service[Request, HttpResponse])\n                                        : Future[HttpResponse] = {\n      req.contentType match {\n        case Some(MediaType) => service.apply(req).map({ resp =>\n          resp.setContentType(MediaType, \"UTF-8\")\n          resp\n        })\n        case Some(_) => Future\n          {BadRequest(s\"Media type not understood, use $MediaType\")}\n        case None => Future\n          {BadRequest(s\"Media type not present, use $MediaType\")}\n      }\n    }\n  }\n\n  val matchTaskFilter: Matcher = \"tasksFilter\"\n  val createTask = CreateNewTask()\n  val createNewTaskFilter = filter andThen createTask\n\n  val taskCreateAPI =\n     Post / matchTaskFilter /> createNewTaskFilter\n```", "```java\nval MediaType = \"application/vnd.restwithscala.task+json\"\n\ncase req @ Path(\"/tasks\") => (req, req) match {\n  case (req @ POST(_), (RequestContentType(MediaType))) => handleCreateTask(req).map(Ok ~> ResponseHeader(\"content-type\",\n                              Set(MediaType)) ~> ResponseString(_))\n```", "```java\nbefore(\"/tasks\") {\n    (request.getMethod, request.contentType) match {\n      case (\"POST\", Some(MediaType)) => // do nothing\n      case (\"POST\", _) => halt(status = 400, reason = \"Unsupported Mimetype\")\n      case (_,_) => // do nothing since it isn't a post\n    }\n  }\n\n  after(\"/task\") {\n    request.getMethod match {\n      case \"POST\" => response.setContentType(MediaType)\n      case _ => // do nothing since it isn't a post\n    }    \n  }\n```", "```java\n  val CustomContentType = \n  MediaType.custom(\"application/vnd.restwithscala.task+json\",\n                    Encoding.Fixed(HttpCharsets.`UTF-8`))\n\n  def mapEntity(entity: ResponseEntity): ResponseEntity = entity match {\n    case HttpEntity.Strict(contentType, data) =>\n      HttpEntity.Strict(CustomContentType, data)\n    case _ => throw new IllegalStateException(\n       \"Unexpected entity type\")\n  }\n```", "```java\n            post {\n                (entity(as[String]) & (extractRequest)) { \n                  (ent, request) =>\n                request.entity.contentType() match {\n                  case ContentType(MediaType(\n                      \"application/vnd.restwithscala.task+json\")\n                      , _) =>\n                    mapRequest({ req => req.copy(entity = \n                      HttpEntity.apply(MediaTypes.`application/json`,\n                      ent)) }) {\n                      (entity(as[Task])) {\n                        task => {\n                          mapResponseEntity(mapEntity) {\n                            complete {\n                              TaskService.insert(task)\n                            }\n                          }\n                        }\n                      }\n                    }\n                  case _ => complete(StatusCodes.BadRequest,\n                                     \"Unsupported mediatype\")\n                }\n            }\n          }\n```", "```java\nobject MediaTypeAction extends ActionBuilder[Request] {\n\n  val MediaType = \"application/vnd.restwithscala.task+json\"\n\n  def invokeBlock[A](request: Request[A], block: (Request[A]) => Future[Result]) = {\n    request.headers.get(\"Content-Type\") match  {\n      case Some(MediaType) => {\n          block(request)\n      }\n      case _ => Future{BadRequest(\"Unsupported mimetype\")}\n    }\n  }\n}\n```", "```java\n  def createTask = MediaTypeAction.async((parse.tolerantJson)) { request =>\n\n    val body = request.body.validate[Task]\n\n    // option defines whether we have a JSON body or not.\n    body match {\n        case JsSuccess(task, _) => TaskService.insert(task).map(\n           b => Ok(Json.toJson(b)).as(MediaTypeAction.MediaType))\n        case JsError(errors) => Future{BadRequest(errors.mkString(\"\\n\"))}\n    }\n  }\n```", "```java\n{\n  \"_links\" : [ {\n    \"rel\" : \"self\",\n    \"href\" : \"/tasks/123\",\n    \"media-type\" : \"application/vnd.restwithscala.task+json\"\n  } ],\n  \"id\" : 1,\n  \"title\" : \"This is the title\",\n  \"content\" : \"This is the content\",\n  \"assignedTo\" : {\n    \"name\" : \"Me\"\n  },\n  \"notes\" : [ {\n    \"id\" : 1,\n    \"content\" : \"Note 1\"\n  }, {\n    \"id\" : 2,\n    \"content\" : \"Note 2\"\n  } ],\n  \"status\" : {\n    \"status\" : \"new\"\n  }\n}\n```", "```java\nimport org.restwithscala.common.model.{Note, Person, Status, Task}\nimport play.api.libs.json._\nimport play.api.libs.functional.syntax._\n\nobject PlayJsonLinks extends App {\n\n  trait HasLinks {\n    val links: List[Links]\n  }\n\n  case class Links(rel: String, href: String, `media-type`: String)\n```", "```java\n  trait LowPriorityWritesInstances {\n\n    // use standard writes for the case classes\n    implicit val statusWrites = Json.writes[Status]\n    implicit val noteWrites = Json.writes[Note]\n    implicit val personWrites = Json.writes[Person]\n    implicit val taskWrites = Json.writes[Task]\n    implicit val linkWrites = Json.writes[Links]\n\n    // and a custom one for the trait\n    implicit object hiPriorityWrites extends OWrites[HasLinks] {\n      def writes(hi: HasLinks) = Json.obj(\"_links\" -> hi.links)\n    }\n  }\n\n  /**\n   * The write instance which we include\n   */\n  object WritesInstances extends LowPriorityWritesInstances {\n  implicit val taskWithLinksWrites = new Writes[Task with HasLinks] {\n      def writes(o: Task with HasLinks) = {\n        (implicitly[OWrites[HasLinks]].writes(o)) ++ \n                    taskWrites.writes(o).as[JsObject]\n      }\n    }\n  }\n```", "```java\nval task = new Task(\n    1, \"This is the title\", \"This is the content\", \n    Some(Person(\"Me\")), List[Note](Note(1,\"Note 1\"), \n       Note(2, \"Note 2\")), Status(\"new\")) with HasLinks {\n         val links = \n             List(Links(\"self\",\n                        \"/tasks/123\",        \n                        \"application/vnd.restwithscala.task+json\"))\n  }\n\n  // import the implicit convertors\n  import WritesInstances._\n\n  println(Json.prettyPrint(Json.toJson(task)))\n}\n```"]