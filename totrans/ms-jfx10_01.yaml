- en: Introducing WebDriver and WebElements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebDriver和Web元素
- en: 'In this chapter, we will look briefly into Selenium, its various components,
    such as Appium, and proceed to the basic components of a web page, including the
    various types of WebElements. We will learn different ways to locate WebElements
    on a web page and execute various user actions on them. We will cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍Selenium，其各种组件，例如Appium，然后继续探讨网页的基本组件，包括各种类型的Web元素。我们将学习不同的方法在网页上定位Web元素并对它们执行各种用户操作。本章将涵盖以下主题：
- en: Various components of Selenium Testing Tools
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium测试工具的各个组件
- en: Setting up a project in Eclipse with Maven and TestNG
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven和TestNG在Eclipse中设置项目
- en: Locating WebElements on a Web Page
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网页上定位Web元素
- en: Actions that can be taken on the WebElements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在Web元素上执行的操作
- en: Selenium is a set of widely popular tools used to automate browsers. It is largely
    used to test applications, but its usages are not limited to testing. It can also
    be used to perform screen scraping and automate repetitive tasks in a browser
    window. Selenium supports automation on all the major browsers, including Google
    Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, Apple Safari, and
    Opera. Selenium 3.0 is now a part of W3C standards and is supported by major browser
    vendors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一套广泛使用的工具，用于自动化浏览器。它主要用于测试应用程序，但其用途不仅限于测试。它还可以用于执行屏幕抓取和在浏览器窗口中自动化重复性任务。Selenium支持所有主要浏览器的自动化，包括Google
    Chrome、Mozilla Firefox、Microsoft Internet Explorer和Edge、Apple Safari和Opera。Selenium
    3.0现在是W3C标准的一部分，并得到主要浏览器供应商的支持。
- en: Selenium Testing Tools
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium测试工具
- en: Selenium 3.0 offers three important tools, Selenium WebDriver, Selenium Server,
    and Selenium IDE. Each of these tools provides features to create, debug, and
    run tests on supported browsers and operating systems. Let's explore each of them
    in detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 3.0提供了三个重要的工具：Selenium WebDriver、Selenium服务器和Selenium IDE。每个工具都提供创建、调试和运行在支持的浏览器和操作系统上的测试的功能。让我们详细探讨每个工具。
- en: Selenium WebDriver
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium WebDriver
- en: 'Selenium WebDriver is the successor of Selenium RC (Remote Control), which
    has been officially deprecated. Selenium WebDriver accepts commands using the
    JSON-Wire protocol (also called Client API) and sends them to a browser launched
    by the specific driver class (such as ChromeDriver, FirefoxDriver, or IEDriver).
    This is implemented through a browser-specific browser driver. It works with the
    following sequence:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver是Selenium RC（远程控制）的继任者，已被官方弃用。Selenium WebDriver使用JSON-Wire协议（也称为客户端API）接受命令，并将它们发送到由特定驱动程序类（如ChromeDriver、FirefoxDriver或IEDriver）启动的浏览器。这是通过特定于浏览器的浏览器驱动程序实现的。它按照以下顺序工作：
- en: The driver listens to the commands from Selenium
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序监听来自Selenium的命令
- en: It converts these commands into the browser's native API
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将这些命令转换为浏览器的原生API
- en: 'The driver takes the result of native commands and sends the result back to
    Selenium:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序接收原生命令的结果，并将结果发送回Selenium：
- en: '![](img/bf64b2d5-cd1c-4c5a-a08d-a08dc873aa4d.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf64b2d5-cd1c-4c5a-a08d-a08dc873aa4d.jpg)'
- en: 'We can use Selenium WebDriver to do the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Selenium WebDriver执行以下操作：
- en: Create robust, browser-based regression automation
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建健壮的基于浏览器的回归自动化
- en: Scale and distribute scripts across many browsers and platforms
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多浏览器和平台上缩放和分发脚本
- en: Create scripts in your favourite programming language
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您喜欢的编程语言创建脚本
- en: Selenium WebDriver offers a collection of language-specific bindings (client
    libraries) to drive a browser. WebDriver comes with a better set of APIs that
    meet the expectations of most developers by being similar to object-oriented programming
    in its implementation. WebDriver is being actively developed over a period of
    time, and you can see many advanced interactions with the web as well as mobile
    applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver提供了一套特定于语言的绑定（客户端库），用于驱动浏览器。WebDriver附带了一组更好的API，通过其实现类似于面向对象编程，满足了大多数开发者的期望。WebDriver正在一段时间内积极开发，你可以看到许多与Web以及移动应用程序的先进交互。
- en: The Selenium Client API is a language-specific Selenium library that provides
    a consistent Selenium API in programming languages such as Java, C#, Python, Ruby,
    and JavaScript. These languages bindings let tests to launch a WebDriver session
    and communicate with the browser or Selenium Server.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium客户端API是一种特定于语言的Selenium库，它为Java、C#、Python、Ruby和JavaScript等编程语言提供了一致的Selenium
    API。这些语言绑定允许测试启动WebDriver会话并与浏览器或Selenium服务器通信。
- en: Selenium Server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium服务器
- en: Selenium Server allows us to run tests on browser instances running on remote
    machines and in parallel, thus spreading a load of testing across several machines.
    We can create a Selenium Grid, where one server runs as the Hub, managing a pool
    of Nodes. We can configure our tests to connect to the Hub, which then obtains
    a node that is free and matches the browser we need to run the tests. The hub
    has a list of nodes that provide access to browser instances, and lets tests use
    these instances similarly to a load balancer. Selenium Grid enables us to execute
    tests in parallel on multiple machines by managing different types of browsers,
    their versions, and operating system configurations centrally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 服务器允许我们在远程机器上运行的浏览器实例上并行运行测试，从而将测试负载分散到多台机器上。我们可以创建一个 Selenium Grid，其中一个服务器作为
    Hub 运行，管理节点池。我们可以配置我们的测试以连接到 Hub，然后 Hub 获取一个空闲的节点，该节点与我们需要运行的测试所需的浏览器相匹配。Hub 有一个节点列表，提供对浏览器实例的访问，并允许测试像负载均衡器一样使用这些实例。Selenium
    Grid 通过集中管理不同类型的浏览器、它们的版本和操作系统配置，使我们能够在多台机器上并行执行测试。
- en: Selenium IDE
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium IDE
- en: 'Selenium IDE is a Firefox add-on that allows users to record, edit, debug,
    and play back tests captured in the *Selenese* format, which was introduced in
    the Selenium Core version. It also provides us with the ability to convert these
    tests into the Selenium RC or Selenium WebDriver format. We can use Selenium IDE
    to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium IDE 是一个 Firefox 插件，允许用户以 *Selenese* 格式记录、编辑、调试和回放测试，该格式是在 Selenium
    核心版本中引入的。它还提供了将测试转换为 Selenium RC 或 Selenium WebDriver 格式的功能。我们可以使用 Selenium IDE
    执行以下操作：
- en: Create quick and simple scripts using record and replay, or use them in exploratory
    testing
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记录和回放创建快速简单的脚本，或在探索性测试中使用它们
- en: Create scripts to aid in automation-aided exploratory testing
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建脚本以辅助自动化辅助的探索性测试
- en: Create macros to perform repetitive tasks on Web pages
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建宏以在网页上执行重复性任务
- en: The Selenium IDE for Firefox stopped working after the Firefox 55 moved to the
    WebExtension format from XPI format and it is currently no longer maintained.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Firefox 55 从 XPI 格式迁移到 WebExtension 格式后，Selenium IDE for Firefox 停止工作，并且目前不再维护。
- en: Differences between Selenium 2 and Selenium 3
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium 2 和 Selenium 3 之间的区别
- en: Before we dive further into Selenium 3, let's understand the differences between
    Selenium 2 and Selenium.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步深入探讨 Selenium 3 之前，让我们先了解 Selenium 2 和 Selenium 之间的区别。
- en: Handling the browser
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理浏览器
- en: As the Selenium WebDriver has been accepted as the W3C Standard, Selenium 3
    brings a number of changes to the browser implementations. All of the major browser
    vendors now support WebDriver specification and provide the necessary features
    along with the browser. For example, Microsoft came with EdgeDriver, and Apple
    supports the SafariDriver implementation. We will see some of these changes later
    in this book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Selenium WebDriver 已被接受为 W3C 标准，Selenium 3 对浏览器实现带来了一系列变化。现在，所有主要的浏览器厂商都支持
    WebDriver 规范，并提供了必要的功能以及浏览器。例如，微软推出了 EdgeDriver，苹果支持 SafariDriver 实现。我们将在本书的后续部分看到一些这些变化。
- en: Having better APIs
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有更好的 API
- en: As W3C-standard WebDriver comes with a better set of APIs, which meet the expectations
    of most developers by being similar to the implementation of object-oriented programming.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 W3C 标准的 WebDriver 提供了一套更好的 API，这些 API 通过类似于面向对象编程的实现来满足大多数开发者的期望。
- en: Having developer support and advanced functionalities
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拥有开发支持和高功能
- en: WebDriver is being actively developed and is now supported by Browser vendors
    per W3C specification; you can see many advanced interactions with the web as
    well as mobile applications, such as File-Handling and Touch APIs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 正在积极开发中，并且现在根据 W3C 规范得到了浏览器厂商的支持；您可以看到许多与网页以及移动应用的高级交互，例如文件处理和触摸 API。
- en: Testing Mobile Apps with Appium
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Appium 测试移动应用
- en: One of the major differences introduced in Selenium 3 was the introduction of
    the `Appium` project. The mobile-testing features that were part of Selenium 2
    are now moved into a separate project named Appium.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Selenium 3 中引入的一个主要区别是引入了 `Appium` 项目。原本属于 Selenium 2 的移动测试功能现在已移至一个名为 Appium
    的独立项目中。
- en: '`Appium` is an open source mobile-automation framework for testing native,
    hybrid, and web mobile apps on iOS and Android platforms using the JSON-Wire protocol
    with Selenium WebDriver. `Appium` replaces the iPhoneDriver and AndroidDriver
    APIs in Selenium 2 that were used to test mobile web applications.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appium` 是一个开源的移动自动化框架，用于使用 JSON-Wire 协议和 Selenium WebDriver 在 iOS 和 Android
    平台上测试原生、混合和 Web 移动应用程序。`Appium` 替换了 Selenium 2 中的 iPhoneDriver 和 AndroidDriver
    API，这些 API 用于测试移动 Web 应用程序。'
- en: '`Appium` enables the use and extension of the existing Selenium WebDriver framework
    to build mobile tests. As it uses Selenium WebDriver to drive the tests, we can
    use any programming language to create tests for a Selenium client library.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Appium` 允许使用和扩展现有的 Selenium WebDriver 框架来构建移动测试。因为它使用 Selenium WebDriver 来驱动测试，所以我们可以使用任何编程语言为
    Selenium 客户端库创建测试。'
- en: Setting up a project in Eclipse with Maven and TestNG using Java
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Java 在 Eclipse 中设置 Maven 和 TestNG 的项目
- en: Selenium WebDriver is a library that helps you automate browsers. However, much
    more is needed when using it for testing and building a test framework or automating
    browsers for non-testing purposes. You will need an Integrated Development Environment
    (**IDE**) or a code editor to create a new Java project and add Selenium WebDriver
    and other dependencies in order to build a testing framework.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium WebDriver 是一个帮助您自动化浏览器的库。然而，当用于测试和构建测试框架或用于非测试目的自动化浏览器时，需要更多。您需要一个集成开发环境（**IDE**）或代码编辑器来创建一个新的
    Java 项目，并添加 Selenium WebDriver 和其他依赖项以构建测试框架。
- en: In the Java development community, Eclipse is a widely-used IDE, as well as
    IntelliJ IDEA and NetBeans. Eclipse provides a feature-rich environment for Selenium
    WebDriver test-development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 开发社区中，Eclipse 是一个广泛使用的 IDE，以及 IntelliJ IDEA 和 NetBeans。Eclipse 为 Selenium
    WebDriver 测试开发提供了一个功能丰富的环境。
- en: Along with Eclipse, Apache Maven provides support for managing the life cycle
    of a test project. Maven is used to define the project structure, dependencies,
    build, and test-management.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Eclipse，Apache Maven 还提供了对测试项目生命周期的管理支持。Maven 用于定义项目结构、依赖项、构建和测试管理。
- en: We can use Eclipse and Maven to build our Selenium WebDriver test framework
    from a single window. Another important benefit of using Maven is that we can
    get all the Selenium library files and their dependencies by configuring the pom.xml
    file. Maven automatically downloads the necessary files from the repository while
    building the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Eclipse 和 Maven 从单个窗口构建我们的 Selenium WebDriver 测试框架。使用 Maven 的另一个重要好处是，我们可以通过配置
    pom.xml 文件来获取所有 Selenium 库文件及其依赖项。Maven 在构建项目时会自动从存储库下载必要的文件。
- en: In this section, we will learn how to configure Eclipse and Maven for the Selenium
    WebDriver test development. Most of the code in this book has been developed in
    Eclipse and Maven.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何配置 Eclipse 和 Maven 以进行 Selenium WebDriver 测试开发。本书中的大部分代码都是在 Eclipse
    和 Maven 中开发的。
- en: You will need Eclipse and Maven to set up the test-development environment.
    Download and set up Maven from [http://maven.apache.org/download.html](http://maven.apache.org/download.html).
    Follow the instructions on the Maven download page (see the Installation Instructions
    section of the page).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要 Eclipse 和 Maven 来设置测试开发环境。从 [http://maven.apache.org/download.html](http://maven.apache.org/download.html)
    下载并设置 Maven。遵循 Maven 下载页面上的说明（请参阅页面上的安装说明部分）。
- en: Download and set up Eclipse IDE for Java Developers from [https://eclipse.org/downloads/](https://eclipse.org/downloads/)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://eclipse.org/downloads/](https://eclipse.org/downloads/) 下载并设置 Eclipse
    IDE for Java Developers。
- en: Along with Eclipse and Maven, we will also use TestNG as a testing framework
    for our project. The TestNG library will help us define test cases, test fixtures,
    and assertions. We need to install the TestNG plugin for Eclipse via Eclipse Marketplace.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Eclipse 和 Maven，我们还将使用 TestNG 作为项目的测试框架。TestNG 库将帮助我们定义测试用例、测试夹具和断言。我们需要通过
    Eclipse Marketplace 安装 TestNG 插件。
- en: 'Let''s configure Eclipse with Maven to develop Selenium WebDriver tests using
    the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤配置 Eclipse 和 Maven 以使用 Selenium WebDriver 开发测试：
- en: Launch the Eclipse IDE.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Eclipse IDE。
- en: Create a new project by selecting File | New | Other from the Eclipse Main Menu.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 Eclipse 主菜单中的文件 | 新建 | 其他来创建一个新的项目。
- en: 'On the New dialog, select Maven | Maven Project, as shown in the following
    screenshot, and click Next:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建”对话框中，选择 Maven | Maven 项目，如图所示，然后点击“下一步”：
- en: '![](img/84b40e3b-fe30-4866-a448-47dec065c1ef.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84b40e3b-fe30-4866-a448-47dec065c1ef.png)'
- en: 'The New Maven Project dialog will be displayed. Select the Create a simple
    project (skip archetype selection) checkbox and click on the Next button, as shown
    in the following screenshot:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新建Maven项目对话框将显示。选择创建简单项目（跳过存档选择）复选框，然后点击下一步按钮，如图所示：
- en: '![](img/8abd601e-4710-48fb-aa46-8bd4d9648eb6.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8abd601e-4710-48fb-aa46-8bd4d9648eb6.png)'
- en: 'On the New Maven Project dialog box, enter ***com.example*** in the Group Id:
    textbox and ***chapter1*** in the Artifact Id: textbox. You can also add a name
    and description. Click on the Finish button, as shown in the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建Maven项目对话框中，在组ID:文本框中输入***com.example***，在工件ID:文本框中输入***chapter1***。您还可以添加一个名称和描述。点击完成按钮，如图所示：
- en: '![](img/aaaed783-5ef5-4e1e-b32b-dd1a4c704d52.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaaed783-5ef5-4e1e-b32b-dd1a4c704d52.png)'
- en: 'Eclipse will create the ***chapter1*** project with a structure (in Package
    Explorer) similar to the one shown in the following screenshot:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eclipse将创建名为***chapter1***的项目，其结构（在包资源管理器中）类似于以下截图所示：
- en: '![](img/59e3dbc7-75cc-4827-8cc6-8728ffe6551e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59e3dbc7-75cc-4827-8cc6-8728ffe6551e.png)'
- en: 'Select pom.xml from Package Explorer. This will open the pom.xml file in the
    editor area with the **Overview** tab open. Select the **pom.xml** tab next to
    the Overview tab, as shown in the following screenshot:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从包资源管理器中选择pom.xml。这将打开编辑器区域中的pom.xml文件，并打开**概览**选项卡。选择位于概览选项卡旁边的**pom.xml**选项卡，如图所示：
- en: '![](img/febf79fa-3b4c-4f59-9314-393375c11bc8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/febf79fa-3b4c-4f59-9314-393375c11bc8.png)'
- en: 'Add the Selenium WebDriver and TestNG dependencies highlighted in the following
    code snippet to pom.xml in the between `project` node:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段中突出显示的Selenium WebDriver和TestNG依赖项添加到pom.xml中的`project`节点之间：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Select ***src/test/java*** in Package Explorer and right-click on it to show
    the menu. Select New | Other, as shown in the following screenshot:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包资源管理器中选择***src/test/java***，然后右键单击以显示菜单。选择新建 | 其他，如图所示：
- en: '![](img/4dfc74b9-5e7a-4bc8-9464-462c1f3ee2eb.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dfc74b9-5e7a-4bc8-9464-462c1f3ee2eb.png)'
- en: 'Select the TestNG | TestNG class from the Select a wizard dialog, as shown
    in the following screenshot:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从选择向导对话框中选择TestNG | TestNG类，如图所示：
- en: '![](img/686fa9e7-cbef-45ac-8626-24e569aac808.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/686fa9e7-cbef-45ac-8626-24e569aac808.png)'
- en: 'On the New TestNG class dialog box, enter ***/chapter1/src/test/java*** in
    the Source folder: field. Enter com.example in the Package name: field. Enter
    NavigationTest in the Class name: field. Select the @BeforeMethod and @AfterMethod
    checkboxes and add `src/test/resources/suites/testng.xml` in the XML suite file:
    field. Click on the Finish button:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新TestNG类对话框中，在源文件夹:字段中输入***/chapter1/src/test/java***。在包名:字段中输入com.example。在类名:字段中输入NavigationTest。选择@BeforeMethod和@AfterMethod复选框，并在XML套件文件:字段中添加`src/test/resources/suites/testng.xml`。点击完成按钮：
- en: '![](img/5548a321-387e-4b67-8c87-9431b4c8b168.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5548a321-387e-4b67-8c87-9431b4c8b168.png)'
- en: 'This will create the ***NavigationTest.java*** class in the com.example package
    with TestNG annotations such as `@Test`, `@BeforeMethod`, and `@AfterMethod`,
    and the `beforeMethod` and `afterMethod` methods:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在com.example包中创建名为***NavigationTest.java***的类，并使用TestNG注解如`@Test`、`@BeforeMethod`和`@AfterMethod`，以及`beforeMethod`和`afterMethod`方法：
- en: '![](img/6c71fcdc-148a-494f-8f12-47723f3bd1fc.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c71fcdc-148a-494f-8f12-47723f3bd1fc.png)'
- en: 'Modify the `NavigationTest` class with following code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码修改`NavigationTest`类：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, three methods are added as part of the `NavigationTest`
    class. We also declared a `WebDriver driver;` instance variable, which we will
    use later in the test to launch a browser and navigate to the site.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，添加了三个方法作为`NavigationTest`类的一部分。我们还声明了一个`WebDriver driver;`实例变量，我们将在测试中稍后使用它来启动浏览器并导航到网站。
- en: '`beforeMethod()`, which is annotated with the `@BeforeMethod` TestNG annotation,
    will execute before the test method. It will set the path of the *chromedriver*
    executable required by Google Chrome. It will then instantiate the driver variable
    using the `ChromeDriver()` class. This will launch a new Google Chrome window
    on the screen.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeMethod()`方法，被`@BeforeMethod` TestNG注解标记，将在测试方法之前执行。它将设置Google Chrome所需的*chromedriver*可执行文件的路径。然后使用`ChromeDriver()`类实例化driver变量。这将启动屏幕上的新Google
    Chrome窗口。'
- en: The next method, `navigateToAUrl()`, annotated with the `@Test` annotation is
    the test method. We will call the `get()` method of the WebDriver interface passing
    the URL of the application. This will navigate to the site in the browser. We
    will check the title of the page by calling TestNG's `Assert.assertEquals` method
    and the `getTitle()` method of the WebDriver interface.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法，`navigateToAUrl()`，被`@Test`注解标记的是测试方法。我们将通过 WebDriver 接口的`get()`方法传递应用程序的
    URL。这将导航到浏览器中的网站。我们将通过调用 TestNG 的`Assert.assertEquals`方法和 WebDriver 接口的`getTitle()`方法来检查页面标题。
- en: Lastly, `afterMethod()` is annotated with the `@AfterMethod` TestNG annotation
    will close the browser window.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`afterMethod()`被`@AfterMethod` TestNG 注解标记，将关闭浏览器窗口。
- en: We need to download and copy the chromedriver executable from [https://sites.google.com/a/chromium.org/chromedriver/downloads](https://sites.google.com/a/chromium.org/chromedriver/downloads).
    Download the appropriate version based on the Google Chrome browser version installed
    on your computer as well as the operating system. Copy the executable file in
    the `/src/test/resources/ drivers` folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 [https://sites.google.com/a/chromium.org/chromedriver/downloads](https://sites.google.com/a/chromium.org/chromedriver/downloads)
    下载并复制 chromedriver 可执行文件。根据您计算机上安装的 Google Chrome 浏览器版本以及操作系统下载适当的版本。将可执行文件复制到`/src/test/resources/drivers`文件夹中。
- en: 'To run the tests, right-click in the code editor and select Run As | TestNG
    Test, as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请在代码编辑器中右键单击并选择“运行 As | TestNG 测试”，如下截图所示：
- en: '![](img/c6a4dc78-ebbf-4123-807b-4434c06a8991.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6a4dc78-ebbf-4123-807b-4434c06a8991.png)'
- en: 'This will launch a new Google Chrome browser window and navigate to the site.
    The test will validate the page title and the browser window will be closed at
    the end of the test. The TestNG Plugin will display results in Eclipse:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个新的 Google Chrome 浏览器窗口并导航到该网站。测试将验证页面标题，并在测试结束时关闭浏览器窗口。TestNG 插件将在 Eclipse
    中显示结果：
- en: '![](img/32793ec0-2892-40f0-bd7e-4506701ddc11.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32793ec0-2892-40f0-bd7e-4506701ddc11.png)'
- en: You can download the example code files for all the Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    have purchased this book elsewhere, you can visit http://www.packtpub. com/support
    and register to have the files emailed directly to you. The example code is also
    hosted at [https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition](https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 http://www.packtpub.com/support 并注册，以便将文件直接通过电子邮件发送给您。示例代码也托管在
    [https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition](https://github.com/PacktPublishing/Selenium-WebDriver-3-Practical-Guide-Second-Edition)
- en: WebElements
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebElements
- en: 'A web page is composed of many different types of HTML elements, such as links,
    textboxes, dropdown buttons, a body, labels, and forms. These are called WebElements
    in the context of WebDriver. Together, these elements on a web page will achieve
    the user functionality. For example, let''s look at the HTML code of the login
    page of a website:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页由许多不同类型的 HTML 元素组成，例如链接、文本框、下拉按钮、主体、标签和表单。在 WebDriver 的上下文中，这些元素被称为 WebElements。这些元素共同构成了网页的用户功能。例如，让我们看看一个网站登录页面的
    HTML 代码：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding HTML code, there are different types of WebElements, such
    as `<html>`, `<body>`, `<form>`, `<label>`, `<input>`, and `<a>`, which together
    make a web page provide the Login feature for the user. Let''s analyze the following
    WebElement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 HTML 代码中，存在不同类型的 WebElements，例如 `<html>`、`<body>`、`<form>`、`<label>`、`<input>`
    和 `<a>`，这些元素共同构成了一个网页，为用户提供登录功能。让我们分析以下 WebElement：
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `<label>` is the start tag of the WebElement label. `Enter Username:`
    is the text present on the `label` element. Finally, `</label>` is the end tag,
    which indicates the end of a WebElement.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<label>`是 WebElement 标签的开始标签。`Enter Username:`是`label`元素上的文本。最后，`</label>`是结束标签，表示
    WebElement 的结束。
- en: 'Similarly, take another WebElement:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，再取另一个 WebElement：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, `type` and `name` are the attributes of the WebElement
    `input` with the `text` and `Username` values, respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`type`和`name`是具有`text`和`Username`值的`input` WebElement 的属性。
- en: UI-automation using Selenium is mostly about locating these WebElements on a
    web page and executing user actions on them. In the rest of the chapter, we will
    use various methods to locate WebElements and execute relevant user actions on
    them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Selenium进行UI自动化主要涉及在网页上定位这些Web元素并对其执行用户操作。在本章的其余部分，我们将使用各种方法来定位Web元素并对其执行相关的用户操作。
- en: Locating WebElements using WebDriver
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WebDriver定位Web元素
- en: 'Let''s start this section by automating the Search feature from the Homepage
    of the demo application, [http://demo-store.seleniumacademy.com/](http://demo-store.seleniumacademy.com/),
    which involves navigating to the homepage, typing the search text in the textbox,
    and executing the search. The code is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从自动化演示应用程序主页上的搜索功能开始这一部分，该应用程序的主页地址为[http://demo-store.seleniumacademy.com/](http://demo-store.seleniumacademy.com/)，这涉及到导航到主页，在文本框中输入搜索文本，并执行搜索。以下是相应的代码：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, there are three new things that are highlighted, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，以下有三点新内容被突出显示：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: They are the `findElement()` method, the `By.name()` method, and the `WebElement`
    interface. The `findElement()` and `By()` methods instruct WebDriver to locate
    a `WebElement` on a web page, and once found, the `findElement()` method returns
    the `WebElement` instance of that element. Actions, such as click and type, are
    performed on a returned `WebElement` using the methods declared in the `WebElement`
    interface, which will be discussed in detail in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是`findElement()`方法、`By.name()`方法和`WebElement`接口。`findElement()`和`By()`方法指示WebDriver在网页上定位一个`WebElement`，一旦找到，`findElement()`方法就返回该元素的`WebElement`实例。使用`WebElement`接口中声明的各种方法在返回的`WebElement`上执行操作，如点击和输入，这些方法将在下一节中详细讨论。
- en: The findElement method
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findElement`方法'
- en: 'In UI automation, locating an element is the first step before executing any
    user actions on it. WebDriver''s `findElement()` method is a convenient way to
    locate an element on the web page. According to WebDriver''s Javadoc ([http://selenium.googlecode.com/git/docs/api/java/index.html](http://seleniumhq.github.io/selenium/docs/api/java/index.html)),
    the method declaration is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI自动化中，定位元素是在对它执行任何用户操作之前的第一个步骤。WebDriver的`findElement()`方法是在网页上定位元素的一种便捷方式。根据WebDriver的Javadoc([http://selenium.googlecode.com/git/docs/api/java/index.html](http://seleniumhq.github.io/selenium/docs/api/java/index.html))，该方法的声明如下：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, the input parameter for the `findElement()` method is the `By` instance.
    The `By` instance is a WebElement-locating mechanism. There are eight different
    ways to locate a WebElement on a web page. We will see each of these eight methods
    later in the chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`findElement()`方法的输入参数是`By`实例。`By`实例是一种定位`WebElement`的机制。有八种不同的方式可以在网页上定位一个`WebElement`。我们将在本章后面看到这八种方法。
- en: The return type of the `findElement()` method is the WebElement instance that
    represents the actual HTML element or component of the web page. The method returns
    the first WebElement that the driver comes across that satisfies the locating-mechanism
    condition. This WebElement instance will act as a handle to that component from
    then on. Appropriate actions can be taken on that component by the test-script
    developer using this returned WebElement instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`findElement()`方法的返回类型是表示网页实际HTML元素或组件的`WebElement`实例。该方法返回第一个满足定位机制条件的`WebElement`。从那时起，此`WebElement`实例将作为该组件的句柄。测试脚本开发者可以通过此返回的`WebElement`实例对该组件采取适当的操作。'
- en: If WebDriver doesn't find the element, it throws a runtime exception named `NoSuchElementException`,
    which the invoking class or method should handle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果WebDriver找不到元素，它将抛出一个名为`NoSuchElementException`的运行时异常，调用类或方法应该处理此异常。
- en: The findElements method
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`findElements`方法'
- en: 'For finding multiple elements matching the same locator criteria on a web page,
    the `findElements()` method can be used. It returns a list of WebElements found
    for a given locating mechanism. The method declaration of the `findElements()`
    method is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在网页上找到符合相同定位条件的多元素，可以使用`findElements()`方法。该方法返回一个包含通过给定定位机制找到的Web元素的列表。`findElements()`方法的声明如下：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The input parameter is the same as the `findElement()` method, which is an instance
    of the `By` class. The difference lies in the return type. Here, if no element
    is found, an empty list is returned and if there are multiple WebElements present
    that satisfy the locating mechanism, all of them are returned to the caller in
    a list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输入参数与 `findElement()` 方法相同，它是一个 `By` 类的实例。区别在于返回类型。这里，如果没有找到元素，则返回空列表；如果有多个满足定位机制的
    WebElements 存在，则将它们全部以列表形式返回给调用者。
- en: Inspecting Elements with Developer Tools
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发者工具检查元素
- en: Before we start exploring how to find elements on a page and what locator mechanism
    to use, we need to look at the HTML code of the page to understand the Document
    Object Model (**DOM**) tree, what properties or attributes are defined for the
    elements displayed on the page, and how JavaScript or AJAX calls are made from
    the application. browsers use the HTML code written for the page to render visual
    elements in the browser window. It uses other resources, including JavaScript,
    CSS, and images, to decide on the look, feel, and behavior of these elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索如何在页面上查找元素以及使用什么定位机制之前，我们需要查看页面的 HTML 代码，以了解文档对象模型（**DOM**）树，页面显示的元素定义了哪些属性或属性，以及应用程序如何通过浏览器使用为页面编写的
    HTML 代码来渲染视觉元素。它使用其他资源，包括 JavaScript、CSS 和图像，来决定这些元素的外观、感觉和行为。
- en: 'Here is an example of a login page of the demo application and the HTML code
    written to render this page in a browser, as displayed in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示应用程序的登录页面示例以及用于在浏览器中渲染此页面的 HTML 代码，如图下所示：
- en: '![](img/abf78c19-fab7-46a2-9ad3-51fe0ffa8758.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abf78c19-fab7-46a2-9ad3-51fe0ffa8758.png)'
- en: We need tools that can display the HTML code of the page in a structured and
    easy-to-understand format. Almost all browsers now offer Developer tools to inspect
    the structure of the page and associated resources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够以结构化和易于理解的方式显示页面 HTML 代码的工具。现在几乎所有浏览器都提供了开发者工具来检查页面结构和相关资源。
- en: Inspecting pages and elements with Mozilla Firefox
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mozilla Firefox 检查页面和元素
- en: 'The newer versions of Mozilla Firefox provide built-in ways to inspect the
    page and elements. To inspect an element from the page, move the mouse over the
    desired element and right-click to open the pop-up menu. Select the **Inspect
    Element** option, as shown in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla Firefox 的新版本提供了内置的方式来检查页面和元素。要检查页面上的元素，将鼠标移至所需元素上并右键点击以打开弹出菜单。选择**检查元素**选项，如图下所示：
- en: '![](img/f81e2d68-fb90-4d4f-b186-2fa8594c3543.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f81e2d68-fb90-4d4f-b186-2fa8594c3543.png)'
- en: 'This will display the Inspector tab with the HTML code in a tree format with
    the selected element highlighted, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示带有突出显示所选元素的 HTML 代码的树格式检查器标签页，如图下所示：
- en: '![](img/4058e793-e9b3-407f-8918-7a0b90aaf34b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4058e793-e9b3-407f-8918-7a0b90aaf34b.png)'
- en: 'Using Inspector, we can also validate the XPath or CSS Selectors using the
    search box shown in the Inspector section. Just enter the XPath or CSS Selector
    and Inspector will highlight the elements that match the expression, as shown
    in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检查器，我们还可以使用检查器部分显示的搜索框验证 XPath 或 CSS 选择器。只需输入 XPath 或 CSS 选择器，检查器就会突出显示与表达式匹配的元素，如图下所示：
- en: '![](img/1a408ea7-82f2-4d2e-b169-75b78bc32142.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a408ea7-82f2-4d2e-b169-75b78bc32142.png)'
- en: 'The Developer tools provide various other debugging features. It also generates
    XPath and CSS selectors for elements. For this, select the desired element in
    the tree, right-click, and select the Copy > XPath or Copy > CSS Path option from
    the pop-up menu, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具还提供了各种其他调试功能。它还会为元素生成 XPath 和 CSS 选择器。为此，在树中选择所需的元素，右键点击，并从弹出菜单中选择复制 >
    XPath 或复制 > CSS 路径选项，如图下所示：
- en: '![](img/71a679b3-2ce1-4546-9e1e-cf63a696088f.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/71a679b3-2ce1-4546-9e1e-cf63a696088f.png)'
- en: This will paste the suggested XPath or CSS selector value to the clipboard to
    be used later with the `findElement()` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将建议的 XPath 或 CSS 选择器值粘贴到剪贴板，以便稍后与 `findElement()` 方法一起使用。
- en: Inspecting pages and elements in Google Chrome with Developer Tools
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发者工具在 Google Chrome 中检查页面和元素
- en: 'Similar to Mozilla Firefox, Google Chrome also provides a built-in feature
    to inspect pages and elements. We can move the mouse over a desired element on
    the page, right-click to open the pop-up menu, and then select the Inspect element
    option. This will open Developer tools in the browser, which displays information
    similar to that of Firefox, as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mozilla Firefox类似，Google Chrome也提供了一个内置功能来检查页面和元素。我们可以将鼠标悬停在页面上的一个所需元素上，右键单击以打开弹出菜单，然后选择“检查元素”选项。这将打开浏览器中的开发者工具，显示与Firefox类似的信息，如下面的截图所示：
- en: '![](img/da72f733-a2ee-4bff-a6b8-be04dcff9d01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da72f733-a2ee-4bff-a6b8-be04dcff9d01.png)'
- en: 'Similar to Firefox, we can also test XPath and CSS Selectors in Google Chrome
    Developer tools. Press *Ctrl + F* (on Mac, use *Command + F*) in the Elements
    tab. This will display a search box. Just enter *XPath* or *CSS Selector*, and
    matching elements will be highlighted in the tree, as shown in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与Firefox类似，我们也可以在Google Chrome开发者工具中测试XPath和CSS选择器。在元素标签页中按*Ctrl + F*（在Mac上使用*Command
    + F*）。这将显示一个搜索框。只需输入*XPath*或*CSS Selector*，匹配的元素将在树中突出显示，如下面的截图所示：
- en: '![](img/67ecbaf8-2338-47da-b959-8c993e44ecce.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67ecbaf8-2338-47da-b959-8c993e44ecce.png)'
- en: Chrome Developer Tools also provides a feature where you can get the XPath for
    an element by right-clicking on the desired element in the tree and selecting
    the Copy XPath option from the pop-up menu.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具还提供了一个功能，您可以通过在树中右键单击所需的元素并从弹出菜单中选择“复制XPath”选项来获取元素的XPath。
- en: Similar to Mozilla Firefox and Google Chrome, you will find similar Developer
    tools in any major browser, including Microsoft Internet Explorer and Edge.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与Mozilla Firefox和Google Chrome类似，您将在任何主要浏览器中找到类似的开发者工具，包括Microsoft Internet
    Explorer和Edge。
- en: Browser developer tools come in really handy during the test-script development.
    These tools will help you to find the locator details for the elements with which
    you need to interact as part of the test. These tools parse the code for a page
    and display the information in a hierarchal tree.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器开发者工具在测试脚本开发过程中非常有用。这些工具可以帮助您找到需要交互的元素的位置详情，作为测试的一部分。这些工具解析页面代码，并以层次树的形式显示信息。
- en: WebElements on a web page may not have all the attributes declared. It is up
    to the developer of the test script to select the attribute that uniquely identifies
    the WebElement on the web page for the automation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 网页上的WebElements可能不会声明所有属性。选择用于在网页上唯一标识WebElement的属性的测试脚本的开发者。
- en: Using the By locating mechanism
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`By`定位机制
- en: By is the locating mechanism passed to the `findElement()` method or the `findElements()`
    method to fetch the respective WebElement(s) on a web page. There are eight different
    locating mechanisms; that is, eight different ways to identify
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`By`是通过`findElement()`方法或`findElements()`方法传递给定位机制，以在网页上获取相应的WebElement（s）。有八种不同的定位机制；也就是说，有八种不同的识别方式'
- en: an HTML element on a web page. They are located by ID, Name, ClassName, TagName,
    LinkText, PartialLinkText, XPath, and CSS Selector.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上的HTML元素。它们通过ID、Name、ClassName、TagName、LinkText、PartialLinkText、XPath和CSS
    Selector定位。
- en: The By.id() method
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`By.id()`方法'
- en: 'On a web page, each element is uniquely identified by an ID attribute, which
    is optionally provided. An ID can be assigned manually by the developer of the
    web application or left to be dynamically generated by the application. Dynamically-generated
    IDs can be changed on every page refresh or over a period of time. Now, consider
    the HTML code of the Search box:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上，每个元素都通过一个ID属性唯一标识，该属性是可选的。ID可以由Web应用程序的开发者手动分配，或者由应用程序动态生成。动态生成的ID可以在每次页面刷新或一段时间内更改。现在，考虑搜索框的HTML代码：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, the `id` attribute value of the search box is `search`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，搜索框的`id`属性值为`search`。
- en: 'Let''s see how to use the ID attribute as a locating mechanism to find the
    Search box:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用ID属性作为定位机制来查找搜索框：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In preceding code, we used the `By.id()` method and the search box's `id` attribute
    value to find the element.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`By.id()`方法和搜索框的`id`属性值来查找元素。
- en: 'Here, try to use the `By.id` identifier, and use the name value (that is, `q`)
    instead of the `id` value (that is, `search`). Modify line three as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尝试使用`By.id`标识符，并使用名称值（即`q`）而不是`id`值（即`search`）。将第三行修改如下：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The test script will fail to throw an exception, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 测试脚本将无法抛出异常，如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: WebDriver couldn't find an element by `id` whose value is `q`. Thus, it throws
    an exception saying `NoSuchElementException`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver无法通过`id`找到值为`q`的元素。因此，它抛出一个异常，表示`NoSuchElementException`。
- en: The By.name() method
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.name()方法
- en: 'As seen earlier, every element on a web page has many attributes. Name is one
    of them. For instance, the HTML code for the Search box is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网页上的每个元素都有许多属性。名称就是其中之一。例如，搜索框的HTML代码如下：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, `name` is one of the many attributes of the search box, and its value
    is `q`. If we want to identify this search box and set a value in it in your test
    script, the code will look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`是搜索框的许多属性之一，其值为`q`。如果我们想在测试脚本中识别这个搜索框并在其中设置值，代码将如下所示：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you observe line four, the locating mechanism used here is `By.name` and
    the name is `q`. So, where did we get this name from? As discussed in the previous
    section, it is the browser developer tools that helped us get the name of the
    button. Launch Developer tools and use the inspect elements widget to get the
    attributes of an element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您观察第四行，这里使用的定位机制是`By.name`，名称是`q`。那么这个名称是从哪里来的呢？如前所述，是浏览器开发者工具帮助我们获取按钮名称的。启动开发者工具并使用检查元素小部件来获取元素的属性。
- en: The By.className() method
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.className()方法
- en: Before we discuss the `className()` method, we have to talk a little about style
    and CSS. Every HTML element on a web page, generally, is styled by the web page
    developer or designer. It is not mandatory that each element should be styled,
    but they generally are to make the page appealing to the end user.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论`className()`方法之前，我们必须稍微谈谈样式和CSS。网页上的每个HTML元素通常都是由网页开发者或设计师进行样式的。并不是每个元素都必须有样式，但它们通常都有，以便使页面对最终用户更具吸引力。
- en: 'So, in order to apply styles to an element, they can be declared directly in
    the element tag, or placed in a separate file called the CSS file and can be referenced
    in the element using the `class` attribute. For instance, a style attribute for
    a button can be declared in a CSS file as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了将样式应用于一个元素，它们可以直接在元素标签中声明，或者放在一个单独的文件中，称为CSS文件，并可以通过`class`属性在元素中引用。例如，按钮的样式属性可以在CSS文件中声明如下：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, this style can be applied to the button element in a web page as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种样式可以按照以下方式应用于网页中的按钮元素：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, `buttonStyle` is used as the value for the `class` attribute of the button
    element, and it inherits all the styles declared in the CSS file. Now, let's try
    this on our Homepage. We will try to make WebDriver identify the search button
    using its class name and click on it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`buttonStyle`被用作按钮元素的`class`属性的值，并继承CSS文件中声明的所有样式。现在，让我们在我们的主页上尝试这个操作。我们将尝试使用按钮的类名来让WebDriver识别搜索按钮并点击它。
- en: 'First, in order to get the class name of the search button, as we know, we
    will use Developers tools to fetch it. After getting it, change the location mechanism
    to `By.className` and specify the class attribute value in it. The code for that
    is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了获取搜索按钮的类名，正如我们所知，我们将使用开发者工具来获取它。获取后，将定位机制更改为`By.className`，并在其中指定类属性值。相应的代码如下：
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we have used the `By.className` locating mechanism by
    passing the class attribute value to it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过传递类属性值给`By.className`定位机制来使用`By.className`定位机制。
- en: 'Sometimes, an element might have multiple values given for the `class` attribute.
    For example, the Search button has *button* and *search-button* values specified
    in the `class` attribute in the following HTML snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个元素的`class`属性可能会有多个值。例如，以下HTML片段中搜索按钮的`class`属性指定了`button`和`search-button`值：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have to use one of the values of the `class` attribute with the `By.className`
    method. In this case, we can either use *button* or *search-button*, whichever
    uniquely identifies the element.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`class`属性的某个值与`By.className`方法一起使用。在这种情况下，我们可以使用`button`或`search-button`中的任何一个，只要它能唯一标识元素即可。
- en: The By.linkText() method
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.linkText()方法
- en: 'As the name suggests, the `By.linkText` locating mechanism can only be used
    to identify the HTML links. Before we start discussing how WebDriver can be commanded
    to identify a link element using link text, let''s see what an HTML link element
    looks like. The HTML link elements are represented on a web page using the `<a>`
    tag, an abbreviation for the anchor tag. A typical anchor tag looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`By.linkText`定位机制只能用来识别HTML链接。在我们开始讨论如何使用WebDriver通过链接文本来识别链接元素之前，让我们看看HTML链接元素的样子。HTML链接元素在网页上使用`<a>`标签表示，这是锚点标签的缩写。一个典型的锚点标签看起来像这样：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, `href` is the link to a different page where your web browser will take
    you when you click on the link. So, the preceding HTML code when rendered by the
    browser looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`href`是链接到另一个页面，当你点击链接时，你的网络浏览器会带你到那里。所以，浏览器渲染的前面的HTML代码看起来是这样的：
- en: '![](img/b54093b6-14c6-4354-b0b7-cd34a68d245e.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b54093b6-14c6-4354-b0b7-cd34a68d245e.png)'
- en: 'This **MY ACCOUNT** is the link text. So the `By.linkText` locating mechanism
    uses this text on an anchor tag to identify the WebElement. The code would look
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个**我的账户**是链接文本。所以`By.linkText`定位机制使用这个文本在锚点标签上以识别WebElement。代码看起来是这样的：
- en: '[PRE20]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, the `By.linkText` locating mechanism is used to identify the **MY ACCOUNT**
    link.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`By.linkText`定位机制来识别**我的账户**链接。
- en: The `linkText` and `partialLinkText` methods are case-sensitive.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkText`和`partialLinkText`方法是区分大小写的。'
- en: The By.partialLinkText() method
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`By.partialLinkText()`方法'
- en: 'The `By.partialLinkText` locating mechanism is an extension of the `By.linkText`
    locator. If you are not sure of the entire link text or want to use only part
    of the link text, you can use this locator to identify the link element. So, let''s
    modify the previous example to use only partial text on the link; in this case,
    we will use Privacy from the Privacy Policy link in the site footer:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.partialLinkText`定位机制是`By.linkText`定位器的扩展。如果你不确定整个链接文本或者只想使用链接文本的一部分，你可以使用这个定位器来识别链接元素。所以，让我们修改之前的例子，只使用链接的部分文本；在这种情况下，我们将使用网站页脚中的隐私政策链接中的Privacy：'
- en: '![](img/1dcdff51-63dc-4c09-9b1c-4c85b3a9777a.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dcdff51-63dc-4c09-9b1c-4c85b3a9777a.png)'
- en: 'The code would look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来是这样的：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What happens if there are multiple links whose text has *Privacy* in it? That
    is a question for the `findElement()` method rather than the locator. Remember
    when we discussed the `findElement()` method earlier, it will return only the
    first WebElement that it comes across. If you want all the WebElements that contain
    *Privacy* in its link text, use the `findElements()` method, which will return
    a list of all those elements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个链接的文本包含*隐私*这个词，会发生什么？这是一个关于`findElement()`方法而不是定位器的问题。记得我们之前讨论`findElement()`方法时，它只会返回它遇到的第一个WebElement。如果你想找到所有包含*隐私*的链接文本的WebElement，请使用`findElements()`方法，它将返回所有这些元素的列表。
- en: Use WebDriver's `findElements()` method if you think you need all the WebElements
    that satisfy a locating-mechanism condition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为你需要所有满足定位机制条件的WebElement，请使用WebDriver的`findElements()`方法。
- en: The By.tagName() method
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`By.tagName()`方法'
- en: Locating an element by tag name is slightly different from the locating mechanisms
    we saw earlier. For example, on a Homepage, if you search for an element with
    the `button` tag name, it will result in multiple WebElements because there are
    nine buttons present on the Homepage. So, it is always advisable to use the `findElements()`
    method rather than the `findElement()` method when trying to locate elements using
    tag names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签名定位元素与之前我们看到的定位机制略有不同。例如，在主页面上，如果你使用`button`标签名搜索元素，它将导致多个WebElements，因为主页面上有九个按钮。因此，在尝试使用标签名定位元素时，始终建议使用`findElements()`方法而不是`findElement()`方法。
- en: 'Let''s see how the code looks when a search for the number of links present
    on a Homepage is made:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当搜索主页上链接数量时的代码看起来是什么样子：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we have used the `By.tagName` locating mechanism and
    the `findElements()` method, which return a list of all the links, that is, the
    `a` anchor tags defined on the page. On line five, we printed the size of the
    list, and then printed text of only links where the text has been provided. We
    use the Java 8 Stream API to filter the element list and output the text value
    by calling the `getText()` method. This will generate the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了 `By.tagName` 定位机制和 `findElements()` 方法，它返回所有链接的列表，即页面上定义的 `a`
    锚标签。在第五行，我们打印了列表的大小，然后只打印了提供文本的链接文本。我们使用 Java 8 Stream API 通过调用 `getText()` 方法来过滤元素列表并输出文本值。这将生成以下输出：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The By.xpath() method
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.xpath() 方法
- en: 'WebDriver uses **XPath** to identify a WebElement on the web page. Before we
    see how it does that, let''s quickly look at the syntax for XPath. XPath is a
    short name for the XML path, the query language used for searching XML documents.
    The HTML for our web page is also one form of the XML document. So, in order to
    identify an element on an HTML page, we need to use a specific XPath syntax:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: WebDriver 使用 **XPath** 来识别网页上的 WebElement。在我们看到它是如何做到这一点之前，让我们快速看一下 XPath 的语法。XPath
    是 XML 路径的简称，是用于搜索 XML 文档的查询语言。我们网页的 HTML 也是 XML 文档的一种形式。因此，为了在 HTML 页面上识别一个元素，我们需要使用特定的
    XPath 语法：
- en: The root element is identified as `//`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根元素被标识为 `//`。
- en: To identify all the div elements, the syntax will be `//div`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别所有 div 元素，语法将是 `//div`。
- en: To identify the link tags that are within the div element, the syntax will be
    `//div/a`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别位于 div 元素内的链接标签，语法将是 `//div/a`。
- en: To identify all the elements with a tag, we use *. The syntax will be `//div/*`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别所有具有标签的元素，我们使用 `*`。语法将是 `//div/*`。
- en: To identify all the div elements that are at three levels down from the root,
    we can use `//*/*/div`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别从根元素向下三个级别的所有 div 元素，我们可以使用 `//*/*/div`。
- en: To identify specific elements, we use attribute values of those elements, such
    as `//*/div/a[@id='attrValue']`, which will return the anchor element. This element
    is at the third level from the root within a `div` element and has an `id` value
    of `attrValue`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别特定元素，我们使用这些元素的属性值，例如 `//*/div/a[@id='attrValue']`，这将返回锚元素。该元素位于根元素内部的第三个级别，并且具有
    `id` 值为 `attrValue`。
- en: So, we need to pass the XPath expression to the `By.xpath` locating mechanism
    to make it identify our target element.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将 XPath 表达式传递给 `By.xpath` 定位机制，以便它能够识别我们的目标元素。
- en: 'Now, let''s see the code example and how WebDriver uses this XPath to identify
    the element:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看代码示例以及 WebDriver 如何使用这个 XPath 来识别元素：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we are using the `By.xpath` locating mechanism and passing
    the XPath of the WebElement to it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在使用 `By.xpath` 定位机制并将 WebElement 的 XPath 传递给它。
- en: One disadvantage of using XPath is that it is costly in terms of time. For every
    element to be identified, WebDriver actually scans through the entire page, which
    is very time consuming, and too much usage of XPath in your test script will actually
    make it too slow to execute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 XPath 的一个缺点是它在时间上代价很高。对于要识别的每个元素，WebDriver 实际上都会扫描整个页面，这非常耗时，而且过多地在测试脚本中使用
    XPath 会使执行速度变得非常慢。
- en: The By.cssSelector() method
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: By.cssSelector() 方法
- en: 'The `By.cssSelector()` method is similar to the `By.xpath()` method in its
    usage, but the difference is that it is slightly faster than the `By.xpath` locating
    mechanism. The following are the commonly used syntaxes to identify elements:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.cssSelector()` 方法在用法上与 `By.xpath()` 方法类似，但区别在于它比 `By.xpath` 定位机制稍微快一些。以下是一些常用的语法，用于识别元素：'
- en: To identify an element using the div element with the `#flrs` ID, we use the
    `#flrs` syntax
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用具有 `#flrs` ID 的 div 元素来识别一个元素，我们使用 `#flrs` 语法
- en: To identify the child anchor element, we use the `#flrs > a` syntax, which will
    return the link element
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要识别子锚元素，我们使用 `#flrs > a` 语法，这将返回链接元素
- en: To identify the anchor element with its attribute, we use the `#flrs > a[a[href="/intl/en/about.html"]]`
    syntax
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用其属性来识别锚元素，我们使用 `#flrs > a[a[href="/intl/en/about.html"]]` 语法
- en: 'Let''s try to modify the previous code, which uses the XPath locating mechanism
    to use the `cssSelector` mechanism:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试修改之前使用 XPath 定位机制的代码，以使用 `cssSelector` 机制：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code uses the `By.cssSelector` locating mechanism, which uses
    the css selector `ID` of the Search box.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了 `By.cssSelector` 定位机制，它使用搜索框的 css 选择器 `ID`。
- en: 'Let''s look at a slightly complex example. We will try to identify the About
    Us on the Homepage:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个稍微复杂一点的例子。我们将尝试在主页上识别“关于我们”：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code uses the `cssSelector()` method to find the anchor element
    identified by its `href` attribute.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了 `cssSelector()` 方法来找到由其 `href` 属性标识的锚元素。
- en: Interacting with WebElements
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 WebElements 交互
- en: In the previous section, we saw how to locate WebElements on a web page by using
    different locator methods. Here, we will see all the different user actions that
    can be performed on a WebElement. Different WebElements will have different actions
    that can be taken on them. For example, in a textbox element, we can type in some
    text or clear the text that is already typed in it. Similarly, for a button, we
    can click on it, get the dimensions of it, and so on, but we cannot type into
    a button, and for a link, we cannot type into it. So, though all the actions are
    listed in one WebElement interface, it is the test script developer's responsibility
    to use the actions that are supported by the target element. In case we try to
    execute the wrong action on a WebElement, we don't see any exception or error
    thrown and we don't see any action get executed; WebDriver ignores such actions
    silently.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何通过使用不同的定位方法在网页上定位 WebElements。在这里，我们将看到可以在 WebElement 上执行的所有不同用户操作。不同的
    WebElements 将有不同的操作可以执行。例如，在一个文本框元素中，我们可以输入一些文本或清除已经输入的文本。同样，对于按钮，我们可以点击它，获取它的尺寸等，但我们不能在按钮中输入文本，对于链接，我们也不能在它里面输入文本。所以，尽管所有操作都列在了一个
    WebElement 接口中，但使用目标元素支持的操作是测试脚本开发者的责任。如果我们尝试在 WebElement 上执行错误操作，我们不会看到任何异常或错误抛出，也不会看到任何操作被执行；WebDriver
    会静默忽略这些操作。
- en: Now, let's get into each of the actions individually by looking at their Javadocs
    and a code example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过查看它们的 Javadocs 和代码示例，逐个分析每个操作。
- en: Getting element properties and attributes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元素属性和属性
- en: In this section, we will learn the various methods to retrieve value and properties
    from the WebElement interface.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习从 WebElement 接口检索值和属性的各种方法。
- en: The getAttribute() method
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getAttribute()` 方法'
- en: 'The `getAttribute` method can be executed on all the WebElements. Remember,
    we have seen attributes of WebElement in the WebElements section. The HTML attributes
    are modifiers of HTML elements. They are generally key-value pairs that appear
    in the start tag of an element. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAttribute` 方法可以在所有 WebElements 上执行。记住，我们在 WebElements 部分已经看到了 WebElement
    的属性。HTML 属性是 HTML 元素的修饰符。它们通常是出现在元素起始标签中的键值对。例如：'
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, `name` and `id` are the attributes or attribute keys
    and `Username` and `uname` are the attribute values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`name` 和 `id` 是属性或属性键，而 `Username` 和 `uname` 是属性值。
- en: 'The API syntax of the `getAttribute()` method is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAttribute()` 方法的 API 语法如下：'
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, the input parameter is `String`, which is the name of
    the attribute. The return type is again `String`, which is the value of the attribute.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，输入参数是 `String`，它是属性的名称。返回类型仍然是 `String`，它是属性的值。
- en: 'Now let''s see how we can get all the attributes of a WebElement using WebDriver.
    Here, we will make use of the Search box from the example application. This is
    what the element looks like:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 WebDriver 获取一个 WebElement 的所有属性。在这里，我们将使用示例应用程序中的搜索框。这个元素看起来是这样的：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will list all the attributes of this WebElement using WebDriver. The code
    for that is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 WebDriver 列出这个 WebElement 的所有属性。相应的代码如下：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the last four lines of code use the `getAttribute()`
    method to fetch the attribute values of the `name`, `id`, `class`, and `placeholder`
    attributes of the WebElement search box. The output of the preceding code will
    be following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，最后四行代码使用了 `getAttribute()` 方法来获取 WebElement 搜索框的 `name`、`id`、`class`
    和 `placeholder` 属性的属性值。前面代码的输出将是以下内容：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Going back to the `By.tagName()` method of the previous section, if the search
    by a locating mechanism, `By.tagName`, results in more than one result, you can
    use the `getAttribute()` method to further filter the results and get to your
    exact intended element.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 回到上一节中的 `By.tagName()` 方法，如果通过定位机制 `By.tagName` 的搜索结果超过一个，你可以使用 `getAttribute()`
    方法进一步筛选结果，并到达你确切想要的目标元素。
- en: The getText() method
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getText()` 方法'
- en: 'The `getText` method can be called from all the WebElements. It will return
    visible text if the element contains any text on it, otherwise it will return
    nothing. The API syntax for the `getText()` method is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`getText` 方法可以从所有 WebElement 中调用。如果元素上包含任何文本，它将返回可见文本，否则将返回无内容。`getText()`
    方法的 API 语法如下：'
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is no input parameter for the preceding method, but it returns the visible
    `innerText` string of the WebElement if anything is available, otherwise it will
    return an empty string.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法没有输入参数，但如果可用的任何内容都会返回 WebElement 的可见 `innerText` 字符串，否则将返回空字符串。
- en: 'The following is the code to get the text present on the Site notice element
    present on the example application Homepage:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于获取示例应用程序主页上存在的站点通知元素上的文本：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code uses the `getText()` method to fetch the text present on
    the Site notice element, which returns the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码使用 `getText()` 方法来获取站点通知元素上的文本，它返回以下内容：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The getCssValue() method
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getCssValue()` 方法'
- en: 'The `getCssValue` method can be called on all the WebElements. This method
    is used to fetch a CSS property value from a WebElement. CSS properties can be
    `font-family`, `background-color`, `color`, and so on. This is useful when you
    want to validate the CSS styles that are applied to your WebElements through your
    test scripts. The API syntax for the `getCssValue()` method is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCssValue` 方法可以在所有 WebElement 上调用。此方法用于从 WebElement 中获取 CSS 属性值。CSS 属性可以是
    `font-family`、`background-color`、`color` 等。当您想通过测试脚本验证应用于您的 WebElement 的 CSS 样式时，这非常有用。`getCssValue()`
    方法的 API 语法如下：'
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, the input parameter is the String value of the CSS property
    name, and the return type is the value assigned to that property name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，输入参数是 CSS 属性名称的字符串值，返回类型是分配给该属性名称的值。
- en: 'The following is the code example to retrieve `font-family` of the text from
    the Search box:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，用于检索搜索框中文本的 `font-family`：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code uses the `getCssValue()` method to find `font-family` of
    the text visible in the Search box. The output of the method is shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码使用 `getCssValue()` 方法来查找搜索框中可见文本的 `font-family`。方法的输出如下：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The getLocation() method
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getLocation()` 方法'
- en: The `getLocation` method can be executed on all the WebElements. This is used
    to get the relative position of an element where it is rendered on the web page.
    This position is calculated relative to the top-left corner of the web page of
    which the (x, y) coordinates are assumed to be (0, 0). This method will be of
    use if your test script tries to validate the layout of your web page.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLocation` 方法可以在所有 WebElement 上执行。这用于获取元素在网页上渲染的相对位置。这个位置是相对于网页的左上角计算的，其中
    (x, y) 坐标假定为 (0, 0)。如果您的测试脚本尝试验证网页布局，此方法将非常有用。'
- en: 'The API syntax of the `getLocation()` method is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLocation()` 方法的 API 语法如下：'
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding method obviously doesn't take any input parameters, but the return
    type is a `Point` class that contains the (x, y) coordinates of the element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法显然不接受任何输入参数，但返回类型是包含元素 (x, y) 坐标的 `Point` 类。
- en: 'The following is the code to retrieve the location of the Search box:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于检索搜索框的位置：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output for the preceding code is the (x, y) location of the Search box,
    as shown in the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出是搜索框的 (x, y) 位置，如下截图所示：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The getSize() method
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getSize()` 方法'
- en: 'The `getSize` method can also be called on all the visible components of HTML.
    It will return the width and height of the rendered WebElement. The API syntax
    of the `getSize()` method is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSize` 方法也可以在所有可见的 HTML 组件上调用。它将返回渲染的 WebElement 的宽度和高度。`getSize()` 方法的
    API 语法如下：'
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding method doesn''t take any input parameters, and the return type
    is a class instance named `Dimension`. This class contains the width and height
    of the target WebElement. The following is the code to get the width and height
    of the Search box:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法不接受任何输入参数，返回类型是一个名为 `Dimension` 的类实例。这个类包含目标 WebElement 的宽度和高度。以下代码用于获取搜索框的宽度和高度：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output for the preceding code is the width and height of the Search box,
    as shown in the following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出是搜索框的宽度和高度，如下截图所示：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The getTagName() method
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`getTagName()` 方法'
- en: 'The `getTagName` method can be called from all the WebElements. This will return
    the HTML tag name of the WebElement. For example, in the following HTML code,
    the button is the tag name of the HTML element:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTagName`方法可以从所有WebElements中调用。这将返回WebElement的HTML标签名。例如，在以下HTML代码中，按钮是HTML元素的标签名：'
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, the button is the tag name of the HTML element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，按钮是HTML元素的标签名。
- en: 'The API syntax for the `getTagName()` method is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTagName()`方法的API语法如下：'
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The return type of the preceding method is `String`, and it returns the tag
    name of the target element.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的返回类型是`String`，它返回目标元素的标签名。
- en: 'The following is the code that returns the tag name of the Search button:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回搜索按钮的标签名：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code uses the `getTagName()` method to get the tag name of the
    Search button element. The output of the code is as expected:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码使用`getTagName()`方法获取搜索按钮元素的标签名。代码的输出符合预期：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Performing actions on WebElements
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对WebElements执行操作
- en: In the previous section, we saw how to retrieve values or properties of WebElements.
    In this section, we will see how to perform actions on WebElements, which is the
    most crucial part of automation. Let's explore the various methods available in
    the WebElement interface.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何检索WebElements的值或属性。在本节中，我们将看到如何对WebElements执行操作，这是自动化中最关键的部分。让我们探索WebElement接口中可用的各种方法。
- en: The sendKeys() method
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sendKeys()`方法'
- en: 'The`sendKeys` action is applicable for `textbox` or `textarea` HTML elements.
    This is used to type text into the textbox. This will simulate the user keyboard
    and types text into WebElements exactly as a user would. The API syntax for the
    `sendKeys()` method is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendKeys`操作适用于`textbox`或`textarea`HTML元素。这用于将文本输入到文本框中。这将模拟用户键盘，并将文本输入到WebElements中，就像用户一样。`sendKeys()`方法的API语法如下：'
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The input parameter for the preceding method is `CharSequence` of text that
    has to be entered into the element. This method doesn''t return anything. Now,
    let''s see a code example of how to type a search text into the Search box using
    the `sendKeys()` method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法的输入参数是要输入到元素中的`CharSequence`文本。此方法不返回任何内容。现在，让我们看看如何使用`sendKeys()`方法在搜索框中输入搜索文本的代码示例：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, the `sendKeys()` method is used to type the required
    text in the textbox element of the web page. This is how we deal with normal keys,
    but if you want to type in some special keys, such as *Backspace, Enter, Tab,*
    or *Shift*, we need to use a special enum class of WebDriver, named `Keys`. Using
    the `Keys` enumeration, you can simulate many special keys while typing into a
    WebElement.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`sendKeys()`方法用于在网页的文本框元素中输入所需文本。这就是我们处理普通键的方式，但如果你想要输入一些特殊键，例如*退格键、回车键、制表键*或*Shift键*，我们需要使用WebDriver的一个特殊枚举类，名为`Keys`。使用`Keys`枚举，你可以在输入到WebElement时模拟许多特殊键。
- en: 'Now let''s see some code example, which uses the *Shift* key to type the text
    in uppercase in the Search Box:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些代码示例，它使用*Shift*键在搜索框中输入大写文本：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code, the `chord()` method from the `Keys` enum is used to
    type the key, while the text specified is being given as an input to be the textbox.
    Try this in your environment to see all the text being typed in uppercase.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Keys`枚举的`chord()`方法用于输入键，同时指定的文本作为输入给文本框。在你的环境中尝试这个示例，以查看所有输入的文本都是大写的。
- en: The clear() method
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`clear()`方法'
- en: 'The clear action is similar to the `sendKeys()` method, which is applicable
    for the `textbox` and `textarea` elements. This is used to erase the text entered
    in a WebElement using the `sendKeys()` method. This can be achieved using the
    `Keys.BACK_SPACE` enum, but WebDriver has given us an explicit method to clear
    the text easily. The API syntax for the `clear()` method is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 清除操作类似于`sendKeys()`方法，适用于`textbox`和`textarea`元素。这用于使用`sendKeys()`方法擦除在WebElement中输入的文本。这可以通过使用`Keys.BACK_SPACE`枚举实现，但WebDriver已经提供了一个简单的方法来清除文本。`clear()`方法的API语法如下：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This method doesn't take any input and doesn't return any output. It is simply
    executed on the target text-entry element.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不接收任何输入，也不返回任何输出。它只是在目标文本输入元素上执行。
- en: 'Now, let''s see how we can clear text that is entered in the Search box. The
    code example for it is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何清除搜索框中输入的文本。相应的代码示例如下：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have used the WebElement's `clear()` method to clear the text after typing
    `phones` into the Search box.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 WebElement 的 `clear()` 方法在搜索框中输入 `phones` 后清除文本。
- en: The submit() method
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`submit()` 方法'
- en: 'The `submit()` action can be taken on a `Form` or on an element, which is inside
    a `Form` element. This is used to submit a form of a web page to the server hosting
    the web application. The API syntax for the `submit()` method is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit()` 操作可以在 `Form` 或 `Form` 元素内的元素上执行。这是用来将网页表单提交给托管 web 应用的服务器的。`submit()`
    方法的 API 语法如下：'
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding method doesn't take any input parameters and doesn't return anything.
    But a `NoSuchElementException` is thrown when this method is executed on a WebElement
    that is not present within the form.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法不接收任何输入参数，也不返回任何内容。但是，当这个方法在一个不在表单内的 WebElement 上执行时，会抛出 `NoSuchElementException`。
- en: 'Now, let''s see a code example to submit the form on a Search page:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个在搜索页面上提交表单的代码示例：
- en: '[PRE54]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding code, toward the end is where the Search form is submitted
    to the application servers using the `submit()` method. Now, try to execute the
    `submit()` method on an element, let's say the About link, which is not a part
    of any form. We should see `NoSuchElementException` is thrown. So, when you use
    the `submit()` method on a WebElement, make sure it is part of the `Form` element.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，接近结尾的部分是使用 `submit()` 方法将搜索表单提交给应用程序服务器。现在，尝试在一个元素上执行 `submit()` 方法，比如
    About 链接，它不是任何表单的一部分。我们应该看到会抛出 `NoSuchElementException`。所以，当你在一个 WebElement 上使用
    `submit()` 方法时，请确保它属于 `Form` 元素。
- en: Checking the WebElement state
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 WebElement 状态
- en: In the previous sections, we saw how to retrieve values and perform actions
    on WebElements. Now, we will see how to check the state of a WebElement. We will
    explore methods to check whether the WebElement is displayed in the Browser window,
    whether it is editable, and if the WebElement is Radio Button of Checkbox, we
    can determine whether it's selected or unselected. Let's see how we can use the
    methods available in the WebElement interface.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何检索值和在对 WebElements 执行操作。现在，我们将了解如何检查 WebElement 的状态。我们将探讨检查 WebElement
    是否在浏览器窗口中显示、是否可编辑，以及如果 WebElement 是单选按钮或复选框，我们可以确定它是选中还是未选中的方法。让我们看看如何使用 WebElement
    接口中的可用方法。
- en: The isDisplayed() method
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isDisplayed()` 方法'
- en: 'The `isDisplayed` action verifies whether an element is displayed on the web
    page and can be executed on all the WebElements. The API syntax for the `isDisplayed()`
    method is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDisplayed` 操作验证元素是否在网页上显示，并且可以在所有 WebElements 上执行。`isDisplayed()` 方法的 API
    语法如下：'
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is displayed on the web page. The following is the code to verify whether
    the Search box is displayed, which obviously should return true in this case:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法返回一个 `Boolean` 值，指定目标元素是否在网页上显示。以下是对搜索框是否显示的验证代码，在这种情况下显然应该返回 true：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code uses the `isDisplayed()` method to determine whether the
    element is displayed on a web page. The preceding code returns `true` for the
    Search box:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了 `isDisplayed()` 方法来确定元素是否在网页上显示。前面的代码对搜索框返回 `true`：
- en: '[PRE57]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The isEnabled() method
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isEnabled()` 方法'
- en: 'The `isEnabled` action verifies whether an element is enabled on the web page
    and can be executed on all the WebElements. The API syntax for the `isEnabled()`
    method is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`isEnabled` 操作验证元素是否在网页上启用，并且可以在所有 WebElements 上执行。`isEnabled()` 方法的 API 语法如下：'
- en: '[PRE58]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is enabled on the web page. The following is the code to verify whether
    the Search box is enabled, which obviously should return true in this case:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法返回一个 `Boolean` 值，指定目标元素是否在网页上启用。以下是对搜索框是否启用的验证代码，在这种情况下显然应该返回 true：
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The preceding code uses the `isEnabled()` method to determine whether the element
    is enabled on a web page. The preceding code returns true for the Search box:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了 `isEnabled()` 方法来确定元素是否在网页上启用。前面的代码对搜索框返回 true：
- en: '[PRE60]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The isSelected() method
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`isSelected()` 方法'
- en: 'The `isSelected` method returns a `boolean` value if an element is selected
    on the web page and can be executed only on a radio button, options in select,
    and checkbox WebElements. When executed on other elements, it will return false.
    The API syntax for the `isSelected()` method is as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个元素在网页上被选中，`isSelected`方法返回一个`boolean`值，并且只能在单选按钮、选择框中的选项和复选框WebElement上执行。在其他元素上执行时，它将返回`false`。`isSelected()`方法的API语法如下：
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The preceding method returns a `Boolean` value specifying whether the target
    element is selected on the web page. The following is the code to verify whether
    the Search box is selected on a search page:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个方法返回一个`Boolean`值，指定目标元素是否在网页上被选中。以下代码用于验证搜索框是否在搜索页面上被选中：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding code uses the `isSelected()` method. It returns false for the
    Search box, because this is not a radio button, options in select, or a checkbox.
    The preceding code returns `false` for the Search box:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码使用了`isSelected()`方法。对于搜索框，它返回`false`，因为这不是单选按钮、选择框中的选项或复选框。前一个代码对搜索框返回`false`：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To select a Checkbox or Radio button, we need to call the `WebElement.click()`
    method, which toggles the state of the element. We can use the `isSelected()`
    method to see whether it's selected.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择复选框或单选按钮，我们需要调用`WebElement.click()`方法，该方法切换元素的状态。我们可以使用`isSelected()`方法来查看它是否被选中。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a brief overview of the Selenium testing tools,
    and the architecture of WebDriver, WebElements. We learned how to set up a test-development
    environment using Eclipse, Maven, and TestNG. This will provide us with the foundation
    to build a testing framework using Selenium. Then, we saw how to locate elements,
    and the actions that can be taken on them. This is the most important aspect when
    automating Web Applications. In this chapter, we used ChromeDriver to run our
    tests. In the next chapter, we will learn how to configure and run tests on Mozilla
    Firefox, Microsoft IE and Edge, and Apple Safari.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要概述了Selenium测试工具和WebDriver、WebElement的架构。我们学习了如何使用Eclipse、Maven和TestNG设置测试开发环境。这将为我们使用Selenium构建测试框架提供基础。然后，我们看到了如何定位元素以及可以对其执行的操作。这是自动化Web应用程序时最重要的方面。在本章中，我们使用了ChromeDriver来运行我们的测试。在下一章中，我们将学习如何配置和运行Mozilla
    Firefox、Microsoft IE和Edge以及Apple Safari上的测试。
- en: Questions
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True or false: Selenium is a browser automation library.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对错：Selenium是一个浏览器自动化库吗？
- en: What are the different types of locator mechanisms provided by Selenium?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Selenium提供了哪些不同类型的定位机制？
- en: 'True or false: With the `getAttribute()` method, we can read CSS attributes
    as well?'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对错：使用`getAttribute()`方法，我们也可以读取CSS属性吗？
- en: What actions can be performed on a WebElement?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在一个WebElement上执行哪些操作？
- en: How can we determine whether the checkbox is checked or unchecked?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确定复选框是被选中还是未选中？
- en: Further information
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'You can check out the following links for more information on the topics covered
    in this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接获取更多关于本章涵盖主题的信息：
- en: Read the WebDriver Specification at [https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)阅读WebDriver规范。
- en: Read more about using TestNG and Maven in *[Chapter 1](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml),
    Creating a Faster Feedback Loop* from *Mastering Selenium WebDriver* By Mark Collin,
    Packt Publishing
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《精通Selenium WebDriver》一书中，由Mark Collin著，Packt Publishing出版，您可以了解更多关于在*[第1章](9f647c33-1720-4d7b-973b-7d2ef9dad924.xhtml)，创建更快的反馈循环*中使用TestNG和Maven的内容。
- en: Read more about element interaction in *Chapter 2, Finding Elements* and *Chapter
    3, Working with Elements* from *Selenium Testing Tools Cookbook*, 2nd Edition,
    by Unmesh Gundecha, Packt Publishing
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在《Selenium 测试工具食谱》第2版中，由Unmesh Gundecha著，Packt Publishing出版的书中，您可以了解更多关于元素交互的内容，包括第2章“寻找元素”和第3章“与元素一起工作”。
