<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing</h1>
                </header>
            
            <article>
                
<p>This chapter shows how to unit test your APIs before they are integrated with other components. Sometimes, we would have to stub dependencies with some dummy data, and this can be done by mocking the dependencies. We will show you how to do this using a mocking library. We will also show you how to write fixtures to populate test data and then how you can test the behavior of your application by integrating different APIs and testing them together. We will cover the following recipes:</p>
<ul>
<li>Unit testing of an API using JUnit</li>
<li>Unit testing by mocking dependencies</li>
<li>Using fixtures to populate data for testing</li>
<li>Behavioral testing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Well-tested code provides a peace of mind to the developer. If you get a feeling that writing a test for the new method you are developing is too much of an overhead, then you usually don't get it right the first time.. This is because you have to test your method anyway. Doing this in the context of the application only requires time to set things up (especially if you are trying to test all the possible input and conditions). Then, if the method changes, you need to redo the setup again. And you do it manually. You can avoid this by creating an automated test at the same time you were developing the new method (we assume not-too complex code, of course; setters and getters do not count). This would save you time in the long run. </p>
<p>Why do we get this feeling of overhead sometimes? It's probably because we are not prepared psychologically. When we think about how long it would take to add the new functionality, we often forget to include the time needed for writing the test. It is even worse when we forget this while providing an estimate to a manager. Often, we shy away from giving a higher estimate because we do not want to look not perception we have of not being very knowledgeable or skilled enough. Whatever the reason, it happens. Only after years of experience, we learn to include tests in our estimates and earn enough respect and clout to be able to assert publicly that doing things right requires more time up front, but saves much more time in the long run. Besides, doing it right leads to a better quality of the result with far less stress, which means a better quality of life overall.</p>
<p>If you are still not convinced, make note of the date when you read this and check back every year until this advice becomes obvious to you. Then, please share your experiences with others. This is how humanity makes progress, by passing knowledge from one generation to the next.</p>
<p>However, if you would like to learn how to write tests that will help you produce good quality Java code, this chapter is for you. Methodologically, this is applicable to other languages and professions too. This chapter is written primarily for Java developers and assumes the authorship of tested code. Another assumption is that testing happens during the early stages of code writing so that code weaknesses discovered during the testing can be fixed immediately. Writing automated tests early is the best time to do it for two other reasons:</p>
<ul>
<li>You can easily restructure your code to make it more testable</li>
<li>It saves you time by eliminating guesswork, which in turn makes your development process more productive</li>
</ul>
<p>Another good moment to write a test (or enhance the existing one) is when a defect is discovered in production. It helps your investigation of the root cause if you recreate the problem and demonstrate it in a failed test and then show how the issue disappears (and the test does not fail anymore) in the new version of the code. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing of an API using JUnit</h1>
                </header>
            
            <article>
                
<p>According to Wikipedia, <em>A research survey performed in 2013 across 10,000 Java projects hosted on GitHub found that JUnit, (in a tie with slf4j-api), was the most commonly included external library. Each library was used by 30.7% of projects.</em> JUnit is a testing framework--one of a family of unit testing frameworks collectively known as xUnit that originated with SUnit. It is linked as a JAR at compile time and resides (since JUnit 4) in the <kbd>org.junit</kbd> package.  </p>
<p>Here's an excerpt from another article on Wikipedia, <em>In object-oriented programming, a unit is often an entire interface, such as a class, but could be an individual method.</em> We've found the last part--a unit as an individual method--the most useful in practice. It will be the basis for the examples of the recipes of this chapter. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>At the time of this writing, the latest stable version of JUnit is 4.12, which can be used by adding the following Maven dependency to the <kbd>pom.xml</kbd> project level:</p>
<pre>&lt;dependency&gt;<br/>  &lt;groupId&gt;junit&lt;/groupId&gt;<br/>  &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>  &lt;version&gt;4.12&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>After this, you can write your first JUnit test. Let's assume you have the <kbd>Vehicle</kbd> class created in the <kbd>src/main/java/com/packt/cookbook.ch02_oop.a_classes</kbd> folder (this is exactly the code we discussed in <a href="8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml">Chapter 2</a>, <em>Fast Track to OOP - Classes and Interfaces</em>, of this book):</p>
<pre><span>package </span>com.packt.cookbook.ch02_oop.a_classes<span>;</span><span><br/></span><span>public class </span>Vehicle {<br/>  <span>private int </span><span>weightPounds</span><span>;<br/></span><span>  private </span>Engine <span>engine</span><span>;</span><span><br/></span><span>  public </span><span>Vehicle</span>(<span>int </span>weightPounds<span>, </span>Engine engine) {<br/>    <span>this</span>.<span>weightPounds </span>= weightPounds<span>;<br/></span><span>    if</span>(engine == <span>null</span>){<br/>      <span>throw new </span>RuntimeException(<span>"Engine value is not set."</span>)<span>;<br/></span><span>    </span>}<br/>    <span>this</span>.<span>engine </span>= engine<span>;<br/></span>  }<br/>  <span>protected double </span><span>getSpeedMph</span>(<span>double </span>timeSec){<br/>    <span>double </span>v = <span>2.0</span>*<span>this</span>.<span>engine</span>.getHorsePower()*<span>746</span><span>;<br/></span><span>    </span>v = v*timeSec*<span>32.174</span>/<span>this</span>.<span>weightPounds</span><span>;<br/></span><span>    return </span>Math.<span>round</span>(Math.<span>sqrt</span>(v)*<span>0.68</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Now you can create the <kbd>src/test/java/com/packt/cookbook.ch02_oop.a_classes</kbd><span> folder (notice the new folder tree that starts with <kbd>test</kbd>, created in parallel to the tree of <kbd>main</kbd>) and create a new file in it called <kbd>VehicleTest.java</kbd> that contains the <kbd>VehicleTest</kbd> class:</span></p>
<pre><span>package </span>com.packt.cookbook.ch02_oop.a_classes<span>;</span><span><br/></span><span>import </span>org.junit.<span>Test</span><span>;</span><span><br/></span><span>public class </span>VehicleTest {<br/>  <span>@Test<br/></span><span>  </span><span>public void </span><span>testGetSpeedMph</span>(){<br/>    System.<span>out</span>.println(<span>"Hello!" + " I am your first test method!"</span>)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>Run it using your favorite IDE or just with the <kbd>mvn test</kbd> command. You will see an output that will include the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="136" width="383" class="image-border" src="assets/44d4630b-d846-41c3-b270-c9ed50889d93.png"/></div>
<p>Congratulations! You have created your first test class. It does not test anything yet, but it is an important setup--the overhead that is necessary for doing things the right way. In the next section, we will start with the actual testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's look at the <kbd>Vehicle</kbd> class closer. Testing the getters would be of little value, but we can still do it, making sure that the value passed to the constructor is returned by the corresponding getter. The exception in the constructor belongs to the must-test features as well as the <kbd>getSpeedMph()</kbd> method. There is also an object of the <kbd>Engine</kbd> class that has the <kbd>getHorsePower()</kbd> method. Can it return <kbd>null</kbd>? We should look in the <kbd>Engine</kbd> class too: </p>
<pre><span>public class </span>Engine {<br/>  <span>private int </span><span>horsePower</span><span>;</span><span><br/></span><span>  public int </span><span>getHorsePower</span>() {<br/>    <span>return </span><span>horsePower</span><span>;<br/></span><span>  </span>}<br/>  <span>public void </span><span>setHorsePower</span>(<span>int </span>horsePower) {<br/>    <span>this</span>.<span>horsePower </span>= horsePower<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>There is not much behavior in this class to test and it cannot return <kbd>null</kbd>. But returning a negative value is a definite possibility, which in turn can cause problems for the <kbd>Math.sqrt()</kbd> function of the <kbd>getSpeedMph()</kbd> method. Should we make sure that the horsepower value will never be negative? It depends on how limited is the method's usage and the source of the input data for it.</p>
<p>Similar considerations are applicable to the value of the <kbd>weightPounds</kbd> property of the <kbd>Vehicle</kbd> class. It can stop the application with <kbd>ArithmeticException</kbd> caused by the division by zero in <span>the </span><kbd>getSpeedMph()</kbd> method.</p>
<p>However, in practice, there is little chance that the values of an engine's horsepower and vehicle weight will be negative or close to zero, so we will assume this and will not add these checks to the code.</p>
<p>Such analysis is the daily routine and the background thoughts of every developer, and that is the first step in the right direction. The second step is to capture all these thoughts and doubts in the unit tests and verify the assumptions.  </p>
<p>Let's go back to the test class we have created and enhance it. As you may have probably noticed, the <kbd>@Test</kbd> annotation makes a certain method a test method. This means it will be run by your IDE or Maven every time you issue a command to run tests. The method can be named any way you like, but a best practice advises to indicate which method (of the <kbd>Vehicle</kbd> class, in this case) you are testing. So, the format usually looks like <kbd>test&lt;methodname&gt;&lt;scenario&gt;</kbd>, where  <kbd>scenario</kbd> indicates a particular test case: a happy path, a failure, or some other condition you would like to test. In our example, we do not use suffix as an indication that we are going to test the main functionality that is working successfully (without any errors or edge cases). Later, we will show examples of methods that test other scenarios.</p>
<p>In such a test method, you can call the application method you are testing, provide it with the data, and assert the result. You can create your own assertions (methods to compare the actual results with the expected ones) or you can use assertions provided by JUnit. To do the latter, just add <kbd>static</kbd> import: </p>
<pre><span>import</span><span> static </span>org.junit.Assert.assertEquals;</pre>
<p>If you use a modern IDE, you can type <kbd>import static org.junit.Assert</kbd> and see how many different assertions are available (or go to JUnit's API documentation and see it there). There is a dozen or more overloaded methods available: <kbd>assertArrayEquals()</kbd>, <kbd>assertEquals()</kbd>, <kbd>assertNotEquals()</kbd>, <kbd>assertNull()</kbd>, <kbd>assertNotNull()</kbd>, <kbd>assertSame()</kbd>, <kbd>assertNotSame()</kbd>, <kbd>assertFalse()</kbd>, <kbd>assertTrue()</kbd>, <kbd>assertThat()</kbd>, and <kbd>fail()</kbd>. It would be helpful if you spend a few minutes reading what these methods do. You can also guess their purpose by name. Here is an example of the usage of the <kbd>assertEquals()</kbd> method:</p>
<pre><span>import </span>org.junit.<span>Test</span><span>;<br/></span><span>import static </span>org.junit.Assert.<span>assertEquals</span><span>;</span><span><br/></span><span>public class </span>VehicleTest {<br/>  <span>@Test<br/></span><span>  </span><span>public void </span><span>testGetSpeedMph</span>(){<br/>    System.<span>out</span>.println(<span>"Hello!" + " I am your first test method!"</span>)<span>;<br/></span><span>    </span><span>assertEquals</span>(<span>4</span><span>, </span><span>"Hello"</span>.length())<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>We compare the actual length of the word <kbd>Hello</kbd> and the expected length, that is, <kbd>4</kbd>. We know that the correct number would be <kbd>5</kbd>, but we would like the test to fail to demonstrate the failing behavior and advise how to read the failing test results (you don't need to read happy results, do you?). If you run this test, you'll get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="73" width="517" class="image-border" src="assets/5d13c64e-732d-456c-a2a5-c25dd93a2b83.png"/></div>
<p>You can see that the expected value was <kbd>4</kbd>, while the actual is <kbd>5</kbd>. Say, you switch the order like this:</p>
<pre><span>assertEquals</span>(<span>"Assert Hello length:"</span><span>,</span><span>"Hello"</span>.length()<span>, </span><span>4</span>)<span>;</span></pre>
<p>The result of this will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="73" width="527" class="image-border" src="assets/63be96a0-04c4-4610-9117-d330ea82b6e5.png"/></div>
<p>This is incorrect because <kbd>5</kbd> is the actual result, while <kbd>4</kbd> is the expected (although erroneous, for demonstration purposes only).</p>
<div class="packt_tip">It is important to remember that in each of the asserting methods, the parameter with the expected value is located (in the signature of an assertion) <strong><em>before</em></strong> the actual one.  </div>
<p>After the test is written, you will do something else, and months later, you will probably forget what each assertion actually evaluated. But it may well be that one day the test will fail (because you or somebody will change the application code). You will see the test method name, expected value, and the actual value, but you will have to dig through the code to figure which of the assertion failed (there are often several of them in each test method). You will probably be forced to add a debug statement and run the test several times in order to figure it out. To help you avoid this extra digging, each of the JUnit assertions allows you to add a message that describes the particular assertion. For example, run this version of the test:</p>
<pre><span>public class </span>VehicleTest {<br/><span>  @Test<br/></span><span>  public void </span><span>testGetSpeedMph</span>(){<br/>    System.<span>out</span>.println(<span>"Hello!" + " I am your first test method!"</span>)<span>;<br/></span><span>    </span><span>assertEquals</span>(<span>"Assert Hello length:"</span><span>, </span><span>4</span><span>, </span><span>"Hello"</span>.length())<span>;<br/></span><span>  </span>}<br/>}</pre>
<p> If you do this, the result will be much more readable:</p>
<div class="CDPAlignCenter CDPAlign"><img height="71" width="518" class="image-border" src="assets/1c3dda9b-be51-4f34-9f36-ad39c2a0410d.png"/></div>
<p>To complete this demonstration, we change the expected value to <kbd>5</kbd>:</p>
<pre><span>assertEquals</span>(<span>"Assert Hello length:"</span><span>, 5, </span><span>"Hello"</span>.length())<span>;</span></pre>
<p>This will be your test output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="50" width="420" class="image-border" src="assets/6e1d30c5-ecf8-41da-9c7f-e1f117d5e3cc.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Equipped with some knowledge of the JUnit framework, we can now write a real test method for the main case: the calculation of the speed of a vehicle of certain weight with an engine of certain horsepower to determine where it can reach in a certain period of time. We take the formula we used for writing the code (provided originally by the domain expert) and calculate the expected value. For example, if the vehicle has an engine of 246 hp and weight of 4,000 lb, then in 10 sec, its speed can reach 117 mph. Since the speed is of the type <kbd>double</kbd>, we will use this assertion:  </p>
<pre>void assertEquals(String message, double expected, <br/>                       double actual, double delta)</pre>
<p>Here, <kbd>delta</kbd> is allowable precision (we decided that 1 percent is good enough). The resulting implementation of the <kbd>test</kbd> method will look as follows:  </p>
<pre><span>@Test<br/></span><span>public void </span><span>testGetSpeedMph</span>(){<br/><span>  </span><span>double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>engineHorsePower = <span>246</span><span>;<br/></span><span>  int </span>vehicleWeightPounds = <span>4000</span><span>;<br/></span><span><br/></span><span>  </span>Engine engine = <span>new </span>Engine()<span>;<br/></span><span>  </span>engine.setHorsePower(engineHorsePower)<span>;<br/></span><span><br/></span><span>  </span>Vehicle vehicle = <span>new </span>Vehicle(vehicleWeightPounds<span>,</span> engine)<span>;<br/></span><span>  double </span>speed = vehicle.getSpeedMph(timeSec)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert vehicle (" </span>+ engineHorsePower <br/>            + <span>" hp, " </span>+ vehicleWeightPounds + <span>" lb) speed in " <br/></span>            + timeSec + <span>" sec: "</span><span>, </span><span>117</span><span>, </span>speed<span>, </span><span>0.001 </span>* speed)<span>;</span><span><br/></span>}</pre>
<p> If we run this test, the output will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="38" width="486" class="image-border" src="assets/f19a21ab-44cb-4b1f-be96-07db70a1c7dc.png"/></div>
<p>To make sure the test is working, we set the expected value to 119 mph (more than 1 percent different) and run the test again. The result will be as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/56312767-34f4-4dc3-b1ee-9f4111bd91e5.png"/></div>
<p>We change the expected value back to 117 and continue writing other test cases we discussed while analyzing the code. </p>
<p>Let's make sure that the exception is thrown when expected. Let's add another import:</p>
<pre><span>import static </span>org.junit.Assert.<span>fail</span><span>;<br/></span></pre>
<p>Then, write the following test:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testGetSpeedMphException</span>(){<br/>  <span>int </span>vehicleWeightPounds = <span>4000</span><span>;<br/></span><span>  </span>Engine engine = <span>null;<br/></span><span>  try </span>{<br/>    Vehicle vehicle = <span>new </span>Vehicle(vehicleWeightPounds<span>, </span>engine)<span>;<br/></span><span>    </span><span>fail</span>(<span>"Exception was not thrown"</span>)<span>;<br/></span><span>  </span>} <span>catch </span>(RuntimeException ex) {}<br/>}</pre>
<p>This test runs successfully too. To make sure that the test works correctly, we temporarily assign it with the following:</p>
<pre>Engine engine = <span>new Engine();</span></pre>
<p>Then, we observe the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="66" width="637" class="image-border" src="assets/c6f0d5e3-84b1-4d0c-852f-16e0091e5a1a.png"/></div>
<p>This way, we get a level of confidence that we did not code something that is going to be correct always, no matter the code changes.</p>
<p>As you can see, the best way to write these tests is in the process of writing application code, so you can test the code as it grows in complexity. Otherwise, especially in more complex code, you might have problems debugging it after all of the code is written already.</p>
<p>There are quite a few other annotations and JUnit features that can be helpful to you, so please refer to the JUnit documentation for more in-depth understanding of all the framework capabilities.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Unit testing by mocking dependencies</li>
<li>Using fixtures to populate data for testing</li>
<li>Behavioral testing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing by mocking dependencies</h1>
                </header>
            
            <article>
                
<p>Writing a unit test requires unit isolation. In case a method uses several other methods from different objects, there arises a need to limit the depth of testing so that each layer can be tested in isolation as a unit. This is when the need for mocking the lower level comes into focus. </p>
<p>Mocking can not only be done vertically, but also horizontally: at the same level, but already isolated from the underlying functionality. If a method is long and complicated, you might consider breaking it into several smaller methods so you can test only one of them while mocking the others. This is another advantage of unit testing code along with its development; it is easier to redesign code for better testability before it is hardened. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Mocking other methods and classes is straightforward. Coding to an interface (as described in <a href="8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml">Chapter 2</a>, <em>Fast Track to OOP - Classes and Interfaces</em>) makes it much easier, although there are mocking frameworks that allow you to mock classes that do not implement any interface (we will see examples of such framework usage in the next section of this recipe). Also, using object and method factories helps you create test-specific implementations of such factories so they can generate objects with methods that return the expected hardcoded values.   </p>
<p>For example, in <a href="039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml">Chapter 4</a>, <em>Going Functional</em>, we introduced <kbd>FactoryTraffic</kbd>, which produced one or many objects of <kbd>TrafficUnit</kbd>. In a real system, this factory would draw data from some external system that has data about traffic for a certain geographic location and time of the day. Using the real system as the source would complicate the code setup for you when you run the examples. To get around this problem, we have mocked the data by generating them according to the distribution that somewhat resembles the real one: a bit more cars than trucks, the weight of the vehicle depending on the type of the car, the number of passengers and weight of the payload, and similar. What is important for such a simulation is that the range of values (min and max) should reflect those coming from the real system, so the application would be tested on the full range of possible real data. </p>
<p>The important constraint for mocking code is that it should not be too complicated. Otherwise, its maintenance would require an overhead that would either decrease the team productivity or decrease (if not abandon completely) the test coverage. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Here is how the mock of <kbd>FactoryTraffic</kbd> will look like:</p>
<pre><span>public class </span>FactoryTraffic {<br/>  <span>public static </span>List&lt;TrafficUnit&gt; <span>generateTraffic</span>(<span>int <br/></span>    trafficUnitsNumber<span>, </span>Month month<span>, </span>DayOfWeek dayOfWeek<span>, <br/>    int </span>hour<span>, </span>String country<span>, </span>String city<span>, </span>String trafficLight){<br/>    List&lt;TrafficUnit&gt; tms = <span>new </span>ArrayList()<span>;<br/></span><span>    for </span>(<span>int </span>i = <span>0</span><span>; </span>i &lt; trafficUnitsNumber<span>; </span>i++) {<br/>      TrafficUnit trafficUnit = <br/>        FactoryTraffic.<span>getOneUnit</span>(month<span>, </span>dayOfWeek<span>, </span> hour<span>, </span>country<span>, <br/>                                  </span>city<span>, </span>trafficLight)<span>;<br/></span><span>        </span>tms.add(trafficUnit)<span>;<br/></span><span>    </span>}<br/>    <span>return </span>tms<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>It assembles a collection of <kbd>TrafficUnit</kbd> objects. In a real system, these objects would be created from the rows of the result of some database query, for example. But in our case, we just mock the result:</p>
<p> </p>
<pre><span>public static </span>TrafficUnit <span>getOneUnit</span>(Month month<span>, <br/></span>              DayOfWeek dayOfWeek<span>, int </span>hour<span>, </span>String country<span>, <br/></span>              String city<span>, </span>String trafficLight) {<br/>  <span>double </span>r0 = Math.<span>random</span>()<span>; <br/></span>  VehicleType vehicleType = r0 &lt; <span>0.4 </span>? VehicleType.<span>CAR </span>:<br/>  (r0 &gt; <span>0.6 </span>? VehicleType.<span>TRUCK </span>: VehicleType.<span>CAB_CREW</span>)<span>;<br/></span><span>  double </span>r1 = Math.<span>random</span>()<span>;<br/></span><span>  double </span>r2 = Math.<span>random</span>()<span>;<br/></span><span>  double </span>r3 = Math.<span>random</span>()<span>;<br/></span><span>  return new </span>TrafficModelImpl(vehicleType<span>, </span><span>gen</span>(<span>4</span><span>,</span><span>1</span>)<span>,<br/>             </span><span>gen</span>(<span>3300</span><span>,</span><span>1000</span>)<span>, </span><span>gen</span>(<span>246</span><span>,</span><span>100</span>)<span>, </span><span>gen</span>(<span>4000</span><span>,</span><span>2000</span>)<span>,<br/></span><span>             </span>(r1 &gt; <span>0.5 </span>? RoadCondition.<span>WET </span>: RoadCondition.<span>DRY</span>)<span>,    <br/></span>             (r2 &gt; <span>0.5 </span>? TireCondition.<span>WORN </span>: TireCondition.<span>NEW</span>)<span>,<br/></span><span>             </span>r1 &gt; <span>0.5 </span>? ( r3 &gt; <span>0.5 </span>? <span>63 </span>: <span>50 </span>) : <span>63 </span>)<span>;<br/></span>}</pre>
<p>As you can see, we used a random number generator to pick up the value from a range for each of the parameters. The range is in line with the ranges of the real data. This code is very simple and it does not require much maintenance, but it provides the application with the flow of data similar to the real one.</p>
<p>You can use another technique for testing the method that has some dependencies that you would like to isolate in order to get the predictable result. For example, let's revisit the <kbd>VechicleTest</kbd> class. Instead of creating a real <kbd>Engine</kbd> object, we can mock it using one of the mocking frameworks. In this case, we use Mockito. Here is the Maven dependency for it:</p>
<p> </p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.mockito<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>mockito-core<span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>2.7.13<span>&lt;/version&gt;<br/></span><span>  &lt;scope&gt;</span>test<span>&lt;/scope&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p> The test method now looks like this (the two lines that were changed are highlighted):</p>
<p> </p>
<pre><span>@Test<br/></span><span>public void </span><span>testGetSpeedMph</span>(){<br/><span>  </span><span>double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>engineHorsePower = <span>246</span><span>;<br/></span><span>  int </span>vehicleWeightPounds = <span>4000</span><span>;<br/></span><span><br/></span><strong>  Engine engine = Mockito.mock(Engine.class);<br/>  Mockito.when(engine.getHorsePower()).thenReturn(engineHorsePower);</strong><span><br/></span><span><br/>  </span>Vehicle vehicle = <span> new </span>Vehicle(vehicleWeightPounds<span>, </span>engine)<span>;<br/></span><span>  double </span>speed = vehicle.getSpeedMph(timeSec)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert vehicle (" </span>+ engineHorsePower <br/>               + <span>" hp, " </span>+ vehicleWeightPounds + <span>" lb) speed in " <br/></span>               + timeSec + <span>" sec: "</span><span>, </span><span>117</span><span>, </span>speed<span>, </span><span>0.001 </span>* speed)<span>;</span><span><br/></span>}</pre>
<p>As you can see, we instruct the <kbd>mock</kbd> object to return a fixed value when the <kbd>getHorsePower()</kbd> method is called. We can even go as far as creating a mock object for the method we want to test:</p>
<pre>Vehicle vehicleMock = Mockito.<span>mock</span>(Vehicle.<span>class</span>)<span>;<br/></span>Mockito.<span>when</span>(vehicleMock.getSpeedMph(<span>10</span>)).thenReturn(<span>30d</span>)<span>;<br/></span><span><br/></span><span>double </span>speed = vehicleMock.getSpeedMph(<span>10</span>)<span>;<br/></span>System.<span>out</span>.println(speed)<span>;<br/></span></pre>
<p>So, it always returns the same value:</p>
<div class="CDPAlignCenter CDPAlign"><img height="39" width="458" class="image-border" src="assets/bc805877-a5bd-42db-bd36-cbf6908cbb6d.png"/></div>
<p>However, this would defeat the purpose of testing.</p>
<p>You can use another technique while testing a stream's pipeline methods. Let's assume we need to test the <kbd>trafficByLane()</kbd> method in the <kbd>TrafficDensity1</kbd> class (we are going to have  <kbd>TrafficDensity2</kbd><span> and</span> <kbd>TrafficDensity3</kbd><span>, too):</span></p>
<pre><span>public class TrafficDensity1</span> {<br/>  <span>public </span>Integer[] <span>trafficByLane</span>(Stream&lt;TrafficUnit&gt; stream<span>, <br/>  int </span>trafficUnitsNumber<span>, double </span>timeSec<span>,<br/></span><span>  </span>SpeedModel speedModel<span>, double</span>[] speedLimitByLane) {<br/><br/>    <span>int </span>lanesCount = speedLimitByLane.<span>length</span><span>;<br/></span><span><br/>    </span>Map&lt;Integer<span>, </span>Integer&gt; trafficByLane = stream<br/>      .limit(trafficUnitsNumber)<br/>      .map(TrafficUnitWrapper::<span>new</span>)<br/>      .map(tuw -&gt; tuw.setSpeedModel(<span>speedModel</span>))<br/>      .map(tuw -&gt; tuw.calcSpeed(<span>timeSec</span>))<br/>      .map(speed -&gt;  countByLane(<span>lanesCount</span><span>, </span><span>speedLimitByLane</span><span>, </span>speed))<br/>      .collect(Collectors.<span>groupingBy</span>(CountByLane::getLane<span>, <br/></span>               Collectors.<span>summingInt</span>(CountByLane::getCount)))<span>;<br/></span><span><br/></span><span>    for</span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= lanesCount<span>; </span>i++){<br/>      trafficByLane.putIfAbsent(i<span>, </span><span>0</span>)<span>;<br/></span><span>    </span>}<br/>    <span>return </span>trafficByLane.values()<br/>      .toArray(<span>new </span>Integer[lanesCount])<span>;<br/></span><span>  </span>}<br/><br/>  <span>private </span>CountByLane <span>countByLane</span>(<span>int </span>lanesCount<span>, <br/>                 double</span>[] speedLimit<span>, double </span>speed) {<br/>    <span>for</span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= lanesCount<span>; </span>i++){<br/>      <span>if</span>(speed &lt;= speedLimit[i - <span>1</span>]){<br/>        <span>return new </span>CountByLane(<span>1</span><span>, </span>i)<span>;<br/></span><span>      </span>}<br/>    }<br/>    <span>return new </span>CountByLane(<span>1</span><span>, </span>lanesCount)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>It uses two support classes:</p>
<pre><span>private class </span>CountByLane{<br/>  <span>int </span><span>count</span><span>, </span><span>lane</span><span>;<br/></span><span>  private </span><span>CountByLane</span>(<span>int </span>count<span>, int </span>lane){<br/>    <span>this</span>.<span>count </span>= count<span>;<br/></span><span>    this</span>.<span>lane </span>= lane<span>;<br/></span><span>  </span>}<br/>  <span>public int </span><span>getLane</span>() { <span>return </span><span>lane</span><span>; </span>}<br/>  <span>public int </span><span>getCount</span>() { <span>return </span><span>count</span><span>; </span>}<br/>}</pre>
<p>It also uses the following:</p>
<pre><span>private static class </span>TrafficUnitWrapper {<br/>  <span>private </span>Vehicle <span>vehicle</span><span>;<br/></span><span>  private </span>TrafficUnit <span>trafficUnit</span><span>;<br/></span><span>  public </span><span>TrafficUnitWrapper</span>(TrafficUnit trafficUnit){<br/>    <span>this</span>.<span>vehicle </span>= FactoryVehicle.<span>build</span>(trafficUnit)<span>;<br/></span><span>    this</span>.<span>trafficUnit </span>= trafficUnit<span>;<br/></span><span>  </span>}<br/>  <span>public </span>TrafficUnitWrapper <span>setSpeedModel</span>(SpeedModel speedModel) {<br/>    <span>this</span>.<span>vehicle</span>.setSpeedModel(speedModel)<span>;<br/></span><span>    return this;<br/></span><span>  </span>}<br/>  <span>public double </span><span>calcSpeed</span>(<span>double </span>timeSec) {<br/>    <span>double </span>speed = <span>this</span>.<span>vehicle</span>.getSpeedMph(timeSec)<span>;<br/></span><span>    return </span>Math.<span>round</span>(speed * <span>this</span>.<span>trafficUnit</span>.getTraction())<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>We demonstrated the use of such support classes in <a href="488da544-ff73-4ef7-9d57-00b67479defd.xhtml">Chapter 3</a>, <em>Modular</em> <em>Programming</em>, while talking about streams. Now we realize that testing this class might not be easy. </p>
<p>Because the <kbd>SpeedModel</kbd> object is an input parameter for the <kbd>trafficByLane()</kbd> method, we could test its <kbd>getSpeedMph()</kbd> method in isolation:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testSpeedModel</span>(){<br/>  <span>double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>engineHorsePower = <span>246</span><span>;<br/></span><span>  int </span>vehicleWeightPounds = <span>4000</span><span>;<br/></span><span>  double </span>speed = getSpeedModel().getSpeedMph(timeSec<span>,<br/>                 </span>vehicleWeightPounds<span>, </span>engineHorsePower)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert vehicle (" </span>+ engineHorsePower <br/>               + <span>" hp, " </span>+ vehicleWeightPounds + <span>" lb) speed in " <br/></span>               + timeSec + <span>" sec: "</span><span>, </span><span>117</span><span>, </span>speed<span>, </span><span>0.001 </span>* speed)<span>;<br/></span>}<br/><br/><span>private </span>SpeedModel <span>getSpeedModel</span>(){<br/>  //FactorySpeedModel possibly<br/>}</pre>
<p>Refer to the following code: </p>
<pre><span>public class </span>FactorySpeedModel {<br/>  <span>public static </span>SpeedModel <span>generateSpeedModel</span>(TrafficUnit trafficUnit){<br/>    <span>return new </span>SpeedModelImpl(trafficUnit)<span>;<br/></span><span>  </span>}<br/>  <span>private static class </span>SpeedModelImpl <span>implements </span>SpeedModel{<br/>    <span>private </span>TrafficUnit <span>trafficUnit</span><span>;</span><span><br/></span><span>    private </span><span>SpeedModelImpl</span>(TrafficUnit trafficUnit){<br/>      <span>this</span>.<span>trafficUnit </span>= trafficUnit<span>;<br/></span><span>    </span>}<br/>    <span>public double </span><span>getSpeedMph</span>(<span>double </span>timeSec<span>, <br/>                              int </span>weightPounds<span>, int </span>horsePower) {<br/>      <span>double </span>traction = <span>trafficUnit</span>.getTraction()<span>;<br/></span><span>      double </span>v = <span>2.0 </span>* horsePower * <span>746 <br/></span>                 * timeSec * <span>32.174 </span>/ weightPounds<span>;<br/></span><span>      return </span>Math.<span>round</span>(Math.<span>sqrt</span>(v) * <span>0.68 </span>* traction)<span>;<br/></span><span>    </span>}<br/>  }</pre>
<p>As you can see, unfortunately, the current implementation of <kbd>FactorySpeedModel</kbd> requires the <kbd>TrafficUnit</kbd> object (in order to get the traction value). We need to modify it to extract <kbd>SpeedModel</kbd> without any dependency in <kbd>TrafficUnit</kbd> because we will now apply traction in the <kbd>calcSpeed()</kbd> method. The new version of <kbd>FactorySpeedModel</kbd> will now look like this:</p>
<pre><span>public class </span>FactorySpeedModel {<br/>  <span>public static </span>SpeedModel <span>generateSpeedModel</span>(TrafficUnit trafficUnit) {<br/>    <span>return new </span>SpeedModelImpl(trafficUnit)<span>;<br/></span><span>  </span>}<br/><strong>  public static SpeedModel getSpeedModel(){</strong><br/><strong>    return SpeedModelImpl.getSpeedModel();</strong><br/><strong>  }</strong><br/>  <span>private static class </span>SpeedModelImpl <span>implements </span>SpeedModel{<br/>    <span>private </span>TrafficUnit <span>trafficUnit</span><span>;</span><span><br/></span><span>    private </span><span>SpeedModelImpl</span>(TrafficUnit trafficUnit){<br/>      <span>this</span>.<span>trafficUnit </span>= trafficUnit<span>;<br/></span><span>    </span>}<br/>    <span>public double </span><span>getSpeedMph</span>(<span>double </span>timeSec<span>, <br/>                     int </span>weightPounds<span>, int </span>horsePower) {<br/>      <span>double </span>speed = <span>getSpeedModel</span>()<br/>             .getSpeedMph(timeSec<span>, </span>weightPounds<span>, </span>horsePower)<span>;<br/></span><span>      return </span>Math.<span>round</span>(speed *<span>trafficUnit</span>.getTraction())<span>;<br/></span><span>    </span>}<br/>    <span>public static </span>SpeedModel <span>getSpeedModel</span>(){<br/>      <span>return  </span>(t<span>, </span>wp<span>, </span>hp) -&gt; {<br/>        <span>double </span>weightPower = <span>2.0 </span>* hp * <span>746 </span>* <span>32.174 </span>/ wp<span>;<br/></span><span>        return </span>Math.<span>round</span>(Math.<span>sqrt</span>(t * weightPower) * <span>0.68</span>)<span>;<br/></span><span>      </span>}<span>;<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p>The test method could now be implemented as follows:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testSpeedModel</span>(){<br/>  <span>double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>engineHorsePower = <span>246</span><span>;<br/></span><span>  int </span>vehicleWeightPounds = <span>4000</span><span>;<br/></span><span>  double </span>speed = FactorySpeedModel.<span>generateSpeedModel</span>()<br/>                 .getSpeedMph(timeSec<span>, </span>vehicleWeightPounds<span>, <br/></span>                              engineHorsePower)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert vehicle (" </span>+ engineHorsePower <br/>               + <span>" hp, " </span>+ vehicleWeightPounds + <span>" lb) speed in " <br/></span>               + timeSec + <span>" sec: "</span><span>, </span><span>117</span><span>, </span>speed<span>, </span><span>0.001 </span>* speed)<span>;<br/></span>}</pre>
<p>However, the <kbd>calcSpeed()</kbd> method in <kbd>TrafficUnitWrapper</kbd> remains untested.</p>
<p>We could test the <kbd>trafficByLane()</kbd> method as a whole:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testTrafficByLane</span>() {<br/>  TrafficDensity1 trafficDensity = <span>new </span>TrafficDensity1()<span>;<br/></span><span>  double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>trafficUnitsNumber = <span>120</span><span>;<br/></span><span>  double</span>[] speedLimitByLane = {<span>30</span><span>, </span><span>50</span><span>, </span><span>65</span>}<span>;<br/></span><span>  </span>Integer[] expectedCountByLane = {<span>30</span><span>, </span><span>30</span><span>, </span><span>60</span>}<span>;<br/></span><span>  </span>Integer[] trafficByLane = <br/>    trafficDensity.trafficByLane(getTrafficUnitStream2(<br/>      trafficUnitsNumber)<span>, </span>trafficUnitsNumber<span>, </span>timeSec<span>, <br/></span>      FactorySpeedModel.getSpeedModel()<span>,</span>speedLimitByLane)<span>;<br/></span><span>    </span><span>assertArrayEquals</span>(<span>"Assert count of " <br/></span>              + trafficUnitsNumber + <span>" vehicles by " <br/></span>              + speedLimitByLane.<span>length </span>+<span>" lanes with speed limit " <br/></span>              + Arrays.<span>stream</span>(speedLimitByLane)<br/>                      .mapToObj(Double::toString)<br/>                      .collect(Collectors.<span>joining</span>(<span>", "</span>))<span>,<br/></span>                      expectedCountByLane<span>, </span>trafficByLane)<span>;<br/></span>}</pre>
<p>However, this would require you to create a stream of objects of <kbd>TrafficUnit</kbd> with fixed data:</p>
<pre>TrafficUnit <span>getTrafficUnit</span>(<span>int </span>engineHorsePower<span>, <br/>                           int </span>vehicleWeightPounds) {<br/>  <span>return new </span>TrafficUnit() {<br/>    <span>@Override<br/></span><span>    </span><span>public </span>Vehicle.VehicleType <span>getVehicleType</span>() {<br/>      <span>return </span>Vehicle.VehicleType.<span>TRUCK</span><span>;<br/></span><span>    </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>getHorsePower</span>() {<span>return </span><span>engineHorsePower</span><span>;</span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>getWeightPounds</span>() { <span>return </span><span>vehicleWeightPounds</span><span>; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>getPayloadPounds</span>() { <span>return </span><span>0</span><span>; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>getPassengersCount</span>() { <span>return </span><span>0</span><span>; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public double </span><span>getSpeedLimitMph</span>() { <span>return </span><span>55</span><span>; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public double </span><span>getTraction</span>() { <span>return </span><span>0.2</span><span>; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public </span>SpeedModel.RoadCondition <span>getRoadCondition</span>() {<span>return null; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public </span>SpeedModel.TireCondition <span>getTireCondition</span>() { <span>return null; </span>}<br/>    <span>@Override<br/></span><span>    </span><span>public int </span><span>getTemperature</span>() { <span>return </span><span>0</span><span>; </span>}<br/>  }<span>;<br/></span>}</pre>
<p>It is not clear how the data in the <kbd>TrafficUnit</kbd> object resulted in a different speed value. Besides, we would need to add a variety of test data--for different vehicle types and other parameters--and that is a lot of code to write and maintain.</p>
<p>This means we need to revisit the design of the <kbd>trafficByLane()</kbd> <span>method.</span> To get confidence that the method will work correctly, we need to test each step of the calculations inside the method in isolation so that each test would require little input data and allow you to have a clear understanding of the expected results. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>If you look closely at the <kbd>trafficByLane()</kbd><span> method, you will notice that the problem is caused by the location of the calculation--inside the private class <kbd>TrafficUnitWrapper</kbd>. We can move it from there and create a new method of the <kbd>TrafficDensity</kbd> class:</span></p>
<pre><span>double </span><span>calcSpeed</span>(<span>double </span>timeSec) {<br/>  <span>double </span>speed = <span>this</span>.<span>vehicle</span>.getSpeedMph(timeSec)<span>;<br/></span><span>  return </span>Math.<span>round</span>(speed * <span>this</span>.<span>trafficUnit</span>.getTraction())<span>;<br/></span>}</pre>
<p>Then, we can change its signature to this:</p>
<pre><span>double </span><span>calcSpeed</span>(Vehicle vehicle<span>, double </span>traction<span>, double </span>timeSec) {<br/>  <span>double </span>speed = vehicle.getSpeedMph(timeSec)<span>;<br/></span><span>  return </span>Math.<span>round</span>(speed * traction)<span>;<br/></span>}</pre>
<p>Add these two methods to the <kbd>TrafficUnitWrapper</kbd> class: </p>
<pre><span>public </span>Vehicle <span>getVehicle</span>() { <span>return </span><span>vehicle</span><span>; </span>}<br/><span>public double </span><span>getTraction</span>() { <span>return </span><span>trafficUnit</span>.getTraction()<span>; </span>}</pre>
<p>We can now rewrite the stream pipeline like this (the line changed is in bold font):</p>
<pre>Map&lt;Integer<span>, </span>Integer&gt; trafficByLane = stream<br/>  .limit(trafficUnitsNumber)<br/>  .map(TrafficUnitWrapper::<span>new</span>)<br/>  .map(tuw -&gt; tuw.setSpeedModel(<span>speedModel</span>))<br/>  .map(tuw -&gt; <strong>calcSpeed(tuw.getVehicle(), tuw.getTraction(), timeSec))</strong><br/>  .map(speed -&gt; countByLane(<span>lanesCount</span><span>, </span><span>speedLimitByLane</span><span>, </span>speed))<br/>      .collect(Collectors.<span>groupingBy</span>(CountByLane::getLane<span>, <br/></span>            Collectors.<span>summingInt</span>(CountByLane::getCount)))<span>;<br/></span></pre>
<p>By making the <kbd>calcSpeed()</kbd> method protected and assuming that the <kbd>Vehicle</kbd> class is tested in its own test class <kbd>VehicleTest</kbd>, we can now write <kbd>testCalcSpeed()</kbd>:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testCalcSpeed</span>(){<br/>  <span>double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  </span>TrafficDensity2 trafficDensity = <span>new </span>TrafficDensity2()<span>;<br/></span><span><br/></span><span>  </span>Vehicle vehicle = Mockito.<span>mock</span>(Vehicle.<span>class</span>)<span>;<br/></span><span>  </span>Mockito.<span>when</span>(vehicle.getSpeedMph(timeSec)).thenReturn(<span>100d</span>)<span>;</span><span><br/></span><span>  double </span>traction = <span>0.2</span><span>;<br/></span><span>  double </span>speed = trafficDensity.calcSpeed(vehicle<span>, </span>traction<span>, </span>timeSec)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert speed (traction=" </span>+ traction +<span> ") in " <br/>               </span>+ timeSec + <span>" sec: "</span><span>,</span><span>20</span><span>,</span>speed<span>,</span><span>0.001 </span>*speed)<span>;<br/></span>}</pre>
<p>The remaining functionality can now be tested by mocking the <kbd>calcSpeed()</kbd> method:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testCountByLane</span>() {<br/>  <span>int</span>[] count ={<span>0</span>}<span>;<br/></span><span>  double</span>[] speeds = <br/>                  {<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span><span>, </span><span>7</span><span>, </span><span>8</span><span>, </span><span>9</span><span>, </span><span>10</span><span>, </span><span>11</span><span>, </span><span>12</span>}<span>;</span><span><br/></span><span>  </span>TrafficDensity2 trafficDensity = <span>new </span>TrafficDensity2() {<br/>    <span>@Override<br/></span><span>    </span><span>protected double </span><span>calcSpeed</span>(Vehicle vehicle<span>, <br/>                     double </span>traction<span>, double </span>timeSec) {<br/>      <span>return </span><span>speeds</span>[<span>count</span>[<span>0</span>]++]<span>;<br/></span><span>    </span>}<br/>  }<span>;<br/></span><span>  double </span>timeSec = <span>10.0</span><span>;<br/></span><span>  int </span>trafficUnitsNumber = speeds.<span>length</span><span>;<br/></span><span><br/></span><span>  double</span>[] speedLimitByLane = {<span>4.5</span><span>, </span><span>8.5</span><span>, </span><span>12.5</span>}<span>;<br/></span><span>  </span>Integer[] expectedCountByLane = {<span>4</span><span>, </span><span>4</span><span>, </span><span>4</span>}<span>;<br/></span><span><br/></span><span>  </span>Integer[] trafficByLane = trafficDensity.trafficByLane( <br/>    getTrafficUnitStream(trafficUnitsNumber)<span>, <br/></span>    trafficUnitsNumber<span>,</span> timeSec<span>, FactorySpeedModel.</span>getSpeedModel()<span>,<br/>    </span>speedLimitByLane )<span>;<br/></span><span>  </span><span>assertArrayEquals</span>(<span>"Assert count of " </span>+ speeds.<span>length <br/></span>          + <span>" vehicles by " </span>+ speedLimitByLane.<span>length <br/></span>          + <span>" lanes with speed limit " <br/></span>          + Arrays.<span>stream</span>(speedLimitByLane)<br/>                  .mapToObj(Double::toString).collect(Collectors<br/>                  .<span>joining</span>(<span>", "</span>))<span>, </span>expectedCountByLane<span>, </span>trafficByLane)<span>;<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>This experience has made us aware that using an inner private class can make the functionality untestable in isolation. Let's try and get rid of the <kbd>private</kbd> class <kbd>CountByLane</kbd>. This leads us to the third version of the <kbd>TrafficDensity3</kbd> class (we have shown the code that has changed in bold):</p>
<pre>Integer[] <span>trafficByLane</span>(Stream&lt;TrafficUnit&gt; stream<span>, <br/>int </span>trafficUnitsNumber<span>, double </span>timeSec<span>,<br/></span>SpeedModel speedModel<span>, double</span>[] speedLimitByLane) {<br/>  <span>int </span>lanesCount = speedLimitByLane.<span>length</span><span>;<br/></span><span>  </span>Map&lt;Integer<span>, </span>Integer&gt; trafficByLane = <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span>  for</span>(<span>int </span>i = <span>1</span><span>; </span>i &lt;= lanesCount<span>; </span>i++){<br/>    trafficByLane.put(i<span>, </span><span>0</span>)<span>;<br/></span><span>  </span>}<br/>  stream.limit(trafficUnitsNumber)<br/>    .map(TrafficUnitWrapper::<span>new</span>)<br/>    .map(tuw -&gt; tuw.setSpeedModel(<span>speedModel</span>))<br/>    .map(tuw -&gt; calcSpeed(tuw.getVehicle()<span>, <br/></span>                          tuw.getTraction()<span>, </span><span>timeSec</span>))<br/><strong>    .forEach(speed -&gt; trafficByLane.computeIfPresent(</strong><br/><strong>      calcLaneNumber(lanesCount, <br/>                     speedLimitByLane, speed), (k, v) -&gt; ++v));<br/></strong>    return trafficByLane.values().toArray(new Integer[lanesCount]);<strong><br/></strong>}<br/><strong>protected int calcLaneNumber(int lanesCount, <br/>  double[] speedLimitByLane, double speed) {</strong><br/><strong>    for(int i = 1; i &lt;= lanesCount; i++){</strong><br/><strong>      if(speed &lt;= speedLimitByLane[i - 1]){</strong><br/><strong>        return i;<br/>      }</strong><br/><strong>    }</strong><br/><strong>    return lanesCount;<br/>}</strong></pre>
<p>This change allows us to extend the class in the test:</p>
<pre><span>private class </span>TrafficDensityTestCalcLaneNumber <br/><span>extends </span>TrafficDensity3 {<br/>  <span>protected int </span><span>calcLaneNumber</span>(<span>int </span>lanesCount<span>, <br/>    double</span>[] speedLimitByLane<span>, double </span>speed){<br/>    <span>return super</span>.calcLaneNumber(lanesCount<span>, <br/></span>    speedLimitByLane<span>, </span>speed)<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>It also allows us to change the test method <kbd>calcLaneNumber()</kbd> in isolation:</p>
<pre><span>@Test<br/></span><span>public void </span><span>testCalcLaneNumber</span>() {<br/>  <span>double</span>[] speeds = {<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span><span>, </span><span>7</span><span>, </span><span>8</span><span>, </span><span>9</span><span>, </span><span>10</span><span>, </span><span>11</span><span>, </span><span>12</span>}<span>;<br/></span><span>  double</span>[] speedLimitByLane = {<span>4.5</span><span>, </span><span>8.5</span><span>, </span><span>12.5</span>}<span>;<br/></span><span>  int</span>[] expectedLaneNumber = {<span>1</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>1</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>3</span><span>, </span><span>3</span><span>, </span><span>3</span>}<span>;<br/></span><span><br/></span><span>  </span>TrafficDensityTestCalcLaneNumber trafficDensity = <br/><span>               new </span>TrafficDensityTestCalcLaneNumber()<span>;<br/></span><span>  for</span>(<span>int </span>i = <span>0</span><span>; </span>i &lt; speeds.<span>length</span><span>; </span>i++){<br/>    <span>int </span>ln = trafficDensity.calcLaneNumber(<br/>               speedLimitByLane.<span>length</span><span>, <br/></span>               speedLimitByLane<span>, </span>speeds[i])<span>;<br/></span><span>    </span><span>assertEquals</span>(<span>"Assert lane number of speed " <br/></span>                + speeds + <span>" with speed limit "</span><span> <br/></span>                + Arrays.<span>stream</span>(speedLimitByLane)<br/>                        .mapToObj(Double::toString).collect(<br/>                              Collectors.<span>joining</span>(<span>", "</span>))<span>, <br/></span>                expectedLaneNumber[i]<span>, </span>ln)<span>;<br/></span><span>  </span>}<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipes in this chapter:</p>
<ul>
<li>Using fixtures to populate data for testing</li>
<li>Behavioral testing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using fixtures to populate data for testing</h1>
                </header>
            
            <article>
                
<p>In more complex applications (which use a database, for example), there is often a need to set up the same data before each test and clean it up after each test is run. Some parts of the data need to be set before each test method and cleaned afterwards. You'd also need to have another setup configured before you run the test class, and it should be cleaned up afterwards.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>To accomplish this, you can dedicate a method that does the setup by writing a </span><kbd>@Before</kbd> <span>annotation</span> <span>in front of it. The corresponding cleaning method is identified by the</span> <kbd>@After</kbd><span> annotation. Similar class-level methods are annotated by</span> <kbd>@BeforeClass</kbd> <span>and</span> <kbd>@AfterClass</kbd><span>. </span>Here is a quick demo of this. Add the following methods:</p>
<pre><span>public class </span>DatabaseRelatedTest {<br/>  <span>@BeforeClass<br/></span><span>  </span><span>public static void </span><span>setupForTheClass</span>(){<br/>    System.<span>out</span>.println(<span>"setupForTheClass() is called"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>@AfterClass<br/></span><span>  </span><span>public static void </span><span>cleanUpAfterTheClass</span>(){<br/>    System.<span>out</span>.println(<span>"cleanAfterClass() is called"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>@Before<br/></span><span>  </span><span>public void </span><span>setupForEachMethod</span>(){<br/>    System.<span>out</span>.println(<span>"setupForEachMethod() is called"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>@After<br/></span><span>  </span><span>public void </span><span>cleanUpAfterEachMethod</span>(){<br/>    System.<span>out</span>.println(<span>"cleanAfterEachMethod() is called"</span>)<span>;<br/></span><span>  </span>}<br/>  <span>@Test<br/></span><span>  </span><span>public void </span><span>testMethodOne</span>(){      <br/>    System.<span>out</span>.println(<span>"testMethodOne() is called"</span>)<span>; <br/></span>  }<br/>  <span>@Test<br/></span><span>  </span><span>public void </span><span>testMethodTwo</span>(){ <br/>    System.<span>out</span>.println(<span>"testMethodTwo() is called"</span>)<span>; <br/></span>  }<br/>}</pre>
<p>If you run the tests now, you'll get the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img height="142" width="422" class="image-border" src="assets/fca629ca-04df-4c56-a42d-40b00d388119.png"/></div>
<p>Such methods that "fix" the test context are called <strong>fixtures</strong>. Notice that they have to be public, and the class-level setup/cleanup fixtures have to be static. The upcoming JUnit 5 plans to lift these constraints, though.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A typical example of such a usage would be creating necessary tables before the first test method is run and removing them after the last method of the test class is finished. The setup/cleanup methods can also be used to create/close a database connection unless your code does it in the try-with-resources construct (refer to <a href="01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml">Chapter 12</a>, <em>Memory Management and Debugging</em>). </p>
<p>Here is an example of the usage of fixtures (refer to <a href="41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml">Chapter 6</a>, <em>Database Programming</em> on how to set up a database for running it). Let's assume we need to test the <kbd>DbRelatedMethods</kbd> class:</p>
<pre><span>class </span>DbRelatedMethods{<br/>  <span>public void </span><span>updateAllTextRecordsTo</span>(String text){<br/>    executeUpdate(<span>"update text set text = ?"</span><span>, </span>text)<span>;<br/></span><span>  </span>}<br/>  <span>private void </span><span>executeUpdate</span>(String sql<span>, </span>String text){<br/>    <span>try </span>(Connection conn = getDbConnection()<span>;<br/></span><span>      </span>PreparedStatement st = conn.prepareStatement(sql)){<br/>        st.setString(<span>1</span><span>, </span>text)<span>;<br/></span><span>        </span>st.executeUpdate()<span>;<br/></span><span>      </span>} <span>catch </span>(Exception ex) {<br/>        ex.printStackTrace()<span>;<br/></span><span>      </span>}<br/>    }<br/>    <span>private </span>Connection <span>getDbConnection</span>(){<br/>       ...    <br/>    }<br/>}</pre>
<p>We would like to make sure that this method always updates all the records of the <kbd>text</kbd> table with the provided value. Our first test is to update all the existing records:</p>
<pre><span>@Test<br/></span><span>public void updateAllTextRecordsTo1</span>(){<br/>  System.<span>out</span>.println(<span>"updateAllTextRecordsTo1() is called"</span>)<span>;<br/></span><span>  </span>String testString = <span>"Whatever"</span><span>;<br/></span><span>  </span>System.<span>out</span>.println(<span>"  Update all records to " </span>+ testString)<span>;<br/></span><span>  </span><span>dbRelatedMethods</span>.updateAllTextRecordsTo(testString)<span>;<br/></span><span>  int </span>count = countRecordsWithText(testString)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert number of records with " <br/></span>                + testString + <span>": "</span><span>, </span><span>1</span><span>, </span>count)<span>;<br/></span><span>  </span>System.<span>out</span>.println(<span>"All records are updated to " </span>+ testString)<span>;<br/></span>}</pre>
<p>This means that the table has to exist in the test database and should have a record in it.</p>
<p>Our second test makes sure that all the records are updated even if there is more than one record, and each record contains a different value:</p>
<pre><span>@Test<br/></span><span>public void </span><span>updateAllTextRecordsTo2</span>(){<br/>  System.<span>out</span>.println(<span>"updateAllTextRecordsTo2() is called"</span>)<span>;<br/></span><span>  </span>String testString = <span>"Whatever"</span><span>;<br/></span><span>  </span>System.<span>out</span>.println(<span>"  Update all records to Unexpected"</span>)<span>;<br/></span><span>  </span><span>dbRelatedMethods</span>.updateAllTextRecordsTo(<span>"Unexpected"</span>)<span>;<br/></span><span>  </span><span>executeUpdate</span>(<span>"insert into text(id, text) values(2, ?)"</span><span>,</span><span><br/>                                                "Text 01"</span>)<span>;<br/></span><span>  S</span>ystem.<span>out</span>.println(<span>"Update all records to " </span> + testString)<span>;<br/></span><span>  </span><span>dbRelatedMethods</span>.updateAllTextRecordsTo(testString)<span>;<br/></span><span>  int </span>count = countRecordsWithText(testString)<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert number of records with " <br/></span>               + testString + <span>": "</span><span>, </span><span>2</span><span>, </span>count)<span>;<br/></span><span>  </span>System.<span>out</span>.println(<span>"  " </span>+ count + <span>" records are updated to " </span>+<br/>                     testString)<span>;<br/></span>}</pre>
<p>Both the tests use the same table, that is, <kbd>text</kbd>. Therefore, there is no need to drop it after each test. This is why we create and drop it at the class level:</p>
<pre><span>@BeforeClass<br/></span><span>public static void </span><span>setupForTheClass</span>(){<br/>  System.<span>out</span>.println(<span>"setupForTheClass() is called"</span>)<span>;<br/></span><span>  </span><span>execute</span>(<span>"create table text (id integer not null, <br/>          text character varying not null)"</span>)<span>;<br/></span>}<br/><span>@AfterClass<br/></span><span>public static void </span><span>cleanUpAfterTheClass</span>(){<br/>  System.<span>out</span>.println(<span>"cleanAfterClass() is called"</span>)<span>;<br/></span><span>  </span><span>execute</span>(<span>"drop table text"</span>)<span>;<br/></span>}</pre>
<p>This means that all we need to do is populate the table before each test and clean it up:</p>
<pre><span>@Before<br/></span><span>public void </span><span>setupForEachMethod</span>(){<br/>  System.<span>out</span>.println(<span>"setupForEachMethod() is called"</span>)<span>;<br/></span><span>  </span><span>executeUpdate</span>(<span>"insert into text(id, text) values(1,?)"</span><span>, </span><span>"Text 01"</span>)<span>;<br/></span>}<br/><span>@After<br/></span><span>public void </span><span>cleanUpAfterEachMethod</span>(){<br/>  System.<span>out</span>.println(<span>"cleanAfterEachMethod() is called"</span>)<span>;<br/></span><span>  </span><span>execute</span>(<span>"delete from text"</span>)<span>;<br/></span>}</pre>
<p>Also, since we can use the same object for all the tests, let's create it on the class level too (as the test class's property):</p>
<pre><span>private </span>DbRelatedMethods <span>dbRelatedMethods </span>= <span>new </span>DbRelatedMethods()<span>;<br/></span></pre>
<p>If we run all the tests of the <kbd>test</kbd> class now, the output would look like this: </p>
<div class="CDPAlignCenter CDPAlign"><img height="266" width="403" class="image-border" src="assets/85cfcf20-c1a0-4a23-af85-6161b5635397.png"/></div>
<p>The printed messages allow you to trace the sequence of all the method calls and see that they are executed as expected. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Refer to the following recipe in this chapter:</p>
<ul>
<li>Behavioral testing</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Behavioral testing</h1>
                </header>
            
            <article>
                
<p>If you have read all the chapters and have looked at the code examples, you may have probably noticed that by now, we have discussed and built all the components necessary for a typical distributed application. Now is the time to put all the components together and see whether they cooperate as expected. This process is called integration.  </p>
<p>While doing this, we will look closely at assessing whether the application behaves according to the requirements. In cases where functional requirements are presented in an executable form (using the Cucumber framework, for example), we can run them and check whether all the checks pass. Many software companies follow a behavior-driven development process and perform testing very early, sometimes even before any substantial amount of code is written (such tests fail, of course, but succeed as soon as the expected functionality is implemented). As mentioned already, early testing can be very helpful for writing focused, clear, and well-testable code.</p>
<p>However, even without strict adherence to the <em>test-first</em> process, the integration phase naturally includes some kind of behavioral testing. In this recipe, we will see several possible approaches and specific examples related to this. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>You might have noticed that in the course of this book, we have built several classes that compose an application that analyzes and models traffic. For your convenience, we have included all of them in the <kbd>com.packt.cookbook.ch15_testing</kbd> package. You're already familiar with (from <span>Chapters 2, 4, 5, and 7)</span> the five interfaces in the <kbd>api</kbd> folder: <kbd>Car</kbd>, <kbd>SpeedModel</kbd>, <kbd>TrafficUnit</kbd>, <kbd>Truck</kbd>, and <kbd>Vehicle</kbd>. Their implementations are encapsulated inside classes called <em>factories</em> in the folder with the same name <span>(used in </span><span>Chapters 2, 4, 5, and 7</span>): <kbd>FactorySpeedModel</kbd>, <kbd>FactoryTraffic</kbd>, and <kbd>FactoryVehicle</kbd>. These factories produced input for the functionality of the <kbd>AverageSpeed</kbd> classes (<a href="e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml">Chapter 7</a>, <em>Concurrent and Multithreaded Programming</em>) and <kbd>TrafficDensity</kbd> (based on <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter 5</a>, <em>Stream Operations and Pipelines</em> but created and discussed in the current chapter)--the core classes of our demo application. They produce the values that motivated the development of this particular application in the first place. </p>
<p>The main functionality of the application is straightforward. For a given number of lanes and speed limit for each lane, <kbd>AverageSpeed</kbd> calculates (estimates) the actual speed of each lane (assuming all the drivers are behaving rationally, taking the lane according to their speed), while <kbd>TrafficDensity</kbd> calculates the number of vehicles in each lane after 10 sec (assuming all the cars start at the same time after the traffic light). The calculations are done based on the data from <kbd>numberOfTrafficUnits</kbd> vehicles collected at a certain location and time of the year. It does not mean that all the thousand vehicles were racing at the same time. These 1,000 measuring points have been collected over 50 years for approximately 20 vehicles that drove at the specified intersection during the specified hour (which means one vehicle every three minutes on average).</p>
<p>The overall infrastructure of the application is supported by the classes in the <kbd>process</kbd> folder: <kbd>Dispatcher</kbd>, <kbd>Processor</kbd>, and <kbd>Subscription</kbd> (we discussed their functionality and demonstrated them in <a href="e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml">Chapter 7</a>, <em>Concurrent and Multithreaded Programming</em> ). These classes allow distributed processing. The <kbd>Dispatcher</kbd> class sends a request for processing to the population of <kbd>Processors</kbd> in a pool, using the <kbd>Subscription</kbd> class. Each <kbd>Processor</kbd> class performs the task according to the request (using the <kbd>AverageSpeed</kbd> <span>and</span> <kbd>TraffciDensity</kbd> classes<span>) and stores the results in the database (using the <kbd>DbUtil</kbd> class in the <kbd>utils</kbd> folder, based on the functionality discussed in <a href="41632f15-3abe-4f59-8ce9-009aacfbe1cf.xhtml">Chapter 6</a>, <em>Database Programming</em>).</span></p>
<p>We have tested most of these classes as units. Now we are going to integrate them and test the application as a whole for correct behavior. </p>
<p>The requirements were made up just for demo purposes. The goal was to have something well motivated (resembling real data) and at the same time simple enough to understand without special knowledge of traffic analysis and modeling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>There are several levels of integration. We need to integrate the classes and subsystems of the application and also integrate our application with the external system (the source of the traffic data developed and maintained by a third party). Here is an example of class-level integration (see the <kbd>demo1_class_level_integration()</kbd> method in the <kbd>Chapter15Testing</kbd> class):</p>
<pre>String result = IntStream.<span>rangeClosed</span>(<span>1</span><span>, <br/></span><span>  speedLimitByLane</span>.<span>length</span>).mapToDouble(i -&gt; {<br/>    AverageSpeed averageSpeed = <br/><span>      new </span>AverageSpeed(<span>trafficUnitsNumber</span><span>, </span><span>timeSec</span><span>, <br/></span><span>                       dateLocation</span><span>, </span><span>speedLimitByLane</span><span>, </span>i<span>,</span><span>100</span>)<span>;<br/></span><span>    </span>ForkJoinPool commonPool = ForkJoinPool.<span>commonPool</span>()<span>;<br/></span><span>    return </span>commonPool.invoke(averageSpeed)<span>;<br/></span>}).mapToObj(Double::toString).collect(Collectors.<span>joining</span>(<span>", "</span>))<span>;<br/></span>System.<span>out</span>.println(<span>"Average speed = " </span>+ result)<span>;<br/></span><span><br/></span>TrafficDensity trafficDensity = new TrafficDensity();<br/>Integer[] trafficByLane = <br/><span>     trafficDensity</span>.trafficByLane(<span>trafficUnitsNumber</span><span>,<br/>                    </span><span>timeSec</span><span>, </span><span>dateLocation</span><span>, </span><span>speedLimitByLane </span>)<span>;<br/></span>System.<span>out</span>.println(<span>"Traffic density = "</span> + Arrays.<span>stream</span>(trafficByLane)<br/>                                  .map(Object::toString)<br/>                                  .collect(Collectors.<span>joining</span>(<span>", "</span>)))<span>;<br/></span></pre>
<p>In this example, we integrated each of the two main classes, namely <kbd>AverageSpeed</kbd> and <kbd>TrafficDensity</kbd>, with factories and implementation of their API interfaces.</p>
<p>The results are as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="39" width="403" class="image-border" src="assets/da2c3168-be61-45cc-83e9-990473e412e2.png"/></div>
<p>Notice that the results are slightly different from one run to another. This is because the data produced by <kbd>FactoryTraffic</kbd> varies from one request to another. But, at this stage, we just have to make sure that everything works together and produce some more or less accurate-looking results. We have tested the code by units and have a level of confidence that it is doing what it is supposed to do. We will get back to the results' validation during the actual integration <em>testing</em> process, not during integration.</p>
<p>After finishing the integration at the class level, see how the subsystems work together <span>(see the </span><kbd>demo1_subsystem_level_integration()</kbd> <span>method</span> <span>in</span> the <kbd>Chapter15Testing</kbd> <span>class)</span>:</p>
<pre>DbUtil.<span>createResultTable</span>()<span>;</span><span><br/></span>Dispatcher.<span>dispatch</span>(<span>trafficUnitsNumber</span><span>, timeSec</span><span>,</span><span> dateLocation</span><span>, <br/>                    </span><span>speedLimitByLane</span>)<span>;</span><span><br/></span><span>try </span>{ Thread.<span>sleep</span>(<span>2000L</span>)<span>; </span>} <br/><span>catch </span>(InterruptedException ex) {}<br/>Arrays.<span>stream</span>(Process.<span>values</span>()).forEach(v -&gt; {<br/>  System.<span>out</span>.println(<span>"Result " </span>+ v.name() + <span>": " <br/></span>                     + DbUtil.<span>selectResult</span>(v.name()))<span>;<br/></span>})<span>;<br/></span></pre>
<p>In this code, you can see that we used <kbd>DBUtil</kbd> to create the necessary table that holds the input data and the results (produced and recorded by <kbd>Processor</kbd>). The <kbd>Dispatcher</kbd> class sends a request and inputs data to the objects of the <kbd>Processor</kbd> class, as shown here:</p>
<pre><span>void </span><span>dispatch</span>(<span>int </span>trafficUnitsNumber<span>, double </span>timeSec<span>, <br/></span>         DateLocation dateLocation<span>, double</span>[] speedLimitByLane) {<br/>  ExecutorService execService =  ForkJoinPool.<span>commonPool</span>()<span>;<br/></span><span>  try </span>(SubmissionPublisher&lt;Integer&gt; publisher = <br/><span>                              new </span>SubmissionPublisher&lt;&gt;()){<br/>    <span>subscribe</span>(publisher<span>, </span>execService<span>,</span>Process.<span>AVERAGE_SPEED</span><span>, <br/></span>              timeSec<span>, </span>dateLocation<span>, </span>speedLimitByLane)<span>;<br/></span><span>   </span><span>subscribe</span>(publisher<span>,</span>execService<span>,</span>Process.<span>TRAFFIC_DENSITY</span><span>, <br/></span>             timeSec<span>, </span>dateLocation<span>, </span>speedLimitByLane)<span>;<br/></span><span>    </span>publisher.submit(trafficUnitsNumber)<span>;<br/></span><span>  </span>} <span>finally </span>{<br/>    <span>try </span>{<br/>      execService.shutdown()<span>;<br/></span><span>      </span>execService.awaitTermination(<span>1</span><span>, </span>TimeUnit.<span>SECONDS</span>)<span>;<br/></span><span>    </span>} <span>catch </span>(Exception ex) {<br/>      System.<span>out</span>.println(ex.getClass().getName())<span>;<br/></span><span>    </span>} <span>finally </span>{<br/>      execService.shutdownNow()<span>;<br/></span><span>    </span>}<br/>  }<br/>}</pre>
<p><span>The</span> <span><kbd>Subscription</kbd> class is used to send/get the message (</span>refer to <a href="e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml">Chapter 7</a>, <em>Concurrent and Multithreaded Programming</em> for a description of this functionality):</p>
<pre><span>void </span><span>subscribe</span>(SubmissionPublisher&lt;Integer&gt; publisher<span>, <br/></span>              ExecutorService execService<span>, </span>Process process<span>, <br/>              double </span>timeSec<span>, </span>DateLocation dateLocation<span>, <br/>              double</span>[] speedLimitByLane) {<br/>  Processor&lt;Integer&gt; subscriber = <span> new </span>Processor&lt;&gt;(process<span>, </span>timeSec<span>, <br/></span>                                 dateLocation<span>, </span>speedLimitByLane)<span>;<br/></span><span>  </span>Subscription subscription = <span>new </span>Subscription(subscriber<span>, </span>execService)<span>;<br/></span><span>  </span>subscriber.onSubscribe(subscription)<span>;<br/></span><span>  </span>publisher.subscribe(subscriber)<span>;<br/></span>}</pre>
<p>The processors are doing their job; we just need to wait for a few seconds (you might adjust this time if the computer you are using requires more time to finish the job) before we get the results (using DBUtil for reading the recorded results from the database):</p>
<div class="CDPAlignCenter CDPAlign"><img height="47" width="496" class="image-border" src="assets/065b3686-1952-49c0-a757-b0684adf772f.png"/></div>
<p>The names of the <kbd>Process</kbd> enum class point to the corresponding records in the <kbd>result</kbd> table in the database. Again, at this stage, we are primarily looking for getting any results at all, not at how correct the values are.</p>
<p>After the successful integration between the subsystems of our application (based on the generated data from <kbd>FactoryTraffic</kbd>), we can try and connect to the external system that provides real traffic data. Inside <kbd>FactoryTraffic</kbd>, we would now switch from generating <kbd>TrafficUnit</kbd> <span>objects</span> to getting data from a real system:</p>
<pre><span>public class </span>FactoryTraffic {<br/>  <span>private static <strong>boolean </strong></span><strong>switchToRealData = true</strong><span><strong>;</strong><br/></span><span>  public static </span>Stream&lt;TrafficUnit&gt; <br/><span>  getTrafficUnitStream</span>(DateLocation dl<span>, int </span>trafficUnitsNumber){<br/>    <span>if</span>(<strong>switchToRealData</strong>){<br/>      <span>return </span><span>getRealData</span>(dL<span>,  </span>trafficUnitsNumber)<span>;<br/></span><span>    </span>} <span>else </span>{<br/>      return IntStream.range(0, trafficUnitsNumber)<br/>      .mapToObj(i -&gt; generateOneUnit());<span><br/></span><span>    </span>}<br/>  }<br/><br/>  <span>private static </span>Stream&lt;TrafficUnit&gt; <br/><span>  getRealData</span>(DateLocation dl<span>, int </span>trafficUnitsNumber) {<br/>    /<span>/connect to the source of the real data <br/>    // and request the flow or collection of data<br/></span><span>    </span><span>return new </span>ArrayList&lt;TrafficUnit&gt;().stream()<span>;<br/></span><span>  </span>}<br/>}</pre>
<p>The switch can be implemented as a Boolean property in the class (as seen in the preceding code) or the project configuration property. We leave out the details of the connection to a particular source of real traffic data as this is not relevant to the purpose of this book.</p>
<p>The main focus at this stage has to be the performance and having a smooth data flow between the external source of real data and our application. After we have made sure that everything works and produces results (that look realistic) with satisfactory performance, we can turn to integration <em>testing</em> (with the actual results' assertion). </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>For testing, we need to set the expected values, which we can then can compare with the (actual) values, produced by the application that processes real data. But real data change slightly from run to run, and an attempt to predict the resulting values either makes the test fragile or forces the introduction of a huge margin of error, which may effectively defeat the purpose of testing.  </p>
<p>We cannot even mock the generated data (as we did in the case of unit testing) because we are at the integration stage and have to use the real data. </p>
<p>One possible solution would be to store the incoming real data and the result our application produced along with them in the database. Then, a domain specialist can walk through each record and assert whether the results are as expected. </p>
<p>To accomplish this, we introduced a boolean switch in the <kbd>TrafficDensity</kbd> class, so it records the input along with each unit of the calculations: </p>
<pre>public class TrafficDensity {<br/><strong>  public static Connection conn;</strong><br/><strong>  public static boolean recordData = false;</strong><br/>  //... <br/>  private double calcSpeed(TrafficUnitWrapper tuw, double timeSec){<br/>    double speed = calcSpeed(tuw.getVehicle(),       <br/>    tuw.getTrafficUnit().getTraction(), timeSec);<br/><strong>    if(recordData) {</strong><br/><strong>      DbUtil.recordData(conn, tuw.getTrafficUnit(), speed);</strong><br/><strong>    }</strong><br/>    return speed;<br/>  }<br/>  //...<br/>} </pre>
<p>We have also introduced a static property to keep the same database connection across all the class instances. Otherwise, the connection pool should be very big because, as you may recall from <a href="e97e9c98-9673-4d3e-822f-780bab1d256d.xhtml">Chapter 7</a>, <em>Concurrent and Multithreaded Programming</em>, the number of workers that execute the task in parallel grows with the growth of the amount of work to do.</p>
<p>If you look at <kbd>DbUtils</kbd>, you will see a new method that creates the <kbd>data</kbd> table (designed to hold <kbd>TrafficUnits</kbd> coming from <kbd>FactoryTraffic</kbd>) and the <kbd>data_common</kbd> table that keeps the main parameters used for data requests and calculations: requested traffic units' number, the date and geolocation of the traffic data, time in seconds (the point when the speed is calculated), and the speed limit for each lane (its size defines how many lanes we plan to use while modeling the traffic). Here is the code that we configure to do the recording:</p>
<pre><span>private static void </span><span>demo3_prepare_for_integration_testing</span>(){<br/>  DbUtil.<span>createResultTable</span>()<span>;<br/></span><span>  </span>DbUtil.<span>createDataTables</span>()<span>;<br/></span><span>  </span>TrafficDensity.<span>recordData </span>= <span>true;<br/></span><span>  try</span>(Connection conn = DbUtil.<span>getDbConnection</span>()){<br/>    TrafficDensity.<span>conn </span>= conn<span>;<br/></span><span>    </span>Dispatcher.<span>dispatch</span>(<span>trafficUnitsNumber</span><span>, </span><span>timeSec</span><span>, <br/></span><span>                        dateLocation</span><span>, </span><span>speedLimitByLane</span>)<span>;<br/></span><span>  </span>} <span>catch </span>(SQLException ex){<br/>    ex.printStackTrace()<span>;<br/></span><span>  </span>}<br/>}</pre>
<p> After the recording is completed, we can turn the data over to a domain specialist who can assert the correctness of the application behavior. </p>
<p>The verified data can now be used for integration testing. We can add another switch to <kbd>FactoryTrafficUnit</kbd> and force it to read the recorded data instead of the unpredictable real or generated ones:</p>
<pre><span>public class </span>FactoryTraffic {<br/>  <strong>public static boolean readDataFromDb = </strong><span><strong>false;</strong><br/></span><span>  private static boolean </span><span>switchToRealData </span>= <span>false;<br/></span><span>  public static </span>Stream&lt;TrafficUnit&gt; <br/><span>                 getTrafficUnitStream</span>(DateLocation dl<span>,<br/>                                     int </span>trafficUnitsNumber){<br/><strong>    if(readDataFromDb){</strong><br/><strong>      if(!DbUtil.isEnoughData(trafficUnitsNumber)){</strong><br/><strong>        System.out.println("Not enough data");<br/>        return new ArrayList&lt;TrafficUnit&gt;().stream();<br/>      }</strong><br/><strong>      return readDataFromDb(trafficUnitsNumber);<br/>    }</strong><br/>    //....<br/>}</pre>
<p>As you may have noticed, we have also added method <kbd>isEnoughData()</kbd> that checks whether there is enough recorded data:</p>
<pre><span>public static boolean </span><span>isEnoughData</span>(<span>int </span>trafficUnitsNumber){<br/>  <span>try </span>(Connection conn = <span>getDbConnection</span>()<span>;<br/></span><span>  </span>PreparedStatement st = <br/>      conn.prepareStatement(<span>"select count(*) from data"</span>)){<br/>    ResultSet rs = st.executeQuery()<span>;<br/></span><span>    if</span>(rs.next()){<br/>      <span>int </span>count = rs.getInt(<span>1</span>)<span>;<br/></span><span>      return </span>count &gt;= trafficUnitsNumber<span>;<br/></span><span>    </span>}<br/>  } <span>catch </span>(Exception ex) {<br/>    ex.printStackTrace()<span>;<br/></span><span>  </span>}<br/>  <span>return false;<br/></span>}</pre>
<p>This will help avoid the unnecessary frustration of debugging the test problem, especially in the case of testing a more complex system.</p>
<p>Now we can predict not only the input data, but also the expected results that we can use to assert the application behavior. Both are now included in the <kbd>TrafficUnit</kbd> object. To be able to do this, we took advantage of the new Java interface feature discussed in <a href="8fa56f18-959c-4d24-8073-c4cb67c30355.xhtml">Chapter 2</a>, <em>Fast Track to OOP - Classes and Interfaces</em>, which is the default method:</p>
<pre><span>public interface </span>TrafficUnit {<br/>  VehicleType <span>getVehicleType</span>()<span>;<br/></span><span>  int </span><span>getHorsePower</span>()<span>;<br/></span><span>  int </span><span>getWeightPounds</span>()<span>;<br/></span><span>  int </span><span>getPayloadPounds</span>()<span>;<br/></span><span>  int </span><span>getPassengersCount</span>()<span>;<br/></span><span>  double </span><span>getSpeedLimitMph</span>()<span>;<br/></span><span>  double </span><span>getTraction</span>()<span>;<br/></span><span>  </span>RoadCondition <span>getRoadCondition</span>()<span>;<br/></span><span>  </span>TireCondition <span>getTireCondition</span>()<span>;<br/></span><span>  int </span><span>getTemperature</span>()<span>;<br/></span><strong>  default double getSpeed(){ return 0.0; }</strong><br/>}</pre>
<p>So, we can attach the result to the input data. See the following method:</p>
<pre>List&lt;TrafficUnit&gt; <span>selectData</span>(<span>int </span>trafficUnitsNumber){...}</pre>
<p>We can attach the result to the <kbd>DbUtil</kbd> class and the <kbd>TrafficUnitImpl</kbd> class inside <kbd>DbUtil</kbd> too:</p>
<pre><span>class </span>TrafficUnitImpl <span>implements </span>TrafficUnit{<br/>  <span>private int </span><span>horsePower</span><span>, </span><span>weightPounds</span><span>, </span><span>payloadPounds</span><span>, <br/></span><span>              passengersCount</span><span>, </span><span>temperature</span><span>;<br/></span><span>  private </span>Vehicle.VehicleType <span>vehicleType</span><span>;<br/></span><span>  private double </span><span>speedLimitMph</span><span>, </span><span>traction</span><span>, </span><strong>speed</strong><span>;<br/></span><span>  private </span>RoadCondition <span>roadCondition</span><span>;<br/></span><span>  private </span>TireCondition <span>tireCondition</span><span>;<br/>  ...<br/>  <strong>public double getSpeed() { return speed; }</strong><br/>}</span></pre>
<p>We can attach it inside the <kbd>DbUtil</kbd> class too.</p>
<p>Now we can write an integration test. First, we will test the speed model using the recorded data:</p>
<pre><span>void </span><span>demo1_test_speed_model_with_real_data</span>(){<br/>  <span>double </span>timeSec = DbUtil.<span>getTimeSecFromDataCommon</span>()<span>;<br/></span><span>  </span>FactoryTraffic.<span>readDataFromDb </span>= <span>true;<br/></span><span>  </span>TrafficDensity trafficDensity = <span>new </span>TrafficDensity()<span>;<br/></span><span>  </span>FactoryTraffic.<span>getTrafficUnitStream</span>(<span>dateLocation</span><span>, </span><span>1000</span>).forEach(tu -&gt; {<br/>    Vehicle vehicle = FactoryVehicle.<span>build</span>(tu)<span>;<br/></span><span>    </span>vehicle.setSpeedModel(FactorySpeedModel.<span>getSpeedModel</span>())<span>;<br/></span><span>    double </span>speed = <span>trafficDensity</span>.calcSpeed(vehicle<span>, <br/></span>                               tu.getTraction()<span>, </span><span>timeSec</span>)<span>;<br/></span><span>    </span><span>assertEquals</span>(<span>"Assert vehicle (" </span>+ tu.getHorsePower() <br/>                 + <span>" hp, " </span>+ tu.getWeightPounds() + <span>" lb) speed in " <br/></span>                 + <span>timeSec</span> + <span>" sec: "</span><span>, </span>tu.getSpeed()<span>, </span>speed<span>, <br/></span>                 speed * <span>0.001</span>)<span>;<br/></span><span>  </span>})<span>;<br/></span>}</pre>
<p>A similar test can be written for testing the speed calculation of the <kbd>AverageSpeed</kbd> class with real data.</p>
<p>Then, we can write an integration test for the class level:</p>
<pre><span>private static void </span><span>demo2_class_level_integration_test</span>() {<br/>  FactoryTraffic.<span>readDataFromDb </span>= <span>true;</span><span><br/></span><span>  </span>String result = IntStream.<span>rangeClosed</span>(<span>1</span><span>, <br/></span><span>              speedLimitByLane</span>.<span>length</span>).mapToDouble(i -&gt; {<br/>    AverageSpeed averageSpeed = <span>new </span>AverageSpeed(<span>trafficUnitsNumber</span><span>, <br/></span><span>               timeSec</span><span>, </span><span>dateLocation</span><span>, </span><span>speedLimitByLane</span><span>, </span>i<span>,</span><span>100</span>)<span>;<br/></span><span>    </span>ForkJoinPool commonPool = ForkJoinPool.<span>commonPool</span>()<span>;<br/></span><span>    return </span>commonPool.invoke(averageSpeed)<span>;<br/></span>  }).mapToObj(Double::toString).collect(Collectors.<span>joining</span>(<span>", "</span>))<span>;</span><span><br/></span><span>  </span>String expectedResult = <span>"7.0, 23.0, 41.0"</span><span>;<br/></span><span>  </span>String limits = Arrays.<span>stream</span>(<span>speedLimitByLane</span>)<br/>                        .mapToObj(Double::toString)<br/>                        .collect(Collectors.<span>joining</span>(<span>", "</span>))<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert average speeds by " <br/></span>                + <span>speedLimitByLane</span>.<span>length <br/></span>                + <span>" lanes with speed limit "</span><span> <br/></span>                + limits<span>, </span>expectedResult<span>, </span>result)<span>;<br/></span></pre>
<p>Similar code can be written for the class level testing of class <kbd>TrafficDensity</kbd> too:</p>
<pre>TrafficDensity trafficDensity = new TrafficDensity();<br/>String result = Arrays.stream(trafficDensity.<br/>       trafficByLane(trafficUnitsNumber, timeSec, <br/>                     dateLocation, speedLimitByLane))<br/>       .map(Object::toString)<br/>       .collect(Collectors.joining(", "));<br/>expectedResult = "354, 335, 311";<br/>assertEquals("Assert vehicle count by " + speedLimitByLane.length + <br/>         " lanes with speed limit " + limits, expectedResult, result);</pre>
<p>Finally, we can write the integration test for the subsystem level as well:</p>
<pre><span>void </span><span>demo3_subsystem_level_integration_test</span>() {<br/>  FactoryTraffic.<span>readDataFromDb </span>= <span>true;<br/></span><span>  </span>DbUtil.<span>createResultTable</span>()<span>;</span><span><br/></span><span>  </span>Dispatcher.<span>dispatch</span>(<span>trafficUnitsNumber</span><span>, </span><span>10</span><span>, </span><span>dateLocation</span><span>, <br/>                      </span><span>speedLimitByLane</span>)<span>;</span><span><br/></span><span>  try </span>{ Thread.<span>sleep</span>(<span>3000l</span>)<span>; </span>} <br/><span>  catch </span>(InterruptedException ex) {}<br/>  String result = DbUtil.<span>selectResult</span>(Process.<span>AVERAGE_SPEED</span>.name())<span>;<br/></span><span>  </span>String expectedResult = <span>"7.0, 23.0, 41.0"</span><span>;<br/></span><span>  </span>String limits = Arrays.<span>stream</span>(<span>speedLimitByLane</span>)<br/>                        .mapToObj(Double::toString)<br/>                        .collect(Collectors.<span>joining</span>(<span>", "</span>))<span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert average speeds by " </span>+ <span>speedLimitByLane</span>.<span>length <br/></span>        + <span>" lanes with speed limit "</span><span> </span>+ limits<span>, </span>expectedResult<span>, </span>result)<span>;</span><span><br/></span><span>  </span>result = DbUtil.<span>selectResult</span>(Process.<span>TRAFFIC_DENSITY</span>.name())<span>;<br/></span><span>  </span>expectedResult = <span>"354, 335, 311"</span><span>;<br/></span><span>  </span><span>assertEquals</span>(<span>"Assert vehicle count by " </span>+ <span>speedLimitByLane</span>.<span>length <br/></span>        + <span>" lanes with speed limit " </span>+ limits<span>, </span>expectedResult<span>, </span>result)<span>;<br/></span>}</pre>
<p>All of them can be run successfully now and may be used for application regression testing any time later.</p>
<p>An automated integration test between our application and the source of the real traffic data can be created only if the latter has a test mode from where the same flow of data can be sent our way so we can use them in the same manner we use recorded data (which is essentially the same thing).</p>
<p>One parting thought. All of this integration testing is possible when the amount of processing data is statistically significant. This is because we do not have full control over the number of workers and how the JVM decides to split the load. It is quite possible that on a particular occasion, the provided code would not work. In such a case, try to increase the number of requested traffic units. This will ensure more space for the load-distributing logic. </p>


            </article>

            
        </section>
    </body></html>