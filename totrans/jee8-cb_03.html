<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building Powerful Services with JSON and RESTful Features</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Nowadays, using <span class="calibre8">REST services with </span>JSON is the most common method for data transfer between applications over the HTTP protocol and this is not a coincidence—this is fast and easy to do. It's an easy to read, easy to parse and, with JSON-P, easy to code!</p>
<p class="mce-root">The following recipes will show you some common scenarios and how to apply Java EE to deal with them.</p>
<p class="mce-root">This chapter covers the following recipes:</p>
<ul class="calibre13">
<li class="calibre14">Building server-side events with JAX-RS</li>
<li class="calibre14">Improving a service's capabilities with JAX-RS and CDI</li>
<li class="calibre14">Easing data and object representation with JSON-B</li>
<li class="calibre14">Parsing, generating, transforming, and querying JSON objects using JSON-P</li>
</ul>
<p class="mce-root"> </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building server-side events with JAX-RS</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Usually, web applications rely on the events sent by the client side. So, basically the server will only do something if it is asked to.</p>
<p class="mce-root">But with the evolution of the technologies surrounding the internet (HTML5, mobile clients, smartphones, and so on), the server side also had to evolve. So that gave birth to the server-side events, events fired by the server (as the name suggests).</p>
<p class="mce-root">With this recipe, you will learn how to use <span class="calibre8">the server-side event</span> to update a user view.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the Java EE dependency:</p>
<pre class="calibre21">    &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>    &lt;/dependencies&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, we build a REST endpoint to manage the server events we are going to use, and to use REST we should start by properly configuring it:</p>
<pre class="calibre22">@ApplicationPath("webresources")<br class="calibre2"/>public class ApplicationConfig extends Application {<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">The following is quite a big chunk of code, but don't worry, we are going to split it up and understand each piece:</p>
<pre class="calibre21">@Path("serverSentService")<br class="calibre2"/>@RequestScoped<br class="calibre2"/>public class ServerSentService {<br class="calibre2"/><br class="calibre2"/>    private static final Map&lt;Long, UserEvent&gt; POOL = <br class="calibre2"/>    new ConcurrentHashMap&lt;&gt;();<br class="calibre2"/><br class="calibre2"/>    @Resource(name = "LocalManagedExecutorService")<br class="calibre2"/>    private ManagedExecutorService executor;<br class="calibre2"/><br class="calibre2"/>    @Path("start")<br class="calibre2"/>    @POST<br class="calibre2"/>    public Response start(@Context Sse sse) {<br class="calibre2"/><br class="calibre2"/>        final UserEvent process = new UserEvent(sse);<br class="calibre2"/><br class="calibre2"/>        POOL.put(process.getId(), process);<br class="calibre2"/>        executor.submit(process);<br class="calibre2"/><br class="calibre2"/>        final URI uri = UriBuilder.fromResource(ServerSentService.class).path<br class="calibre2"/>        ("register/{id}").build(process.getId());<br class="calibre2"/>        return Response.created(uri).build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @Path("register/{id}")<br class="calibre2"/>    @Produces(MediaType.SERVER_SENT_EVENTS)<br class="calibre2"/>    @GET<br class="calibre2"/>    public void register(@PathParam("id") Long id,<br class="calibre2"/>            @Context SseEventSink sseEventSink) {<br class="calibre2"/>        final UserEvent process = POOL.get(id);<br class="calibre2"/><br class="calibre2"/>        if (process != null) {<br class="calibre2"/>            process.getSseBroadcaster().register(sseEventSink);<br class="calibre2"/>        } else {<br class="calibre2"/>            throw new NotFoundException();<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    static class UserEvent implements Runnable {<br class="calibre2"/><br class="calibre2"/>        private final Long id;<br class="calibre2"/>        private final SseBroadcaster sseBroadcaster;<br class="calibre2"/>        private final Sse sse;<br class="calibre2"/><br class="calibre2"/>        UserEvent(Sse sse) {<br class="calibre2"/>            this.sse = sse;<br class="calibre2"/>            this.sseBroadcaster = sse.newBroadcaster();<br class="calibre2"/>            id = System.currentTimeMillis();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        Long getId() {<br class="calibre2"/>            return id;<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        SseBroadcaster getSseBroadcaster() {<br class="calibre2"/>            return sseBroadcaster;<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        @Override<br class="calibre2"/>        public void run() {<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>                sseBroadcaster.broadcast(sse.newEventBuilder().<br class="calibre2"/>                name("register").data(String.class, "Text from event " <br class="calibre2"/>                                      + id).build());<br class="calibre2"/>                sseBroadcaster.close();<br class="calibre2"/>            } catch (InterruptedException e) {<br class="calibre2"/>                System.out.println(e.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Here, we have a bean to manage the UI and help us with a better view of what is happening in the server:</p>
<pre class="calibre21">@ViewScoped<br class="calibre2"/>@Named<br class="calibre2"/>public class SseBean implements Serializable {<br class="calibre2"/><br class="calibre2"/>    @NotNull<br class="calibre2"/>    @Positive<br class="calibre2"/>    private Integer countClient;<br class="calibre2"/>    <br class="calibre2"/>    private Client client;<br class="calibre2"/>    <br class="calibre2"/>    @PostConstruct<br class="calibre2"/>    public void init(){<br class="calibre2"/>        client = ClientBuilder.newClient();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @PreDestroy<br class="calibre2"/>    public void destroy(){<br class="calibre2"/>        client.close();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void sendEvent() throws URISyntaxException, InterruptedException {<br class="calibre2"/>        WebTarget target = client.target(URI.create("http://localhost:8080/<br class="calibre2"/>                                                    ch03-sse/"));<br class="calibre2"/>        Response response = <br class="calibre2"/>        target.path("webresources/serverSentService/start")<br class="calibre2"/>                .request()<br class="calibre2"/>                .post(Entity.json(""), Response.class);<br class="calibre2"/><br class="calibre2"/>        FacesContext.getCurrentInstance().addMessage(null,<br class="calibre2"/>                new FacesMessage("Sse Endpoint: " + <br class="calibre2"/>                response.getLocation()));<br class="calibre2"/><br class="calibre2"/>        final Map&lt;Integer, String&gt; messageMap = new ConcurrentHashMap&lt;&gt;<br class="calibre2"/>        (countClient);<br class="calibre2"/>        final SseEventSource[] sources = new <br class="calibre2"/>        SseEventSource[countClient];<br class="calibre2"/><br class="calibre2"/>        final String processUriString = <br class="calibre2"/>        target.getUri().relativize(response.getLocation()).<br class="calibre2"/>        toString();<br class="calibre2"/>        final WebTarget sseTarget = target.path(processUriString);<br class="calibre2"/><br class="calibre2"/>        for (int i = 0; i &lt; countClient; i++) {<br class="calibre2"/>            final int id = i;<br class="calibre2"/>            sources[id] = SseEventSource.target(sseTarget).build();<br class="calibre2"/>            sources[id].register((event) -&gt; {<br class="calibre2"/>                final String message = event.readData(String.class);<br class="calibre2"/><br class="calibre2"/>                if (message.contains("Text")) {<br class="calibre2"/>                    messageMap.put(id, message);<br class="calibre2"/>                }<br class="calibre2"/>            });<br class="calibre2"/>            sources[i].open();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        TimeUnit.SECONDS.sleep(10);<br class="calibre2"/><br class="calibre2"/>        for (SseEventSource source : sources) {<br class="calibre2"/>            source.close();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        for (int i = 0; i &lt; countClient; i++) {<br class="calibre2"/>            final String message = messageMap.get(i);<br class="calibre2"/><br class="calibre2"/>            FacesContext.getCurrentInstance().addMessage(null,<br class="calibre2"/>                    new FacesMessage("Message sent to client " + <br class="calibre2"/>                                     (i + 1) + ": " + message));<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public Integer getCountClient() {<br class="calibre2"/>        return countClient;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setCountClient(Integer countClient) {<br class="calibre2"/>        this.countClient = countClient;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">And finally, the UI is code a simple JSF page:</p>
<pre class="calibre21">&lt;h:body&gt;<br class="calibre2"/>    &lt;h:form&gt;<br class="calibre2"/>        &lt;h:outputLabel for="countClient" value="Number of Clients" /&gt;<br class="calibre2"/>        &lt;h:inputText id="countClient" value="#{sseBean.countClient}" /&gt;<br class="calibre2"/>        <br class="calibre2"/>        &lt;br /&gt;<br class="calibre2"/>        &lt;h:commandButton type="submit" action="#{sseBean.sendEvent()}" <br class="calibre2"/>         value="Send Events" /&gt;<br class="calibre2"/>    &lt;/h:form&gt;<br class="calibre2"/>&lt;/h:body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We started with our SSE engine, the <kbd class="calibre16">ServerEvent</kbd> class, and a JAX-RS endpoint—these hold all the methods that we need for this recipe.</p>
<p class="mce-root">Let's understand the first one:</p>
<pre class="calibre21">    @Path("start")<br class="calibre2"/>    @POST<br class="calibre2"/>    public Response start(@Context Sse sse) {<br class="calibre2"/><br class="calibre2"/>        final UserEvent process = new UserEvent(sse);<br class="calibre2"/><br class="calibre2"/>        POOL.put(process.getId(), process);<br class="calibre2"/>        executor.submit(process);<br class="calibre2"/><br class="calibre2"/>        final URI uri = UriBuilder.fromResource(ServerSentService.class).<br class="calibre2"/>        path("register/{id}").build(process.getId());<br class="calibre2"/>        return Response.created(uri).build();<br class="calibre2"/>    }</pre>
<p class="mce-root">Following are the main points:</p>
<ol class="calibre19">
<li class="chapter">First things first—this method will create and prepare an event to be sent by the server to the clients.</li>
<li class="chapter">Then, the just created event is put in a HashMap called <kbd class="calibre16">POOL.</kbd></li>
<li class="chapter">Then our event is attached to a URI that represents another method in this same class (details are provided next).</li>
</ol>
<p class="mce-root">Pay attention to this parameter:</p>
<pre class="calibre21">@Context Sse sse</pre>
<p class="mce-root">It brings the server-side events feature from the server context and lets you use it as you need and, of course, it is injected by CDI (yes, CDI is everywhere!).</p>
<p class="mce-root">Now we see our <kbd class="calibre16">register()</kbd> method:</p>
<pre class="calibre21">    @Path("register/{id}")<br class="calibre2"/>    @Produces(MediaType.SERVER_SENT_EVENTS)<br class="calibre2"/>    @GET<br class="calibre2"/>    public void register(@PathParam("id") Long id,<br class="calibre2"/>            @Context SseEventSink sseEventSink) {<br class="calibre2"/>        final UserEvent event = POOL.get(id);<br class="calibre2"/><br class="calibre2"/>        if (event != null) {<br class="calibre2"/>            event.getSseBroadcaster().register(sseEventSink);<br class="calibre2"/>        } else {<br class="calibre2"/>            throw new NotFoundException();<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">This is the very method that sends the events to your clients—check the <kbd class="calibre16">@Produces</kbd> annotation; it uses the new media type <kbd class="calibre16">SERVER_SENT_EVENTS</kbd>.</p>
<p class="mce-root">The engine works, thanks to this small piece of code:</p>
<pre class="calibre21">@Context SseEventSink sseEventSink<br class="calibre2"/><br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>event.getSseBroadcaster().register(sseEventSink);</pre>
<p class="mce-root">The <kbd class="calibre16">SseEventSink</kbd> is a queue of events managed by the Java EE server, and it is served to you by injection from the context.</p>
<p class="mce-root">Then you get the process broadcaster and register it to this sink, which means that everything that this process broadcasts will be sent by the server from <kbd class="calibre16">SseEventSink</kbd>.</p>
<p class="mce-root">And now we check our event setup:</p>
<pre class="calibre21">    static class UserEvent implements Runnable {<br class="calibre2"/><br class="calibre2"/>        ...<br class="calibre2"/><br class="calibre2"/>        UserEvent(Sse sse) {<br class="calibre2"/>            this.sse = sse;<br class="calibre2"/>            this.sseBroadcaster = sse.newBroadcaster();<br class="calibre2"/>            id = System.currentTimeMillis();<br class="calibre2"/>        }<br class="calibre2"/><br class="calibre2"/>        ...<br class="calibre2"/><br class="calibre2"/>        @Override<br class="calibre2"/>        public void run() {<br class="calibre2"/>            try {<br class="calibre2"/>                TimeUnit.SECONDS.sleep(5);<br class="calibre2"/>                sseBroadcaster.broadcast(sse.newEventBuilder().<br class="calibre2"/>                name("register").data(String.class, "Text from event " <br class="calibre2"/>                + id).build());<br class="calibre2"/>                sseBroadcaster.close();<br class="calibre2"/>            } catch (InterruptedException e) {<br class="calibre2"/>                System.out.println(e.getMessage());<br class="calibre2"/>            }<br class="calibre2"/>        }<br class="calibre2"/>    }</pre>
<p class="mce-root">If you pay attention to this line:</p>
<pre class="calibre21">this.sseBroadcaster = sse.newBroadcaster();</pre>
<p class="mce-root">You'll remember that we've just used this broadcaster in the last class. Here we see that this broadcaster is brought by the <kbd class="calibre16">Sse</kbd> object injected by the server.</p>
<p class="mce-root">This event implements the <kbd class="calibre16">Runnable</kbd> interface so we can use it with the executor (as explained before), so once it runs, you can broadcast to your clients:</p>
<pre class="calibre21">sseBroadcaster.broadcast(sse.newEventBuilder().name("register").<br class="calibre2"/>data(String.class, "Text from event " + id).build());</pre>
<p class="mce-root">This is exactly the message sent to the client. This could be whatever message you need.</p>
<p class="mce-root">For this recipe, we used another class to interact with <kbd class="calibre16">Sse</kbd>. Let's highlight the most important parts:</p>
<pre class="calibre21">        WebTarget target = client.target(URI.create<br class="calibre2"/>        ("http://localhost:8080/ch03-sse/"));<br class="calibre2"/>        Response response = target.path("webresources/serverSentService<br class="calibre2"/>                                        /start")<br class="calibre2"/>                .request()<br class="calibre2"/>                .post(Entity.json(""), Response.class);</pre>
<p class="mce-root">This is a simple code that you can use to call any JAX-RS endpoint.</p>
<p class="mce-root">And finally, the most important part of this mock client:</p>
<pre class="calibre21">        for (int i = 0; i &lt; countClient; i++) {<br class="calibre2"/>            final int id = i;<br class="calibre2"/>            sources[id] = SseEventSource.target(sseTarget).build();<br class="calibre2"/>            sources[id].register((event) -&gt; {<br class="calibre2"/>                final String message = event.readData(String.class);<br class="calibre2"/><br class="calibre2"/>                if (message.contains("Text")) {<br class="calibre2"/>                    messageMap.put(id, message);<br class="calibre2"/>                }<br class="calibre2"/>            });<br class="calibre2"/>            sources[i].open();<br class="calibre2"/>        }</pre>
<p class="mce-root">Each message that is broadcast is read here:</p>
<pre class="calibre21">final String message = messageMap.get(i);</pre>
<p class="mce-root">It could be any client you want, another service, a web page, a mobile client, or anything.</p>
<p class="mce-root">Then we check our UI:</p>
<pre class="calibre21">&lt;h:inputText id="countClient" value="#{sseBean.countClient}" /&gt;<br class="calibre2"/>...<br class="calibre2"/>&lt;h:commandButton type="submit" action="#{sseBean.sendEvent()}" <br class="calibre2"/>value="Send Events" /&gt;</pre>
<p class="mce-root">We are using the <kbd class="calibre16">countClient</kbd> field to fill the <kbd class="calibre16">countClient</kbd> value in the client, so you can play around with as many threads as you want.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre8">It's important to mention that SSE is not supported in MS IE/Edge web browsers and that it is not as scalable as web sockets. In case you want to have full cross-browser support in the desktop side and/or better scalability (so, not only mobile apps, but also web apps which can open many more connections per instance), then <strong class="calibre7">WebSockets</strong> should be considered instead. Fortunately, standard Java EE has supported WebSockets since 7.0.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-sse</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Improving service's capabilities with JAX-RS and CDI</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This recipe will show you how to take advantage of CDI and JAX-RS features to reduce the effort and lower the complexity of writing powerful services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the Java EE dependency:</p>
<pre class="calibre21">    &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>    &lt;/dependencies&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We first create a <kbd class="calibre16">User</kbd> class to be managed through our service:</li>
</ol>
<pre class="mce-root2">public class User implements Serializable{<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/><br class="calibre2"/>    public User(){<br class="calibre2"/>        <br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public User(String name, String email) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">To have multiple sources of <kbd class="calibre16">User</kbd> objects, we create a <kbd class="calibre16">UserBean</kbd> class:</li>
</ol>
<pre class="mce-root2">@Stateless<br class="calibre2"/>public class UserBean {<br class="calibre2"/>    <br class="calibre2"/>    public User getUser(){<br class="calibre2"/>        long ts = System.currentTimeMillis();<br class="calibre2"/>        return new User("Bean" + ts, "user" + ts + <br class="calibre2"/>                        "@eldermoraes.com"); <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And finally, we create our <kbd class="calibre16">UserService</kbd> endpoint:</li>
</ol>
<pre class="mce-root2">@Path("userservice")<br class="calibre2"/>public class UserService implements Serializable{<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private UserBean userBean;<br class="calibre2"/>    <br class="calibre2"/>    private User userLocal;<br class="calibre2"/>    <br class="calibre2"/>    @Inject<br class="calibre2"/>    private void setUserLocal(){<br class="calibre2"/>        long ts = System.currentTimeMillis();<br class="calibre2"/>        userLocal = new User("Local" + ts, "user" + ts + <br class="calibre2"/>                             "@eldermoraes.com"); <br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUserFromBean")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserFromBean(){<br class="calibre2"/>        return Response.ok(userBean.getUser()).build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUserFromLocal")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserFromLocal(){<br class="calibre2"/>        return Response.ok(userLocal).build();<br class="calibre2"/>    } <br class="calibre2"/>    <br class="calibre2"/>}</pre>
<ol start="4" class="calibre19">
<li class="chapter">To load our UI, we have the <kbd class="calibre16">UserView</kbd> class that will be like a Controller between the UI and the service:</li>
</ol>
<pre class="mce-root2">@ViewScoped<br class="calibre2"/>@Named<br class="calibre2"/>public class UserView implements Serializable {<br class="calibre2"/><br class="calibre2"/>    public void loadUsers() {<br class="calibre2"/>        Client client = ClientBuilder.newClient();<br class="calibre2"/>        WebTarget target = client.target(URI.create<br class="calibre2"/>        ("http://localhost:8080/ch03-rscdi/"));<br class="calibre2"/>        User response = target.path("webresources/userservice/<br class="calibre2"/>                                     getUserFromBean")<br class="calibre2"/>                .request()<br class="calibre2"/>                .accept(MediaType.APPLICATION_JSON)<br class="calibre2"/>                .get(User.class);<br class="calibre2"/><br class="calibre2"/>        FacesContext.getCurrentInstance()<br class="calibre2"/>                .addMessage(null,<br class="calibre2"/>                        new FacesMessage("userFromBean: " + <br class="calibre2"/>                                         response));<br class="calibre2"/><br class="calibre2"/>        response = target.path("webresources/userservice<br class="calibre2"/>                               /getUserFromLocal")<br class="calibre2"/>                .request()<br class="calibre2"/>                .accept(MediaType.APPLICATION_JSON)<br class="calibre2"/>                .get(User.class);<br class="calibre2"/><br class="calibre2"/>        FacesContext.getCurrentInstance()<br class="calibre2"/>                .addMessage(null,<br class="calibre2"/>                        new FacesMessage("userFromLocal: <br class="calibre2"/>                                         " + response));</pre>
<pre class="mce-root2">        client.close();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>}</pre>
<ol start="5" class="calibre19">
<li class="chapter">And we add simple JSF page just to show the results:</li>
</ol>
<pre class="mce-root2"> &lt;h:body&gt;<br class="calibre2"/> &lt;h:form&gt;<br class="calibre2"/> &lt;h:commandButton type="submit" <br class="calibre2"/> action="#{userView.loadUsers()}" <br class="calibre2"/> value="Load Users" /&gt;<br class="calibre2"/> &lt;/h:form&gt;<br class="calibre2"/> &lt;/h:body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We used two kinds of injection:</p>
<ul class="calibre13">
<li class="calibre14">From <kbd class="calibre16">UserBean</kbd>, when <kbd class="calibre16">UserService</kbd> is attached to the context</li>
<li class="calibre14">From <kbd class="calibre16">UserService</kbd> itself</li>
</ul>
<p class="mce-root">Injection from <kbd class="calibre16">UserBean</kbd> is the simplest possible to perform:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    private UserBean userBean;</pre>
<p class="mce-root">Injection from <kbd class="calibre16">UserService</kbd> itself is also simple:</p>
<pre class="calibre21">    @Inject<br class="calibre2"/>    private void setUserLocal(){<br class="calibre2"/>        long ts = System.currentTimeMillis();<br class="calibre2"/>        userLocal = new User("Local" + ts, "user" + ts + <br class="calibre2"/>                             "@eldermoraes.com"); <br class="calibre2"/>    }</pre>
<p class="mce-root">Here, the <kbd class="calibre16">@Inject</kbd> works like the <kbd class="calibre16">@PostConstruct</kbd> annotation, with the difference begin in the server context running the method. But the result is quite the same.</p>
<p class="mce-root">Everything is injected, so now it's just a matter of getting the results:</p>
<pre class="calibre21">response = target.path("webresources/userservice/getUserFromBean")<br class="calibre2"/>                .request()<br class="calibre2"/>                .accept(MediaType.APPLICATION_JSON)<br class="calibre2"/>                .get(User.class);<br class="calibre2"/><br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>response = target.path("webresources/userservice/getUserFromLocal")<br class="calibre2"/>                .request()<br class="calibre2"/>                .accept(MediaType.APPLICATION_JSON)<br class="calibre2"/>                .get(User.class);</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As you can see, JAX-RS eases a lot of the objects parsing and represention:</p>
<pre class="calibre21">    @GET<br class="calibre2"/>    @Path("getUserFromBean")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserFromBean(){<br class="calibre2"/>        userFromBean = userBean.getUser();<br class="calibre2"/>        return Response.ok(userFromBean).build();<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    @GET<br class="calibre2"/>    @Path("getUserFromLocal")<br class="calibre2"/>    @Produces(MediaType.APPLICATION_JSON)<br class="calibre2"/>    public Response getUserFromLocal(){<br class="calibre2"/>        return Response.ok(userLocal).build();<br class="calibre2"/>    }</pre>
<p class="mce-root">By using a <kbd class="calibre16">Response</kbd> returning object and <kbd class="calibre16">@Produces(MediaType.APPLICATION_JSON)</kbd>, you give the framework the hard job of parsing your <kbd class="calibre16">user</kbd> object to a JSON representation. Lots of effort saved in a few lines!</p>
<p class="mce-root">You could also inject the user using a producer (the <kbd class="calibre16">@Produces</kbd> annotation). Check the CDI recipe from <a href="86071f26-42aa-43e2-8409-6feaed4759e0.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 1</a>, <em class="calibre17">New Features and Improvements,</em> for more details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-rscdi</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Easing data and objects representation with JSON-B</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This recipe will show you how you can use the power of the new JSON-B API to give some flexibility to your data representation, and also help to transform your objects into JSON messages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the Java EE dependency:</p>
<pre class="calibre21">    &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>    &lt;/dependencies&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">We first create a <kbd class="calibre16">User</kbd> class with some customization (details ahead):</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private Long id;<br class="calibre2"/>    <br class="calibre2"/>    @JsonbProperty("fullName")<br class="calibre2"/>    private String name;<br class="calibre2"/>    <br class="calibre2"/>    private String email;<br class="calibre2"/>    <br class="calibre2"/>    @JsonbTransient<br class="calibre2"/>    private Double privateNumber;<br class="calibre2"/>    <br class="calibre2"/>    @JsonbDateFormat(JsonbDateFormat.DEFAULT_LOCALE)<br class="calibre2"/>    private Date dateCreated;<br class="calibre2"/>    <br class="calibre2"/>    public User(Long id, String name, String email, <br class="calibre2"/>                Double privateNumber, Date dateCreated) {<br class="calibre2"/>        this.id = id;<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>        this.privateNumber = privateNumber;<br class="calibre2"/>        this.dateCreated = dateCreated;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    private User(){<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Here we use <kbd class="calibre16">UserView</kbd> to return the user JSON to the UI:</li>
</ol>
<pre class="mce-root2">@ViewScoped<br class="calibre2"/>@Named<br class="calibre2"/>public class UserView implements Serializable{<br class="calibre2"/>    <br class="calibre2"/>    private String json;<br class="calibre2"/>    <br class="calibre2"/>    public void loadUser(){<br class="calibre2"/>        long now = System.currentTimeMillis();<br class="calibre2"/>        User user = new User(now, <br class="calibre2"/>                "User" + now, <br class="calibre2"/>                "user" + now + "@eldermoraes.com",<br class="calibre2"/>                Math.random(),<br class="calibre2"/>                new Date());<br class="calibre2"/>        <br class="calibre2"/>        Jsonb jb = JsonbBuilder.create();<br class="calibre2"/>        json = jb.toJson(user);<br class="calibre2"/>        try {<br class="calibre2"/>            jb.close();<br class="calibre2"/>        } catch (Exception ex) {<br class="calibre2"/>            System.out.println(ex.getMessage());<br class="calibre2"/>        }<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public String getJson() {<br class="calibre2"/>        return json;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    public void setJson(String json) {<br class="calibre2"/>        this.json = json;<br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">And we add JSF page just to show the results:</li>
</ol>
<pre class="mce-root2"> &lt;h:body&gt;<br class="calibre2"/> &lt;h:form&gt;<br class="calibre2"/> &lt;h:commandButton type="submit" action="#{userView.loadUser()}" <br class="calibre2"/>  value="Load User" /&gt;<br class="calibre2"/> <br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> <br class="calibre2"/> &lt;h:outputLabel for="json" value="User JSON" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> &lt;h:inputTextarea id="json" value="#{userView.json}" <br class="calibre2"/>  style="width: 300px; height: 300px;" /&gt;<br class="calibre2"/> &lt;/h:form&gt;<br class="calibre2"/> &lt;/h:body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We are using some JSON-B annotations to customize our user data representation:</p>
<pre class="calibre21">    @JsonbProperty("fullName")<br class="calibre2"/>    private String name;</pre>
<p class="mce-root">The <kbd class="calibre16">@JsonbProperty</kbd> is used to change the field name to some other value:</p>
<pre class="calibre21">    @JsonbTransient<br class="calibre2"/>    private Double privateNumber;</pre>
<p class="mce-root">Use <kbd class="calibre16">@JsonbTransient</kbd> when you want to prevent some property appearing at the JSON representation:</p>
<pre class="calibre21">    @JsonbDateFormat(JsonbDateFormat.DEFAULT_LOCALE)<br class="calibre2"/>    private Date dateCreated;</pre>
<p class="mce-root">With <kbd class="calibre16">@JsonbDateFormat,</kbd> you use the API to automatically format your dates.</p>
<p class="mce-root">And then we use our UI manager to update the view:</p>
<pre class="calibre21">    public void loadUser(){<br class="calibre2"/>        long now = System.currentTimeMillis();<br class="calibre2"/>        User user = new User(now, <br class="calibre2"/>                "User" + now, <br class="calibre2"/>                "user" + now + "@eldermoraes.com",<br class="calibre2"/>                Math.random(),<br class="calibre2"/>                new Date());<br class="calibre2"/>        <br class="calibre2"/>        Jsonb jb = JsonbBuilder.create();<br class="calibre2"/>        json = jb.toJson(user);<br class="calibre2"/>    }</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">The full source code of this recipe is at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonb</a></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Parsing, generating, transforming, and querying on JSON objects using JSON-P</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Dealing with JSON objects is an activity that you can't avoid anymore. So if you can do it by relying on a powerful and easy to use framework—even better!</p>
<p class="mce-root">This recipe will show you how you can use JSON-P to carry out some different operations using or generating JSON objects.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Start by adding the Java EE dependency:</p>
<pre class="calibre21">    &lt;dependencies&gt;<br class="calibre2"/>        &lt;dependency&gt;<br class="calibre2"/>            &lt;groupId&gt;javax&lt;/groupId&gt;<br class="calibre2"/>            &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;<br class="calibre2"/>            &lt;version&gt;8.0&lt;/version&gt;<br class="calibre2"/>            &lt;scope&gt;provided&lt;/scope&gt;<br class="calibre2"/>        &lt;/dependency&gt;<br class="calibre2"/>    &lt;/dependencies&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article class="calibre2">
                
<ol class="calibre19">
<li class="chapter">Let's create a <kbd class="calibre16">User</kbd> class to support our operations:</li>
</ol>
<pre class="mce-root2">public class User {<br class="calibre2"/><br class="calibre2"/>    private String name;<br class="calibre2"/>    private String email;<br class="calibre2"/>    private Integer[] profiles;<br class="calibre2"/>    <br class="calibre2"/>    public User(String name, String email, Integer[] profiles) {<br class="calibre2"/>        this.name = name;<br class="calibre2"/>        this.email = email;<br class="calibre2"/>        this.profiles = profiles;<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="2" class="calibre19">
<li class="chapter">Then a <kbd class="calibre16">UserView</kbd> class to do all the JSON operations:</li>
</ol>
<pre class="mce-root2">@ViewScoped<br class="calibre2"/>@Named<br class="calibre2"/>public class UserView implements Serializable{<br class="calibre2"/>    <br class="calibre2"/>    private static final JsonBuilderFactory BUILDERFACTORY = <br class="calibre2"/>    Json.createBuilderFactory(null);<br class="calibre2"/>    private final Jsonb jsonbBuilder = JsonbBuilder.create();<br class="calibre2"/>    <br class="calibre2"/>    private String fromArray;<br class="calibre2"/>    private String fromStructure;<br class="calibre2"/>    private String fromUser;<br class="calibre2"/>    private String fromJpointer;<br class="calibre2"/>    <br class="calibre2"/>    public void loadUserJson(){<br class="calibre2"/>        loadFromArray();<br class="calibre2"/>        loadFromStructure();<br class="calibre2"/>        loadFromUser();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    private void loadFromArray(){<br class="calibre2"/>        JsonArray array = BUILDERFACTORY.createArrayBuilder()<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User1")<br class="calibre2"/>                        .add("email", "user1@eldermoraes.com"))<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User2")<br class="calibre2"/>                        .add("email", "user2@eldermoraes.com"))<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User3")<br class="calibre2"/>                        .add("email", "user3@eldermoraes.com")) <br class="calibre2"/>                .build(); <br class="calibre2"/>        fromArray = jsonbBuilder.toJson(array);<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    private void loadFromStructure(){<br class="calibre2"/>        JsonStructure structure = <br class="calibre2"/>        BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                .add("name", "User1")<br class="calibre2"/>                .add("email", "user1@eldermoraes.com")<br class="calibre2"/>                .add("profiles", BUILDERFACTORY.createArrayBuilder()<br class="calibre2"/>                        .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                                .add("id", "1")<br class="calibre2"/>                                .add("name", "Profile1"))<br class="calibre2"/>                        .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                                .add("id", "2")<br class="calibre2"/>                                .add("name", "Profile2")))<br class="calibre2"/>                .build();<br class="calibre2"/>        fromStructure = jsonbBuilder.toJson(structure);<br class="calibre2"/><br class="calibre2"/>        JsonPointer pointer = Json.createPointer("/profiles");<br class="calibre2"/>        JsonValue value = pointer.getValue(structure);<br class="calibre2"/>        fromJpointer = value.toString();<br class="calibre2"/>    }<br class="calibre2"/>    <br class="calibre2"/>    private void loadFromUser(){<br class="calibre2"/>        User user = new User("Elder Moraes", <br class="calibre2"/>        "elder@eldermoraes.com", <br class="calibre2"/>        new Integer[]{1,2,3});<br class="calibre2"/>        fromUser = jsonbBuilder.toJson(user);<br class="calibre2"/>    }<br class="calibre2"/><br class="calibre2"/>    //DO NOT FORGET TO IMPLEMENT THE GETTERS AND SETTERS<br class="calibre2"/>}</pre>
<ol start="3" class="calibre19">
<li class="chapter">Then we create a JSF page to show the results:</li>
</ol>
<pre class="mce-root2"> &lt;h:body&gt;<br class="calibre2"/> &lt;h:form&gt;<br class="calibre2"/> &lt;h:commandButton type="submit" action="#{userView.loadUserJson()}" <br class="calibre2"/> value="Load JSONs" /&gt;<br class="calibre2"/> <br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> <br class="calibre2"/> &lt;h:outputLabel for="fromArray" value="From Array" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> &lt;h:inputTextarea id="fromArray" value="#{userView.fromArray}" <br class="calibre2"/> style="width: 300px; height: 150px" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> <br class="calibre2"/> &lt;h:outputLabel for="fromStructure" value="From Structure" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> &lt;h:inputTextarea id="fromStructure" value="#{userView.fromStructure}" <br class="calibre2"/> style="width: 300px; height: 150px" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/><br class="calibre2"/> &lt;h:outputLabel for="fromUser" value="From User" /&gt;<br class="calibre2"/> &lt;br /&gt;<br class="calibre2"/> &lt;h:inputTextarea id="fromUser" value="#{userView.fromUser}" <br class="calibre2"/> style="width: 300px; height: 150px" /&gt;<br class="calibre2"/><br class="calibre2"/>  &lt;br /&gt;<br class="calibre2"/>  &lt;h:outputLabel for="fromJPointer" value="Query with JSON Pointer <br class="calibre2"/>  (from JsonStructure Above)" /&gt;<br class="calibre2"/>  &lt;br /&gt;<br class="calibre2"/>  &lt;h:inputTextarea id="fromJPointer" <br class="calibre2"/>   value="#{userView.fromJpointer}"  <br class="calibre2"/>  style="width: 300px; height: 100px" /&gt;<br class="calibre2"/> &lt;/h:form&gt;<br class="calibre2"/> &lt;/h:body&gt;</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">First, the <kbd class="calibre16">loadFromArray()</kbd> method:</p>
<pre class="calibre21">    private void loadFromArray(){<br class="calibre2"/>        JsonArray array = BUILDERFACTORY.createArrayBuilder()<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User1")<br class="calibre2"/>                        .add("email", "user1@eldermoraes.com"))<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User2")<br class="calibre2"/>                        .add("email", "user2@eldermoraes.com"))<br class="calibre2"/>                .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                        .add("name", "User3")<br class="calibre2"/>                        .add("email", "user3@eldermoraes.com")) <br class="calibre2"/>                .build(); <br class="calibre2"/>        fromArray = jsonbBuilder.toJson(array);<br class="calibre2"/>    }</pre>
<p class="mce-root">It uses the <kbd class="calibre16">BuilderFactory</kbd> and the <kbd class="calibre16">createArrayBuilder</kbd> method to easily build an array of JSONs (each call of <kbd class="calibre16">createObjectBuilder</kbd> creates another array member). At the end, we use the JSON-B to convert it to a JSON string:</p>
<pre class="calibre21">    private void loadFromStructure(){<br class="calibre2"/>        JsonStructure structure = BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                .add("name", "User1")<br class="calibre2"/>                .add("email", "user1@eldermoraes.com")<br class="calibre2"/>                .add("profiles", BUILDERFACTORY.createArrayBuilder()<br class="calibre2"/>                        .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                                .add("id", "1")<br class="calibre2"/>                                .add("name", "Profile1"))<br class="calibre2"/>                        .add(BUILDERFACTORY.createObjectBuilder()<br class="calibre2"/>                                .add("id", "2")<br class="calibre2"/>                                .add("name", "Profile2")))<br class="calibre2"/>                .build();<br class="calibre2"/>        fromStructure = jsonbBuilder.toJson(structure);<br class="calibre2"/><br class="calibre2"/>        JsonPointer pointer = new JsonPointerImpl("/profiles");<br class="calibre2"/>        JsonValue value = pointer.getValue(structure);<br class="calibre2"/>        fromJpointer = value.toString();<br class="calibre2"/>    }</pre>
<p class="mce-root">Here, instead of an array, we are building a single JSON structure. <span class="calibre8">Again, we use JSON-B to convert the <kbd class="calibre16">JsonStructure</kbd> to a JSON string.</span></p>
<p class="mce-root">We also took advantage of having this <kbd class="calibre16">JsonStructure</kbd> ready and used it to query the user profiles using the <kbd class="calibre16">JsonPointer</kbd> object:</p>
<pre class="calibre21">private void loadFromUser(){<br class="calibre2"/>        User user = new User("Elder Moraes", "elder@eldermoraes.com",<br class="calibre2"/>                    new Integer[]{1,2,3});<br class="calibre2"/>        fromUser = jsonbBuilder.toJson(user);<br class="calibre2"/>    }</pre>
<p class="mce-root">And here was the simplest: creating an object and asking JSON-B to convert it to a JSON string.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article class="calibre2">
                
<ul class="calibre13">
<li class="calibre14">Check the full source code of this recipe at <a href="https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter03/ch03-jsonp</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>