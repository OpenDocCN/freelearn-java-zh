- en: Dealing with Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we had quite a shift in perspective. In [Chapter
    6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects*,
    we looked at a handful of implementations of the concrete effects available in
    the standard library. In [Chapter 7](c1798142-6829-479c-bb7b-d50ccd16e629.xhtml),
    *Understanding Algebraic Structures* we jumped from the real to the theoretical
    and played with abstract algebraic structures.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the process of working with abstractions defined
    by laws, we can finally deliver on the promise we gave in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects*, and identify abstractions lying beneath the standard implementations
    we touched on there.
  prefs: []
  type: TYPE_NORMAL
- en: We'll define and implement a functor, an abstract concept that's useful in relation
    to any effect. Moreover, we’ll have three different flavors of them, so stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll be able to identify and implement or use
    the existing implementation of one of the following structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversable functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 1.8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this chapter is available in our GitHub repository at [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the situation in which we wanted to combine
    elements inside of a container. We found out that abstractions such as `Reducible`
    and `Foldable` can help with that by taking a function of two arguments and bringing
    it *into* the container so that it can be applied on pairs of elements inside
    of it. As an example, we showed you how this approach makes it possible to implement
    different survival strategies for a bucket of fish.
  prefs: []
  type: TYPE_NORMAL
- en: What we haven't covered is a case where we don't want to *combine* elements
    in the container but *do* something with all of them, a single element at a time.
    This is the bread and butter of functional programming—applying pure functions
    to arguments and getting the results back, then repeating this process with the
    result. Usually, the functions applied to the argument in succession can be combined
    into a single function, which in a sense is *fusing* all of the intermediate steps
    into one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our fish example. Let''s imagine that we have a fish and that we''d
    like to eat it. We''d first check that the fish is healthy and still fresh, then
    we would cook it somehow, and finally, we''d consume it. We might represent this
    sequence with the following model, extending the original `Fish` definition from
    the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And our possible actions would naturally be represented as functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we might want to combine our actions so that they represent the whole
    process from fresh to eaten fish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can act on the fish as desired by applying the combined function to
    the fish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're using the `Gen[Fish]` function we defined in the previous
    chapter. Please consult the GitHub repository if you need to refresh your understanding
    on how this was done.
  prefs: []
  type: TYPE_NORMAL
- en: So far so good—we're satisfied and happy. But the situation will change if we
    have a bucket of fish. Suddenly, all of the functions we've defined are useless
    because we don't know how to apply them to the fish inside of the bucket! What
    do we do now?
  prefs: []
  type: TYPE_NORMAL
- en: The requirement to work "inside" of the bucket might sound strange, but it is
    only because our example is disconnected from the implementation. In programming,
    most of the time, working with collections implies that we have the same collection
    (though with changed elements) after applying the operation. Moreover, if the
    *structure* of the collection is preserved, then the category theory we mentioned
    previously can provide some guarantees in regard to combining the operations as
    long as these obey a required set of laws. We've seen how this works with abstract
    algebraic structures, and the principle is the same for all abstractions derived
    from category theory. In practice, the requirement to preserve the structure of
    the collection means that the operation cannot change the type of the collection
    or the number of elements in it or throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that there is an abstraction that can help us in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Functor` has a `map` method which takes a container and a function and
    applies this function to all of the elements in the container, and finally returning
    the container with the same structure but filled with new elements. This is how
    we can specify this in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`F[_]` is a type constructor for the container. The `map` itself takes a container
    and a function to apply and returns a container with new elements. We could also
    define the `map` slightly differently, in a curried form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `mapC` takes a function called `A => B` and returns a function called `F[A]
    => F[B]`, which can then be applied to the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is an abstract definition, we would naturally expect some laws to be
    defined and satisfied—exactly like in the previous chapter. For functors, there
    are two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The *identity* law states that mapping over an  identity function should not
    change the original collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *distributive* law requires that successive mapping over two functions should
    always produce the same result as mapping over the combination of these functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will capture these requirements as properties in the same that way we did
    in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the identity law:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this property, we're using the `identity` function from [Chapter 3](9f67be8e-4fee-4050-ab96-8444bb795138.xhtml), *Deep
    Dive into Functions*, which just returns its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associativity law is a bit more involved because we need to test it with
    random functions. This requires that a lot of implicits are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re creating the arbitrary functions `f: A => B` and `g: B => C` 
    and checking that the combined function has the same effect as applying both functions
    in succession.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some functors to apply our checks. We can implement a `Functor[Option]`
    by delegating to the map function defined on `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The instance is defined as `implicit`, the same way as in the previous chapter,
    so that represents a type class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this implementation obeys the necessary laws? Let''s see. The properties
    in this chapter are defined in the test scope and can be run in SBT using the `test`
    command. They cannot be pasted into the REPL standalone, but only as a part of
    the `Properties` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we need to specify types of the functor and functions to check
    the laws that make it impossible—in our case—to formulate the functor properties
    *in general*. The functional programming library, cats, solves this problem by also defining
    type classes for the types of arguments. We'll stick to the explicit definition—this
    is sufficient for our learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: We can also implement functors for the other effects we saw in [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring
    Built-In Effects* in the same way we did for `Option`. The functor for `Try` is
    identical with respect to the type of effect. We'll leave this implementation
    as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'The case of `Either` is a bit more complicated, because we need to convert
    the two type arguments it takes to one type argument that''s expected by a `Functor`
    type constructor. We do this by fixing a type of the left side to `L` and using
    the type lambda in the definition of the functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, the implementation itself is the same again. It turns out that
    this is the abstraction we were looking for at the end of [Chapter 6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml),
    *Exploring Built-In Effects*. All of the standard effects we discussed in [Chapter
    6](8ccc5685-2fbb-4bd4-9d9e-4560b625b00e.xhtml), *Exploring Built-In Effects* are
    functors! The visible difference in the definition of the `map` method comes from
    the fact that, for the standard effects, it is defined using object-oriented polymorphism,
    and in our functor code, we're doing this by using ad-hoc polymorphism with type
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to our fish. As we have a bucket of them, which is represented
    by the `List` type, we''ll need a `Functor[Bucket]` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition is once again the same as before. However, we can perform actions
    on the fish in the bucket as desired now, reusing the `bucketOfFishGen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re using our freshly defined functor to check and prepare the fish
    inside of the bucket. The nice thing about our implementation is that the bucket
    can be any type that has a functor. To demonstrate this, we need a helper function
    that will allow us to pass a functor as a third parameter, along with the two
    we have in the definition of the `Functor.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an effect and a function and implicitly resolves the appropriate
    functor. The calling code does not make this distinction any more since we''re
    mapping over three different types of effects in the same way by using different
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is starting to look like a useful abstraction—well, as long as our desires
    are limited to the functions of one argument. We'll see why in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With functor, we now have a convenient way to apply functions to the contents
    of an effect, regardless of the type of the effect itself. We were able to check
    the fish and cook it by applying the same logic we had for an effect-free fish.
    To get even more comfortable with functors, we will now make a fish pie with our
    new tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a function to make a pie from a single fish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy—one fish, one pie, with the size of the fish. Now, we are ready
    to bake every fish in the bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Oops! This won't compile because the functor only accepts the function of one
    argument, and we have three.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can we do? One of the possibilities would be to refactor and partially
    apply our function. We could also create a function that uses `mapC` to convert
    the bucket of fish in to a fresh fish bucket so that we can simplify further actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can implement the rest of the logic with the partially applied
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a valid approach and would work, but this will use the same amount of
    ingredients for each and every fish. Some of the pies won't taste very good if
    this strategy. Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we can make our original function curried. This will give us a function
    that accepts a single fish and then other arguments on top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we would like to use the ingredients from another bucket so that we can
    add to the `pieInProgress`. Unfortunately, this is something that a functor can''t
    help us with. If we try and nest, the map calls for a bucket of potatoes and a
    bucket of milk, so we would come up with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, each nested call will leave the result in the nested bucked so
    that even if this were able to compile at the end, we'd have three nested buckets.
    Our functors do not know how to extract nested buckets from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can help us is the *Applicative Functor*. Sometimes just known as *Applicative*,
    this structure extends the original functor with two more methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The apply method takes an effect, `a`, and a function, `f`, defined in the context
    of the same effect and applies `f` to `a`, thus returning the result that's wrapped
    in the very same effect.
  prefs: []
  type: TYPE_NORMAL
- en: The `unit` method allows us to wrap a plain value, `a`, into the effect. This
    is often called *lifting*, especially if `a` is a function, as it "lifts" the
    original value (or function) into the context of the effect, `F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An astute reader will expect some laws to pop up for the aforementioned functions.
    And you would be absolutely right! There are a few of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity law states that an application of an identity function should return
    the argument unchanged, the same way the identity function does. This is similar
    to the identity law for the functor, but this time defined for the `apply` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Homomorphism law states that applying a function to a value and then lifting
    the result is the same as first lifting this function and value and then applying
    them in the context of the applicative.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interchange law states that changing the order of the parameters for the apply
    method should not change the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Composition law states that function composition should be preserved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, this might start to sound abstract. Let's make these points clear by capturing
    them as properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The identity property is the simplest one. The only caveat is that we can''t
    use the `identity` function—we have to be explicit about the type of the argument
    for the `unit` method because there is no possibility for the compiler to infer
    it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Homomorphism is also not very spectacular—it literally encodes the rules we
    stated in prose. Similar to the case of `identityProp`, we''re taking advantage
    of the `apply` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The interchange law is where it starts to become interesting. We''ll define
    left and right sides separately to simplify the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The left side is identical to the homomorphism definition—we're lifting some
    random function and a value into the applicative. Now, we need to change the order
    of `f` and `a`. The `f` is a first-class value, so we're fine on this side, but
    `a` is not a function. Therefore, we're defining a helper `func` which takes something
    with the same type as `f` and returns type `B`. Given `a`, we have only one way
    to implement this. With this helper, the types will align. Finally, we are defining
    the `rightSide` with the changed order of arguments and finish with the property
    comparing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The composition property is the most lengthy one because we have to define
    the functions that we are about to compose. First, let''s define function composition
    as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Given two functions with matching types, `composeF` will return a function composition
    by delegating to the `compose` method of the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll again define left and right sides of the property separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The right side is straightforward—we''re applying lifted functions `f` and
    `g` in succession on some effect, `as`. As the composition law states, this must
    be preserved if we apply composition inside of an applicative. This is what the
    left side does. It is better to read it from right to left: we''re lifting our
    function which composes functions into the applicative and than applying lifted
    `f` and `g` in succession, but this time inside of the `A`. This gives us a `compose`
    function that''s built inside of the applicative, which we finally apply to `as`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a valid applicative, all of these properties must hold, as well as the
    functor properties we defined earlier, as shown in the following snippet (not
    showing the implicit parameters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Secured with properties, we can define a few instances of applicative for the
    standard effects, just like we did for functor. The `Option` is arguably the easiest
    one to implement. Unfortunately, we can''t just delegate to the instance method
    as we did with `map`, so we have to get our hands dirty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The type signatures dictate the implementation. We can't return `Option[B]`
    in any other way but by applying `f` to `a`. Similarly, we can't return `Option[A]`
    from the `unit` method. Please pay attention, though, to how we're using the `Some`
    constructor in both cases instead of the `Option` constructor. This is done in
    order to preserve structure in the case of `null` parameters or returned values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation for `Either` and `Try` is very similar with respect to the
    effect type. Remarkably, our `Bucket` type, which is represented by `List`, is
    quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Because we need to apply all functions to all arguments, we're doing this in
    a recursive way in our example (notice that it is not tail-recursive!) by splitting
    the process into four parts—dealing with both first elements, the first element
    and all of its functions, all of the elements and the first function, and the
    recursive call for all but the first elements from both lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `bucketApplicative` at hand, we can finally finish our curried `pieInProgress`
    function by first applying it to `potato` and then to `milk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This definition works and produces the expected result—nice. But the implementation
    does not show the intent to mix three ingredients, which is not so nice. Let's
    improve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, there are three different valid ways to define an applicative in terms
    of its basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The one we just implemented, with `apply` and `unit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To define it with the `unit` and `map2` methods so that `map2[A, B, C](fa:
    F[A], fb: F[B])(f: (A, B) => C): F[C]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To define it with the `unit`, `map`, and `product` functions so that `product[A,
    B](fa: F[A], fb: F[B]): F[(A, B)]`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `apply` and `map2` methods are equally powerful in the sense that it is
    possible to implement one in terms of another. The same applies to `product`,
    though it is weaker as it needs a `map` function to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'As these functions are equally powerful, we can implement them directly in
    the type class definition so that they are available on all type class instances.
    The `map2` method looks good to start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The implementation almost looks disappointing in its simplicity—we just apply
    `fa` and `fb` in succession to the given `f` we converted to the curried form
    so that we are able to apply them in two steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting how the `map2` method is implemented in terms of `map`, which
    in a sense is a map of *lower power*. The curious readers out there could be asking
    if it is possible to implement a `map` with yet another function of *lower power*.
    It turns out we can do this! Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is lift the given function `f` into the context of applicative
    and use the `apply` function we already have.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of defining functions in terms of other functions is common in functional
    programming. All the way down in the abstraction, there are methods that provide
    the basis for all other definitions and cannot be defined as a combination of
    other methods. These are called *primitive*. The tree flavors of applicative we
    are talking about are different by their choice of primitive functions. As it
    turns out, our initial choice was the first of them, that is, the `unit` and `apply`
    methods. Using these primitive functions, we were able to define the `Functor`
    in terms of `Applicative`! It makes sense to do the same and define a `Functor.mapC`
    in terms of `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The nice side-effect of deriving implementations this way is that as soon as
    primitive functions are implemented properly and obey the applicative (or functor)
    laws, the derived implementations should be lawful as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the flavors of applicative—we still need to implement the `product`
    method which creates an applicative of a product from two applicatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This time, we had to use a type lambda again to represent a product of two types, `F`
    and `G`, as a single type. We also needed to store the reference to the current
    instance of the applicative as `F` so that we're able to call its methods later.
    The implementation itself is naturally expressed in terms of the `unit` and `apply` primitives.
    For the resulting applicative, the `unit` is defined as a product of units for
    `F` and `G`, and the `apply` is just a product of using an `apply` method on the
    given arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, we still can''t define our `pie` function in a very readable
    way. If only we had `map3`, we could implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this implementation expresses a very clear intent: take three containers
    full of ingredients, apply a function on these ingredients, and get a container
    with pies back. This works for any container for which an instance of an `Applicative`
    type class is available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, we already know how to derive functions from primitives defined for an
    abstraction. Why don''t we do this again? Here goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm, it turned out to be a definition for the `map2` function, just extended
    with one more call for an `apply` for a third parameter! Needless to say, it is
    possible to implement the `mapN` method for any arity like this. We can also define
    it in an inductive way by calling a `map` of smaller arity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We just needed to convert the provided function to the form where we can feed
    it with all but the last parameters and the last parameter separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we have our `pie3` implementation, we must stop for a moment. We need
    to tell you something. Yes, we need to admit that we cheated a bit as we defined
    the `check` function. Surely, we can''t just return `FreshFish` every time we
    have `Fish` as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We did this on purpose so that we''re able to focus on `Applicative`. Now,
    we are ready to improve on this. We are already familiar with the notion of optionality,
    so we could change this function to return an `Option`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'But let''s decide which kind of effect it should be later. Let''s call it `F`
    for now. We need two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: To return an empty `F` in the case that the fish is not fresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To return an `F` with a fresh fish otherwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of abstractions, we have a way to lift a fish into `F` as soon as we
    have an applicative for it—the applicative gives this as a `unit`. All we need
    is an empty `F[FreshFish]`, which we'll provide as an argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, our new definition for the check will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Having empty `F` as a separate argument list will allow us to partially apply
    this function later. The preceding implementation returns an empty `F` in approximately
    30% of cases. We're asking the compiler to check that the implicit `Applicative`
    is available for `F`, as discussed. If this is the case, our implementation will
    delegate to it to create a proper result.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we now have a way to separate fresh fish from the rest, but there is another
    problem. Our `pie3` function expects all of the ingredients to be wrapped in the
    same type of applicative. This is common in functional programming, and we''ll
    deal with this impediment by lifting other parameters into the same container.
    We could introduce checks for freshness for potatoes and milk in the same way
    that we did for fish, but for simplicity, we''ll assume they are always fresh
    (sorry, critical reader):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of the ingredients checked for freshness, we can use our existing
    `pie3` function, almost like we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that we need to help the compiler to recognize the proper
    type parameter. We do this by using the type lambda to define the type of the
    container explicitly. There is one missing piece of the puzzle, though. If we
    try to compile the preceding code, it will fail because we don't have an instance
    of `Applicative[Bucket[Option]]` yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready to roll up your sleeves and implement it? Well, although there is nothing
    wrong with getting our hands dirty, we don''t want to implement a new applicative
    each time we''d like to have a composition of them. What we''ll do instead is
    define a generic combination of applicatives, which is itself an applicative.
    The fact that applicatives *compose* is their most admirable property. Let''s
    see how this works. This is how we can implement it for our `Applicative[F]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Again, we had to use the type lambda to tell the compiler that this is actually
    just a single type parameter and not two. The implementation of the `unit` method
    is just wrapping one applicative into another. The `apply` method is more complex
    and we implemented it as a local function to make it clearer what is happening.
    The first thing we're doing is converting the internal function of type `G[A =>
    B]` to the type `G[A] => G[B]`. We're doing this by applying the applicative `G`
    on the "internal" function wrapped inside of `f`. Now that we have this function,
    we can call the `map` function of the outer applicative to wrap the result into `F`. The
    last thing we're doing is applying this wrapped composed function on the original
    function and the resulting function, that is, to the original argument of the
    `apply` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can compose these applicatives as we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And use this combination to call our original pie-making logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of this approach is that it allows us to reuse existing logic with
    arbitrarily nested applicatives, just like in the following artificial example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'All that we need in the case that the structure of containers changes is to
    define a new composite applicative (and a few syntactic helpers like the type
    alias as a constructor, but these aren''t essential). Then, we are able to use
    the existing logic as we did previously. This is what the result looks like in
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily change the structure of the result by rewiring the composite
    applicative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed the composition order and now the result looks different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Does it feel like combining applicatives leaves no desires unfulfilled? Well,
    in a sense, it is, except for the case that we want to change the structure of
    the result at hand. To give you an example, let's recall the result of our baking
    endeavor for the fresh fish: `List(Some(FishPie(45)), Some(FishPie(66)), None)`.
    It is a bucket containing either a pie, if the fish was fresh, or nothing if it
    was not. But what if we hired a new cook and now every single fish in the bucket
    has to be fresh or the whole bucket is discarded? Our return type would be `Option[Bucket[FishPie]]`
    in this case—the bucket is full of pies if we have a bucket of fresh fish, or
    nothing. We want to keep our kitchen processes, though! This is the time for the
    `Traversable` functor to enter the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Traversable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Traversable` functor is similar to `Reducible` and `Foldable`, which we
    talked about in the previous chapter. The difference is that methods defined on
    `Traversable` preserve the underlying structure while going over it, as opposed
    to the other abstractions which collapse it into the single result. The `Traversable`
    defines two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, Scala has a deprecated `Traversable` definition left over from
    previous versions, so we are getting rid of it by using import renaming. Our `Traversable`
    defines the `sequence` and `traverse` methods, which loosely correspond to the
    `reduce` and `fold` methods defined on monoids. Starting with the `sequence` method,
    we can see that it turns its argument *inside out*. This is exactly what we needed
    to make our new cook happy. Let''s skip the implementation part for a moment and
    see how it works in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we have `None` in the list, we''re getting `None` back as the result.
    Let''s give it another try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If all of the fish are fresh, we get `Some` bucket of pies, as expected. But
    we''re still not 100% satisfied with this approach. The reason for this is that
    we first bake all of the fresh pies we possibly can and then discard them in the
    case that not all of the fish was fresh. Instead, we would like to stop as soon
    as we encounter the first rotten fish. This is what the `traverse` method is for.
    Using it, we can implement our baking process like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're traversing over the `bucketOfFish`. We're using `bucketTraversable`
    for this. It expects a function called `Fish => G[?]` so that `G` is applicative.
    We can satisfy this requirement by providing a function called `Fish => Option[FishPie]`.
    We're using `checkHonestly` to lift a `Fish` into the `Option[FreshFish]`, and
    then we need to `map` over it with our original `bakePie` method.
  prefs: []
  type: TYPE_NORMAL
- en: How is `traverse` implemented? Unfortunately, the implementation for this requires
    knowing the structure of the effect so that it can be preserved. Because of this,
    it needs to be implemented for each instance of the type class or delegated to
    another abstraction where this knowledge is preserved, like `Foldable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `traverse` method can be implemented for `Traversable[List]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To preserve the structure of the list, we `foldRight` over it, starting by lifting
    an empty list into the context of `G`. We're using `map2` in each fold iteration
    to call the provided function on the next element of the original list, lift it
    into `G`, and append it to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Option`, we could use an approach similar to what we used for `fold`,
    but as we only need to handle two cases, a pattern matching implementation reveals
    the intent much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We're just lifting the `Option` into the context of `G` by using the appropriate
    methods for different states of an `Option`. It is worth noting that we're using
    `Some.apply` directly in the case of the non-empty `Option` to preserve the structure
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that the second method, `sequence`, is less powerful than
    traverse. Because of this, it can be defined directly on `Traversable` in terms
    of `traverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It just uses the `identity` function to return a proper value of `G[A]`, as
    expected by `traverse`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a functor, `Traversable`s also compose. The `compose` function will have
    the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We'll leave the task of implementing this to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how composing `Traversable`s can make life easier. Remember our controversial
    `deeplyPackaged` example? This is, once again, what the type of the container
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you imagine iterating over it and applying some logic to the elements of
    it? With a composed `Traversable`, this is absolutely straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We first compose the `Traversable` to match our nested types. Then, we traverse
    over it, as we did previously. Please note how we omitted the bottom `Option`
    type and have it as a wrapper type for the function parameter for traverse. This
    is the output of the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Does it feel like you have superpowers yet? If you're still not feeling it,
    we have something more to offer in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was an intense chapter. We learned about the concept of working with effects
    in a way that the knowledge of the effects' structure is *outsourced* to another
    abstraction. We looked at three such abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Functor` allows us to apply a function of one argument to each element
    stored in the container.
  prefs: []
  type: TYPE_NORMAL
- en: The `Applicative` (or applicative functor) extends the `Functor` in a way that
    it is possible to apply a function of two arguments (and by induction, functions
    of any number of arguments). We’ve seen that it is possible to choose one of three
    equally valid sets of primitives that define applicative and derive all of the
    other methods from these primitives.
  prefs: []
  type: TYPE_NORMAL
- en: We said that this approach of defining a minimal set of primitive functions
    and the rest of functionality in terms of these primitives is a common approach
    in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The last abstraction we saw was the `Traversable` (or traversable functor),
    which allows us to iterate over effects, thus changing their content, but preserving
    the underlying structure.
  prefs: []
  type: TYPE_NORMAL
- en: We paid special attention to combining applications and later to combining traversable.
    Having implemented the general methods that allow us to build stacks of arbitrary
    functors and use these stacks to go straight to the *heart*, we were able to reuse
    existing functions that were defined in terms of plain effect-free types.
  prefs: []
  type: TYPE_NORMAL
- en: What we haven't demonstrated, though, is the way that data from one applicative
    can influence functions that are called deeper in the stack—we just used constant
    parameters in our examples. The reason we did this is that applications do not
    support sequencing computations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about another abstraction that is capable of
    truly chaining computations—a monad.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement `Functor[Try]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Applicative[Try]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Applicative[Either]`. Check that your implementation passes the property
    check, just like it did in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Traversable[Try]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Traversable[Either]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Traversable.compose`, in the same way, that we discussed at the end
    of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atul S. Khot, *Scala Functional Programming Patterns*: Grok and performing effective
    functional programming in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ivan Nikolov, *Scala Design Patterns* - Second Edition: Learn how to write efficient,
    clean, and reusable code with Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
