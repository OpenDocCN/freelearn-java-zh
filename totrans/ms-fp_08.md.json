["```java\ndef map[A, B](fa: F[A])(f: A => B): F[B] = fm.flatMap(fa)(x => pure(f(x)))\n```", "```java\nimplicit override def F: Monad[F]\ndef monadLeftIdentity[A, B](a: A, f: A => F[B]): IsEq[F[B]] =\n F.pure(a).flatMap(f) <-> f(a)\ndef monadRightIdentity[A](fa: F[A]): IsEq[F[A]] =\n fa.flatMap(F.pure) <-> fa\n/**\n * Make sure that map and flatMap are consistent.\n */\n def mapFlatMapCoherence[A, B](fa: F[A], f: A => B): IsEq[F[B]] =\n  fa.flatMap(a => F.pure(f(a))) <-> fa.map(f)\n lazy val tailRecMStackSafety: IsEq[F[Int]] = {\n   val n = 50000\n   val res = F.tailRecM(0)(i => F.pure(if (i < n) Either.left(i + 1)\n    else Either.right(i)))\n   res <-> F.pure(n)\n }\n```", "```java\nimport cats.Monad, cats.syntax.monad._\n```", "```java\ndef add[F[_]](a: Double, b: Double)(implicit M: Monad[F], L: Logging[F]): F[Double] =\n for {\n   _ <- L.log(s\"Adding $a to $b\")\n   res = a + b\n   _ <- L.log(s\"The result of the operation is $res\")\n } yield res\n println(add[SimpleWriter](1, 2)) // SimpleWriter(List(Adding 1.0 to\n 2.0, The result of the operation is 3.0),3.0)\n```", "```java\nimplicit val monad: Monad[SimpleWriter] = new Monad[SimpleWriter] {\n  override def map[A, B](fa: SimpleWriter[A])(f: A => B):\n   SimpleWriter[B] = fa.copy(value = f(fa.value))\n  override def flatMap[A, B](fa: SimpleWriter[A])(f: A =>  \n   SimpleWriter[B]): SimpleWriter[B] = {\n     val res = f(fa.value)\n     SimpleWriter(fa.log ++ res.log, res.value)\n  }\n  override def pure[A](a: A): SimpleWriter[A] = SimpleWriter(Nil, a)\n\n  override def tailRecM[A, B](a: A)(f: A =>\n   SimpleWriter[Either[A,B]]): SimpleWriter[B] = ???\n}\n```", "```java\ndef add(a: Double, b: Double): Writer[List[String], Double] =\n  for {\n    _ <- Writer.tell(List(s\"Adding $a to $b\"))\n    res = a + b\n    _ <- Writer.tell(List(s\"The result of the operation is $res\"))\n  } yield res\n  println(add(1, 2)) // WriterT((List(Adding 1.0 to 2.0,\n   The result of the operation is 3.0),3.0))\n```", "```java\noverride def tailRecM[A, B](a: A)(f: A => SimpleWriter[Either[A,B]]):\n  SimpleWriter[B] = f(a).flatMap {\n   case Left (a1) => tailRecM(a1)(f)\n   case Right(res) => pure(res)\n}\n```", "```java\nMonad[SimpleWriter].tailRecM[Int, Unit](0) { a => Monad[SimpleWriter].pure(Left(a))}\n```", "```java\n[error] java.lang.StackOverflowError\n...\n[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)\n[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)\n[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)\n[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)\n[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)\n[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)\n[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)\n[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)\n[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)\n[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)\n[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)\n[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)\n...\n```", "```java\ndef factorial(n: Int): Int =\n  if (n <= 0) 1\n  else n * factorial(n - 1)\nprintln(factorial(5)) // 120\n```", "```java\ndef factorialTailrec(n: Int, accumulator: Int = 1): Int =\n  if (n <= 0) accumulator\n  else factorialTailrec(n - 1, n * accumulator)\nprintln(factorialTailrec(5)) // 120\n```", "```java\n@annotation.tailrec\ndef factorialTailrec(n: Int, accumulator: Int = 1): Int =\n if (n <= 0) accumulator\n else factorialTailrec(n - 1, n * accumulator)\n```", "```java\n@annotation.tailrec\noverride def tailRecM[A, B](a: A)(f: A => SimpleWriter[Either[A,B]]): SimpleWriter[B] =\n f(a).flatMap {\n  case Left (a1) => tailRecM(a1)(f)\n  case Right(res) => pure(res)\n }\n```", "```java\n[error] /Users/anatolii/Projects/1mastering-funprog/Chapter8/jvm/src/main/scala/jvm/TailRecM.scala:19:12: could not optimize @tailrec annotated method tailRecM: it contains a recursive call not in tail position\n[error] f(a).flatMap {\n[error] ^\n```", "```java\n@annotation.tailrec\n override def tailRecM[A, B](a: A)(f: A => SimpleWriter[Either[A,B]]):\n SimpleWriter[B] = {\n   val next = f(a)\n   next.value match {\n     case Left (a1) => tailRecM(a1)(f)\n     case Right(res) => pure(res)\n   }\n }\n```", "```java\noverride def tailRecM[A, B](a: A)(f: A => SimpleWriter[Either[A,B]]): SimpleWriter[B] = ???\n```", "```java\ncase class SimpleWriter[A](log: List[String], value: A)\n```", "```java\nimport cats._, cats.implicits._\n```", "```java\nimplicit val simpleWriterFunctor: Functor[SimpleWriter] =\n new Functor[SimpleWriter] {\n   override def map[A, B](fa: SimpleWriter[A])(f: A => B):\n    SimpleWriter[B] = fa.copy(value = f(fa.value))\n }\n```", "```java\nval x = SimpleWriter(Nil, 3)\nprintln(x.map(_ * 2)) // SimpleWriter(List(),6)\n```", "```java\ntype Fx[A] = Either[List[String], A]\ndef combineComputations[F[_]: Monad](f1: F[Double], f2: F[Double]): F[Double] =\n for {\n   r1 <- f1\n   r2 <- f2\n } yield r1 + r2\nval result = combineComputations[Fx](Monad[Fx].pure(1.0), \n Monad[Fx].pure(2.0))\n println(result) // Right(3.0)\n```", "```java\nval resultFirstFailed = combineComputations[Fx](\n Left(List(\"Division by zero\")), Monad[Fx].pure(2.0))\n println(resultFirstFailed) // Left(List(Division by zero))\nval resultSecondFailed = combineComputations[Fx](\n Monad[Fx].pure(1.0), Left(List(\"Null pointer encountered\")))\n println(resultSecondFailed) // Left(List(Null pointer encountered))\n```", "```java\nval resultBothFailed = combineComputations(\n Left(List(\"Division by zero\")), Left(List(\"Null pointer encountered\")))\n println(resultBothFailed) // Left(List(Division by zero))\n```", "```java\ntype Fx[A] = Either[List[String], A]\ndef zip[A, B](f1: Fx[A], f2: Fx[B]): Fx[(A, B)] = (f1, f2) match {\n  case (Right(r1), Right(r2)) => Right((r1, r2))\n  case (Left(e1), Left(e2)) => Left(e1 ++ e2)\n  case (Left(e), _) => Left(e)\n  case (_, Left(e)) => Left(e)\n}\n```", "```java\ndef combineComputations(f1: Fx[Double], f2: Fx[Double]): Fx[Double] =\n zip(f1, f2).map { case (r1, r2) => r1 + r2 }\n\nval result = combineComputations(Monad[Fx].pure(1.0),\n  Monad[Fx].pure(2.0))\n  println(result) // Right(3.0)\n\nval resultFirstFailed = combineComputations(\n  Left(List(\"Division by zero\")), Monad[Fx].pure(2.0))\n  println(resultFirstFailed) // Left(List(Division by zero))\n\nval resultSecondFailed = combineComputations(\n  Monad[Fx].pure(1.0), Left(List(\"Null pointer encountered\")))\n  println(resultSecondFailed) // Left(List(Null pointer encountered))\n\nval resultBothFailed = combineComputations(\n  Left(List(\"Division by zero\")), Left(List(\"Null pointer encountered\")))\n  println(resultBothFailed) // Left(List(Division by zero, Null pointer \n  encountered))\n```", "```java\ndef ap[A, B](ff: Fx[A => B])(fa: Fx[A]): Fx[B] = (ff, fa) match {\n  case (Right(f), Right(a)) => Right(f(a))\n  case (Left(e1), Left(e2)) => Left(e1 ++ e2)\n  case (Left(e), _) => Left(e)\n  case (_, Left(e)) => Left(e)\n}\n```", "```java\ndef zip[A, B](f1: Fx[A], f2: Fx[B]): Fx[(A, B)] =\n ap[B, (A, B)](ap[A, B => (A, B)](Right { (a: A) => (b: B) => (a, b) })(f1))(f2)\n```", "```java\ndef combineComputations(f1: Fx[Double], f2: Fx[Double]): Fx[Double] =\n (f1, f2).mapN { case (r1, r2) => r1 + r2 }\n```", "```java\nimplicit val applicative: Applicative[Fx] = new Applicative[Fx] {\n  override def ap[A, B](ff: Fx[A => B])(fa: Fx[A]): Fx[B] = (ff, fa)\n  match {\n    case (Right(f), Right(a)) => Right(f(a))\n    case (Left(e1), Left(e2)) => Left(e1 ++ e2)\n    case (Left(e), _) => Left(e)\n    case (_, Left(e)) => Left(e)\n  }\n  override def pure[A](a: A): Fx[A] = Right(a)\n}\n```", "```java\nimplicit def applicative[L]: Applicative[Either[L, ?]]\n```", "```java\noverride def ap[A, B](ff: Either[L, A => B])(fa: Either[L, A]): \nEither[L, B] = (ff, fa) match {\n  case (Right(f), Right(a)) => Right(f(a))\n  case (Left(e1), Left(e2)) => Left(e1 |+| e2)\n  case (Left(e), _) => Left(e)\n  case (_, Left(e)) => Left(e)\n}\n```", "```java\nimplicit val semigroupInt: Semigroup[Int] = new Semigroup[Int] {\n  override def combine(a: Int, b: Int) = a + b\n}\n```", "```java\ncombine(a, empty) == combine(empty, a) == a\n```", "```java\nimplicit def monoidInt: Monoid[Int] = new Monoid[Int] {\n  override def combine(a: Int, b: Int) = a + b\n  override def empty = 0\n}\n```", "```java\nimplicit def monoidIntMult: Monoid[Int] = new Monoid[Int] {\n  override def combine(a: Int, b: Int) = a * b\n  override def empty = 1\n}\n```", "```java\nprintln(2 |+| 3) // 6\n```", "```java\nprintln(2 combine 3) // 6\n```", "```java\nimplicit def applicative[L: Monoid]: Applicative[Either[L, ?]] =\n new Applicative[Either[L, ?]] {\n   override def ap[A, B](ff: Either[L, A => B])(fa: Either[L, A]):\n   Either[L, B] = (ff, fa) match {\n      case (Right(f), Right(a)) => Right(f(a))\n      case (Left(e1), Left(e2)) => Left(e1 |+| e2)\n      case (Left(e), _) => Left(e)\n      case (_, Left(e)) => Left(e)\n   }\n   override def pure[A](a: A): Either[L, A] = Right(a)\n}\n```", "```java\nimplicit val listMonoid: MonoidK[List] = new MonoidK[List] {\n  override def combineK[A](a1: List[A], a2: List[A]): List[A] =\n   a1 ++ a2\n  override def empty[A] = Nil\n}\n```", "```java\ntype Fx[A] = Either[List[String], A]\ndef combineComputations(f1: List[Fx[Double]]): Fx[Double] =\n (f1, f2).mapN { case (r1, r2) => r1 + r2 }\n```", "```java\nabstract def traverse[G[_], A, B](fa: F[A])(f: (A) â‡’ G[B])(implicit arg0: Applicative[G]): G[F[B]]\n```", "```java\nList[Either[List[String], A]]\n```", "```java\nEither[List[String], (A, A)]\n```", "```java\nEither[List[String], List[A]]\n```", "```java\ndef combineComputationsFold(f1: List[Fx[Double]]): Fx[Double] =\n f1.traverse(identity).map { lst =>\n lst.foldLeft(0D) { (runningSum, next) => runningSum + next } }\n\nval samples: List[Fx[Double]] =\n  (1 to 5).toList.map { x => Right(x.toDouble) }\n\nval samplesErr: List[Fx[Double]] =\n  (1 to 5).toList.map {\n    case x if x % 2 == 0 => Left(List(s\"$x is not a multiple of 2\"))\n    case x => Right(x.toDouble)\n  }\n\nprintln(combineComputationsFold(samples)) // Right(15.0)\nprintln(combineComputationsFold(samplesErr)) // Left(List(2 is not a \n multiple of 2, 4 is not a multiple of 2))\n```", "```java\ndef combineComputations(f1: List[Fx[Double]]): Fx[Double] =\n f1.traverse(identity).map(_.combineAll)\n\nprintln(combineComputations(samples)) // Right(15.0)\nprintln(combineComputations(samplesErr)) // Left(List(2 is not a  \n multiple of 2, 4 is not a multiple of 2))\n```", "```java\ntype Fx[A] = Either[List[String], A]\nimplicit val applicative: Applicative[Fx] = new Applicative[Fx] {\n  override def ap[A, B](ff: Fx[A => B])(fa: Fx[A]): Fx[B] = (ff, fa)  \n  match {\n    case (Right(f), Right(a)) => Right(f(a))\n    case (Left(e1), Left(e2)) => Left(e1 ++ e2)\n    case (Left(e), _) => Left(e)\n    case (_, Left(e)) => Left(e)\n  }\n  override def pure[A](a: A): Fx[A] = Right(a)\n}\nimplicit val monoidDouble: Monoid[Double] = new Monoid[Double] {\n  def combine(x1: Double, x2: Double): Double = x1 + x2\n  def empty: Double = 0\n}\n```"]