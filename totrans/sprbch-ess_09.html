<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 9. Testing the Spring Batch"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Testing the Spring Batch</h1></div></div></div><p>In the previous chapter, we learned the importance of performance and scaling batch applications through different configurations (namely, thread model, parallel processing, remote chunking, and partitioning techniques) and how to choose the right strategy to scale the batch application with the available infrastructure. Spring Batch applications are developed and configured with individual components and different integrations, and hence it is important to test the individual features as well as the integrated project for its expected behavior.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Types of testing for Spring Batch</li><li class="listitem" style="list-style-type: disc">Unit testing</li><li class="listitem" style="list-style-type: disc">Integration testing</li><li class="listitem" style="list-style-type: disc">Functional testing</li></ul></div><div class="section" title="Types of testing for Spring Batch"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Types of testing for Spring Batch</h1></div></div></div><p>The primary <a id="id429" class="indexterm"/>purpose of any software testing is to detect software failures and correct them. The scope of software testing can be established from validating the software components to verifying the software functionality and the software functioning in various environments and conditions.</p><p>The following are the types of software testing that we might want to perform on Spring Batch applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unit testing</strong></span>: Also <a id="id430" class="indexterm"/>known as component testing, this refers to verifying the functionality of a specific piece of code. Unit testing is generally written by the developers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Integration testing</strong></span>: This identifies the defects in the interfaces and the interaction <a id="id431" class="indexterm"/>between integrated components. As the software components are integrated in an iteratively incremental <a id="id432" class="indexterm"/>fashion, integration testing is an important testing aspect in larger projects.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functional testing</strong></span>: This verifies the functionality of a specific code component or group of code <a id="id433" class="indexterm"/>components, as defined in the functional specification of a particular application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Performance testing</strong></span>: This verifies if the entire system is meeting the performance <a id="id434" class="indexterm"/>standards expected from the specified environment or run conditions.</li></ul></div><p>Functional testing and performance testing are usually covered together in system testing.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Unit testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Unit testing</h1></div></div></div><p>Unit testing is <a id="id435" class="indexterm"/>the component-level testing performed by developers, with the source code and test plan prepared by developers. If the unit test fails, developers can <a id="id436" class="indexterm"/>fix the issues of the component and perform the unit test again. The following figure depicts the unit test scenario.</p><div class="mediaobject"><img src="Images/3372OS_09_01.jpg" alt="Unit testing" width="600" height="193"/></div><div class="section" title="JUnit"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec46"/>JUnit</h2></div></div></div><p>JUnit is the <a id="id437" class="indexterm"/>standard Java framework to perform unit testing. Most IDEs <a id="id438" class="indexterm"/>have in-built support for JUnit. TestNG can also be used as a JUnit analog.</p><p>JUnit test cases can be written as simple Java classes to be executed with the <code class="literal">@Test</code> annotation on a method that performs the test operation.</p><p>The following is an example of JUnit on a Java String concatenation operation:</p><div class="informalexample"><pre class="programlisting">public class MyClass {
    public String concatenate(String former, String later){
        return former + latter;
    }
}</pre></div><p>The <code class="literal">Junit</code> class to test <a id="id439" class="indexterm"/>this Java class can be as follows:</p><div class="informalexample"><pre class="programlisting">import org.junit.Test;
import static org.junit.Assert.*;

public class MyClassTest {

    @Test
    public void testConcatenate() {
        MyClass myclass = new MyClass();

        String output = myClass.concatenate("Spring", "Batch");

        assertEquals("SpringBatch", output);

    }
}</pre></div><p>In the preceding class, the <code class="literal">testConcatenate</code> method with the <code class="literal">@Test</code> annotation verified the <code class="literal">MyClass java component</code>. The <code class="literal">assertEquals()</code> method does the actual testing by comparing the <code class="literal">MyClass.concatenate()</code> method output with the expected output. If the comparison fails, the <code class="literal">assertEquals()</code> method throws an exception. We can also write methods to set <a id="id440" class="indexterm"/>up operations before the unit test method execution with <code class="literal">@Before</code> annotation and clean up tasks after the unit test operation with the <code class="literal">@After</code> annotation. A <a id="id441" class="indexterm"/>detailed list of JUnit classes and their usage can be referred to from JUnit API (<a class="ulink" href="http://junit.sourceforge.net/javadoc/">http://junit.sourceforge.net/javadoc/</a>).</p></div><div class="section" title="Mockito"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec47"/>Mockito</h2></div></div></div><p>As we need to perform <a id="id442" class="indexterm"/>batch application testing, each component can access the other with some dependency. Replicating all those classes needs to create the instances of such objects and provide to the component under test. Mockito is an open <a id="id443" class="indexterm"/>source Java framework that lets us create test double objects (mock objects) easily for the purpose of testing.</p><p>Mockito can be added to the application with an easy Maven dependency, such as the following:</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
&lt;groupId&gt;org.mockito&lt;/groupId&gt;
&lt;artifactId&gt;mockito-all&lt;/artifactId&gt;
&lt;version&gt;1.10.8&lt;/version&gt;
&lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p>In a batch application, we have the <code class="literal">EmployeeReader</code> class that we need to create an object during the test execution. This can be performed with the help of <code class="literal">Mockito</code> within the <code class="literal">JUnit</code> test class, as follows:</p><div class="informalexample"><pre class="programlisting">import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
 
import org.junit.Before;
import org.junit.Test;

public class EmployeeReaderUnitTest {
  EmployeeReader empReaderMock;
  
  @Before
  public void setUp() {
  empReaderMock = mock(EmployeeReader.class);
  }
  
  @Test
  public void testEmpReader()throws Exception {
  ...
  }
}</pre></div><p>In the preceding code snippet, we created the <code class="literal">EmployeeReader</code> object with the help of the <code class="literal">mock()</code> method from <code class="literal">Mockito</code> within the JUnit <code class="literal">@Before</code> (setup) method. We shall utilize this object in <a id="id444" class="indexterm"/>the <code class="literal">@Test</code> method to validate the functionality of the component.</p><p>Likewise, any <a id="id445" class="indexterm"/>Spring Batch components, such as listeners and validator must be unit tested to verify functionality.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Integration testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Integration testing</h1></div></div></div><p>Integration testing <a id="id446" class="indexterm"/>identifies the defects in the software components as <a id="id447" class="indexterm"/>they are integrated in an iteratively incremental fashion. Integration testing is an important testing aspect in larger projects.</p><p>The modules that are unit tested are grouped to the larger aggregation, tested according to the integration test plan, and then the tested application is ready for its next level of testing as a system for functional testing.</p><div class="mediaobject"><img src="Images/3372OS_09_02.jpg" alt="Integration testing" width="600" height="362"/></div><p>The following are the <a id="id448" class="indexterm"/>two ways to perform component <a id="id449" class="indexterm"/>testing with Spring Batch.</p><div class="section" title="Listener-based approach"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec48"/>Listener-based approach</h2></div></div></div><p>The following <a id="id450" class="indexterm"/>class-level annotations help in <a id="id451" class="indexterm"/>testing the Spring Batch components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@RunWith</code>(<code class="literal">SpringJUnit4ClassRunner.class</code>): This annotation indicates that <a id="id452" class="indexterm"/>the class should use the Spring support for JUnit facilities.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@ContextConfiguration</code>: This lets the program know about the configuration <a id="id453" class="indexterm"/>properties that contain the application context.</li><li class="listitem" style="list-style-type: disc"><code class="literal">@TestExecutionListeners</code>: This helps in configuring listeners to help the test <a id="id454" class="indexterm"/>execution to set up the abilities such as dependency injection and step scope test execution.</li></ul></div><p>The following is a sample configuration using these annotations:</p><div class="informalexample"><pre class="programlisting">@ContextConfiguration(locations = { "/app-context.xml" })
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
StepScopeTestExecutionListener.class })
@RunWith(SpringJUnit4ClassRunner.class)
public class CarFileReaderIntegrationTest {
...
}</pre></div></div><div class="section" title="The StepScopeTestUtils approach"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec49"/>The StepScopeTestUtils approach</h2></div></div></div><p>The <code class="literal">StepScopeTestUtils</code> utility class is used to create and manipulate <code class="literal">StepScope</code> in unit tests. This <a id="id455" class="indexterm"/>helps in using the Spring <a id="id456" class="indexterm"/>test support and injecting dependencies into the test case being the step scoped in the application context.</p><div class="informalexample"><pre class="programlisting">@Test
public void testEmployeeReader() throws Exception {
  StepExecution execution = getStepExecution();
  int empReads = 
  StepScopeTestUtils.doInStepScope(stepExecution, new 
  Callable&lt;Integer&gt;() {
  @Override
  public int call() throws Exception {
  ((ItemStream) employeeReader).open(new ExecutionContext());
  int count = 0;
  while(employeeReader.read() != null) {
    count++;
    }
  return count;
  }
  });
  assertEquals(empReads, 10);
}</pre></div><p>The <code class="literal">doInStepScope()</code> method of <code class="literal">StepScopeTestUtils</code> takes in <code class="literal">stepExecution</code> and the callable implementation; it automatically takes the runtime dependency injection and returns the <a id="id457" class="indexterm"/>result. The rest of the test is about validating the number of <code class="literal">empReads</code> with the expected number, with the <code class="literal">assertEquals()</code> method of <code class="literal">JUnit</code>.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Functional testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Functional testing</h1></div></div></div><p>Functional testing <a id="id458" class="indexterm"/>verifies the functionality of a specific code <a id="id459" class="indexterm"/>component or a group of code components, as defined in the functional specification of the particular application with input data for the components and the output behavior is compared with the expected behaviour. Functional testing is the "black box" testing, as we deal with only the external system behavior for the specific input with the expected output.</p><div class="mediaobject"><img src="Images/3372OS_09_03.jpg" alt="Functional testing" width="500" height="262"/></div><p>In a Spring Batch application, the entire job is considered as a unit of execution and it can be tested for its <a id="id460" class="indexterm"/>functionality with the help of <code class="literal">JobLauncherTestUtils</code>, a utility class to test Spring Batch jobs. <code class="literal">JobLauncherTestUtils</code> provides methods to launch an entire <code class="literal">AbstractJob</code>, allowing for end-to-end testing of individual steps without having to run every step in the job. <code class="literal">JobLauncherTestUtils</code> also provides the ability to run steps individually from <code class="literal">FlowJob</code> or <code class="literal">SimpleJob</code>. By launching steps within a job on their own, end-to-end testing of individual steps can be performed without having to run every step in the job.</p><p>The following code snippet is an example of using <code class="literal">JobLauncherTestUtils</code> to perform job and step launching:</p><div class="informalexample"><pre class="programlisting">@Before
public void setup() {
jobLaunchParameters = new JobParametersBuilder().addString("employeeData", EMPFILE_LOCATION)
.addString("resultsData", "file:/" + RESULTFILE_LOCATION)
.toJobParameters();
}

@Test
public void testEmployeeJob() throws Exception {
JobExecution execution = jobLauncherTestUtils.launchJob(jobLaunchParameters);
assertEquals(ExitStatus.COMPLETED, execution.getExitStatus());
StepExecution stepExecution =
execution.getStepExecutions().iterator().next();
assertEquals(ExitStatus.COMPLETED, stepExecution.getExitStatus());  
}</pre></div><p>In the preceding code, with the help of <code class="literal">JobLauncherTestUtils</code>, we are able to launch the batch job, a <a id="id461" class="indexterm"/>particular step, with the help of a simple API as part of the JUnit <code class="literal">@Test</code> method. The <code class="literal">@Before</code> (setup) method prepares the <code class="literal">JobLaunchParameters</code> with the details of the input <code class="literal">employeeData</code> file to be processed and output result <a id="id462" class="indexterm"/>file location to be stored.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Summary</h1></div></div></div><p>Through this chapter, we learned the importance of software testing and the types of software testing we might want to perform on a Spring Batch application. We also learned about different open source frameworks, such as JUnit and Mockito, to perform unit testing on Spring Batch components. We finished this chapter with an understanding of Spring support, APIs to perform unit testing, integration testing, and functional testing on Spring Batch applications.</p><p>In the <a class="link" href="apa.xhtml" title="Appendix A. Appendix">Appendix</a> section, we discuss in detail about setting up the development environment, project configurations, and Spring Batch administration.</p></div></div>



  </body></html>