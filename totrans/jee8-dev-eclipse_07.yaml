- en: Creating Web Applications with Spring MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we learned how to create JEE applications using EJBs. In
    this chapter, we are going to divert a bit from the core JEE specifications and
    learn Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Although this book is about JEE and Eclipse, and Spring MVC is not a part of
    JEE, it would be worthwhile to understand the Spring MVC framework. Spring MVC
    is a very popular framework for creating web applications and can be used with
    other JEE technologies, such as servlet, JSP, JPA, and EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: JEE does support MVC out of the box, if you use JSF. Refer to *Java Server Faces*
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*, for details. However, there is a difference in
    the design of JSF and Spring MVC. JSF is a component-based MVC framework. It is
    designed so that the user interface designer can create pages by assembling reusable
    components that are either provided by JSF or custom-developed. Spring MVC is
    a request-response-based MVC framework. If you are familiar with writing JSP or
    servlets, then Spring MVC would be an easier framework to use than JSF. You can
    find a good description of component-based MVC (as implemented by JSF) and request-response-based
    MVC (as implemented by Spring MVC) by Ed Burns at [http://www.oracle.com/technetwork/articles/java/mvc-2280472.html](http://www.oracle.com/technetwork/articles/java/mvc-2280472.html).
    JSR 371 for MVC was supposed to be part of JEE 8, but this JSR was later withdrawn
    from JEE 8 specifications. You can find more information about JSR 371 (also called
    MVC 1.0) at [https://www.mvc-spec.org/](https://www.mvc-spec.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we see how Spring MVC works, we need to understand what the MVC framework
    is. **MVC** stands for **Model-View-Controller**. We are going to refer to the
    MVC framework in the context of Java web applications only, although it should
    be mentioned here that the MVC pattern is often used in desktop applications too:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: The Model contains data that is used by the View to create the output.
    In the example that we have been following in this book, the *Course Management*
    application, if you have a `Course` class that contains information about the
    course to be displayed on a page, then the `Course` object can be called the Model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some definitions of MVC also include classes that implement business logic in
    the Model layer. For example, a `CourseService` class that takes a `Course` object
    and calls `CourseDAO` to save the `Course` in the database could also be considered
    a part of the Model layer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**View**: The View is a page that is displayed to the user. A JSP that displays
    a list of courses could be considered a part of the View layer. The View holds
    a reference to the Model object and uses the data it contains to create the page
    that the user sees in the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller:** The Controller is the glue between Model and View. It handles
    requests/actions from the web client (for example, the browser), calls the Model
    to handle business logic, and makes Model objects available to the View to create
    the page (user interface) to be returned to the client. The Controller could be
    a servlet, as in the case of JSF, or could be POJOs (as in the case of Spring
    MVC). When Controllers are POJOs, typically they get called by `DispatcherServlet`.
    `DispatherServlet` is a servlet that receives the request and dispatches it to
    one of the Controllers, based on the configuration. We will see example of this
    later in the chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC provides separation of concerns; that is, the code for the user interface
    and the business logic are separate. Because of this, the UI and the business
    layer can be modified independently to a great extent. Of course, since the UI
    usually displays the data generated by the business layer, it may not always be
    possible to make changes to each of the layers independent of the others. Developers
    of appropriate skills can work on each layer independently. A UI expert need not
    be too worried about how the business layer is implemented and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Spring dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring beans and injecting them into the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Spring MVC applications using the Eclipse plugin and JEE specifications
    such as JDBC, JPA, and JSP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC is a part of the overall Spring Framework. The core feature of the
    Spring Framework is **dependency injection** (**DI**). Almost all other features
    of the Spring Framework use DI. Objects managed by the dependency injection framework
    are not directly instantiated in the code (using, for example, the `new` operator).
    Let's call them *managed objects*. These objects are created by a DI framework,
    such as Spring. Because these objects are created by a framework, the framework
    has a lot more flexibility in deciding how to set values in the object and from
    where to get them. For example, your **Data Access Object** (**DAO**) class might
    need an instance of a database connection factory object. However, instead of
    instantiating it in the DAO class, you just tell the DI framework that when it
    instantiates the DAO, it has to set the value of a member variable for the connection
    pool factory. Of course, the parameters for the connection pool factory will have
    to be configured somewhere and be known to the DI framework.
  prefs: []
  type: TYPE_NORMAL
- en: When a class instantiates another class, there is tight dependency between them.
    Such design could be a problem if you want to test classes independently of others.
    For example, you may want to test a class that has business logic, but one that
    also refers to a DAO, which in turn depends on a JDBC connection object. When
    testing the first class, you will have to instantiate the DAO and configure the
    connection pool. As we saw in [Chapter 5](part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Unit Testing*, unit tests should be able to run without any external dependencies.
    One way to achieve this is by using DI. Instead of instantiating the DAO class,
    our class could refer to an interface that is implemented by the DAO and have
    the DI framework inject the implementation of this interface at runtime. When
    you are unit testing this class, the DI framework can be configured to inject
    a mock object that implements the required interface. Thus, DI enables loose coupling
    between objects.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because DI is at the core of the Spring Framework, let''s spend some time understanding
    how it works in Spring. We will create a standalone application for this purpose.
    Create a simple Maven project. Add the following dependency for the Spring Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding version number with the latest version of Spring. Classes
    managed by the DI container of Spring are called beans or components. You can
    either declare beans in an XML file or you can annotate the class. We will use
    annotations in this chapter. However, even though we use annotations, we need
    to specify the minimum configuration in an XML file. So, create an XML file in
    the `src/main/resource` folder of your project and name it `context.xml`. The
    reason that we are creating this file in the `src/main.resource` folder is that
    the files in this folder are made available in the classpath. Next, add the following
    content to `context.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By using the `<context:component-scan>` tag, we are telling the Spring Framework
    to scan the `base-package` folder and then look for the classes annotated with
    `@Component` and recognize them as managed classes so that they can be made available
    when injecting dependencies. In the preceding example, all classes in the `packt.jee.eclipse.spring`
    package (and its sub-packages) would be scanned to identify components.
  prefs: []
  type: TYPE_NORMAL
- en: Information read from the configuration file must be saved in an object. In
    Spring, it is saved in an instance of the `ApplicationContext` interface. There
    are different implementations of `ApplicationContext`. We will be using the `ClassPathXmlApplicationContext`
    class, which looks for the configuration XML file in the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create two Spring components. The first one is `CourseDAO`, and
    the second is `CourseService`. Although we won''t write any business logic in
    these classes (the purpose of this example is to understand how DI works in Spring),
    assume that `CourseDAO` could have the code to access the database and `CourseService`
    calls `CourseDAO` to perform the database operations. So, `CourseService` is dependent
    on `CourseDAO`. To keep the code simple, we will not create any interface for
    `CourseDAO` but will have the direct dependency. Create the `CourseDAO` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have no methods in `CourseDAO`, but as mentioned before, it could have
    methods to access the database. `@Component` marks this class as managed by Spring.
    Now, create the `CourseService` class. This class needs an instance of `CourseDAO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have declared a member variable called `courseDAO` and annotated it with
    `@Autowired`. This tells Spring to look for a component in its context (of `CourseDAO`
    type) and assign that to the `courseDAO` member.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create the main class. It creates `ApplicationContext`, gets the `CourseService`
    bean, calls the `getCourseDAO` method, and then checks whether it was injected
    properly. Create the `SpringMain` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We first create an instance of `ClassPathXmlApplicationContext`. The configuration
    XML file is passed as an argument to the constructor. We then get the `courseService`
    bean/component. Note the naming convention when specifying the bean name; it is
    the class name with the first letter in lowercase. We then get and print the value
    of `CourseDAO`. The value won't show any meaningful information, but if the value
    is not null, then it would mean that the Spring DI container has injected it properly.
    Note that we have not instantiated `CourseDAO`; it is the Spring DI container
    that instantiates and injects this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we saw an example of injecting objects at the member
    declaration (this is also called property injection). We can have this object
    injected in the constructors too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `@Autowired` annotation is moved to the constructor, and the
    single constructor argument is auto-injected. You can also have the object injected
    in a setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Component scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can specify the scope for your components in Spring MVC. The default scope
    is singleton, which means that there will be only one instance of the component
    in the context. Every request for this component will be served with the same
    instance. The other scopes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prototype**: Each request for the component is served with a new instance
    of that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request**: Valid for web applications. Single instance of a component class
    created for each HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session**: Single instance of a component class created for each HTTP session.
    Used in web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global session**: Single instance of a component class created for the global
    HTTP session. Used in portlet applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: Single instance of a component class in the web application.
    The instance is shared by all sessions in that application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See  [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) for
    more information on component scopes in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: If the component to be injected was not instantiated at the time it was requested,
    then Spring creates an instance of the component. In the previous example, we
    have not specified the scope of the `CourseDAO` component, so the same instance
    would be injected if there is another request for injecting `CourseDAO`. You can
    specify the scope in the `@Component` annotation. You can also specify the component
    name if you want to override the default name that Spring gives to the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if a single instance of a component is injected when no scope is specified,
    let''s change the `main` method in the `SpringMain` class and make two calls to
    the `getBean` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application and you should see the same instance of the `courseService`
    bean printed. Let''s change the scope of the `CourseService` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the application again; this time, you should see different instances of
    the `CourseService` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Spring comes across the `@Autowire` annotation, it tries to find the component
    by type. In the preceding example, `courseDAO` is annotated with `@Autowire`.
    Spring tries to find a component of `CourseDAO` type; it finds an instance of
    `CourseDAO` and injects it. But what if there are multiple instances of the class
    in the context? In such a case, we can use the `@Qualifier` annotation to uniquely
    identify components. Let''s now create the `ICourseDAO` interface, which will
    be implemented by two components, namely `CourseDAO` and `CourseDAO1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`CourseDAO` implements `ICourseDAO` and is uniquely qualified as `"courseDAO"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`CourseDAO1` implements `ICourseDAO` and is uniquely qualified as `"courseDAO1"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CourseService` class, we will use a qualifier to uniquely identify
    whether we want `CourseDAO` or `CourseDAO1` to be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The qualifier can also be specified at method arguments, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the application now. You should see that an instance of `CourseDAO1` is
    printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the basics of dependency injection in Spring. However, Spring
    offers a lot more options and features for dependency injection than we have covered
    here. We will see more DI features as and when required in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies)
    for more information about dependency injection in Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Spring Tool Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Tool Suite** (**STS**) is a set of tools in Eclipse for creating Spring
    applications. It can be either installed as a plugin to an existing installation
    of Eclipse JEE or can be installed standalone. The standalone version of STS is
    also packaged with Eclipse EE, so all Eclipse features for Java EE development
    are available in STS too. You can download STS from [https://spring.io/tools](https://spring.io/tools).
    Since we have already installed Eclipse EE, we will install STS as a plugin. The
    easiest way to install the STS plugin is from Eclipse Marketplace. Select the
    Help | Eclipse Marketplace... menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type `Spring Tool Suite` in the Find box, and click the Go button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Search fir STS in Eclipse Marketplace'
  prefs: []
  type: TYPE_NORMAL
- en: Click Install. The next page shows the features of STS that will be installed.
    Click Confirm to install the selected features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring MVC application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring MVC can be used for creating web applications. It provides an easy framework
    to map incoming web requests to a handler class (Controller) and create dynamic
    HTML output. It is an implementation of the MVC pattern. The Controller and Models
    are created as POJOs, and Views can be created using JSP, JSTL, XSLT, and even
    JSF. However, in this chapter, we will focus on creating Views using JSP and JSTL.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the Spring web documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'A web request is handled by four layers in Spring MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Front controller**: This is a Spring servlet configured in `web.xml`. Based
    on the request URL pattern, it passes requests to the Controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller**: These are POJOs annotated with `@Controller`. For each Controller
    that you write, you need to specify a URL pattern that the Controller is expected
    to handle. Sub-URL patterns can be specified at the method level too. We will
    see examples of this later. Controller has access to Model and to HTTP request
    and response objects. Controller can delegate processing of a request to other
    business handler objects, get results, and populate the Model object, which is
    made available to View by Spring MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**: These are data objects. The Controller and View layers can set and
    get data from Model objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: These are typically JSPs, but Spring MVC supports other types of
    Views too. See View technologies in the Spring documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn Spring MVC in this chapter through examples, as we have been learning
    in some other chapters in this book. We will create a part of the same *Course
    Management* application using Spring MVC. The application will display a list
    of courses with options to add, remove, and modify them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Spring project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, make sure that you have installed STS in Eclipse EE. From the Eclipse
    menu, select File | New | Other and then select the Spring | Spring Legacy Project
    option. Enter the project name and select the Spring MVC Project template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Select the Spring MVC Project template'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Next. The page will ask you to enter the top-level package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Enter top-level package name'
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you enter as a top-level package, the wizard takes the third sub-package
    as the application name. When the application is deployed in a server, the application
    name becomes the context name. For example, if you enter the package name as `packt.jee.course_management`,
    then `course_management` becomes the application name, and the base URL of the
    application on the local machine would be `http://localhost:8080/course_management/`.
  prefs: []
  type: TYPE_NORMAL
- en: Click Finish. This creates a Maven project with the required libraries for Spring
    MVC.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding files created by the Spring MVC project template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s examine some of the files created by the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/WEB-INF/web.xml`: A front Controller servlet is declared here,
    along with other configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`DispatcherServlet` is the front Controller servlet. It is passed the path
    of the context (XML) file for configuring Spring DI. Recall that in the standalone
    Spring application, we created `context.xml` to configure dependency injection.
    The `DispatcherServlet` servlet is mapped to handle requests to this web application.'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`: Context configuration
    for Spring DI. Some of the notable configuration parameters in this file are as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This enables annotations for configuring dependency injection at the class
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Static files, such as CSS, JavaScript, and images, can be placed in the `resources`
    folder (`src/main/webapp/resources`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Spring to use the `InternalResourceViewResolver` class to resolve
    Views. Properties of this bean tell the `InternalResourceViewResolver` class to
    look for the View files in the `/WEB-INF/views` folder. Furthermore, Views will
    be JSP files, as indicated by the suffix property. Our Views will be the JSP files
    in the `src/main/webapp/WEB-INF/views` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This tells Spring to scan the `packt.jee.course_management` package and its
    sub-packages to search for components (annotated by `@Component`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The default template also creates one Controller and one View. The controller
    class is `HomeController` in the package that you specified in the Spring project
    wizard (in our example, it is `packt.jee.course_management`). Controller in Spring
    MVC is called by the dispatcher servlet. Controllers are annotated by `@Controller`.
    To map the request path to a Controller, you use the `@RequestMapping` annotation.
    Let''s see the code generated by the template in the `HomeController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `home` method is annotated with `@RequestMapping`. The value of mapping
    is `/`, which tells the dispatcher servlet to send all requests coming its way
    to this method. The `method` attribute tells the dispatcher to call the `home`
    method only for HTTP requests of the `GET` type. The `home` method takes two arguments,
    namely `Locale` and `Model`; both are injected at runtime by Spring. The `@RequestMapping`
    annotation also tells Spring to insert any dependencies when calling the `home`
    method, and so `locale` and `model` are auto-injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method itself does not do much; it gets the current date-time and sets
    it as an attribute in the Model. Any attributes set in the Model are available
    to the View (JSP). The method returns a string, `"home"`. This value is used by
    Spring MVC to resolve the View to be displayed. The `InternalResourceViewResolver`
    that we saw in `servlet-context.xml` previously resolves this as `home.jsp` in
    the `/WEB-INF/views` folder. `home.jsp` has the following code in the `<body>`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `serverTime` variable comes from the Model object set in the `home` method
    of `HomeController`.
  prefs: []
  type: TYPE_NORMAL
- en: To run this project, we need to configure a server in Eclipse and add this project
    to the server. Refer to the *Configuring Tomcat in Eclipse* and *Running JSP in
    Tomcat* sections in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you configure Tomcat and add the project to it, start the server. Then,
    right-click on the project and select Run As | Run on Server. You should see a
    hello message with the timestamp displayed in the internal Eclipse browser. The
    URL in the browser''s address bar should be `http://localhost:8080/course_management/`,
    assuming that Tomcat is deployed on port `8080` and the context name (derived
    from the top-level package name) is `course_management`. If you want to change
    the default context name or remove the context, that is, deploy the application
    in the root context, then open the project properties (right-click on the project
    and select Properties) and go to Web Project Settings. You can change the context
    root name or remove it from this page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Context root setting'
  prefs: []
  type: TYPE_NORMAL
- en: For our *Course Management* application, we are not going to need the `HomeController`
    class or `home.jsp`, so you can go ahead and delete these files.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Spring MVC application using JDBC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a part of the course management application using
    Spring MVC and JDBC. The application will display a list of courses and options
    for adding, deleting, and modifying courses. We will continue using the project
    that we created in the previous section. We will learn many of the features of
    Spring for data access using JDBC as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will configure our datasource. We will use the same MySQL database
    that we created in the *Creating database schema* section of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a datasource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring, you can configure a JDBC datasource either in Java code or in the
    XML configuration (context) file. Before we see how to configure a datasource,
    we need to add some dependencies in Maven. In this chapter, we will use Apache''s
    Commons DBCP component for connection pooling (recall that in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, we selected the Hikari connection pool).
    Visit [https://commons.apache.org/proper/commons-dbcp/](https://commons.apache.org/proper/commons-dbcp/)
    for details on Apache DBCP. In addition to adding a dependency for Apache DBCP,
    we need to add dependencies for Spring JDBC and the MySQL JDBC driver. Add the
    following dependencies to the `pom.xml` of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a datasource in Java code, you can do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we will configure a datasource in an XML configuration file. Open
    `servlet-context.xml` (you will find it in the `src/main/webapp/WEB-INF/spring/appServlet`
    folder) and add the following bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering what *bean* means, it is the same as the component that
    we created in the examples earlier in the chapter. We have so far created a component
    using annotations, but the component and the bean can be declared in an XML file
    too. In fact, this is how it used to be in earlier versions, till support for
    annotations was added in Spring. In a real-world application, you may want to
    encrypt database passwords before specifying them in a configuration file. One
    way to decrypt a password before sending it to the database is to create a wrapper
    class for the datasource (in the previous example, create a wrapper for `org.apache.commons.dbcp.BasicDataSource`)
    and override the `setPassword` method, where you can decrypt the password.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep the database connection parameters separate from the Spring
    configuration, then you can use a `properties` file. Spring provides a consistent
    way to access resources such as a `properties` file. Just as you can access web
    URLs using the `http` protocol prefix or the file URL using the `file` protocol
    prefix, Spring allows you to access resources in the classpath using the `classpath`
    prefix. For example, if we create a `jdbc.properties` file and save it in one
    of the folders in the classpath, then we could access it as `classpath:jdbc.properties`.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources) for
    detailed information on accessing resources using Spring. The Spring resource
    URL formats can be used in configuration files or Spring APIs where the resource
    location is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Spring also provides a convenient tag to load property files in context config
    XML. You can access the values of properties in a `property` file in the config
    XML using the `${property_name}` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move the database connection properties to a file in this example.
    Create `jdbc.properties` in the `src/main/resources` folder. Maven makes this
    folder available in the classpath, so we can access it using the Spring resource
    format in the XML configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will load this `properties` file from `servlet-context.xml` using the `property-placeholder`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the location of the `property` file is specified using the Spring
    resource format. In this case, we ask Spring to look for the `jdbc.properties`
    file in the classpath. Further, because the `src/main/resources` folder is in
    the classpath (where we saved `jdbc.properties`), it should be loaded by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify the `datasource` bean declaration in `servlet-context.xml`
    to use the property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order of the `property-placeholder` tag and where the properties
    are used does not matter. Spring loads the entire XML configuration file before
    replacing `property` references with their values.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Spring JDBCTemplate class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a utility class called `JDBCTemplate` that makes it easy to
    perform many operations using JDBC. It provides convenient methods to execute
    SQL statements, map results of a query to an object (using the `RowMapper` class),
    close a database connection at the end of database operations, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc) for
    more information on `JDBCTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any data access code, we will create a **Data Transfer Object**
    (**DTO**), `CourseDTO`, which will just contain members that describe one `Course`
    and setters and getters for them. Create `CourseDTO` in the `packt.jee.course_management.dto`
    package. Instances of this class will be used to transfer data between different
    tiers of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We will now create a simple DAO that will use the `JdbcTemplate` class to execute
    a query to get all courses. Create the `CourseDAO` class in the `packt.jee.course_management.dao`
    package. Annotate the `CourseDAO` class with `@Repository`. Similar to `@Component`, the `@Repository`
    annotation marks the class as a Spring DI container-managed class.
  prefs: []
  type: TYPE_NORMAL
- en: As per the Spring documentation ([https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations)),
    `@Component` is a generic annotation to mark a class as Spring container-managed,
    and `@Repository` and `@Controller` are more specific ones. More specific annotations
    help to identify classes for specific treatments. It is recommended to use `@Repository`
    annotations for DAOs.
  prefs: []
  type: TYPE_NORMAL
- en: '`CourseDAO` needs to have an instance of the `JdbcTemplate` class to execute
    queries and other SQL statements. `JdbcTemplate` needs a `DataSource` object before
    it can be used. We will have `DataSource` injected in a method in `CourseDAO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `datasource` that we have configured in `servlet-context.xml` will be injected
    by Spring when the `CourseDAO` object is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now write the method to get all courses. The `JdbcTemplate` class has
    a `query` method that allows you to specify `RowMapper`, where you can map each
    row in the query to a Java object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `getCourses` method, we will execute a static query. Later, we will see
    how to execute parameterized queries too. The second argument to the `query` method
    of `JDBCTemplate` is an instance of the `RowMapper` interface. We have created
    the static inner class `CourseRowMapper` that implements the `RowMapper` interface.
    We override the `mapRow` method, which is called for each row in `ResultSet`,
    and then we create/map the `CourseDTO` object from the `ResultSet` passed in the
    arguments. The method returns a `CourseDTO` object. The result of `JdbcTemplate.query`
    is a list of `CourseDTO` objects. Note that the `query` method can also return
    other Java collection objects, such as `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a method to add a course to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When we add or insert a new course, we want to get the ID of the new record,
    which is autogenerated. Furthermore, we would like to use the prepared statement
    to execute SQL. Therefore, first we create `KeyHolder` for the auto-generated
    field. The `update` method of `JdbcTemplate` has many overloaded versions. We
    use the one that takes `PreparedStatementCreator` and `KeyHolder`. We create an
    instance of `PreparedStatementCreator` and override the `createPreparedStatement`
    method. In this method, we create a JDBC `PreparedStatement` and return it. Once
    the update method is successfully executed, we retrieve the auto-generated value
    by calling the `getKey` method of `KeyHolder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods to update or delete a course are similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add one more method to `CourseDAO`, to get the details of a course,
    given the ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`queryForObject` returns a single object for a given query. We use a parameterized
    query here, and the parameter is passed as the last argument to the `queryForObject`
    method. Further, we use `CourseRowMapper` to map the single row returned by this
    query to `CourseDTO`. Note that you can pass a variable number of parameters to the `queryForObject`
    method, although in this case, we pass a single value, that is, the ID.'
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the methods in the `CourseDAO` class to access data for `Course`.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed discussion on data access using JDBC in Spring, refer to [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Spring MVC Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create the `Controller` class. In Spring MVC, the Controller is
    mapped to the request URL and handles requests matching the URL pattern. The request
    URL for matching an incoming request is specified at the method level in the controller.
    However, more generic request mapping can be specified at the `Controller` class
    level, and a specific URL, with respect to the URL at the class level, can be
    specified at the method level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `CourseController` in the `packt.jee.course_management.controller`
    package. Annotate it with `@Controller`. The `@Controller` annotation is of type
    `@Component`, and allows the Spring Framework to identify that class specifically
    as a controller. Add the method to get courses in `CourseController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `CourseDAO` instance is autowired; that is, it will be injected by Spring.
    We have added the  `getCourses` method, which takes a Spring Model object. Data
    can be shared between View and Controller using this Model object. Therefore,
    we add an attribute to Model, named `courses`, and assign the list of courses
    that we get by calling `courseDAO.getCourses`. This list could be used in the
    View JSP as the `courses` variable. We have annotated this method with `@RequestMapping`.
    This annotation maps the incoming request URL to a controller method. In this
    case, we are saying that any request (relative to the root) that starts with `/courses`
    should be handled by the `getCourses` method in this controller. We will add more
    methods to `CourseController` later and discuss some of the parameters that we
    can pass to the `@RequestMapping` annotation, but first let's create a View to
    display the list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created data access objects for `Course` and a Controller. Let's see
    how we can call them from a View. Views in Spring are typically JSPs. Create a
    JSP (name it `courses.jsp`) in the `src/main/webapp/WEB-INF/views` folder. This
    is the folder that we configured in `servlet-context.xml` to hold the Spring View
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the JSTL tag library in `courses.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The markup code to display courses is very simple; we make use of the `courses`
    variable, which is made available in the Model from the `CourseController.getCourses`
    method and displays values using JSTL expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `courses` is a list of objects of `CourseDTO` type. Members of `CourseDTO`
    are accessed in the `forEach` tag to display the actual values.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can't run this page from Eclipse the way we have so far in
    this book, that is, by right-clicking on the project or page and selecting Run
    As | Run on Server. If you try to run the project (right-click on the project
    and select the Run menu), then Eclipse will try to open the `http://localhost:8080/course_management/`
    URL, and because we do not have any start page (`index.html` or `index.jsp`),
    we will get an HTTP 404 error. The reason that we can't run the page by right-clicking
    and selecting the run option is that Eclipse tries to open `http://localhost:8080/course_management/WEB-INF/views/courses.jsp`,
    and this fails because files in `WEB-INF` are not accessible from outside the
    server. Another reason, or rather the primary reason, that this URL will not work
    is that in `web.xml`, we have mapped all requests to be handled by `DispatcherServlet`
    of the Spring Framework and it does not find a suitable mapping for the request
    URL. To run the application, open the URL `http://localhost:8080/course_management/courses`
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data using @ModelAttribute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the feature to insert a new course. In the
    process, we will learn more about mapping requests to methods and mapping request
    parameters to method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we implemented `CourseController` with one method,
    `getCourses`. We will now add methods to insert new courses. To add a course,
    we first need to display a View with a form that accepts the user input. When
    the user actually submits the form, the form data should be posted to a URL that
    handles insertion of the data to the database. Therefore, there are two requests
    involved here: the first is to display the *add course* form, and the second is
    to handle the data posted from the form. We will call the first request `addCourse`
    and the second request `doAddCourse`. Let''s first create the user interface.
    Create a new JSP and name it `addCourse.jsp`. Add the following markup to the
    `body` of the page (JSTL and other header declarations are skipped to save space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The page expects a course variable to be made available by the controller. In
    the form body, it assigns the values of the course to appropriate input fields;
    for example, the `${course.name}` value is assigned to the text input for `Course
    Name`. The form posts the data to the `"${pageContext.request.contextPath}/doAddCourse"`
    URL. Note that since our application is not deployed in the root context, we need
    to include the context name in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add Controller methods to handle two requests for add: `addCourse`
    and `doAddCourse`. When the `addCourse` request is made, we want to serve the
    page that displays the input form. When the user clicks the Submit button, we
    want form data to be sent using the `doAddCourse` request. Open the `CourseController`
    class and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `addCourse` method is configured, using the `@RequestMapping` annotation,
    to handle  request URLs starting (relative to context root) with `"/addCourse"`.
    If previously the  `course` attribute was added to Model, then we want this object
    to be passed as an argument to this function. Using `@ModelAttribute`, we tell
    the Spring Framework to inject the Model attribute called `course` if it is present
    and assign it to the argument named `course`; else, `null` is passed. In the case
    of the first request, Model would not have a `course` attribute, so it would be
    `null`. In the subsequent requests, for example, when the user-entered data in
    the form (to add a course) is not valid and we want to redisplay the page, Model
    will have the `course` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a handler method for the `''/doAddCourse''` request. This
    is a `POST` request sent when the user submits the form in `addCourse.jsp` (refer
    to the form and its `POST` attribute discussed earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `doAddCourse` method also asks Spring to inject the Model attribute called
    `course` as the first argument. It then adds the course to the database using
    `CourseDAO`. In the case of an error, it returns the `addCourse` string, and Spring
    MVC displays `addCourse.jsp` again. If the course is successfully added, then
    the request is redirected to `courses`, which tells Spring to process and display
    `courses.jsp`. Recall that in `servlet-context.xml` (the Spring context configuration
    file in the `src/main/webapp/WEB-INF/spring/appServlet` folder), we configured
    a bean with the `org.springframework.web.servlet.view.InternalResourceViewResolver`
    class. This class is extended from `UrlBasedViewResolver`, which understands how
    to handle URLs with `redirect` and `forward` prefixes. So, in `doAddCourse` we
    save the data in the database, and if successful, we redirect the request to `courses`,
    which displays (after processing `courses.jsp`) the list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you want to test the application, browse to `http://localhost:8080/course_management/addCourse`.
    Enter the course name and credits and click Submit. This should take you to the
    courses page and display the list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Spring MVC looks at the form field names and properties of the object
    in Model (in this case, `CourseDTO`) when mapping form values to the object. For
    example, the form field `name` is mapped to the `CourseDTO.name` property. So,
    make sure that the names of the form fields and the property names in the class
    (objects of which are added to the Model) are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using parameters in @RequestMapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use the `@RequestMapping` annotation to map the incoming
    request to a Controller method. So far, we have mapped static URL patterns in
    `@RequestMapping`. However, it is possible to map parameterized URLs (like those
    used in REST; see [https://spring.io/understanding/REST](https://spring.io/understanding/REST))
    using `@RequestMapping`. The parameters are specified inside `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the feature to update an existing course. Here, we will only discuss
    how to code the Controller method for this feature. The complete code is available
    when you download the samples for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following method in `CourseController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we map the `updateCourse` method to handle requests with the following
    URL pattern: `/course/update/{id}`, where `{id}` could be replaced with the ID
    (number) of any existing course, or for that matter, any integer. To access the
    value of this parameter, we used the `@PathVariable` annotation in the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring interceptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring interceptors can be used to process any request before it reaches the
    controller. These could be used, for example, to implement security features (authentication
    and authorization). Like request mappers, interceptors can also be declared for
    specific URL patterns. Let's add the login page to our application, which should
    be displayed before any other page in the application if the user has not already
    logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create `UserDTO` in the `packt.jee.course_management.dto` package.
    This class contains the username, password, and any message to be displayed on
    the login page, for example, authentication errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `UserController` that will process the login request.
    Once the user is logged in successfully, we would like to keep this information
    in the session.  The presence of this object in the session can be used to check
    whether the user is already logged in. Create the `UserController` class in the `packt.jee.course_management.controller`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a handler method for the `GET` request for the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have specified the method attribute in the `@RequestMapping` annotation.
    When the request URL is `/login` and the HTTP request type is `GET`, only then
    will the `login` method be called. This method would not be called if a `POST`
    request is sent from the client. In the `login` method, we create an instance
    of `UserDTO` and add it to the Model so that it is accessible to the View.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a method to handle `POST` requests from the login page. We will
    keep the same URL, that is, `/login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We now have two methods in `UserController` handling the request URL `/login`.
    However, the login method handles `GET` requests and `doLogin` handles `POST`
    requests. If authentication is successful in the `doLogin` method, then we redirect
    to the courses (list) page. Else, we set the error message and return to the login
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save the user object created in the login method in the HTTP session.
    This can be done with the simple `@SessionAttributes` annotation. You can specify
    the list of attributes in Model that need to be saved in the session too. Furthermore,
    we want to save the `user` attribute of Model in the session. Therefore, we will
    add the following annotation to the `UserController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the login page. Create `login.jsp` in the `views` folder
    and add the following code in the HTML `<body>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The page expects `user` (instance of `UserDTO`) to be available. It is made
    available by `UserController` through Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the login page and `UserController` to handle the authentication,
    but how do we make sure this page is displayed for every request when the user
    is not logged in? This is where we can use Spring interceptors. We will configure
    an interceptor in the Spring context configuration file: `servlet-context.xml`.
    Add the following code to `servlet-context.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration, we are telling Spring to call `LoginInterceptor` before
    executing any request (indicated by `mapping path = "/**"`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement `LoginInterceptor`. Interceptors must implement `HandlerInterceptor`.
    We will make `LoginInterceptor` extend `HandlerInterceptorAdapter`, which implements
    `HandlerInterceptor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `LoginInterceptor` in the `packt.jee.course_management.interceptor`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `preHandle` method of the interceptor is called before Spring executes any
    request. If we return `true` from the method, then the request is handled further;
    else, it is aborted. In `preHandle`, we first check whether the `user` object
    is present in the session. The presence of the `user` object means that the user
    is already logged in. In such a case, we don't do anything more in this interceptor
    and return `true`. If the user is not logged in, then we redirect to the login
    page and return `false` so that Spring does not process this request further.
  prefs: []
  type: TYPE_NORMAL
- en: Browse to `http://localhost:8080/course_management/courses` to test the login
    page. If you are not already logged in, the login page should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC application using JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to create a web application using Spring
    and JDBC. In this section, we will take a quick look at how to use Spring with
    **JPA** (**Java Persistence API**). We have already learned how to use JPA in
    [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, and in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, so we won't go into detail of how to set
    up the Eclipse project for JPA. However, we will discuss how to use JPA along
    with Spring in detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a separate project for this example. Create a Spring MVC project
    as described in the *Creating Spring project* section of this chapter. On the
    second page of the project wizard, where you are asked to enter a top-level package
    name, enter `packt.jee.course_management_jpa`. Recall that the last part of this
    package name is also used as the web application context.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the EclipseLink JPA provider and the MySQL database driver
    in this project. So, add the Maven dependencies for them in the `pom.xml` file
    of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now configure the project for JPA. Right-click on the project and select
    Configure | Convert to JPA Project. This opens the Project Facets page, with JPA
    selected as one of the facets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Project facets'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the Next button to configure the JPA facet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: JPA facet'
  prefs: []
  type: TYPE_NORMAL
- en: Select the EclipseLink platform in the preceding page. We will also disable
    the library configuration (select from the dropdown for the Type field). Configure
    the MySQL Connection (named CourseMgmtDBConnection), as described in the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. `Persistence.xml` is created under the JPA Content group in Project
    Explorer (the actual location of this file is `src/main/resources/META-INF/persistence.xml`).
    We will configure properties for the MySQL JDBC connection in this. Open the file
    and click the Connection tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Configure connection in persistence.xml'
  prefs: []
  type: TYPE_NORMAL
- en: Select Transaction type as `Resource Local`. Then, enter the JDBC driver details.
    Save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Course entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `Course` entity. Right-click on the project and select
    the JPA Tools | Generate Tables from Entities menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Generate course entity'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that `CourseMgmtDBConnection` is selected (refer to the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, for configuring a MySQL database connection
    in Eclipse) and that List generated classes in persistence.xml is selected. Click
    Next on this and the next page. On the Customize Defaults page, select identity as
    the Key generator and set the package name as `packt.jee.course_management_jpa.entity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Customize JPA entity defaults'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next. Verify the entity class name and the other details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Customize JPA entity details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. The `Course` entity class will be created in the package selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that the wizard has also created the named query to get all the courses
    from the table.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create `EntityManagerFactory` so that `EntityManager` can be
    created from it (refer to the *JPA concepts* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*). We will create a Spring bean/component
    to create and store `EntityManagerFactory`. Furthermore, we will inject (autowire)
    this component into the DAO class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `JPAEntityFactoryBean` class in the `packt.jee.course_management_jpa.entity`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor of the class, we create `EntityManagerFactory`. The argument
    to `createEntityManagerFactory` is the name of the persistence unit, as specified
    in `persistence.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating CourseDAO and Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `CourseDAO` class. We will have an instance of `JPAEntityFactoryBean`
    injected (auto-wired) into this class. Create the `packt.jee.course_management_jpa.dao`
    package and the `CourseDAO` class in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the `getCourses` method, we first create `EntityManager` (from `JPAEntityFactoryBean`)
    and execute the named query. Once we get the results, we close `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` class for `Course` will have `CourseDAO` auto-injected (auto-wired).
    Create `CourseController` in the `packt.jee.course_management_jpa.controller`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in the `CourseController` created for the JDBC application earlier,
    we get courses from the database and add the list of courses to the Model under
    the key name `courses`. This variable will be available to the View page that
    displays the list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the course list view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all the classes to get courses. Let''s now create a JSP to display
    the list of courses. Create `courses.jsp` in the `src/main/webapp/WEB-INF/views`
    folder. Add the following content in the HTML `body` tag of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The View page makes use of JSTL tags to iterate over courses (using the variable
    that was made available in the Model by the Controller) and displays them.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to build the entire application here. The idea was to understand
    how to use JPA with Spring MVC, which we have learned in this section. Browse
    to `http://localhost:8080/course_management_jpa/courses` to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Spring MVC to create web applications.
    As the name indicates, Spring MVC implements the MVC design pattern, which enables
    clear separation of the user interface code and the business logic code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dependency injection feature of the Spring Framework, we can easily
    manage the dependencies of different objects in the application. We also learned
    how to use JDBC and JPA along with Spring MVC to create data-driven web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create and consume web services in JEE
    applications. We will look at both SOAP-based and RESTful web services.
  prefs: []
  type: TYPE_NORMAL
