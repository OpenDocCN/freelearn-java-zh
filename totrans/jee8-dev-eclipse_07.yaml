- en: Creating Web Applications with Spring MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring MVC创建Web应用程序
- en: In the last chapter, we learned how to create JEE applications using EJBs. In
    this chapter, we are going to divert a bit from the core JEE specifications and
    learn Spring MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用EJBs创建JEE应用程序。在这一章中，我们将稍微偏离核心JEE规范，学习Spring MVC。
- en: Although this book is about JEE and Eclipse, and Spring MVC is not a part of
    JEE, it would be worthwhile to understand the Spring MVC framework. Spring MVC
    is a very popular framework for creating web applications and can be used with
    other JEE technologies, such as servlet, JSP, JPA, and EJBs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书是关于JEE和Eclipse的，Spring MVC不是JEE的一部分，但了解Spring MVC框架是值得的。Spring MVC是一个非常流行的用于创建Web应用的框架，并且可以与其他JEE技术（如servlet、JSP、JPA和EJBs）一起使用。
- en: JEE does support MVC out of the box, if you use JSF. Refer to *Java Server Faces*
    in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    a Simple JEE Web Application*, for details. However, there is a difference in
    the design of JSF and Spring MVC. JSF is a component-based MVC framework. It is
    designed so that the user interface designer can create pages by assembling reusable
    components that are either provided by JSF or custom-developed. Spring MVC is
    a request-response-based MVC framework. If you are familiar with writing JSP or
    servlets, then Spring MVC would be an easier framework to use than JSF. You can
    find a good description of component-based MVC (as implemented by JSF) and request-response-based
    MVC (as implemented by Spring MVC) by Ed Burns at [http://www.oracle.com/technetwork/articles/java/mvc-2280472.html](http://www.oracle.com/technetwork/articles/java/mvc-2280472.html).
    JSR 371 for MVC was supposed to be part of JEE 8, but this JSR was later withdrawn
    from JEE 8 specifications. You can find more information about JSR 371 (also called
    MVC 1.0) at [https://www.mvc-spec.org/](https://www.mvc-spec.org/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JEE默认支持MVC，如果你使用JSF。有关详细信息，请参阅[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中的*Java服务器端面*，*创建一个简单的JEE
    Web应用程序*。然而，JSF和Spring MVC的设计有所不同。JSF是一个基于组件的MVC框架。它被设计成用户界面设计师可以通过组装由JSF提供或自定义开发的可重用组件来创建页面。Spring
    MVC是一个基于请求-响应的MVC框架。如果你熟悉编写JSP或servlet，那么Spring MVC将比JSF更容易使用。你可以在Ed Burns的[http://www.oracle.com/technetwork/articles/java/mvc-2280472.html](http://www.oracle.com/technetwork/articles/java/mvc-2280472.html)上找到关于基于组件的MVC（由JSF实现）和基于请求-响应的MVC（由Spring
    MVC实现）的良好描述。MVC的JSR 371原本应该是JEE 8的一部分，但这个JSR后来从JEE 8规范中撤回。你可以在[https://www.mvc-spec.org/](https://www.mvc-spec.org/)上找到更多关于JSR
    371（也称为MVC 1.0）的信息。
- en: 'Before we see how Spring MVC works, we need to understand what the MVC framework
    is. **MVC** stands for **Model-View-Controller**. We are going to refer to the
    MVC framework in the context of Java web applications only, although it should
    be mentioned here that the MVC pattern is often used in desktop applications too:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解Spring MVC是如何工作之前，我们需要了解MVC框架是什么。**MVC**代表**模型-视图-控制器**。我们将在Java Web应用程序的上下文中引用MVC框架，尽管应该在这里提到，MVC模式也常用于桌面应用程序：
- en: '**Model**: The Model contains data that is used by the View to create the output.
    In the example that we have been following in this book, the *Course Management*
    application, if you have a `Course` class that contains information about the
    course to be displayed on a page, then the `Course` object can be called the Model.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：模型包含视图用于创建输出的数据。在我们这本书中跟随的示例中，*课程管理*应用程序，如果你有一个包含要在页面上显示的课程信息的`Course`类，那么这个`Course`对象可以被称为模型。'
- en: Some definitions of MVC also include classes that implement business logic in
    the Model layer. For example, a `CourseService` class that takes a `Course` object
    and calls `CourseDAO` to save the `Course` in the database could also be considered
    a part of the Model layer.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: MVC的一些定义也包括在模型层实现业务逻辑的类。例如，一个`CourseService`类，它接受一个`Course`对象并调用`CourseDAO`将`Course`保存到数据库中，也可以被认为是模型层的一部分。
- en: '**View**: The View is a page that is displayed to the user. A JSP that displays
    a list of courses could be considered a part of the View layer. The View holds
    a reference to the Model object and uses the data it contains to create the page
    that the user sees in the browser.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：视图是显示给用户的页面。一个显示课程列表的JSP可以被认为是视图层的一部分。视图持有模型对象的引用，并使用它包含的数据来创建用户在浏览器中看到的页面。'
- en: '**Controller:** The Controller is the glue between Model and View. It handles
    requests/actions from the web client (for example, the browser), calls the Model
    to handle business logic, and makes Model objects available to the View to create
    the page (user interface) to be returned to the client. The Controller could be
    a servlet, as in the case of JSF, or could be POJOs (as in the case of Spring
    MVC). When Controllers are POJOs, typically they get called by `DispatcherServlet`.
    `DispatherServlet` is a servlet that receives the request and dispatches it to
    one of the Controllers, based on the configuration. We will see example of this
    later in the chapter.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：控制器是模型和视图之间的粘合剂。它处理来自网络客户端（例如，浏览器）的请求/操作，调用模型来处理业务逻辑，并将模型对象提供给视图以创建要返回给客户端的页面（用户界面）。控制器可以是servlet，如JSF的情况，或者可以是POJO（如Spring
    MVC的情况）。当控制器是POJO时，通常由`DispatcherServlet`调用。`DispatcherServlet`是一个接收请求并将其调度到配置中的一个控制器上的servlet。我们将在本章后面看到这个示例。'
- en: MVC provides separation of concerns; that is, the code for the user interface
    and the business logic are separate. Because of this, the UI and the business
    layer can be modified independently to a great extent. Of course, since the UI
    usually displays the data generated by the business layer, it may not always be
    possible to make changes to each of the layers independent of the others. Developers
    of appropriate skills can work on each layer independently. A UI expert need not
    be too worried about how the business layer is implemented and vice versa.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: MVC提供了关注点的分离；也就是说，用户界面和业务逻辑的代码是分开的。正因为如此，UI和业务层可以很大程度上独立地进行修改。当然，由于UI通常显示由业务层生成的数据，因此可能并不总是能够独立于其他层对每一层进行修改。具备适当技能的开发者可以独立地对每一层进行工作。UI专家无需过分担心业务层的实现方式，反之亦然。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Spring dependency injection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring依赖注入简介
- en: Configuring Spring beans and injecting them into the application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Bean并将它们注入到应用程序中
- en: Creating Spring MVC applications using the Eclipse plugin and JEE specifications
    such as JDBC, JPA, and JSP
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse插件和JEE规范（如JDBC、JPA和JSP）创建Spring MVC应用程序
- en: Dependency injection
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Spring MVC is a part of the overall Spring Framework. The core feature of the
    Spring Framework is **dependency injection** (**DI**). Almost all other features
    of the Spring Framework use DI. Objects managed by the dependency injection framework
    are not directly instantiated in the code (using, for example, the `new` operator).
    Let's call them *managed objects*. These objects are created by a DI framework,
    such as Spring. Because these objects are created by a framework, the framework
    has a lot more flexibility in deciding how to set values in the object and from
    where to get them. For example, your **Data Access Object** (**DAO**) class might
    need an instance of a database connection factory object. However, instead of
    instantiating it in the DAO class, you just tell the DI framework that when it
    instantiates the DAO, it has to set the value of a member variable for the connection
    pool factory. Of course, the parameters for the connection pool factory will have
    to be configured somewhere and be known to the DI framework.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC是Spring框架整体的一部分。Spring框架的核心特性是**依赖注入**（**DI**）。Spring框架的几乎所有其他特性都使用了DI。由依赖注入框架管理的对象不是直接在代码中实例化的（例如，使用`new`运算符）。我们可以称它们为*管理对象*。这些对象是由DI框架（如Spring）创建的。因为这些对象是由框架创建的，所以框架在决定如何设置对象中的值以及从哪里获取它们方面具有更多的灵活性。例如，你的**数据访问对象**（**DAO**）类可能需要一个数据库连接工厂对象的实例。然而，你不需要在DAO类中实例化它，你只需告诉DI框架，当它实例化DAO时，它必须设置连接池工厂成员变量的值。当然，连接池工厂的参数必须在某处进行配置，并且为DI框架所知。
- en: When a class instantiates another class, there is tight dependency between them.
    Such design could be a problem if you want to test classes independently of others.
    For example, you may want to test a class that has business logic, but one that
    also refers to a DAO, which in turn depends on a JDBC connection object. When
    testing the first class, you will have to instantiate the DAO and configure the
    connection pool. As we saw in [Chapter 5](part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Unit Testing*, unit tests should be able to run without any external dependencies.
    One way to achieve this is by using DI. Instead of instantiating the DAO class,
    our class could refer to an interface that is implemented by the DAO and have
    the DI framework inject the implementation of this interface at runtime. When
    you are unit testing this class, the DI framework can be configured to inject
    a mock object that implements the required interface. Thus, DI enables loose coupling
    between objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实例化另一个类时，它们之间存在紧密的依赖关系。如果你希望独立于其他类测试类，这种设计可能会成为问题。例如，你可能想测试一个具有业务逻辑的类，但它也引用了一个DAO，而DAO又依赖于一个JDBC连接对象。当你测试第一个类时，你必须实例化DAO并配置连接池。正如我们在[第5章](part0108.html#36VSO0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)“单元测试”中看到的，单元测试应该能够在没有任何外部依赖的情况下运行。实现这一目标的一种方法是通过使用DI。我们不是实例化DAO类，而是让我们的类引用由DAO实现的接口，并在运行时由DI框架注入该接口的实现。当你对这个类进行单元测试时，可以配置DI框架注入一个实现了所需接口的模拟对象。因此，DI使得对象之间能够实现松耦合。
- en: Dependency injection in Spring
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的依赖注入
- en: 'Because DI is at the core of the Spring Framework, let''s spend some time understanding
    how it works in Spring. We will create a standalone application for this purpose.
    Create a simple Maven project. Add the following dependency for the Spring Framework:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因为依赖注入（DI）是Spring框架的核心，让我们花些时间来了解它在Spring中的工作方式。为此，我们将创建一个独立的应用程序。创建一个简单的Maven项目。为Spring框架添加以下依赖项：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace the preceding version number with the latest version of Spring. Classes
    managed by the DI container of Spring are called beans or components. You can
    either declare beans in an XML file or you can annotate the class. We will use
    annotations in this chapter. However, even though we use annotations, we need
    to specify the minimum configuration in an XML file. So, create an XML file in
    the `src/main/resource` folder of your project and name it `context.xml`. The
    reason that we are creating this file in the `src/main.resource` folder is that
    the files in this folder are made available in the classpath. Next, add the following
    content to `context.xml`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的版本号替换为Spring的最新版本。由Spring的DI容器管理的类被称为bean或组件。你可以要么在XML文件中声明bean，要么在类上使用注解。在本章中，我们将使用注解。然而，尽管我们使用了注解，我们仍需要在XML文件中指定最小配置。因此，在你的项目`src/main/resource`文件夹中创建一个XML文件，并将其命名为`context.xml`。我们在`src/main.resource`文件夹中创建此文件的原因是，此文件夹中的文件将在类路径中可用。接下来，将以下内容添加到`context.xml`文件中：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the `<context:component-scan>` tag, we are telling the Spring Framework
    to scan the `base-package` folder and then look for the classes annotated with
    `@Component` and recognize them as managed classes so that they can be made available
    when injecting dependencies. In the preceding example, all classes in the `packt.jee.eclipse.spring`
    package (and its sub-packages) would be scanned to identify components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`<context:component-scan>`标签，我们告诉Spring框架扫描`base-package`文件夹，然后查找带有`@Component`注解的类，并将它们识别为受管理的类，以便在注入依赖项时可以使用。在前面的例子中，`packt.jee.eclipse.spring`包（及其子包）中的所有类都将被扫描以识别组件。
- en: Information read from the configuration file must be saved in an object. In
    Spring, it is saved in an instance of the `ApplicationContext` interface. There
    are different implementations of `ApplicationContext`. We will be using the `ClassPathXmlApplicationContext`
    class, which looks for the configuration XML file in the classpath.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从配置文件中读取的信息必须保存到一个对象中。在Spring中，它被保存在`ApplicationContext`接口的一个实例中。`ApplicationContext`有不同的实现方式。我们将使用`ClassPathXmlApplicationContext`类，它在类路径中查找配置XML文件。
- en: 'We will now create two Spring components. The first one is `CourseDAO`, and
    the second is `CourseService`. Although we won''t write any business logic in
    these classes (the purpose of this example is to understand how DI works in Spring),
    assume that `CourseDAO` could have the code to access the database and `CourseService`
    calls `CourseDAO` to perform the database operations. So, `CourseService` is dependent
    on `CourseDAO`. To keep the code simple, we will not create any interface for
    `CourseDAO` but will have the direct dependency. Create the `CourseDAO` class
    as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建两个Spring组件。第一个是`CourseDAO`，第二个是`CourseService`。尽管我们不会在这些类中编写任何业务逻辑（此示例的目的是了解Spring中的DI如何工作），但假设`CourseDAO`可能有访问数据库的代码，而`CourseService`调用`CourseDAO`来执行数据库操作。因此，`CourseService`依赖于`CourseDAO`。为了使代码简单，我们不会为`CourseDAO`创建任何接口，而是将直接依赖。按照以下方式创建`CourseDAO`类：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will have no methods in `CourseDAO`, but as mentioned before, it could have
    methods to access the database. `@Component` marks this class as managed by Spring.
    Now, create the `CourseService` class. This class needs an instance of `CourseDAO`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CourseDAO`中，我们将没有方法，但如前所述，它可能有访问数据库的方法。`@Component`将此类标记为由Spring管理。现在，创建`CourseService`类。此类需要一个`CourseDAO`实例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have declared a member variable called `courseDAO` and annotated it with
    `@Autowired`. This tells Spring to look for a component in its context (of `CourseDAO`
    type) and assign that to the `courseDAO` member.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已声明一个名为`courseDAO`的成员变量，并使用`@Autowired`进行了注解。这告诉Spring在其上下文中查找（`CourseDAO`类型的）组件并将其分配给`courseDAO`成员。
- en: 'We will now create the main class. It creates `ApplicationContext`, gets the `CourseService`
    bean, calls the `getCourseDAO` method, and then checks whether it was injected
    properly. Create the `SpringMain` class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建主类。它创建`ApplicationContext`，获取`CourseService`豆/组件，调用`getCourseDAO`方法，然后检查它是否被正确注入。创建`SpringMain`类：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first create an instance of `ClassPathXmlApplicationContext`. The configuration
    XML file is passed as an argument to the constructor. We then get the `courseService`
    bean/component. Note the naming convention when specifying the bean name; it is
    the class name with the first letter in lowercase. We then get and print the value
    of `CourseDAO`. The value won't show any meaningful information, but if the value
    is not null, then it would mean that the Spring DI container has injected it properly.
    Note that we have not instantiated `CourseDAO`; it is the Spring DI container
    that instantiates and injects this object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`ClassPathXmlApplicationContext`实例。配置XML文件作为参数传递给构造函数。然后我们获取`courseService`豆/组件。注意指定豆名称时的命名约定；它是类名，首字母小写。然后我们获取并打印`CourseDAO`的值。值不会显示任何有意义的信
- en: 'In the preceding code, we saw an example of injecting objects at the member
    declaration (this is also called property injection). We can have this object
    injected in the constructors too:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了在成员声明处注入对象的一个示例（这也可以称为属性注入）。我们也可以在构造函数中注入此对象：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the `@Autowired` annotation is moved to the constructor, and the
    single constructor argument is auto-injected. You can also have the object injected
    in a setter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`@Autowired`注解已移动到构造函数中，并且单个构造函数参数是自动注入的。您也可以在设置器中注入对象：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Component scopes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件作用域
- en: 'You can specify the scope for your components in Spring MVC. The default scope
    is singleton, which means that there will be only one instance of the component
    in the context. Every request for this component will be served with the same
    instance. The other scopes are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Spring MVC中指定组件的作用域。默认作用域是单例，这意味着在上下文中将只有一个组件实例。对每个此组件的请求都将使用相同的实例。其他作用域如下：
- en: '**Prototype**: Each request for the component is served with a new instance
    of that class.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原型**：为每个组件请求提供该类的新实例。'
- en: '**Request**: Valid for web applications. Single instance of a component class
    created for each HTTP request.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：适用于Web应用程序。为每个HTTP请求创建的组件类的单个实例。'
- en: '**Session**: Single instance of a component class created for each HTTP session.
    Used in web applications.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：为每个HTTP会话创建的组件类的单个实例。用于Web应用程序。'
- en: '**Global session**: Single instance of a component class created for the global
    HTTP session. Used in portlet applications.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局会话**：为全局HTTP会话创建的组件类的单个实例。用于portlet应用程序。'
- en: '**Application**: Single instance of a component class in the web application.
    The instance is shared by all sessions in that application.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序**：在Web应用程序中组件类的单个实例。该实例由该应用程序中的所有会话共享。'
- en: See  [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes) for
    more information on component scopes in Spring.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring中组件作用域的更多信息，请访问[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes)。
- en: If the component to be injected was not instantiated at the time it was requested,
    then Spring creates an instance of the component. In the previous example, we
    have not specified the scope of the `CourseDAO` component, so the same instance
    would be injected if there is another request for injecting `CourseDAO`. You can
    specify the scope in the `@Component` annotation. You can also specify the component
    name if you want to override the default name that Spring gives to the component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在请求组件时该组件尚未实例化，那么Spring将创建该组件的一个实例。在先前的例子中，我们没有指定`CourseDAO`组件的作用域，因此如果有另一个请求注入`CourseDAO`，则将注入相同的实例。你可以在`@Component`注解中指定作用域。如果你想覆盖Spring给组件提供的默认名称，也可以指定组件名称。
- en: 'To see if a single instance of a component is injected when no scope is specified,
    let''s change the `main` method in the `SpringMain` class and make two calls to
    the `getBean` method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看在没有指定作用域的情况下是否注入了组件的单个实例，让我们更改`SpringMain`类中的`main`方法并调用两次`getBean`方法：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the application and you should see the same instance of the `courseService`
    bean printed. Let''s change the scope of the `CourseService` component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该会看到打印出相同的`courseService` bean实例。现在让我们改变`CourseService`组件的作用域：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the application again; this time, you should see different instances of
    the `CourseService` component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序；这次，你应该会看到`CourseService`组件的不同实例。
- en: 'When Spring comes across the `@Autowire` annotation, it tries to find the component
    by type. In the preceding example, `courseDAO` is annotated with `@Autowire`.
    Spring tries to find a component of `CourseDAO` type; it finds an instance of
    `CourseDAO` and injects it. But what if there are multiple instances of the class
    in the context? In such a case, we can use the `@Qualifier` annotation to uniquely
    identify components. Let''s now create the `ICourseDAO` interface, which will
    be implemented by two components, namely `CourseDAO` and `CourseDAO1`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring遇到`@Autowire`注解时，它会尝试通过类型查找组件。在先前的例子中，`courseDAO`被注解为`@Autowire`。Spring会尝试找到一个`CourseDAO`类型的组件；它找到一个`CourseDAO`的实例并将其注入。但如果上下文中存在该类的多个实例呢？在这种情况下，我们可以使用`@Qualifier`注解来唯一标识组件。现在让我们创建`ICourseDAO`接口，该接口将由两个组件实现，即`CourseDAO`和`CourseDAO1`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`CourseDAO` implements `ICourseDAO` and is uniquely qualified as `"courseDAO"`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO`实现了`ICourseDAO`，并且被唯一限定为`"courseDAO"`：'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`CourseDAO1` implements `ICourseDAO` and is uniquely qualified as `"courseDAO1"`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`CourseDAO1`实现了`ICourseDAO`，并且被唯一限定为`"courseDAO1"`：'
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `CourseService` class, we will use a qualifier to uniquely identify
    whether we want `CourseDAO` or `CourseDAO1` to be injected:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CourseService`类中，我们将使用限定符来唯一标识我们想要注入`CourseDAO`还是`CourseDAO1`：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The qualifier can also be specified at method arguments, for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符也可以在方法参数中指定，例如：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the application now. You should see that an instance of `CourseDAO1` is
    printed in the console.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序。你应该会在控制台看到打印出一个`CourseDAO1`实例。
- en: We have covered the basics of dependency injection in Spring. However, Spring
    offers a lot more options and features for dependency injection than we have covered
    here. We will see more DI features as and when required in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Spring中依赖注入的基本知识。然而，Spring提供的依赖注入选项和功能比我们在这里介绍的要多得多。在本章中，我们将根据需要看到更多的DI功能。
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies)
    for more information about dependency injection in Spring.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring中依赖注入的更多信息，请访问[https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-dependencies)。
- en: Installing Spring Tool Suite
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Spring Tool Suite
- en: '**Spring Tool Suite** (**STS**) is a set of tools in Eclipse for creating Spring
    applications. It can be either installed as a plugin to an existing installation
    of Eclipse JEE or can be installed standalone. The standalone version of STS is
    also packaged with Eclipse EE, so all Eclipse features for Java EE development
    are available in STS too. You can download STS from [https://spring.io/tools](https://spring.io/tools).
    Since we have already installed Eclipse EE, we will install STS as a plugin. The
    easiest way to install the STS plugin is from Eclipse Marketplace. Select the
    Help | Eclipse Marketplace... menu.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Tool Suite**（**STS**）是Eclipse中用于创建Spring应用的一组工具。它既可以作为Eclipse JEE现有安装的插件安装，也可以独立安装。STS的独立版本也包含在Eclipse
    EE中，因此STS也提供了所有Eclipse Java EE开发功能。您可以从[https://spring.io/tools](https://spring.io/tools)下载STS。由于我们已安装Eclipse
    EE，我们将以插件的形式安装STS。在Eclipse Marketplace中安装STS插件的最简单方法是选择“帮助 | Eclipse Marketplace...”菜单。'
- en: 'Type `Spring Tool Suite` in the Find box, and click the Go button:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找框中输入`Spring Tool Suite`，然后点击“Go”按钮：
- en: '![](img/00178.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00178.jpeg)'
- en: 'Figure 8.1: Search fir STS in Eclipse Marketplace'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：在Eclipse Marketplace中搜索STS
- en: Click Install. The next page shows the features of STS that will be installed.
    Click Confirm to install the selected features.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“安装”。下一页将显示将要安装的STS功能。点击“确认”以安装所选功能。
- en: Creating a Spring MVC application
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring MVC应用
- en: Spring MVC can be used for creating web applications. It provides an easy framework
    to map incoming web requests to a handler class (Controller) and create dynamic
    HTML output. It is an implementation of the MVC pattern. The Controller and Models
    are created as POJOs, and Views can be created using JSP, JSTL, XSLT, and even
    JSF. However, in this chapter, we will focus on creating Views using JSP and JSTL.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC可用于创建Web应用。它提供了一个简单的框架，将传入的Web请求映射到处理类（控制器）并创建动态HTML输出。它是MVC模式的实现。控制器和模型作为POJO创建，视图可以使用JSP、JSTL、XSLT甚至JSF创建。然而，在本章中，我们将专注于使用JSP和JSTL创建视图。
- en: You can find the Spring web documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)找到Spring网络文档。
- en: 'A web request is handled by four layers in Spring MVC:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Spring MVC通过四层处理网络请求：
- en: '**Front controller**: This is a Spring servlet configured in `web.xml`. Based
    on the request URL pattern, it passes requests to the Controller.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端控制器**：这是一个配置在`web.xml`中的Spring servlet。根据请求URL模式，它将请求传递到控制器。'
- en: '**Controller**: These are POJOs annotated with `@Controller`. For each Controller
    that you write, you need to specify a URL pattern that the Controller is expected
    to handle. Sub-URL patterns can be specified at the method level too. We will
    see examples of this later. Controller has access to Model and to HTTP request
    and response objects. Controller can delegate processing of a request to other
    business handler objects, get results, and populate the Model object, which is
    made available to View by Spring MVC.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这些是带有`@Controller`注解的POJO。对于您编写的每个控制器，您需要指定控制器预期处理的URL模式。子URL模式也可以在方法级别指定。我们将在稍后看到这方面的示例。控制器可以访问模型以及HTTP请求和响应对象。控制器可以将请求的处理委托给其他业务处理对象，获取结果，并填充模型对象，该对象由Spring
    MVC提供给视图。'
- en: '**Model**: These are data objects. The Controller and View layers can set and
    get data from Model objects.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这些是数据对象。控制器和视图层可以设置和获取模型对象中的数据。'
- en: '**View**: These are typically JSPs, but Spring MVC supports other types of
    Views too. See View technologies in the Spring documentation at [https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这些通常是JSP页面，但Spring MVC也支持其他类型的视图。请参阅Spring文档中的视图技术[https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view)。'
- en: We will learn Spring MVC in this chapter through examples, as we have been learning
    in some other chapters in this book. We will create a part of the same *Course
    Management* application using Spring MVC. The application will display a list
    of courses with options to add, remove, and modify them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过示例学习本章的Spring MVC，就像我们在本书的一些其他章节中学习的那样。我们将使用Spring MVC创建同一**课程管理**应用的一部分。该应用将显示课程列表，并提供添加、删除和修改课程的功能。
- en: Creating a Spring project
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Spring项目
- en: 'First, make sure that you have installed STS in Eclipse EE. From the Eclipse
    menu, select File | New | Other and then select the Spring | Spring Legacy Project
    option. Enter the project name and select the Spring MVC Project template:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保你在Eclipse EE中安装了STS。从Eclipse菜单中选择File | New | Other，然后选择Spring | Spring
    Legacy Project选项。输入项目名称并选择Spring MVC Project模板：
- en: '![](img/00179.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00179.jpeg)'
- en: 'Figure 8.2: Select the Spring MVC Project template'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：选择Spring MVC项目模板
- en: 'Click on Next. The page will ask you to enter the top-level package name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步。页面将要求你输入顶级包名：
- en: '![](img/00180.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00180.jpeg)'
- en: 'Figure 8.3: Enter top-level package name'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：输入顶级包名
- en: Whatever you enter as a top-level package, the wizard takes the third sub-package
    as the application name. When the application is deployed in a server, the application
    name becomes the context name. For example, if you enter the package name as `packt.jee.course_management`,
    then `course_management` becomes the application name, and the base URL of the
    application on the local machine would be `http://localhost:8080/course_management/`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你输入什么作为顶级包，向导都会将第三个子包作为应用程序名称。当应用程序在服务器上部署时，应用程序名称变为上下文名称。例如，如果你输入的包名为`packt.jee.course_management`，那么`course_management`将成为应用程序名称，本地机器上应用程序的基本URL将是`http://localhost:8080/course_management/`。
- en: Click Finish. This creates a Maven project with the required libraries for Spring
    MVC.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击完成。这将创建一个包含所需库的Maven项目，用于Spring MVC。
- en: Understanding files created by the Spring MVC project template
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring MVC项目模板创建的文件
- en: 'Let''s examine some of the files created by the template:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查模板创建的一些文件：
- en: '`src/main/webapp/WEB-INF/web.xml`: A front Controller servlet is declared here,
    along with other configurations:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/web.xml`: 在这里声明了一个前端控制器servlet以及其他配置：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`DispatcherServlet` is the front Controller servlet. It is passed the path
    of the context (XML) file for configuring Spring DI. Recall that in the standalone
    Spring application, we created `context.xml` to configure dependency injection.
    The `DispatcherServlet` servlet is mapped to handle requests to this web application.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatcherServlet`是前端控制器servlet。它传递上下文（XML）文件的路径以配置Spring DI。回想一下，在独立Spring应用程序中，我们创建了`context.xml`来配置依赖注入。`DispatcherServlet`
    servlet被映射来处理对此Web应用程序的请求。'
- en: '`src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`: Context configuration
    for Spring DI. Some of the notable configuration parameters in this file are as
    follows:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src/main/webapp/WEB-INF/spring/appServlet/servlet-context.xml`：Spring DI的上下文配置。此文件中的一些显著配置参数如下：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This enables annotations for configuring dependency injection at the class
    level:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这启用了在类级别配置依赖注入的注解：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Static files, such as CSS, JavaScript, and images, can be placed in the `resources`
    folder (`src/main/webapp/resources`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件，如CSS、JavaScript和图像，可以放置在`resources`文件夹中（`src/main/webapp/resources`）：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This tells Spring to use the `InternalResourceViewResolver` class to resolve
    Views. Properties of this bean tell the `InternalResourceViewResolver` class to
    look for the View files in the `/WEB-INF/views` folder. Furthermore, Views will
    be JSP files, as indicated by the suffix property. Our Views will be the JSP files
    in the `src/main/webapp/WEB-INF/views` folder:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Spring使用`InternalResourceViewResolver`类来解析视图。此bean的属性告诉`InternalResourceViewResolver`类在`/WEB-INF/views`文件夹中查找视图文件。此外，视图将是JSP文件，如后缀属性所示。我们的视图将是`src/main/webapp/WEB-INF/views`文件夹中的JSP文件：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This tells Spring to scan the `packt.jee.course_management` package and its
    sub-packages to search for components (annotated by `@Component`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Spring扫描`packt.jee.course_management`包及其子包以搜索组件（由`@Component`注解）。
- en: 'The default template also creates one Controller and one View. The controller
    class is `HomeController` in the package that you specified in the Spring project
    wizard (in our example, it is `packt.jee.course_management`). Controller in Spring
    MVC is called by the dispatcher servlet. Controllers are annotated by `@Controller`.
    To map the request path to a Controller, you use the `@RequestMapping` annotation.
    Let''s see the code generated by the template in the `HomeController` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板还创建了一个控制器和一个视图。控制器类是你在Spring项目向导中指定的包中的`HomeController`（在我们的例子中是`packt.jee.course_management`）。Spring
    MVC中的控制器由调度器servlet调用。控制器通过`@Controller`注解。要映射请求路径到控制器，你使用`@RequestMapping`注解。让我们看看模板在`HomeController`类中生成的代码：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `home` method is annotated with `@RequestMapping`. The value of mapping
    is `/`, which tells the dispatcher servlet to send all requests coming its way
    to this method. The `method` attribute tells the dispatcher to call the `home`
    method only for HTTP requests of the `GET` type. The `home` method takes two arguments,
    namely `Locale` and `Model`; both are injected at runtime by Spring. The `@RequestMapping`
    annotation also tells Spring to insert any dependencies when calling the `home`
    method, and so `locale` and `model` are auto-injected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`home`方法被`@RequestMapping`注解。映射的值是`/`，这告诉Dispatcher Servlet将所有传入的请求发送到这个方法。`method`属性告诉Dispatcher只对HTTP请求的`GET`类型调用`home`方法。`home`方法接受两个参数，即`Locale`和`Model`；这两个都是在运行时由Spring注入的。`@RequestMapping`注解还告诉Spring在调用`home`方法时插入任何依赖项，因此`locale`和`model`会自动注入。'
- en: 'The method itself does not do much; it gets the current date-time and sets
    it as an attribute in the Model. Any attributes set in the Model are available
    to the View (JSP). The method returns a string, `"home"`. This value is used by
    Spring MVC to resolve the View to be displayed. The `InternalResourceViewResolver`
    that we saw in `servlet-context.xml` previously resolves this as `home.jsp` in
    the `/WEB-INF/views` folder. `home.jsp` has the following code in the `<body>`
    tag:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法本身并没有做什么；它获取当前的日期和时间，并将其设置为Model的属性。在Model中设置的任何属性都对View（JSP）可用。该方法返回一个字符串，“home”。这个值被Spring
    MVC用来解析要显示的View。我们在之前的`servlet-context.xml`中看到的`InternalResourceViewResolver`将这个值解析为`/WEB-INF/views`文件夹中的`home.jsp`。`home.jsp`在`<body>`标签中有以下代码：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `serverTime` variable comes from the Model object set in the `home` method
    of `HomeController`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`serverTime`变量来自`HomeController`的`home`方法中设置的Model对象。'
- en: To run this project, we need to configure a server in Eclipse and add this project
    to the server. Refer to the *Configuring Tomcat in Eclipse* and *Running JSP in
    Tomcat* sections in [Chapter 2](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating a Simple JEE Web Application*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此项目，我们需要在Eclipse中配置一个服务器并将此项目添加到服务器中。请参考[第2章](part0037.html#1394Q0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55)中的*在Eclipse中配置Tomcat*和*在Tomcat中运行JSP*部分，*创建一个简单的JEE
    Web应用程序*。
- en: 'Once you configure Tomcat and add the project to it, start the server. Then,
    right-click on the project and select Run As | Run on Server. You should see a
    hello message with the timestamp displayed in the internal Eclipse browser. The
    URL in the browser''s address bar should be `http://localhost:8080/course_management/`,
    assuming that Tomcat is deployed on port `8080` and the context name (derived
    from the top-level package name) is `course_management`. If you want to change
    the default context name or remove the context, that is, deploy the application
    in the root context, then open the project properties (right-click on the project
    and select Properties) and go to Web Project Settings. You can change the context
    root name or remove it from this page:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你配置了Tomcat并将项目添加到其中，启动服务器。然后，在项目上右键单击并选择Run As | Run on Server。你应该在Eclipse的内部浏览器中看到一个带有时间戳的hello消息。浏览器地址栏中的URL应该是`http://localhost:8080/course_management/`，假设Tomcat部署在端口`8080`，上下文名称（从顶级包名派生）是`course_management`。如果你想更改默认的上下文名称或删除上下文，即以根上下文部署应用程序，那么打开项目属性（在项目上右键单击并选择Properties）并转到Web
    Project Settings。你可以从这个页面更改上下文根名称或删除它：
- en: '![](img/00181.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00181.jpeg)'
- en: 'Figure 8.4: Context root setting'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：上下文根设置
- en: For our *Course Management* application, we are not going to need the `HomeController`
    class or `home.jsp`, so you can go ahead and delete these files.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的*课程管理*应用程序，我们不需要`HomeController`类或`home.jsp`，所以你可以继续删除这些文件。
- en: Building the Spring MVC application using JDBC
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC构建Spring MVC应用程序
- en: In this section, we will build a part of the course management application using
    Spring MVC and JDBC. The application will display a list of courses and options
    for adding, deleting, and modifying courses. We will continue using the project
    that we created in the previous section. We will learn many of the features of
    Spring for data access using JDBC as we go along.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Spring MVC和JDBC构建课程管理应用程序的一部分。该应用程序将显示课程列表以及添加、删除和修改课程的选项。我们将继续使用上一节中创建的项目。随着我们的进行，我们将学习使用JDBC作为数据访问的许多Spring特性。
- en: First, we will configure our datasource. We will use the same MySQL database
    that we created in the *Creating database schema* section of [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a datasource
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Spring, you can configure a JDBC datasource either in Java code or in the
    XML configuration (context) file. Before we see how to configure a datasource,
    we need to add some dependencies in Maven. In this chapter, we will use Apache''s
    Commons DBCP component for connection pooling (recall that in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*, we selected the Hikari connection pool).
    Visit [https://commons.apache.org/proper/commons-dbcp/](https://commons.apache.org/proper/commons-dbcp/)
    for details on Apache DBCP. In addition to adding a dependency for Apache DBCP,
    we need to add dependencies for Spring JDBC and the MySQL JDBC driver. Add the
    following dependencies to the `pom.xml` of the project:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you want to create a datasource in Java code, you can do so as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, we will configure a datasource in an XML configuration file. Open
    `servlet-context.xml` (you will find it in the `src/main/webapp/WEB-INF/spring/appServlet`
    folder) and add the following bean:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you are wondering what *bean* means, it is the same as the component that
    we created in the examples earlier in the chapter. We have so far created a component
    using annotations, but the component and the bean can be declared in an XML file
    too. In fact, this is how it used to be in earlier versions, till support for
    annotations was added in Spring. In a real-world application, you may want to
    encrypt database passwords before specifying them in a configuration file. One
    way to decrypt a password before sending it to the database is to create a wrapper
    class for the datasource (in the previous example, create a wrapper for `org.apache.commons.dbcp.BasicDataSource`)
    and override the `setPassword` method, where you can decrypt the password.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep the database connection parameters separate from the Spring
    configuration, then you can use a `properties` file. Spring provides a consistent
    way to access resources such as a `properties` file. Just as you can access web
    URLs using the `http` protocol prefix or the file URL using the `file` protocol
    prefix, Spring allows you to access resources in the classpath using the `classpath`
    prefix. For example, if we create a `jdbc.properties` file and save it in one
    of the folders in the classpath, then we could access it as `classpath:jdbc.properties`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#resources) for
    detailed information on accessing resources using Spring. The Spring resource
    URL formats can be used in configuration files or Spring APIs where the resource
    location is expected.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Spring also provides a convenient tag to load property files in context config
    XML. You can access the values of properties in a `property` file in the config
    XML using the `${property_name}` syntax.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move the database connection properties to a file in this example.
    Create `jdbc.properties` in the `src/main/resources` folder. Maven makes this
    folder available in the classpath, so we can access it using the Spring resource
    format in the XML configuration file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will load this `properties` file from `servlet-context.xml` using the `property-placeholder`
    tag:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that the location of the `property` file is specified using the Spring
    resource format. In this case, we ask Spring to look for the `jdbc.properties`
    file in the classpath. Further, because the `src/main/resources` folder is in
    the classpath (where we saved `jdbc.properties`), it should be loaded by Spring.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify the `datasource` bean declaration in `servlet-context.xml`
    to use the property values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the order of the `property-placeholder` tag and where the properties
    are used does not matter. Spring loads the entire XML configuration file before
    replacing `property` references with their values.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Using the Spring JDBCTemplate class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides a utility class called `JDBCTemplate` that makes it easy to
    perform many operations using JDBC. It provides convenient methods to execute
    SQL statements, map results of a query to an object (using the `RowMapper` class),
    close a database connection at the end of database operations, and many others.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Visit [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc) for
    more information on `JDBCTemplate`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write any data access code, we will create a **Data Transfer Object**
    (**DTO**), `CourseDTO`, which will just contain members that describe one `Course`
    and setters and getters for them. Create `CourseDTO` in the `packt.jee.course_management.dto`
    package. Instances of this class will be used to transfer data between different
    tiers of our application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will now create a simple DAO that will use the `JdbcTemplate` class to execute
    a query to get all courses. Create the `CourseDAO` class in the `packt.jee.course_management.dao`
    package. Annotate the `CourseDAO` class with `@Repository`. Similar to `@Component`, the `@Repository`
    annotation marks the class as a Spring DI container-managed class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: As per the Spring documentation ([https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-stereotype-annotations)),
    `@Component` is a generic annotation to mark a class as Spring container-managed,
    and `@Repository` and `@Controller` are more specific ones. More specific annotations
    help to identify classes for specific treatments. It is recommended to use `@Repository`
    annotations for DAOs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`CourseDAO` needs to have an instance of the `JdbcTemplate` class to execute
    queries and other SQL statements. `JdbcTemplate` needs a `DataSource` object before
    it can be used. We will have `DataSource` injected in a method in `CourseDAO`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `datasource` that we have configured in `servlet-context.xml` will be injected
    by Spring when the `CourseDAO` object is created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now write the method to get all courses. The `JdbcTemplate` class has
    a `query` method that allows you to specify `RowMapper`, where you can map each
    row in the query to a Java object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `getCourses` method, we will execute a static query. Later, we will see
    how to execute parameterized queries too. The second argument to the `query` method
    of `JDBCTemplate` is an instance of the `RowMapper` interface. We have created
    the static inner class `CourseRowMapper` that implements the `RowMapper` interface.
    We override the `mapRow` method, which is called for each row in `ResultSet`,
    and then we create/map the `CourseDTO` object from the `ResultSet` passed in the
    arguments. The method returns a `CourseDTO` object. The result of `JdbcTemplate.query`
    is a list of `CourseDTO` objects. Note that the `query` method can also return
    other Java collection objects, such as `Map`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write a method to add a course to the table:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we add or insert a new course, we want to get the ID of the new record,
    which is autogenerated. Furthermore, we would like to use the prepared statement
    to execute SQL. Therefore, first we create `KeyHolder` for the auto-generated
    field. The `update` method of `JdbcTemplate` has many overloaded versions. We
    use the one that takes `PreparedStatementCreator` and `KeyHolder`. We create an
    instance of `PreparedStatementCreator` and override the `createPreparedStatement`
    method. In this method, we create a JDBC `PreparedStatement` and return it. Once
    the update method is successfully executed, we retrieve the auto-generated value
    by calling the `getKey` method of `KeyHolder`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The methods to update or delete a course are similar:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to add one more method to `CourseDAO`, to get the details of a course,
    given the ID:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`queryForObject` returns a single object for a given query. We use a parameterized
    query here, and the parameter is passed as the last argument to the `queryForObject`
    method. Further, we use `CourseRowMapper` to map the single row returned by this
    query to `CourseDTO`. Note that you can pass a variable number of parameters to the `queryForObject`
    method, although in this case, we pass a single value, that is, the ID.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the methods in the `CourseDAO` class to access data for `Course`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed discussion on data access using JDBC in Spring, refer to [https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#jdbc).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Spring MVC Controller
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create the `Controller` class. In Spring MVC, the Controller is
    mapped to the request URL and handles requests matching the URL pattern. The request
    URL for matching an incoming request is specified at the method level in the controller.
    However, more generic request mapping can be specified at the `Controller` class
    level, and a specific URL, with respect to the URL at the class level, can be
    specified at the method level.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `CourseController` in the `packt.jee.course_management.controller`
    package. Annotate it with `@Controller`. The `@Controller` annotation is of type
    `@Component`, and allows the Spring Framework to identify that class specifically
    as a controller. Add the method to get courses in `CourseController`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CourseDAO` instance is autowired; that is, it will be injected by Spring.
    We have added the  `getCourses` method, which takes a Spring Model object. Data
    can be shared between View and Controller using this Model object. Therefore,
    we add an attribute to Model, named `courses`, and assign the list of courses
    that we get by calling `courseDAO.getCourses`. This list could be used in the
    View JSP as the `courses` variable. We have annotated this method with `@RequestMapping`.
    This annotation maps the incoming request URL to a controller method. In this
    case, we are saying that any request (relative to the root) that starts with `/courses`
    should be handled by the `getCourses` method in this controller. We will add more
    methods to `CourseController` later and discuss some of the parameters that we
    can pass to the `@RequestMapping` annotation, but first let's create a View to
    display the list of courses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Creating View
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created data access objects for `Course` and a Controller. Let's see
    how we can call them from a View. Views in Spring are typically JSPs. Create a
    JSP (name it `courses.jsp`) in the `src/main/webapp/WEB-INF/views` folder. This
    is the folder that we configured in `servlet-context.xml` to hold the Spring View
    files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the JSTL tag library in `courses.jsp`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The markup code to display courses is very simple; we make use of the `courses`
    variable, which is made available in the Model from the `CourseController.getCourses`
    method and displays values using JSTL expressions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Recall that `courses` is a list of objects of `CourseDTO` type. Members of `CourseDTO`
    are accessed in the `forEach` tag to display the actual values.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can't run this page from Eclipse the way we have so far in
    this book, that is, by right-clicking on the project or page and selecting Run
    As | Run on Server. If you try to run the project (right-click on the project
    and select the Run menu), then Eclipse will try to open the `http://localhost:8080/course_management/`
    URL, and because we do not have any start page (`index.html` or `index.jsp`),
    we will get an HTTP 404 error. The reason that we can't run the page by right-clicking
    and selecting the run option is that Eclipse tries to open `http://localhost:8080/course_management/WEB-INF/views/courses.jsp`,
    and this fails because files in `WEB-INF` are not accessible from outside the
    server. Another reason, or rather the primary reason, that this URL will not work
    is that in `web.xml`, we have mapped all requests to be handled by `DispatcherServlet`
    of the Spring Framework and it does not find a suitable mapping for the request
    URL. To run the application, open the URL `http://localhost:8080/course_management/courses`
    in the browser.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Mapping data using @ModelAttribute
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the feature to insert a new course. In the
    process, we will learn more about mapping requests to methods and mapping request
    parameters to method arguments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we implemented `CourseController` with one method,
    `getCourses`. We will now add methods to insert new courses. To add a course,
    we first need to display a View with a form that accepts the user input. When
    the user actually submits the form, the form data should be posted to a URL that
    handles insertion of the data to the database. Therefore, there are two requests
    involved here: the first is to display the *add course* form, and the second is
    to handle the data posted from the form. We will call the first request `addCourse`
    and the second request `doAddCourse`. Let''s first create the user interface.
    Create a new JSP and name it `addCourse.jsp`. Add the following markup to the
    `body` of the page (JSTL and other header declarations are skipped to save space):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The page expects a course variable to be made available by the controller. In
    the form body, it assigns the values of the course to appropriate input fields;
    for example, the `${course.name}` value is assigned to the text input for `Course
    Name`. The form posts the data to the `"${pageContext.request.contextPath}/doAddCourse"`
    URL. Note that since our application is not deployed in the root context, we need
    to include the context name in the URL.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add Controller methods to handle two requests for add: `addCourse`
    and `doAddCourse`. When the `addCourse` request is made, we want to serve the
    page that displays the input form. When the user clicks the Submit button, we
    want form data to be sent using the `doAddCourse` request. Open the `CourseController`
    class and add the following method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `addCourse` method is configured, using the `@RequestMapping` annotation,
    to handle  request URLs starting (relative to context root) with `"/addCourse"`.
    If previously the  `course` attribute was added to Model, then we want this object
    to be passed as an argument to this function. Using `@ModelAttribute`, we tell
    the Spring Framework to inject the Model attribute called `course` if it is present
    and assign it to the argument named `course`; else, `null` is passed. In the case
    of the first request, Model would not have a `course` attribute, so it would be
    `null`. In the subsequent requests, for example, when the user-entered data in
    the form (to add a course) is not valid and we want to redisplay the page, Model
    will have the `course` attribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a handler method for the `''/doAddCourse''` request. This
    is a `POST` request sent when the user submits the form in `addCourse.jsp` (refer
    to the form and its `POST` attribute discussed earlier):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `doAddCourse` method also asks Spring to inject the Model attribute called
    `course` as the first argument. It then adds the course to the database using
    `CourseDAO`. In the case of an error, it returns the `addCourse` string, and Spring
    MVC displays `addCourse.jsp` again. If the course is successfully added, then
    the request is redirected to `courses`, which tells Spring to process and display
    `courses.jsp`. Recall that in `servlet-context.xml` (the Spring context configuration
    file in the `src/main/webapp/WEB-INF/spring/appServlet` folder), we configured
    a bean with the `org.springframework.web.servlet.view.InternalResourceViewResolver`
    class. This class is extended from `UrlBasedViewResolver`, which understands how
    to handle URLs with `redirect` and `forward` prefixes. So, in `doAddCourse` we
    save the data in the database, and if successful, we redirect the request to `courses`,
    which displays (after processing `courses.jsp`) the list of courses.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you want to test the application, browse to `http://localhost:8080/course_management/addCourse`.
    Enter the course name and credits and click Submit. This should take you to the
    courses page and display the list of courses.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that Spring MVC looks at the form field names and properties of the object
    in Model (in this case, `CourseDTO`) when mapping form values to the object. For
    example, the form field `name` is mapped to the `CourseDTO.name` property. So,
    make sure that the names of the form fields and the property names in the class
    (objects of which are added to the Model) are the same.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Using parameters in @RequestMapping
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use the `@RequestMapping` annotation to map the incoming
    request to a Controller method. So far, we have mapped static URL patterns in
    `@RequestMapping`. However, it is possible to map parameterized URLs (like those
    used in REST; see [https://spring.io/understanding/REST](https://spring.io/understanding/REST))
    using `@RequestMapping`. The parameters are specified inside `{}`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the feature to update an existing course. Here, we will only discuss
    how to code the Controller method for this feature. The complete code is available
    when you download the samples for this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following method in `CourseController`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we map the `updateCourse` method to handle requests with the following
    URL pattern: `/course/update/{id}`, where `{id}` could be replaced with the ID
    (number) of any existing course, or for that matter, any integer. To access the
    value of this parameter, we used the `@PathVariable` annotation in the arguments.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring interceptors
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring interceptors can be used to process any request before it reaches the
    controller. These could be used, for example, to implement security features (authentication
    and authorization). Like request mappers, interceptors can also be declared for
    specific URL patterns. Let's add the login page to our application, which should
    be displayed before any other page in the application if the user has not already
    logged in.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create `UserDTO` in the `packt.jee.course_management.dto` package.
    This class contains the username, password, and any message to be displayed on
    the login page, for example, authentication errors:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s create the `UserController` that will process the login request.
    Once the user is logged in successfully, we would like to keep this information
    in the session.  The presence of this object in the session can be used to check
    whether the user is already logged in. Create the `UserController` class in the `packt.jee.course_management.controller`
    package:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add a handler method for the `GET` request for the login page:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we have specified the method attribute in the `@RequestMapping` annotation.
    When the request URL is `/login` and the HTTP request type is `GET`, only then
    will the `login` method be called. This method would not be called if a `POST`
    request is sent from the client. In the `login` method, we create an instance
    of `UserDTO` and add it to the Model so that it is accessible to the View.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a method to handle `POST` requests from the login page. We will
    keep the same URL, that is, `/login`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We now have two methods in `UserController` handling the request URL `/login`.
    However, the login method handles `GET` requests and `doLogin` handles `POST`
    requests. If authentication is successful in the `doLogin` method, then we redirect
    to the courses (list) page. Else, we set the error message and return to the login
    page.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s save the user object created in the login method in the HTTP session.
    This can be done with the simple `@SessionAttributes` annotation. You can specify
    the list of attributes in Model that need to be saved in the session too. Furthermore,
    we want to save the `user` attribute of Model in the session. Therefore, we will
    add the following annotation to the `UserController` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s create the login page. Create `login.jsp` in the `views` folder
    and add the following code in the HTML `<body>`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The page expects `user` (instance of `UserDTO`) to be available. It is made
    available by `UserController` through Model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the login page and `UserController` to handle the authentication,
    but how do we make sure this page is displayed for every request when the user
    is not logged in? This is where we can use Spring interceptors. We will configure
    an interceptor in the Spring context configuration file: `servlet-context.xml`.
    Add the following code to `servlet-context.xml`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this configuration, we are telling Spring to call `LoginInterceptor` before
    executing any request (indicated by `mapping path = "/**"`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement `LoginInterceptor`. Interceptors must implement `HandlerInterceptor`.
    We will make `LoginInterceptor` extend `HandlerInterceptorAdapter`, which implements
    `HandlerInterceptor`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `LoginInterceptor` in the `packt.jee.course_management.interceptor`
    package:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `preHandle` method of the interceptor is called before Spring executes any
    request. If we return `true` from the method, then the request is handled further;
    else, it is aborted. In `preHandle`, we first check whether the `user` object
    is present in the session. The presence of the `user` object means that the user
    is already logged in. In such a case, we don't do anything more in this interceptor
    and return `true`. If the user is not logged in, then we redirect to the login
    page and return `false` so that Spring does not process this request further.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Browse to `http://localhost:8080/course_management/courses` to test the login
    page. If you are not already logged in, the login page should be displayed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Spring MVC application using JPA
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to create a web application using Spring
    and JDBC. In this section, we will take a quick look at how to use Spring with
    **JPA** (**Java Persistence API**). We have already learned how to use JPA in
    [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*, and in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, so we won't go into detail of how to set
    up the Eclipse project for JPA. However, we will discuss how to use JPA along
    with Spring in detail in this section.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We will create a separate project for this example. Create a Spring MVC project
    as described in the *Creating Spring project* section of this chapter. On the
    second page of the project wizard, where you are asked to enter a top-level package
    name, enter `packt.jee.course_management_jpa`. Recall that the last part of this
    package name is also used as the web application context.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JPA
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the EclipseLink JPA provider and the MySQL database driver
    in this project. So, add the Maven dependencies for them in the `pom.xml` file
    of the project:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will now configure the project for JPA. Right-click on the project and select
    Configure | Convert to JPA Project. This opens the Project Facets page, with JPA
    selected as one of the facets:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Project facets'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the Next button to configure the JPA facet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: JPA facet'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Select the EclipseLink platform in the preceding page. We will also disable
    the library configuration (select from the dropdown for the Type field). Configure
    the MySQL Connection (named CourseMgmtDBConnection), as described in the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. `Persistence.xml` is created under the JPA Content group in Project
    Explorer (the actual location of this file is `src/main/resources/META-INF/persistence.xml`).
    We will configure properties for the MySQL JDBC connection in this. Open the file
    and click the Connection tab:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Configure connection in persistence.xml'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Select Transaction type as `Resource Local`. Then, enter the JDBC driver details.
    Save the file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Course entity
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `Course` entity. Right-click on the project and select
    the JPA Tools | Generate Tables from Entities menu:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Generate course entity'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that `CourseMgmtDBConnection` is selected (refer to the *Configuring
    JPA* section of [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*, for configuring a MySQL database connection
    in Eclipse) and that List generated classes in persistence.xml is selected. Click
    Next on this and the next page. On the Customize Defaults page, select identity as
    the Key generator and set the package name as `packt.jee.course_management_jpa.entity`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.9: Customize JPA entity defaults'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Next. Verify the entity class name and the other details:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.10: Customize JPA entity details'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Finish. The `Course` entity class will be created in the package selected:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that the wizard has also created the named query to get all the courses
    from the table.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: We now need to create `EntityManagerFactory` so that `EntityManager` can be
    created from it (refer to the *JPA concepts* section in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Database Applications*). We will create a Spring bean/component
    to create and store `EntityManagerFactory`. Furthermore, we will inject (autowire)
    this component into the DAO class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `JPAEntityFactoryBean` class in the `packt.jee.course_management_jpa.entity`
    package:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the constructor of the class, we create `EntityManagerFactory`. The argument
    to `createEntityManagerFactory` is the name of the persistence unit, as specified
    in `persistence.xml`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Creating CourseDAO and Controller
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now create the `CourseDAO` class. We will have an instance of `JPAEntityFactoryBean`
    injected (auto-wired) into this class. Create the `packt.jee.course_management_jpa.dao`
    package and the `CourseDAO` class in it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the `getCourses` method, we first create `EntityManager` (from `JPAEntityFactoryBean`)
    and execute the named query. Once we get the results, we close `EntityManager`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Controller` class for `Course` will have `CourseDAO` auto-injected (auto-wired).
    Create `CourseController` in the `packt.jee.course_management_jpa.controller`
    package:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we saw in the `CourseController` created for the JDBC application earlier,
    we get courses from the database and add the list of courses to the Model under
    the key name `courses`. This variable will be available to the View page that
    displays the list of courses.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Creating the course list view
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have all the classes to get courses. Let''s now create a JSP to display
    the list of courses. Create `courses.jsp` in the `src/main/webapp/WEB-INF/views`
    folder. Add the following content in the HTML `body` tag of the page:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The View page makes use of JSTL tags to iterate over courses (using the variable
    that was made available in the Model by the Controller) and displays them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to build the entire application here. The idea was to understand
    how to use JPA with Spring MVC, which we have learned in this section. Browse
    to `http://localhost:8080/course_management_jpa/courses` to run the application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Spring MVC to create web applications.
    As the name indicates, Spring MVC implements the MVC design pattern, which enables
    clear separation of the user interface code and the business logic code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Using the dependency injection feature of the Spring Framework, we can easily
    manage the dependencies of different objects in the application. We also learned
    how to use JDBC and JPA along with Spring MVC to create data-driven web applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create and consume web services in JEE
    applications. We will look at both SOAP-based and RESTful web services.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
