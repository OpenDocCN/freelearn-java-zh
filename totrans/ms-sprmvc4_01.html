<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Setting Up a Spring Web Application in No Time"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Setting Up a Spring Web Application in No Time</h1></div></div></div><p>In this chapter, we will get straight to the code and set up a web application, which we will be working on for the rest of this book.</p><p>We will leverage Spring Boot's autoconfiguration capabilities to build an application with zero boilerplate or configuration files.</p><p>I will lay out the big picture regarding how Spring Boot works and how to configure it. There are four ways to get started with Spring:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using Spring Tool Suite to generate the starter code</li><li class="listitem" style="list-style-type: disc">Using IntelliJ IDEA 14.1, which now has good support for Spring Boot</li><li class="listitem" style="list-style-type: disc">Using Spring's<a id="id0" class="indexterm"/> website, <a class="ulink" href="http://start.Spring.io">http://start.Spring.io</a>, to download a configurable zip file</li><li class="listitem" style="list-style-type: disc">Using the curl command line to <a class="ulink" href="http://start.Spring.io">http://start.Spring.io</a> and achieving the same result</li></ul></div><p>We will use Gradle and Java 8 throughout this book, but don't be scared. Even if you are still working with Maven and a previous version of Java, I bet you will find these technologies easy to work with.</p><p>Many official Spring tutorials have both a Gradle build and a Maven build, so you will find examples easily if you decide to stick with Maven. Spring 4 is fully compatible with Java 8, so it would be a shame not to take advantage of lambdas to simplify our code base.</p><p>I will also show you some Git commands. I think it's a good idea to keep track of your progress and commit when you are in a stable state. It will also make it easier to compare your work with the source code provided with this book.</p><p>As we will deploy our application with Heroku in <a class="link" href="ch09.html" title="Chapter 9. Deploying Your Web Application to the Cloud">Chapter 9</a>, <span class="emphasis"><em>Deploying Your Web Application to the Cloud</em></span>, I recommend that you start versioning your code with Git from the very beginning. I will give you some advice on how to get started with Git later in this chapter.</p><div class="section" title="Getting started with Spring Tool Suite"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Getting started with Spring Tool Suite</h1></div></div></div><p>One of the best ways to get started with Spring and discover the numerous tutorials and starter projects that the Spring community offers is to download <span class="strong"><strong>Spring Tool Suite</strong></span> (<span class="strong"><strong>STS</strong></span>). STS is <a id="id1" class="indexterm"/>a custom version of eclipse designed to work with various Spring projects, as well as Groovy and Gradle. Even if, like me, you have another IDE that you would rather work with, I strongly recommend that you give STS a shot because it gives you the opportunity to explore Spring's vast ecosystem in a matter of minutes with the "Getting Started" projects.</p><p>So, let's visit <a class="ulink" href="https://Spring.io/tools/sts/all">https://Spring.io/tools/sts/all</a> and download the latest release of STS. Before we <a id="id2" class="indexterm"/>generate our first Spring Boot project we will need to install the Gradle support for STS. You can find a <span class="strong"><strong>Manage IDE Extensions</strong></span> button<a id="id3" class="indexterm"/> on the dashboard. You will then need to download the <span class="strong"><strong>Gradle Support</strong></span> software in the <span class="strong"><strong>Language and framework tooling</strong></span> section.</p><p>I also recommend installing the <span class="strong"><strong>Groovy Eclipse</strong></span> plugin along with the <span class="strong"><strong>Groovy 2.4 compiler</strong></span>, as<a id="id4" class="indexterm"/> shown in the following screenshot. These will be needed later in this book when we set up acceptance tests with geb:</p><div class="mediaobject"><img src="graphics/2117_01_01.jpg" alt="Getting started with Spring Tool Suite"/></div><p>We now <a id="id5" class="indexterm"/>have two main options to get started.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p><p>You can also download the example code for this book at <a class="ulink" href="https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4">https://github.com/Mastering-Spring-MVC-4/mastering-spring-mvc4</a>.</p></div></div><p>The first option<a id="id6" class="indexterm"/> is to navigate to<span class="strong"><strong> File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Spring Starter Project</strong></span>, as shown in the following screenshot. This will give you the same options as <a class="ulink" href="http://start.Spring.io">http://start.Spring.io</a>, embedded in your IDE:</p><div class="mediaobject"><img src="graphics/2117_01_02.jpg" alt="Getting started with Spring Tool Suite"/></div><p>You also have access to all <a id="id7" class="indexterm"/>the tutorials available on <a class="ulink" href="http://spring.io">http://spring.io</a>, selecting in <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Import Getting Started Content</strong></span> in the top bar. You will have the choice of working with either Gradle or Maven, as shown in the following screenshot:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>You can also check out the starter code to follow along with the tutorial, or get the complete code directly.</p></div></div><div class="mediaobject"><img src="graphics/2117_01_03.jpg" alt="Getting started with Spring Tool Suite"/></div><p>There is a lot of very interesting content available in the <span class="strong"><strong>Getting Started Content</strong></span> and I encourage you to explore it on your own. It will demonstrate the integration of Spring with various <a id="id8" class="indexterm"/>technologies that you might be interested in.</p><p>For the moment, we will generate a web project as shown in the preceding image. It will be a Gradle application, producing a JAR file and using Java 8.</p><p>Here is the configuration we want to use:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Name</p>
</td><td style="text-align: left" valign="top">
<p>masterSpringMvc</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Type</p>
</td><td style="text-align: left" valign="top">
<p>Gradle project</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Packaging</p>
</td><td style="text-align: left" valign="top">
<p>Jar</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Java version</p>
</td><td style="text-align: left" valign="top">
<p>1.8</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Language</p>
</td><td style="text-align: left" valign="top">
<p>Java</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Group</p>
</td><td style="text-align: left" valign="top">
<p>masterSpringMvc</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Artifact</p>
</td><td style="text-align: left" valign="top">
<p>masterSpringMvc</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Version</p>
</td><td style="text-align: left" valign="top">
<p>0.0.1-SNAPSHOT</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Description</p>
</td><td style="text-align: left" valign="top">
<p>Be creative!</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Package</p>
</td><td style="text-align: left" valign="top">
<p>masterSpringMvc</p>
</td></tr></tbody></table></div><p>On the second screen you will be asked for the Spring Boot version you want to use and the the dependencies that should be added to the project.</p><p>At the time of writing this, the latest version of Spring boot was 1.2.5. Ensure that you always check out the latest release.</p><p>The latest snapshot version of Spring boot will also be available by the time you read this. If Spring boot 1.3 isn't released by then, you can probably give it a shot. One of its big features is the awesome devs tools. Refer to <a class="ulink" href="https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3">https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3</a> for more details.</p><p>At the bottom the configuration window you will see a number of checkboxes representing the various boot starter libraries. These are dependencies that can be appended to your build file. They provide autoconfigurations for various Spring projects.</p><p>We are only interested in Spring MVC for the moment, so we will check only the Web checkbox.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>A JAR for a web application? Some of you might find it odd to package your web application as a JAR file. While it is still possible to use WAR files for packaging, it is not always the recommended practice. By default, Spring boot will create a fat JAR, which will include all the application's dependencies and provide a convenient way to start a web server using Java -jar.</p><p>Our application <a id="id9" class="indexterm"/>will be packaged as a JAR file. If you want to create a war file, refer to <a class="ulink" href="http://spring.io/guides/gs/convert-jar-to-war/">http://spring.io/guides/gs/convert-jar-to-war/</a>.</p></div></div><p>Have you<a id="id10" class="indexterm"/> clicked on <span class="strong"><strong>Finish</strong></span> yet? If you have, you should get the following project structure:</p><div class="mediaobject"><img src="graphics/2117_01_04.jpg" alt="Getting started with Spring Tool Suite"/></div><p>We can see our main class <span class="strong"><strong>MasterSpringMvcApplication</strong></span> and its test suite <span class="strong"><strong>MasterSpringMvcApplicationTests</strong></span>. There are also two empty folders, <span class="strong"><strong>static</strong></span> and <span class="strong"><strong>templates</strong></span>, where we will put our static web assets (images, styles, and so on) and obviously our templates (jsp, freemarker, Thymeleaf). The last file is an empty <span class="strong"><strong>application.properties</strong></span> file, which is the default Spring boot configuration file. It's a very handy file and we'll see how Spring boot uses it throughout this chapter.</p><p>The <code class="literal">build.gradle</code> file, the build file that we will detail in a moment.</p><p>If you feel ready to go, run the main method of the application. This will launch a web server for us.</p><p>To do this, go to the main method of the application and navigate to <span class="strong"><strong>Run as</strong></span> | <span class="strong"><strong>Spring Application</strong></span> in the toolbar either by right-clicking on the class or clicking on the green play button in the toolbar.</p><p>Doing so <a id="id11" class="indexterm"/>and navigating to <code class="literal">http://localhost:8080</code> will produce an error. Don't worry, and read on.</p><p>I will show you how to generate the same project without STS, and we will come back to all these files.</p></div></div>
<div class="section" title="Getting started with IntelliJ"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Getting started with IntelliJ</h1></div></div></div><p>IntelliJ IDEA is a very popular tool among Java developers. For the past few years I've been very pleased to pay Jetbrains <a id="id12" class="indexterm"/>a yearly fee for this awesome editor.</p><p>IntelliJ also has a way of creating Spring boot projects very quickly.</p><p>Go to the<a id="id13" class="indexterm"/> new project menu and select the <span class="strong"><strong>Spring Initializr</strong></span> project type:</p><div class="mediaobject"><img src="graphics/2117_01_05.jpg" alt="Getting started with IntelliJ"/></div><p>This will give us exactly the same options as STS, so refer to the previous chapter for the detailed configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>You will need to import the Gradle project into IntelliJ. I recommend generating the Gradle wrapper first (refer to the following <span class="strong"><strong>Gradle build</strong></span> section).</p><p>If needed, you<a id="id14" class="indexterm"/> can reimport the project by opening its <code class="literal">build.gradle</code> file again.</p></div></div></div>
<div class="section" title="Getting started with start.Spring.io"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Getting started with start.Spring.io</h1></div></div></div><p>Go to <a class="ulink" href="http://start.Spring.io">http://start.Spring.io</a> to<a id="id15" class="indexterm"/> get started with start.Spring.io. The <a id="id16" class="indexterm"/>system behind this remarkable Bootstrap-like website should be familiar to you! You will see the following screenshot when you go to the previously mentioned link:</p><div class="mediaobject"><img src="graphics/2117_01_06.jpg" alt="Getting started with start.Spring.io"/></div><p>Indeed, the same<a id="id17" class="indexterm"/> options available with STS can be found here. Clicking on <span class="strong"><strong>Generate Project</strong></span> will download a ZIP file containing our starter project.</p><div class="section" title="Getting started with the command line"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting started with the command line</h2></div></div></div><p>For those of you who are<a id="id18" class="indexterm"/> addicted to the console, it is possible to curl <a class="ulink" href="http://start.Spring.io">http://start.Spring.io</a>. Doing so will display instructions on how to structure your curl request.</p><p>For instance, to generate the same project as earlier, you can issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl http://start.Spring.io/starter.tgz \</strong></span>
<span class="strong"><strong>-d name=masterSpringMvc  \</strong></span>
<span class="strong"><strong>-d dependencies=web \</strong></span>
<span class="strong"><strong>-d language=java \</strong></span>
<span class="strong"><strong>-d JavaVersion=1.8 \</strong></span>
<span class="strong"><strong>-d type=gradle-project \</strong></span>
<span class="strong"><strong>-d packageName=masterSpringMvc \</strong></span>
<span class="strong"><strong>-d packaging=jar \</strong></span>
<span class="strong"><strong>-d baseDir=app | tar -xzvf -</strong></span>
<span class="strong"><strong>% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</strong></span>
<span class="strong"><strong>Dload  Upload   Total   Spent    Left  Speed</strong></span>
<span class="strong"><strong>100  1255  100  1119  100   136   1014    123  0:00:01  0:00:01 --:--:--  1015</strong></span>
<span class="strong"><strong>x app/</strong></span>
<span class="strong"><strong>x app/src/</strong></span>
<span class="strong"><strong>x app/src/main/</strong></span>
<span class="strong"><strong>x app/src/main/Java/</strong></span>
<span class="strong"><strong>x app/src/main/Java/com/</strong></span>
<span class="strong"><strong>x app/src/main/Java/com/geowarin/</strong></span>
<span class="strong"><strong>x app/src/main/resources/</strong></span>
<span class="strong"><strong>x app/src/main/resources/static/</strong></span>
<span class="strong"><strong>x app/src/main/resources/templates/</strong></span>
<span class="strong"><strong>x app/src/test/</strong></span>
<span class="strong"><strong>x app/src/test/Java/</strong></span>
<span class="strong"><strong>x app/src/test/Java/com/</strong></span>
<span class="strong"><strong>x app/src/test/Java/com/geowarin/</strong></span>
<span class="strong"><strong>x app/build.Gradle</strong></span>
<span class="strong"><strong>x app/src/main/Java/com/geowarin/AppApplication.Java</strong></span>
<span class="strong"><strong>x app/src/main/resources/application.properties</strong></span>
<span class="strong"><strong>x app/src/test/Java/com/geowarin/AppApplicationTests.Java</strong></span>
</pre></div><p>And viola! You are now ready to get started with Spring without leaving the console, a dream come<a id="id19" class="indexterm"/> true.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>You might consider creating an alias with the previous command, it will help you prototype the Spring application very quickly.</p></div></div></div></div>
<div class="section" title="Let's get started"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Let's get started</h1></div></div></div><p>Now that our web application is ready, let's take a look at how it is written. Before going further, we can <a id="id20" class="indexterm"/>save our work with Git.</p><p>If you don't know <a id="id21" class="indexterm"/>anything <a id="id22" class="indexterm"/>about Git, I recommend the two following tutorials:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://try.github.io">https://try.github.io</a>, which is a good step-by-step interactive tutorial to learn the basic Git commands</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://pcottle.github.io/learnGitBranching">http://pcottle.github.io/learnGitBranching</a>, which is an excellent interactive visualization of the Git tree-like structure that will show you basic, as well as very advanced, Git capabilities</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<span class="strong"><strong>Installing Git</strong></span>
</p><p>On<a id="id23" class="indexterm"/> windows, install Git bash, which can be found at <a class="ulink" href="https://msysgit.github.io">https://msysgit.github.io</a>. On Mac, if you use homebrew you should already have Git. Otherwise, use the command <code class="literal">brew install git</code>. When in doubt, check out the documentation at <a class="ulink" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>.</p></div></div><p>To version our work with Git, type the following commands in a console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd app</strong></span>
<span class="strong"><strong>$ git init</strong></span>
</pre></div><p>With IntelliJ, ignore the generated files: <code class="literal">.idea</code> and <code class="literal">*.iml</code>. With eclipse you should commit the <code class="literal">.classpath</code> and <code class="literal">.settings</code> folder. In any case you should ignore the <code class="literal">.gradle</code> folder and the <code class="literal">build</code> folder.</p><p>Create a <code class="literal">.gitignore</code> file containing the following text:</p><div class="informalexample"><pre class="programlisting"># IntelliJ project files
.idea
*.iml

# gradle
.gradle
build</pre></div><p>Now, we<a id="id24" class="indexterm"/> can<a id="id25" class="indexterm"/> add all the other files to<a id="id26" class="indexterm"/> Git:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add .</strong></span>
<span class="strong"><strong>$ git commit -m "Generated with curl start.Spring.io"</strong></span>
<span class="strong"><strong>[master (root-commit) eded363] Generated with curl start.Spring.io</strong></span>
<span class="strong"><strong>4 files changed, 75 insertions(+)</strong></span>
<span class="strong"><strong>create mode 100644 build.Gradle</strong></span>
<span class="strong"><strong>create mode 100644 src/main/Java/com/geowarin/AppApplication.Java</strong></span>
<span class="strong"><strong>create mode 100644 src/main/resources/application.properties</strong></span>
<span class="strong"><strong>create mode 100644 src/test/Java/com/geowarin/AppApplicationTests.Java</strong></span>
</pre></div><div class="section" title="The Gradle build"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The Gradle build</h2></div></div></div><p>If you are unfamiliar with Gradle, think of it as Maven's successor, a modern build tool. Like Maven, it uses <a id="id27" class="indexterm"/>conventions such as how to structure a Java application. Our sources will still be found in <code class="literal">src/main/java</code>, our webapp in <code class="literal">src/main/webapp</code>, and so on. Not unlike Maven, you can use Gradle plugins to deal with various<a id="id28" class="indexterm"/> build tasks. However, Gradle really shines because it allows you to write your own build tasks using the Groovy DSL. The default library makes it easy to manipulate files, declare dependencies between tasks, and execute jobs incrementally.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>
<span class="strong"><strong>Installing Gradle</strong></span>
</p><p>If you're on OS X, you can install Gradle with brew by using <code class="literal">brew install gradle</code> command. On any *NIX system (Mac included), you can install it with gvm (<a class="ulink" href="http://gvmtool.net/">http://gvmtool.net/</a>). Alternatively, you can grab the binary distribution at <a class="ulink" href="https://Gradle.org/downloads">https://Gradle.org/downloads</a>.</p></div></div><p>The first good <a id="id29" class="indexterm"/>practice when creating an application with Gradle is to generate a Gradle wrapper. The Gradle wrapper is a small script that you will share along with your code to ensure that the build will use the same version of Gradle that you used to build the application.</p><p>The command to generate the wrapper is <code class="literal">Gradle wrapper</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle wrapper</strong></span>
<span class="strong"><strong>:wrapper</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 6.699 secs</strong></span>
</pre></div><p>If we look at the new files created, we can see two scripts and two directories:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git status -s</strong></span>
<span class="strong"><strong>?? .gradle/</strong></span>
<span class="strong"><strong>?? gradle/</strong></span>
<span class="strong"><strong>?? gradlew</strong></span>
<span class="strong"><strong>?? gradlew.bat</strong></span>
</pre></div><p>The <code class="literal">.gradle</code> directory<a id="id30" class="indexterm"/> contains the Gradle binaries; you wouldn't want to <a id="id31" class="indexterm"/>commit those to your version control.</p><p>We previously ignored this file along with the build directory so that you could safely <code class="literal">git add</code> everything else:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git add .</strong></span>
<span class="strong"><strong>$ git commit -m "Added Gradle wrapper"</strong></span>
</pre></div><p>The <code class="literal">Gradle</code> directory contains information on how to get the binaries. The two other files are scripts: a batch script for windows (<code class="literal">Gradlew.bat</code>) and a shell script for other systems.</p><p>We can also run our application with Gradle instead of executing the application from the IDE:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./gradlew bootrun</strong></span>
</pre></div><p>Issuing this command will run an embedded tomcat server with our application in it!</p><p>The log tells us that the server is running on port 8080. Let's check it out:</p><div class="mediaobject"><img src="graphics/2117_01_07.jpg" alt="The Gradle build"/></div><p>I can imagine your disappointment. Our application is not ready for the grand public just yet.</p><p>That being said, the work <a id="id32" class="indexterm"/>accomplished by the two files our project is made <a id="id33" class="indexterm"/>of is rather impressive. Let's review them.</p><p>The first one is the Gradle build file, <code class="literal">build.Gradle</code>:</p><div class="informalexample"><pre class="programlisting">buildscript {
    ext {
        springBootVersion = '1.2.5.RELEASE'
    }
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}") 
        classpath("io.spring.gradle:dependency-management-plugin:0.5.1.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'spring-boot' 
apply plugin: 'io.spring.dependency-management' 

jar {
    baseName = 'masterSpringMvc'
    version = '0.0.1-SNAPSHOT'
}
sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}


dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
    testCompile("org.springframework.boot:spring-boot-starter-test") 
}


eclipse {
    classpath {
         containers.remove('org.eclipse.jdt.launching.JRE_CONTAINER')
         containers 'org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8'
    }
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.3'
}</pre></div><p>What do we see here?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A dependency <a id="id34" class="indexterm"/>on the Spring Boot plugin distributed on Maven central.</li><li class="listitem" style="list-style-type: disc">Our project is a Java project. IDE project files can be generated by Gradle for IntelliJ or Eclipse.</li><li class="listitem" style="list-style-type: disc">The application will generate a JAR file.</li><li class="listitem" style="list-style-type: disc">Our project dependencies are hosted on maven central.</li><li class="listitem" style="list-style-type: disc">Our classpath includes <code class="literal">spring-boot-starter-web</code> in production and <code class="literal">spring-boot-starter-test</code> for testing.</li><li class="listitem" style="list-style-type: disc">Some additional configuration for eclipse.</li><li class="listitem" style="list-style-type: disc">The version of the Gradle wrapper is 2.3.</li></ul></div><p>The Spring Boot Plugin will generate a fat jar that contains all the dependencies of the project. To build it, type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>./gradlew build</strong></span>
</pre></div><p>You will find the <a id="id35" class="indexterm"/>JAR in the directory <code class="literal">build/libs</code>. This directory will contain two files, the fat jar called <code class="literal">masterSpringMvc-0.0.1-SNAPSHOT.jar</code> and the classic JAR file that does not include any dependencies, <code class="literal">masterSpringMvc-0.0.1-SNAPSHOT.jar.original</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>Runnable jar</strong></span>
</p><p>One of the main advantages of Spring Boot is embedding everything the application needs in one easily redistributable JAR file, including the web server. If you run <code class="literal">java jar masterSpringMvc-0.0.1-SNAPSHOT.jar</code>, tomcat will start on port 8080, just like it did when you developed it. This is extremely handy for deploying in production or in the cloud.</p></div></div><p>Our main <a id="id36" class="indexterm"/>dependency here is <code class="literal">spring-boot-starter-web</code>. Spring Boot provides a good number of starters that will automatically configure some aspects of the application for us by providing typical dependencies and Spring configuration.</p><p>For instance, <code class="literal">spring-starter-web</code> will include dependencies of <code class="literal">tomcat-embedded</code> and Spring MVC. It will also run the most commonly used Spring MVC configuration and provide a dispatcher listening on the "<code class="literal">/</code>" root path, error handling such as the 404 page we saw earlier, and a classical view resolver configuration.</p><p>We'll see more on this later. First, let's take a look at the next section.</p></div><div class="section" title="Let me see the code!"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Let me see the code!</h2></div></div></div><p>Here is all the code that is needed to run the application. Everything is in a classic main function, which is a huge advantage because you can run your application in your IDE like you would for any other program. You can debug it and also benefit from some class reloading out<a id="id37" class="indexterm"/> of the box without a plugin.</p><p>This reloading will be available in the debug mode when saving your file in eclipse, or clicking on <span class="strong"><strong>Make Project</strong></span> in IntelliJ. This will be possible only if the JVM is able to switch the new compile version of the class file with the new one; modifying the static variable or touching configuration files will force you to reload the application.</p><p>Our main class looks as follows:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc;

import org.Springframework.boot.SpringApplication;
import org.Springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AppApplication {

    public static void main(String[] args) {
        SpringApplication.run(AppApplication.class, args);
    }
}</pre></div><p>Note the <code class="literal">@SpringBootApplication</code> annotation. If you look at the code of this annotation you will see that it actually combines three other annotations: <code class="literal">@Configuration</code>, <code class="literal">@EnableAutoConfiguration</code>, and <code class="literal">@ComponentScan</code>:</p><div class="informalexample"><pre class="programlisting">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Configuration
@EnableAutoConfiguration
@ComponentScan
public @interface SpringBootApplication {

  /**
  * Exclude specific auto-configuration classes such that they will never be applied.
  */
  Class&lt;?&gt;[] exclude() default {};
}</pre></div><p>The <code class="literal">@Configuration</code> class should be familiar to you if you've already configured a Spring application <a id="id38" class="indexterm"/>with Java code earlier. It indicates that our class will handle classical aspects of a Spring configuration: declaring beans, for instance.</p><p>The <code class="literal">@ComponentScan</code> class is also a classic. It will tell Spring where to look to find our Spring components (services, controllers, and so on). By default, this annotation will scan every current package and everything under it.</p><p>The novelty here is <code class="literal">@EnableAutoConfiguration</code>, which will instruct Spring Boot to do its magic. If you remove it, you will no longer benefit from Spring Boot's autoconfiguration.</p><p>The first step when writing an MVC application with Spring Boot is usually to add a controller to our code. Add the controller in the controller subpackage so that it is picked up by the <code class="literal">@ComponentScan</code> annotation:</p><div class="informalexample"><pre class="programlisting">package masterSpringMvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HelloController {

    @RequestMapping("/")
    @ResponseBody
    public String hello() {
        return "Hello, world!";
    }
}</pre></div><p>This time, if<a id="id39" class="indexterm"/> you open your browser and visit <code class="literal">http://localhost:8080</code> you will see this lovely <span class="strong"><strong>Hello, world!</strong></span> output:</p><div class="mediaobject"><img src="graphics/2117_01_08.jpg" alt="Let me see the code!"/></div></div></div>
<div class="section" title="Spring Boot behind the curtains"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Spring Boot behind the curtains</h1></div></div></div><p>If you <a id="id40" class="indexterm"/>already set up a Spring MVC application earlier, you may be used to writing at least a small portion of XML or a handful of Java annotation configuration classes.</p><p>Initialization steps<a id="id41" class="indexterm"/> are typically as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Initializing the DispatcherServlet of Spring MVC.</li><li class="listitem">Setting up an encoding filter to ensure that client requests are encoded correctly.</li><li class="listitem">Setting up a view resolver to tell Spring where to find our views and in which dialect they are written (jsp, Thymeleaf templates, and so on).</li><li class="listitem">Configuring static resources locations (css, js).</li><li class="listitem">Configuring supported locales and resource bundles.</li><li class="listitem">Configuring a multipart resolver for file uploads to work.</li><li class="listitem">Including tomcat or jetty to run our application on a web server.</li><li class="listitem">Setting up the error pages (For example 404).</li></ol></div><p>However, Spring Boot handles all that work for us. Because this configuration is typically up to your application, you can come up with an unlimited amount of combinations.</p><p>Spring boot, in a way, is an opinionated Spring project configurator. It is based on conventions and will enforce them on your project by default.</p><div class="section" title="The dispatcher and multipart configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>The dispatcher and multipart configuration</h2></div></div></div><p>Let's see <a id="id42" class="indexterm"/>what happens behind the curtains.</p><p>We will use the default Spring Boot configuration file that was created for us and put it in the debug mode. Add the following line to <code class="literal">src/main/resources/application.properties</code>:</p><div class="informalexample"><pre class="programlisting">debug=true</pre></div><p>Now, if we launch our application again we'll see Spring Boot's autoconfiguration report. It is divided into two parts: <span class="strong"><strong>positive matches,</strong></span> which list all autoconfigurations that are used by our application; and <span class="strong"><strong>negative matches</strong></span>, which are Spring Boot autoconfigurations whose requirements weren't met when the application started:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>=========================</strong></span>
<span class="strong"><strong>AUTO-CONFIGURATION REPORT</strong></span>
<span class="strong"><strong>=========================</strong></span>


<span class="strong"><strong>Positive matches:</strong></span>
<span class="strong"><strong>-----------------</strong></span>

<span class="strong"><strong>  DispatcherServletAutoConfiguration</strong></span>
<span class="strong"><strong>      - @ConditionalOnClass classes found: org.Springframework.web.servlet.DispatcherServlet (OnClassCondition)</strong></span>
<span class="strong"><strong>      - found web application StandardServletEnvironment (OnWebApplicationCondition)</strong></span>

<span class="strong"><strong>  EmbeddedServletContainerAutoConfiguration</strong></span>
<span class="strong"><strong>      - found web application StandardServletEnvironment (OnWebApplicationCondition)</strong></span>

<span class="strong"><strong>  ErrorMvcAutoConfiguration</strong></span>
<span class="strong"><strong>      - @ConditionalOnClass classes found: javax.servlet.Servlet,org.springframework.web.servlet.DispatcherServlet (OnClassCondition)</strong></span>
<span class="strong"><strong>      - found web application StandardServletEnvironment (OnWebApplicationCondition)</strong></span>

<span class="strong"><strong>  HttpEncodingAutoConfiguration</strong></span>
<span class="strong"><strong>      - @ConditionalOnClass classes found: org.springframework.web.filter.CharacterEncodingFilter (OnClassCondition)</strong></span>
<span class="strong"><strong>      - matched (OnPropertyCondition)</strong></span>


<span class="strong"><strong>&lt;Input trimmed&gt;</strong></span>
</pre></div><p>Let's take a closer look at <code class="literal">DispatcherServletAutoConfiguration</code>:</p><div class="informalexample"><pre class="programlisting">/**
* {@link EnableAutoConfiguration Auto-configuration} for the Spring
* {@link DispatcherServlet}. Should work for a standalone application where an embedded
* servlet container is already present and also for a deployable application using
* {@link SpringBootServletInitializer}.
*
* @author Phillip Webb
* @author Dave Syer
*/
@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass(DispatcherServlet.class)
@AutoConfigureAfter(EmbeddedServletContainerAutoConfiguration.class)
public class DispatcherServletAutoConfiguration {

    /*
    * The bean name for a DispatcherServlet that will be mapped to the root URL "/"
    */
    public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = "dispatcherServlet";

    /*
    * The bean name for a ServletRegistrationBean for the DispatcherServlet "/"
    */
    public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = "dispatcherServletRegistration";

    @Configuration
    @Conditional(DefaultDispatcherServletCondition.class)
    @ConditionalOnClass(ServletRegistration.class)
    protected static class DispatcherServletConfiguration {

        @Autowired
        private ServerProperties server;

        @Autowired(required = false)
        private MultipartConfigElement multipartConfig;

        @Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
        public DispatcherServlet dispatcherServlet() {
            return new DispatcherServlet();
        }

        @Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
        public ServletRegistrationBean dispatcherServletRegistration() {
            ServletRegistrationBean registration = new ServletRegistrationBean(
                    dispatcherServlet(), this.server.getServletMapping());
            registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
            if (this.multipartConfig != null) {
                registration.setMultipartConfig(this.multipartConfig);
            }
            return registration;
        }

        @Bean
        @ConditionalOnBean(MultipartResolver.class)
        @ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
        public MultipartResolver multipartResolver(MultipartResolver resolver) {
            // Detect if the user has created a MultipartResolver but named it incorrectly
            return resolver;
        }

    }

    @Order(Ordered.LOWEST_PRECEDENCE - 10)
    private static class DefaultDispatcherServletCondition extends SpringBootCondition {

        @Override
        public ConditionOutcome getMatchOutcome(ConditionContext context,
                AnnotatedTypeMetadata metadata) {
            ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
            ConditionOutcome outcome = checkServlets(beanFactory);
            if (!outcome.isMatch()) {
                return outcome;
            }
            return checkServletRegistrations(beanFactory);
        }

    }
}</pre></div><p>This is a typical <a id="id43" class="indexterm"/>Spring Boot configuration class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is annotated with <code class="literal">@Configuration</code> like any other Spring configuration class.</li><li class="listitem" style="list-style-type: disc">It typically declares its priority level with the <code class="literal">@Order</code> annotation. You can see that <code class="literal">DispatcherServletAutoConfiguration</code> needs to be configured first.</li><li class="listitem" style="list-style-type: disc">It can also contain hints such as <code class="literal">@AutoConfigureAfter</code> or <code class="literal">@AutoConfigureBefore</code> to further refine the order in which configurations are processed.</li><li class="listitem" style="list-style-type: disc">It is enabled under certain conditions. With <code class="literal">@ConditionalOnClass(DispatcherServlet.class)</code>, this particular configuration ensures that our classpath contains <code class="literal">DispatcherServlet</code>, which is a good indication that Spring MVC is in the classpath and the user certainly wants to bootstrap it.</li></ul></div><p>This file also contains classic bean declarations for the Spring MVC dispatcher servlet and a multipart resolver. The whole Spring MVC configuration is broken into multiple files.</p><p>It is also worth noting that these beans obey certain rules to check whether are active. The <code class="literal">ServletRegistrationBean</code> function will be enabled under the <code class="literal">@Conditional(DefaultDispatcherServletCondition.class)</code> condition, which is a bit complex but checks whether you already have a dispatcher servlet registered in your own configuration.</p><p>The <code class="literal">MultipartResolver</code> function will become active only if the condition <code class="literal">@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)</code> is met, for example, if we didn't declare it ourselves.</p><p>This means Spring boot only gives you a hand in configuring your application according to common use cases. However, at any point, you can override these defaults and declare your own configuration.</p><p>So, the <code class="literal">DispatcherServletAutoConfiguration</code> class explains why we have a dispatcher servlet and a multipart resolver.</p></div><div class="section" title="The view resolver, static resources, and locale configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The view resolver, static resources, and locale configuration</h2></div></div></div><p>Another very relevant piece of configuration is <code class="literal">WebMvcAutoConfiguration</code>. It declares the <a id="id44" class="indexterm"/>view resolver, the locale resolver, and the location of our <a id="id45" class="indexterm"/>static<a id="id46" class="indexterm"/> resources. The <a id="id47" class="indexterm"/>view <a id="id48" class="indexterm"/>resolver is as<a id="id49" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">@Configuration
@Import(EnableWebMvcConfiguration.class)
@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
public static class WebMvcAutoConfigurationAdapter extends WebMvcConfigurerAdapter {

  @Value("${spring.view.prefix:}")
  private String prefix = "";

  @Value("${spring.view.suffix:}")
  private String suffix = "";

  @Bean
  @ConditionalOnMissingBean(InternalResourceViewResolver.class)
  public InternalResourceViewResolver defaultViewResolver() {
    InternalResourceViewResolver resolver = new InternalResourceViewResolver();
    resolver.setPrefix(this.prefix);
    resolver.setSuffix(this.suffix);
    return resolver;
  }
}</pre></div><p>The view resolver <a id="id50" class="indexterm"/>configuration is really typical. What's really interesting here is the use of configuration properties to allow users to customize it.</p><p>What it says is "I will look for two variables in the user's <code class="literal">application.properties</code> called <code class="literal">spring.view.prefix</code> and <code class="literal">spring.view.suffix</code>". This is a very handy way to set up the view resolver with only two lines in our configuration.</p><p>Keep this in mind for the next chapter. For now, we will just stroll through Spring Boot's code.</p><p>Regarding <a id="id51" class="indexterm"/>static resources, this configuration includes the following lines:</p><div class="informalexample"><pre class="programlisting">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
    "classpath:/META-INF/resources/", "classpath:/resources/",
    "classpath:/static/", "classpath:/public/" };

private static final String[] RESOURCE_LOCATIONS;
static {
  RESOURCE_LOCATIONS = new String[CLASSPATH_RESOURCE_LOCATIONS.length
      + SERVLET_RESOURCE_LOCATIONS.length];
  System.arraycopy(SERVLET_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS, 0,
      SERVLET_RESOURCE_LOCATIONS.length);
  System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, 0, RESOURCE_LOCATIONS,
      SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);
}

@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
  if (!this.resourceProperties.isAddMappings()) {
    logger.debug("Default resource handling disabled");
    return;
  }

  Integer cachePeriod = this.resourceProperties.getCachePeriod();
  if (!registry.hasMappingForPattern("/webjars/**")) {
    registry.addResourceHandler("/webjars/**")
        .addResourceLocations("classpath:/META-INF/resources/webjars/")
        .setCachePeriod(cachePeriod);
  }
  if (!registry.hasMappingForPattern("/**")) {
    registry.addResourceHandler("/**")
        .addResourceLocations(RESOURCE_LOCATIONS)
        .setCachePeriod(cachePeriod);
  }
}</pre></div><p>The <a id="id52" class="indexterm"/>declaration of resource locations is a bit convoluted but we<a id="id53" class="indexterm"/> can still understand two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any resource <a id="id54" class="indexterm"/>accessed with the "webjar" prefix will be resolved inside the classpath inside the classpath. This will allow us to use prepackaged <a id="id55" class="indexterm"/>JavaScript dependencies from<a id="id56" class="indexterm"/> Maven<a id="id57" class="indexterm"/> central.</li><li class="listitem" style="list-style-type: disc">Our static resources can reside in any of the locations after our classpath <code class="literal">/META-INF/resources/</code>, <code class="literal">/resources/</code>, <code class="literal">/static/</code>, or <code class="literal">/public/</code>.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>WebJars are JAR packages of client JavaScript libraries available on Maven central. They include a Maven project file, which allows for transitive dependencies and works in all JVM-based applications. WebJars are an alternative to JavaScript package managers such as bower or npm. They are great for applications that require just a few JavaScript libraries. Find the list of available WebJars on <a class="ulink" href="http://www.webjars.org">www.webjars.org</a>.</p></div></div><p>There<a id="id58" class="indexterm"/> is<a id="id59" class="indexterm"/> also a part of this file that is<a id="id60" class="indexterm"/> dedicated to locale management:</p><div class="informalexample"><pre class="programlisting">@Bean
@ConditionalOnMissingBean(LocaleResolver.class)
@ConditionalOnProperty(prefix = "spring.mvc", name = "locale")
public LocaleResolver localeResolver() {
  return new FixedLocaleResolver(
      StringUtils.parseLocaleString(this.mvcProperties.getLocale()));
}</pre></div><p>This <a id="id61" class="indexterm"/>default locale resolver handles only one locale and allows us<a id="id62" class="indexterm"/> to <a id="id63" class="indexterm"/>define it via the <code class="literal">spring.mvc.locale</code> configuration property.</p></div></div>
<div class="section" title="Error and encoding configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Error and encoding configuration</h1></div></div></div><p>Remember when we first launched our application without adding a controller? We got a funny <span class="strong"><strong>Whitelabel Error Page</strong></span> output.</p><p>Error handling<a id="id64" class="indexterm"/> is a lot trickier than it looks, especially when you don't have <a id="id65" class="indexterm"/>a <code class="literal">web.xml</code> configuration file and want your application to be portable across web servers. The good news is that Spring Boot takes care of that for us! Let's look at <code class="literal">ErrorMvcAutoConfiguration</code>:</p><div class="informalexample"><pre class="programlisting">ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@ConditionalOnWebApplication
// Ensure this loads before the main WebMvcAutoConfiguration so that the error View is
// available
@AutoConfigureBefore(WebMvcAutoConfiguration.class)
@Configuration
public class ErrorMvcAutoConfiguration implements EmbeddedServletContainerCustomizer,
        Ordered {

    @Value("${error.path:/error}")
    private String errorPath = "/error";

    @Autowired
    private ServerProperties properties;

    @Override
    public int getOrder() {
        return 0;
    }

    @Bean
    @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)
    public DefaultErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes();
    }

    @Bean
    @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)
    public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) {
        return new BasicErrorController(errorAttributes);
    }

    @Override
    public void customize(ConfigurableEmbeddedServletContainer container) {
        container.addErrorPages(new ErrorPage(this.properties.getServletPrefix()
                + this.errorPath));
    }

    @Configuration
    @ConditionalOnProperty(prefix = "error.whitelabel", name = "enabled", matchIfMissing = true)
    @Conditional(ErrorTemplateMissingCondition.class)
    protected static class WhitelabelErrorViewConfiguration {

        private final SpelView defaultErrorView = new SpelView(
                "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;"
                        + "&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;"
                        + "&lt;div id='created'&gt;${timestamp}&lt;/div&gt;"
                        + "&lt;div&gt;There was an unexpected error (type=${error}, status=${status}).&lt;/div&gt;"
                        + "&lt;div&gt;${message}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;");

        @Bean(name = "error")
        @ConditionalOnMissingBean(name = "error")
        public View defaultErrorView() {
            return this.defaultErrorView;
        }

        // If the user adds @EnableWebMvc then the bean name view resolver from
        // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.
        @Bean
        @ConditionalOnMissingBean(BeanNameViewResolver.class)
        public BeanNameViewResolver beanNameViewResolver() {
            BeanNameViewResolver resolver = new BeanNameViewResolver();
            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
            return resolver;
        }

    }
}</pre></div><p>What does<a id="id66" class="indexterm"/> this piece of configuration do?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It <a id="id67" class="indexterm"/>defines a bean, <code class="literal">DefaultErrorAttributes</code>, which exposes helpful error information via special attributes such as the status, error code, and associated stack trace.</li><li class="listitem" style="list-style-type: disc">It defines a <code class="literal">BasicErrorController</code> bean, which is an MVC controller in charge of displaying the error page we've seen.</li><li class="listitem" style="list-style-type: disc">It allows us to deactivate Spring Boot whitelabel error page by setting <code class="literal">error.whitelable.enabled</code> to false in our configuration file, <code class="literal">application.properties</code>.</li><li class="listitem" style="list-style-type: disc">We can also leverage our templating engine to provide our own error page. It will be named <code class="literal">error.html</code>, for example. This is what the condition <code class="literal">ErrorTemplateMissingCondition</code> checks.</li></ul></div><p>We'll see how to properly handle errors later in this book.</p><p>As far as encoding is concerned, the very simple <code class="literal">HttpEncodingAutoConfiguration</code> function will handle it by providing Spring's <code class="literal">CharacterEncodingFilter</code> class. It is possible <a id="id68" class="indexterm"/>to override the default encoding ("UTF-8") with <code class="literal">spring.http.encoding.charset</code> and<a id="id69" class="indexterm"/> disable this configuration with <code class="literal">spring.http.encoding.enabled</code>.</p></div>
<div class="section" title="Embedded Servlet container (Tomcat) configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Embedded Servlet container (Tomcat) configuration</h1></div></div></div><p>By default, Spring Boot runs and packages our application using the Tomcat <a id="id70" class="indexterm"/>embedded API.</p><p>Let's look at <code class="literal">EmbeddedServletContainerAutoConfiguration</code>:</p><div class="informalexample"><pre class="programlisting">@Order(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(EmbeddedServletContainerCustomizerBeanPostProcessorRegistrar.class)
public class EmbeddedServletContainerAutoConfiguration {

  /**
  * Nested configuration for if Tomcat is being used.
  */
  @Configuration
  @ConditionalOnClass({ Servlet.class, Tomcat.class })
  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
  public static class EmbeddedTomcat {

    @Bean
    public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {
      return new TomcatEmbeddedServletContainerFactory();
    }

  }

  /**
  * Nested configuration if Jetty is being used.
  */
  @Configuration
  @ConditionalOnClass({ Servlet.class, Server.class, Loader.class })
  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
  public static class EmbeddedJetty {

    @Bean
    public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {
      return new JettyEmbeddedServletContainerFactory();
    }

  }

  /**
  * Nested configuration if Undertow is being used.
  */
  @Configuration
  @ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
  @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
  public static class EmbeddedUndertow {

    @Bean
    public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {
      return new UndertowEmbeddedServletContainerFactory();
    }

  }
}</pre></div><p>The preceding<a id="id71" class="indexterm"/> code is pretty straight forward. This code includes three different configurations, which will be activated depending on what's available on your classpath.</p><p>You can use Tomcat, tc-server, Jetty, or Undertow with Spring Boot. Your server can be easily replaced by excluding the <code class="literal">spring-boot-starter-tomcat</code> JAR dependency and replacing it with its Jetty or Undertow equivalent. Please refer to the documentation if you wish to do so.</p><p>All the configuration of our Servlet container (Tomcat) will happen in <code class="literal">TomcatEmbeddedServletContainerFactory</code>. While you should definitely read it because it provides a very advanced configuration of tomcat embedded (for which finding documentation can be hard), we will not look at this class directly.</p><p>Instead, I will walk you through the different options available to configure your Servlet Container.</p><div class="section" title="The HTTP port"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The HTTP port</h2></div></div></div><p>You can <a id="id72" class="indexterm"/>change the default HTTP<a id="id73" class="indexterm"/> port by defining a <code class="literal">server.port</code> property in your <code class="literal">application.properties</code> file or by defining an environment variable called <code class="literal">SERVER_PORT</code>.</p><p>You can disable HTTP by setting this variable to <code class="literal">-1</code> or launch it on a random port by setting it to <code class="literal">0</code>. This is very handy for testing.</p></div><div class="section" title="The SSL configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>The SSL configuration</h2></div></div></div><p>Configuring SSL is <a id="id74" class="indexterm"/>such a chore, but <a id="id75" class="indexterm"/>spring boot has a simple solution. You need only a handful of properties to secure your server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>server.port = 8443</strong></span>
<span class="strong"><strong>server.ssl.key-store = classpath:keystore.jks</strong></span>
<span class="strong"><strong>server.ssl.key-store-password = secret</strong></span>
<span class="strong"><strong>server.ssl.key-password = another-secret</strong></span>
</pre></div><p>You will have to generate a keystore file for the above example to work, thought.</p><p>We'll have a deeper look at our security options in <a class="link" href="ch06.html" title="Chapter 6. Securing Your Application">Chapter 6</a>, <span class="emphasis"><em>Securing Your Application</em></span>. Of course, you can customize the <code class="literal">TomcatEmbeddedServletContainerFactory</code> function further by adding your own <code class="literal">EmbeddedServletContainerFactory</code>. This can come in handy if you wish <a id="id76" class="indexterm"/>to add multiple connectors, for instance. Refer to the documentation at <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-configure-ssl">http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-configure-ssl</a> for more information.</p></div><div class="section" title="Other configurations"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Other configurations</h2></div></div></div><p>You can add classic Java web elements such as <code class="literal">Servlet</code>, <code class="literal">Filter</code>, and <code class="literal">ServletContextListener</code> by simply declaring them as the <code class="literal">@Bean</code> elements in your configuration.</p><p>Out of the <a id="id77" class="indexterm"/>box, spring boot also added three other things for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSON serialization with Jackson in <code class="literal">JacksonAutoConfiguration</code></li><li class="listitem" style="list-style-type: disc">Default <code class="literal">HttpMessageConverters</code> in <code class="literal">`HttpMessageConvertersAutoConfiguration</code></li><li class="listitem" style="list-style-type: disc">JMX capabilities in <code class="literal">JmxAutoConfiguration</code></li></ul></div><p>We will see a bit more about the jackson configuration in <a class="link" href="ch05.html" title="Chapter 5. Crafting a RESTful Application">Chapter 5</a>, <span class="emphasis"><em>Crafting a RESTful Application</em></span>. About JMX configuration, you can try it out by connecting to your application with <code class="literal">jconsole</code> locally:</p><div class="mediaobject"><img src="graphics/2117_01_09.jpg" alt="Other configurations"/></div><p>You can <a id="id78" class="indexterm"/>add more interesting MBeans by adding <code class="literal">org.springframework.boot:spring-boot-starter-actuator</code> to your classpath. You can even define your own MBeans and expose them on HTTP using Jolokia. On the other hand, you can also disable those endpoints by adding <code class="literal">spring.jmx.enabled=false</code> to your configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Refer to <a class="ulink" href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-jmx.html">http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-jmx.html</a> for more details.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Summary</h1></div></div></div><p>We now have a very humble spring web application with a RESTful JSON "Hello world" despite having configured nothing ourselves. We have seen what spring boot does for us, how it does it, and hopefully we've got a good idea of how to override the default autoconfiguration.</p><p>Detailing how spring boot works is the topic of a book all by itself. If you want to dig deeper, I recommend that you read the excellent book <span class="emphasis"><em>Learning Spring Boot</em></span> by Greg Turnquist in the same collection.</p><p>We are now ready for the next chapter where our application will reach a new stage by actually serving web pages, and you will learn more about spring MVC's philosophy.</p></div></body></html>