- en: 13\. Functional Programming with Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how Java doubles up as a functional programming language.
    It also details the manner in which lambda expressions are used to perform pattern
    matching in Java. It accomplishes this, first, by explaining, in general terms,
    the difference between **Object-Oriented Programming** (**OOP**) and **Functional
    Programming** (**FP**). You will then learn the basic definition of a pure function,
    as well as the difference between functional and normal interfaces. And, finally,
    you practice employing lambda expressions as callbacks to events and using them
    to filter data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Java has been around for over 20 years now, and **Functional Programming**
    (**FP**) has been around for even longer than Java, it's not been until recently
    that the topic of FP has caught traction in the Java community. This is probably
    due to Java being an inherently imperative programming language; when learning
    Java, you learn OOP.
  prefs: []
  type: TYPE_NORMAL
- en: However, the movements in the mainstream programming community have, in the
    past few years, shifted more toward FP. These days, you can see it on every platform—from
    the web to mobile to servers. FP concepts are everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FP has been around for a very long time even though it is a relatively new topic
    in Java. In fact, it has been around even longer than the first personal computer;
    it has its origins in the lambda calculus study that Alonzo Church created in
    the 1930s.
  prefs: []
  type: TYPE_NORMAL
- en: The name "lambda" comes from the Greek symbol, which was the symbol Church decided
    to use when describing the rules and mathematical functions for his lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: The lambda identity function is, quite simply, a function returning the input
    parameter—that is, the identity. In a more normal mathematical script.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, lambda calculus is a simple approach to use for expressing mathematical
    equations. However, it doesn't necessarily have to be mathematical. In its truest
    form, it's a function with one argument and a body where the arithmetic happens.
    In lambda calculus, the function is a first-class citizen – meaning it can be
    treated like any other variable. You can even combine multiple lambdas if you
    require multiple attributes in your function.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FP boils down to two things: side effects and determinism. These concepts form
    the basis of what we call FP, and they are also the easiest things for newcomers
    to grasp in this paradigm because they don''t introduce new, complex patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Side Effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing a program, we often strive to get some form of side effect – a
    program without side effects is a very dull program, as nothing would happen.
    However, side effects are also a common headache when trying to test a program
    reliably as its state may change unpredictably.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very useful class in Java is the `Math` class; it contains all sorts of mathematical
    helpers and is likely to be used in all Java applications, either directly or
    indirectly. Here is an example of printing a pseudo-random number to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we dig into the code of `Math.java` and review the details of the `random()`
    function, we will notice that it uses an object, `randomNumberGenerator`, that
    doesn''t belong exclusively to the `random()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It also calls `nextDouble()` on the `randomNumberGenerator` object. This is
    what we refer to as a side effect; the `random` function reaches outside its own
    home, or body, and performs changes on other variables or classes. These variables,
    in turn, can be by other functions or objects that may or may not produce their
    own side effects. This behavior is a red flag when you are trying to implement
    a program in FP fashion because it's unpredictable. It can also be more difficult
    to make it safe to use in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Math.random()` function, by design, delivers an unpredictable result. However,
    as an example, it serves us well to highlight the concept of side effects. The
    `random` function is also safe to use in multithreaded environments (for the most
    part)—Sun and Oracle have done their homework!
  prefs: []
  type: TYPE_NORMAL
- en: As the `Math.random()` function produces different results for the same arguments,
    it's defined as a non-deterministic function.
  prefs: []
  type: TYPE_NORMAL
- en: Deterministic Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A deterministic function is defined as a function that will always produce
    the same result for the same arguments, no matter how many times, or when, you
    execute the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `Math.random()` is called twice, and will always print two
    different values to the terminal. No matter how many times you call `Math.random()`,
    it will always give different results – as, by design, it''s not deterministic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this simple code, we can see that the `Math.toRadians()` function will
    give the same result for both functions, and doesn''t seem to change anything
    else in the program. This is a hint that it is deterministic – let''s dig into
    the function and review it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function, as expected, will not change anything from the outside world and
    will always produce the same result. This means that we can consider it as a deterministic
    function. However, it does read a constant that lives outside of the function's
    scope; this is something of an edge case of what we can call a **pure function**.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purest of functions can be considered black boxes, meaning that what happens
    inside the function is not really of any interest to the programmer. They are
    only interested in what is put into the box, and what comes out of it as a result—that's
    because there will always be a result of a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: The pure function takes arguments and produces a result based on these arguments.
    The pure function will never change the state of the outside world or rely on
    it. Everything that is required by the function should be available inside it,
    or as an input to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Writing Pure Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A grocery store has a system for managing their stock; however, the company
    that built their software has gone bankrupt and has lost all the source code for
    their system. This is a system that only allows customers to buy one thing at
    a time. Because their customers want to buy two things at a time, never more or
    less, they have asked you to implement a function that takes the price of two
    products and returns the sum of those two prices. They want you to implement this
    without causing any side effects or incompatibilities with their current system.
    You''ll implement this as a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: If IntelliJ is already started but no project is open, then select `Create New
    Project`. If IntelliJ already has a project open, then select `File` -> `New`
    -> `Project` from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `New Project` dialog, select the `Java project`. Then, click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the box to create the project from a template. Select `Command Line App`.
    Then, click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new project the name `Exercise1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IntelliJ will give you a default project location; if you wish to select one,
    you can enter it here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the package name to `com.packt.java.chapter13`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on `Finish`. IntelliJ will create your project, called `Exercise1`, with
    the standard folder structure. IntelliJ will also create the main entry point
    for your application, called `Main.java`; it will look like the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Rename `Main.java` to `Exercise1.java`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new function in the `Main` class, placing it under the `main(String[]
    args)` function. Call the new function `sum` and let it return an integer value.
    This function should take two integers as input. For the simplicity of the code,
    we''ll make the function a `static` utility function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All this function should do is return the sum of the two arguments—`price1`
    and `price2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call this new method a few times using the same parameters in your `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run your program and observe the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `System.out.println()` method is considered by many as an impure function
    because it manipulates the terminal – which is, of course, "the outside world"
    because, at some point in the call stack, the function will reach outside of its
    body to manipulate an `OutputStream` instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function you just wrote takes two arguments and produces a whole new output,
    without modifying anything outside the function's scope. With this, you've successfully
    taken the first step toward writing applications in a more functional way.
  prefs: []
  type: TYPE_NORMAL
- en: Another important consideration when writing functional programs is how to handle
    the state in your application. In OOP, we attack the problem of handling state
    in large applications by using the divide-and-conquer strategy. Here, each object
    in the application contains a little piece of the state of the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implicit attribute of this type of state handling is the ownership and mutability
    of the state. Each object often has a private state that is accessible using a
    public interface—the object''s method. If, for example, we review the `ParseException.java`
    class from the OpenJDK source code, we''ll find this pattern as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see one private member variable called `errorOffset`. This member
    variable is writeable from the constructor and is accessible for other objects
    via the `getErrorOffest()` method. We can also imagine a class that has another
    method that changes the `errorOffset` value—that is, a setter.
  prefs: []
  type: TYPE_NORMAL
- en: One possible problem with this approach to state handling is multithreaded applications.
    If two or more threads were to either read or write to this member variable, we
    would usually see unpredictable changes. These changes can, of course, be mended
    in Java by using synchronization. However, synchronization comes at a cost; it's
    complicated to plan access accurately and, often, we end up with race conditions.
    It's also quite an expensive procedure in any language that supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using synchronization is quite popular and is a safe way to build multithreaded
    applications. However, one of the downsides of synchronization—apart from it being
    very expensive—is that it effectively makes our application behave as a single-threaded
    application, as all threads accessing the synchronized data must wait their turn
    to handle the data.
  prefs: []
  type: TYPE_NORMAL
- en: In FP, we try to avoid using synchronization by instead saying that our state
    should always be immutable—effectively negating the need for synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability of State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the state is immutable, it essentially means that it cannot change, ever.
    There is a common way of writing this rule in FP that goes something like this:
    replace your data rather than editing it in place.'
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in *Chapter 3*, *Object-Oriented Programming*, one of the core
    concepts of OOP is inheritance; that is, the ability to create child classes that
    build upon, or inherit, the functionality already present in parent classes, but
    also add new functionality to the child classes. In FP, this becomes relatively
    tricky because we're targeting data that should never change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way of making data unchangeable in Java is by using the `final`
    keyword. There are three ways of using the `final` keyword in Java: locking variables
    for change, making methods impossible to override, and making classes impossible
    to extend. When building immutable data structures in Java, it''s often not enough
    with just one of these methods; we need to use two or sometimes even all three.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Creating an Immutable Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A local carpenter has set up shop on your street and has asked you to build
    the storage mechanism for a simple shopping cart application, which they will
    use internally for people ordering furniture. The application should be able to
    safely handle multiple people editing it at the same time from different threads.
    The salespeople will take orders on the phone and the carpenters will be editing
    the price in hours spent and material used. The shopping cart must be immutable.
    To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Project` pane in IntelliJ, right-click on the folder named `src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `New` -> `Java Class` in the menu and enter `Exercise2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `main` method in your new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new inner class called `ShoppingCart`, and then make it `final` to
    ensure that it cannot be extended or its behavior changed. Your code should now
    look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need items to put into this cart, so create a simple data object for
    `ShoppingItem`, give it a name and price attribute, and then make the class immutable.
    We''ll later use this class to instantiate a few different objects to test the
    mutability of our `ShoppingCart` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a list in which we will keep all the items for this immutable shopping
    cart. Make sure that you declare the list with the `final` keyword, keeping it
    unchangeable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have a way to create items for our customers to purchase, and we also
    have a bag for our customers to put their selected items in. However, we lack
    a way for our customers to add items to the shopping cart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the object-oriented approach to solving this problem, we could add a method
    called `addItem(ShoppingItem shoppingItem)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looking at this solution from an FP approach, we can already see that it will
    modify the collection. This is something that we're desperately trying to avoid
    as multiple people will be working on this shopping cart at the same time. In
    this case, using the `final` keyword has no impact since the contents of a final
    list can still change. One basic approach to solving this in a functional way
    is to return a new `ShoppingCart` when adding an item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a new constructor to the `ShoppingCart` class and let it take a list as
    an argument. Then, pass this list to `mShoppingList` of the `ShoppingCart` class
    and make it unmodifiable with the `Collections.unmodifiableList()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Rewrite the `addItem(ShoppingItem item)` method and let it return a new `ShoppingCart`
    item instead of `void`. Copy the list of the previous `ShoppingCart` items into
    a temporary list and add another item to it. Then, pass this temporary list to
    the constructor and return the newly created `ShoppingCart` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we can see that the constructor now accepts a list of `ShoppingItem`
    classes; we can also see that the list is directly saved as an unmodifiable list.
    This is a special type of list in Java—one that throws an exception whenever you
    attempt to modify it in any way, either directly or through its iterator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also see that the `addItem(ShoppingItem item)` function now returns a
    new `ShoppingCart`, with a whole new list, but with the items from the previous
    shopping list shared between the two `ShoppingCart` instances. This is an acceptable
    solution even for a multithreaded environment as the `ShoppingItem` classes are
    final and, therefore, may never change their state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Java 8 introduced the Stream API, which was a whole new way of working with
    collections, that is, a more FP-based approach. You can read more about the Stream
    API in *Chapter 15*, *Processing Data with Streams*. In this chapter, we'll focus
    on solutions that don't use the Stream API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you need to use this new `ShoppingCart` in a program. Edit your `main`
    method, and then let it create an empty `ShoppingCart` first. Then, add a new
    shopping item to that cart, storing the newly created `ShoppingCart` in another
    variable. Finally, add another `ShoppingItem` to the second `ShoppingCart`, again
    storing the new `ShoppingCart` in a new variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place a breakpoint on the last line and debug your code. You'll notice the carts
    that are created when calling `addItem` maintain their own unmodifiable list of
    `ShoppingItem`, but the immutable `ShoppingItem` are shared across the lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Collections.unmodifiableList()` method and other similar methods (such
    as `Set`, `Map`, and `SortedList`) are not providing any immutability to the list
    itself. They produce a view of the list that prohibits any change. However, anyone
    with a reference to the actual list will still be able to change the data.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise the lists are safe as the `main` method doesn't keep any reference
    to the lists, so no one outside can change it. However, this is not the recommended
    path when attempting to implement a program using a functional approach; don't
    trust anyone to follow rules unless they strictly must. Since Java 9, there are
    now real immutable collections that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1: Modifying Immutable Lists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new behavior to your `ShoppingCart`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `removeItem(ShoppingItem)` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that takes multiple `ShoppingItem` as arguments, either as
    a list or as variable arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify your `ShoppingCart` to take multiple items of each `ShoppingItem`—for
    example, four chairs and one table. Additionally, modify the `addItem(ShoppingItem)`
    and `removeItem(ShoppingItem)` functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 561.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Immutable Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `Collections.unmodifiableList` is a quick way to provide an unmodifiable
    version of an existing list. Another option available since Java 9 is to use the
    immutable collections with factory methods. These factory methods allow you to
    create three different immutable collection types: `List`, `Set`, and `Map`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are a few libraries that provide more optimized immutable collections;
    one popular example is Guava with its `ImmutableArrayList` and other types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to use the `List` factory methods instead of the `Collections` class
    in our shopping cart, it could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that there's very little difference to what we had before.
    Instead of using `Collections.unmodifiableList()` to create an unmodifiable view
    of the list, we create an immutable copy of this list with `List.copyOf()`. The
    difference in our example is invisible for the user. However, at the bottom, they're
    based on different implementations—the `UnmodifiableCollection` and `ImmutableCollections`
    classes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Overriding the String Method'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll make a small technical proof of the difference between
    `UnmodifiableCollection` and `ImmutableCollection` classes. For this example,
    we''ll need to override the `toString()` method for the `ShoppingItem` and `ShoppingCart`
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `toString()` method to the `ShoppingItem` class, and then let it return
    the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `toString()` method to the `ShoppingCart` class. Then, let it return
    a concatenated string for all the `ShoppingItem` in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have a simple way of printing the contents of a `ShoppingCart` using
    the `toString()` method. To demonstrate the difference, replace the code in the
    `main` method. Add a few books to a standard list, and then copy this list into
    an unmodifiable version and an immutable version. Print the two copies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now remove the first item, the `Java Fundamentals` book, from the original
    `books` list and print the two copies again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This simple example provides proof of the difference between an unmodifiable
    view and an immutable copy. In the unmodifiable version, the list can still be
    changed, and the unmodifiable view will pick up on that change, whereas the immutable
    version will ignore that change because it contains a new list of items.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional interfaces are declared as standard Java interfaces, except they're
    only allowed to contain one abstract function, but can contain any number of default
    or static functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `Comparator` interface is one of the older interfaces of Java. It has been
    with us since version 1.2 and has seen many several over the years. However, the
    biggest change yet is probably the move to become a functional interface in Java
    8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reviewing the changes on the `Comparator` interface in Java 8, you''ll notice
    some interesting changes. First, the interface has grown from 4 lines of code
    to 80 lines, excluding package declaration and comments. Then, you''ll notice
    that there''s a new annotation at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This annotation marks that this is now a functional interface. Its main purpose
    is to tell the reader that this interface is intended to follow the functional
    interfaces specification as defined in Java 8\. If it fails to follow those guidelines,
    the Java compiler should print an error.
  prefs: []
  type: TYPE_NORMAL
- en: After the two original abstract function declarations, you'll find no less than
    seven default functions. These default functions were introduced in Java 8 to
    add new functionality to interfaces without breaking backward compatibility. The
    default functions are always public and will always contain a code block. They
    can return a value, but this is not required by the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll find a total of nine `static` functions. Since Java 8, the functional
    interface can contain any number of `static` methods, they work very much like
    the static methods found in normal classes. You will explore more details about
    building and using functional interfaces in a later chapter in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the functional improvements in Java 8, there also came `Lambda` expressions.
    One of the primary improvements with lambdas is the code readability—most of the
    boilerplate code for interfaces is now gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very commonly used interface is the **Runnable interface**; it''s used in
    multithreaded applications to perform any type of task in the background, such
    as downloading a large file from a network. In Java 7 and earlier versions, you''d
    often see the Runnable interface used as an anonymous instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Java 8, the preceding five lines of code can now be simplified by using
    a lambda expression instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code becomes much more readable when we remove a lot of
    the boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda expression consists of two main components: the arguments and the
    body. Additionally, between these two components, there is always an arrow operator
    (which is also known as a lambda operator). The body also contains the optional
    return value. The parentheses contain the optional arguments for the lambda expression.
    Because it''s an FP component, though, you''ll want to use arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also omit the type of the arguments as those will be inferred by the
    functional interface that the lambda expression implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have only one argument, you can omit the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you have no arguments in your lambda, then you must include the
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there is the function body; if you have many lines of code in your lambda
    logic, you must use the curly brackets to enclose the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you only have one single line of code, you can omit the curly brackets
    and immediately return the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also omit the `return` keyword if all you have is a single
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to write the lambda calculus identity function in Java, assuming
    we have a functional interface called `Identity`, it would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: One commonly used interface is the `Comparator` interface, which is used in
    almost any object you wish to order, specifically in a collection of some form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Listing Spare Tires'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A racing team has contacted you to organize their stock of spare tires because
    it's in a mess. They've asked you to write an application that will show the list
    of available tires in order of size, starting with the biggest tire.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you''ll build a lambda function that implements the `Comparator`
    functional interface. For reference, this is the base view of the `Comparator`
    interface, excluding the default and static functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the `Project` pane in IntelliJ, right-click on the folder named `src`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose `New` -> `Java Class` in the menu, and then enter `Exercise4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the `main` method in your new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new inner class called `Tire`. It should have a size variable that
    is the diameter of the tire in inches. Make sure that the class and size are declared
    as `final` to adhere to the FP guidelines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Tire` constructor, taking one argument—the `size`—and passing that
    to the member variable. Additionally, override the `toString()` method to print
    the size of the tire:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of tires that need to be sorted into your `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the actual lambda expression, using the `Comparator` functional interface,
    that you will use to sort the immutable list of tires. It should take two arguments,
    and return the difference in size. Remember that the lambda expression infers
    a lot of the structure; you won''t need to specify the types or return a keyword
    in this simple example. The lambda expression is a first-class citizen, so it''s
    fine to store it in a variable for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can, of course, also apply the lambda expression as an anonymous instance—that
    way, you can save a few lines of code while keeping the code very readable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apply the lambda expression in the `sort` method. The `List.sort()` method
    modifies the content of the list, so you need to copy your immutable list of tires
    before sorting it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make this program functional, you could move the sorting intelligence to
    a pure function that takes a list as an argument, then performs the sorting on
    a copy of that list and returns the immutable sorted list. This way, you will
    avoid keeping a reference of the mutable list in your main program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You've just created your first lambda expression, based on an already present
    `Functional` interface, and you've then used it to sort a list of tires. There
    are lots of functional interfaces available since Java 8, and you've probably
    already been using most of them; we'll explore this in more detail later in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It shouldn't matter the order in which different threads act on your data, and
    you should be able to easily add functionality that doesn't affect older parts
    of your application. Following these FP concepts allows you to build code that
    can easily be used in multithreaded applications, as well as to build code that
    can be tested very easily for problems and regression bugs. It also often makes
    your code much more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the core concepts of FP that you've learned about in this chapter—pure
    functions and immutability—can lead to performance issues in some cases, specifically
    when modifying large datasets. There are ways to get around these, as we'll explore
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Because Java was designed for an OOP approach, it can be a bit daunting to get
    into FP at first, but if you "go functional" in only certain parts of your code,
    the transition from OOP may become easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on how to navigate larger datasets and repeat
    code without using loops.
  prefs: []
  type: TYPE_NORMAL
