- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gRPC API Development and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will learn how to implement gRPC-based APIs in this chapter. You will learn
    how to write the gRPC server and client along with writing APIs based on gRPC.
    In the later part of this chapter, you will be introduced to microservices and
    see how they can help you to design modern, scalable architecture.
  prefs: []
  type: TYPE_NORMAL
- en: You will also go through the implementation of two services – the gRPC server
    and the gRPC client. gRPC-based APIs are more popular and preferred over REST
    APIs for service-to-service communication in a microservice-based system. Hence,
    gRPC development skills are important in the API space.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will be well versed in the gRPC server and
    client development, gRPC-based API testing automation, and microservice concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will explore the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing an API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the gRPC server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the gRPC client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning microservice concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains a great deal of theory on gRPC. However, you will also
    undertake the development and testing of gRPC-based web services, for which you
    will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Any Java IDE, such as NetBeans, IntelliJ, or Eclipse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) 17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection to clone the code and download the dependencies and Gradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman/cURL (for API testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please visit the following link to check the code: [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Writing an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write the API using **Protocol Buffer** (**Protobuf**)
    for a payment service. If you recall, this is the piece that you haven’t yet implemented
    in the sample e-commerce app.
  prefs: []
  type: TYPE_NORMAL
- en: Before writing the API, let’s set up the Gradle project.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this chapter will contain three projects under the `Chapter11`
    directory – the API, server, and client:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.proto` file and its generated Java classes packaged in a JAR file. This project
    will generate the `payment-gateway-api-0.0.1.jar` library artifact, which you
    will publish in a local repository. This library will then be used in both the
    server and client projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server**: This project represents the gRPC server, which will implement the
    gRPC services and serve the gRPC requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client**: This project contains the gRPC client, which will call the gRPC
    server. To kick off the inter-service communication between the gRPC server and
    client applications, you are going to implement a REST call, which will call the
    gRPC server internally to serve the HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s first create the server and client projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gRPC server and client projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Either you can clone the [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250) code
    from the Git repository ([https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11))
    or you can start by creating the new Spring project from scratch using `api` library
    project separately):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Gradle -` `Groovy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Java`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3.0.8`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preferred version is *3.0+*. Please choose the version that is available.
    You can modify it manually in the `build.gradle` file later too.
  prefs: []
  type: TYPE_NORMAL
- en: '`com.packt.modern.api`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chapter11`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter11`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chapter 11 code of book Modern API Development with Spring and Spring Boot`
    `Ed 2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`com.packt.modern.api`.*   `Jar`.*   `17`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can opt for any new version, such as *20*. It can be modified in the `build.gradle`
    file later too, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`Spring Web`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, you can click on **GENERATE** and download the project.
  prefs: []
  type: TYPE_NORMAL
- en: The downloaded project can be used to create both the server and the client.
    Then, create separate `server` and `client` directories under the `Chapter11`
    directory. After creating the directories, copy the extracted content from the
    downloaded zipped project into them.
  prefs: []
  type: TYPE_NORMAL
- en: You can configure the server and client projects later. Let’s first create the
    gRPC API library project as this library is going to be used in both the server
    and client projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the gRPC API library project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new directory, called `api`, in the `Chapter11` directory. Then, use
    Gradle to create a new Gradle project using the following command executed from
    the `Chapter11` directory. It will ask for a few options. The following block
    is executed after setting the `JAVA_HOME` environment variable to Java 17 and
    adding Java 17 to the path. You may find the order of questions a bit different
    in some systems. You should select the options highlighted in the following terminal
    interface output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The project is bootstrapped by Gradle. Next, you will configure the `api` project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the gRPC API library project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, you will configure the `plugins` section in `api/libs/build.gradle` with
    the Protobuf and Maven Publish plugins. These plugins and setting their configuration
    are key steps. Let’s do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `api/settings.gradle` in the project’s root directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: plugins {    id 'java'    id 'maven-publish'    id "com.google.protobuf" version
    "0.9.2"}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Maven Publish plugin will be used to publish the generated `Jar` artifact
    to the local Maven repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the group name, version, and source compatibility in `api/libs/build.gradle`,
    as shown in the following code block. The group and version will be used by the
    Maven Publish plugin to name the published artifact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following dependencies, which are required for Protobuf and gRPC
    (check the highlighted part). You can remove the existing dependencies added while
    generating the project using the `gradlew init` command and keep the dependencies
    mentioned next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: protobuf {  protoc {    artifact = "com.google.protobuf:protoc:3.22.2"  }  plugins
    {    grpc {      artifact = "io.grpc:protoc-gen-grpc-java:1.54.0"    }  }  generateProtoTasks
    {    all()*.plugins {      grpc { }    }  }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, you have configured the artifact used by the Protobuf
    compiler (`protoc`) and its Java plugin (`protoc-gen-grpc-java`), which will generate
    the Java code based on `.``proto` files.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `gradlew` `build` command for the first time, Gradle will download
    the `protoc` and `protoc-gen-grpc-java` executables based on the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Protobuf Gradle plugin works with the configuration shared hitherto in
    this subsection. It works when you run the `build` command from the command line.
    However, the IDE may give a compilation error if you don’t add the following block
    to the `api/libs/build.gradle` file to add the generated source files to `sourceSets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you will add the following block to configure the Maven Publish plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you have configured the `api` project. You can find more information about
    the Protobuf Gradle plugin at [https://github.com/google/protobuf-gradle-plugin](https://github.com/google/protobuf-gradle-plugin).
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `api` project setup is done, we are ready to write the service
    definitions using Protobuf in the next subsection. You haven’t yet implemented
    the payment functionality for our sample e-commerce app. This is because it needs
    to be integrated with a payment gateway service such as Stripe or PayPal. Therefore,
    you are going to write the sample payment gateway service definition using gRPC
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the payment gateway functionalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you write the payment gateway service definition, let’s first understand
    the basic functionality of the payment gateway system in easy terms.
  prefs: []
  type: TYPE_NORMAL
- en: The payment gateway provides a way to capture and transfer a payment from a
    customer to online sellers and then returns Accepted/Declined as a response to
    the customer. It performs various other actions here, such as verification, security,
    encryption, and communication with all participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the actors who participate in this transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Payment gateway**: A web interface that allows the processing of online payments
    and coordinates with all other actors. This is very similar to physical **point-of-sale**
    (**POS**) terminals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Merchant**: Merchants are online sellers or service providers, such as Amazon,
    Uber, and Airbnb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer**: This is you, the customer, who performs the buy/pay transaction
    for products or services and uses credit/debit cards, digital wallets, or online
    banking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issuing bank**: The party that provides the functionality to perform online
    money transfers, such as Visa, Mastercard, AmEx, PayPal, Stripe, or traditional
    banks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acquirer or acquiring bank**: The institution that holds the merchant account.
    It passes the transaction to the issuing bank to receive payment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are going to create two gRPC services – `ChargeService` and `SourceService`
    – as part of the payment gateway service. Don’t get confused with the web service,
    which is an executable/deployable artifact. `ChargeService` and `SourceService`
    are part of the service component of Protobuf’s `EmployeeService` example in the
    last chapter (the *How gRPC uses Protobuf* section of [*Chapter 10*](B19349_10.xhtml#_idTextAnchor233),
    *Getting Started with gRPC*). Both services are inspired by Stripe public REST
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the transaction flow before we jump into creating the service
    components of a gRPC-based payment gateway service.
  prefs: []
  type: TYPE_NORMAL
- en: Online payment workflow steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following steps are performed when an online transaction takes place:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the customer should have a payment source (read method) created before
    initiating the payment. If not, then the customer creates a source, such as their
    card details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Payment is initiated by creating a charge against the payment source (read method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The payment gateway performs all the necessary validation and verification steps
    and then allows the charge to be captured. These steps trigger the fund transfer
    from the issuing bank to the merchant account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can observe that there are two objects (resources) involved in this workflow
    (aka source and charge). Therefore, you are going to write two services that function
    around these two objects. There are various other functionalities performed by
    the payment gateway, such as disputes, refunds, and payouts. However, you are
    going to implement only two services, charge and source, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the payment gateway service definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing a Protobuf-based IDL is very similar to the way you defined the OpenAPI
    Specification for REST APIs. In REST, you define the models and API endpoints,
    whereas in gRPC, you define the messages and RPC procedures wrapped in the service.
    Let’s write our payment gateway service IDL using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a new file, `PaymentGatewayService.proto`, in the `api/lib/src/main/proto`
    directory under the root directory of the `api` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After creating a new file, you can add the metadata, as shown in the following
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s understand the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Line *1* tells the compiler to use version 3 of Protobuf by using the syntax
    specifier. If you don’t specify this, then the compiler will use version 2 of
    Protobuf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 2* uses the optional package specifier to attach the namespace to message
    types. This prevents name clashes among message types. We must postfix it with
    a package version that allows us to create new versions of APIs with backward
    compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 3* uses the `java_package` option specifier. This specifies the Java
    package to be used in the generated Java files. If you don’t use this option specifier
    and declare the `package` specifier, then the value of `package` will be used
    as a Java package in the generated Java files instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 4* declares the `java_multiple_files` option specifier, which is a Boolean
    option. It is set to `false` by default. If it is set to `true`, then it generates
    separate Java files for each top-level message type, enumeration (`enum`), and
    service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let’s add the `ChargeService` service, which contains the operations
    required for charge functionality denoted by `rpc` (as shown in the following
    code block). Charge objects get created for charging the card, bank account, or
    digital wallet. Let’s add the charge service to the Protobuf (`.``proto`) file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these procedures in `ChargeService` will perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Charge` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charge` object based on the given charge ID that was previously created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charge` object identified by the given charge ID by setting the values of
    the parameters passed. Any parameters not provided will be left unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`capture` option set to `false`. Uncaptured payments expire precisely seven
    days after they are created. If they are not captured by that point in time, they
    will be marked as refunded and capture will no longer be allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RetrieveAll**: This procedure returns the list of charges that belong to
    the given customer ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty request or response type
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `google.protobuf.Empty` for void/empty request and response types.
    This can be used in `.proto` files. You just must place the following `import`
    statement before any message/service is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import "google/protobuf/timestamp.proto";`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can use it as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rpc delete(SourceId) returns (``google.protobuf. Empty);`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The amount is charged to a source, which could be a card, bank account, or
    digital wallet. A variety of payment methods can be used by the customer using
    a `Source` object. Therefore, you need a service that will allow you to perform
    operations on the `source` resource. Let’s add the `Source` service and its operations
    to the Protobuf (`.``proto`) file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each of these procedures in `SourceService` will perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Source` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` object based on the given source ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` object passed using the `UpdateSourceReq` object. Any field that is
    not part of `UpdateSourceReq` will remain unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` object to the customer. The `AttachOrDetachReq` parameter contains
    the IDs of both the source and the customer. However, the `Source` object should
    be in the `CHARGEABLE` or `PENDING` state to perform the attached operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Source` object from the customer. It will also change the state of the `Source`
    object to `consumed` and it can no longer be used to create the charge. The `AttachOrDetachReq`
    parameter contains the IDs of both the source and the customer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended approach for defining the request and response types
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to always use the wrapper request and response types. This
    allows you to add another field to the request or response types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the service definitions are done, you can define the given parameters
    and the returned types of these procedures. Let’s first define the parameters
    and returned types of `ChargeService`. First, you will define the `Charge` message
    type, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `Charge` message contains the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The unique identifier of the `Charge` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amount`: The amount is a positive number or zero, referring to the amount
    of the payment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amountCaptured`: This is the captured amount (a positive number or zero).
    It can be less than the value of the `amount` field if a partial capture is made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amountRefunded`: The amount refunded (a positive number or zero). It can be
    less than the value of the `amount` field if a partial refund is issued.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`balanceTransactionId`: The ID of the balance transaction, which describes
    the impact of this charge on your account balance (not including refunds or disputes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`billingDetails`: The object of the `BillingDetails` message type, which contains
    billing information associated with the payment method at the time of the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculatedStatementDescriptor`: The statement description that is passed to
    card networks and is displayed on your customers’ credit card and bank statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`captured`: A Boolean field that represents whether a charge has since been
    captured. (It is possible to create a charge without capturing the charge details.
    Therefore, this field is added, which determines whether a charge will be captured
    or not.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created`: The timestamp (measured in seconds since the Unix epoch) at which
    the object was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currency`: The three-letter ISO currency code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customerId`: The ID of the customer owning the charge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: A description of the charge displayed to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disputed`: A Boolean field that represents whether the charge has been disputed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureCode`: The error code of the failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failureMessage`: A description of the failure. The reason may be stated if
    this option is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invoiceId`: The ID of the invoice this charge is for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`orderId`: The ID of the order this charge is for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paid`: The Boolean value represents whether the charge succeeded or was successfully
    authorized for subsequent capture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paymentMethodId`: The ID of the payment method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paymentMethodDetails`: The object that contains the details of the payment
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receiptEmail`: The email where receipt of the charge will be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receiptNumber`: This represents the transaction number in the charge receipt
    that was sent by email. It should remain null until a charge receipt is sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refunded`: A Boolean field that represents whether the charge was refunded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`refunds`: This contains the list of refunds that have been issued. The `repeated`
    keyword is used to create a list of `Refund` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statementDescriptor`: The description of a charge for a card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: An object of the `Status` enumeration type (`SUCCEEDED`, `PENDING`,
    or `FAILED`) that represents the status of the charge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sourceId`: ID of the `Source` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UInt32 and string scalar types were discussed in the *How gRPC uses Protobuf*
    subsection under the *How does gRPC work?* section in the previous chapter ([*Chapter
    10*](B19349_10.xhtml#_idTextAnchor233), *Getting Started with gRPC*). You can
    refer to it for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined well-known types
  prefs: []
  type: TYPE_NORMAL
- en: Apart from scalar types, Protobuf also provides predefined types such as `Empty`
    (which we saw earlier in *step 3*), `Timestamp`, and `Duration`. You can find
    the complete list at https://developers.google.com/protocol-buffers/docs/reference/google.protobuf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can define the remaining message types of the other parameters (`CreateChargeReq`,
    `ChargeId`, `UpdateChargeReq`, `CaptureChargeReq`, and `CustomerId`) and return
    the `ChargeList` type of `ChargeService`, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `CreateChargeReq` type contains the required attribute’s charge amount
    (`amount`) and `currency`. It also contains several optional attributes – `customerId`,
    `receiptEmail`, `source`, and `statementDescriptor`.
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateChargeReq` contains all the optional attributes – `customerId`, `description`,
    and `receiptEmail`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`CaptureChargeReq` contains all the optional attributes – `amount`, `receiptEmail`,
    and `statementDescriptor`.'
  prefs: []
  type: TYPE_NORMAL
- en: Less well-known Google common types
  prefs: []
  type: TYPE_NORMAL
- en: '`Money` and `Date` (not `Timestamp`) are less commonly known types that can
    be used. However, you must copy the definitions instead of importing them (unlike
    what you do for `Empty` and `Timestamp`). You can copy the definitions from the
    following links: `Money` from https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
    and `Date` from https://github.com/googleapis/googleapis/blob/master/google/type/date.proto.
    Other common types that you can use are also available in the repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can define the parameters and return the `SourceService` types. First,
    let’s define the `Source` message type, as shown in the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The source uses a `Flow` value, which could be either `REDIRECT`, `RECEIVER`,
    `CODEVERIFICATION`, or `NONE`. Similarly, the `Usage` value could be `REUSABLE`
    or `SINGLEUSE`. Therefore, let’s first create the `Flow` and `Usage` enumerations
    using `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use this `Flow` enum in the `Source` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can define the remaining message types for the other parameters of
    `SourceService` – `CreateSourceReq`, `UpdateSourceReq`, `AttachOrDetachReq`, and
    `SourceId` – as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The other message types used in these messages can be referred to in the payment
    gateway definition file, located at https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple .proto files
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a separate definition file for each service, such as `ChargeService.proto`
    and `SourceService.proto`, for modularity. You can then import these files into
    another Protobuf file using `import "SourceService.proto";`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about importing at https://protobuf.dev/programming-guides/proto3/#importing-definitions.
  prefs: []
  type: TYPE_NORMAL
- en: You are now done with the payment gateway service definitions in the Protobuf
    file. Now, you can use this file to generate the gRPC server interface and stubs
    for the gRPC client.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will publish the Java classes generated from the Protobuf file packaged
    in the `Jar` file.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the payment gateway service gRPC server, stubs, and models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the following command, which should be executed from the `api`
    project’s root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, you are setting the file encoding to UTF-8 first
    because we are using the UTF characters in Java files. Then, you are performing
    clean, build, and publish operations. The second command will first remove the
    existing files. Then, it will generate the Java files (the `generateProto` Gradle
    task) from the Protobuf file, build it (the `build` Gradle task), and publish
    the artifact to your local Maven repository (the `publishToMavenLocal` Gradle
    task).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `generateProto` Gradle task will generate the two types of Java classes
    in two directories, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/lib/build/generated/source/proto/main/java` directory, such as `Card.java`
    or `Address.java`. This directory will also contain the Java files of request
    and response objects used in operation contracts, such as `CreateChargeReq`, `CreateSourceReq`,
    `Charge.java`, and `Source.java`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChargeServiceGrpc.java` and `SourceServiceGrpc .java`) in the `/api/lib/build/generated/source/proto/main
    /grpc` directory. Each of these gRPC Java files contains a base class, stub classes,
    and methods for each operation defined in the service descriptor for the `Charge`
    and `Source` services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following key static classes are defined in `ChargeServiceGrpc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChargeServiceImplBase` (abstract base class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stubs: `ChargeServiceStub`, `ChargeServiceBlockingStub`, and `ChargeServiceFutureStub`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, the following key static classes are defined in `SourceServiceGrpc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SourceServiceImplBase` (abstract base class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stubs: `SourceServiceStub`, `SourceServiceBlockingStub`, and `SourceServiceFutureStub`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract base classes described earlier contain the operations defined in
    the service block in the Protobuf file. You can use these base classes to implement
    the business logic for operations offered by these services, just like you implemented
    the REST endpoints from the Swagger-generated API Java interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: These abstract classes should be implemented to provide the business logic implementations
    to the services offered by the gRPC server. Let’s develop the gRPC server next.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the gRPC server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to configure the `server` project before implementing these abstract
    classes. Let’s configure the server project first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `server` project directory structure will look like the following. The
    project root directory contains the `build.gradle` and `settings.gradle` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `resources` directory will contain the `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sprint Boot gRPC starters
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two Spring Boot starter projects that you can use. However, we’ll
    stick to the libraries provided by gRPC for a simplified solution and to aid understanding
    of the gRPC concepts. These libraries are available at the following links: https://github.com/LogNet/grpc-spring-boot-starter
    and https://github.com/yidongnan/grpc-spring-boot-starter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform the following steps to configure the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to modify the project name in the `Chapter11/server/ settings.gradle`
    file to represent the server, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can add the dependencies required for `server` projects to the `Chapter11/server/build.gradle`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: repositories {  mavenCentral()  mavenLocal()}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are done with the Gradle configuration! Now, you can write the gRPC server.
    However, before writing the server, you need to implement the base abstract classes
    generated by Protobuf. Once the source and charge services (using base classes)
    are implemented, you can write the gRPC server code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the gRPC server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are going to use the same layered architecture that you used in the REST
    implementation – persistence store > repository layer > service layer > API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need a persistence store where you can save the data, aka the first
    layer. You are going to use in-memory persistence (`ConcurrentHashMap`) for storing
    and retrieving the data. If you want, you can use the external database the way
    it is used in REST web services. This is done to keep the focus on gRPC server
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the in-memory persistence store for both the charge and source
    data stores. Create a new file, `server/src/main/java/com/packt/modern/api/server/
    repository/DbStore.java`, and add code, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/
    server/repository/DbStore.java
  prefs: []
  type: TYPE_NORMAL
- en: Here, you create two `ConcurrentHashMap` objects for storing the `Charge` and
    `Store` objects, respectively. You create two seed objects of each of these in
    the constructor using the `builder` and store them in their respective hash maps.
  prefs: []
  type: TYPE_NORMAL
- en: According to the operations defined in the service contract, you create the
    methods in the database store to perform the operations. These operations are
    implemented with basic business logic to keep the flow and logic concise and to
    the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the `createSource()` method to implement the `create()` contract
    of `SourceService` defined in the Protobuf file, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a `source` object from the values received from the request
    object (`CreateSourceReq`). This newly created `Source` object is then saved in
    a hash map called `sourceEntities` and returned to the caller. You can enhance
    this method by adding validation that would validate the request object (`req`).
    Owner and receiver objects (highlighted in the code) should be retrieved from
    the request object. To keep the program simple, we have hardcoded these values
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can implement other contract methods for `source` and `charge`
    along with their persistence. You can find the full source code of this class
    at https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have the in-memory persistence store – `DbStore`. Next, let’s use this
    store in repository classes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing repository classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, you can implement the next layer – the repository layer. The in-memory
    persistence store (`DbStore`) can be consumed in the `ChargeRepositoryImpl` repository
    class to interact, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepositoryImpl.java
  prefs: []
  type: TYPE_NORMAL
- en: '`ChargeRepositoryImpl` implements the `ChargeRepository` interface and makes
    use of `DbStore` to perform the operations. The code of this repository interface
    is available at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can create the `SourceRepositoryImpl` class, which implements
    `SourceRespository`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Like `ChangeRepositoryImpl`, `SourceRepositoryImpl` too makes use of a persistence
    store to persist the data. You can find the code for the `SourceRepository` interface
    at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java).
  prefs: []
  type: TYPE_NORMAL
- en: Methods of the `Source` and `Charge` repository classes are consumed by the
    service classes. Service base classes are generated by gRPC (part of the `api`
    project). Service classes implement these abstract-generated base classes (service
    base classes).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the service layer next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you have the underlying implementation ready in the form of repository and
    database store classes, which can be used to implement the gRPC service’s base
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the `Source` service first, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `SourceService.java`, in the `server/src/main/com/packt/modern/api/server/service`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the implementations to operations defined in the `SourceService` abstract
    base class, as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `SourceServiceImplBase` abstract class is autogenerated by the Protobuf
    plugin, which contains the contract methods of the `Source` service. A unique
    part of the method signature generated is the second argument, `StreamObserver`.
    `StreamObserver` receives notifications from observable streams. It is being used
    here for service implementation. Similarly, it is also used in the client stubs.
    The gRPC library provides the `StreamObserver` argument for outgoing messages.
    However, you also must implement it for incoming messages.
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamObserver` arguments are not thread-safe, so you must take care of multithreading
    and should use synchronized calls.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three primary methods of `StreamObserver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onNext()`: This method receives the value from the stream. It can be called
    multiple times. However, it should not be called after `onCompleted()` or `onError()`.
    Multiple `onNext()` calls are required for streams when multiple datasets are
    sent to clients.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCompleted()`: This marks the completion of the stream and no further method
    calls are allowed after that. It can only be called once.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: This method receives the termination error from the stream. Like
    `onCompleted()`, it can only be called once and no further method calls are allowed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, you can implement the other methods of an abstract class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you can implement the `Charge` service in the same way you have implemented
    the `Source` service. Let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file, `ChargeService.java`, in the `server/src/main/com/packt/modern/api/server/service`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the implementations to operations defined in the `ChargeService` abstract
    base class, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This is along the same lines as the way the `SourceService` `create` method
    was implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can implement the other methods of the abstract class. Please
    refer to the link to the source code after the preceding code block for the complete
    code implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have the service layer implementation ready. Let’s implement the API
    layer (gRPC server) next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of the gRPC server class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Spring Boot application runs on its own server. However, we want to run
    the gRPC server, which internally uses the Netty web server. Therefore, we first
    need to modify the Spring Boot configuration to stop running its web server. You
    can do that by modifying the `server/src/main/resources/application.properties`
    file, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/resources/application.properties)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create the gRPC server. It will have three methods – `start()`,
    `stop()`, and `block()` – for starting up the server, stopping the server, and
    serving requests until a termination request is received, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `GrpcServer.java`, in the `server/src/main/com/packt/ modern/api/server`
    directory and the code, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The server library of gRPC provides the server builder for building the server.
    You can see that both services are added to the server. The builder also allows
    you to add interceptors that can intercept the incoming request and response.
    We are going to use the interceptor in the *Coding for handling* *errors* section.
  prefs: []
  type: TYPE_NORMAL
- en: The `GrpcServer start()` method has also added a shutdown hook that calls the
    `stop()` method, which internally calls the `server.shutdown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The server code is ready. Now, you need an interface to start the server. You
    are going to use the `CommandLineRunner` function interface to run the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `GrpcServerRunner.java`, in the same directory where you
    created the `GrpcServer.java` file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServerRunner.java
  prefs: []
  type: TYPE_NORMAL
- en: Here, you override the `CommandLineRunner` `run()` method and call the `start`
    and `block` methods. Therefore, when you execute the `jar` file, `GrpcServerRunner`
    will be executed using its `run()` method and will start the gRPC server.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to remember is that you have marked the `GrpcServerRunner` class
    with the `@Profile` annotation with the `"!test"` value, which means that when
    the test profile is active, this class won’t be loaded, and hence not executed.
  prefs: []
  type: TYPE_NORMAL
- en: You are now done with both service and server implementation, so let’s test
    the gRPC server in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gRPC server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, you need to set the active profile to `test` in your `test` classes
    because doing so will disable `GrpcServerRunner`. Let’s do this and test it, as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java)'
  prefs: []
  type: TYPE_NORMAL
- en: The `beanGrpcServerRunnerTest()` method tests the loading of the `GrpcServer`
    class and `GrpcServerRunner` and the test should pass if the profile is set correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to test the gRPC services.
  prefs: []
  type: TYPE_NORMAL
- en: The gRPC test library provides a special class, `GrpcCleanupRule`, that manages
    the shutdown of registered servers and channels gracefully. You need to annotate
    it with the JUnit `@Rule` to make it effective. The gRPC test library also provides
    the `InProcessServerBuilder` builder class, which allows you to build the server,
    and the `InProcessChannelBuilder` builder class, which allows you to build the
    channel. These three classes are all you need to build and manage the server and
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you first need to declare the required instances and then set up
    the method so that the execution environment is available before you fire the
    requests to the gRPC `Source` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the required class instances and test the `setup()` method in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `setup` method creates the server and channel with the `Source` service.
    Let’s understand each of the lines mentioned in the `setup()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Line 1* generates the unique name of the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 2* registers the newly created server and adds the `Source` service and
    server interceptor to it. We’ll discuss `ExceptionInterceptor` in the *Coding
    for handling errors* section. Then, it starts the server for serving requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Line 3* creates the blocking stub, which will be used as a client for making
    the calls to the server. Here again, `GrpcCleanUpRule` is used to create the client
    channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the setup is executed, it provides us with the environment to carry out
    the tests. Let’s test our first request, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All the complex aspects of the `setup()` method are complete. These tests now
    look pretty simple. You just use the blocking stub to make a call. You create
    the request object and use the stub to call the server. Finally, validate the
    server responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can test the validation error, as shown in the following code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also test for the valid response for source retrieval, as shown in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the way in which you can write the test for the gRPC server and test
    the exposed RPC calls. You can use the same approach to write the rest of the
    test cases. After writing the test, you may have an idea of how the client is
    going to send the request to the server.
  prefs: []
  type: TYPE_NORMAL
- en: We have not yet discussed the exception interceptor that we have used in both
    the server code and test. Let’s discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Coding for handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already gone through the theory-based *Handling errors and error
    status codes* section in [*Chapter 10*](B19349_10.xhtml#_idTextAnchor233), *Getting
    Started with gRPC*, where `google.rpc.Status` and gRPC status codes were discussed.
    You may want to revisit that section before going through this section as here
    you are going to write the actual code.
  prefs: []
  type: TYPE_NORMAL
- en: '`io.grpc.ServerInterceptor` is a thread-safe interface for intercepting incoming
    calls that can be used for cross-cutting calls, such as authentication and authorization,
    logging, and monitoring. Let’s use it to write `ExceptionInterceptor`, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `RQT` represents the request type, and `RST` represents the response type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use it for exception intercepting. An interceptor will pass
    the call to the server listener (`ExceptionHandlingServerCallListener`). `ExceptionHandlingServer``     CallListener` is a private class in `ExceptionInterceptor` that extends the `ForwardingServerCallListener.
    SimpleForwardingServerCallListener` abstract class.'
  prefs: []
  type: TYPE_NORMAL
- en: The private listener class has overridden events, `onHalfClose()` and `onReady()`,
    which will catch the exception and pass the call to the `handleException()` method.
    The `handleException()` method will use the `ExceptionUtils` method to trace the
    actual exception and respond with error details. `ExceptionUtils` returns `StatusRuntimeException`,
    which is used to close the server call with an error status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this flow looks in code in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write the `ExceptionUtils` class next to complete the exception-handling
    core components. Then, you can use these components in a service implementation
    to raise the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExceptionUtils` class will have two types of overloaded methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`observerError()`: This method will use `StreamObserver` to raise the `onError()`
    event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`traceException()`: This method will trace the error from `Throwable` and return
    the `StatusRuntimeException` instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use the following code to write the `ExceptionUtils` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that the `observerError()` method is also calling `traceException()`
    internally for `onError` events. Let’s write the last overloaded method, `traceException()`,
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, `SocketException` is shown by way of an example. You can add a check for
    another kind of exception here. You may notice that here we are using `com.google
    .rpc.Status` to build the status. Then, this instance of `Status` is passed to
    `toStatusRuntimeException()` of `StatusProto`, which converts the status to `StatusRuntimeException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the validation error in the `DbStore` class to make use of these
    exception-handling components, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java)'
  prefs: []
  type: TYPE_NORMAL
- en: You can similarly raise `StatusRuntimeException` in any part of the service
    implementation. You can also use the `addDetails()` method of `com.google.rpc.Status`
    to add more details to the error status, as shown in the `traceException(Throwable
    e, T` `defaultInstance)` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can capture the error raised by the `retrieve()` method of `SourceService`
    in the `Service` implementation class, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling is explained simply and constructively in this chapter. You
    can enhance it more as per your application requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write the gRPC client in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the gRPC client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A client project’s directory structure will look as follows. The project root
    directory contains the `build.gradle` and `settings.gradle` files, as shown in
    the following directory tree structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `resources` directory will contain the `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform the following steps to configure the project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to modify the project name in the `Chapter11/client/ settings.gradle`
    file to represent the server, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can add the dependencies required for client projects to the `Chapter11/client/build.gradle`
    file. The `grpc-stub` library provides the stubs-related APIs, and `protobuf-java-util`
    provides the utility methods for Protobuf and JSON conversions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/build.gradle)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `payment-gateway-api` dependency is published in the local Maven repository.
    Therefore, you need to add the local Maven repository to the `repositories` section,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You are done with the Gradle configuration. Now, you can write the gRPC client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the gRPC client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, the Spring Boot application runs on its own server. Therefore,
    the client’s application port should be different from the gRPC server port. Also,
    we need to provide the gRPC server host and port. These can be configured in `application.properties`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/resources/application.properties)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create the gRPC client. This client will be used to configure the
    gRPC service stubs with the channel. The channel is responsible for providing
    the virtual connection to a conceptual endpoint in order to perform gRPC calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `GrpcClient.java`, in the `client/src/main/com/packt/modern/api/client`
    directory and add the code shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `start()` is the key that initialized the `Source` and `Charge` service
    stubs. `ManagedChannelBuilder` is used to build `ManagedChannel`. `ManagedChannel`
    is a channel that also provides life cycle management. This managed channel is
    passed to stubs.
  prefs: []
  type: TYPE_NORMAL
- en: You are using plain-text communication. However, it also provides encrypted
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with the client’s code. Now, we need to call the `start()` method.
    You are going to implement `CommandLineRunner` the way it was implemented for
    the `GrpcServerRunner` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be implemented as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java)'
  prefs: []
  type: TYPE_NORMAL
- en: This will initiate the stub instantiation following the start of the application.
    You can then call the stub methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to call the stub methods, let’s add a simple REST endpoint. This will demonstrate
    how to use the charge service stub to call its `retrieve` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new `ChargeController.java` file for the REST controller in
    the `src/main/java/com/packts/modern/api/controller` directory and add the code
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java)'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have created a REST endpoint, `/charges`. This uses the `GrpcClient`
    instance to call the `retrieveAll()` RPC method of the `Charge` gRPC service using
    `ChargeServiceStub`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the response is converted into a JSON-formatted string using the `JsonFormat`
    class from the `protobuf-java-util` library and returned as a response. Generated
    JSON-formatted strings will also contain the fields with default values.
  prefs: []
  type: TYPE_NORMAL
- en: We are done with our development. Let’s now test the complete flow in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the gRPC service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure that your gRPC server is up and running before testing the client.
    It is assumed that the gRPC `api` project has been built and that its latest artifacts
    have been published to the local Maven repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure that your `api` project library is published in the local
    Maven repository because it is required by both the `server` and `client` projects.
    Skip to *step 2* if you have already published the library. Java should be set
    to version 17\. Execute the following commands from the `api` root project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'client project’s root directory (Java should be set to version 17):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '// calls the client service''s charges API endpoint$ curl http://localhost:8081/charges{  "charge":
    [{    "id": "cle9e9oam6gajkkeivjof5pploq89ncp",    "amount": 1000,    "amountCaptured":
    0,    …    "created": "1679924425",    "currency": "USD",    "customerId": "ab1ab2ab3ab4ab5",    "description":
    "Charge Description",    …    "receiptEmail": "receipt@email.com",    …    "status":
    "SUCCEEDED",    "sourceId": "0ovjn4l6crgp9apr79bhpefme4dok3qf"  }]}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A REST endpoint is used for demonstration purposes only. Similarly, you can
    use the gRPC client to call other services and their methods. gRPC is often used
    for inter-service communication, which is essential for microservice-based applications.
    However, it can also be used for web-based communication.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn a bit about microservices in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservice concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are self-contained lightweight processes that communicate over
    a network. Microservices provide narrowly focused APIs to their consumers. These
    APIs can be implemented using REST, gRPC, or events.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are not new—they have been around for many years. For example,
    *Stubby*, a general-purpose infrastructure based on RPC, was used in Google data
    centers in the early 2000s to connect several services with and across data centers.
  prefs: []
  type: TYPE_NORMAL
- en: They have seen a recent rise in popularity and visibility. Before microservices
    became popular, monolithic architectures were mainly used for developing on-premises
    and cloud-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: A monolithic architecture allows the development of different components, such
    as presentation, application logic, business logic, and **data access objects**
    (**DAOs**), and then you either bundle them together in an **enterprise archive**
    (**EAR**) or **web archive** (**WAR**) or store them in a single directory hierarchy
    (such as Rails or Node.js).
  prefs: []
  type: TYPE_NORMAL
- en: Many famous applications, such as Netflix, have been developed using a microservices
    architecture. Moreover, eBay, Amazon, and Groupon have evolved from monolithic
    architectures into microservices architectures. Nowadays, microservices-based
    application development is very common. The gRPC server that we have developed
    in this chapter could be called a microservice (obviously if you keep the scope
    of the server to either the `Source` service or `Charge` server).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at simple monolithic and microservices application designs
    in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will take a look at the different system designs, which
    are designed using a monolithic design, an SOA monolithic design, and a microservices
    design. Let’s discuss each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional monolithic design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram depicts the traditional monolithic application design.
    This design was widely used before SOA became popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Traditional monolithic application design](img/Figure_11.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Traditional monolithic application design
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional monolithic design, everything is bundled in the same archive
    (all the presentation code is bundled in with the presentation archive, the application
    logic goes into the application logic archive, and so on), regardless of how it
    all interacts with the database files or other sources.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic design with services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After SOA, applications started being developed based on services, where each
    component provides services to other components or external entities. The following
    diagram depicts a monolithic application with different services; here, services
    are being used with a presentation component. All services, the presentation component,
    or any other components are bundled together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Monolithic design with services](img/Figure_11.2_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Monolithic design with services
  prefs: []
  type: TYPE_NORMAL
- en: So, everything is bundled together in the form of EAR with a modules approach.
    A few SOA services may be deployed separately, but overall, it will be monolithic.
    However, the database is shared across the services.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following diagram depicts the microservices design. Here, each component
    is autonomous. Each component can be developed, built, tested, and deployed independently.
    Here, even the application’s UI component could also be a client and consume the
    microservices. For our example, the layer designed is used within the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Microservices design](img/Figure_11.3_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Microservices design
  prefs: []
  type: TYPE_NORMAL
- en: The API gateway provides an interface where different clients can access the
    individual services and solve various problems, such as what to do when you want
    to send different responses to different clients for the same service. For example,
    a booking service could send different responses to a mobile client (minimal information)
    and a desktop client (detailed information), providing different details to each,
    before providing something different again to a third-party client.
  prefs: []
  type: TYPE_NORMAL
- en: A response may require the fetching of information from two or more services.
  prefs: []
  type: TYPE_NORMAL
- en: Each API service will be developed and deployed as a separate process and communication
    among these will happen based on exposed APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a sample e-commerce app, you can divide the application based on domains
    and bounded context and then develop a separate microservice for each of the domains.
    The following is a brief list of the provided microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Billing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoicing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can develop each of these separately and use inter-process (inter-service)
    communication to stitch the solution together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored Protobuf and gRPC-based service implementation.
    You developed the gRPC server and then consumed its services by developing a gRPC
    client. You learned about unit-testing the gRPC server and handling exceptions
    for gRPC-based services, and you also learned about the basic concepts of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: You now have the skills to develop gRPC-based services (servers) and clients
    by defining the services using Protobuf.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about distributed logging and tracing in
    web services.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should you use gRPC for binary large object transfers via HTTP/2?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have implemented exception handling using `com.google.rpc.Status`. Can you
    do so without using this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `com.google.rpc.Status` and `io.grpc.Status`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because, unlike HTTP libraries, gRPC libraries also provide the following features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interaction with flow control at the application layer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cascading call cancellation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing and failover
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Yes, you can. You can use the metadata shown in the following code block. However,
    making use of `com.google.rpc.Status` allows you to use the `details` (with a
    type of `Any`) object, which can capture more information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`com.google.rpc.Status` can include details of the `Any` type, which can be
    used to provide more error details. `io.grpc.Status` does not have a field that
    contains the error details. You must rely on another class’s metadata to provide
    the error-related details, which may or may not contain only error specific information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Protobuf version 3 documentation: [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protobuf’s well-known types: [https://developers.google.com/protocol-buffers/docs/reference/google.protobuf](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical* *gRPC*: [https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
