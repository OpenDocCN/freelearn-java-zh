- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Exposing a RESTful API with Spring
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 暴露 RESTful API
- en: To implement REST APIs, in most chapters of this book, we are going to use **Spring
    Boot** . As it is a well-known and popular framework, it is very likely that you
    are familiar with it or have used it before.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 REST API，在本书的大部分章节中，我们将使用 **Spring Boot**。由于它是一个知名且流行的框架，你很可能熟悉它或之前使用过它。
- en: However, the general API design principles are easily transferable to other
    Java technologies. You will learn more about how we can apply these principles
    to other technologies in [*Chapter 11*](B21843_11.xhtml#_idTextAnchor310) .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通用的 API 设计原则很容易转移到其他 Java 技术。你将了解我们如何将这些原则应用到其他技术中，请参阅[*第 11 章*](B21843_11.xhtml#_idTextAnchor310)。
- en: In this chapter, we will discuss the process of designing a RESTful API. We
    will also concentrate on the practical implementation of the API using the Spring
    Framework, a popular choice for building RESTful APIs. By the end of this chapter,
    you will have the knowledge to design and create a RESTful API following the best
    practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论设计 RESTful API 的过程。我们还将专注于使用 Spring 框架（构建 RESTful API 的流行选择）的实际 API
    实现。到本章结束时，你将具备根据最佳实践设计和创建 RESTful API 的知识。
- en: 'In this chapter, we will be covering these topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Designing the product API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计产品 API
- en: API implementation using Spring Boot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 实现 API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will implement an example product API. To be able to follow
    along and use the code examples as they are printed in the book, you should have
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现一个示例产品 API。为了能够跟随并使用书中打印的代码示例，你应该具备以下条件：
- en: Intermediate knowledge of the Java language and platform
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Java 语言和平台有中级知识
- en: At least a basic knowledge of Spring Boot or a similar framework
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少对 Spring Boot 或类似框架有基本了解
- en: Java 21 and Maven 3.9.0 installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21 和 Maven 3.9.0 已安装
- en: Basic knowledge of a tool for calling REST APIs, such as `curl` , is recommended
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐对调用 REST API 的工具（如 `curl`）有基本了解
- en: In this chapter, we are going to apply REST principles to create our API; you
    can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2)
    .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将应用 REST 原则来创建我们的 API；你可以在 GitHub 上找到本章的代码，网址为 [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2)。
- en: Designing the product API
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计产品 API
- en: The product API we will develop is an API for managing products. Our API will
    offer various operations, which will be detailed during the design phase.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发的产品 API 是用于管理产品的 API。我们的 API 将提供各种操作，这些操作将在设计阶段详细说明。
- en: Spending an adequate amount of time on properly designing the API before starting
    to write the code can save a lot of time later, preventing costly and risky refactoring.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写代码之前，花足够的时间正确设计 API 可以在以后节省大量时间，防止昂贵的和风险大的重构。
- en: 'The design stage should include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计阶段应包括以下内容：
- en: '**Defining the requirements** : Understanding the use cases and who will use
    the API is essential to creating an API that contains everything that is needed
    and nothing more. A good understanding of the requirements lets you avoid breaking
    changes for as long as possible. In [*Chapter 5*](B21843_05.xhtml#_idTextAnchor116)
    , we will talk about how you can evolve your API and ensure backward compatibility.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义需求**：了解用例和谁将使用 API 对于创建包含所需一切且不包含多余内容的 API 至关重要。对需求有良好的理解可以使你尽可能长时间避免破坏性更改。在第
    [*5 章*](B21843_05.xhtml#_idTextAnchor116) 中，我们将讨论你如何演进你的 API 并确保向后兼容性。'
- en: '**Identifying the resources** : Resources are usually domain entities such
    as users or products. Relationships between multiple entities are often represented
    by a hierarchical URI structure.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别资源**：资源通常是领域实体，如用户或产品。多个实体之间的关系通常通过分层 URI 结构表示。'
- en: '**Defining the resource structure** : After identifying the resources, it is
    necessary to define the resource fields and relationships.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义资源结构**：在识别资源之后，有必要定义资源字段和关系。'
- en: '**Designing the endpoints** : With the resources and the domain defined, the
    next step is to identify the endpoints that should be exposed, how they should
    be exposed, and what HTTP methods should be used for what purpose.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计端点**：在定义了资源和域之后，下一步是确定应该公开哪些端点，如何公开它们，以及应该使用哪些HTTP方法来达到什么目的。'
- en: '**Error handling** : Having clear error responses with standard error codes
    helps the client to react to the error correctly.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：具有标准错误代码的清晰错误响应有助于客户端正确地响应错误。'
- en: '**Security** : It is essential to prevent malicious actors from accessing resources
    that they are not authorized to. You will learn more about API security in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176) .'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：防止恶意行为者访问他们未经授权的资源是至关重要的。你将在[*第7章*](B21843_07.xhtml#_idTextAnchor176)中了解更多关于API安全性的内容。'
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: An endpoint is a specific URI that enables clients to interact with a server
    via an API to perform a specific function. It represents an operation that can
    be executed using a unique path and the corresponding HTTP method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 端点是一个特定的URI，它使客户端能够通过API与服务器交互以执行特定功能。它代表了一个可以使用唯一路径和相应的HTTP方法执行的操作。
- en: Based on these design steps, you can proceed directly to implementing the API
    in code using Java. This is called the **code-first approach** , usually representing
    the fastest path to a working API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些设计步骤，您可以直接使用Java在代码中实现API。这被称为**先代码**方法，通常代表通往工作API的最快途径。
- en: A different approach, called **specification-first** , will be explained in
    [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076) .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为**先规范**的不同方法将在[*第3章*](B21843_03.xhtml#_idTextAnchor076)中解释。
- en: Defining the requirements
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义需求
- en: 'The API requirements can be divided into functional and non-functional:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: API需求可以分为功能性和非功能性：
- en: '**Functional requirements** : These describe the specific functions and features
    that the software must perform. Examples include data validation, data processing,
    and system interactions.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能性需求**：这些描述了软件必须执行的具体功能和特性。例如，数据验证、数据处理和系统交互。'
- en: '**Non-functional requirements** : These are also known as quality attributes
    or software quality requirements that specify the qualities or characteristics
    that the software must possess. Examples include performance (response time and
    throughput), reliability, security, scalability, usability, and maintainability.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求**：这些也被称为质量属性或软件质量要求，它们指定了软件必须具备的品质或特性。例如，包括性能（响应时间和吞吐量）、可靠性、安全性、可伸缩性、可用性和可维护性。'
- en: In this chapter, we will only work on the functional requirements. We will get
    to some of the non-functional requirements in *Chapters 7 and 10* .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只关注功能性需求。我们将在*第7章和第10章*中了解到一些非功能性需求。
- en: 'As mentioned earlier, our example REST API will be a product API and will have
    the following requirements:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的示例REST API将是一个产品API，并将具有以下要求：
- en: '**Product creation** : The API should allow users to create new products by
    providing necessary information such as the SKU (Stock Keeping Unit, in the context
    of this book it is the unique product ID), name, description, and price'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品创建**：API应该允许用户通过提供必要的信息（如SKU（库存单位，在本书中是指唯一的商品ID）、名称、描述和价格）来创建新产品'
- en: '**Product retrieval** : Users should be able to retrieve information about
    all products available in the system'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品检索**：用户应该能够检索有关系统中所有产品的信息'
- en: '**Product details** : The API should provide endpoints to retrieve detailed
    information about a specific product, identified by its SKU'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品详情**：API应该提供端点以检索有关特定产品的详细信息，该产品通过其SKU（库存单位，在本书中是指唯一的商品ID）进行标识'
- en: '**Product update** : Users should be able to update existing product information,
    such as name, description, or price'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品更新**：用户应该能够更新现有产品信息，例如名称、描述或价格'
- en: '**Product description update** : The API should provide an endpoint to update
    the description only'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品描述更新**：API应该提供一个端点以仅更新描述'
- en: '**Product deletion** : The API should allow users to delete a product from
    the system, identified by its SKU'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**产品删除**：API应该允许用户通过其SKU从系统中删除产品'
- en: '**Unique SKU constraint** : The API should enforce a constraint to ensure that
    each product has a unique SKU, preventing duplicate products with the same identifier'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一的SKU约束**：API应该强制执行约束以确保每个产品都有一个唯一的SKU，防止具有相同标识符的重复产品'
- en: Now that we have identified the requirements, the next step is to identify our
    resources.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了需求，下一步就是确定我们的资源。
- en: Identifying the resources
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别资源
- en: A REST API can have one or more resources, and it can also have a hierarchical
    URI structure. A hierarchical URI structure is a way of organizing resources in
    a URL hierarchy that reflects the relationships between those resources. In a
    hierarchical URI structure, resources are arranged in a tree-like format, where
    each segment of the URL represents a level of the hierarchy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: REST API可以有一个或多个资源，也可以有一个分层URI结构。分层URI结构是一种在URL分层中组织资源的方式，反映了这些资源之间的关系。在分层URI结构中，资源以树状格式排列，其中URL的每个部分代表层次结构的一个级别。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: URI or URL?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: URI还是URL？
- en: 'In the context of REST APIs, we often use the acronyms **URI** (which stands
    for **Uniform Resource Identifier** ) and **URL** (which stands for **Uniform
    Resource Locator** ) interchangeably. To be precise, URLs are a subset of URIs.
    There is a second subset of URIs called **URNs** (which stands for **Uniform Resource
    Names** ). The advantage of a URL over a URN is that besides being a unique identifier
    of the resource, it also contains information that can be used to locate and access
    the resource: protocol, hostname, and path. The path part of a URL supports a
    hierarchical structure such as the sequence of folders and a filename that you
    know from filesystem paths.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST API的上下文中，我们经常互换使用缩写**URI**（代表**统一资源标识符**）和**URL**（代表**统一资源定位符**）。为了精确起见，URL是URI的一个子集。URI的第二个子集称为**URNs**（代表**统一资源名称**）。与URN相比，URL的优势在于，除了是资源的唯一标识符外，它还包含可用于定位和访问资源的信息：协议、主机名和路径。URL的路径部分支持类似于从文件系统路径中知道的一系列文件夹和文件名的分层结构。
- en: 'Let’s take the following as an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下列为例：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this URI, we have the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个URI中，我们有以下内容：
- en: '[https://example.com](https://example.com) is the base URL'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://example.com](https://example.com)是基本URL'
- en: '`/blog` represents the top-level resource, indicating that we are accessing
    the blog section of a website'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/blog`代表顶级资源，表示我们正在访问网站的博客部分'
- en: '`/posts` is a sub-resource under the `/blog` resource, representing a collection
    of blog posts'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/posts`是`/blog`资源下的子资源，代表一系列博客文章'
- en: '`/12` is a specific blog post identified by its unique identifier'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/12`是一个通过其唯一标识符识别的具体博客文章'
- en: In our case, we have only one resource, which is the product, so we have only
    `/products` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只有一个资源，那就是产品，所以我们只有`/products`。
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Resources should be nouns; they should not be verbs. For example, `/products/create`
    should not be used; instead, use the corresponding HTTP method for this action.
    This is essential for adhering to level 2 of the Richardson Maturity Model.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 资源应该是名词；它们不应该是动词。例如，不应使用`/products/create`；相反，应使用与此动作对应的HTTP方法。这对于遵守Richardson成熟度模型的第2级至关重要。
- en: In English, many verbs can be used as nouns too, for example, `/products/quote`
    . When we make a `POST` request to this resource, it means *create a quote* .
    The verb part of the sentence is represented by the correct HTTP method.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，许多动词也可以用作名词，例如，`/products/quote`。当我们向这个资源发送`POST`请求时，意味着*创建报价*。句子的动词部分由正确的HTTP方法表示。
- en: Resources map to business entities and the API usually works with multiple entities
    of the same type. When creating or listing resources (entities) of a particular
    type, we are working with a collection of objects. For collection resources, we
    use the plural form of the noun – for example, `products` instead of `product`
    because we want to support operations on the collection of products.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 资源映射到业务实体，API通常与同一类型的多个实体一起工作。当创建或列出特定类型的资源（实体）时，我们正在处理一个对象集合。对于集合资源，我们使用名词的复数形式——例如，`products`而不是`product`，因为我们希望支持对产品集合的操作。
- en: '![img](img/Information_Box_Icon.png)![img](img/Information_Box_Icon.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)![img](img/Information_Box_Icon.png)'
- en: RFC 3986 defines a URI as a compact sequence of characters that identifies an
    abstract or physical resource. According to RFC 1738, a URL is a specific type
    of URI that represents the location of a resource accessible via the internet.
    Thus, a URI can be further classified as a locator, a name, or both, with the
    term URL referring to the subset of URIs. This means that all URLs are URIs, but
    not all URIs are URLs. RFC 2141 further defines URNs as another type of URI that
    names a resource in a persistent, location-independent manner.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 3986定义URI为一个字符序列，用于标识一个抽象或物理资源。根据RFC 1738，URL是URI的一种特定类型，表示可通过互联网访问的资源的位置。因此，URI可以进一步分类为定位符、名称或两者兼具，其中术语URL指的是URI的子集。这意味着所有URL都是URI，但并非所有URI都是URL。RFC
    2141进一步定义URN为另一种URI类型，以持久、位置无关的方式命名资源。
- en: Now that we have identified the resources, the next step is to define the resource
    structure.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了资源，下一步是定义资源结构。
- en: Defining the resource structure
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义资源结构
- en: After identifying the resources, we should identify the attributes of the resources
    and any relationships that are important in the API. The attributes represent
    the data fields associated with the resource. Consider the data types, constraints,
    and any required or optional attributes for each resource. A relationship indicates
    how the resources are related to each other and whether they have any hierarchical
    or nested relationships. For example, a user may have multiple orders associated
    with them, or a product may belong to a specific category.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定资源后，我们应该确定资源的属性以及API中任何重要的关系。属性代表与资源相关的数据字段。考虑数据类型、约束以及每个资源所需的或可选的属性。关系表示资源之间的关系以及它们是否有层次或嵌套关系。例如，一个用户可能有多个与之关联的订单，或者一个产品可能属于特定的类别。
- en: 'In our case, we have only one resource, which is the product, which should
    have these attributes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们只有一个资源，即产品，它应该具有以下属性：
- en: '`name` : The name of the product'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：产品的名称'
- en: '`sku` : The unique key of the product'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKU`：产品的唯一键'
- en: '`description` : A description of the product'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`：产品的描述'
- en: '`price` : The price of the product'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`：产品的价格'
- en: 'We can also define the rules for these attributes in this step:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这一步定义这些属性的规则：
- en: '`name` : Required field, with a string with a length between 3 and 255 characters'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：必填字段，长度在3到255个字符之间的字符串'
- en: '`sku` : Required field, with the pattern AA99999'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKU`：必填字段，格式为AA99999'
- en: '`description` : Required field, with a string with a length between 10 and
    255 characters'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`：必填字段，长度在10到255个字符之间的字符串'
- en: '`price` : Required field, with a value greater than 0'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`：必填字段，值必须大于0'
- en: After this step, we can design the endpoints.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，我们可以设计端点。
- en: Designing the endpoints
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计端点
- en: To design the endpoints, it is important to know the HTTP methods and the HTTP
    status codes. Before talking about this, though, we should go one step back and
    understand how it started.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论HTTP方法和HTTP状态码之前，我们应该回顾一步，了解它是如何开始的。
- en: The HTTP methods and principles we are going to share here follow the guidelines
    from Microsoft mentioned in the previous chapter. Any REST guidelines should adhere
    to the internet standard known as RFC 9110, the updated version of RFC 2616. **RFC**
    stands for **Request for Comments** . RFC specifies HTTP, TCP, IP, SMTP, and many
    other vital internet protocols. Fielding’s dissertation, titled *Architectural
    Styles and the Design of Network-based Software Architectures* , was an important
    source for RFC 2616, defining the HTTP/1.1 protocol.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要分享的HTTP方法和原则遵循上一章中提到的微软的指南。任何REST指南都应该遵守互联网标准RFC 9110，即RFC 2616的更新版本。**RFC**代表**请求评论**。RFC指定了HTTP、TCP、IP、SMTP以及许多其他重要的互联网协议。Fielding的论文，题为《架构风格和网络软件架构设计》是RFC
    2616的重要来源，定义了HTTP/1.1协议。
- en: HTTP methods (verbs)
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP方法（动词）
- en: 'HTTP defines several methods (also known as verbs) that indicate the action
    to be performed on a resource. The most used HTTP methods in RESTful APIs are
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP定义了几个方法（也称为动词），用于指示对资源要执行的操作。在RESTful API中最常用的HTTP方法是以下这些：
- en: '`GET` : The `GET` method requests are used to retrieve resource representations,
    and they should not alter the server state. They are safe and idempotent, meaning
    they do not have any side effects on the server and can be repeated without changing
    the server state. (Think about the `get` method of a `Map` in Java.)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：`GET` 方法请求用于检索资源表示，它们不应改变服务器状态。它们是安全的和幂等的，这意味着它们对服务器没有副作用，并且可以重复执行而不改变服务器状态。（想想
    Java 中 `Map` 的 `get` 方法。）'
- en: '`POST` : The `POST` method requests are used to create new resources or generally
    submit data to be processed by the server. They are non-idempotent, meaning that
    each request is unique and may have side effects on the server. (Think about the
    `++` operator in Java; the result will be different if it is evaluated multiple
    times.)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：`POST` 方法请求用于创建新资源或通常提交数据由服务器处理。它们是非幂等的，这意味着每个请求都是唯一的，并且可能对服务器有副作用。（想想
    Java 中的 `++` 操作符；如果多次评估，结果将不同。） '
- en: '`PUT` : These requests are typically used to create or update the entire representation
    of a resource. They are idempotent, meaning that sending the same request multiple
    times should have the same effect as sending it once. (Think about the `put` method
    of a `Map` in Java.)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：这些请求通常用于创建或更新资源的整个表示。它们是幂等的，这意味着发送相同的请求多次应该与发送一次的效果相同。（想想 Java 中 `Map`
    的 `put` 方法。）'
- en: '`PATCH` : This is like `PUT` but used to apply partial modifications to a resource.
    It is often used when you want to update only certain fields of a resource. (Think
    about a setter method of a Java Bean/POJO.)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：这与 `PUT` 类似，但用于对资源应用部分修改。它通常用于只想更新资源的一定字段。（想想 Java Bean/POJO 的 setter
    方法。）'
- en: '`DELETE` : This method is used to remove a resource from the server. The method
    is idempotent, meaning that sending the same request multiple times should result
    in the same state on the server.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此方法用于从服务器删除资源。方法是幂等的，这意味着发送相同的请求多次应该导致服务器上相同的状态。'
- en: HTTP status codes
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: 'HTTP status codes are three-digit numbers that a server sends back to the client
    after receiving a request. They indicate the outcome of the request and provide
    information about the status of the server or the requested resource. All HTTP
    status codes are grouped into the following categories:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码是服务器在收到请求后发送给客户端的三位数。它们表示请求的结果，并提供有关服务器或请求资源状态的信息。所有 HTTP 状态码都被分为以下类别：
- en: '`1xx Informational` : This indicates that the request was received and is being
    processed.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1xx 信息性`：这表示请求已被接收并正在处理。'
- en: '`2xx Success` : This indicates that the request was received, understood, and
    processed successfully by the server.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2xx 成功`：这表示请求已被接收、理解并成功处理。'
- en: '`3xx Redirection` : This indicates that further action is needed to complete
    the request. The client may need to redirect to a different URI.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3xx 重定向`：这表示需要进一步的操作来完成请求。客户端可能需要重定向到不同的 URI。'
- en: '`4xx Client Error` : This indicates that there was an error in the client’s
    request.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4xx 客户端错误`：这表示客户端请求中存在错误。'
- en: '`5xx Server Error` : This indicates that there was an error on the server side
    while processing the request.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5xx 服务器错误`：这表示在处理请求时服务器端出现错误。'
- en: Now that we understand HTTP methods and statuses, we can define the API endpoints.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 HTTP 方法和服务状态，我们可以定义 API 端点。
- en: Defining the endpoints for our API
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义我们 API 的端点
- en: Let’s define the endpoints for the resource we identified in the previous step.
    We will use the HTTP methods with the `products` resources to ensure we can perform
    all the necessary operations as outlined in the requirements phase.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义上一步中确定的资源的端点。我们将使用 `products` 资源上的 HTTP 方法来确保我们可以执行需求阶段概述的所有必要操作。
- en: GET /products
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GET /products
- en: This endpoint will be responsible for returning a list of products. We should
    return a `200 (ok)` HTTP status with the products.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点将负责返回产品列表。我们应该返回带有产品的 `200 (ok)` HTTP 状态。
- en: PUT /products/{id}
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PUT /products/{id}
- en: This endpoint will be responsible for creating or updating the product. `PUT`
    is an idempotent method, so we can call it many times and the result will be the
    same. In case of success, we should return `201 (created)` if the product doesn’t
    exist and `200` if the product already exists.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点将负责创建或更新产品。`PUT` 是幂等的，因此我们可以多次调用它，结果将相同。在成功的情况下，如果产品不存在，我们应该返回 `201 (created)`，如果产品已存在，则返回
    `200`。
- en: We could also return `202 (accepted)` if the product will be processed in the
    future as an asynchronous task, which is not the case here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果产品将在未来作为异步任务处理，我们可以返回 `202 (已接受)`，但这在这里不是情况。
- en: If we decided to use the `POST` method, we would need to choose between throwing
    an exception if the product already exists – this exception could be `409 (conflict)`
    – or creating another product. In our case, because the SKU is not generated by
    the application, it is an attribute passed to the API, and we cannot have two
    products with the same SKU, so we will need to return `409` and have another endpoint
    that would be responsible for updating the resource as it is a requirement. Instead
    of doing this, we can use the `PUT` method, which can create or update the resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定使用 `POST` 方法，我们需要在抛出异常（这个异常可能是 `409 (冲突)`）如果产品已经存在，或者创建另一个产品之间做出选择。在我们的情况下，因为
    SKU 不是由应用程序生成的，它是一个传递给 API 的属性，我们不能有两个具有相同 SKU 的产品，所以我们需要返回 `409` 并有一个负责更新资源的另一个端点，因为这是一个要求。而不是这样做，我们可以使用
    `PUT` 方法，它可以创建或更新资源。
- en: According to RFC 9110, Section 9.3.4, “The fundamental difference between the
    POST and PUT methods is highlighted by the different intent for the enclosed representation.
    The target resource in a POST request is intended to handle the enclosed representation
    according to the resource’s own semantics, whereas the enclosed representation
    in a PUT request is defined as replacing the state of the target resource. Hence,
    the intent of PUT is idempotent and visible to intermediaries, even though the
    exact effect is only known by the origin server”.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 RFC 9110，第 9.3.4 节，“POST 和 PUT 方法之间的基本区别在于对所包含表示的不同意图。POST 请求中的目标资源旨在根据资源自身的语义处理所包含的表示，而
    PUT 请求中的所包含的表示被定义为替换目标资源的状态。因此，PUT 的意图是幂等的，并且对中间代理可见，尽管确切的效果只有原始服务器才知道”。
- en: Proper interpretation of a PUT request presumes that the user agent knows which
    target resource is desired. To get a better insight, please refer to [https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4](https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4)
    .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正确解释 PUT 请求假设用户代理知道所需的哪个目标资源。为了获得更好的洞察，请参阅 [https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4](https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4)
    。
- en: DELETE /products/{id}
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DELETE /products/{id}
- en: This endpoint should remove the product. We can return `204 (no content)` in
    case the product is removed. Even if the product does not exist, we can return
    `204` , as the method is idempotent, meaning that sending the same request multiple
    times should result in the same state on the server.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点应删除产品。如果产品被删除，我们可以返回 `204 (无内容)`。即使产品不存在，我们也可以返回 `204`，因为该方法具有幂等性，意味着发送相同的请求多次应该在服务器上产生相同的状态。
- en: PATCH /products/{id}
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PATCH /products/{id}
- en: This endpoint should be used to update the description of the product. As it
    is a partial update of a resource, it is recommended to use `PATCH` . The `PATCH`
    method was introduced in RFC 5789 as a partial update that doesn’t need to be
    idempotent. If the product does not exist, we can return a `404 (Not found)` error.
    In case of success, we can return the updated product data and a `200` HTTP status.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用此端点来更新产品的描述。由于这是一个资源的部分更新，建议使用 `PATCH`。`PATCH` 方法在 RFC 5789 中被引入，作为不需要幂等的部分更新。如果产品不存在，我们可以返回
    `404 (未找到)` 错误。在成功的情况下，我们可以返回更新后的产品数据和 `200` HTTP 状态码。
- en: GET /products/{id}
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GET /products/{id}
- en: This endpoint is responsible for returning the details of a single product by
    the ID. If the product does not exist, we can return a `404 (Not found)` error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点负责通过 ID 返回单个产品的详细信息。如果产品不存在，我们可以返回 `404 (未找到)` 错误。
- en: In case of success, we should return the product representation and a `200`
    HTTP status.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们应该返回产品表示和 `200` HTTP 状态码。
- en: Now that we have defined our endpoints, let’s see the possible errors that we
    may encounter and how we can prepare for them effectively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的端点，让我们看看我们可能会遇到的可能错误以及我们如何有效地为它们做准备。
- en: Error handling
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: Preparing for common issues by defining possible errors can help us implement
    a more reliable API. We have already discussed some errors in the previous step;
    however, let’s get deep into it and see the most common HTTP status codes in the
    `4xx` range.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义可能的错误来准备常见问题可以帮助我们实现更可靠的 API。我们已经在之前的步骤中讨论了一些错误；然而，让我们深入探讨并看看 `4xx` 范围内最常见的
    HTTP 状态码。
- en: 'The most common HTTP status codes in the `4xx` range, which indicates client
    errors, are the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`4xx`范围内的最常见HTTP状态码，表示客户端错误，如下所示：'
- en: '`400 Bad Request` : This status code indicates that the server could not understand
    the client’s request due to invalid syntax or a malformed request message.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 请求错误`：此状态码表示服务器无法理解客户端的请求，因为请求语法无效或请求消息格式不正确。'
- en: '`401 Unauthorized` : This status code indicates that the client needs to authenticate
    itself to access the requested resource. It typically occurs when the client fails
    to provide proper authentication credentials or access tokens.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`401 未授权`：此状态码表示客户端需要验证自身才能访问请求的资源。通常发生在客户端未能提供适当的认证凭据或访问令牌时。'
- en: '`403 Forbidden` : This status code indicates that the client is authenticated,
    but it does not have permission to access the requested resource. It may be due
    to insufficient permissions or access control restrictions imposed by the server.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`403 禁止访问`：此状态码表示客户端已通过认证，但没有权限访问请求的资源。可能是因为权限不足或服务器施加的访问控制限制。'
- en: '`404 Not Found` : This status code indicates that the server could not find
    the requested resource. It is commonly used to indicate that the URI provided
    by the client does not correspond to any known resource on the server.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`404 未找到`：此状态码表示服务器找不到请求的资源。它通常用于表示客户端提供的URI不对应于服务器上的任何已知资源。'
- en: '`405 Method Not Allowed` : This status code indicates that the HTTP method
    used by the client is not supported for the requested resource. For example, trying
    to use a `POST` request on a resource that only supports `GET` requests would
    result in a `405 Method Not Allowed` response.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`405 方法不允许`：此状态码表示客户端使用的HTTP方法不支持请求的资源。例如，尝试对一个只支持`GET`请求的资源使用`POST`请求将导致`405
    方法不允许`响应。'
- en: '`409 Conflict` : This status code indicates that the request could not be completed
    because of a conflict with the current state of the resource. It typically occurs
    when the client attempts to create or update a resource but the server detects
    a conflict with the resource’s current state; for example, when two requests attempt
    to update the same product’s details concurrently, a `409` status can be returned
    if one request’s changes conflict with the other due to a version mismatch.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`409 冲突`：此状态码表示由于与资源的当前状态冲突，请求无法完成。通常发生在客户端尝试创建或更新资源，但服务器检测到与资源当前状态的冲突；例如，当两个请求同时尝试更新同一产品的详细信息时，如果由于版本不匹配，一个请求的更改与另一个请求冲突，则可能会返回`409`状态码。'
- en: '`422 Unprocessable Entity` : This status code indicates that the server understands
    the request but cannot process it due to semantic errors or validation failures
    in the request payload. It is often used to indicate validation errors in the
    request data, for example, trying to buy a product that is out of stock.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`422 无法处理实体`：此状态码表示服务器理解了请求，但由于请求负载中的语义错误或验证失败而无法处理它。它通常用于指示请求数据中的验证错误，例如，尝试购买缺货的产品。'
- en: '`429 Too Many Requests` : This status code indicates that the client has exceeded
    the rate limit or quota imposed by the server for the number of requests allowed
    within a certain time period. It is often used to prevent abuse or excessive usage
    of server resources by limiting the rate of incoming requests from a single client
    or IP address. This error is typically handled by an API gateway using a rate-limiting
    strategy, as we’ll cover in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135) .'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`429 请求过多`：此状态码表示客户端在特定时间段内超过了服务器对允许请求数量的限制或配额。它通常用于通过限制单个客户端或IP地址的请求速率来防止滥用或过度使用服务器资源。此错误通常由使用速率限制策略的API网关处理，正如我们将在[*第6章*](B21843_06.xhtml#_idTextAnchor135)中介绍的那样。'
- en: 'In our API implementation, we should be able to handle some errors:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的API实现中，我们应该能够处理一些错误：
- en: When a product does not exist, we should return `404 Not Found`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当产品不存在时，我们应该返回`404 未找到`
- en: When the payload does not meet the requirements, for example, if a negative
    number is provided for the product price, we should return `400 Bad Request` with
    the details
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有效载荷不符合要求时，例如，如果产品价格提供了负数，我们应该返回带有详细信息的`400 Bad Request`
- en: Some error conditions (for example, an unsupported method leading to `405 Method
    Not Allowed` ) are handled automatically by the framework.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误条件（例如，导致`405 方法不允许`的不支持的方法）由框架自动处理。
- en: The security-related `401` and `403` HTTP status codes will be covered in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176) .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与安全相关的 `401` 和 `403` HTTP 状态码将在 [*第7章*](B21843_07.xhtml#_idTextAnchor176) 中介绍。
- en: In the upcoming chapters, we will take on security and documentation as separate
    topics and address them head-on. However, for the development iteration represented
    by this chapter, we have completed our design phase. Moving forward, we will focus
    on implementing our product API and ensuring that we can meet the requirements
    that we defined.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将把安全和文档作为单独的主题进行讨论，并直接解决它们。然而，对于本章所代表的开发迭代，我们已经完成了设计阶段。向前推进，我们将专注于实现我们的产品API，并确保我们能够满足我们定义的要求。
- en: API implementation using Spring Boot
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 实现API
- en: Spring Boot is the most popular Java framework for microservice applications.
    It provides embedded servlet containers such as **Tomcat** , **Jetty** , and **Undertow**
    . Embedding a container allows you to package your application as an executable
    JAR file that can be run directly without needing to deploy your application to
    a separate application server. We are going to use Tomcat as it is the default.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 是最受欢迎的用于微服务应用的 Java 框架。它提供了嵌入式Servlet容器，如 **Tomcat**、**Jetty** 和
    **Undertow**。嵌入容器允许您将应用程序打包为可执行的JAR文件，可以直接运行，无需将应用程序部署到单独的应用服务器。我们将使用Tomcat，因为它是默认的。
- en: Our application will provide some endpoints and will use an SQL database. We
    will use **H2** , which is a lightweight and open source database. It can function
    as both an in-memory and filesystem database, making it easily usable in development
    environments without the need for additional infrastructure.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将提供一些端点并使用 SQL 数据库。我们将使用 **H2**，这是一个轻量级和开源的数据库。它既可以作为内存数据库，也可以作为文件系统数据库，这使得它在开发环境中易于使用，无需额外的基础设施。
- en: 'We are going to use a Spring Data dependency to integrate with the persistence
    layer, but since this is not the focus of the book, we won’t delve deep into it.
    We recommend the book *Persistence Best Practices for Java Applications, by Otávio
    Santana and Karina Varela, Packt Publishing* , which talks more about the persistence
    layer. To add the Spring Data dependency, include the following entry in your
    `pom.xml` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data 依赖项来集成持久层，但由于这不是本书的重点，我们不会深入探讨。我们推荐由 Otávio Santana 和 Karina
    Varela 编写的书籍《Java应用程序持久化最佳实践》，Packt 出版，该书更多地讨论了持久层。要添加 Spring Data 依赖项，请在您的 `pom.xml`
    文件中包含以下条目：
- en: '[PRE1]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As our API is a web application, we are also going to use Spring Web to create
    our REST endpoints and Bean Validation to validate the user input, which we are
    going to talk about later in this chapter. We will use the **Clean Architecture**
    ( [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
    ) design for our API.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的API是一个Web应用程序，我们还将使用Spring Web来创建我们的REST端点，并使用Bean Validation来验证用户输入，我们将在本章后面讨论这一点。我们将使用
    **清洁架构**（[https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)）设计我们的API。
- en: Clean Architecture was created by Robert C. Martin, who was influenced by other
    well-known architectures, such as the Onion Architecture by Jeffrey Palermo and
    Hexagonal Architecture (a.k.a. ports and adapters) by Alistair Cockburn.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构是由 Robert C. Martin 创建的，他受到了其他知名架构的影响，例如Jeffrey Palermo的洋葱架构和Alistair Cockburn的六边形架构（也称为端口和适配器）。
- en: 'Clean Architecture shares a similar goal with these other architectures: the
    separation of concerns by dividing the software into layers. The key distinction
    of Clean Architecture is its clear definition of layers. While other architectures
    provide less precise layer definitions, Clean Architecture distinctly defines
    four layers, each with specific roles and responsibilities.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构与其他这些架构有相似的目标：通过将软件划分为层来分离关注点。清洁架构的关键区别在于其对层的清晰定义。虽然其他架构提供了不太精确的层定义，但清洁架构明确地定义了四个层，每个层都有特定的角色和责任。
- en: 'We are going to use Clean Architecture because its multiple layers allow for
    a clear separation of concerns, facilitating better organization and understandability.
    *Figure 2.1* shows the layers defined by Clean Architecture:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用清洁架构，因为其多层结构允许清晰的关注点分离，从而促进更好的组织和可理解性。*图2.1*显示了清洁架构定义的层：
- en: '![Figure 2.1 – Clean Architecture layers](img/B21843_02_1.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 清洁架构层](img/B21843_02_1.png)'
- en: Figure 2.1 – Clean Architecture layers
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 清洁架构层
- en: 'Let’s break down each of these layers:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些层：
- en: '**Entities** : This layer contains the business entities or domain objects
    of the application.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：这一层包含应用程序的业务实体或域对象。'
- en: '**Use cases** : This layer contains the application-specific business logic
    or use cases. This layer represents the application’s behavior in terms of the
    actions or operations that users can perform.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：这一层包含特定于应用程序的业务逻辑或用例。这一层从用户可以执行的动作或操作的角度来表示应用程序的行为。'
- en: '**Interface adapters** : This layer is responsible for adapting the application’s
    internal representation to external interfaces such as **user interfaces** ( **UIs**
    ), REST APIs, databases, or third-party services.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配器**：这一层负责将应用程序的内部表示适配到外部接口，如**用户界面**（**UIs**）、REST API、数据库或第三方服务。'
- en: '**Frameworks and drivers** : This layer includes libraries, frameworks, and
    infrastructure code that handle external concerns such as UI rendering, database
    access, web servers, and external APIs.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和驱动程序**：这一层包括处理外部关注点（如UI渲染、数据库访问、Web服务器和外部API）的库、框架和基础设施代码。'
- en: 'In our application, we are going to use only three layers: entities, use cases,
    and interface adapters. This is because for our application, we decided we do
    not want to decouple from the Spring Framework completely. In our case, we prefer
    having direct access to the many useful features the Spring Framework provides.
    We accept coupling with the framework while reducing the complexity of creating
    a layer to separate it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将只使用三个层：实体、用例和接口适配器。这是因为对于我们的应用程序，我们决定我们不想完全从Spring框架中解耦。在我们的情况下，我们更喜欢直接访问Spring框架提供的许多有用功能。我们接受与框架的耦合，同时减少创建一个层来将其分离的复杂性。
- en: The layers are defined to achieve loose coupling, ease of maintenance, and reusability.
    Robert C. Martin says that we can have more layers, and these layers are only
    schematic. The main principle of layered architectures is to ensure that dependencies
    cross the boundaries in only one direction; an inner layer should not depend on
    an outer layer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 层的定义旨在实现松散耦合、易于维护和可重用。罗伯特·C·马丁说，我们可以有更多的层，这些层只是示意图。分层架构的主要原则是确保依赖关系只在一个方向上跨越边界；内层不应依赖于外层。
- en: Now that we have defined the architecture and also the technologies, let’s build
    our product API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了架构和所用的技术，让我们构建我们的产品API。
- en: Creating the endpoints of our product API
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们产品API的端点
- en: 'As mentioned previously, to create our product API, we are going to use Spring
    Boot. We recommend using the latest version of Spring and Java (JDK); we will
    be using the following versions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了创建我们的产品API，我们将使用Spring Boot。我们建议使用最新的Spring和Java（JDK）版本；我们将使用以下版本：
- en: Java 21
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 21
- en: Spring Boot 3.2.5
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 3.2.5
- en: 'Before starting to create our API, we will define an interface with all the
    expected endpoints:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建我们的API之前，我们将定义一个包含所有预期端点的接口：
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This “ `ProductsAPI` " interface contains all the expected endpoints defined
    in the design step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“`ProductsAPI`”接口包含了在设计步骤中定义的所有预期端点。
- en: 'Because we are following clean architecture guidelines, we defined three **data
    transfer objects** ( **DTOs** ) for input and output: `ProductOutput` , `ProductInput`
    , and `ProductDescriptionInput` . Utilizing these DTOs enables us to modify them
    without affecting our domain classes.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循了清洁架构指南，我们为输入和输出定义了三个**数据传输对象**（**DTOs**）：`ProductOutput`、`ProductInput`和`ProductDescriptionInput`。利用这些DTO，我们可以修改它们而不会影响我们的域类。
- en: 'To create our product API, we will have to define a Spring controller. This
    class will be managed by Spring to handle requests to our endpoints. Our API class
    will implement the `ProductsApi` interface, and we will need to add two annotations,
    `@RestController` and `@RequestMapping("/api/products")` :'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的产品API，我们需要定义一个Spring控制器。这个类将由Spring管理，以处理对端点的请求。我们的API类将实现`ProductsApi`接口，并且我们需要添加两个注解，`@RestController`和`@RequestMapping("/api/products")`：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`@RestController` is used to create a bean managed by Spring. This controller
    will handle the endpoint requests mapped by the `@RequestMapping("/api/products")`
    annotation, meaning that all requests whose URI matches the `/api/products` pattern
    will be handled by our controller.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RestController`用于创建由Spring管理的bean。这个控制器将处理由`@RequestMapping("/api/products")`注解映射的端点请求，这意味着所有URI匹配`/api/products`模式的请求都将由我们的控制器处理。'
- en: '![img](img/Information_Box_Icon.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/Information_Box_Icon.png)'
- en: Using `@RestController` is recommended for creating RESTful APIs with the Spring
    Framework. It is a shortcut for the combination of the `@Controller` and `@ResponseBody`
    annotations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@RestController`推荐用于使用Spring框架创建RESTful API。它是`@Controller`和`@ResponseBody`注解的组合的快捷方式。
- en: '`ProductsQueryUseCase` and `ProductsCommandUseCase` are the implementations
    of our use cases. We are segregating the query and command responsibilities using
    the **Command Query Responsibility Segregation** ( **CQRS** ) pattern. This pattern
    is commonly used in software architecture to separate the responsibilities of
    reading data (queries) from writing data (commands).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductsQueryUseCase`和`ProductsCommandUseCase`是我们用例的实现。我们正在使用**命令查询责任分离**（**CQRS**）模式来分离查询和命令责任。该模式在软件架构中常用，用于将读取数据（查询）的责任与写入数据（命令）的责任分开。'
- en: CQRS is useful in systems where read and write operations have different characteristics
    or performance requirements. It promotes a clear separation of concerns, leading
    to more maintainable and scalable architecture. By segregating these responsibilities,
    we can later decide to break the API into two microservices and scale them separately.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS在读取和写入操作具有不同特性或性能要求的系统中很有用。它促进了关注点的清晰分离，从而导致了更易于维护和可扩展的架构。通过分离这些责任，我们可以在以后决定将API拆分为两个微服务并分别对其进行扩展。
- en: 'The `ProductMapper` class uses the `MapStruct` library to transform one object
    into another object; in our case, we are mapping the data from our domain to our
    DTO. Let’s see how we can implement it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductMapper`类使用`MapStruct`库将一个对象转换成另一个对象；在我们的案例中，我们正在将领域数据映射到我们的DTO。让我们看看我们如何实现它：'
- en: '[PRE4]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The implementation of `ProductMapper` is generated during the compilation phase.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductMapper`的实现是在编译阶段生成的。'
- en: Implementing the product API endpoints
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现产品API端点
- en: In this section, we will implement the `ProductsApiController` class. This will
    involve adding all the endpoints we defined in the previous sections, enabling
    full functionality for creating, retrieving, updating, and deleting products in
    our API.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`ProductsApiController`类。这包括添加我们在前几节中定义的所有端点，使我们的API能够实现创建、检索、更新和删除产品的全部功能。
- en: Create or update product endpoint
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建或更新产品端点
- en: 'To implement this endpoint, we’ll need to use Spring annotations. For the create
    operation, it’s advisable to employ either `@PutMapping` or `@PostMapping` :'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此端点，我们需要使用Spring注解。对于创建操作，建议使用`@PutMapping`或`@PostMapping`：
- en: '[PRE5]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our case, we decided to use the `PUT` annotation; this decision was made
    because our method is idempotent, so we can use this method to update or create
    the product. One of the requirements is to not allow two products to have the
    same SKU; in our case, we can update or create the product if it does not exist.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们决定使用`PUT`注解；这个决定是因为我们的方法是幂等的，因此我们可以使用这个方法来更新或创建产品。一个要求是不允许两个产品具有相同的SKU；在我们的案例中，如果产品不存在，我们可以更新或创建产品。
- en: We then have two annotations for the input, `@Valid` and `@RequestBody` . The
    `@Valid` annotation will be discussed in the *Bean Validation* section. `@RequestBody`
    means that we should send the input by passing it into the body of the request.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个输入注解，`@Valid`和`@RequestBody`。`@Valid`注解将在*Bean Validation*部分进行讨论。`@RequestBody`表示我们应该通过将输入传递到请求体中来发送输入。
- en: Following best practices, this method can return `200 (ok)` or `201 (created)`
    , depending on whether the product already exists or not.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最佳实践，此方法可以返回`200 (ok)`或`201 (created)`，具体取决于产品是否已存在。
- en: All API call examples will be demonstrated using a `curl` command, but you can
    easily perform the same requests using various tools, such as **Postman** or **UseBruno**
    , directly from your IDE, or with any other API testing tool of your choice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有API调用示例都将使用`curl`命令进行演示，但您也可以轻松地使用各种工具，如**Postman**或**UseBruno**，直接从您的IDE或使用您选择的任何其他API测试工具执行相同的请求。
- en: 'To call this endpoint, we can use a request as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此端点，我们可以使用以下请求：
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will receive the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Get all products endpoint
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取所有产品端点
- en: 'To return all the products, we need to use the HTTP `GET` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回所有产品，我们需要使用HTTP `GET`方法：
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To call this endpoint, we can use a request as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用此端点，我们可以使用以下请求：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will receive the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Get product by ID endpoint
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID获取产品端点
- en: 'To return the product by ID, we need to use the HTTP `GET` method and pass
    the ID as a path parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过ID返回产品，我们需要使用HTTP `GET`方法并将ID作为路径参数传递：
- en: '[PRE11]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This endpoint uses the `@PathVariable("productId")` annotation and expects to
    have this value in the URI. We also need to add this path variable ID to the `@GetMapping`
    mapping annotation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点使用`@PathVariable("productId")`注解，并期望在URI中具有此值。我们还需要将此路径变量ID添加到`@GetMapping`映射注解中。
- en: In case of success, we should return the HTTP status `200` code and return the
    product content. Otherwise, we can return `404` , meaning the product does not
    exist. We are going to see how to handle errors in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功的情况下，我们应该返回HTTP状态码`200`并返回产品内容。否则，我们可以返回`404`，表示产品不存在。我们将在下一节中看到如何处理错误。
- en: 'To call this endpoint, we can use the following request:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此端点，我们可以使用以下请求：
- en: '[PRE12]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will receive the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Delete product by ID endpoint
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID删除产品端点
- en: 'Deleting a product by ID is very similar to getting a product by ID, with the
    big difference being the HTTP method; in this case, we should use the `DELETE`
    method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ID删除产品与通过ID获取产品非常相似，主要区别在于HTTP方法；在这种情况下，我们应该使用`DELETE`方法：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method is very similar to the previous one. The big difference is the `@DeleteMapping`
    annotation and `return` . In this case, we return a `204 (no content)` HTTP status.
    This means that we did not provide any content and the request was done successfully.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与上一个方法非常相似。主要区别在于`@DeleteMapping`注解和`return`。在这种情况下，我们返回`204 (no content)`
    HTTP状态。这意味着我们没有提供任何内容，请求已成功完成。
- en: The `DELETE` method is idempotent; because of this, we can return `204` whether
    the product exists or not. As the expected behavior will be the same, the product
    will not exist in the database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`方法是幂等的；因此，无论产品是否存在，我们都可以返回`204`。由于预期的行为将相同，数据库中的产品将不存在。'
- en: 'To call this endpoint, we can use the following request:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此端点，我们可以使用以下请求：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will receive the following output:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Update product description by ID endpoint
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过ID更新产品描述端点
- en: 'The endpoint for updating the product description by ID is much like the one
    for retrieving a product. In this case, we will use the `PATCH` method, as it
    is a partial update, so the client will only pass a body with the content that
    is changed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 更新产品描述的端点通过ID与检索产品的端点非常相似。在这种情况下，我们将使用`PATCH`方法，因为它是一个部分更新，所以客户端将只传递包含更改内容的主体：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method receives the product ID in `@PathVariable` and uses the `@PatchMapping`
    annotation to map it to the `PATCH` method. This method also has an input argument
    of type `ProductDescriptionInput` with the `@RequestBody` and `@Valid` annotations.
    The input argument represents the request body containing the description of the
    product that the client would like to change.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收产品ID作为`@PathVariable`，并使用`@PatchMapping`注解将其映射到`PATCH`方法。此方法还有一个类型为`ProductDescriptionInput`的输入参数，带有`@RequestBody`和`@Valid`注解。输入参数表示包含客户希望更改的产品描述的请求体。
- en: 'To call this endpoint, we can use the following request:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此端点，我们可以使用以下请求：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will receive the following output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With our endpoints in place, our API class is now complete.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好我们的端点后，我们的API类现在就完整了。
- en: 'You can access the full code with the following link: [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java)
    .'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接访问完整代码：[https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java)
    .
- en: The code of our API is done; now we can call the endpoints and test them. However,
    what happens if the product does not exist, or we send invalid data? We need to
    cover the negative cases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API代码已完成；现在我们可以调用端点并测试它们。然而，如果产品不存在，或者我们发送了无效数据，会发生什么？我们需要涵盖负面情况。
- en: Exception handling
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception handling is the part of the implementation where we respond to errors
    or exceptional situations that occur during a program’s execution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是实现中响应程序执行期间发生的错误或异常情况的部分。
- en: In a RESTful API, many types of errors can occur, usually belonging to the `4xx`
    or `5xx` group of HTTP status codes. The `5xx` statuses mean that there is an
    error in the server application. They can be caused by external factors on the
    server side (e.g., unavailability of a database server) or a bug in the application
    (e.g., `NullPointerException` ). On the other hand, the `4xx` statuses indicate
    errors caused by the client. For example, `405 (Method Not Allowed)` is automatically
    generated by the Spring Framework when the client tries to use an HTTP method
    not expected by the API.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 中，可能会发生许多类型的错误，通常属于 HTTP 状态码的 `4xx` 或 `5xx` 组。`5xx` 状态码表示服务器应用程序中存在错误。它们可能是由服务器端的外部因素（例如，数据库服务器的不可用）或应用程序中的错误（例如，`NullPointerException`）引起的。另一方面，`4xx`
    状态码表示由客户端引起的错误。例如，当客户端尝试使用 API 不期望的 HTTP 方法时，Spring 框架会自动生成 `405 (Method Not Allowed)`。
- en: Spring and Java provide many ways to handle exceptions. We can create a `try-catch`
    block in each endpoint and handle them one by one; we can also have a custom `ExceptionHandler`
    for each controller or have a global exception handler.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 和 Java 提供了许多处理异常的方法。我们可以在每个端点中创建一个 `try-catch` 块并逐个处理它们；我们也可以为每个控制器有一个自定义的
    `ExceptionHandler`，或者有一个全局异常处理器。
- en: We will be implementing global exception handling in our API. This approach
    helps to prevent repeated code and ensures uniform behavior across all endpoints,
    especially if the API exposes multiple resources.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的 API 中实现全局异常处理。这种方法有助于防止代码重复，并确保所有端点之间的一致行为，特别是如果 API 公开了多个资源。
- en: 'Spring Frameworks supports the *Problem Details for HTTP APIs* specification,
    RFC 9457. This RFC is an updated standard that builds upon RFC 7807. The main
    goal is to provide detailed information about errors in HTTP APIs by defining
    five fields:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 框架支持 `HTTP APIs 的 Problem Details` 规范，RFC 9457。这个 RFC 是一个基于 RFC 7807
    的更新标准，其主要目标是通过对五个字段进行定义，提供有关 HTTP API 中错误的详细信息：
- en: '`Type` : This should contain a URI that identifies the problem type'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`：这应该包含一个标识问题类型的 URI'
- en: '`Status` : This indicates the HTTP status code'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`：这表示 HTTP 状态码'
- en: '`Title` : The title is a concise summary of the problem'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`：标题是对问题的简洁总结'
- en: '`Detail` : This field should contain more detailed information about the problem'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`详细信息`：此字段应包含有关问题的更详细信息'
- en: '`Instance` : This should contain a URI that identifies the endpoint call'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`实例`：这应包含一个标识端点调用的 URI'
- en: 'In Spring, we can follow the RFC guidelines by extending the `ResponseEntityExceptionHandler`
    class or enabling the `spring.mvc.problemdetails.enabled` property. We will extend
    the `ResponseEntityExceptionHandler` class, which provides the `ProblemDetail`
    class with the five elements defined by RFC 9457. We can also add some extensions,
    which we will do to provide better response errors in `400 (Bad Request)` :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在春季，我们可以通过扩展 `ResponseEntityExceptionHandler` 类或启用 `spring.mvc.problemdetails.enabled`
    属性来遵循 RFC 指南。我们将扩展 `ResponseEntityExceptionHandler` 类，它为 `ProblemDetail` 类提供了
    RFC 9457 定义的五个元素。我们还可以添加一些扩展，我们将这样做以在 `400 (Bad Request)` 中提供更好的响应错误：
- en: '[PRE20]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our `GlobalExceptionHandler` extends the `ResponseEntityExceptionHandler` Spring
    class, which provides the `handleMethodArgumentNotValid` method; we are overriding
    this method and updating the `ProblemDetail` class to give a clear message in
    the case of `400 (Bad Request)` informing about the wrong input data. This kind
    of error can be detected by Bean Validation when the user does not send the correct
    input.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GlobalExceptionHandler` 扩展了 `ResponseEntityExceptionHandler` Spring 类，它提供了
    `handleMethodArgumentNotValid` 方法；我们正在重写此方法并更新 `ProblemDetail` 类，以便在 `400 (Bad
    Request)` 的情况下提供关于错误输入数据的清晰信息。这种错误可以在用户未发送正确输入时通过 Bean Validation 检测到。
- en: 'Our class also has two custom `ExceptionHandler` : the first one to handle
    our custom exception, `EntityNotFoundException` , and the second one to handle
    `ConstraintViolationException` , which can be caused due to validation from `PathVariable`
    .'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的这个类还有两个自定义的 `ExceptionHandler`：第一个用于处理我们的自定义异常 `EntityNotFoundException`，第二个用于处理
    `ConstraintViolationException`，这可能是由于 `PathVariable` 的验证引起的。
- en: Thanks to our `GlobalExceptionHandler` , every the `EntityNotFoundException`
    exception is thrown, the client will receive a **404** error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们的 `GlobalExceptionHandler`，每当抛出 `EntityNotFoundException` 异常时，客户端将收到一个
    **404** 错误。
- en: By creating this class, we have implemented global exception handling and defined
    a consistent and standardized format for errors, making it easier for clients
    consuming the API to understand and handle errors consistently across different
    endpoints. Besides, it also provides more clarity, helping clients to understand
    the nature of the error and how to resolve it. This improves the developer experience
    and reduces the time required to diagnose and fix issues.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建这个类，我们已经实现了全局异常处理，并定义了一个一致和标准化的错误格式，这使得API的客户端能够更容易地理解和处理不同端点上的错误。此外，它还提供了更多的清晰度，帮助客户端理解错误的本质以及如何解决它。这提高了开发者的体验，并减少了诊断和修复问题所需的时间。
- en: Now that we have our exception handler, we need to ensure that the user does
    not send invalid input. Let’s see how we can achieve this using Bean Validation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了异常处理器，我们需要确保用户不会发送无效的输入。让我们看看如何使用Bean Validation来实现这一点。
- en: Bean Validation
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bean Validation
- en: Bean Validation is a Java specification based on **Java Specification Requests**
    ( **JSRs** ) 380, 349, and 303. These requests provide a standardized approach
    to validating Java beans. Bean Validation is very useful for validating user requests,
    by providing some predefined rules and a way to create your custom Bean Validation,
    making it easier to enforce data integrity and validate input data within Java
    applications.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation是基于Java规范请求（**JSRs**）380、349和303的Java规范。这些请求提供了一种标准化的方法来验证Java
    Bean。Bean Validation对于验证用户请求非常有用，它提供了一些预定义的规则以及创建自定义Bean Validation的方法，这使得在Java应用程序中强制数据完整性和验证输入数据变得更加容易。
- en: 'Bean Validation can be applied through various annotations, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Bean Validation可以通过以下各种注解来应用：
- en: '`@NotNull` : Specifies that the annotated element must not be null'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotNull` : 指定被注解的元素不能为null'
- en: '`@Size` : Specifies the size constraints for a string, collection, map, or
    array'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Size` : 指定字符串、集合、映射或数组的大小约束'
- en: '`@Min` : Specifies the minimum value for a numeric element'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Min` : 指定数值元素的最小值'
- en: '`@Max` : Specifies the maximum value for a numeric element'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Max` : 指定数值元素的最大值'
- en: '`@DecimalMin` : Specifies the minimum value for a numeric element with decimal
    precision'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DecimalMin` : 指定具有小数精度的数值元素的最小值'
- en: '`@DecimalMax` : Specifies the maximum value for a numeric element with decimal
    precision'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@DecimalMax` : 指定具有小数精度的数值元素的最大值'
- en: '`@Digits` : Specifies the exact or maximum number of digits for a numeric element'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Digits` : 指定数值元素的精确或最大位数'
- en: '`@Pattern` : Specifies a regular expression pattern that the annotated element
    must match'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Pattern` : 指定被注解的元素必须匹配的正则表达式模式'
- en: '`@Email` : Specifies that the annotated element must be a well-formed email
    address'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Email` : 指定被注解的元素必须是一个格式良好的电子邮件地址'
- en: '`@NotBlank` : Specifies that the annotated string must not be null or empty
    and must contain at least one non-whitespace character'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotBlank` : 指定被注解的字符串不能为空或空字符串，并且必须包含至少一个非空白字符'
- en: '`@NotEmpty` : Specifies that the annotated string must not be null or empty'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NotEmpty` : 指定被注解的字符串不能为空或空字符串'
- en: '`@Positive` : Specifies that the annotated numeric element must be positive
    (greater than 0)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Positive` : 指定被注解的数值元素必须是正数（大于0）'
- en: '`@Negative` : Specifies that the annotated numeric element must be negative
    (less than 0)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Negative` : 指定被注解的数值元素必须是负数（小于0）'
- en: '`@PositiveOrZero` : Specifies that the annotated numeric element must be positive
    or 0'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PositiveOrZero` : 指定被注解的数值元素必须是正数或0'
- en: '`@NegativeOrZero` : Specifies that the annotated numeric element must be negative
    or 0'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NegativeOrZero` : 指定被注解的数值元素必须是负数或0'
- en: '`@Past` : Specifies that the annotated date or time must be in the past'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Past` : 指定被注解的日期或时间必须是过去'
- en: '`@PastOrPresent` : Specifies that the annotated date or time must be in the
    past or present'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PastOrPresent` : 指定被注解的日期或时间必须是过去或现在'
- en: '`@Future` : Specifies that the annotated date or time must be in the future'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Future` : 指定被注解的日期或时间必须是未来'
- en: '`@FutureOrPresent` : Specifies that the annotated date or time must be in the
    future or present'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@FutureOrPresent` : 指定被注解的日期或时间必须是未来或现在'
- en: Besides all this, the Bean Validation specification provides the `@Valid` annotation,
    which is used to trigger the validation of nested objects or elements within a
    collection. When applied to a field or parameter representing a complex object
    or a collection of objects, `@Valid` tells the Bean Validation framework to validate
    the nested objects according to their validation constraints.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，Bean Validation规范还提供了`@Valid`注解，该注解用于触发嵌套对象或集合内元素的有效性验证。当应用于表示复杂对象或对象集合的字段或参数时，`@Valid`告诉Bean
    Validation框架根据其验证约束来验证嵌套对象。
- en: Let’s implement a custom Bean Validation for our SKU field and apply the annotations
    we’ve discussed in our request.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的SKU字段实现自定义的Bean Validation，并在我们的请求中应用所讨论的注解。
- en: Our API has an SKU field that should conform to a pattern (AA99999) specified
    in the requirements phase. We can prevent clients from using invalid SKUs by creating
    a custom Bean Validation rule.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的API有一个SKU字段，该字段在需求阶段应遵循指定的模式（AA99999）。我们可以通过创建自定义的Bean Validation规则来防止客户端使用无效的SKU。
- en: 'We can use the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code creates a new annotation called `@ValidSku` , and it checks whether
    the field adheres to a specific pattern: two alphabetic characters followed by
    five numeric digits (e.g., `AA12345` ). If the annotated field does not match
    the defined pattern, a validation error message, `SKU must follow the pattern
    AA99999` , is generated.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个名为`@ValidSku`的新注解，并检查字段是否遵循特定的模式：两个字母字符后跟五个数字（例如，`AA12345`）。如果注解的字段不匹配定义的模式，将生成一个验证错误消息，`SKU必须遵循模式AA99999`。
- en: The `ValidSku` annotation is designed to be applied to fields and parameters,
    as indicated by the `@Target` annotation. It also indicates that the validation
    constraint should be retained at runtime for reflection purposes. This annotation
    streamlines the process of validating SKUs in Java applications, enhancing data
    integrity and ensuring compliance with specific SKU formatting requirements.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidSku`注解被设计为应用于字段和参数，如`@Target`注解所示。它还指示验证约束应在运行时保留以供反射使用。此注解简化了Java应用程序中验证SKU的过程，增强了数据完整性并确保符合特定的SKU格式要求。'
- en: '`ValidSku` also validates whether the field is not null using the `@NotNull`
    annotation.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidSku`还使用`@NotNull`注解验证字段是否不为空。'
- en: 'After creating our annotation, we can update our API by adding `@ValidSku`
    to our `PathVariable` . We should also add the `@Validated` annotation from Spring
    to our `ProductsApiController` . It is essential to validate the method annotation
    and not just the fields:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的注解后，我们可以通过向我们的`PathVariable`添加`@ValidSku`来更新我们的API。我们还应该向我们的`ProductsApiController`添加Spring的`@Validated`注解。验证方法注解非常重要，而不仅仅是字段：
- en: '[PRE22]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have created the SKU validation and our `ExceptionHandler` , we
    can test it by passing a wrong SKU to check the result:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了SKU验证和`ExceptionHandler`，我们可以通过传递错误的SKU来测试它，以检查结果：
- en: '[PRE23]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will receive the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下输出：
- en: '[PRE24]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our output follows the standard by RFC 9457, and we also have an extra field
    to detail the errors from the Bean Validation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果遵循RFC 9457标准，我们还有一个额外的字段来详细说明Bean Validation的错误。
- en: 'Now, we can enhance our `ProductInput` and `ProductDescriptionInput` classes
    with Bean Validation annotations to ensure the input is valid. For the `ProductInput`
    class, we can use the following annotations:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加Bean Validation注解来增强我们的`ProductInput`和`ProductDescriptionInput`类，以确保输入有效。对于`ProductInput`类，我们可以使用以下注解：
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: By adding these annotations, we guarantee that the input is in accord with what
    is expected from our API. With these annotations, we provide a safer API, as we
    control the user input and ensure the data integrity.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这些注解，我们保证输入符合我们API的预期。有了这些注解，我们提供了一个更安全的API，因为我们控制用户输入并确保数据完整性。
- en: 'Our code guarantees these behaviors:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码保证了以下行为：
- en: The name should not be blank, and its length should be between 3 and 255
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称不应为空，且长度应在3到255个字符之间。
- en: The description should not be blank, and its length should be between 10 and
    255
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不应为空，且长度应在10到255个字符之间。
- en: The price should not be null and should be a positive number
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格不应为空，且应为正数。
- en: In case the user of this API does not obey these rules, the client will receive
    a `400` error with the message detail that we defined by the Bean Validation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果API的用户不遵守这些规则，客户端将收到一个`400`错误，错误信息是我们通过Bean Validation定义的。
- en: Bean Validation lets our API provide standardized feedback to clients when validation
    errors occur, which is crucial for maintaining data integrity. It ensures that
    invalid or malformed data is prevented from being processed, significantly reducing
    the risk of data corruption or inconsistent state within the application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 验证豆（Bean Validation）允许我们的API在发生验证错误时向客户端提供标准化的反馈，这对于维护数据完整性至关重要。它确保无效或格式不正确的数据不会被处理，从而显著降低了应用程序内部数据损坏或状态不一致的风险。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered many topics essential to creating a RESTful API.
    You learned how to design and implement a RESTful API following the best practices
    using the HTTP methods and HTTP status codes, and how to apply Bean Validation
    to guarantee data integrity. Not only that, you’ve also learned how to handle
    exceptions using the Spring Framework.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了创建RESTful API所必需的许多主题。你学习了如何遵循最佳实践使用HTTP方法和HTTP状态码来设计和实现RESTful API，以及如何应用Bean
    Validation来保证数据完整性。不仅如此，你还学习了如何使用Spring框架来处理异常。
- en: In the next chapter, we will see how to create well-defined documentation for
    our API that clients can use.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何为我们的API创建定义良好的文档，以便客户端可以使用。
- en: Further reading
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Jakarta Bean Validation specification* (version 3.0): [https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html
    )'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Jakarta Bean Validation规范*（版本3.0）：[https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html)'
- en: '*RFC 9110* : [https://www.rfc-editor.org/rfc/rfc9110.html](https://www.rfc-editor.org/rfc/rfc9110.html
    )'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 9110* : [https://www.rfc-editor.org/rfc/rfc9110.html](https://www.rfc-editor.org/rfc/rfc9110.html)'
- en: '*RFC 9457* : [https://www.rfc-editor.org/rfc/rfc9457.html](https://www.rfc-editor.org/rfc/rfc9457.html)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RFC 9457* : [https://www.rfc-editor.org/rfc/rfc9457.html](https://www.rfc-editor.org/rfc/rfc9457.html)'
