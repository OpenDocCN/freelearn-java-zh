- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exposing a RESTful API with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement REST APIs, in most chapters of this book, we are going to use **Spring
    Boot** . As it is a well-known and popular framework, it is very likely that you
    are familiar with it or have used it before.
  prefs: []
  type: TYPE_NORMAL
- en: However, the general API design principles are easily transferable to other
    Java technologies. You will learn more about how we can apply these principles
    to other technologies in [*Chapter 11*](B21843_11.xhtml#_idTextAnchor310) .
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss the process of designing a RESTful API. We
    will also concentrate on the practical implementation of the API using the Spring
    Framework, a popular choice for building RESTful APIs. By the end of this chapter,
    you will have the knowledge to design and create a RESTful API following the best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the product API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API implementation using Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement an example product API. To be able to follow
    along and use the code examples as they are printed in the book, you should have
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of the Java language and platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least a basic knowledge of Spring Boot or a similar framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 21 and Maven 3.9.0 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of a tool for calling REST APIs, such as `curl` , is recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to apply REST principles to create our API; you
    can access the code for this chapter on GitHub at [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/tree/main/chapter2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Designing the product API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The product API we will develop is an API for managing products. Our API will
    offer various operations, which will be detailed during the design phase.
  prefs: []
  type: TYPE_NORMAL
- en: Spending an adequate amount of time on properly designing the API before starting
    to write the code can save a lot of time later, preventing costly and risky refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design stage should include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the requirements** : Understanding the use cases and who will use
    the API is essential to creating an API that contains everything that is needed
    and nothing more. A good understanding of the requirements lets you avoid breaking
    changes for as long as possible. In [*Chapter 5*](B21843_05.xhtml#_idTextAnchor116)
    , we will talk about how you can evolve your API and ensure backward compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying the resources** : Resources are usually domain entities such
    as users or products. Relationships between multiple entities are often represented
    by a hierarchical URI structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining the resource structure** : After identifying the resources, it is
    necessary to define the resource fields and relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Designing the endpoints** : With the resources and the domain defined, the
    next step is to identify the endpoints that should be exposed, how they should
    be exposed, and what HTTP methods should be used for what purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling** : Having clear error responses with standard error codes
    helps the client to react to the error correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : It is essential to prevent malicious actors from accessing resources
    that they are not authorized to. You will learn more about API security in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: An endpoint is a specific URI that enables clients to interact with a server
    via an API to perform a specific function. It represents an operation that can
    be executed using a unique path and the corresponding HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these design steps, you can proceed directly to implementing the API
    in code using Java. This is called the **code-first approach** , usually representing
    the fastest path to a working API.
  prefs: []
  type: TYPE_NORMAL
- en: A different approach, called **specification-first** , will be explained in
    [*Chapter 3*](B21843_03.xhtml#_idTextAnchor076) .
  prefs: []
  type: TYPE_NORMAL
- en: Defining the requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The API requirements can be divided into functional and non-functional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional requirements** : These describe the specific functions and features
    that the software must perform. Examples include data validation, data processing,
    and system interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-functional requirements** : These are also known as quality attributes
    or software quality requirements that specify the qualities or characteristics
    that the software must possess. Examples include performance (response time and
    throughput), reliability, security, scalability, usability, and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will only work on the functional requirements. We will get
    to some of the non-functional requirements in *Chapters 7 and 10* .
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, our example REST API will be a product API and will have
    the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product creation** : The API should allow users to create new products by
    providing necessary information such as the SKU (Stock Keeping Unit, in the context
    of this book it is the unique product ID), name, description, and price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product retrieval** : Users should be able to retrieve information about
    all products available in the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product details** : The API should provide endpoints to retrieve detailed
    information about a specific product, identified by its SKU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product update** : Users should be able to update existing product information,
    such as name, description, or price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product description update** : The API should provide an endpoint to update
    the description only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product deletion** : The API should allow users to delete a product from
    the system, identified by its SKU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unique SKU constraint** : The API should enforce a constraint to ensure that
    each product has a unique SKU, preventing duplicate products with the same identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have identified the requirements, the next step is to identify our
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A REST API can have one or more resources, and it can also have a hierarchical
    URI structure. A hierarchical URI structure is a way of organizing resources in
    a URL hierarchy that reflects the relationships between those resources. In a
    hierarchical URI structure, resources are arranged in a tree-like format, where
    each segment of the URL represents a level of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: URI or URL?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of REST APIs, we often use the acronyms **URI** (which stands
    for **Uniform Resource Identifier** ) and **URL** (which stands for **Uniform
    Resource Locator** ) interchangeably. To be precise, URLs are a subset of URIs.
    There is a second subset of URIs called **URNs** (which stands for **Uniform Resource
    Names** ). The advantage of a URL over a URN is that besides being a unique identifier
    of the resource, it also contains information that can be used to locate and access
    the resource: protocol, hostname, and path. The path part of a URL supports a
    hierarchical structure such as the sequence of folders and a filename that you
    know from filesystem paths.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this URI, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://example.com](https://example.com) is the base URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/blog` represents the top-level resource, indicating that we are accessing
    the blog section of a website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/posts` is a sub-resource under the `/blog` resource, representing a collection
    of blog posts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/12` is a specific blog post identified by its unique identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we have only one resource, which is the product, so we have only
    `/products` .
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: Resources should be nouns; they should not be verbs. For example, `/products/create`
    should not be used; instead, use the corresponding HTTP method for this action.
    This is essential for adhering to level 2 of the Richardson Maturity Model.
  prefs: []
  type: TYPE_NORMAL
- en: In English, many verbs can be used as nouns too, for example, `/products/quote`
    . When we make a `POST` request to this resource, it means *create a quote* .
    The verb part of the sentence is represented by the correct HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: Resources map to business entities and the API usually works with multiple entities
    of the same type. When creating or listing resources (entities) of a particular
    type, we are working with a collection of objects. For collection resources, we
    use the plural form of the noun – for example, `products` instead of `product`
    because we want to support operations on the collection of products.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: RFC 3986 defines a URI as a compact sequence of characters that identifies an
    abstract or physical resource. According to RFC 1738, a URL is a specific type
    of URI that represents the location of a resource accessible via the internet.
    Thus, a URI can be further classified as a locator, a name, or both, with the
    term URL referring to the subset of URIs. This means that all URLs are URIs, but
    not all URIs are URLs. RFC 2141 further defines URNs as another type of URI that
    names a resource in a persistent, location-independent manner.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have identified the resources, the next step is to define the resource
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the resource structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After identifying the resources, we should identify the attributes of the resources
    and any relationships that are important in the API. The attributes represent
    the data fields associated with the resource. Consider the data types, constraints,
    and any required or optional attributes for each resource. A relationship indicates
    how the resources are related to each other and whether they have any hierarchical
    or nested relationships. For example, a user may have multiple orders associated
    with them, or a product may belong to a specific category.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we have only one resource, which is the product, which should
    have these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` : The name of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sku` : The unique key of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` : A description of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price` : The price of the product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also define the rules for these attributes in this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` : Required field, with a string with a length between 3 and 255 characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sku` : Required field, with the pattern AA99999'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description` : Required field, with a string with a length between 10 and
    255 characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price` : Required field, with a value greater than 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this step, we can design the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To design the endpoints, it is important to know the HTTP methods and the HTTP
    status codes. Before talking about this, though, we should go one step back and
    understand how it started.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP methods and principles we are going to share here follow the guidelines
    from Microsoft mentioned in the previous chapter. Any REST guidelines should adhere
    to the internet standard known as RFC 9110, the updated version of RFC 2616. **RFC**
    stands for **Request for Comments** . RFC specifies HTTP, TCP, IP, SMTP, and many
    other vital internet protocols. Fielding’s dissertation, titled *Architectural
    Styles and the Design of Network-based Software Architectures* , was an important
    source for RFC 2616, defining the HTTP/1.1 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods (verbs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP defines several methods (also known as verbs) that indicate the action
    to be performed on a resource. The most used HTTP methods in RESTful APIs are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` : The `GET` method requests are used to retrieve resource representations,
    and they should not alter the server state. They are safe and idempotent, meaning
    they do not have any side effects on the server and can be repeated without changing
    the server state. (Think about the `get` method of a `Map` in Java.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` : The `POST` method requests are used to create new resources or generally
    submit data to be processed by the server. They are non-idempotent, meaning that
    each request is unique and may have side effects on the server. (Think about the
    `++` operator in Java; the result will be different if it is evaluated multiple
    times.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` : These requests are typically used to create or update the entire representation
    of a resource. They are idempotent, meaning that sending the same request multiple
    times should have the same effect as sending it once. (Think about the `put` method
    of a `Map` in Java.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH` : This is like `PUT` but used to apply partial modifications to a resource.
    It is often used when you want to update only certain fields of a resource. (Think
    about a setter method of a Java Bean/POJO.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` : This method is used to remove a resource from the server. The method
    is idempotent, meaning that sending the same request multiple times should result
    in the same state on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP status codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP status codes are three-digit numbers that a server sends back to the client
    after receiving a request. They indicate the outcome of the request and provide
    information about the status of the server or the requested resource. All HTTP
    status codes are grouped into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1xx Informational` : This indicates that the request was received and is being
    processed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2xx Success` : This indicates that the request was received, understood, and
    processed successfully by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3xx Redirection` : This indicates that further action is needed to complete
    the request. The client may need to redirect to a different URI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4xx Client Error` : This indicates that there was an error in the client’s
    request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`5xx Server Error` : This indicates that there was an error on the server side
    while processing the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand HTTP methods and statuses, we can define the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the endpoints for our API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s define the endpoints for the resource we identified in the previous step.
    We will use the HTTP methods with the `products` resources to ensure we can perform
    all the necessary operations as outlined in the requirements phase.
  prefs: []
  type: TYPE_NORMAL
- en: GET /products
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This endpoint will be responsible for returning a list of products. We should
    return a `200 (ok)` HTTP status with the products.
  prefs: []
  type: TYPE_NORMAL
- en: PUT /products/{id}
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This endpoint will be responsible for creating or updating the product. `PUT`
    is an idempotent method, so we can call it many times and the result will be the
    same. In case of success, we should return `201 (created)` if the product doesn’t
    exist and `200` if the product already exists.
  prefs: []
  type: TYPE_NORMAL
- en: We could also return `202 (accepted)` if the product will be processed in the
    future as an asynchronous task, which is not the case here.
  prefs: []
  type: TYPE_NORMAL
- en: If we decided to use the `POST` method, we would need to choose between throwing
    an exception if the product already exists – this exception could be `409 (conflict)`
    – or creating another product. In our case, because the SKU is not generated by
    the application, it is an attribute passed to the API, and we cannot have two
    products with the same SKU, so we will need to return `409` and have another endpoint
    that would be responsible for updating the resource as it is a requirement. Instead
    of doing this, we can use the `PUT` method, which can create or update the resource.
  prefs: []
  type: TYPE_NORMAL
- en: According to RFC 9110, Section 9.3.4, “The fundamental difference between the
    POST and PUT methods is highlighted by the different intent for the enclosed representation.
    The target resource in a POST request is intended to handle the enclosed representation
    according to the resource’s own semantics, whereas the enclosed representation
    in a PUT request is defined as replacing the state of the target resource. Hence,
    the intent of PUT is idempotent and visible to intermediaries, even though the
    exact effect is only known by the origin server”.
  prefs: []
  type: TYPE_NORMAL
- en: Proper interpretation of a PUT request presumes that the user agent knows which
    target resource is desired. To get a better insight, please refer to [https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4](https://www.rfceditor.org/rfc/rfc9110.html#section-9.3.4)
    .
  prefs: []
  type: TYPE_NORMAL
- en: DELETE /products/{id}
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This endpoint should remove the product. We can return `204 (no content)` in
    case the product is removed. Even if the product does not exist, we can return
    `204` , as the method is idempotent, meaning that sending the same request multiple
    times should result in the same state on the server.
  prefs: []
  type: TYPE_NORMAL
- en: PATCH /products/{id}
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This endpoint should be used to update the description of the product. As it
    is a partial update of a resource, it is recommended to use `PATCH` . The `PATCH`
    method was introduced in RFC 5789 as a partial update that doesn’t need to be
    idempotent. If the product does not exist, we can return a `404 (Not found)` error.
    In case of success, we can return the updated product data and a `200` HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: GET /products/{id}
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This endpoint is responsible for returning the details of a single product by
    the ID. If the product does not exist, we can return a `404 (Not found)` error.
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, we should return the product representation and a `200`
    HTTP status.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our endpoints, let’s see the possible errors that we
    may encounter and how we can prepare for them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Preparing for common issues by defining possible errors can help us implement
    a more reliable API. We have already discussed some errors in the previous step;
    however, let’s get deep into it and see the most common HTTP status codes in the
    `4xx` range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common HTTP status codes in the `4xx` range, which indicates client
    errors, are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`400 Bad Request` : This status code indicates that the server could not understand
    the client’s request due to invalid syntax or a malformed request message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized` : This status code indicates that the client needs to authenticate
    itself to access the requested resource. It typically occurs when the client fails
    to provide proper authentication credentials or access tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden` : This status code indicates that the client is authenticated,
    but it does not have permission to access the requested resource. It may be due
    to insufficient permissions or access control restrictions imposed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not Found` : This status code indicates that the server could not find
    the requested resource. It is commonly used to indicate that the URI provided
    by the client does not correspond to any known resource on the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`405 Method Not Allowed` : This status code indicates that the HTTP method
    used by the client is not supported for the requested resource. For example, trying
    to use a `POST` request on a resource that only supports `GET` requests would
    result in a `405 Method Not Allowed` response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`409 Conflict` : This status code indicates that the request could not be completed
    because of a conflict with the current state of the resource. It typically occurs
    when the client attempts to create or update a resource but the server detects
    a conflict with the resource’s current state; for example, when two requests attempt
    to update the same product’s details concurrently, a `409` status can be returned
    if one request’s changes conflict with the other due to a version mismatch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`422 Unprocessable Entity` : This status code indicates that the server understands
    the request but cannot process it due to semantic errors or validation failures
    in the request payload. It is often used to indicate validation errors in the
    request data, for example, trying to buy a product that is out of stock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`429 Too Many Requests` : This status code indicates that the client has exceeded
    the rate limit or quota imposed by the server for the number of requests allowed
    within a certain time period. It is often used to prevent abuse or excessive usage
    of server resources by limiting the rate of incoming requests from a single client
    or IP address. This error is typically handled by an API gateway using a rate-limiting
    strategy, as we’ll cover in [*Chapter 6*](B21843_06.xhtml#_idTextAnchor135) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our API implementation, we should be able to handle some errors:'
  prefs: []
  type: TYPE_NORMAL
- en: When a product does not exist, we should return `404 Not Found`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the payload does not meet the requirements, for example, if a negative
    number is provided for the product price, we should return `400 Bad Request` with
    the details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some error conditions (for example, an unsupported method leading to `405 Method
    Not Allowed` ) are handled automatically by the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The security-related `401` and `403` HTTP status codes will be covered in [*Chapter
    7*](B21843_07.xhtml#_idTextAnchor176) .
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we will take on security and documentation as separate
    topics and address them head-on. However, for the development iteration represented
    by this chapter, we have completed our design phase. Moving forward, we will focus
    on implementing our product API and ensuring that we can meet the requirements
    that we defined.
  prefs: []
  type: TYPE_NORMAL
- en: API implementation using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot is the most popular Java framework for microservice applications.
    It provides embedded servlet containers such as **Tomcat** , **Jetty** , and **Undertow**
    . Embedding a container allows you to package your application as an executable
    JAR file that can be run directly without needing to deploy your application to
    a separate application server. We are going to use Tomcat as it is the default.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will provide some endpoints and will use an SQL database. We
    will use **H2** , which is a lightweight and open source database. It can function
    as both an in-memory and filesystem database, making it easily usable in development
    environments without the need for additional infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a Spring Data dependency to integrate with the persistence
    layer, but since this is not the focus of the book, we won’t delve deep into it.
    We recommend the book *Persistence Best Practices for Java Applications, by Otávio
    Santana and Karina Varela, Packt Publishing* , which talks more about the persistence
    layer. To add the Spring Data dependency, include the following entry in your
    `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As our API is a web application, we are also going to use Spring Web to create
    our REST endpoints and Bean Validation to validate the user input, which we are
    going to talk about later in this chapter. We will use the **Clean Architecture**
    ( [https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
    ) design for our API.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture was created by Robert C. Martin, who was influenced by other
    well-known architectures, such as the Onion Architecture by Jeffrey Palermo and
    Hexagonal Architecture (a.k.a. ports and adapters) by Alistair Cockburn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean Architecture shares a similar goal with these other architectures: the
    separation of concerns by dividing the software into layers. The key distinction
    of Clean Architecture is its clear definition of layers. While other architectures
    provide less precise layer definitions, Clean Architecture distinctly defines
    four layers, each with specific roles and responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use Clean Architecture because its multiple layers allow for
    a clear separation of concerns, facilitating better organization and understandability.
    *Figure 2.1* shows the layers defined by Clean Architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Clean Architecture layers](img/B21843_02_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Clean Architecture layers
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down each of these layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities** : This layer contains the business entities or domain objects
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use cases** : This layer contains the application-specific business logic
    or use cases. This layer represents the application’s behavior in terms of the
    actions or operations that users can perform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface adapters** : This layer is responsible for adapting the application’s
    internal representation to external interfaces such as **user interfaces** ( **UIs**
    ), REST APIs, databases, or third-party services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frameworks and drivers** : This layer includes libraries, frameworks, and
    infrastructure code that handle external concerns such as UI rendering, database
    access, web servers, and external APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our application, we are going to use only three layers: entities, use cases,
    and interface adapters. This is because for our application, we decided we do
    not want to decouple from the Spring Framework completely. In our case, we prefer
    having direct access to the many useful features the Spring Framework provides.
    We accept coupling with the framework while reducing the complexity of creating
    a layer to separate it.'
  prefs: []
  type: TYPE_NORMAL
- en: The layers are defined to achieve loose coupling, ease of maintenance, and reusability.
    Robert C. Martin says that we can have more layers, and these layers are only
    schematic. The main principle of layered architectures is to ensure that dependencies
    cross the boundaries in only one direction; an inner layer should not depend on
    an outer layer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined the architecture and also the technologies, let’s build
    our product API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the endpoints of our product API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, to create our product API, we are going to use Spring
    Boot. We recommend using the latest version of Spring and Java (JDK); we will
    be using the following versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 3.2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before starting to create our API, we will define an interface with all the
    expected endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This “ `ProductsAPI` " interface contains all the expected endpoints defined
    in the design step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are following clean architecture guidelines, we defined three **data
    transfer objects** ( **DTOs** ) for input and output: `ProductOutput` , `ProductInput`
    , and `ProductDescriptionInput` . Utilizing these DTOs enables us to modify them
    without affecting our domain classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our product API, we will have to define a Spring controller. This
    class will be managed by Spring to handle requests to our endpoints. Our API class
    will implement the `ProductsApi` interface, and we will need to add two annotations,
    `@RestController` and `@RequestMapping("/api/products")` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`@RestController` is used to create a bean managed by Spring. This controller
    will handle the endpoint requests mapped by the `@RequestMapping("/api/products")`
    annotation, meaning that all requests whose URI matches the `/api/products` pattern
    will be handled by our controller.'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/Information_Box_Icon.png)'
  prefs: []
  type: TYPE_IMG
- en: Using `@RestController` is recommended for creating RESTful APIs with the Spring
    Framework. It is a shortcut for the combination of the `@Controller` and `@ResponseBody`
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductsQueryUseCase` and `ProductsCommandUseCase` are the implementations
    of our use cases. We are segregating the query and command responsibilities using
    the **Command Query Responsibility Segregation** ( **CQRS** ) pattern. This pattern
    is commonly used in software architecture to separate the responsibilities of
    reading data (queries) from writing data (commands).'
  prefs: []
  type: TYPE_NORMAL
- en: CQRS is useful in systems where read and write operations have different characteristics
    or performance requirements. It promotes a clear separation of concerns, leading
    to more maintainable and scalable architecture. By segregating these responsibilities,
    we can later decide to break the API into two microservices and scale them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductMapper` class uses the `MapStruct` library to transform one object
    into another object; in our case, we are mapping the data from our domain to our
    DTO. Let’s see how we can implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `ProductMapper` is generated during the compilation phase.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the product API endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will implement the `ProductsApiController` class. This will
    involve adding all the endpoints we defined in the previous sections, enabling
    full functionality for creating, retrieving, updating, and deleting products in
    our API.
  prefs: []
  type: TYPE_NORMAL
- en: Create or update product endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement this endpoint, we’ll need to use Spring annotations. For the create
    operation, it’s advisable to employ either `@PutMapping` or `@PostMapping` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we decided to use the `PUT` annotation; this decision was made
    because our method is idempotent, so we can use this method to update or create
    the product. One of the requirements is to not allow two products to have the
    same SKU; in our case, we can update or create the product if it does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: We then have two annotations for the input, `@Valid` and `@RequestBody` . The
    `@Valid` annotation will be discussed in the *Bean Validation* section. `@RequestBody`
    means that we should send the input by passing it into the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Following best practices, this method can return `200 (ok)` or `201 (created)`
    , depending on whether the product already exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: All API call examples will be demonstrated using a `curl` command, but you can
    easily perform the same requests using various tools, such as **Postman** or **UseBruno**
    , directly from your IDE, or with any other API testing tool of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this endpoint, we can use a request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Get all products endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To return all the products, we need to use the HTTP `GET` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To call this endpoint, we can use a request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Get product by ID endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To return the product by ID, we need to use the HTTP `GET` method and pass
    the ID as a path parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This endpoint uses the `@PathVariable("productId")` annotation and expects to
    have this value in the URI. We also need to add this path variable ID to the `@GetMapping`
    mapping annotation.
  prefs: []
  type: TYPE_NORMAL
- en: In case of success, we should return the HTTP status `200` code and return the
    product content. Otherwise, we can return `404` , meaning the product does not
    exist. We are going to see how to handle errors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this endpoint, we can use the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Delete product by ID endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Deleting a product by ID is very similar to getting a product by ID, with the
    big difference being the HTTP method; in this case, we should use the `DELETE`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method is very similar to the previous one. The big difference is the `@DeleteMapping`
    annotation and `return` . In this case, we return a `204 (no content)` HTTP status.
    This means that we did not provide any content and the request was done successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The `DELETE` method is idempotent; because of this, we can return `204` whether
    the product exists or not. As the expected behavior will be the same, the product
    will not exist in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this endpoint, we can use the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Update product description by ID endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The endpoint for updating the product description by ID is much like the one
    for retrieving a product. In this case, we will use the `PATCH` method, as it
    is a partial update, so the client will only pass a body with the content that
    is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method receives the product ID in `@PathVariable` and uses the `@PatchMapping`
    annotation to map it to the `PATCH` method. This method also has an input argument
    of type `ProductDescriptionInput` with the `@RequestBody` and `@Valid` annotations.
    The input argument represents the request body containing the description of the
    product that the client would like to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call this endpoint, we can use the following request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With our endpoints in place, our API class is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the full code with the following link: [https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java](https://github.com/PacktPublishing/Mastering-RESTful-Web-Services-with-Java/blob/main/chapter2/product-api/src/main/java/com/packt/productapi/adapter/inbound/rest/ProductsApiController.java)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: The code of our API is done; now we can call the endpoints and test them. However,
    what happens if the product does not exist, or we send invalid data? We need to
    cover the negative cases.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exception handling is the part of the implementation where we respond to errors
    or exceptional situations that occur during a program’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: In a RESTful API, many types of errors can occur, usually belonging to the `4xx`
    or `5xx` group of HTTP status codes. The `5xx` statuses mean that there is an
    error in the server application. They can be caused by external factors on the
    server side (e.g., unavailability of a database server) or a bug in the application
    (e.g., `NullPointerException` ). On the other hand, the `4xx` statuses indicate
    errors caused by the client. For example, `405 (Method Not Allowed)` is automatically
    generated by the Spring Framework when the client tries to use an HTTP method
    not expected by the API.
  prefs: []
  type: TYPE_NORMAL
- en: Spring and Java provide many ways to handle exceptions. We can create a `try-catch`
    block in each endpoint and handle them one by one; we can also have a custom `ExceptionHandler`
    for each controller or have a global exception handler.
  prefs: []
  type: TYPE_NORMAL
- en: We will be implementing global exception handling in our API. This approach
    helps to prevent repeated code and ensures uniform behavior across all endpoints,
    especially if the API exposes multiple resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Frameworks supports the *Problem Details for HTTP APIs* specification,
    RFC 9457. This RFC is an updated standard that builds upon RFC 7807. The main
    goal is to provide detailed information about errors in HTTP APIs by defining
    five fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Type` : This should contain a URI that identifies the problem type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Status` : This indicates the HTTP status code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Title` : The title is a concise summary of the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Detail` : This field should contain more detailed information about the problem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Instance` : This should contain a URI that identifies the endpoint call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Spring, we can follow the RFC guidelines by extending the `ResponseEntityExceptionHandler`
    class or enabling the `spring.mvc.problemdetails.enabled` property. We will extend
    the `ResponseEntityExceptionHandler` class, which provides the `ProblemDetail`
    class with the five elements defined by RFC 9457. We can also add some extensions,
    which we will do to provide better response errors in `400 (Bad Request)` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our `GlobalExceptionHandler` extends the `ResponseEntityExceptionHandler` Spring
    class, which provides the `handleMethodArgumentNotValid` method; we are overriding
    this method and updating the `ProblemDetail` class to give a clear message in
    the case of `400 (Bad Request)` informing about the wrong input data. This kind
    of error can be detected by Bean Validation when the user does not send the correct
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our class also has two custom `ExceptionHandler` : the first one to handle
    our custom exception, `EntityNotFoundException` , and the second one to handle
    `ConstraintViolationException` , which can be caused due to validation from `PathVariable`
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to our `GlobalExceptionHandler` , every the `EntityNotFoundException`
    exception is thrown, the client will receive a **404** error.
  prefs: []
  type: TYPE_NORMAL
- en: By creating this class, we have implemented global exception handling and defined
    a consistent and standardized format for errors, making it easier for clients
    consuming the API to understand and handle errors consistently across different
    endpoints. Besides, it also provides more clarity, helping clients to understand
    the nature of the error and how to resolve it. This improves the developer experience
    and reduces the time required to diagnose and fix issues.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our exception handler, we need to ensure that the user does
    not send invalid input. Let’s see how we can achieve this using Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bean Validation is a Java specification based on **Java Specification Requests**
    ( **JSRs** ) 380, 349, and 303. These requests provide a standardized approach
    to validating Java beans. Bean Validation is very useful for validating user requests,
    by providing some predefined rules and a way to create your custom Bean Validation,
    making it easier to enforce data integrity and validate input data within Java
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bean Validation can be applied through various annotations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@NotNull` : Specifies that the annotated element must not be null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Size` : Specifies the size constraints for a string, collection, map, or
    array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Min` : Specifies the minimum value for a numeric element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Max` : Specifies the maximum value for a numeric element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DecimalMin` : Specifies the minimum value for a numeric element with decimal
    precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@DecimalMax` : Specifies the maximum value for a numeric element with decimal
    precision'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Digits` : Specifies the exact or maximum number of digits for a numeric element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Pattern` : Specifies a regular expression pattern that the annotated element
    must match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Email` : Specifies that the annotated element must be a well-formed email
    address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotBlank` : Specifies that the annotated string must not be null or empty
    and must contain at least one non-whitespace character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NotEmpty` : Specifies that the annotated string must not be null or empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Positive` : Specifies that the annotated numeric element must be positive
    (greater than 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Negative` : Specifies that the annotated numeric element must be negative
    (less than 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PositiveOrZero` : Specifies that the annotated numeric element must be positive
    or 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@NegativeOrZero` : Specifies that the annotated numeric element must be negative
    or 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Past` : Specifies that the annotated date or time must be in the past'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PastOrPresent` : Specifies that the annotated date or time must be in the
    past or present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Future` : Specifies that the annotated date or time must be in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@FutureOrPresent` : Specifies that the annotated date or time must be in the
    future or present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides all this, the Bean Validation specification provides the `@Valid` annotation,
    which is used to trigger the validation of nested objects or elements within a
    collection. When applied to a field or parameter representing a complex object
    or a collection of objects, `@Valid` tells the Bean Validation framework to validate
    the nested objects according to their validation constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a custom Bean Validation for our SKU field and apply the annotations
    we’ve discussed in our request.
  prefs: []
  type: TYPE_NORMAL
- en: Our API has an SKU field that should conform to a pattern (AA99999) specified
    in the requirements phase. We can prevent clients from using invalid SKUs by creating
    a custom Bean Validation rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates a new annotation called `@ValidSku` , and it checks whether
    the field adheres to a specific pattern: two alphabetic characters followed by
    five numeric digits (e.g., `AA12345` ). If the annotated field does not match
    the defined pattern, a validation error message, `SKU must follow the pattern
    AA99999` , is generated.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidSku` annotation is designed to be applied to fields and parameters,
    as indicated by the `@Target` annotation. It also indicates that the validation
    constraint should be retained at runtime for reflection purposes. This annotation
    streamlines the process of validating SKUs in Java applications, enhancing data
    integrity and ensuring compliance with specific SKU formatting requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`ValidSku` also validates whether the field is not null using the `@NotNull`
    annotation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating our annotation, we can update our API by adding `@ValidSku`
    to our `PathVariable` . We should also add the `@Validated` annotation from Spring
    to our `ProductsApiController` . It is essential to validate the method annotation
    and not just the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the SKU validation and our `ExceptionHandler` , we
    can test it by passing a wrong SKU to check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our output follows the standard by RFC 9457, and we also have an extra field
    to detail the errors from the Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can enhance our `ProductInput` and `ProductDescriptionInput` classes
    with Bean Validation annotations to ensure the input is valid. For the `ProductInput`
    class, we can use the following annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By adding these annotations, we guarantee that the input is in accord with what
    is expected from our API. With these annotations, we provide a safer API, as we
    control the user input and ensure the data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code guarantees these behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: The name should not be blank, and its length should be between 3 and 255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The description should not be blank, and its length should be between 10 and
    255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The price should not be null and should be a positive number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case the user of this API does not obey these rules, the client will receive
    a `400` error with the message detail that we defined by the Bean Validation.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation lets our API provide standardized feedback to clients when validation
    errors occur, which is crucial for maintaining data integrity. It ensures that
    invalid or malformed data is prevented from being processed, significantly reducing
    the risk of data corruption or inconsistent state within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many topics essential to creating a RESTful API.
    You learned how to design and implement a RESTful API following the best practices
    using the HTTP methods and HTTP status codes, and how to apply Bean Validation
    to guarantee data integrity. Not only that, you’ve also learned how to handle
    exceptions using the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to create well-defined documentation for
    our API that clients can use.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Jakarta Bean Validation specification* (version 3.0): [https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html](https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 9110* : [https://www.rfc-editor.org/rfc/rfc9110.html](https://www.rfc-editor.org/rfc/rfc9110.html
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*RFC 9457* : [https://www.rfc-editor.org/rfc/rfc9457.html](https://www.rfc-editor.org/rfc/rfc9457.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
