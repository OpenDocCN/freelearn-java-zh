- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up the Database and Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Spring Boot’s fundamentals to develop
    our backend application, such as dependency injection, beans, and annotations.
    In addition, we now know how to create a Spring Boot project using Spring Initializr.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you how to connect your Spring Boot application to a
    database by adding a PSQL container and PostgreSQL dependencies and accessing
    data using the **Java Persistence** **API** (**JPA**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to database using a PSQL container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Spring Data JPA and PostgreSQL dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is what you need to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PostgreSQL**: [https://www.postgresql.org/download/windows/](https://www.postgresql.org/download/windows/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pgAdmin**: [https://www.pgadmin.org/download/](https://www.pgadmin.org/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database using a PSQL container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will teach us how to set up and configure our PostgreSQL in our
    terminal by using the conventional method, using the installer, or through a Docker
    container. But first, let’s discuss what PostgreSQL is and what its advantages
    are.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PostgreSQL** is an open source object-relational database system that uses
    the SQL language to store and handle complicated and large workloads. PostgreSQL
    also supports both *SQL (relational)* and *JSON (non-relational)* querying. It
    is commonly used as primary data storage for geospatial and analytics applications
    because of its flexibility and rich features. Its community has improved and continuously
    backed it for more than 20 years to add more features and reliability to the database
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL’s flexibility means that it is widely used in developing applications.
    Here are some of the everyday use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scientific data**: Research projects can be demanding in storing data, which
    requires effective and efficient handling. PostgreSQL provides analytical features
    and a powerful SQL engine that can process a large amount of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Financial industry**: PostgreSQL is used in financial companies because of
    its analytical capabilities and easy integration with mathematical software such
    as MATLAB and R.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web applications**: PostgreSQL is also used widely in web applications because
    apps nowadays require processing thousands of pieces of data. It is compatible
    with modern web frameworks such as Node.js, Hibernate PHP, and Django.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Government GIS data**: PostgreSQL offers extensions such as PostGIS that
    provide functions to process geometric data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The features of PostgreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s a list of some of the features that PostgreSQL offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compatibility with multiple data types**: PostgreSQL is compatible with several
    data types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structured**: Arrays, date and time, **Universally Unique Identifiers** (**UUIDs**),
    and range'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizations**: Custom types, and composite'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Primitives**: String, integer, numeric, and Boolean'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geometry**: Polygon, circle, line, and point'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document**: XML, JSON/JSONB, and key-value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supports different features of SQL**: It offers the various features of SQL,
    such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple indexing, such as B-tree and expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL subselects
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex SQL queries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-Version Concurrency** **Control** (**MVCC**):'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Table partitioning
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNIQUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NOT NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure database**: It adheres to standard security protocols, which includes
    the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentications such as **Lightweight Directory Access Protocol** (**LDAP**),
    SCRAM-SHA-256, and the **Security Support Provider** **Interface** (**SSPI**)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supports column and row-level security*   **Highly extensible**: It offers
    several features, making it modifiable, such as the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON/SQL path expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored procedures and functions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility with foreign data wrappers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an overview of the features and use cases of PostgreSQL, let’s
    move on to installing it on our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways for us to set up our PostgreSQL in our development terminal.
    The two approaches are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conventional method**: Download the installer directly from the PostgreSQL
    website.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL on a Docker container**: Connect our application directly to a
    container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The conventional method – installation on Windows, macOS, and Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL was mainly developed for Unix-like platforms. However, it was created
    to be portable and can be installed on Windows and macOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step we need to take is to download the PostgreSQL installer through
    this URL: [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – PostgreSQL installation](img/B18159_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – PostgreSQL installation
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for the three operating systems are the same, and we only need to
    configure some settings:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the latest version (**14.1**) and download the installer, depending on
    your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a successful download, open the installer, click **Next**, and specify
    the path where PostgreSQL will be installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The PostgreSQL installer (specify the path to install)](img/B18159_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The PostgreSQL installer (specify the path to install)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have chosen the default installation path. Click
    **Next** again, which will ask us what components we want to install. The components
    that we select are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PostgreSQL Server**: Installs the server where our database will run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pgAdmin 4**: A GUI management tool for interacting with the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack Builder**: A GUI that allows us to download and install drivers that
    are compatible with PostgreSQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command Line Tools**: Provides interaction with PostgreSQL using command-line
    tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The PostgreSQL installer (select the needed components)](img/B18159_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The PostgreSQL installer (select the needed components)
  prefs: []
  type: TYPE_NORMAL
- en: We have checked all the components in the preceding example, as we will need
    all of them throughout our development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Next** again, and you will be asked to specify the directory to store
    the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The PostgreSQL installer (select the directory for the data)](img/B18159_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The PostgreSQL installer (select the directory for the data)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we can see that the default path is the same as where
    PostgreSQL is installed, and it has created a new folder named `data`. It is recommended
    that you use the default path.
  prefs: []
  type: TYPE_NORMAL
- en: Click `postgres`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `postgres` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Next** again, and you will now be asked what locale should be used
    for the database cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The PostgreSQL installer (select a locale for the database cluster)](img/B18159_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The PostgreSQL installer (select a locale for the database cluster)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have selected **[Default locale]** as our locale
    for the database.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** again, which will display all of the settings we have configured;
    make sure all the details are correct before proceeding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After reviewing, click **Next**, which will now install PostgreSQL in our terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After installation, we can verify whether PostgreSQL is installed successfully
    by checking the currently installed version.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, open `Server`, `Port`, `Database`, `Username`, and `Password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we have used the default settings, we can press *Enter* until password
    confirmation. After successful validation of our password, execute the `select
    version()` command to display the currently installed PostgreSQL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.6 – The PostgreSQL installer (displaying the version of PostgreSQL)](img/B18159_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – The PostgreSQL installer (displaying the version of PostgreSQL)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we can see that we have successfully installed **PostgreSQL**
    version **13.4** on our terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to install and configure PostgreSQL using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL on a Docker container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have installed PostgreSQL on our terminal using the conventional installer;
    now, we will learn to configure PostgreSQL using Docker. This method will help
    us skip the complex steps in configuring PostgreSQL for us to start with development
    and provide a GUI for database management:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step you need to do is install Docker on your terminal. You can install
    Docker at the following link: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    For documentation on the system requirements and installation steps for Docker,
    you can refer to this link: https://docs.dockerocker.com/desktop/windows/install/.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After successful installation of Docker, open Docker Desktop and start Docker
    on your Terminal. Then, open your command line and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will pull the PSQL from `Docker-hub`. The `postgresql-container`
    part in the command can be replaced, as this is a container name that we can define.
    The `POSTGRES_PASSWORD` parameter is the password for the `postgres` admin, which
    we can also configure.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the command, we can verify the newly created container by executing
    the `Docker ps -a` command or viewing Docker Desktop to check the list of containers
    running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The PostgreSQL installation using Docker](img/B18159_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – The PostgreSQL installation using Docker
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have executed the `Docker ps -a` command, and
    we can see that our PostgreSQL image has been pulled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – The PostgreSQL installation using Docker (viewing the container
    in Docker Desktop)](img/B18159_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – The PostgreSQL installation using Docker (viewing the container
    in Docker Desktop)
  prefs: []
  type: TYPE_NORMAL
- en: We can also view the pulled `postgresql-container` in Docker Desktop and verify
    its status in our terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have successfully configured our PostgreSQL with Docker. We can connect this
    to our `pgAdmin` by creating a new server with our terminal IP address and port.
  prefs: []
  type: TYPE_NORMAL
- en: We have configured the PostgreSQL database in our terminal. Now, we will learn
    about Spring Data JPA and its importance in developing Spring applications.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Data JPA** (**Java Persistence API**) is a widely used specification
    for managing relational data in Java applications. It helps develop Spring, as
    it reduces boilerplate code by not implementing read and write operations. It
    also handles the complex process involved in JDBC-based accessing of database
    and object-relational mappings.'
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing Spring Data JPA, let’s discuss its clear advantages and why
    it is commonly used in Spring development.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Spring Data JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the advantages of Spring Data JPA:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No-code repositories**: Spring Data JPA promotes *no-code* repositories,
    which means that we don’t have to write the repository pattern, which creates
    a lot of repetitive code. It provides a set of interfaces that we can use to extend
    our classes to apply data-specific implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we have a `BlogRepository` class in our application; when we extend
    it with the `CrudRepository<Blog, Long>` interface, it will have methods that
    have the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting, updating, and deleting one or multiple blog entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding one or multiple blogs by their primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting all blogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating whether a single blog exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the repository with the interface provided by Spring Data JPA includes
    all data-related methods, which allows us to focus more on business logic.
  prefs: []
  type: TYPE_NORMAL
- en: '**Boilerplate reduction**: Spring Data JPA offers built-in implementations
    for methods. As stated in the first advantage, we only need to focus on business
    logic and no longer need to code read and write operations, as written under the
    interfaces. This also prevents human errors, as all implementations are already
    registered for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findBy`, and Spring will parse the name and create a query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we have created a `findByAuthor()` method, which will
    allow Spring to generate a query and set the parameters as bind parameter values.
    It will execute the query once we call the method.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories provided by Spring Data JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Data JPA provides repositories that provide different methods for data-related
    implementations. The repositories are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CrudRepository`: The interface repository, which provides the basic operations
    to **Create**, **Read**, **Update**, and **Delete** (**CRUD**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PagingAndSortingRepository`: Extends `CrudRepostiory` and adds a method named
    `findAll`, which can sort results and be retrieved in a paginated manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JpaRepository`: Adds specific JPA methods and has all the functions of `CrudRepository`
    and `PagingAndSortingRepository`. It also adds methods such as `flush()`, which
    flushes the persistence context, and `deleteInBatch()`, which deletes records
    in a batch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned about the different repositories we can use with Spring Data
    JPA. We will now take a look at Spring Data JPA on Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data JPA on Spring Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For us to implement Spring Data JPA in our application, we need the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Entity`: This is a simple class that defines our model. It will be used as
    a JPA entity, generated with a primary key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we will create an entity for `Villain` by making a plain class
    and adding `@Entity` annotations to indicate the `Villain` class as a JPA entity.
    The entity will be used as the type for extending our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that our `Villain` class is annotated with
    `@Entity`, indicating it as a JPA entity. We have also defined an `id` field of
    the `UUID` type and annotated it with `@Id` to indicate that this is the primary
    key, and `@GeneratedValue`, where we specified that this is automatically generated
    using `strategy = GenerationType`.The `AUTO` and the ID generated should be of
    the `UUID` type, using `generator = "``UUID"`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Repository`: This is an interface that we need to extend with JPA repositories
    for the entities to have built-in operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous example, we have a `Villain` entity. To implement the CRUD
    operations, we will create a `VillainRepository` interface and extend it with
    `CrudRepository`, with a type of `Villain` and `UUID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Service`: This is where we will use our created repository. We can use the
    `@Autowired` annotation to inject the repository and call the JPA and custom-defined
    methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we can see that we have injected `VillainRepository`
    in `VillainService` using the `@``Autowired` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue with the following methods using the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have also created methods by using the built-in JPA implementation, such
    as `save()`, `deleteById()`, `findAll()`, and `findById()`, which are found in
    the `CrudRepository` interface. The service can now be injected into our controllers
    or other services to use the methods.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now learned about Spring Data JPA, its advantages, and an overview of
    implementation on Spring JPA. In the next section, we will learn how to add Spring
    Data JPA and PostgreSQL dependencies to our Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Data JPA and PostgreSQL dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will add Spring Data JPA, PostgreSQL, and other valuable dependencies
    to our application. We will add the dependencies with Spring Initializr and an
    existing Spring Boot project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding with Spring Initializr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding dependencies after creating a Spring Boot application using Spring Initializr
    is simple. We only need to select the dependencies on Initializr before generating
    our project:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is to go to [https://start.spring.io/](https://start.spring.io/)
    or to your IntelliJ IDEA (for Ultimate users) to open Spring Initializr (for a
    recap of the *Using Spring Initializr* section, refer to [*Chapter 3*](B18159_03.xhtml#_idTextAnchor058),
    *Moving into* *Spring Boot*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose your project if it will use Maven or Gradle and set the required configurations,
    which are **Group**, **Artifact, Name**, **Description**, **Package name**, **Packaging**,
    and the **Java** version of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, click **Add Dependencies** at the top right and select the following
    dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spring Data JPA**: This dependency is for adding Spring Data JPA used for
    built-in data store-related implementation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**H2 Database**: This is an in-memory database that supports the JDBC API and
    R2DBC access, which is commonly used for unit testing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL Driver**: This is a JDBC and R2DBC driver that will allow the
    connection of Java applications to the PostgreSQL database:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Adding dependencies in Spring Initializr](img/B18159_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Adding dependencies in Spring Initializr
  prefs: []
  type: TYPE_NORMAL
- en: After successfully adding the dependencies, we can see that our dependencies
    are already listed.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **GENERATE**, which will download our already generated project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the ZIP file and open the project on your IDE. If you developed your
    project using Maven, open `pom.xml` in the `src` folder, or if you are using`build.gradle`,
    which is also found in the `src` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure \uFEFF4.10 – The Spring Boot application (a view of pom.xml)](img/B18159_04_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The Spring Boot application (a view of pom.xml)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we can see that the Spring Boot application is generated
    with Maven, and we can see that our `pom.xml` file has included the dependencies
    we added in Spring Initializr:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure \uFEFF4.11 – The Spring Boot application (a view of build.gradle)](img/B18159_04_11.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The Spring Boot application (a view of build.gradle)
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the preceding example, where the Spring Boot application is generated
    with Gradle, we can see the list of dependencies is already added under the `build.gradle`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We will now add the dependencies to an existing Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an existing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we added the dependencies to generate our Spring Boot
    application using Spring Initializr. Now, we will add our dependencies to an existing
    application. It is simple to add a dependency to an existing Spring app; we only
    need to modify the `pom.xml` (Maven) or `build.gradle` (Gradle) files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Spring Data JPA, the H2 database, and PostgreSQL Driver using Maven,
    we will add the dependencies in the form of XML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And for a Spring application using Gradle, we will add the dependencies as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: IntelliJ will automatically recognize the added dependencies and install them
    for the project, and we can successfully build and run the Spring Boot application
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to add Spring Data JPA and PostgreSQL Driver to our Spring
    Boot application. In the next section, we will learn how to connect our Spring
    Boot application to our PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already configured our PostgreSQL database and initialized our Spring
    Boot application with the needed dependencies. Now, we will learn how to connect
    our PostgreSQL to our application. There are two ways we can connect to our database
    – the first is through Spring JDBC, and the other is Spring Data JPA. Spring Data
    JPA is the most convenient way to connect to our database, but we will demonstrate
    both methods in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the database properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is configure the database properties in our Spring
    Boot application. We need to specify the server URL of the database, the admin
    username, and the password by adding the following source code to the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that we have configured the basic connection
    settings for our PostgreSQL. `springDB` on the URL will be the name of the database
    in PostgreSQL, which should already exist on our server.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting using Spring JDBC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method to connect to the database is by using Spring JDBC. We will
    add an additional dependency to our application for us to use this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add JDBC, we will add the following code to our `pom.xml` (Maven) or `build.gradle`
    (Gradle) files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully adding the JDBC dependency, we can now use `JdbcTemplate`
    to execute queries on our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can execute database statements such as `INSERT`
    in our application and call the `update()` method to modify data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting using Spring Data JPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second method is by using the Spring Data JPA plugin. The first step we
    need to take is to add additional details to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the new settings, we can now create `Entity` and `Repository`
    for a specific table in our application – for example, we have a `Blog` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have created a `Blog` class and annotated it with
    `@Entity` and `@Table` to indicate that this is an object connected to our database
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After creating our entity, we have made the repository for the blog, which can
    be extended by the repositories provided by JPA. `BlogRepository` can now be injected
    into our services or controllers to read, add, modify, or delete data on our database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That brings you to the end of this chapter. Let’s have a recap of the valuable
    things you have learned. You learned how to set up PostgreSQL on your local machine
    using the installer or Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: You have also learned about the concepts and advantages of Spring Data JPA in
    Spring Boot and how to add it to your application, which is helpful in creating
    services with CRUD capabilities with less boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, you learned how to connect your Spring Boot application
    with the PostgreSQL database using JDBC and Spring Data JPA.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning how to start our server, how to add
    controllers, models, and services in our code, and about Redis for caching.
  prefs: []
  type: TYPE_NORMAL
