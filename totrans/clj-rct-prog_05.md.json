["```java\n$ lein new respondent\n\n```", "```java\n:dependencies [[org.clojure/clojure \"1.5.1\"]\n               [org.clojure/core.async \"0.1.303.0-886421-alpha\"]\n               [org.clojure/clojurescript \"0.0-2202\"]]\n```", "```java\n:plugins [[com.keminglabs/cljx \"0.3.2\"]\n          [lein-cljsbuild \"1.0.3\"]]\n```", "```java\n:cljx {:builds [{:source-paths [\"src/cljx\"]\n                 :output-path \"target/classes\"\n                 :rules :clj}\n\n                {:source-paths [\"src/cljx\"]\n                 :output-path \"target/classes\"\n                 :rules :cljs}]}\n  :hooks [cljx.hooks]\n```", "```java\ncljx allows us to write code that is portable between Clojure and ClojureScript by placing annotations its preprocessor can understand. We will see later what these annotations look like, but this chunk of configuration tells cljx where to find the annotated files and where to output them once they're processed.\n```", "```java\n:cljsbuild\n{:builds [{:source-paths [\"target/classes\"]\n           :compiler {:output-to \"target/main.js\"}}]}\n```", "```java\n$ rm src/respondent/core.clj\n$ rm test/respondent/core_test.clj\n\n```", "```java\n(ns respondent.core\n  (:refer-clojure :exclude [filter map deliver])\n\n  #+clj\n  (:import [clojure.lang IDeref])\n\n  #+clj\n  (:require [clojure.core.async :as async\n             :refer [go go-loop chan <! >! timeout\n                     map> filter> close! mult tap untap]])\n  #+cljs\n  (:require [cljs.core.async :as async\n             :refer [chan <! >! timeout map> filter>\n                     close! mult tap untap]])\n\n  #+cljs\n  (:require-macros [respondent.core :refer [behavior]]\n                   [cljs.core.async.macros :refer [go go-loop]]))\n```", "```java\n(defprotocol IBehavior\n  (sample [b interval]\n    \"Turns this Behavior into an EventStream from the sampled values at the given interval\"))\n```", "```java\n(defprotocol IEventStream\n  (map        [s f]\n    \"Returns a new stream containing the result of applying f\n    to the values in s\")\n  (filter     [s pred]\n    \"Returns a new stream containing the items from s\n    for which pred returns true\")\n  (flatmap    [s f]\n    \"Takes a function f from values in s to a new EventStream.\n    Returns an EventStream containing values from all underlying streams combined.\")\n  (deliver    [s value]\n    \"Delivers a value to the stream s\")\n  (completed? [s]\n    \"Returns true if this stream has stopped emitting values. False otherwise.\"))\n```", "```java\n(defprotocol IObservable\n  (subscribe [obs f] \"Register a callback to be invoked when the underlying source changes.\n   Returns a token the subscriber can use to cancel the subscription.\"))\n```", "```java\n(defprotocol IToken\n  (dispose [tk]\n    \"Called when the subscriber isn't interested in receiving more items\"))\n```", "```java\n(deftype Token [ch]\n  IToken\n  (dispose [_]\n    (close! ch)))\n```", "```java\n(defn event-stream\n  \"Creates and returns a new event stream. You can optionally provide an existing\n  core.async channel as the source for the new stream\"\n  ([]\n     (event-stream (chan)))\n  ([ch]\n     (let [multiple  (mult ch)\n           completed (atom false)]\n       (EventStream. ch multiple completed))))\n```", "```java\n  (def in (chan))\n  (def multiple (mult in))\n\n  (def out-1 (chan))\n  (tap multiple out-1)\n\n  (def out-2 (chan))\n  (tap multiple out-2)\n  (go (>! in \"Single put!\"))\n\n  (go (prn \"Got from out-1 \" (<! out-1)))\n  (go (prn \"Got from out-2 \" (<! out-2)))\n```", "```java\nin, and mult of it called multiple. Then, we create two output channels, out-1 and out-2, which are both followed by a call to tap. This essentially means that whatever values are written to in will be taken by multiple and written to any channels tapped into it as the following output shows:\n```", "```java\n\"Got from out-1 \" \"Single put!\"\n\"Got from out-2 \" \"Single put!\"\n```", "```java\n(declare event-stream)\n\n(deftype EventStream [channel multiple completed]\n  IEventStream\n  (map [_ f]\n    (let [out (map> f (chan))]\n      (tap multiple out)\n      (event-stream out)))\n\n  (deliver [_ value]\n    (if (= value ::complete)\n      (do (reset! completed true)\n          (go (>! channel value)\n              (close! channel)))\n      (go (>! channel value))))\n\n  IObservable\n  (subscribe [this f]\n    (let [out (chan)]\n      (tap multiple out)\n      (go-loop []\n        (let [value (<! out)]\n          (when (and value (not= value ::complete))\n            (f value)\n            (recur))))\n      (Token. out))))\n```", "```java\n  (def es1 (event-stream))\n  (subscribe es1 #(prn \"first event stream emitted: \" %))\n  (deliver es1 10)\n  ;; \"first event stream emitted: \" 10\n\n  (def es2 (map es1 #(* 2 %)))\n  (subscribe es2 #(prn \"second event stream emitted: \" %))\n\n  (deliver es1 20)\n  ;; \"first event stream emitted: \" 20\n  ;; \"second event stream emitted: \" 40\n```", "```java\n  (filter [_ pred]\n    (let [out (filter> pred (chan))]\n      (tap multiple out)\n      (event-stream out)))\n```", "```java\n  (def es1 (event-stream))\n  (def es2 (filter es1 even?))\n  (subscribe es1 #(prn \"first event stream emitted: \" %))\n  (subscribe es2 #(prn \"second event stream emitted: \" %))\n\n  (deliver es1 2)\n  (deliver es1 3)\n  (deliver es1 4)\n\n  ;; \"first event stream emitted: \" 2\n  ;; \"second event stream emitted: \" 2\n  ;; \"first event stream emitted: \" 3\n  ;; \"first event stream emitted: \" 4\n  ;; \"second event stream emitted: \" 4\n```", "```java\n(flatmap [_ f]\n    (let [es (event-stream)\n          out (chan)]\n      (tap multiple out)\n      (go-loop []\n        (when-let [a (<! out)]\n          (let [mb (f a)]\n            (subscribe mb (fn [b]\n                            (deliver es b)))\n            (recur))))\n      es))\n```", "```java\n  (defn range-es [n]\n    (let [es (event-stream (chan n))]\n      (doseq [n (range n)]\n        (deliver es n))\n      es))\n\n  (def es1 (event-stream))\n  (def es2 (flatmap es1 range-es))\n  (subscribe es1 #(prn \"first event stream emitted: \" %))\n  (subscribe es2 #(prn \"second event stream emitted: \" %))\n\n  (deliver es1 2)\n  ;; \"first event stream emitted: \" 2\n  ;; \"second event stream emitted: \" 0\n  ;; \"second event stream emitted: \" 1\n\n  (deliver es1 3)\n  ;; \"first event stream emitted: \" 3\n  ;; \"second event stream emitted: \" 0\n  ;; \"second event stream emitted: \" 1\n  ;; \"second event stream emitted: \" 2\n```", "```java\n  (completed? [_] @completed)\n```", "```java\n(defn from-interval\n  \"Creates and returns a new event stream which emits values at the given\ninterval.\n  If no other arguments are given, the values start at 0 and increment by\none at each delivery.\n\n  If given seed and succ it emits seed and applies succ to seed to get\nthe next value. It then applies succ to the previous result and so on.\"\n  ([msecs]\n     (from-interval msecs 0 inc))\n  ([msecs seed succ]\n     (let [es (event-stream)]\n       (go-loop [timeout-ch (timeout msecs)\n                 value seed]\n         (when-not (completed? es)\n           (<! timeout-ch)\n           (deliver es value)\n           (recur (timeout msecs) (succ value))))\n       es)))\n```", "```java\n  (def es1 (from-interval 500))\n  (def es1-token (subscribe es1 #(prn \"Got: \" %)))\n  ;; \"Got: \" 0\n  ;; \"Got: \" 1\n  ;; \"Got: \" 2\n  ;; \"Got: \" 3\n  ;; ...\n  (dispose es1-token)\n```", "```java\n(deftype Behavior [f]\n  IBehavior\n  (sample [_ interval]\n    (from-interval interval (f) (fn [& args] (f))))\n  IDeref\n  (#+clj deref #+cljs -deref [_]\n    (f)))\n\n(defmacro behavior [& body]\n  `(Behavior. #(do ~@body)))\n```", "```java\n  (def time-behavior (behavior (System/nanoTime)))\n\n  @time-behavior\n  ;; 201003153977194\n\n  @time-behavior\n  ;; 201005133457949\n```", "```java\n  (def time-stream (sample time-behavior 1500))\n  (def token       (subscribe time-stream #(prn \"Time is \" %)))\n  ;; \"Time is \" 201668521217402\n  ;; \"Time is \" 201670030219351\n  ;; ...\n\n  (dispose token)\n```", "```java\n$ lein install\nRewriting src/cljx to target/classes (clj) with features #{clj} and 0 transformations.\nRewriting src/cljx to target/classes (cljs) with features #{cljs} and 1 transformations.\nCreated respondent/target/respondent-0.1.0-SNAPSHOT.jar\nWrote respondent/pom.xml\n\n```", "```java\n(def es1 (from-interval 500))\n(def take-es (take es1 5))\n\n(subscribe take-es #(prn \"Take values: \" %))\n\n;; \"Take values: \" 0\n;; \"Take values: \" 1\n;; \"Take values: \" 2\n;; \"Take values: \" 3\n;; \"Take values: \" 4\n```", "```java\n(def es1 (from-interval 500))\n(def es2 (map (from-interval 500) #(* % 2)))\n(def zipped (zip es1 es2))\n\n(def token (subscribe zipped #(prn \"Zipped values: \" %)))\n\n;; \"Zipped values: \" [0 0]\n;; \"Zipped values: \" [1 2]\n;; \"Zipped values: \" [2 4]\n;; \"Zipped values: \" [3 6]\n;; \"Zipped values: \" [4 8]\n\n(dispose token)\n```", "```java\nlein new cljs-start respondent-app\n\n```", "```java\n[clojure-reactive-programming/respondent \"0.1.0-SNAPSHOT\"]\n[prismatic/dommy \"0.1.2\"]\n```", "```java\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n\n    <title>Example: tracking mouse position</title>\n    <!--[if lt IE 9]>\n    <script src=\"img/html5.js\"></script>\n    <![endif]-->\n</head>\n\n<body>\n    <div id=\"test\">\n        <h1>Mouse (x,y) coordinates:</h1>\n    </div>\n    <div id=\"mouse-xy\">\n      (0,0)\n    </div>\n    <script src=\"img/respondent_app.js\"></script>\n</body>\n</html>\n```", "```java\n created a new div element, which will contain the mouse position. It defaults to (0,0).\n```", "```java\n (ns respondent-app.core\n  (:require [respondent.core :as r]\n            [dommy.core :as dommy])\n  (:use-macros\n   [dommy.macros :only [sel1]]))\n\n(def mouse-pos-stream (r/event-stream))\n(set! (.-onmousemove js/document)\n      (fn [e]\n        (r/deliver mouse-pos-stream [(.-pageX e) (.-pageY e)])))\n\n(r/subscribe mouse-pos-stream\n             (fn [[x y]]\n               (dommy/set-text! (sel1 :#mouse-xy)\n                                (str \"(\" x \",\" y \")\"))))\n```", "```java\n$ lein compile\n\n```", "```java\n$ lein repl\nuser=> (run)\n\n```"]