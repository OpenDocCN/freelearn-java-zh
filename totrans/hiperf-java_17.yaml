- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit and Performance Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The importance of thoroughly testing our code cannot be overstated; moreover,
    this testing should be efficient. As our systems grow in complexity and scale,
    it becomes increasingly critical for us to ensure that every component of our
    software functions accurately and efficiently. This is where unit and performance
    testing comes into play. This is the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter starts by covering **unit testing**, which we use to verify individual
    units of code. The goal is to ensure that the units perform efficiently and as
    expected. Through unit testing, we can catch anomalies (bugs) early, before the
    code is deployed into a production environment. Performance testing is introduced
    as a complementary process, whereby we test our software under various conditions
    to assess behaviors such as responsiveness, availability, scalability, reliability,
    and scalability. As the chapter demonstrates, performance testing can help us
    identify potential bottlenecks and ensure our systems can handle anticipated use
    cases and loads.
  prefs: []
  type: TYPE_NORMAL
- en: Both theoretical and hands-on approaches are taken in this chapter, giving you
    the opportunity to gain knowledge and experience with unit and performance testing.
    We will cover overarching strategies to include integrating both types of testing,
    automation, test environments, continuous testing, and feedback loops.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a thorough understanding of unit and
    performance testing and be able to leverage them to enhance the reliability and
    efficiency of your Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overarching strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples and instructions in this chapter, you will need the ability
    to load, edit, and run Java code. If you have not set up your development environment,
    refer to [*Chapter 1*](B21942_01.xhtml#_idTextAnchor014), *Peeking Inside the
    Java Virtual* *Machine (JVM)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished code for this chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17](https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter17)'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The software developer’s adage of “test, test, and test again” still applies
    to modern systems but in a more refined way. Instead of testing our systems as
    a whole, we focus on small components of our code to ensure that they perform
    efficiently and as expected. These components are referred to as **units**. When
    we isolate units of code, we can more easily detect bugs and improve the overall
    quality of our code. This approach is referred to as unit testing and is the focus
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is an approach to software testing that involves testing the smallest
    sections of a system’s code to ensure that it performs correctly and efficiently
    in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary benefits of unit testing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bug detection**: Unit testing enables us to detect bugs early, before the
    code is published as part of the larger system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code quality**: This testing approach, with its finite focus, results in
    higher code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: The process of unit testing includes documentation of each
    unit’s functionality, purpose, connectivity, and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand what unit testing is and why it is important, let’s look
    at two popular unit testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common unit testing frameworks is **JUnit**, perhaps because
    of its simplicity and ease of integration with **Integrated Development Environments**
    (**IDEs**). Another popular framework is **TestNG**, which is comparatively more
    flexible and has functionality in addition to JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on JUnit and demonstrate how to write a unit test in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways you can write and implement unit testing. Here is a
    straightforward approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have a recent version of the **Java Development Kit** (**JDK**)
    installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and install the **JUnit Jupiter API and Engine JARs**. The process
    for accomplishing this will depend on your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming that you are using Visual Studio Code, install the **Test Runner for**
    **Java** extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To demonstrate unit testing, we will write a simple calculator program, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our application contains methods for adding, subtracting, multiplying,
    and dividing two numbers based on passed parameters. Next, let’s create a `testing`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we have created individual methods to
    test the methods in the primary class file. The next step is to run the test.
    Using Visual Studio Code, you can select the testing icon (the beaker in the leftmost
    panel). Now you can run individual tests, or all of the tests, by selecting the
    **Run Test** button to the right of each test name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – The Visual Studio Code navigation panel](img/B21942_17_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.1 – The Visual Studio Code navigation panel
  prefs: []
  type: TYPE_NORMAL
- en: 'The test results will be available in the bottom section of your `testMultiple()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates a simple unit test. Next, let’s review some best practices
    to help us get the most out of unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key best practice for unit testing is to keep the tests as small as possible.
    This will give us a tighter focus and allow us to more rapidly troubleshoot and
    resolve issues through code edits.
  prefs: []
  type: TYPE_NORMAL
- en: Another best practice is to ensure that our tests are **isolated tests**, which
    are tests that are independent of any external factors. This helps ensure that
    any errors or issues we detect are caused by our code and not an external environment.
    If we do not take this approach, we might struggle to efficiently determine the
    source of any errors.
  prefs: []
  type: TYPE_NORMAL
- en: A third practice is to ensure that our tests cover a myriad of scenarios, including
    error conditions and even edge cases. This is a thorough approach that strives
    to test for any possible situation. The extended time that this approach takes
    is worth it, as our approach can help ensure that our systems can perform under
    both routine and irregular conditions.
  prefs: []
  type: TYPE_NORMAL
- en: A fourth best practice, **assertions**, will be covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assertions are an important best practice. This best practice is simply to leverage
    assertions to validate expected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs: []
  type: TYPE_NORMAL
- en: Assertions are code statements that are used to check whether a condition is
    true.
  prefs: []
  type: TYPE_NORMAL
- en: When an assertion fails, it indicates that the condition evaluated by the assertion
    is false, which usually results in the unit test failing. There are several assertion
    methods that we can use in JUnit. Let’s look at four of the most common assertion
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`assertEquals`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assertions.assertEquals(expected, actual);`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`assertNotEquals`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assertions.assertNotEquals(unexpected, actual);`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`assertTrue`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assertions.assertTrue(condition)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`assertFalse`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assertions.assertFalse(condition);`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To use an assertion in our application, we simply add a line of code to each
    unit test. For example, as you review the `testAdd()` method in our `CH17CalculatorTest`
    application, you will see that it uses the `assertEquals()` assertion method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an understanding of some best practices in writing unit tests,
    let’s review some common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As powerful as unit testing is, it also comes with several pitfalls. Here are
    three common pitfalls involved with unit testing and how to avoid them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pitfall** | **Avoidance strategy** |'
  prefs: []
  type: TYPE_TB
- en: '| Ignoring edge cases | When we ignore edge cases in our unit testing, our
    systems can have undetected bugs. Ensure that you include a robust edge case strategy
    in your unit testing. |'
  prefs: []
  type: TYPE_TB
- en: '| Over-testing | Over-testing in our context is creating tests that are too
    large, covering multiple units. To avoid this pitfall, create unit tests that
    are isolated from external dependencies and are focused on a single unit of code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Under-testing | Under-testing refers to not running tests frequently enough
    to catch issues, especially when changing environments and scaling systems. To
    avoid this pitfall, perform tests frequently. |'
  prefs: []
  type: TYPE_TB
- en: Table 17.1 – Unit testing pitfalls and avoidance strategies
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude our coverage of unit testing with a look at **Test-Driven**
    **Development** (**TTD**).
  prefs: []
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TTD is an interesting software development approach whereby the unit tests are
    written before the code is. The TDD cycle is often referred to as **Red-Green-Refactor**
    and is illustrated in *Figure 17**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – The TTD cycle](img/B21942_17_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17.2 – The TTD cycle
  prefs: []
  type: TYPE_NORMAL
- en: TDD implementation starts with the Red step, wherein we write a test that fails
    because the related functionality has not been written. Next, in the Green step,
    we write the minimum amount of code required so the test will pass. Finally, in
    the Refactor step, we refactor our code to make it more efficient, improve its
    readability, and ensure that all related unit tests continue to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of implementing TDD include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Promoting clean code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the code is testable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helping developers thoroughly consider requirements before writing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few challenges to the TDD approach, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is not beginner-friendly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It requires a mental paradigm shift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can slow initial development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a firm handle on unit testing, let’s explore performance testing
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Performance testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The crux of this book has been to ensure our Java applications perform at the
    highest possible level. Several strategies, tools, and techniques have been presented
    to help us achieve our goal of high performance. In the previous section, we covered
    unit testing to help us ensure proper functionality. With performance testing,
    we will test our applications to see whether they can perform under various conditions
    and loads. This testing strategy involves evaluating the following characteristics
    of our applications: efficiency (speed), stability, responsiveness, reliability,
    and scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several primary objectives of performance testing, including the determination
    of whether performance criteria have been met. We also want to identify performance
    bottlenecks so that we can refine our code. An additional objective is to ensure
    that our application can handle anticipated system and user loads.
  prefs: []
  type: TYPE_NORMAL
- en: Types and tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The five primary types of performance tests are detailed in the table that
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Focus** |'
  prefs: []
  type: TYPE_TB
- en: '| **Endurance testing** | Checks for memory leaks and resource depletion with
    a sustained load over extended time |'
  prefs: []
  type: TYPE_TB
- en: '| **Load testing** | Tests performance with a specific number of concurrent
    users |'
  prefs: []
  type: TYPE_TB
- en: '| **Scalability testing** | Checks scalability by adding transactions and users
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Spike testing** | Determines whether the application can handle a sudden
    increase in load |'
  prefs: []
  type: TYPE_TB
- en: '| **Stress testing** | Pushes the load past capacity to determine the breaking
    point |'
  prefs: []
  type: TYPE_TB
- en: Table 17.2 – Performance test types
  prefs: []
  type: TYPE_NORMAL
- en: It is important to implement a performance testing plan that includes each type
    of performance test with an added focus on the types that are more critical to
    your specific application and goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several tools available to help us with performance testing. The
    three most common ones are featured in the table that follows. The table includes
    use cases for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool** | **Description** | **Use case** |'
  prefs: []
  type: TYPE_TB
- en: '| Apache Bench | Basic command-line tool for benchmarking HTTP servers | Simple
    load tests of HTTP services |'
  prefs: []
  type: TYPE_TB
- en: '| Apache JMeter | Open source tool for load testing | Comprehensive testing
    with a variety of protocols (that is, HTTP, FTP, and so on) |'
  prefs: []
  type: TYPE_TB
- en: '| Gatling | Advanced open source tool that simulates high user loads | Advanced
    load testing scenarios |'
  prefs: []
  type: TYPE_TB
- en: Table 17.3 – Performance testing tools
  prefs: []
  type: TYPE_NORMAL
- en: Let’s wrap up this chapter with a look at big-picture approaches that are specific
    to unit testing and performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Overarching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter’s previous two sections were focused on unit testing and performance
    testing. This final section considers how we might combine the two types of testing
    for a cohesive strategy. This duality of testing is critical to our ability to
    develop and maintain robust and highly efficient Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a look at how to integrate the two types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating unit and performance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few strategies we can adopt for incorporating both types of testing.
    The first approach is **parallel testing**, which involves running unit tests
    and performance tests in parallel. This approach can save us time. Another approach
    is **shared test cases**, which can make our testing more efficient. This approach
    allows us to leverage shared test data and potential configurations. A third,
    more advanced strategy is to use a **unified testing framework**. These frameworks
    support both types of testing and can ensure a seamless transition between them.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of our implementation approach, we want to ensure that we have comprehensive
    test coverage. To accomplish this, we should use tools to measure our code coverage
    for both testing types. This is referred to as **coverage analysis** and helps
    us ensure that all critical paths are tested. We should also use **incremental
    testing**, whereby we gradually increase our test coverage until all code has
    been covered by tests. Finally, we should conduct a **cross-validation** of our
    test results with performance outcomes. This validation is used to confirm that
    functionality is accurate and performance efficiency is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the critical role of testing in ensuring the reliability
    and efficiency of our Java applications. We started with an introduction to unit
    testing, highlighting its purpose, benefits, and best practices for writing effective
    tests. We then covered performance testing, explaining its objectives and the
    various types such as load and stress testing. The chapter concluded with a look
    at overarching strategies to integrate both testing types seamlessly into the
    development workflow, emphasizing the need for unified frameworks and comprehensive
    test coverage to enhance the overall quality and performance of our Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take an extensive look at how to leverage **Artificial
    Intelligence** (**AI**) tools and technologies to help ensure that our applications
    are as efficient as possible and that they perform at the highest possible level.
    The chapter offers several opportunities for developers to harness the power of
    AI for the betterment of their Java applications’ performance.
  prefs: []
  type: TYPE_NORMAL
