- en: Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the process of erecting a new building, a set of blueprints helps all related
    parties communicate--the architect, electricians, carpenters, plumbers, and so
    on. It details things such as shapes, sizes, and materials. Without them, each
    of the subcontractors would be left guessing as to what to do, where to do it,
    and how. Without these blueprints, modern architecture would be almost impossible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在建造一座新建筑的过程中，一套蓝图帮助所有相关方进行沟通——建筑师、电工、木匠、水管工等等。它详细说明了形状、尺寸和材料等内容。没有它们，每个分包商都会被留下猜测要做什么，在哪里做，以及如何做。没有这些蓝图，现代建筑几乎是不可能的。
- en: What is in your hands--or on the screen in front of you--is a set of blueprints
    of a different sort. Rather than detailing exactly how to build your specific
    software system, as each project and environment has unique constraints and requirements,
    these blueprints offer examples of how to build a variety of Java-based systems,
    providing examples of how to use specific features in the **Java Development Kit**,
    or **JDK**, with a special focus on the new features of Java 9 that you can then
    apply to your specific problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你手中的——或者在你面前的屏幕上——是一套不同类型的蓝图。这些蓝图并不是详细说明如何构建你的特定软件系统，因为每个项目和环境都有独特的约束和要求，这些蓝图提供了如何构建各种基于
    Java 的系统的示例，提供了如何使用 **Java 开发工具包**（**JDK**）中特定特性的示例，特别关注你可以应用于特定问题的 Java 9 的新特性。
- en: Since it would be impossible to build an application using only the new Java
    9 features, we will also be using and highlighting many of the newest features
    in the JDK. Before we get too far into what that entails, then, let's take a brief
    moment to discuss some of these great new features from recent major JDK releases.
    Hopefully, most Java shops are already on Java 7, so we'll focus on version 8
    and, of course, version 9.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仅使用新的 Java 9 特性构建应用程序是不可能的，因此我们还将使用并突出显示 JDK 中许多最新的特性。在我们深入探讨这涉及的内容之前，让我们简要地讨论一下最近主要
    JDK 发布的一些这些出色的新特性。希望大多数 Java 商店已经使用 Java 7，因此我们将重点关注版本 8，当然还有版本 9。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: New features in Java 8
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 的新特性
- en: New features in Java 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 的新特性
- en: Projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: New features in Java 8
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 8 的新特性
- en: Java 8, released on March 8, 2014, brought arguably two of the most significant
    features since Java 5, released in 2004--lambdas and streams. With functional
    programming gaining popularity in the JVM world, especially with the help of languages
    such as Scala, Java adherents had been clamoring for more functional-style language
    features for several years. Originally slated for release in Java 7, the feature
    was dropped from that release, finally seeing a stable release with Java 8.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8，于 2014 年 3 月 8 日发布，可能是自 2004 年发布的 Java 5 以来最具争议的两个特性——lambda 和 streams。随着函数式编程在
    JVM 世界中的流行，尤其是在 Scala 等语言的帮助下，Java 的拥护者已经呼吁了几年更多的函数式语言特性。最初计划在 Java 7 中发布，该特性被从那个版本中删除，最终在
    Java 8 中稳定发布。
- en: While it can be hoped that everyone is familiar with Java's lambda support,
    experience has shown that many shops, for a variety of reasons, are slow to adopt
    new language versions and features, so a quick introduction might be helpful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以希望每个人都熟悉 Java 的 lambda 支持，但经验表明，由于各种原因，许多公司对新的语言版本和特性的采用速度较慢，因此一个快速的介绍可能是有帮助的。
- en: Lambdas
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda
- en: 'The term lambda, which has its roots in lambda calculus, developed by Alonzo
    Church in 1936, simply refers to an anonymous function. Typically, a function
    (or method, in more proper Java parlance), is a statically-named artifact in the
    Java source:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 lambda，其根源在于由 Alonzo Church 在 1936 年开发的 lambda 演算，简单地说是指一个匿名函数。通常，一个函数（或方法，在更正式的
    Java 术语中），是 Java 源代码中的一个静态命名的工件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simple method is one named `add` that takes two `int` parameters as well
    as returning an `int` parameter. With the introduction of lambdas, this can now
    be written as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法被命名为 `add`，它接受两个 `int` 参数并返回一个 `int` 参数。随着 lambda 的引入，现在可以这样编写：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, more simply as this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地说，如下所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This abbreviated syntax indicates that we have a function that takes two parameters
    and returns their sum. Depending on where this lambda is used, the types of the
    parameters can be inferred by the compiler, making the second, even more concise
    format possible. Most importantly, though, note that this method is no longer
    named. Unless it is assigned to a variable or passed as a parameter (more on this
    later), it can not be referenced--or used--anywhere in the system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缩写语法表示我们有一个接受两个参数并返回它们和的函数。根据 lambda 的使用位置，编译器可以推断出参数的类型，这使得第二个，甚至更简洁的格式成为可能。最重要的是，注意这个方法不再有名字。除非它被分配给变量或作为参数传递（稍后会更详细地讨论这一点），否则它不能在任何系统中的任何地方被引用或使用。
- en: 'This example, of course, is absurdly simple. A better example of this might
    be in one of the many APIs where the method''s parameter is an implementation
    of what is known as a **Single Abstract Method** (**SAM**) interface, which is,
    at least until Java 8, an interface with a single method. One of the canonical
    examples of a SAM is `Runnable`. Here is an example of the pre-lambda `Runnable`
    usage:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个例子过于简单。更好的例子可能出现在许多 API 中，其中方法的参数是实现所谓的 **单抽象方法（SAM**）接口的实现，至少在 Java 8
    之前，这是一个只有一个方法的接口。`Runnable` 是 SAM 的一个典型例子。以下是一个 pre-lambda `Runnable` 使用的例子：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With Java 8 lambdas, this code can be vastly simplified to this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 8 的 lambda，这段代码可以大大简化为以下形式：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The body of the `Runnable` method is still pretty trivial, but the gains in
    clarity and conciseness should be pretty obvious.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable` 方法的体仍然相当简单，但清晰度和简洁度的提升应该是相当明显的。'
- en: 'While lambdas are anonymous functions (that is, they have no names), Java lambdas,
    as is the case in many other languages, can also be assigned to variables and
    passed as parameters (indeed, the functionality would be almost worthless without
    this capability). Revisiting the `Runnable` method in the preceding code, we can
    separate the declaration and the use of `Runnable` as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 lambda 是匿名函数（也就是说，它们没有名字），但 Java 的 lambda，就像许多其他语言一样，也可以分配给变量并作为参数传递（实际上，如果没有这种功能，功能几乎毫无价值）。回顾前面代码中的
    `Runnable` 方法，我们可以将 `Runnable` 的声明和使用分开，如下所示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is intentionally more verbose than the preceding example. The stubbed out
    body of the `Runnable` method is intended to mimic, after a fashion, how a real-world
    `Runnable` may look and why one may want to assign the newly-defined `Runnable`
    method to a variable in spite of the conciseness that lambdas offer. This new
    lambda syntax allows us to declare the body of the `Runnable` method without having
    to worry about method names, signatures, and so on. It is true that any decent
    IDE would help with this kind of boilerplate, but this new syntax gives you, and
    the countless developers who will maintain your code, much less noise to have
    to parse when debugging the code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这比前面的例子更冗长。`Runnable` 方法的占位符体旨在模仿现实世界中的 `Runnable` 可能的样子，以及为什么尽管 lambda 提供了简洁性，人们可能仍然希望将新定义的
    `Runnable` 方法分配给变量。这种新的 lambda 语法允许我们声明 `Runnable` 方法的体，而无需担心方法名、签名等。诚然，任何不错的
    IDE 都会帮助处理这种样板代码，但这种新的语法为您和将维护您的代码的无穷无尽的开发者提供了更少的噪音，以便在调试代码时解析。
- en: Any SAM interface can be written as a lambda. Do you have a comparator that
    you really only need to use once?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 SAM 接口都可以写成 lambda。您有一个只需要使用一次的比较器吗？
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How about `ActionListener`?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `ActionListener` 呢？
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Additionally, you can use your own SAM interfaces in lambdas as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在 lambda 中使用自己的 SAM 接口，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of the advantages of this approach is that it not only makes the consuming
    code more concise, but it also reduces the level of effort, such as it is, in
    creating some of these concrete SAM instances. That is to say, rather than having
    to decide between an anonymous class and a concrete, named class, the developer
    can declare it inline, cleanly and concisely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点不仅使消费代码更加简洁，而且也减少了创建这些具体 SAM 实例的努力。也就是说，开发者不必在匿名类和具体命名类之间做出选择，而可以声明它，干净且简洁。
- en: 'In addition to the SAMs Java developers have been using for years, Java 8 introduced
    a number of functional interfaces to help facilitate more functional style programming.
    The Java 8 Javadoc lists 43 different interfaces. Of these, there are a handful
    of basic function **shapes** that you should know of, some of which are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Java开发者多年来一直在使用的SAMs（单抽象方法接口）之外，Java 8引入了许多功能接口，以帮助促进更函数式风格的编程。Java 8的Javadoc列出了43个不同的接口。在这些接口中，有一些基本的函数**形状**你应该了解，其中一些如下：
- en: '| `BiConsumer<T,U>` | This represents an operation that accepts two input arguments
    and returns no result |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `BiConsumer<T,U>` | 这表示一个接受两个输入参数且不返回结果的操作 |'
- en: '| `BiFunction<T,U,R>` | This represents a function that accepts two arguments
    and produces a result |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `BiFunction<T,U,R>` | 这表示一个接受两个参数并产生结果的函数 |'
- en: '| `BinaryOperator<T>` | This represents an operation upon two operands of the
    same type, producing a result of the same type as the operands |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `BinaryOperator<T>` | 这表示对两个相同类型的操作数进行操作，产生与操作数相同类型的结果 |'
- en: '| `BiPredicate<T,U>` | This represents a predicate (Boolean-valued function)
    of two arguments |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `BiPredicate<T,U>` | 这表示一个接受两个参数的谓词（布尔值函数） |'
- en: '| `Consumer<T>` | This represents an operation that accepts a single input
    argument and returns no result |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `Consumer<T>` | 这表示一个接受单个输入参数且不返回结果的操作 |'
- en: '| `Function<T,R>` | This represents a function that accepts one argument and
    produces a result |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `Function<T,R>` | 这表示一个接受一个参数并产生结果的函数 |'
- en: '| `Predicate<T>` | This represents a predicate (Boolean-valued function) of
    one argument |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Predicate<T>` | 这表示一个接受一个参数的谓词（布尔值函数） |'
- en: '| `Supplier<T>` | This represents a supplier of results |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Supplier<T>` | 这表示一个结果提供者 |'
- en: There are a myriad of uses for these interfaces, but perhaps the best way to
    demonstrate some of them is to turn our attention to the next big feature in Java
    8--Streams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口有无数的使用场景，但也许最好的方式是将注意力转向Java 8的下一个重要特性——Streams。
- en: Streams
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流
- en: The other major addition to Java 8, and, perhaps where lambdas shine the brightest,
    is the new **Streams API**. If you were to search for a definition of Java streams,
    you would get answers that range from the somewhat circular **a stream of data
    elements** to the more technical **Java streams are monads**, and they're probably
    both right. The Streams API allows the Java developer to interact with a stream
    of data elements via a **sequence of steps**. Even putting it that way isn't as
    clear as it could be, so let's see what it means by looking at some sample code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8的另一个主要新增功能，也许是最能体现lambda表达式优势的地方，就是新的**Streams API**。如果你要搜索Java流的定义，你会得到从“数据元素流”这样的相对循环定义到“Java流是monads”这样的更技术性的定义，两者可能都是正确的。Streams
    API允许Java开发者通过一系列步骤与数据元素流进行交互。即使这样描述也不是非常清晰，所以让我们通过查看一些示例代码来了解它的含义。
- en: 'Let''s say you have a list of grades for a particular class. You would like
    to know what the average grade is for the girls in the class. Prior to Java 8,
    you might have written something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个特定班级的分数列表。你可能想知道班级中女生的平均分数。在Java 8之前，你可能写成这样：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We initialize two variables, one to store the sums and one to count the number
    of hits. Next, we loop through the grades. If the student''s gender is female,
    we increment our counter and update the sum. When the loop terminates, we then
    have the information we need to calculate the average. This works, but it''s a
    bit verbose. The new Streams API can help with that:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化两个变量，一个用于存储总和，一个用于计数。然后我们遍历分数。如果学生的性别是女性，我们增加计数器并更新总和。当循环结束时，我们就有了计算平均分所需的信息。这可以工作，但有点冗长。新的Streams
    API可以帮助解决这个问题：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This new version is not significantly smaller, but the purpose of the code
    is much clearer. In the preceding pre-stream code, we have to play computer, parsing
    the code and teasing out its intended purpose. With streams, we have a clear,
    declarative means to express application logic. For each entry in the map do the
    following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本并没有显著减小，但代码的目的更加清晰。在之前的非流代码中，我们必须像计算机一样解析代码，并推断其预期目的。使用流，我们有清晰、声明性的方式来表达应用逻辑。对于映射中的每个条目执行以下操作：
- en: Filter out each entry whose `gender` is not `F`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤掉所有`gender`不是`F`的条目。
- en: Map each value to the primitive int.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个值映射到原始的int类型。
- en: Average the grades.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算平均分数。
- en: Return the value as a double.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值作为double类型返回。
- en: With the stream-based and lamba-based approach, we don't need to declare temporary,
    intermediate variables (grade count and total), and we don't need to worry about
    calculating the admittedly simple average. The JDK does all of the heavy-lifting
    for us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于流和lambda的方法，我们不需要声明临时、中间变量（成绩计数和总分），也不需要担心计算平均数。JDK为我们做了所有的繁重工作。
- en: The new java.time package
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的java.time包
- en: 'While lambdas and streams are extremely important game-changing updates, with
    Java 8, we were given another long-awaited change that was, at least in some circles,
    just as exciting: a new date/time API. Anyone who has worked with dates and times
    in Java knows the pain of `java.util.Calendar` and company. Clearly, you can get
    your work done, but it''s not always pretty. Many developers found the API too
    painful to use, so they integrated the extremely popular Joda Time library into
    their projects. The Java architects agreed, and engaged Joda Time''s author, Stephen
    Colebourne, to lead JSR 310, which brought a version of Joda Time (fixing various
    design flaws) to the platform. We''ll take a detailed look at how to use some
    of these new APIs in our date/time calculator later in the book.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 lambda 表达式和流式处理是极其重要的变革性更新，但在Java 8中，我们还得到了另一个长期期待的改变，至少在某些圈子中，它同样令人兴奋：一个新的日期/时间API。任何在Java中处理日期和时间的开发者都知道`java.util.Calendar`及其公司的痛苦。显然，你可以完成你的工作，但并不总是那么美观。许多开发者发现API的使用过于痛苦，因此他们将其集成到他们的项目中。Java架构师也同意这一点，并聘请了Joda
    Time的作者Stephen Colebourne领导JSR 310，将Joda Time（修复各种设计缺陷）的一个版本带到了平台上。我们将在本书的后面部分详细探讨如何使用这些新的API。
- en: Default methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认方法
- en: 'Before turning our attention to Java 9, let''s take a look at one more significant
    language feature: default methods. Since the beginning of Java, an interface was
    used to define how a class looks, implying a certain type of behavior, but was
    unable to implement that behavior. This made polymorphism much simpler in a lot
    of cases, as any number of classes could implement a given interface, and the
    consuming code treats them as that interface, rather than whatever concrete class
    they actually are.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将注意力转向Java 9之前，让我们先看看另一个重要的语言特性：默认方法。自从Java开始以来，接口被用来定义类的外观，暗示了一种特定的行为，但无法实现这种行为。这使得在许多情况下多态性变得更加简单，因为任何数量的类都可以实现给定的接口，并且消费代码将它们视为该接口，而不是它们实际是的具体类。
- en: One of the problems that have confronted API developers over the years, though,
    was how to evolve an API and its interfaces without breaking existing code. For
    example, take the `ActionSource` interface from the JavaServer Faces 1.1 specification.
    When the JSF 1.2 expert group was working on the next revision of the specification,
    they identified the need to add a new property to the interface, which would result
    in two new methods--the getters and setters. They could not simply add the methods
    to the interface, as that would break every implementation of the specification,
    requiring the maintainers of the implementation to update their classes. Obviously,
    this sort of breakage is unacceptable, so JSF 1.2 introduced `ActionSource2`,
    which extends `ActionSource` and adds the new methods. While this approach is
    considered ugly by many, the 1.2 expert group had a few choices, and none of them
    were very good.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多年来API开发者面临的一个问题是如何在不破坏现有代码的情况下演进API及其接口。例如，以JavaServer Faces 1.1规范中的`ActionSource`接口为例。当JSF
    1.2专家小组在制定规范的下一个版本时，他们确定需要向接口添加一个新属性，这将导致两个新方法——获取器和设置器。他们不能简单地添加方法到接口中，因为这会破坏规范的所有实现，需要实现者更新他们的类。显然，这种破坏是不可接受的，因此JSF
    1.2引入了`ActionSource2`，它扩展了`ActionSource`并添加了新方法。虽然这种方法被许多人认为很丑陋，但1.2专家小组有几个选择，而且没有一个选择是很好的。
- en: 'With Java 8, though, interfaces can now specify a default method on the interface
    definition, which the compiler will use for the method implementation if the extending
    class does not provide one. Let''s take the following piece of code as an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Java 8的到来，接口现在可以在接口定义上指定默认方法，如果扩展类没有提供该方法，编译器将使用该方法实现。以下代码片段可以作为例子：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ve developed our API and made it available to the public, and it''s proved
    to be really popular. Over time, though, we''ve identified an improvement we''d
    like to make: we''d like to add some convenience methods, such as `sayHello()`
    and `sayGoodbye()`, to save our users a little time. However, as discussed earlier,
    if we just add these new methods to the interface, we''ll break our users'' code
    as soon as they update to the new version of the library. Default methods allow
    us to extend the interface and avoid the breakage by defining an implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开发了自己的API并将其公开，并且它证明非常受欢迎。然而，随着时间的推移，我们发现了一个我们想要改进的地方：我们希望添加一些便利方法，例如`sayHello()`和`sayGoodbye()`，以节省我们的用户一些时间。然而，正如之前讨论的那样，如果我们只是将这些新方法添加到接口中，一旦用户更新到库的新版本，就会破坏他们的代码。默认方法允许我们扩展接口，并通过定义一个实现来避免破坏：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when users update their library JARs, they immediately gain these new methods
    and their behavior, without making any changes. Of course, to use these methods,
    the users will need to modify their code, but they need not do so until--and if--they
    want to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户更新他们的库JAR文件时，他们立即获得这些新方法和它们的行为，而无需做出任何更改。当然，要使用这些方法，用户将需要修改他们的代码，但他们不需要这样做，直到——如果——他们想要这样做。
- en: New features in Java 9
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9的新特性
- en: As with any new version of the JDK, this release was packed with a lot of great
    new features. Of course, what is most appealing will vary based on your needs,
    but we'll focus specifically on a handful of these new features that are most
    relevant to the projects we'll build together. First up is the most significant,
    the Java Module System.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何新的JDK版本一样，这个版本包含了大量令人兴奋的新特性。当然，最吸引人的特性将根据您的需求而有所不同，但我们将特别关注一些与我们共同构建的项目最相关的几个新特性。首先是最大的一个，Java模块系统。
- en: Java Platform Module System/Project Jigsaw
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java平台模块系统/Project Jigsaw
- en: Despite being a solid, feature-packed release, Java 8 was considered by a fair
    number to be a bit disappointing. It lacked the much anticipated **Java Platform
    Module System** (**JPMS**), also known more colloquially, though not quite accurately,
    as Project Jigsaw. The Java Platform Module System was originally slated to ship
    with Java 7 in 2011, but it was deferred to Java 8 due to some lingering technical
    concerns. Project Jigsaw was started not only to finish the module system, but
    also to modularize the JDK itself, which would help Java SE scale down to smaller
    devices, such as mobile phones and embedded systems. Jigsaw was scheduled to ship
    with Java 8, which was released in 2014, but it was deferred yet again, as the
    Java architects felt they still needed more time to implement the system correctly.
    At long last, though, Java 9 will finally deliver this long-promised project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java 8是一个功能齐全的版本，但许多人认为它有些令人失望。它缺乏备受期待的**Java平台模块系统**（**JPMS**），虽然更通俗地被称为Project
    Jigsaw，但并不完全准确。Java平台模块系统最初计划于2011年与Java 7一起发布，但由于一些悬而未决的技术问题而被推迟到Java 8。Project
    Jigsaw不仅是为了完成模块系统，还为了模块化JDK本身，这将有助于Java SE缩小到更小的设备，如移动电话和嵌入式系统。Jigsaw计划与2014年发布的Java
    8一起发布，但它再次被推迟，因为Java架构师认为他们还需要更多时间来正确实施该系统。然而，最终，Java 9将最终交付这个长期承诺的项目。
- en: That said, what exactly is it? One problem that has long haunted API developers,
    including the JDK architects, is the inability to hide implementation details
    of public APIs. A good example from the JDK of private classes that developers
    should not be using directly is the `com.sun.*/sun.*` packages and classes. A
    perfect example of this--of private APIs finding widespread public use--is the
    `sun.misc.Unsafe` class. Other than a strongly worded warning in Javadoc about
    not using these internal classes, there's little that could be done to prevent
    their use. Until now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这究竟是什么呢？长期以来一直困扰着API开发者，包括JDK架构师的一个问题是无法隐藏公共API的实现细节。一个来自JDK的例子是开发者不应直接使用的私有类，例如`com.sun.*/sun.*`包和类。一个完美的例子——私有API被广泛用于公共领域——是`sun.misc.Unsafe`类。除了在Javadoc中有一个措辞强烈的警告，不要使用这些内部类之外，几乎没有其他方法可以阻止它们的使用。直到现在。
- en: With the JPMS, developers will be able to make implementation classes public
    so that they may be easily used inside their projects, but not expose them outside
    the module, meaning they are not exposed to consumers of the API or library. To
    do this, the Java architects have introduced a new file, `module-info.java`, similar
    to the existing `package-info.java` file, found at the root of the module, for
    example, at `src/main/java/module-info.java`. It is compiled to `module-info.class`,
    and is available at runtime via reflection and the new `java.lang.Module` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JPMS，开发者将能够使实现类公开，以便它们可以在项目中轻松使用，但又不暴露给模块外部，这意味着它们不会暴露给API或库的消费者。为此，Java架构师引入了一个新的文件，`module-info.java`，类似于现有的`package-info.java`文件，位于模块的根目录中，例如，在`src/main/java/module-info.java`。它被编译成`module-info.class`，并在运行时通过反射和新的`java.lang.Module`类可用。
- en: 'So what does this file do, and what does it look like? Java developers can
    use this file to name the module, list its dependencies, and express to the system,
    both compile and runtime, which packages are exported to the world. For example,
    suppose, in our preceding stream example, we have three packages: `model`, `api`,
    and `impl`. We want to expose the models and the API classes, but not any of the
    implementation classes. Our `module-info.java` file may look something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个文件的作用是什么，它的样子又是什么样的呢？Java开发者可以使用这个文件来命名模块，列出其依赖项，并向系统表达，无论是编译时还是运行时，哪些包被导出到外部世界。例如，假设在我们前面的流示例中，我们有三个包：`model`、`api`和`impl`。我们希望暴露模型和API类，但不暴露任何实现类。我们的`module-info.java`文件可能看起来像这样：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This definition exposes the two packages we want to export, and also declares
    a dependency on the `com.foo` module. If this module is not available at compile-time,
    the project will not build, and if it is not available at runtime, the system
    will throw an exception and exit. Note that the `requires` statement does not
    specify a version. This is intentional, as it was decided not to tackle the version-selection
    issue as part of the module system, leaving that to more appropriate systems,
    such as build tools and containers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义暴露了我们想要导出的两个包，并且也声明了对`com.foo`模块的依赖。如果在编译时该模块不可用，项目将无法构建；如果在运行时不可用，系统将抛出异常并退出。请注意，`requires`语句没有指定版本。这是故意的，因为决定不将版本选择问题作为模块系统的一部分来处理，而是将其留给更合适的系统，例如构建工具和容器。
- en: Much more could be said about the module system, of course, but an exhaustive
    discussion of all of its features and limitations is beyond the scope of this
    book. We will be implementing our applications as modules, though, so we'll see
    the system used--and perhaps explained in a bit more detail--throughout the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于模块系统还可以说很多，但对其所有功能和局限性的详尽讨论超出了本书的范围。不过，我们将以模块的形式实现我们的应用程序，因此我们将在整本书中看到系统的使用——也许会有更详细的解释。
- en: Those wanting a more in-depth discussion of the Java Platform Module System
    can search for the article, *The State of the Module System*, by Mark Reinhold.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更深入讨论Java平台模块系统的读者可以搜索马克·雷诺尔德的文章《模块系统现状》。
- en: Process handling API
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程处理API
- en: 'In prior versions of Java, developers interacting with native operating system
    processes had to use a fairly limited API, with some operations requiring resorting
    to native code. As part of **Java Enhancement Proposal** (**JEP**) 102, the Java
    process API was extended with the following features (quoting from the JEP text):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java的早期版本中，与本地操作系统进程交互的开发者必须使用一个相当有限的API，一些操作需要回退到本地代码。作为**Java增强提案**（**JEP**）102的一部分，Java进程API被扩展了以下功能（引用自JEP文本）：
- en: The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前Java虚拟机pid以及使用现有API创建的进程pid的能力。
- en: The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举系统上进程的能力。每个进程的信息可能包括其pid、名称、状态以及可能的使用资源。
- en: The ability to deal with process trees; in particular, some means to destroy
    a process tree.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理进程树的能力；特别是，一些销毁进程树的方法。
- en: The ability to deal with hundreds of subprocesses, perhaps multiplexing the
    output or error streams to avoid creating a thread per subprocess.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理数百个子进程的能力，可能通过复用输出或错误流来避免为每个子进程创建一个线程。
- en: We will explore these API changes in our first project, the Process Viewer/Manager
    (see the following sections for details).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的第一个项目中探索这些API更改，即进程查看器/管理器（有关详细信息，请参阅以下章节）。
- en: Concurrency changes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发更改
- en: 'As was done in Java 7, the Java architects revisited the concurrency libraries,
    making some much needed changes, this time in order to support the reactive-streams
    specification. These changes include a new class, `java.util.concurrent.Flow`,
    with several nested interfaces: `Flow.Processor`, `Flow.Publisher`, `Flow.Subscriber`,
    and `Flow.Subscription`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Java 7所做的那样，Java架构师重新审视了并发库，进行了一些必要的更改，这次是为了支持reactive-streams规范。这些更改包括一个新类`java.util.concurrent.Flow`，它包含几个嵌套接口：`Flow.Processor`、`Flow.Publisher`、`Flow.Subscriber`和`Flow.Subscription`。
- en: REPL
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL
- en: 'One change that seems to excite a lot of people isn''t a language change at
    all. It''s the addition of a **REPL** (**Read-Eval-Print-Loop**), a fancy term
    for a language shell. In fact, the command for this new tool is `jshell`. This
    tool allows us to type or paste in Java code and get immediate feedback. For example,
    if we wanted to experiment with the Streams API discussed in the preceding section,
    we could do something like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎有很多令人兴奋的变化并不是语言上的变化。而是添加了一个**REPL**（**读取-评估-打印-循环**），这是一个语言壳的高级术语。实际上，这个新工具的命令是`jshell`。这个工具允许我们输入或粘贴Java代码并立即获得反馈。例如，如果我们想实验前面章节中讨论的Streams
    API，我们可以这样做：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a very welcome addition that should help Java developers rapidly prototype
    and test their ideas.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常受欢迎的添加，应该有助于Java开发者快速原型设计和测试他们的想法。
- en: Projects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: With that brief and high-level overview of what new features are available to
    use, what do these blueprints we'll cover look like? We'll build ten different
    applications, varying in complexity and kind, and covering a wide range of concerns.
    With each project, we'll pay special attention to the new features we're highlighting,
    but we'll also see some older, tried and true language features and libraries
    used extensively, with any interesting or novel usages flagged. Here, then, is
    our project lineup.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要而高层次地概述了可用的新功能之后，我们将要覆盖的这些蓝图看起来是什么样子？我们将构建十个不同类型的应用程序，这些应用程序在复杂性和种类上有所不同，并涵盖广泛的问题。在每个项目中，我们将特别关注我们强调的新功能，但也会看到一些较旧的、经过验证的语言特性和库被广泛使用，任何有趣或新颖的使用都会被标记出来。因此，以下是我们的项目阵容。
- en: Process Viewer/Manager
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程查看器/管理器
- en: We will explore some of the improvements to the process handling APIs as we
    implement a Java version of the age old Unix tool--**top**. Combining this API
    with JavaFX, we'll build a graphical tool that allows the user to view and manage
    processes running on the system.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现古老的Unix工具——**top**的Java版本时，我们将探索一些进程处理API的改进。结合这个API和JavaFX，我们将构建一个图形工具，允许用户查看和管理系统上运行的过程。
- en: 'This project will cover the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Java 9 Process API enhancements
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9 进程API增强
- en: JavaFX
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Duplicate File Finder
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复文件查找器
- en: As a system ages, the chances of clutter in the filesystem, especially duplicated
    files, increases exponentially, it seems. Leveraging some of the new File I/O
    libraries, we'll build a tool to scan a set of user-specified directories to identify
    duplicates. Pulling JavaFX back out of the toolbox, we'll add a graphical user
    interface that will provide a more user-friendly means to interactively process
    the duplicates.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统老化，文件系统中的杂乱无章，尤其是重复文件的可能性似乎呈指数增长。利用一些新的文件I/O库，我们将构建一个工具来扫描一组用户指定的目录以识别重复文件。将JavaFX重新放回工具箱中，我们将添加一个图形用户界面，它将提供更用户友好的方式来交互式地处理重复文件。
- en: 'This project will cover the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Java File I/O
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 文件I/O
- en: Hashing libraries
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希库
- en: JavaFX
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: Date Calculator
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期计算器
- en: 'With the release of Java 8, Oracle integrated a new library based on a redesign
    of Joda Time, more or less, into the JDK. Officially known as JSR 310, this new
    library fixed a longstanding complaint with the JDK--the official date libraries
    were inadequate and hard to use. In this project, we''ll build a simple command-line
    date calculator that will take a date and, for example, add an arbitrary amount
    of time to it. Consider the following piece of code for example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 8的发布，Oracle将基于对Joda Time的重设计，或多或少地集成到一个新的库中，即JDK。官方称为JSR 310，这个新库解决了JDK长期存在的问题——官方日期库不足且难以使用。在本项目中，我们将构建一个简单的命令行日期计算器，它将接受一个日期，例如，并添加任意数量的时间。以下是一段示例代码：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This project will cover the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Java 8 Date/Time APIs
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 日期/时间API
- en: Regular expressions
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Java command-line libraries
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java命令行库
- en: Social Media Aggregator
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交媒体聚合器
- en: 'One of the problems with having accounts on so many social media networks is
    keeping tabs on what''s happening on each of them. With accounts on Twitter, Facebook,
    Google+, Instagram, and so on, active users can spend a significant amount of
    time jumping from site to site, or app to app, reading the latest updates. In
    this chapter, we''ll build a simple aggregator app that will pull the latest updates
    from each of the user''s social media accounts and display them in one place.
    The features will include the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么多社交媒体网络上拥有账户的一个问题是跟踪每个平台上发生的事情。拥有Twitter、Facebook、Google+、Instagram等账户的活跃用户可能会花费大量时间在不同的网站或应用程序之间跳转，阅读最新的更新。在本章中，我们将构建一个简单的聚合器应用程序，它将从用户的每个社交媒体账户中提取最新的更新，并在一个地方显示它们。功能将包括以下内容：
- en: 'Multiple accounts for a variety of social media networks:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个社交媒体网络的账户：
- en: Twitter
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter
- en: Pinterest
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pinterest
- en: Instagram
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Instagram
- en: Read-only, rich listings of social media posts
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读的社交媒体帖子丰富列表
- en: Links to the appropriate site or app for a quick and easy follow-up
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接到适当的网站或应用程序，以便快速轻松地跟进
- en: Desktop and mobile versions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面和移动版本
- en: 'This project will cover the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: REST/HTTP clients
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST/HTTP客户端
- en: JSON processing
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON处理
- en: JavaFX and Android development
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX和Android开发
- en: 'Given the size and scope of this effort, we''ll actually do this in two chapters:
    JavaFX in the first, and Android in the second.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这项工作的规模和范围，我们将实际上分两章来完成：第一章是JavaFX，第二章是Android。
- en: Email filter
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件过滤器
- en: Managing email can be tricky, especially if you have more than one account.
    If you access your mail from more than one location (that is, from more than one
    desktop or mobile app), managing your email rules can be trickier still. If your
    mail system doesn't support rules stored on the server, you're left deciding where
    to put the rules so that they'll run most often. With this project, we'll develop
    an application that will allow us to author a variety of rules and then run them
    via an optional background process to keep your mail properly curated at all times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 管理电子邮件可能很棘手，尤其是如果你有多个账户。如果你从多个位置（即从多个桌面或移动应用程序）访问你的邮件，管理你的邮件规则可能会更加棘手。如果你的邮件系统不支持存储在服务器上的规则，你将决定将规则放在哪里，以便它们最常运行。通过这个项目，我们将开发一个应用程序，允许我们编写各种规则，并通过可选的后台进程运行它们，以始终保持你的邮件得到适当的整理。
- en: 'A sample `rules` file may look something like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例`rules`文件可能看起来像这样：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This project will cover the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: JavaMail
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaMail
- en: JavaFX
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: JSON Processing
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON处理
- en: Operating System integration
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统集成
- en: File I/O
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件输入/输出
- en: JavaFX photo management
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX照片管理
- en: The Java Development Kit has a very robust assortment of image handling APIs.
    In Java 9, these were augmented with improved support for the TIFF specification.
    In this chapter, we'll exercise this API in creating an image/photo management
    application. We'll add support for importing images from user-specified locations
    into the configured official directory. We'll also revisit the duplicate file
    finder and reuse some of the code developed as a part of the project to help us
    identify duplicate images.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Java开发工具包提供了一套非常强大的图像处理API。在Java 9中，这些API通过改进对TIFF规范的支持得到了增强。在本章中，我们将通过创建图像/照片管理应用程序来练习这个API。我们将添加从用户指定的位置导入图像到配置的官方目录的支持。我们还将回顾重复文件查找器，并重用项目开发中的一些代码，以帮助我们识别重复的图像。
- en: 'This project will cover the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: The new `javax.imageio` package
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`javax.imageio`包
- en: JavaFX
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: NetBeans Rich Client Platform
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBeans富客户端平台
- en: Java file I/O
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java文件输入/输出
- en: A client/server note application
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端/服务器笔记应用程序
- en: Have you ever used a cloud-based note-taking application? Have you wondered
    what it would take to make your own? In this chapter, we'll create such an application,
    with complete front and backends. On the server side, we'll store our data in
    the ever popular document database, MongoDB, and we'll expose the appropriate
    parts of the business logic for the application via REST interfaces. On the client
    side, we'll develop a very basic user interface in JavaScript that will let us
    experiment with, and demonstrate how to use, JavaScript in our Java project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经使用过基于云的笔记应用？你是否想过要创建自己的应用？在本章中，我们将创建这样一个应用，包括完整的前端和后端。在服务器端，我们将数据存储在广受欢迎的文档数据库
    MongoDB 中，并通过 REST 接口公开应用程序的业务逻辑的适当部分。在客户端，我们将使用 JavaScript 开发一个非常基本的用户界面，这将使我们能够实验并展示如何在
    Java 项目中使用 JavaScript。
- en: 'This project will cover the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Document databases (MongoDB)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库（MongoDB）
- en: JAX-RS and RESTful interfaces
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RS 和 RESTful 接口
- en: JavaFX
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: JavaScript and Vue 2
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 和 Vue 2
- en: Serverless Java
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器 Java
- en: Serverless, also known as **function as a service** (**FaaS**), is one of the
    hottest trends these days. It is an application/deployment model where a small
    function is deployed to a service that manages almost every aspect of the function--startup,
    shutdown, memory, and so on, freeing the developer from worrying about such details.
    In this chapter, we'll write a simple serverless Java application to see how it
    might be done, and how you might use this new technique for your own applications.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器，也称为**函数即服务**（**FaaS**），是目前最热门的趋势之一。它是一种应用/部署模型，其中一个小型函数被部署到一个管理函数几乎所有方面的服务中——启动、关闭、内存等，从而让开发者从担心这些细节中解脱出来。在本章中，我们将编写一个简单的无服务器
    Java 应用程序，看看它是如何完成的，以及你如何可能在自己的应用程序中使用这项新技术。
- en: 'This project will cover the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Creating an Amazon Web Services account
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建亚马逊网络服务账户
- en: Configuring AWS Lambda, Simple Notification Service, Simple Email Service, and
    DynamoDB
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 AWS Lambda、简单通知服务、简单电子邮件服务和 DynamoDB
- en: Writing and deploying a Java function
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和部署 Java 函数
- en: Android desktop synchronization client
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓桌面同步客户端
- en: 'With this project, we''ll change gears a little bit and focus specifically
    on a different part of the Java ecosystem: Android. To do this, we''ll focus on
    a problem that still plagues some Android users--the synchronization of an Android
    device and a desktop (or laptop) system. While various cloud providers are pushing
    us to store more and more in the cloud and streaming that to devices, some people
    still prefer to store, for example, photos and music directly on the device for
    a variety of reasons, ranging from cost for cloud resources to unreliable wireless
    connectivity and privacy concerns.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个项目，我们将稍微改变一下方向，专注于 Java 生态系统的一个不同部分：安卓。为此，我们将关注一些安卓用户仍然面临的问题——安卓设备和桌面（或笔记本电脑）系统的同步。虽然各种云服务提供商都在推动我们将越来越多的内容存储在云端并流式传输到设备上，但有些人仍然出于各种原因（从云资源的成本到不可靠的无线连接和隐私问题）更愿意直接在设备上存储照片和音乐。
- en: In this chapter, we'll build a system that will allow users to synchronize music
    and photos between their devices and their desktop or laptop. We'll build an Android
    application that provides the user interface to configure and monitor synchronization
    from the mobile device side as well as the Android Service that will perform the
    synchronization in the background, if desired. We will also build the related
    components on the desktop--a graphical application to configure and monitor the
    process from the desktop as well as a background process to handle the synchronization
    from the desktop side.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个系统，允许用户在他们的设备和桌面或笔记本电脑之间同步音乐和照片。我们将构建一个安卓应用程序，为用户提供从移动设备端配置和监控同步的用户界面，以及一个安卓服务，如果需要，将在后台执行同步。我们还将构建桌面上的相关组件——一个图形应用程序，用于从桌面配置和监控过程，以及一个后台进程，用于处理桌面端的同步。
- en: 'This project will cover the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将涵盖以下内容：
- en: Android
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓
- en: User interfaces
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: Services
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: JavaFX
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaFX
- en: REST
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST
- en: Getting started
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'We have taken a quick look at some of the new language features we will be
    using. We have also seen a quick overview of the projects we will be building.
    One final question remains: what tools will we be using to do our work?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速浏览了一些我们将使用的新语言特性。我们还快速概述了我们将要构建的项目。最后还有一个问题：我们将使用什么工具来完成我们的工作？
- en: The Java ecosystem suffers from an embarrassment of riches when it comes to
    development tools, so we have much to choose from. The most fundamental choice
    facing us is the build tool. For our work here, we will be using Maven. While
    there is a strong and vocal community that would advocate Gradle, Maven seems
    to be the most common build tool at the moment, and seems to have more robust,
    mature, and native support from the major IDEs. If you do not have Maven already
    installed, you can visit [http://maven.apache.org](http://maven.apache.org/) and
    download the distribution for your operating system, or use whatever package management
    system is supported by your OS.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到开发工具时，Java 生态系统拥有丰富的资源，因此我们有大量的选择。我们面临的最基本的选择是构建工具。在我们的工作中，我们将使用 Maven。虽然有一个强大而积极的社区会提倡
    Gradle，但 Maven 似乎是目前最常用的构建工具，并且似乎从主要的 IDE 中获得了更稳健、成熟和本地的支持。如果您还没有安装 Maven，您可以通过访问
    [http://maven.apache.org](http://maven.apache.org/) 下载适用于您操作系统的发行版，或者使用您的操作系统支持的任何包管理系统。
- en: For the IDE, all screenshots, directions, and so forth will be using NetBeans--the
    free and open source IDE from Oracle. There are, of course, proponents of both
    IntelliJ IDEA and Eclipse, and they're both fine choices, but NetBeans offers
    a complete and robust development out-of-the-box, and it's fast, stable, and free.
    To download NetBeans, visit [http://netbeans.org](http://netbeans.org/) and download
    the appropriate installer for your operating system. Since we are using Maven,
    which IDEA and Eclipse both support, you should be able to open the projects presented
    here in the IDE of your choice. Where steps are shown in the GUI, though, you
    will need to adjust for the IDE you've chosen.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 IDE，所有截图、说明等都将使用 NetBeans——来自 Oracle 的免费开源 IDE。当然，IntelliJ IDEA 和 Eclipse
    都有支持者，它们都是不错的选择，但 NetBeans 提供了开箱即用的完整和强大的开发环境，并且速度快、稳定、免费。要下载 NetBeans，请访问 [http://netbeans.org](http://netbeans.org/)
    并下载适用于您操作系统的相应安装程序。由于我们使用 Maven，而 Maven 同时也支持 IDEA 和 Eclipse，因此您应该能够在您选择的任何 IDE
    中打开这里展示的项目。尽管在 GUI 中显示了步骤，但您仍需要根据您选择的 IDE 进行调整。
- en: 'At the time of writing, the latest version of NetBeans is 8.2, and the best
    approach for using it to do Java 9 development is to run the IDE on Java 8, and
    to add Java 9 as an SDK. There is a development version of NetBeans that runs
    on Java 9, but, as it is a development version, it can be unstable from time to
    time. A stable NetBeans 9 should ship at roughly the same time as Java 9 itself.
    In the meantime, we''ll push forward with 8.2:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，NetBeans 的最新版本是 8.2，使用它进行 Java 9 开发的最佳方法是运行 Java 8 的 IDE，并添加 Java 9 作为
    SDK。有一个基于 Java 9 运行的 NetBeans 开发版本，但作为一个开发版本，它有时可能不稳定。一个稳定的 NetBeans 9 应该与 Java
    9 本身大致同时发布。在此期间，我们将继续使用 8.2：
- en: To add Java 9 support, we will need to add a new Java platform, and we will
    do that by clicking on Tools | Platforms.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 Java 9 支持，我们需要添加一个新的 Java 平台，并且我们将通过点击“工具 | 平台”来完成这一操作。
- en: 'This will bring up the Java Platform Manager screen:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开 Java 平台管理器界面：
- en: '![](img/21f6aea0-1ca2-45e8-a850-b5dfe9657170.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21f6aea0-1ca2-45e8-a850-b5dfe9657170.png)'
- en: Click on Add Platform... on the lower left side of your screen.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左下角点击“添加平台...”。
- en: '![](img/748b63db-d5da-4ddf-b243-4891f4813c7d.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/748b63db-d5da-4ddf-b243-4891f4813c7d.png)'
- en: We want to add a Java Standard Edition platform, so we will accept the default
    and click on Next.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望添加一个 Java 标准版平台，因此我们将接受默认设置并点击“下一步”。
- en: '![](img/5d061ee9-6f7f-4c7e-bde0-e6975f484de1.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d061ee9-6f7f-4c7e-bde0-e6975f484de1.png)'
- en: On the Add Java Platform screen, we will navigate to where we've installed Java
    9, select the JDK directory, and click on Next.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加 Java 平台”屏幕上，我们将导航到我们已安装 Java 9 的位置，选择 JDK 目录，然后点击“下一步”。
- en: '![](img/dfd08672-b200-4018-884e-5e550186cf71.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfd08672-b200-4018-884e-5e550186cf71.png)'
- en: We need to give the new Java Platform a name (NetBeans defaults to a very reasonable
    JDK 9) so we will click on Finish and can now see our newly added Java 9 option.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为新 Java 平台命名（NetBeans 默认为非常合理的 JDK 9），因此我们将点击“完成”并现在可以看到我们新添加的 Java 9 选项。
- en: '![](img/5e7c2687-619f-45a3-b5ee-ac21f8dd4088.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e7c2687-619f-45a3-b5ee-ac21f8dd4088.png)'
- en: With the project SDK set, we're ready to take these new Java 9 features for
    a spin, which we'll start doing in [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml),
    *Managing Processes in Java*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目 SDK 设置完成后，我们就准备好体验这些新的 Java 9 特性了，我们将在第 18 章“Java 中的进程管理”中开始这一过程。[链接](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml)。
- en: If you do run NetBeans on Java 9, which should be possible by the time this
    book is published, you will already have Java 9 configured. You can, however,
    use the preceding steps to configure Java 8, should you need that version specifically.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Java 9运行NetBeans，这应该在本书出版时是可能的，那么你将已经配置了Java 9。然而，如果你需要特定版本的Java 8，你可以使用前面的步骤进行配置。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've taken a quick look at some of the great new features
    in Java 8, including lambdas, streams, the new date/time package, and default
    methods. From Java 9, we took a quick look at the Java Platform Module System
    and Project Jigsaw, the process handling APIs, the new concurrency changes, and
    the new Java REPL. For each, we've discussed the what and why, and looked at some
    examples of how these might affect the systems we write. We've also taken a look
    at the types of project we'll be building throughout the book and the tools we'll
    be using.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们快速浏览了Java 8的一些新特性，包括lambda表达式、流、新的日期/时间包和默认方法。从Java 9开始，我们快速了解了Java平台模块系统（JPMS）和Project
    Jigsaw、进程处理API、新的并发更改以及新的Java REPL。对于每一个，我们都讨论了其是什么以及为什么，并查看了一些这些可能对我们编写系统产生影响的例子。我们还探讨了本书中我们将要构建的项目类型以及我们将使用的工具。
- en: Before we move on, I'd like to restate an earlier point--every software project
    is different, so it is not possible to write this book in such a way that you
    can simply copy and paste large swathes of code into your project. Similarly,
    every developer writes code differently; the way I structure my code may be vastly
    different from yours. It is important, then, that you keep that in mind when reading
    this book and not get hung up on the details. The purpose here is not to show
    you the one right way to use these APIs, but to give you an example that you can
    look at to get a better sense of how they might be used. Learn what you can from
    each example, modify things as you see fit, and go build something amazing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想重申一个早期的观点——每个软件项目都是不同的，因此不可能以这种方式编写这本书，让你可以简单地复制粘贴大量代码到你的项目中。同样，每个开发者编写代码的方式也不同；我组织代码的方式可能与你的大相径庭。因此，在阅读这本书时，重要的是要记住这一点，不要纠结于细节。这里的目的是不是向你展示使用这些API的唯一正确方式，而是提供一个你可以参考的例子，以更好地了解它们可能的使用方式。从每个例子中学习你能学到的，根据你的需要修改，然后去构建一些令人惊叹的东西。
- en: With all of that said, let's turn our attention to our first project, the Process
    Manager, and the new process handling APIs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们将注意力转向我们的第一个项目，进程管理器，以及新的进程处理API。
