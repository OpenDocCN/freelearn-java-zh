- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the process of erecting a new building, a set of blueprints helps all related
    parties communicate--the architect, electricians, carpenters, plumbers, and so
    on. It details things such as shapes, sizes, and materials. Without them, each
    of the subcontractors would be left guessing as to what to do, where to do it,
    and how. Without these blueprints, modern architecture would be almost impossible.
  prefs: []
  type: TYPE_NORMAL
- en: What is in your hands--or on the screen in front of you--is a set of blueprints
    of a different sort. Rather than detailing exactly how to build your specific
    software system, as each project and environment has unique constraints and requirements,
    these blueprints offer examples of how to build a variety of Java-based systems,
    providing examples of how to use specific features in the **Java Development Kit**,
    or **JDK**, with a special focus on the new features of Java 9 that you can then
    apply to your specific problem.
  prefs: []
  type: TYPE_NORMAL
- en: Since it would be impossible to build an application using only the new Java
    9 features, we will also be using and highlighting many of the newest features
    in the JDK. Before we get too far into what that entails, then, let's take a brief
    moment to discuss some of these great new features from recent major JDK releases.
    Hopefully, most Java shops are already on Java 7, so we'll focus on version 8
    and, of course, version 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: New features in Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in Java 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 8, released on March 8, 2014, brought arguably two of the most significant
    features since Java 5, released in 2004--lambdas and streams. With functional
    programming gaining popularity in the JVM world, especially with the help of languages
    such as Scala, Java adherents had been clamoring for more functional-style language
    features for several years. Originally slated for release in Java 7, the feature
    was dropped from that release, finally seeing a stable release with Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: While it can be hoped that everyone is familiar with Java's lambda support,
    experience has shown that many shops, for a variety of reasons, are slow to adopt
    new language versions and features, so a quick introduction might be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The term lambda, which has its roots in lambda calculus, developed by Alonzo
    Church in 1936, simply refers to an anonymous function. Typically, a function
    (or method, in more proper Java parlance), is a statically-named artifact in the
    Java source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple method is one named `add` that takes two `int` parameters as well
    as returning an `int` parameter. With the introduction of lambdas, this can now
    be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, more simply as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This abbreviated syntax indicates that we have a function that takes two parameters
    and returns their sum. Depending on where this lambda is used, the types of the
    parameters can be inferred by the compiler, making the second, even more concise
    format possible. Most importantly, though, note that this method is no longer
    named. Unless it is assigned to a variable or passed as a parameter (more on this
    later), it can not be referenced--or used--anywhere in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example, of course, is absurdly simple. A better example of this might
    be in one of the many APIs where the method''s parameter is an implementation
    of what is known as a **Single Abstract Method** (**SAM**) interface, which is,
    at least until Java 8, an interface with a single method. One of the canonical
    examples of a SAM is `Runnable`. Here is an example of the pre-lambda `Runnable`
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With Java 8 lambdas, this code can be vastly simplified to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The body of the `Runnable` method is still pretty trivial, but the gains in
    clarity and conciseness should be pretty obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'While lambdas are anonymous functions (that is, they have no names), Java lambdas,
    as is the case in many other languages, can also be assigned to variables and
    passed as parameters (indeed, the functionality would be almost worthless without
    this capability). Revisiting the `Runnable` method in the preceding code, we can
    separate the declaration and the use of `Runnable` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is intentionally more verbose than the preceding example. The stubbed out
    body of the `Runnable` method is intended to mimic, after a fashion, how a real-world
    `Runnable` may look and why one may want to assign the newly-defined `Runnable`
    method to a variable in spite of the conciseness that lambdas offer. This new
    lambda syntax allows us to declare the body of the `Runnable` method without having
    to worry about method names, signatures, and so on. It is true that any decent
    IDE would help with this kind of boilerplate, but this new syntax gives you, and
    the countless developers who will maintain your code, much less noise to have
    to parse when debugging the code.
  prefs: []
  type: TYPE_NORMAL
- en: Any SAM interface can be written as a lambda. Do you have a comparator that
    you really only need to use once?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How about `ActionListener`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, you can use your own SAM interfaces in lambdas as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One of the advantages of this approach is that it not only makes the consuming
    code more concise, but it also reduces the level of effort, such as it is, in
    creating some of these concrete SAM instances. That is to say, rather than having
    to decide between an anonymous class and a concrete, named class, the developer
    can declare it inline, cleanly and concisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the SAMs Java developers have been using for years, Java 8 introduced
    a number of functional interfaces to help facilitate more functional style programming.
    The Java 8 Javadoc lists 43 different interfaces. Of these, there are a handful
    of basic function **shapes** that you should know of, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BiConsumer<T,U>` | This represents an operation that accepts two input arguments
    and returns no result |'
  prefs: []
  type: TYPE_TB
- en: '| `BiFunction<T,U,R>` | This represents a function that accepts two arguments
    and produces a result |'
  prefs: []
  type: TYPE_TB
- en: '| `BinaryOperator<T>` | This represents an operation upon two operands of the
    same type, producing a result of the same type as the operands |'
  prefs: []
  type: TYPE_TB
- en: '| `BiPredicate<T,U>` | This represents a predicate (Boolean-valued function)
    of two arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `Consumer<T>` | This represents an operation that accepts a single input
    argument and returns no result |'
  prefs: []
  type: TYPE_TB
- en: '| `Function<T,R>` | This represents a function that accepts one argument and
    produces a result |'
  prefs: []
  type: TYPE_TB
- en: '| `Predicate<T>` | This represents a predicate (Boolean-valued function) of
    one argument |'
  prefs: []
  type: TYPE_TB
- en: '| `Supplier<T>` | This represents a supplier of results |'
  prefs: []
  type: TYPE_TB
- en: There are a myriad of uses for these interfaces, but perhaps the best way to
    demonstrate some of them is to turn our attention to the next big feature in Java
    8--Streams.
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other major addition to Java 8, and, perhaps where lambdas shine the brightest,
    is the new **Streams API**. If you were to search for a definition of Java streams,
    you would get answers that range from the somewhat circular **a stream of data
    elements** to the more technical **Java streams are monads**, and they're probably
    both right. The Streams API allows the Java developer to interact with a stream
    of data elements via a **sequence of steps**. Even putting it that way isn't as
    clear as it could be, so let's see what it means by looking at some sample code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a list of grades for a particular class. You would like
    to know what the average grade is for the girls in the class. Prior to Java 8,
    you might have written something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize two variables, one to store the sums and one to count the number
    of hits. Next, we loop through the grades. If the student''s gender is female,
    we increment our counter and update the sum. When the loop terminates, we then
    have the information we need to calculate the average. This works, but it''s a
    bit verbose. The new Streams API can help with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This new version is not significantly smaller, but the purpose of the code
    is much clearer. In the preceding pre-stream code, we have to play computer, parsing
    the code and teasing out its intended purpose. With streams, we have a clear,
    declarative means to express application logic. For each entry in the map do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Filter out each entry whose `gender` is not `F`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map each value to the primitive int.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Average the grades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the value as a double.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the stream-based and lamba-based approach, we don't need to declare temporary,
    intermediate variables (grade count and total), and we don't need to worry about
    calculating the admittedly simple average. The JDK does all of the heavy-lifting
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The new java.time package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While lambdas and streams are extremely important game-changing updates, with
    Java 8, we were given another long-awaited change that was, at least in some circles,
    just as exciting: a new date/time API. Anyone who has worked with dates and times
    in Java knows the pain of `java.util.Calendar` and company. Clearly, you can get
    your work done, but it''s not always pretty. Many developers found the API too
    painful to use, so they integrated the extremely popular Joda Time library into
    their projects. The Java architects agreed, and engaged Joda Time''s author, Stephen
    Colebourne, to lead JSR 310, which brought a version of Joda Time (fixing various
    design flaws) to the platform. We''ll take a detailed look at how to use some
    of these new APIs in our date/time calculator later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Default methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before turning our attention to Java 9, let''s take a look at one more significant
    language feature: default methods. Since the beginning of Java, an interface was
    used to define how a class looks, implying a certain type of behavior, but was
    unable to implement that behavior. This made polymorphism much simpler in a lot
    of cases, as any number of classes could implement a given interface, and the
    consuming code treats them as that interface, rather than whatever concrete class
    they actually are.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the problems that have confronted API developers over the years, though,
    was how to evolve an API and its interfaces without breaking existing code. For
    example, take the `ActionSource` interface from the JavaServer Faces 1.1 specification.
    When the JSF 1.2 expert group was working on the next revision of the specification,
    they identified the need to add a new property to the interface, which would result
    in two new methods--the getters and setters. They could not simply add the methods
    to the interface, as that would break every implementation of the specification,
    requiring the maintainers of the implementation to update their classes. Obviously,
    this sort of breakage is unacceptable, so JSF 1.2 introduced `ActionSource2`,
    which extends `ActionSource` and adds the new methods. While this approach is
    considered ugly by many, the 1.2 expert group had a few choices, and none of them
    were very good.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Java 8, though, interfaces can now specify a default method on the interface
    definition, which the compiler will use for the method implementation if the extending
    class does not provide one. Let''s take the following piece of code as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve developed our API and made it available to the public, and it''s proved
    to be really popular. Over time, though, we''ve identified an improvement we''d
    like to make: we''d like to add some convenience methods, such as `sayHello()`
    and `sayGoodbye()`, to save our users a little time. However, as discussed earlier,
    if we just add these new methods to the interface, we''ll break our users'' code
    as soon as they update to the new version of the library. Default methods allow
    us to extend the interface and avoid the breakage by defining an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when users update their library JARs, they immediately gain these new methods
    and their behavior, without making any changes. Of course, to use these methods,
    the users will need to modify their code, but they need not do so until--and if--they
    want to.
  prefs: []
  type: TYPE_NORMAL
- en: New features in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any new version of the JDK, this release was packed with a lot of great
    new features. Of course, what is most appealing will vary based on your needs,
    but we'll focus specifically on a handful of these new features that are most
    relevant to the projects we'll build together. First up is the most significant,
    the Java Module System.
  prefs: []
  type: TYPE_NORMAL
- en: Java Platform Module System/Project Jigsaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite being a solid, feature-packed release, Java 8 was considered by a fair
    number to be a bit disappointing. It lacked the much anticipated **Java Platform
    Module System** (**JPMS**), also known more colloquially, though not quite accurately,
    as Project Jigsaw. The Java Platform Module System was originally slated to ship
    with Java 7 in 2011, but it was deferred to Java 8 due to some lingering technical
    concerns. Project Jigsaw was started not only to finish the module system, but
    also to modularize the JDK itself, which would help Java SE scale down to smaller
    devices, such as mobile phones and embedded systems. Jigsaw was scheduled to ship
    with Java 8, which was released in 2014, but it was deferred yet again, as the
    Java architects felt they still needed more time to implement the system correctly.
    At long last, though, Java 9 will finally deliver this long-promised project.
  prefs: []
  type: TYPE_NORMAL
- en: That said, what exactly is it? One problem that has long haunted API developers,
    including the JDK architects, is the inability to hide implementation details
    of public APIs. A good example from the JDK of private classes that developers
    should not be using directly is the `com.sun.*/sun.*` packages and classes. A
    perfect example of this--of private APIs finding widespread public use--is the
    `sun.misc.Unsafe` class. Other than a strongly worded warning in Javadoc about
    not using these internal classes, there's little that could be done to prevent
    their use. Until now.
  prefs: []
  type: TYPE_NORMAL
- en: With the JPMS, developers will be able to make implementation classes public
    so that they may be easily used inside their projects, but not expose them outside
    the module, meaning they are not exposed to consumers of the API or library. To
    do this, the Java architects have introduced a new file, `module-info.java`, similar
    to the existing `package-info.java` file, found at the root of the module, for
    example, at `src/main/java/module-info.java`. It is compiled to `module-info.class`,
    and is available at runtime via reflection and the new `java.lang.Module` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does this file do, and what does it look like? Java developers can
    use this file to name the module, list its dependencies, and express to the system,
    both compile and runtime, which packages are exported to the world. For example,
    suppose, in our preceding stream example, we have three packages: `model`, `api`,
    and `impl`. We want to expose the models and the API classes, but not any of the
    implementation classes. Our `module-info.java` file may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This definition exposes the two packages we want to export, and also declares
    a dependency on the `com.foo` module. If this module is not available at compile-time,
    the project will not build, and if it is not available at runtime, the system
    will throw an exception and exit. Note that the `requires` statement does not
    specify a version. This is intentional, as it was decided not to tackle the version-selection
    issue as part of the module system, leaving that to more appropriate systems,
    such as build tools and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Much more could be said about the module system, of course, but an exhaustive
    discussion of all of its features and limitations is beyond the scope of this
    book. We will be implementing our applications as modules, though, so we'll see
    the system used--and perhaps explained in a bit more detail--throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Those wanting a more in-depth discussion of the Java Platform Module System
    can search for the article, *The State of the Module System*, by Mark Reinhold.
  prefs: []
  type: TYPE_NORMAL
- en: Process handling API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In prior versions of Java, developers interacting with native operating system
    processes had to use a fairly limited API, with some operations requiring resorting
    to native code. As part of **Java Enhancement Proposal** (**JEP**) 102, the Java
    process API was extended with the following features (quoting from the JEP text):'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to get the pid (or equivalent) of the current Java virtual machine
    and the pid of processes created with the existing API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to enumerate processes on the system. Information on each process
    may include its pid, name, state, and perhaps resource usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to deal with process trees; in particular, some means to destroy
    a process tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to deal with hundreds of subprocesses, perhaps multiplexing the
    output or error streams to avoid creating a thread per subprocess.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore these API changes in our first project, the Process Viewer/Manager
    (see the following sections for details).
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As was done in Java 7, the Java architects revisited the concurrency libraries,
    making some much needed changes, this time in order to support the reactive-streams
    specification. These changes include a new class, `java.util.concurrent.Flow`,
    with several nested interfaces: `Flow.Processor`, `Flow.Publisher`, `Flow.Subscriber`,
    and `Flow.Subscription`.'
  prefs: []
  type: TYPE_NORMAL
- en: REPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One change that seems to excite a lot of people isn''t a language change at
    all. It''s the addition of a **REPL** (**Read-Eval-Print-Loop**), a fancy term
    for a language shell. In fact, the command for this new tool is `jshell`. This
    tool allows us to type or paste in Java code and get immediate feedback. For example,
    if we wanted to experiment with the Streams API discussed in the preceding section,
    we could do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a very welcome addition that should help Java developers rapidly prototype
    and test their ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that brief and high-level overview of what new features are available to
    use, what do these blueprints we'll cover look like? We'll build ten different
    applications, varying in complexity and kind, and covering a wide range of concerns.
    With each project, we'll pay special attention to the new features we're highlighting,
    but we'll also see some older, tried and true language features and libraries
    used extensively, with any interesting or novel usages flagged. Here, then, is
    our project lineup.
  prefs: []
  type: TYPE_NORMAL
- en: Process Viewer/Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore some of the improvements to the process handling APIs as we
    implement a Java version of the age old Unix tool--**top**. Combining this API
    with JavaFX, we'll build a graphical tool that allows the user to view and manage
    processes running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 Process API enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate File Finder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system ages, the chances of clutter in the filesystem, especially duplicated
    files, increases exponentially, it seems. Leveraging some of the new File I/O
    libraries, we'll build a tool to scan a set of user-specified directories to identify
    duplicates. Pulling JavaFX back out of the toolbox, we'll add a graphical user
    interface that will provide a more user-friendly means to interactively process
    the duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date Calculator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the release of Java 8, Oracle integrated a new library based on a redesign
    of Joda Time, more or less, into the JDK. Officially known as JSR 310, this new
    library fixed a longstanding complaint with the JDK--the official date libraries
    were inadequate and hard to use. In this project, we''ll build a simple command-line
    date calculator that will take a date and, for example, add an arbitrary amount
    of time to it. Consider the following piece of code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 Date/Time APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java command-line libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social Media Aggregator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the problems with having accounts on so many social media networks is
    keeping tabs on what''s happening on each of them. With accounts on Twitter, Facebook,
    Google+, Instagram, and so on, active users can spend a significant amount of
    time jumping from site to site, or app to app, reading the latest updates. In
    this chapter, we''ll build a simple aggregator app that will pull the latest updates
    from each of the user''s social media accounts and display them in one place.
    The features will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple accounts for a variety of social media networks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinterest
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Instagram
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only, rich listings of social media posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links to the appropriate site or app for a quick and easy follow-up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop and mobile versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: REST/HTTP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX and Android development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given the size and scope of this effort, we''ll actually do this in two chapters:
    JavaFX in the first, and Android in the second.'
  prefs: []
  type: TYPE_NORMAL
- en: Email filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing email can be tricky, especially if you have more than one account.
    If you access your mail from more than one location (that is, from more than one
    desktop or mobile app), managing your email rules can be trickier still. If your
    mail system doesn't support rules stored on the server, you're left deciding where
    to put the rules so that they'll run most often. With this project, we'll develop
    an application that will allow us to author a variety of rules and then run them
    via an optional background process to keep your mail properly curated at all times.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample `rules` file may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaMail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON Processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating System integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX photo management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java Development Kit has a very robust assortment of image handling APIs.
    In Java 9, these were augmented with improved support for the TIFF specification.
    In this chapter, we'll exercise this API in creating an image/photo management
    application. We'll add support for importing images from user-specified locations
    into the configured official directory. We'll also revisit the duplicate file
    finder and reuse some of the code developed as a part of the project to help us
    identify duplicate images.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The new `javax.imageio` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NetBeans Rich Client Platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java file I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client/server note application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever used a cloud-based note-taking application? Have you wondered
    what it would take to make your own? In this chapter, we'll create such an application,
    with complete front and backends. On the server side, we'll store our data in
    the ever popular document database, MongoDB, and we'll expose the appropriate
    parts of the business logic for the application via REST interfaces. On the client
    side, we'll develop a very basic user interface in JavaScript that will let us
    experiment with, and demonstrate how to use, JavaScript in our Java project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Document databases (MongoDB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS and RESTful interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript and Vue 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Serverless, also known as **function as a service** (**FaaS**), is one of the
    hottest trends these days. It is an application/deployment model where a small
    function is deployed to a service that manages almost every aspect of the function--startup,
    shutdown, memory, and so on, freeing the developer from worrying about such details.
    In this chapter, we'll write a simple serverless Java application to see how it
    might be done, and how you might use this new technique for your own applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Amazon Web Services account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring AWS Lambda, Simple Notification Service, Simple Email Service, and
    DynamoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and deploying a Java function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android desktop synchronization client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this project, we''ll change gears a little bit and focus specifically
    on a different part of the Java ecosystem: Android. To do this, we''ll focus on
    a problem that still plagues some Android users--the synchronization of an Android
    device and a desktop (or laptop) system. While various cloud providers are pushing
    us to store more and more in the cloud and streaming that to devices, some people
    still prefer to store, for example, photos and music directly on the device for
    a variety of reasons, ranging from cost for cloud resources to unreliable wireless
    connectivity and privacy concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll build a system that will allow users to synchronize music
    and photos between their devices and their desktop or laptop. We'll build an Android
    application that provides the user interface to configure and monitor synchronization
    from the mobile device side as well as the Android Service that will perform the
    synchronization in the background, if desired. We will also build the related
    components on the desktop--a graphical application to configure and monitor the
    process from the desktop as well as a background process to handle the synchronization
    from the desktop side.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaFX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have taken a quick look at some of the new language features we will be
    using. We have also seen a quick overview of the projects we will be building.
    One final question remains: what tools will we be using to do our work?'
  prefs: []
  type: TYPE_NORMAL
- en: The Java ecosystem suffers from an embarrassment of riches when it comes to
    development tools, so we have much to choose from. The most fundamental choice
    facing us is the build tool. For our work here, we will be using Maven. While
    there is a strong and vocal community that would advocate Gradle, Maven seems
    to be the most common build tool at the moment, and seems to have more robust,
    mature, and native support from the major IDEs. If you do not have Maven already
    installed, you can visit [http://maven.apache.org](http://maven.apache.org/) and
    download the distribution for your operating system, or use whatever package management
    system is supported by your OS.
  prefs: []
  type: TYPE_NORMAL
- en: For the IDE, all screenshots, directions, and so forth will be using NetBeans--the
    free and open source IDE from Oracle. There are, of course, proponents of both
    IntelliJ IDEA and Eclipse, and they're both fine choices, but NetBeans offers
    a complete and robust development out-of-the-box, and it's fast, stable, and free.
    To download NetBeans, visit [http://netbeans.org](http://netbeans.org/) and download
    the appropriate installer for your operating system. Since we are using Maven,
    which IDEA and Eclipse both support, you should be able to open the projects presented
    here in the IDE of your choice. Where steps are shown in the GUI, though, you
    will need to adjust for the IDE you've chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the latest version of NetBeans is 8.2, and the best
    approach for using it to do Java 9 development is to run the IDE on Java 8, and
    to add Java 9 as an SDK. There is a development version of NetBeans that runs
    on Java 9, but, as it is a development version, it can be unstable from time to
    time. A stable NetBeans 9 should ship at roughly the same time as Java 9 itself.
    In the meantime, we''ll push forward with 8.2:'
  prefs: []
  type: TYPE_NORMAL
- en: To add Java 9 support, we will need to add a new Java platform, and we will
    do that by clicking on Tools | Platforms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring up the Java Platform Manager screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21f6aea0-1ca2-45e8-a850-b5dfe9657170.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Add Platform... on the lower left side of your screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/748b63db-d5da-4ddf-b243-4891f4813c7d.png)'
  prefs: []
  type: TYPE_IMG
- en: We want to add a Java Standard Edition platform, so we will accept the default
    and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5d061ee9-6f7f-4c7e-bde0-e6975f484de1.png)'
  prefs: []
  type: TYPE_IMG
- en: On the Add Java Platform screen, we will navigate to where we've installed Java
    9, select the JDK directory, and click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfd08672-b200-4018-884e-5e550186cf71.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to give the new Java Platform a name (NetBeans defaults to a very reasonable
    JDK 9) so we will click on Finish and can now see our newly added Java 9 option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e7c2687-619f-45a3-b5ee-ac21f8dd4088.png)'
  prefs: []
  type: TYPE_IMG
- en: With the project SDK set, we're ready to take these new Java 9 features for
    a spin, which we'll start doing in [Chapter 18](bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml),
    *Managing Processes in Java*.
  prefs: []
  type: TYPE_NORMAL
- en: If you do run NetBeans on Java 9, which should be possible by the time this
    book is published, you will already have Java 9 configured. You can, however,
    use the preceding steps to configure Java 8, should you need that version specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken a quick look at some of the great new features
    in Java 8, including lambdas, streams, the new date/time package, and default
    methods. From Java 9, we took a quick look at the Java Platform Module System
    and Project Jigsaw, the process handling APIs, the new concurrency changes, and
    the new Java REPL. For each, we've discussed the what and why, and looked at some
    examples of how these might affect the systems we write. We've also taken a look
    at the types of project we'll be building throughout the book and the tools we'll
    be using.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, I'd like to restate an earlier point--every software project
    is different, so it is not possible to write this book in such a way that you
    can simply copy and paste large swathes of code into your project. Similarly,
    every developer writes code differently; the way I structure my code may be vastly
    different from yours. It is important, then, that you keep that in mind when reading
    this book and not get hung up on the details. The purpose here is not to show
    you the one right way to use these APIs, but to give you an example that you can
    look at to get a better sense of how they might be used. Learn what you can from
    each example, modify things as you see fit, and go build something amazing.
  prefs: []
  type: TYPE_NORMAL
- en: With all of that said, let's turn our attention to our first project, the Process
    Manager, and the new process handling APIs.
  prefs: []
  type: TYPE_NORMAL
