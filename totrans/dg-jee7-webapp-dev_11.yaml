- en: Appendix B. From Request to Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the job interviews for a software developer role, many people are frequently
    asked to describe how the web actually works behind the scenes. A candidate that
    can explain well the architectural layers of a software application to an interviewer
    may give the impression of a so-called full stack developer. However, it can be
    surprising how many candidates have just plausible knowledge of this topic, especially
    if they purport to work professionally in the digital domain. This appendix provides
    a concise and definitive description of the modern issues. The digital developers
    ought to be able to sketch and effectively document their current working architecture.
    So let's start with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a fundamental stateless protocol designed to transport hypermedia between
    a server and client. HTTP 1.1 supports the fine-grained caching of resources and
    the ability to retain persistent connections and chunked transfer encoding. HTTP
    1.1 was created in 1999 (refer to the superseded RFC [https://tools.ietf.org/html/rfc2068](https://tools.ietf.org/html/rfc2068)).
    To cope with the modern demand and usage patterns, the HTTP now supports the WebSocket
    handshaking and upgrade requests ([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455)).
    The next HTTP 2.0 standard will provide the multiplexing of streams over a single
    client server channel. There are exciting possibilities for Java EE 8 (expected
    by May/June 2017) and the HTTP 2.0 support in the Java Servlet 4.0 specification.
    For more details, see RFC 7540 ([http://www.rfc-editor.org/rfc/rfc7540.txt](http://www.rfc-editor.org/rfc/rfc7540.txt))
    and JSR 369 ([https://www.jcp.org/en/jsr/detail?id=369](https://www.jcp.org/en/jsr/detail?id=369)).
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HTTP request consists of a payload with a header and then body content. The
    header information contains the URI request, HTTP method, agent information, request
    parameters, and cookies. For the POST and PUT requests, it may also contain the
    form encoded properties with names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four basic HTTP methods that every digital engineer ought to understand
    are GET, POST, PUT, and DELETE. They are described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GET**: This request fetches the contents of the resources associated with
    a given URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**POST**: This creates a brand new resource with a payload (body content) that
    specifies the data for the new resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PUT**: This updates an existing resource with a payload that specifies some
    or all of the data that is being replaced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DELETE**: This is a request to delete the specified resource association
    with the URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the rare HTTP methods that are also used in special circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HEAD**: This performs an acknowledgement of the resources associated with
    a given URL by just retrieving the headers. This request is similar to the GET
    request but without the body content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPTION**: This retrieves the application server features or web container
    capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TRACE**: This request allows the infrastructure to find out the network hops
    between the client and servers and therefore validates the latency, availability,
    and performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An HTTP response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTTP response consists of the header information and payload data (the body
    content). The header contains the HTTP status code, MIME type, data length, last
    modified date, character set encoding, cookie parameters, and cache information
    of the resource. The header may also contain the authentication data. The body
    content is the data returned that is the client's request.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Status codes are defined by the W3C. These are integer codes with ranges.
    Generally, the status codes 100-199 are informational messages, 200-299 represent
    the successful outcomes, 300-399 represent the redirection requests, 400-499 are
    server side errors, and the 500-599 status codes represent the authentication
    failures. Hence, the HTTP OK 200 and 404 NOT FOUND status codes are well-known
    to developers outside the digital domain. You can find all of them listed in the
    RFC at [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
  prefs: []
  type: TYPE_NORMAL
- en: Java Enterprise Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications in the digital domain share a common thread of architecture across
    multiple industrial sector domains. Obviously, they share and rely on the Java
    EE 7 standard platform and JVM in order to piggy-bank the development, various
    nonfunctional attributes, and enterprise application infrastructure. There are
    subtle differences in the building of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Java EE web architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard Java EE web architecture is derived from the client-server models
    of the 1990s. The application server is the key component as it is responsible
    for three containers in the full Java EE 7 specification: Servlet, CDI, and EJB.
    Generally, we map these containers to the layer tier architecture for a monolithic
    web application. The idea of this architecture is to enhance the best practice
    from the point of view of solid software engineering. We want to maintain a separation
    of the concerns in the layers in order to avoid rigid coupling between layers
    and have a strong cohesion in the layers. The three layers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation layer is strongly associated with code that depends and requires
    the Servlet container. FacesServlet is supplied as a part of the JSF. Alternative
    web application frameworks also have the idea of Front Controller that dispatches
    a request to the separate controllers. The presentation tier also contains the
    controllers and view templates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain layer is associated with code that holds the business logic and projections
    of the persistence objects. It contains the application rules, business logic,
    and business process management. Domain objects may or may not be a part of a
    dependency injection. In most of the modern web applications, almost all the domain
    layer components and objects are a part of a dependency injection container. Therefore,
    domain layer is associated with the CDI container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration layer is associated with the transportation of data from the application
    to the durable persistence or service areas of the system. This layer maps to
    a POJO that is a part of the EJB container. Usually, these objects handle the
    service calls from the application. As EJBs, they are transactional and not necessarily
    contextual, which is why they are not a part of the CDI container. These objects
    communicate with an external system like database through JPA and/or JDBC asynchronously
    to the other systems through a message over JMS or they can also synchronously
    (or asynchronously) invoke the remote web service endpoints through the REST or
    SOAP calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Standard Java EE web architecture](img/image00429.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The standard Java EE web architecture
  prefs: []
  type: TYPE_NORMAL
- en: Extended architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the standard Java web architecture, there are several adaptations. Organizations
    may choose to optimize their architecture in order to suit a particular trade-off.
    A trade-off might be performance versus scalability, which may mean restructuring
    the integration layer in order to use a NoSQL database over a particular RDMS
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will examine availability versus performance for a particular
    customer. Availability is the degree of a system to be accessible. If the system
    is down, then it is not available. Performance is the ability of the system to
    carry out the required functionality in a target timeframe. So, this customer
    is truly interested in the uptime of the system because the downtime will cost
    money, but they also want a fixed quantum of throughput.
  prefs: []
  type: TYPE_NORMAL
- en: Which items can degrade the performance? If the application has too much sanity
    checking in the code (check pointing), then it will degrade the performance. If
    the performance is degraded, then it may also reduce availability. However, if
    you do not perform a sanity check for enough parameters, then a system will be
    culpable to errors. If a hacker finds a weakness in your security or your caseworkers
    enter the wrong data too often, then your availability is compromised because
    your business will suffer downtime to fix issues.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to split the architecture in two computation bunkers. We can
    take advantage of the modern power in smartphones, tablets, and desktop computers
    to render the content on the client side. Therefore, this architecture, suits
    rich clients and other suitable devices with enough GPU power.
  prefs: []
  type: TYPE_NORMAL
- en: The code that has been sanity-checked and rendered is removed from the server
    side to a large degree. Depending on the architecture, we can use the JavaScript
    framework technologies that rely on **Model View ViewModel** (**MVVM**), which
    is supported by AngularJS. Based on the technology choice, we can use an alternative
    to JSF such as the upcoming Java EE 8 MVC or directly the JAX-RS endpoints. We
    must ensure that correct validation takes places on both the client and server
    sides. We must also design the REST API or other remote invocation between client
    and server to be secure, safe, and idempotent. Note that we still have the features
    such as CDI, EJB, JMS, and JPA available to us on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: There are benefits in this extended Java EE 7 architecture that help in the
    performance versus scalability trade-off. If we introduce a caching layer of data,
    we will gain the ability to return the data that is mostly derived from static
    references or changes very infrequently or is requested most often. The key benefit
    of caching requests from the smart clients means that response times are minimized.
  prefs: []
  type: TYPE_NORMAL
- en: Just after Java EE 7 was released in 2013, JCache temporary caching 1.0 final
    JSR 107 ([https://jcp.org/en/jsr/detail?id=107](https://jcp.org/en/jsr/detail?id=107))
    was released, which is now supported by brands such as HazelCast and Terracota.
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture suits a hybrid form that extends Java EE and goes beyond
    and outside the box of specifications. The Java EE 7 umbrella specification does
    not specify the orchestration of the servers, monitoring of servers or systems,
    deep authorization, and cloud provisioning. Let''s take a look at the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extended architectures](img/image00430.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An extended hybrid Java EE architecture that remedies performance versus availability
  prefs: []
  type: TYPE_NORMAL
- en: Containerless systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another architecture that is popular with the leading edge businesses
    that favor continuous deployment and guerilla engineering. This is called containerless
    application, which is actually a misnomer. If we think about it, every entity
    system is contained in some abstract component from the highest level container
    and down to the hardware CPU. The operating system is constrained by the CPU,
    the JVM process is constrained by the operating system, and the application server
    contains the deployed Java EE application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical architects make trade-offs all the time. They may consider agility
    like time-to-market versus cost, innovation versus affordability, and politically,
    the integration of legacy systems with new technology, such as a containerless
    system. The proper name for the containerless application ought to be embedded
    application controlled server, which accurately describes the architecture. There
    are several Java EE application server providers that allow a standalone Java
    application to spin a fully embedded server from the `static void main()` entry
    point. Vendors such as JBoss's WildFly, Tomitribe's Tom EE, and of course, Oracle's
    GlassFish have nonstandard APIs for embedded execution. Some of the proprietary
    vendor solutions even allow the modular selection of the Java EE abilities in
    the runtime of the embedded server. An architect may thus pick and choose the
    provisioning of the JAX-RS, JSF, CDI, EJB, and JMS modules. A well-balanced and
    proficient developed team is able to circumvent the change management. The team
    operates *under the radar* by writing a Containerless solution instead of being
    told for the 100th time that they are not permitted to upgrade the IBM WebSphere
    7 application server.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, embedded servers are popular for the beginning of building the microservices
    architecture across several concerns. Allowing the application to control the
    start up and halting of the embedded servers means that these archetypes play
    well with the modern DevOps movement (Developers/Operations team) and the concepts
    around the automatic configuration management control.
  prefs: []
  type: TYPE_NORMAL
- en: The clear disadvantage of the containerless solution is that the building of
    the development tools for the traditional WAR deployment does not understand this
    mode. So, a digital engineer may lose the interactive and fast turnaround of increment
    engineering using a Java EE solution. However, it might be a short-term issue
    as the Java IDE makers are fairly good at picking up trends in engineering. We
    can hope that the Java EE technical leaders, architects, and the wider community
    voice their support for the specification to include a containerless API.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an embedded server, engineering teams have the responsibility to ensure
    that the infrastructure is correctly set up. The technical architects gain the
    benefit of precisely controlling the external integration points and this is useful
    for the security, authorization and authentication, monitoring and logging, and
    persistent access. However, going from request to the response is exactly the
    same as in the standard Java web architecture. Let''s have a look at the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Containerless systems](img/image00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Containerless Java EE architecture diagram
  prefs: []
  type: TYPE_NORMAL
- en: Although there is no standardization on Java EE 8 for the embedded server application
    architecture, other developers have at least precipitated some innovations in
    order to move the community in this direction. There is the Apache Delta Spike
    CDI Container Control ([https://deltaspike.apache.org/documentation/container-control.html](https://deltaspike.apache.org/documentation/container-control.html))
    that currently provides a cross server library to start and stop the CDI container
    in a standalone Java SE environment. Delta Spike is an award-winning open source
    project that has specialist modules for Bean Validation, CDI, Data, Security,
    and Servlets as well as container management. It is worth keeping an eye on this
    project because some of their innovations have made it to the Java EE 8 standard.
    The `@javax.transactional.Transational` annotation that allows CDI managed beans
    take part in Container Managed Transactions (Java EE 7 and JTA 1.2) was first
    proposed and developed in project Delta Spike.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The embedded application controlled server is a gateway to the Java-based microservices
    architecture. These microservices are a style of designing an enterprise architecture
    where each component solves and operates one requirement of the overall system.
    These key drivers are the nonfunctional requirements and can be any combination
    of Availability, Flexibility, Maintainability, Networkability, Performance, Robustness
    and Scalability. Of these, the original requirements for businesses to choose
    this style over the traditional monolithic architecture were Availability and
    Scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Architects see certain advantages in microservices: these components follow
    the UNIX architectural principle of *do one thing and do it well* and the ability
    to chop and change the component at will. The microservices style enables the
    language agnostic communications; therefore, the implementer has the freedom to
    write a component in Java, Groovy, or Scala or even in a non-JVM language such
    as C++. This architecture strongly favors JSON or XML over REST; however, there
    is nothing to stop a software shop from using SOAP and XML. Technically, microservices
    are some of the most exciting digital projects on the planet today; because of
    these investments, some businesses have clear distinct commercial advantages.'
  prefs: []
  type: TYPE_NORMAL
- en: The cost of microservices is the networking complexity that includes payload
    sizes, monitoring (heart-beating), logging, and fault tolerance with redundancy
    management and service routing. There are ancillary costs that business managers
    and stakeholders should be aware of, namely time-to-marketing, training, information
    silos, and of course, change culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with many movements, there is also a spectrum of effort, ability, and feasibility.
    A business may not necessarily have to give up on the monolith architecture completely,
    especially if scalability and high availability are not a high priority. There
    is certainly a route for the componentized services architecture for the majority
    of the digital business, which takes the best of the monolith—transactions, persistence,
    and configuration—and radically employs as much of the styles of the microservices
    as possible. Therefore, an embedded server dedicated for order management should
    not have code that is relevant to the payment processing in it. Rather, the order
    management component should invoke the payment processing component externally.
    Let''s have a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An evolution of a Java EE monolith to a microservices architecture
  prefs: []
  type: TYPE_NORMAL
- en: The preceding illustration shows a decomposition of the standard Java EE web
    architecture into a hybrid component architecture and then an evolution to a full
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to go from the request and then back to the response. In
    addition to where do we go as a team in order to get there? We must ask ourselves
    the key questions: how do we get there? Why do we want to get there?'
  prefs: []
  type: TYPE_NORMAL
- en: To be full stack or not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is it important to be known as a full stack developer? The consultant's typical
    answer is that it always depends on the context. Some cynics might say that the
    term full stack is a loaded marketing term, but then these same people may also
    suggest that digital is likewise. Obviously, there is more meaning to the term
    than the thoughts that are recurring through some poor recruitment consultant's
    brain. There is a lot to be desired for large organizations that claim and advertise
    that they want to recruit only full stack developers. Are they cutting corners?
    Or are they genuinely interested in getting the best programming talent?
  prefs: []
  type: TYPE_NORMAL
- en: That said, from the discussion in this appendix, it is important to know the
    architecture of a project to a certain degree. For a couple of decades already,
    it has been impossible to be a jack of all trades in the software business and
    therefore, an engineer will specialize in a certain environment, field, role,
    or system. It is no longer possible to live completely closeted in an underground
    silo and resolutely say, *all I want to know is Java on the server side because
    it is the only skill that I care about and it will always be that way*. Decent
    professional engineers must be sympathetic to the other staff members including
    front-end developers, back-end developers, interface and UX designers, testers,
    stakeholders, and management. Everyone has an ultimate stakeholder and therefore
    they share the ultimate responsibility with accountability. Whether this means
    full stack or not depends largely on your attitude towards working life and knowing
    about and respecting the modern web architecture around you.
  prefs: []
  type: TYPE_NORMAL
