<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Unifying Imperative and Reactive with Vert.x</h1>
                </header>
            
            <article>
                
<p class="mce-root">One of the greatest challenges for enterprise applications has traditionally been combining business operations, which are inherently synchronous, with dispatching the results of these operations, which can be also asynchronous and event-driven. In this chapter, we will learn how the Vert.x toolkit can address this challenge in Quarkus applications by combining standard imperative programming with asynchronous data streams that can be created, changed, or combined at runtime. By the end of this chapter, you should be proficient in writing reactive applications on the JVM using Vert.x<span class="st">.</span></p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>An introduction to Reactive Programming and the Vert.x toolkit</li>
<li>Vert.x API models available in Quarkus</li>
<li>Managing the Reactive SQL Client with Vert.x</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You can find the source code for the project in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09">https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter09</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Demystifying Reactive Programming and Vert.x</h1>
                </header>
            
            <article>
                
<p>Imperative programming is the way most programmers write their code every day. Wait a minute <span>â€“ </span>what does imperative programming mean? In a concise statement, we can say that imperative programming means that lines of code get executed in a sequence, statement by statement, as shown in the following example:</p>
<pre>URL url = new URL("http://acme.com/");<br/>BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));<br/><br/>String line;<br/>while ((line = in.readLine()) != null) {<br/>  System.out.println(line);<br/>}<br/>in.close();</pre>
<p>As you can see, imperative programming can use loops or conditional statements to jump to different parts of code. Don't be fooled by this, though. As long as your debugger clearly points to a statement in your code (and thus it's obvious what line will be executed next), you are definitely using imperative programming.</p>
<p>While the imperative programming model is clearly simpler to understand, it can badly impact scalability as the number of connections tends to grow. As a matter of fact, the number of system threads will have to be increased accordingly, causing your OS to spend significant CPU cycles just for thread scheduling management. That's where Vert.x comes into play.</p>
<p>Let's start with a definition: what exactly is Vert.x? Vert.x is not an application server or a framework but merely a toolkit or, if you prefer, a set of plain JAR files that can be added as a dependency to your projects. Easy-peasy. You don't need a specific development environment or plugin to develop applications with Vert.x either.</p>
<p>At its core, Vert.x is a reactive toolkit that fulfills the requirements dictated by the <strong>Reactive Manifesto</strong> (<a href="https://www.reactivemanifesto.org/">https://www.reactivemanifesto.org/</a>). These requirements can be summarized in the following points:</p>
<ul>
<li><strong>Responsive</strong>: A reactive system needs to be capable of handling requests in a reasonable time.</li>
<li><strong>Resilient</strong>: A reactive system must be designed to handle failures and deal with them appropriately. </li>
<li><strong>Elastic</strong>: A reactive system must be able to scale up and down according to loads without compromising the responsiveness of the system. </li>
<li><strong>Message-driven</strong>: The reactive system's components interact with each other by exchanging asynchronous messages.</li>
</ul>
<p>Based on the preceding points, it's clear that Vert.x promotes a new way of designing and building distributed systems while infusing asynchrony, scalability, and reactiveness into the core of your applications. Therefore, with regard to our former example, it can be rewritten in a reactive way, as follows:</p>
<pre>vertx.createHttpClient().getNow(80, "acme.com", "", response -&gt; {<br/>   response.bodyHandler(System.out::println);<br/> });</pre>
<p>Unlike the former example, by using Vert.x, the running thread is released while the connection with the HTTP server is being established. Then, when the response has been received, a handler coded as a Lambda expression (<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a>) is called back to deal with the response.</p>
<p>In the preceding example, the <kbd>vertx</kbd> field can be used in your code each time you extend the Vert.x basic unit of deployment, which is called a <strong>Verticle</strong>. In essence, a Verticle processes incoming events over an event loop, creating the foundation for an asynchronous programming model. Verticles can be written in various languages, not only Java, so you can mix different environments as part of a larger reactive system.</p>
<p>The main tool for allowing different Verticles to communicate with each other is called the <strong>Event Bus</strong>, and communication happens through asynchronous message passing. The following diagram shows how the <strong>Event Bus</strong> fits into this schema:<br/></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/453ec3ac-428a-4835-9e16-02e973e72744.png" style=""/></div>
<p><span>The Event Bus doesn't pose any restrictions on the kind of data format you use, although JSON is the preferred exchange format since it is a popular option for structuring data, allowing Verticles written in different languages to communicate. The Event Bus supports the following communication patterns:</span></p>
<ul>
<li><strong>Point-to-point</strong> messaging, which means that messages are routed to just one of the handlers registered at that address.</li>
<li><strong>Request-respon</strong><strong>se</strong> messaging, which is similar to point-to-point messaging, except that it includes an optional reply handler that can be specified while sending the message so that the recipient can decide whether to reply to the message. If they do so, the reply handler will be called.</li>
<li><strong>Publish-subscribe</strong><span>, which allows you to broadcast messages using a publish function. In this case, the event bus will route messages to all the handlers that are registered against that address.</span></li>
</ul>
<p>Since there are multiple communication patterns, several API models have been designed for Vert.x and are all based around the concept of executing the flow in an asynchronous way via callbacks. The next section discusses a variety of Vert.x API models that are available in Quarkus.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Vert.x API models in Quarkus</h1>
                </header>
            
            <article>
                
<p>Vert.x provides a large ecosystem of reactive APIs that are integrated into Quarkus. More specifically, Quarkus uses Vert.x as the reactive engine by providing a single dependency to your applications:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;<br/>    &lt;artifactId&gt;quarkus-vertx&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</pre>
<p>This allows you to access a managed Vert.x instance with simple code injection:</p>
<pre>@Inject io.vertx.core.Vertx vertx;</pre>
<p>The <kbd>Vertx</kbd> object is the control center of a Vert.x application. It's your pass to Vert.x land and allows you to create an asynchronous and non-blocking client and servers, get a reference to the Event Bus, and many other things.</p>
<p>When using Vert.x API in Quarkus, however, there's no <kbd>Vertx</kbd> object for you to access. As a matter of fact, Quarkus provides three different Vert.x APIs:</p>
<ul>
<li><kbd>io.vertx.core.Vertx</kbd>: This is the entry point into the Vert.x core API and allows you to achieve asynchronous and non-blocking clients and servers using callbacks.</li>
<li><kbd>io.vertx.reactivex.core.Vertx</kbd>: This API allows us to use observable patterns in our Vert.x applications wherever we can use streams or asynchronous results. Additionally, it allows us to use a large set of data transformation operators on our streams.</li>
<li><kbd>io.vertx.axle.core.Vertx</kbd>: This API has been specifically designed to integrate with Quarkus' MicroProfile patterns, proving a solid foundation for sending and receiving asynchronous messages, thus enforcing loose coupling between services.</li>
</ul>
<p>In order to learn about all three different variations of Vert.x, we have provided an equal number of examples in the <kbd>Chapter09</kbd> folder in this book's GitHub repository. Let's take a look at them in detail.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the Vert.x core API</h1>
                </header>
            
            <article>
                
<p>For the purpose of learning about the Vert.x core API, we will be using a modified version of our basic customer service application, which we discussed in <a href="1eb0a987-ab8b-40a1-ab16-6562b8a45344.xhtml" target="_blank">Chapter 4</a>, <em>Adding Web Interfaces to Quarkus Services</em>. You can find the source code for this example of the <kbd>Chapter09/core/customer-service</kbd> folder in this book's GitHub repository. We recommend that you import the project into your IDE.</p>
<p>Now, let's dive straight into the code. Since the Vert.x core API is based around the callback mechanism, in order to leverage asynchronous and non-blocking APIs, for our customer service example we have added two functions that will read and write a list of customers from the filesystem in JSON format. Where shall we write our customer list? The answer is into the <kbd>application.properties</kbd> file, which defines a property named <kbd>file.path</kbd>, which is where the customer list will be written:</p>
<pre><span>file.path</span><span>=</span><span>/tmp/customer.json<br/></span></pre>
<p>Now, let's look at the code. The core class that's responsible for providing customer data is <kbd>CustomerRepository</kbd>. There we'll inject an instance of <kbd>io.vertx.core.Vertx</kbd> at this point. We will also inject the path where the data will be stored:</p>
<pre><span>public class </span>CustomerRepository {<br/>    @Inject io.vertx.core.Vertx vertx<span>;<br/></span>    @ConfigProperty(name = <span>"file.path" </span>)<br/>    String path<span>;</span></pre>
<p>Now comes the interesting bit, that is, writing a method that uses the <kbd>vertx</kbd> instance to flatten our list of customers on the filesystem:</p>
<pre><span>public </span>CompletionStage&lt;String&gt; writeFile( ) {<br/><br/>    JsonArrayBuilder jsonArray = javax.json.Json.createArrayBuilder()<span>;</span><span><br/></span><span>    for </span>(Customer customer:customerList) {<br/>        jsonArray.add(javax.json.Json.createObjectBuilder().<br/>                 add(<span>"id"</span><span>, </span>customer.getId())<br/>                .add(<span>"name"</span><span>, </span>customer.getName())<br/>                .add(<span>"surname"</span><span>, </span>customer.getSurname()).build())<span>;</span><span><br/></span><span>    </span>}<br/><br/>    JsonArray array = jsonArray.build()<span>;</span><span><br/></span><span>    </span>CompletableFuture&lt;String&gt; future = <span>new </span>CompletableFuture&lt;&gt;()<span>;<br/></span><span><br/></span><span>    </span>vertx.fileSystem().writeFile(path<span>, </span>Buffer.buffer(array<br/><br/>    .toString())<span>, </span>handler -&gt; {<br/>        <span>if </span>(handler.succeeded()) {<br/>            future.complete(<span>"Written JSON file in " </span>+path)<span>;<br/></span><span>        </span>} <span>else </span>{<br/>            System.err.println(<span>"Error while writing in file:<br/>             " </span>+ handler.cause().getMessage())<span>;</span><span><br/></span><span>        </span>}<br/>    })<span>;</span><span><br/></span><span>    return </span>future<span>;<br/></span>}</pre>
<p>The first thing you may have noticed is the <kbd>CompletionStage</kbd> method's signature. If you have been programming async Java code, you may be familiar with the <kbd>java.util.concurrent.Future</kbd> API. It's used to do the following:</p>
<ul>
<li>Check whether the execution has completed via the <kbd>isDone()</kbd> method</li>
<li>Cancel the execution using the <kbd>cancel()</kbd> method</li>
<li>Fetch the result of the execution using the blocking <kbd>get()</kbd> method</li>
</ul>
<p>The major limitation of this approach is that the caller cannot manually complete the task, nor can it chain multiple <kbd>Future</kbd> executions.</p>
<p class="mce-root">On the other hand, <kbd>CompletionStage</kbd> is based on the concept of stages, which are thought of as multiple intermediate computations and may or may not be asynchronous. In any case, we have to complete them before we reach the final result. These intermediate computations are known as <strong>completion stages</strong>.</p>
<p>By using the <kbd>CompletionStage</kbd> stage, you can easily address the <kbd>java.util.concurrent.Future</kbd> API's limitations by doing the following:</p>
<ul>
<li>Manually completing <kbd>CompletableStage</kbd> using <kbd>complete(T value)</kbd></li>
<li>Chaining multiple <kbd>CompletableStage</kbd> in a block</li>
</ul>
<p>Let's get back to our example. Once we have created <kbd>JsonArray</kbd> out of our customer list, we can access our <kbd>FileSystem</kbd> using the Vert.x core API. We can also register a handler that is in charge of completing our <kbd>CompletionStage</kbd> as soon as the file has been successfully written.</p>
<p>Let's take a look at the <kbd>readFile</kbd> method, which is in charge of reading the file that contains the customer list:</p>
<pre><span>public </span>CompletionStage&lt;String&gt; readFile() {<span><br/></span><span>    </span>CompletableFuture&lt;String&gt; future = <span>new </span>CompletableFuture&lt;&gt;()<span>;</span><span><br/></span><span>    long </span>start = System.nanoTime()<span>;<br/></span><span><br/></span><span>    </span><span>// Delay reply by 100ms<br/></span><span>    </span>vertx.setTimer(<span>100</span><span>, </span>l -&gt; {<br/>        <span>// Compute elapsed time in milliseconds<br/></span><span>        </span><span>long </span>duration = MILLISECONDS.convert(System.nanoTime() -<br/>         start<span>, </span>NANOSECONDS)<span>;<br/></span><span><br/></span><span>        </span>vertx.fileSystem().readFile(<span>path</span><span>, </span>ar -&gt; {<br/>            <span>if </span>(ar.succeeded()) {<br/>                String response = ar.result().toString(<span>"UTF-8"</span>)<span>;<br/></span><span>                </span>future.complete(response)<span>;<br/></span><span>            </span>} <span>else </span>{<br/>                future.complete(<span>"Cannot read the file: " </span>+ <br/>                ar.cause().getMessage())<span>;<br/></span><span>            </span>}<br/>        })<span>;<br/></span><span><br/></span><span>    </span>})<span>;<br/></span><span>    <br/></span><span>    return </span>future<span>;<br/></span>}</pre>
<p>The <kbd>readFile</kbd> method is intentionally a bit more complex. As a matter of fact, we have chained two different stages into it. The first one executes a one-time timer that will fire the next execution in 100 ms. Timers are a core construct of Vert.x and should be used wherever you want to delay the execution of some code or execute it repeatedly:</p>
<pre>vertx.setPeriodic(1000, l -&gt; {<br/>  // This code will be called every second<br/>  System.out.println("timer fired!");<br/>});</pre>
<p>In any case, timers are how you can delay the execution in Vert.x terms in place of other mechanisms, such as <kbd>Thread.sleep</kbd>, which would block the event loop and therefore should <strong>never</strong>, ever be used in the Vert.x context. </p>
<div class="packt_tip">If you forget our gentle warning, Vert.x will remind you each time you attempt to use a blocking code in the Vert.x context with a log message similar to <em>Thread vertx-eventloop-thread-1 has been blocked for 22258 ms.</em></div>
<p>The remaining part of the <kbd>readFile</kbd> method does exactly the opposite of the <kbd>writeFile</kbd> method; that is, it reads the JSON file and completes the stage as soon as the file has been read.</p>
<p>In order to expose this feature to the client application, we have added two wrapper methods to our <kbd>CustomerEndpoint</kbd> class in order to expose the functions via the REST API:</p>
<pre>@GET<br/>@Path(<span>"writefile"</span>)<br/>@Produces(<span>"text/plain"</span>)<br/><span>public </span>CompletionStage&lt;String&gt; writeFile() {<br/>    <span>return </span>customerRepository.writeFile()<span>;</span><span><br/></span>}<br/><br/>@GET<br/>@Path(<span>"readfile"</span>)<br/><span>public </span>CompletionStage&lt;String&gt; readFile() {<br/>    <span>return </span>customerRepository.readFile()<span>;</span><span><br/></span>}</pre>
<p>It's worth noting that the <kbd>writeFile</kbd> method produces text information since it's supposed to return a simple text message to the caller. On the other hand, the <kbd>readFile</kbd> method relies on the class' default <kbd>application/json</kbd> format to display the JSON text file.</p>
<p>Now, let's move on to the client-side. We can easily capture the <kbd>CompletionStage</kbd> event using two more AngularJS handlers, which will capture the result as soon as it's available:</p>
<pre>$scope.writefile = function () {<br/><br/>$http({<br/>    method: 'GET',<br/>    url: SERVER_URL+'/writefile'<br/>  }).then(_successStage, _error);<br/>};<br/><br/>scope.readfile = function () {<br/><br/>  $http({<br/>    method: 'GET',<br/>    url: SERVER_URL+'/readfile'<br/>  }).then(_successStage, _error);<br/>};<br/><br/>function _successStage(response) {<br/>   _clearForm()<br/>   $scope.jsonfile = JSON.stringify(response.data);<br/>}</pre>
<p>Both functions will be triggered with the addition of two simple buttons to our home page:</p>
<pre><span>&lt;a </span><span>ng-click=</span><span>"writefile()" </span><span>class=</span><span>"myButton"</span><span>&gt;</span>Write File<span>&lt;/a&gt; </span><span> <br/></span><span>&lt;a </span><span>ng-click=</span><span>"readfile()"  </span><span>class=</span><span>"myButton"</span><span>&gt;</span>Read File<span>&lt;/a&gt;</span><span> </span></pre>
<p>Besides doing this, we have also added a <kbd>div</kbd> section to our HTML schema, which is where information will be displayed:</p>
<pre><span>&lt;div </span><span>ng-app=</span><span>"displayfile"  </span><span>&gt;<br/></span><span>        &lt;span </span><span>ng-bind=</span><span>"jsonfile"</span><span>&gt;&lt;/span&gt;<br/></span><span>&lt;/div&gt;</span></pre>
<p>Without further ado, let's build and run the application with the following command:</p>
<pre><strong>mvn install quarkus:dev</strong></pre>
<p>The following is our new UI, which includes the <span class="packt_screen">Read File</span> and <span class="packt_screen">Write File</span> buttons. We have just saved a set of <kbd>Customer</kbd> objects, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/59ac264c-73dd-44c5-a54a-7bcaa4ff5403.png" style=""/></div>
<p>Conversely, if we hit the <span class="packt_screen">Read File</span> button, its content will be displayed in the lower <kbd>div</kbd> of the page in JSON format:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1f5fce28-facd-48b1-85f0-da83b7380be5.png" style=""/></div>
<p>We have completed the first round with Vert.x core. Now, let's move on and look at using Vert.x with <strong>ReactiveX</strong> (<strong>RxJava</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing Vert.x API for RxJava</h1>
                </header>
            
            <article>
                
<p>RxJava (<a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a>) is a Java library that lets you create asynchronous and event-based applications using <kbd>Observable</kbd> sequences for the Java VM. In order to understand the core features of this framework, we need to define the core actors of ReactiveX, which are as follows:</p>
<ul>
<li>
<p><strong>Observables</strong>: These represent the source of data to be emitted. An observable starts providing data once a subscriber starts to listen. An observable may emit a variable number of items and will eventually terminate with success or with an error.</p>
</li>
<li>
<p><strong>Subscribers:</strong> These listen to events that are emitted by observables. There can be one or more subscribers for one observable.</p>
</li>
</ul>
<p>The following diagram shows the relationship between these two components:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae69de57-5da3-409c-a331-3cb57443f8f4.png" style=""/></div>
<p>Based on the number of items emitted and the control of the flow of items, we can distinguish between different types of observables:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Observable type</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td><kbd>Flowable&lt;T&gt;</kbd></td>
<td>Emits <em>0</em> or <em>n</em> items and terminates with a success or an error event. Supports backpressure, which allows us to control the rate of source emission.</td>
</tr>
<tr>
<td><kbd>Observable&lt;T&gt;</kbd></td>
<td>Emits <em>0</em> or <em>n</em> items and terminates with a success or an error event.</td>
</tr>
<tr>
<td><kbd>Single&lt;T&gt;</kbd></td>
<td>Emits either one value or an error notification.</td>
</tr>
<tr>
<td><kbd>Maybe&lt;T&gt;</kbd></td>
<td>Emits a single item, no items, or an error event. The reactive version of an optional call.</td>
</tr>
<tr>
<td><kbd>Completable</kbd></td>
<td>Wraps the <span class="ILfuVd"><span class="e24Kjd">deferred computation without any value but only as an indication of completion or an exception.</span></span></td>
</tr>
</tbody>
</table>
<p>Let's provide a minimalist example of this. The following is a <kbd>Hello world</kbd> example of an <kbd>Observable</kbd> that emits a single item:</p>
<pre>Observable.<span>just</span>(<span>"Hello world!"</span>).subscribe(System.<span>out</span>::println)<span>;</span></pre>
<p>When the subscriber receives the item, it simply prints it on the out stream. The following code is slightly different as it uses a <kbd>Flowable</kbd> observable to control the flow of items in the event you are pushing out data at a high rate, which could overflood your subscribers:</p>
<pre>Flowable.<span>just</span>(<span>"Hello world!"</span>).subscribe(System.<span>out</span>::println)<span>;<br/></span></pre>
<p>One important concept of RxJava programming is <strong>operators</strong>; an operator is a<span class="st"> function that defines an <kbd>Observable</kbd> and how and when it should emit the data stream. We have already met one, that is, the <kbd>just</kbd> operator, which allows you to convert an object or a set of objects into an <kbd>Observable</kbd>. In our first example, the object was the <kbd>Hello world</kbd> string.</span></p>
<p><span class="st">There are many more operators, all of which can be found in RxJava's documentation (</span><a href="http://reactivex.io/documentation/operators.html">http://reactivex.io/documentation/operators.html</a>). For example, you can suppress duplicates in a stream of data using the <kbd>distinct</kbd> operator:</p>
<pre>Observable.<span>just</span>(<span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>4</span><span>, </span><span>2</span><span>, </span><span>1</span>)<br/>        .distinct()<br/>        .subscribe(System.<span>out</span>::println)<span>;</span></pre>
<p>In this case, the expected output from the subscriber will be as follows:</p>
<pre><strong>2,3,4,1</strong></pre>
<p>You can also chain another operator to filter out items that don't meet a pattern, as follows:</p>
<pre>Observable.<span>just</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)  <br/>     .distinct()<br/>     .filter(x -&gt; x % <span>2 </span>== <span>0</span>)<br/>     .subscribe(System.<span>out</span>::println)<span>;</span></pre>
<p>As you may have guessed, the output will be further restricted to the following:</p>
<pre><strong>2,4</strong></pre>
<p>Although we have barely scratched the surface of RxJava's power, we have a minimal background to how we plug these concepts into our example application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using RxJava with Quarkus</h1>
                </header>
            
            <article>
                
<p>In order to learn about RxJava, we will go through the example contained in the <kbd>Chapter09/rx2java/customer-service</kbd> folder in this book's GitHub repository. </p>
<p>The first thing you should be aware of is that, in order to use RxJava with Quarkus, you have to add an instance of <kbd>Vertx</kbd>, which can be found under the <kbd>io.vertx.reativex.core</kbd> namespace:</p>
<pre>@Inject io.vertx.reactivex.core.Vertx vertx;</pre>
<p>That being said, one of the main advantages of including ReactiveX in our project is that it will greatly enhance the capability of <strong>transforming</strong> data that flows between the observable and the subscriber.</p>
<p>For example, let's take a look at the following use case:</p>
<ul>
<li>We want to produce a file with a list of customers to be imported in a spreadsheet. Therefore, we will create a plain CSV file out of our customer list.</li>
<li>Then, we want to convert the CSV file into any other format is coded in the customer's <kbd>toString</kbd> method.</li>
</ul>
<p>Let's learn how to operate the right changes on the <kbd>CustomerRepository</kbd> class. As we mentioned previously, the first change is to replace the <kbd>io.vertx.core.Vertx</kbd> instance with the corresponding <kbd>io.vertx.reativex.core.Vertx</kbd>. Then, we will apply some changes to the <kbd>writeFile</kbd> and <kbd>readFile</kbd> methods. Let's begin with the <kbd>writeFile</kbd> method first:</p>
<pre>public CompletionStage&lt;String&gt; writeFile() {<br/>    CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();<br/>    StringBuffer sb = new StringBuffer("id,name,surname");<br/>    sb.append(System.lineSeparator());<br/><br/>    Observable.fromIterable(customerList)<br/>            .map(c -&gt; c.getId() + "," + c.getName() + "," + <br/>             c.getSurname() + System.lineSeparator())<br/>            .subscribe(<br/>                    data -&gt;   sb.append(data),<br/>                    error -&gt; System.err.println(error),<br/>                    () -&gt;  vertx.fileSystem().writeFile(path, <br/>                     Buffer.buffer(sb.toString()), handler -&gt; {<br/>                        if (handler.succeeded()) {<br/>                            future.complete("File written in "+path);<br/>                        } else {<br/>                            System.err.println("Error while <br/>                            writing in file: " + handler.cause()<br/>                            .getMessage());<br/><br/>                        }<br/>                    }));<br/><br/>    return future;<br/>}</pre>
<p>If you have found our introduction to observables <span>intuitive</span>, the preceding code won't look overly complex, in spite of the proliferation of Lambda expressions. Here, we have added a long list of operators to produce the desired result.</p>
<p>First of all, we have produced a set of observables by iterating over the customer list using the <kbd>Observable.fromIterable</kbd> operator. Since we need to produce a CSV file, we need to map single customer fields with the CSV format, which uses a comma (<kbd>,</kbd>) to separate the values. We have used the <kbd>map</kbd> operator for this purpose. Then, we are done with transformation and the result will be a list of observables that are in the format we have chosen.</p>
<p>For an observer (or subscriber) to see items that are being emitted by <kbd>Observable</kbd>, along with errors or completed notifications from <kbd>Observable</kbd>, it must subscribe to that <kbd>Observable</kbd> using the <kbd>subscribe</kbd> operator. In a nutshell, the <kbd><span class="operator">subscribe</span></kbd> operator is the glue that connects a subscriber to an <kbd>Observable</kbd>.</p>
<p>Our subscriber will receive notifications when new items are added so that they can be appended to <kbd>StringBuffer</kbd>, which has already been initialized with the CSV header. The subscriber will also receive notifications in case of errors and eventually, when the stream of items gets completed, via the <kbd>()</kbd> handler. In this case, the CSV file will be written to the filesystem using the <kbd>writeFile</kbd> function, which is also available in the <kbd>io.vertx.reativex.core.Vertx</kbd> filesystem context.</p>
<p>Then, the <kbd>readFile</kbd> method will need to reverse the CSV file we have already written into the representation of the <kbd>Customer</kbd> object, as provided by its <kbd>toString</kbd> method. The code is as follows:</p>
<pre>public CompletionStage&lt;String&gt; readFile() {<br/><br/>    CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;();<br/>    StringBuffer sb = new StringBuffer();<br/><br/>    vertx.fileSystem().rxReadFile(path)<br/>            .flatMapObservable(buffer -&gt; <br/>              Observable.fromArray(buffer.toString().split(System.<br/>              lineSeparator())))<br/>            .skip(1)<br/>            .map(s -&gt; s.split(","))<br/>            .map(data-&gt; new Customer(Integer.<br/>             parseInt(data[0]),data[1],data[2]))<br/>            .subscribe(<br/>                    data -&gt;  sb.append(data.toString()),<br/>                    error -&gt; System.err.println(error),<br/>                    () -&gt; future.complete(sb.toString()));<br/><br/>    return future;<br/><br/>}</pre>
<p>Here, we have to familiarize ourselves with some more operators. Since we want to read and process the file line by line, we are using the <kbd>flatMapObservable</kbd> operator to produce our array of multiple <kbd>Observable</kbd> instances. In practice, this operator allows us to produce a set of <kbd>Observable</kbd> instances that are the result of a function being emitted by a single item the line in our CSV file.</p>
<p>We have conveniently split the file into an array using the <kbd>split</kbd> method of the string's class. Then, we used the <kbd>skip</kbd> operator to skip the first item, which is the CSV header. After, we applied two <kbd>map</kbd> transformations to the data:</p>
<ul>
<li>The first one creates an array of string objects, out of the CSV line, using the comma (<kbd>,</kbd>) as a separator</li>
<li>Next, we created an instance of the <kbd>Customer</kbd> object using the data arriving from the string array</li>
</ul>
<p>Now that we have collected our target data, which is a <kbd>Customer</kbd> object, we are ready to stream this data, which will eventually be collected by the subscriber. The subscriber, in turn, receives each item and adds the <kbd>toString()</kbd> output from it to the <kbd>StringBuffer</kbd>. You can include any format in your <kbd>toString()</kbd> method, but to keep it simple, we have let our IDE (IntelliJ IDEA) self-generate it:</p>
<pre><span>public </span>String <span>toString</span>() {<br/>    <span>return </span><span>"Customer{" </span>+<br/>            <span>"id=" </span>+ <span>id </span>+<br/>            <span>", name='" </span>+ <span>name </span>+ <span>'</span><span>\'</span><span>' </span>+<br/>            <span>", surname='" </span>+ <span>surname </span>+ <span>'</span><span>\'</span><span>' </span>+<br/>            <span>'}'</span><span>;</span><span><br/></span>}</pre>
<p>The last thing we'll do is set the media type of <kbd>readFile</kbd> so that it's consistent with the format of our <kbd>toString</kbd> data. Since we are producing simple text, it will look as follows:</p>
<pre><span>@GET<br/></span><span>@Path</span>(<span>"readfile"</span>)<br/><span>@Produces</span>(<span>"text/plain"</span>)<br/><span>public </span>CompletionStage&lt;String&gt; <span>readFile</span>() {<br/>    <span>return </span><span>customerRepository</span>.readFile()<span>;</span><span><br/></span>}</pre>
<p>Now, you can just run the application and check the new outcome. The following is what your UI should look like once you've added some customers and clicked on the <span class="packt_screen">Write File</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/579d5247-c8fd-4625-adfe-e1db4b6f2a5d.png" style=""/></div>
<p>Then, by hitting the <span class="packt_screen">Read File</span> button, the lower HTML <kbd>div</kbd> will contain the <kbd>toString</kbd> data for each customer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/173ae975-e619-49b2-8c73-92b4d6fbc23d.png" style=""/></div>
<p>As you can see, in spite of the minimalist UI log, there is plenty of work being done under the hood to manage the transformation of data in different kinds of format.</p>
<p>That was our second implementation of Vert.x and Quarkus. We still have to deal with the third beast, which is <kbd>io.vertx.axle.core.Vertx</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Decoupling events with Vert.x axle libraries</h1>
                </header>
            
            <article>
                
<p>Typically, we want to separate our service entry points (adapters) from the business logic, which is part of the application. A common pattern is to keep the service in a distinct bean, which is injected into our service REST entry point. When approaching Reactive Programming, however, we can decouple even more of our components by bringing the Vert.x Event Bus into the picture.</p>
<p>In this kind of architecture, components communicate with each other by sending messages to virtual addresses. To manage the distribution of messages, the following components are available:</p>
<ul>
<li><strong>EventBus</strong>: This is a lightweight distributed messaging system that allows communication between the different parts of your application in a loosely coupled way.</li>
<li><strong>Message</strong>: This contains data that is received from the Event Bus in a handler. Messages have a body and a header, both of which can be null. By adding a reply handler in the message, it is possible to apply a request-response pattern to the communication.</li>
</ul>
<p>Let's learn how we can instrument a simple messaging pattern by using the example application that's available in the <kbd>Chapter09/axle/customer-service</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding an EventBus layer to Quarkus applications</h1>
                </header>
            
            <article>
                
<p>To include a distributed peer-to-peer messaging pattern in our application, we will need to inject the <kbd>EventBus</kbd> instance into a CDI bean, which will act as a receiver:</p>
<pre><span>@Inject </span>EventBus <span>bus</span><span>;</span></pre>
<p>In our case, we will add the <kbd>EventBus</kbd> to the <kbd>CustomerEndpoint</kbd> class.</p>
<div class="packt_infobox">Please note that there is only one single instance of the Event Bus per Vert.x instance.</div>
<p>Now, in the same class, let's create a new endpoint method, which will be in charge of dispatching messages:</p>
<pre><span>@GET<br/></span><span>@Path</span>(<span>"/call"</span>)<br/><span>@Produces</span>(<span>"text/plain"</span>)<br/><span>public </span>CompletionStage&lt;String&gt; <span>call</span>(<span>@QueryParam</span>(<span>"id"</span>) Integer customerId) {<br/>    <span>return </span><span>bus</span>.&lt;String&gt;send(<span>"callcustomer"</span><span>, <br/>    </span><span>customerRepository</span>.findCustomerById(customerId))<br/>            .thenApply(Message::body)<br/>            .exceptionally(Throwable::getMessage)<span>;</span></pre>
<p>We are conveying messages on the bus through the <kbd>"callcustomer"</kbd> address. The body of the message contains the <kbd>Customer</kbd> object, which is retrieved by the <kbd>findCustomerById</kbd> method. In the event of an error, a throwable with the error's <kbd>getMessage</kbd> content will be thrown.</p>
<p>Now, we need a consumer for messages, so we will add another class named <kbd>CustomerService</kbd>, which contains a method annotated as <kbd>@ConsumeEvent</kbd>:</p>
<pre><span>@ApplicationScoped<br/></span><span>public class </span>CustomerService {<br/><br/>        <span>@ConsumeEvent</span>(<span>"callcustomer"</span>)<br/>        <span>public </span>String <span>reply</span>(Customer c) {<br/>            <span>return </span><span>"Hello! I am " </span>+ c.getName() + <span>" " <br/>             </span>+c.getSurname() + <span>". How are you doing?"</span><span>;<br/></span><span>        </span>}<br/>}</pre>
<p>Within the <kbd>@ConsumeEvent</kbd> annotation, we are specifying the address where messages are consumed. At the end of the day, we are merely returning a response containing a message from the customer.</p>
<p>To complete the loop, we need to make the following changes:</p>
<ul>
<li>We need to add one more button to the <kbd>index.html</kbd> page:</li>
</ul>
<pre style="padding-left: 60px"><span>&lt;a </span><span>ng-click=</span><span>"call( customer )" </span><span>class=</span><span>"myButton"</span><span>&gt;</span>Call<span>&lt;/a&gt;</span></pre>
<ul>
<li>We need to add one more AngularJS controller to handle the response, which will display (in an alert window) the message: <span><br/></span></li>
</ul>
<pre style="padding-left: 60px">$scope.call = function (customer) {<br/><br/>  $http({<br/>    method: 'GET',<br/>    url: SERVER_URL+'/call/?id='+customer.id<br/>  }).then(_callCustomer, _error);<br/>};<br/><br/> function _callCustomer(response) {<br/>   window.alert(response.data);<br/>}</pre>
<p>Now that we have added everything, let's run our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rolling up the application</h1>
                </header>
            
            <article>
                
<p>When all the changes are in place, you should be able to see that the <span class="packt_screen">Call</span> button has been added to each customer's row, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65752cf0-e3d0-4b77-b5b4-9e388c6ea837.png" style=""/></div>
<p>When you click on the <span class="packt_screen">Call</span> button, a message will be sent through the Event Bus. As soon as it's consumed, you should see<span> the following response:</span><span> </span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/505134b9-4543-446a-be13-13b64b9f08be.png" style=""/></div>
<p>Besides peer-to-peer messaging, you can also use the Vert.x axle API to stream <strong>Server-Side Events</strong> (<strong>SSEs</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Streaming SSE with Vert.x</h1>
                </header>
            
            <article>
                
<p>Traditionally, web applications are capable of sending a request to servers to receive a response; that is the standard paradigm. With server-send events, however, it's possible for the server application to send new data to a web page at any time by pushing events (messages) to the web page. These incoming messages are treated as events combined with data inside the web page.</p>
<p class="mce-root">Now, let's demonstrate how to use the Vert.x axle API to stream SSEs in Quarkus. The following class, which has been included in our project, is in charge of sending an SSE to the home page every two seconds:</p>
<pre><span>@Path</span>(<span>"/streaming"</span>)<br/><span>public class </span>StreamingEndpoint {<br/><br/>    <span>@Inject </span><span>io.vertx.axle.core.</span>Vertx <span>vertx</span><span>;<br/></span><span><br/></span><span>    </span><span>@Inject </span>CustomerRepository <span>customerRepository</span><span>;<br/></span><span>    </span><span>@GET<br/></span><span>    @Produces</span>(MediaType.<span>SERVER_SENT_EVENTS</span>)<br/>    <span>public </span>Publisher&lt;String&gt; <span>stream</span>() {<br/><br/>        <span>return<br/></span><span>                </span>ReactiveStreams.<span>fromPublisher<br/>                </span>(<span>vertx</span>.periodicStream(<span>2000</span>).<br/>                 toPublisher())<br/>                        .map(l -&gt; String.<span>format</span><br/>                    (<span>"Number of Customers %s . <br/>                    Last one added: %s %n"</span><span>,</span><span>customerRepository</span>.<br/>                    findAll().size()<span>,<br/></span><span>                                </span><span>customerRepository</span>.findAll().size()<br/>                                 &gt; <span>0</span><span> </span>? <br/>                                (<span>customerRepository</span>.findAll().<br/>                                get(<span>customerRepository</span>.findAll().<br/>                                size() -<span>1</span>)).toString()  : <span>"N/A"</span>))<br/>                        .buildRs()<span>;<br/></span><span><br/></span><span><br/></span><span>    </span>}<br/>}</pre>
<p>First off, notice that we are using an instance of <kbd>io.vertx.axle.core.Vertx</kbd> to handle the streaming of events. Then, our REST method, which is bound to the <kbd>"/streaming"</kbd> URI, is annotated with a different media type, that is, <kbd>SERVER_SENT_EVENTS</kbd>. The method returns a publisher type, which is required in order to publish Reactive Streams.</p>
<p>By using the <kbd>ReactiveStreams.fromPublisher</kbd> method, we push stream events based on the frequency specified by <kbd>vert.xperiodicStream</kbd>. In our case, messages will be dispatched every two seconds. Before sending the actual event, the content will be transformed by the <kbd>map</kbd> operator, which will create a message with some <kbd>Customer</kbd> statistics, such as the number of customers and the last one added. By using the ternary operator, we managed to compress this login into just one statement, at the expense of slightly more complex readability.</p>
<p>That's all you need on the server-side. On the client-side, we made some other adaptations:</p>
<ul>
<li>We added one more button to trigger the SSE:</li>
</ul>
<pre style="padding-left: 60px"><span>&lt;a </span><span>ng-click=</span><span>"stats()" </span><span>class=</span><span>"myButton"</span><span>&gt;</span>Stats<span>&lt;/a&gt;&lt;/div&gt;<br/></span></pre>
<ul>
<li>We added a callback method, in JavaScript, to handle the event that was received:</li>
</ul>
<pre style="padding-left: 60px">$scope.stats = function () {<br/><br/>  var eventSource = new EventSource("/streaming");<br/>  eventSource.onmessage = function (event) {<br/>  var container = document.getElementById("divcontainer");<br/>  var paragraph = document.createElement("p");<br/>  paragraph.innerHTML = event.data;<br/>  container.appendChild(paragraph);<br/>};</pre>
<ul>
<li>We added a <kbd>div</kbd> where messages will be displayed:</li>
</ul>
<pre style="padding-left: 60px"><span>&lt;div </span><span>id=</span><span>"divcontainer" </span><span>style=</span><span>"</span>width: 800px; height: 200px; overflow-y: scroll;<span>"</span><span>&gt;</span></pre>
<p>When we run the updated application, the expected outcome is a UI that includes the <span class="packt_screen">Stats</span> button at the bottom of it:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b2901875-bcc9-49ee-a8ba-810a390dbf2b.png" style=""/></div>
<p>The lower <kbd>div</kbd> will be updated every two seconds, based on the data contained in the customer list.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Canceling events</h1>
                </header>
            
            <article>
                
<p>It's worth mentioning that SSE subscriptions can be canceled by keeping a reference to the <kbd>Subscription</kbd> object so that you can cancel your subscription at any time:</p>
<pre>publisher<br/>   .subscribe(new Subscriber&lt;String&gt;() {<br/>     volatile Subscription subscription;<br/> <br/>     @Override<br/>     public void onSubscribe(Subscription subscription) {<br/>       this.subscription = subscription;<br/>     }<br/> <br/>     @Override<br/>     public void onNext(String s) {<br/>       // when no more event is needed<br/><strong>       subscription.cancel();</strong><br/>     }<br/> <br/>     @Override<br/>     public void onError(Throwable throwable) {<br/>       // handle error<br/>     }<br/> <br/>     @Override<br/>     public void onComplete() {<br/>       // handle complete<br/>     }<br/>});</pre>
<p>In the preceding code snippet, when the event is emitted, the observer's <kbd>onNext</kbd> method is called with the item and the <kbd>onComplete</kbd> method is invoked immediately after. On the other hand, when the callback is a failure, the observer's <kbd>onError</kbd> method is called. Within any callback method, we can cancel the subscription using the <kbd>cancel</kbd> method on the subscription object.</p>
<p>This was our last piece of work with Reactive Events, but not the last with Vert.x. We still have one more thing to cover: Quarkus' Reactive SQL Clients. This is an API that focuses on scalable JDBC connections with minimal overhead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing the Reactive SQL Client</h1>
                </header>
            
            <article>
                
<p>The Reactive SQL Client is an API that allows you to use reactive and non-blocking features of Vert.x to access a relational database. This brings some changes in terms of how you access your data. Let's put the costs and benefits on the table:</p>
<ul>
<li>On one side, you will need to use SQL statements to enable your RDBMS to access data, instead of the abstract HQL. Also, automatic mapping between Java classes and DB is not available anymore since Hibernate is out of the game here.</li>
<li>On the other hand, you will be able to use a fully event-driven, non-blocking, lightweight alternative to stream the result of your SQL statements.</li>
</ul>
<p>Based on your requirements, you may stick with Hibernate's API or switch to Reactive's SQL Client. Let's say you're brave and want to switch to Reactive SQL. To do that, you will need to configure your application so that it can use the PostgreSQL Reactive Client API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring your application to use the PostgreSQL reactive client</h1>
                </header>
            
            <article>
                
<p>In order to delve into the reactive Client API, please refer to the example contained in the <kbd>Chapter09/pgpool</kbd> folder in this book's GitHub repository. Since this example won't use the PostgreSQL JDBC driver, the following dependency has been added as a replacement:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.quarkus<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>quarkus-reactive-pg-client<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>The other configuration we added was the JDBC URL, which needs to be in the following format:</p>
<pre><span>vertx-reactive:postgresql://&lt;Host&gt;:&lt;Port&gt;/&lt;DBName&gt;<br/></span></pre>
<p>Therefore, in our example, we will add this setting in <kbd>application.properties</kbd>:</p>
<pre>quarkus.datasource.url=vertx-reactive:postgresql://localhost:5432/quarkusdb<br/>quarkus.datasource.username=quarkus<br/>quarkus.datasource.password=quarkus</pre>
<p>Now, let's look at the changes in our application. To keep things as simple as possible, we have broken down our example so that it just uses the <kbd>CustomerEndpoint</kbd> and the <kbd>Customer</kbd> POJO class.</p>
<p>Let's begin with the <kbd>CustomerEndpoint</kbd>, which requires access to <kbd>io.vertx.axle.pgclient.PgPool</kbd> and <kbd>io.vertx.core.Vertx</kbd>:</p>
<pre><span>public class </span>CustomerEndpoint {<br/><br/>    <span>@Inject </span>PgPool <span>client</span><span>;</span><span><br/></span><span>    </span><span>@Inject </span>Vertx <span>vertx</span><span>;</span></pre>
<p>Within the same class, we have added an <kbd>init</kbd> method to create some data at startup:</p>
<pre><span>@PostConstruct<br/></span><span>private void </span><span>initdb</span>() {<br/><br/>    <span>client</span>.query(<span>"DROP TABLE IF EXISTS CUSTOMER"</span>)<br/>            .thenCompose(r -&gt; <span>client</span>.query(<span>"CREATE SEQUENCE IF<br/>              NOT EXISTS  customerId_seq"</span>))<br/>            .thenCompose(r -&gt; <span>client</span>.query(<span>"CREATE TABLE CUSTOMER<br/>             (id SERIAL PRIMARY KEY, name TEXT NOT NULL,surname<br/>             TEXT NOT NULL)"</span>))<br/>            .thenCompose(r -&gt; <span>client</span>.query(<span>"INSERT INTO CUSTOMER<br/>             (id, name, surname) VALUES ( nextval('customerId<br/>              _seq'), 'John','Doe')"</span>))<br/>            .thenCompose(r -&gt; <span>client</span>.query(<span>"INSERT INTO CUSTOMER<br/>              (id, name, surname) VALUES ( nextval('customerId<br/>                _seq'), 'Fred','Smith')"</span>))<br/>            .toCompletableFuture()<br/>            .join()<span>;<br/></span>}</pre>
<p>Pgpool's <kbd>query</kbd> method returns a <kbd>CompletionStage</kbd> object with a <kbd>RowSet</kbd> of data, as a result of the query. Please note how we can chain multiple statements to produce a <kbd>CompletableFuture</kbd>, which spins off the execution in another thread. Within this simple method, you can experience how powerful reactive SQL clients can be when it comes to creating event-driven, non-blocking SQL executions. You will eventually get the combined result of all the statements by executing the <kbd>join</kbd> method of <kbd>CompletableFuture</kbd> at the end.</p>
<p>The other methods of <kbd>CustomerEndpoint</kbd> delegate the execution of CRUD statements to the <kbd>Customer</kbd> class using the same composition pattern:</p>
<pre><span>@GET<br/></span><span>public </span>CompletionStage&lt;Response&gt; <span>getAll</span>() {<br/>    <span>return </span>Customer.<span>findAll</span>(<span>client</span>).thenApply(Response::<span>ok</span>)<br/>            .thenApply(ResponseBuilder::build)<span>;<br/></span>}<br/><br/><br/><span>@POST<br/></span><span>public </span>CompletionStage&lt;Response&gt; <span>create</span>(Customer customer) {<br/>    <span>return </span>customer.create(<span>client</span>).thenApply(Response::<span>ok</span>)<br/>            .thenApply(ResponseBuilder::build)<span>;<br/></span><span> </span>}<br/><br/><span>@PUT<br/></span><span>public </span>CompletionStage&lt;Response&gt; <span>update</span>(Customer customer) {<br/>    <span>return </span>customer.update(<span>client</span>)<br/>            .thenApply(updated -&gt; updated ? Status.<span>OK </span>: <br/>             Status.<span>NOT_FOUND</span>)<br/>            .thenApply(status -&gt; Response.<span>status</span>(status).build())<span>;<br/></span>}<br/><br/><span>@DELETE<br/></span><span>public </span>CompletionStage&lt;Response&gt; <span>delete</span>(<span>@QueryParam</span>(<span>"id"</span>) Long customerId) {<br/>    <span>return </span>Customer.<span>delete</span>(<span>client</span><span>, </span>customerId)<br/>            .thenApply(deleted -&gt; deleted ? Status.<span>NO_CONTENT </span>: <br/>             Status.<span>NOT_FOUND</span>)<br/>            .thenApply(status -&gt; Response.<span>status</span>(status).build())<span>;<br/></span>}</pre>
<p>Within the <kbd>Customer</kbd> class, we have coded all the methods that are required to perform CRUD operations. The first one, <kbd>create</kbd>, performs an <kbd>INSERT</kbd> in the <kbd>CUSTOMER</kbd> table by using <kbd>PreparedStatement</kbd>, which applies a tuple containing the name and surname as an argument:</p>
<pre><span>public </span>CompletionStage&lt;Long&gt; <span>create</span>(PgPool client) {<br/>    <span>return </span>client.preparedQuery(<span>"INSERT INTO CUSTOMER (id, name, <br/>     surname) VALUES ( nextval('customerId_seq'), $1,$2)<br/>     RETURNING (id)"</span><span>, </span>Tuple.<span>of</span>(<span>name</span><span>,</span><span>surname</span>))<br/>            .thenApply(pgRowSet -&gt; pgRowSet.iterator()<br/>            .next().getLong(<span>"id"</span>))<span>;<br/></span>}</pre>
<p>In much the same way, the <kbd>update</kbd> method executes an <kbd>UPDATE</kbd> through a <kbd>PreparedStatement</kbd>, and applies the customer's tuple of data as a parameter:</p>
<pre><span>public </span>CompletionStage&lt;Boolean&gt; <span>update</span>(PgPool client) {<br/>    <span>return </span>client.preparedQuery(<span>"UPDATE CUSTOMER SET name = $1,<br/>     surname = $2 WHERE id = $3"</span><span>, </span>Tuple.<span>of</span>(<span>name</span><span>, </span><span>surname</span><span>, </span><span>id</span>))<br/>            .thenApply(pgRowSet -&gt; pgRowSet.rowCount() == <span>1</span>)<span>;<br/></span>}</pre>
<p>To remove a customer, the <kbd>delete</kbd> method executes <kbd>PreparedStatement</kbd>, which uses the customer <kbd>id</kbd> as a parameter:</p>
<pre><span>public static </span>CompletionStage&lt;Boolean&gt; <span>delete</span>(PgPool client<span>, </span>Long id) {<br/>    <span>return </span>client.preparedQuery(<span>"DELETE FROM CUSTOMER WHERE<br/>     id = $1"</span><span>, </span>Tuple.<span>of</span>(id))<br/>            .thenApply(pgRowSet -&gt; pgRowSet.rowCount() == <span>1</span>)<span>;<br/></span>}</pre>
<p>Finally, the <kbd>findAll</kbd> method is used to query a list of customers from the database and returns them as a Java list:</p>
<pre><span>public static </span>CompletionStage&lt;List&lt;Customer&gt;&gt; <span>findAll</span>(PgPool client) {<br/>    <span>return </span>client.query(<span>"SELECT id, name, surname FROM CUSTOMER <br/>    ORDER BY name ASC"</span>).thenApply(pgRowSet -&gt; {<br/>        List&lt;Customer&gt; list = <span>new </span>ArrayList&lt;&gt;(pgRowSet.size())<span>;<br/></span><span>        for </span>(Row row : pgRowSet) {<br/>            list.add(<span>from</span>(row))<span>;<br/></span><span>        </span>}<br/>        <span>return </span>list<span>;<br/></span><span>    </span>})<span>;<br/></span>}</pre>
<p>We have finished coding our application. Let's get it running!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the example</h1>
                </header>
            
            <article>
                
<p>Before running the example, make sure you have bootstrapped the PostgreSQL database; otherwise, the initial statements will fail when the application is deployed:</p>
<pre><strong>$ docker run --ulimit memlock=-1:-1 -it --rm=true --memory-swappiness=0 --name quarkus_test -e POSTGRES_USER=quarkus -e POSTGRES_PASSWORD=quarkus -e POSTGRES_DB=quarkusdb -p 5432:5432 postgres:10.5</strong></pre>
<p>Then, run the application as usual with the following command:</p>
<pre><strong>mvn  install quarkus:dev</strong></pre>
<p>The UI hides the fact that we have switched from plain objects to a real database, though you can work out that this has happened from the page title, which is now <span class="packt_screen">Quarkus Vert.X PgPool Example</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cd40a029-5c1c-4dcf-ba2b-0e2af385763d.png" style=""/></div>
<p>However, if you log in to the database container, you verify sure that the <kbd>Customer</kbd> table has been created with its items. Let's find the container ID for this purpose:</p>
<pre><strong>$ docker ps</strong><br/><strong> CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</strong><br/><strong> 6b1b13b0547f        postgres:10.5       "docker-entrypoint..."   2 minutes ago       Up 2 minutes        0.0.0.0:5432-&gt;5432/tcp   quarkus_test</strong></pre>
<p>Now, let's go into the bash shell of the PostgreSQL container by using the <kbd>docker exec</kbd> command:</p>
<pre><strong>$ docker exec -it 6b1b13b0547f /bin/bash</strong><br/><br/><strong> root@6b1b13b0547f:/# psql -U postgres</strong><br/><strong> psql (10.5 (Debian 10.5-2.pgdg90+1))</strong><br/><strong> Type "help" for help.</strong></pre>
<p>You can check the list of relationships using the <kbd>\dt</kbd> shortcut:</p>
<pre><strong> postgres=# \dt;</strong><br/><strong> List of relations</strong><br/><strong>  Schema |   Name   | Type  |  Owner   </strong><br/><strong> --------+----------+-------+----------</strong><br/><strong>  public | customer | table | postgres</strong><br/><strong> (1 row)</strong></pre>
<p>We can also query the <kbd>Customer</kbd> table's rows, as follows:</p>
<pre><strong>postgres=# select * from customer;</strong><br/><strong>  id | name | surname</strong><br/><strong> ----+------+---------</strong><br/><strong>   5 | John | Doe</strong><br/><strong>   6 | Fred | Smith</strong><br/><strong> (2 rows)</strong></pre>
<p>Great! We have completed our first reactive SQL application with Quarkus. This also marks the end of our journey into the land of Vert.x.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>From this whirlwind tour of Reactive Programming, you should be proficient in writing <span class="st">reactive applications on the JVM. Your programming skills now include how to use the</span> Vert.x core API to write asynchronous and non-blocking services. You have also learned how to combine the <kbd>Observable</kbd> pattern with streams or asynchronous results using the Vert.x Reactive API. Then, we quickly explored the last Vert.x paradigm, Vert.x Axle, which allows different beans to interact using asynchronous messages and enforces loose coupling. Finally, we applied a reactive API to access a relational database using the PostgreSQL client extension for Vert.x. </p>
<p><span class="st">Although you've gotten to grips with the Reactive Programming API, note that much of its power can only be unleashed when building real-time data pipelines and streaming data. We will cover these in the next chapter.<br/></span></p>


            </article>

            
        </section>
    </body></html>