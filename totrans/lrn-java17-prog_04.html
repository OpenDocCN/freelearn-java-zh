<html><head></head><body>
		<div id="_idContainer038">
			<h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor079"/>Chapter 3</em>: Java Fundamentals</h1>
			<p>This chapter presents to you a more detailed view of Java as a language. It starts with code organization in packages and a description of accessibility levels of classes (interfaces) and their methods and properties (fields). Reference types, as the main types of a Java object-oriented nature, are also presented in detail, followed by a list of reserved and restricted keywords and a discussion of their usage. The chapter ends with the methods of conversion between different primitive types and from a primitive type to a corresponding reference type and back.</p>
			<p>These are the fundamental terms and features of the Java language. The importance of understanding them cannot be overstated. Without them, you cannot write any Java program. So, try not to rush through this chapter and make sure you understand everything presented.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Packages, importing, and access</li>
				<li>Java reference types</li>
				<li>Reserved and restricted keywords</li>
				<li>Usage of the <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords</li>
				<li>Converting between primitive types</li>
				<li>Converting between primitive and reference types </li>
			</ul>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system </li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or a code editor you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and an IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, of this book. The files with the code examples for this chapter are available in the GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch03_fundamentals</strong> folder.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Packages, importing, and access</h1>
			<p>As you already know, a package name reflects a directory structure, starting with the project directory that contains the <strong class="source-inline">.java</strong> files. The name of each <strong class="source-inline">.java</strong> file has to be the same as the name of the top-level class declared in it (this class can contain other classes). The first line of the <strong class="source-inline">.java</strong> file is the package statement that starts with the <strong class="source-inline">package</strong> keyword, followed by the actual package name – the directory path to this file in which slashes are replaced with dots. </p>
			<p>A package name<a id="_idIndexMarker365"/> and the class name together compose a <strong class="bold">fully qualified class name</strong>. It uniquely identifies the class but tends to be too long and inconvenient to use. This is when <strong class="bold">importing</strong> comes to the rescue by allowing specification of the <a id="_idIndexMarker366"/>fully qualified name only once, and then referring to the class only by the class name.</p>
			<p>Invoking a method of a class from the method of another class is possible only if a caller has access to that class and its methods. The <strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, and <strong class="source-inline">private</strong> access modifiers define the level of accessibility and allow (or disallow) some methods, properties, or even the class itself to be visible to other classes.</p>
			<p>All these aspects will be discussed in detail in the current section.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Packages</h2>
			<p>Let’s look at<a id="_idIndexMarker367"/> the class we called <strong class="source-inline">Packages</strong>:</p>
			<pre class="source-code">package com.packt.learnjava.ch03_fundamentals;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.C;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.D;</pre>
			<pre class="source-code">public class Packages {</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        C c = new C();</pre>
			<pre class="source-code">        D d = new D();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The first line in the <strong class="source-inline">Packages</strong> class is a package declaration that identifies the class location <a id="_idIndexMarker368"/>on the source tree or, in other words, the <strong class="source-inline">.java</strong> file location in a filesystem. When the class is compiled and its <strong class="source-inline">.class</strong> file with bytecode is generated, the package name also reflects the <strong class="source-inline">.class</strong> file location in the filesystem. </p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Importing </h2>
			<p>After the <a id="_idIndexMarker369"/>package declaration, the <strong class="source-inline">import</strong> statements follow. As you can see from<a id="_idIndexMarker370"/> the previous example, they allow you to avoid using the fully qualified class (or interface) name anywhere else in the current class (or interface). When many classes (or interfaces) from the same package are imported, it is possible to import all classes and interfaces from the same package as a group, using the <strong class="source-inline">*</strong> symbol. In our example, it would look as follows:</p>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.*;</pre>
			<p>But that is not a recommended practice as it hides away the imported class (or interface) location when several packages are imported as a group. For example, look at this code snippet:</p>
			<pre class="source-code">package com.packt.learnjava.ch03_fundamentals;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.*;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.*;</pre>
			<pre class="source-code">public class Packages {</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        C c = new C();</pre>
			<pre class="source-code">        D d = new D();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the <a id="_idIndexMarker371"/>preceding code, can you guess the package to which class <strong class="source-inline">C</strong> or class <strong class="source-inline">D</strong> belongs? Also, it is possible that two classes in different packages have the same name. If that is the case, group importing can create a degree of confusion or even a problem that’s difficult to nail down.</p>
			<p>It is also possible to import an individual static class (or interface) members. For example, if <strong class="source-inline">SomeInterface</strong> has a <strong class="source-inline">NAME</strong> property (as a reminder, interface properties are public and static by default), you can typically refer to it as follows:</p>
			<pre class="source-code">package com.packt.learnjava.ch03_fundamentals;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.SomeInterface;</pre>
			<pre class="source-code">public class Packages {</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println(SomeInterface.NAME);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>To avoid using even the interface name, you can use a static import:</p>
			<pre class="source-code">package com.packt.learnjava.ch03_fundamentals;</pre>
			<pre class="source-code">import <strong class="bold">static</strong> com.packt.learnjava.ch02_oop.SomeInterface.<strong class="bold">NAME</strong>;</pre>
			<pre class="source-code">public class Packages {</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println(<strong class="bold">NAME</strong>);</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Similarly, if <strong class="source-inline">SomeClass</strong> has a public static property, <strong class="source-inline">someProperty</strong>, and a public static method, <strong class="source-inline">someMethod()</strong>, it is <a id="_idIndexMarker372"/>possible to import them statically too:</p>
			<pre class="source-code">package com.packt.learnjava.ch03_fundamentals;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.StaticMembers.SomeClass;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.C;</pre>
			<pre class="source-code">import com.packt.learnjava.ch02_oop.hiding.D;</pre>
			<pre class="source-code">import static com.packt.learnjava.ch02_oop.StaticMembers</pre>
			<pre class="source-code">                                         .SomeClass.someMethod;</pre>
			<pre class="source-code">import static com.packt.learnjava.ch02_oop.StaticMembers</pre>
			<pre class="source-code">                                      .SomeClass.SOME_PROPERTY;</pre>
			<pre class="source-code">public class Packages {</pre>
			<pre class="source-code">    public static void main(String... args){</pre>
			<pre class="source-code">        C c = new C();</pre>
			<pre class="source-code">        D d = new D();</pre>
			<pre class="source-code">        SomeClass obj = new SomeClass();</pre>
			<pre class="source-code">        someMethod(42);</pre>
			<pre class="source-code">        System.out.println(SOME_PROPERTY);    //prints: abc</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>But this technique should be used wisely, since it may create the impression that a statically imported method or property belongs to the current class.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Access modifiers</h2>
			<p>We have <a id="_idIndexMarker373"/>already used in our examples the three access modifiers –<strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, and <strong class="source-inline">private</strong> – which regulate access to the classes, interfaces, and their members from outside – from other classes or interfaces. There is also a <a id="_idIndexMarker374"/>fourth implicit one (also called the <strong class="bold">default modifier package-private</strong>) that is applied when none of the three explicit access modifiers is specified.</p>
			<p>The effect of their usage is pretty straightforward:</p>
			<ul>
				<li><strong class="source-inline">public</strong>: Accessible <a id="_idIndexMarker375"/>to other classes and interfaces of the current and other packages</li>
				<li><strong class="source-inline">protected</strong>: Accessible <a id="_idIndexMarker376"/>only to other members of the same package and children of the class</li>
				<li>no access modifier: Accessible only to other members of the same package</li>
				<li><strong class="source-inline">private</strong>: Accessible <a id="_idIndexMarker377"/>only to members of the same class</li>
			</ul>
			<p>From inside the class or an interface, all the class or interface members are always accessible. Besides, as we have stated several times already, all interface members are public by default, unless declared as <strong class="source-inline">private</strong>.</p>
			<p>Also, please note that class accessibility supersedes the class members’ accessibility because, if the class itself is not accessible from somewhere, no change in the accessibility of its methods or properties can make them accessible.</p>
			<p>When people talk about access modifiers for classes and interfaces, they mean the classes and interfaces that are declared inside other classes or interfaces. The encompassing class or interface is called a top-level class or interface, while those inside them are called inner classes or interfaces. The static inner classes are also called static nested classes.</p>
			<p>It does not make sense to declare a top-level class or interface <strong class="source-inline">private</strong> because it will not be accessible from anywhere. And the Java authors decided against allowing the top-level class or interface to be declared <strong class="source-inline">protected</strong> too. It is possible, though, to have a class without an explicit access modifier, thus making it accessible only to members of the same package.</p>
			<p>Here is an example:</p>
			<pre class="source-code">public class AccessModifiers {</pre>
			<pre class="source-code">    String prop1;</pre>
			<pre class="source-code">    private String prop2;</pre>
			<pre class="source-code">    protected String prop3;</pre>
			<pre class="source-code">    public String prop4;</pre>
			<pre class="source-code">    </pre>
			<pre class="source-code">    void method1(){ }</pre>
			<pre class="source-code">    private void method2(){ }</pre>
			<pre class="source-code">    protected void method3(){ }</pre>
			<pre class="source-code">    public void method4(){ }</pre>
			<pre class="source-code">    class A1{ }</pre>
			<pre class="source-code">    private class A2{ }</pre>
			<pre class="source-code">    protected class A3{ }</pre>
			<pre class="source-code">    public class A4{ }</pre>
			<pre class="source-code">    interface I1 {}</pre>
			<pre class="source-code">    private interface I2 {}</pre>
			<pre class="source-code">    protected interface I3 {}</pre>
			<pre class="source-code">    public interface I4 {}</pre>
			<pre class="source-code">}</pre>
			<p>Please note<a id="_idIndexMarker378"/> that static nested classes do not have access to other members of the top-level class.</p>
			<p>Another particular feature of an inner class is that it has access to all, even private members, of the top-level class, and vice versa. To demonstrate this feature, let’s create the following private properties and methods in the top-level class and in a <strong class="source-inline">private</strong> inner <a id="_idIndexMarker379"/>class:</p>
			<pre class="source-code">public class AccessModifiers {</pre>
			<pre class="source-code">    private String topLevelPrivateProperty = </pre>
			<pre class="source-code">                                     "Top-level private value";</pre>
			<pre class="source-code">    private void topLevelPrivateMethod(){</pre>
			<pre class="source-code">        var inner = new InnerClass();</pre>
			<pre class="source-code">        System.out.println(inner.innerPrivateProperty);</pre>
			<pre class="source-code">        inner.innerPrivateMethod();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private class InnerClass {</pre>
			<pre class="source-code">        //private static String PROP = "Inner static"; //error</pre>
			<pre class="source-code">        private String innerPrivateProperty = </pre>
			<pre class="source-code">                                         "Inner private value";</pre>
			<pre class="source-code">        private void innerPrivateMethod(){</pre>
			<pre class="source-code">            System.out.println(topLevelPrivateProperty);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private static class InnerStaticClass {</pre>
			<pre class="source-code">        private static String PROP = "Inner private static";</pre>
			<pre class="source-code">        private String innerPrivateProperty = </pre>
			<pre class="source-code">                                         "Inner private value";</pre>
			<pre class="source-code">        private void innerPrivateMethod(){</pre>
			<pre class="source-code">            var top = new AccessModifiers();</pre>
			<pre class="source-code">            System.out.println(top.topLevelPrivateProperty);</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you <a id="_idIndexMarker380"/>can see, all the methods and properties in the previous classes are private, which means that normally, they are not accessible from outside the class. And that is true for the <strong class="source-inline">AccessModifiers</strong> class – its private methods and properties are not accessible for other classes that are declared outside of it. But the <strong class="source-inline">InnerClass</strong> class can access the private members of the top-level class, while the top-level class can access the private members of its inner classes. The only limitation is that a non-static inner class cannot have static members. By contrast, a static nested class can have both static and non-static members, which makes a static nested class much more usable.</p>
			<p>To demonstrate all the possibilities described, we will add the following <strong class="source-inline">main()</strong> method to the <strong class="source-inline">AccessModifiers</strong> class:</p>
			<pre class="source-code">public static void main(String... args){</pre>
			<pre class="source-code">    var top = new AccessModifiers();</pre>
			<pre class="source-code">    top.topLevelPrivateMethod();</pre>
			<pre class="source-code">    //var inner = new InnerClass();  //compiler error</pre>
			<pre class="source-code">    System.out.println(InnerStaticClass.PROP);</pre>
			<pre class="source-code">    var inner = new InnerStaticClass();</pre>
			<pre class="source-code">    System.out.println(inner.innerPrivateProperty);</pre>
			<pre class="source-code">    inner.innerPrivateMethod();</pre>
			<pre class="source-code">}</pre>
			<p>Naturally, a non-static inner class cannot be accessed from a static context of the top-level class, hence the <strong class="source-inline">compiler error</strong> comment in the preceding code. If we run it, the result will be as follows:</p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B18388_Figure_3.1.jpg" alt=""/>
				</div>
			</div>
			<p>The <a id="_idIndexMarker381"/>first two lines of the output come from <strong class="source-inline">topLevelPrivateMethod()</strong>, and the rest from the <strong class="source-inline">main()</strong> method. As you can see, an inner- and a top-level class can access each other’s private state, inaccessible from outside.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Java reference types</h1>
			<p>A <strong class="source-inline">new</strong> operator <a id="_idIndexMarker382"/>creates an <a id="_idIndexMarker383"/>object of a class and returns the reference to the memory where the object resides. From a practical standpoint, the variable that holds this reference is treated in the code as if it is the object itself. Such a variable can be a class, an interface, an array, or a <strong class="source-inline">null</strong> literal<a id="_idIndexMarker384"/> that indicates that no memory reference is assigned to the variable. If the type of reference is an interface, it can be assigned either <strong class="source-inline">null</strong> or a reference to the object of the class that implements this interface because the interface itself cannot be instantiated.</p>
			<p>A JVM watches for all the created objects and checks whether there are references to each of them in the currently executed code. If there is an object without any reference to it, JVM removes it from the memory in a <a id="_idIndexMarker385"/>process called <strong class="bold">garbage collection</strong>. We will describe this process in <a href="B18388_09_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 9</em></a>, <em class="italic">JVM Structure and Garbage Collection</em>. For example, an object was created during a method execution and was referred to by the local variable. This reference will disappear as soon as the method finishes its execution.</p>
			<p>You have seen the examples of custom classes and interfaces, and we have talked about the <strong class="source-inline">String</strong> class already (see <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>). In this section, we will also describe two other Java reference types – array and enum – and demonstrate how to use them. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Class and interface</h2>
			<p>A <a id="_idIndexMarker386"/>variable of a class type is <a id="_idIndexMarker387"/>declared using the corresponding class name:</p>
			<pre class="source-code">&lt;Class name&gt; identifier;</pre>
			<p>The value that can be assigned to such a variable can be one of the following:</p>
			<ul>
				<li>A <strong class="source-inline">null</strong> literal reference type (which means the variable can be used but does not refer to any object)</li>
				<li>A reference to an object of the same class or any of its descendants (because a descendant inherits the types of all of its ancestors) </li>
			</ul>
			<p>This last type of assignment is<a id="_idIndexMarker388"/> called a <strong class="bold">widening assignment</strong> because it forces a specialized reference to become less specialized. For example, since every Java class is a subclass of <strong class="source-inline">java.lang.Object</strong>, the following assignment can be done for any class:</p>
			<pre class="source-code">Object obj = new AnyClassName();</pre>
			<p>Such an assignment is also <a id="_idIndexMarker389"/>called an <strong class="bold">upcasting</strong> because it moves the type of the variable up on the line of inheritance (which, like any family tree, is usually presented with the oldest ancestor at the top).</p>
			<p>After such an upcasting, it is possible to make a narrowing assignment using a <strong class="source-inline">(type)</strong>  cast operator:</p>
			<pre class="source-code">AnyClassName anyClassName = (AnyClassName)obj;</pre>
			<p>Such an assignment is also called <strong class="bold">downcasting</strong> and <a id="_idIndexMarker390"/>allows you to restore the descendant type. To apply this operation, you have to be sure that the identifier in fact refers to a descendant type. If in doubt, you can use the <strong class="source-inline">instanceof</strong> operator (see <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>) to check the reference type.</p>
			<p>Similarly, if a class implements a <a id="_idIndexMarker391"/>certain interface, its object reference can be assigned to this interface or any <a id="_idIndexMarker392"/>ancestor of the interface:</p>
			<pre class="source-code">interface C {}</pre>
			<pre class="source-code">interface B extends C {}</pre>
			<pre class="source-code">class A implements B { }</pre>
			<pre class="source-code">B b = new A();</pre>
			<pre class="source-code">C c = new A();</pre>
			<pre class="source-code">A a1 = (A)b;</pre>
			<pre class="source-code">A a2 = (A)c;</pre>
			<p>As you can see, as in the case with class reference upcasting and downcasting, it is possible to <a id="_idIndexMarker393"/>recover the original type of the object after its reference was assigned <a id="_idIndexMarker394"/>to a variable of one of the implemented interface types. </p>
			<p>The material of this section can also be viewed as another demonstration of Java polymorphism in action.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Array</h2>
			<p>An <strong class="bold">array</strong> is a reference type <a id="_idIndexMarker395"/>and, as such, extends the <strong class="source-inline">java.lang.Object</strong> class too. The array elements have the same type as the declared array type. The <a id="_idIndexMarker396"/>number of elements may be zero, in which case the array is said to be an empty array. Each element can be accessed by an index, which is a positive integer or zero. The first element has an index of zero. The number of elements is called an array length. Once an array is created, its length never changes.</p>
			<p>The following are <a id="_idIndexMarker397"/>examples of an array declaration:</p>
			<pre class="source-code">int[] intArray;</pre>
			<pre class="source-code">float[][] floatArray;</pre>
			<pre class="source-code">String[] stringArray;</pre>
			<pre class="source-code">SomeClass[][][] arr;</pre>
			<p>Each bracket pair indicates another dimension. The number of bracket pairs is the nesting depth of the array:</p>
			<pre class="source-code">int[] intArray = new int[10];</pre>
			<pre class="source-code">float[][] floatArray = new float[3][4];</pre>
			<pre class="source-code">String[] stringArray = new String[2];</pre>
			<pre class="source-code">SomeClass[][][] arr = new SomeClass[3][5][2];</pre>
			<p>The <strong class="source-inline">new</strong> operator <a id="_idIndexMarker398"/>allocates memory for each element that can be assigned (filled with) a value later. But in my case, the elements of an array are initialized to the default values at creation time, as the following example demonstrates:</p>
			<pre class="source-code">System.out.println(intArray[3]);      //prints: 0</pre>
			<pre class="source-code">System.out.println(floatArray[2][2]); //prints: 0.0</pre>
			<pre class="source-code">System.out.println(stringArray[1]);   //prints: null</pre>
			<p>Another way <a id="_idIndexMarker399"/>to create an array is to use an array initializer – a comma-separated list of values enclosed in braces for each dimension, such as the following:</p>
			<pre class="source-code">int[] intArray = {1,2,3,4,5,6,7,8,9,10};</pre>
			<pre class="source-code">float[][] floatArray ={{1.1f,2.2f,3,2},{10,20.f,30.f,5},{1,2,3,4}};</pre>
			<pre class="source-code">String[] stringArray = {"abc", "a23"};</pre>
			<pre class="source-code">System.out.println(intArray[3]);      //prints: 4</pre>
			<pre class="source-code">System.out.println(floatArray[2][2]); //prints: 3.0</pre>
			<pre class="source-code">System.out.println(stringArray[1]);   //prints: a23</pre>
			<p>A multidimensional array can be created without declaring the length of each dimension. Only the first dimension has to have the length specified:</p>
			<pre class="source-code">float[][] floatArray = new float[3][];</pre>
			<pre class="source-code">System.out.println(floatArray.length);  //prints: 3</pre>
			<pre class="source-code">System.out.println(floatArray[0]);      //prints: null</pre>
			<pre class="source-code">System.out.println(floatArray[1]);      //prints: null</pre>
			<pre class="source-code">System.out.println(floatArray[2]);      //prints: null</pre>
			<pre class="source-code">//System.out.println(floatArray[3]);    //error</pre>
			<pre class="source-code">//System.out.println(floatArray[2][2]); //error</pre>
			<p>The missing length of<a id="_idIndexMarker400"/> other dimensions can be specified later:</p>
			<pre class="source-code">float[][] floatArray = new float[3][];</pre>
			<pre class="source-code">floatArray[0] = new float[4];</pre>
			<pre class="source-code">floatArray[1] = new float[3];</pre>
			<pre class="source-code">floatArray[2] = new float[7];</pre>
			<pre class="source-code">System.out.println(floatArray[2][5]);   //prints: 0.0</pre>
			<p>This way, it is possible<a id="_idIndexMarker401"/> to assign a different length to different dimensions. Using the array initializer, it is also possible to create dimensions of different lengths:</p>
			<pre class="source-code">float[][] floatArray ={{1.1f},{10,5},{1,2,3,4}};</pre>
			<p>The only requirement is that a dimension has to be initialized before it can be used.</p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Enum</h2>
			<p>The <strong class="bold">enum</strong> reference<a id="_idIndexMarker402"/> type<a id="_idIndexMarker403"/> class extends the <strong class="source-inline">java.lang.Enum</strong> class, which, in turn, extends <strong class="source-inline">java.lang.Object</strong>. It allows the specification of a limited set of constants, each of them an instance of the same type. The declaration of such a set starts with the <strong class="source-inline">enum</strong> keyword. Here is an example:</p>
			<pre class="source-code">enum Season { SPRING, SUMMER, AUTUMN, WINTER }</pre>
			<p>Each of the listed items – <strong class="source-inline">SPRING</strong>, <strong class="source-inline">SUMMER</strong>, <strong class="source-inline">AUTUMN</strong>, and <strong class="source-inline">WINTER</strong> – is an instance of a <strong class="source-inline">Season</strong> type. They are the only four instances the <strong class="source-inline">Season</strong> class can have. They are created in advance and can be used everywhere as a value of a <strong class="source-inline">Season</strong> type. No other instance of the <strong class="source-inline">Season</strong> class can be created, and that is the reason for the creation of the <strong class="source-inline">enum</strong> type – it can be used for cases when the list of instances of a class has to be limited to the fixed set.</p>
			<p>The <strong class="source-inline">enum</strong> declaration<a id="_idIndexMarker404"/> can also be written in title case:</p>
			<pre class="source-code">enum Season { Spring, Summer, Autumn, Winter }</pre>
			<p>However, the all-capitals style is used more often because, as we mentioned earlier, there is a convention to express the static final constant’s identifier in a capital case. It helps to distinguish constants from variables. The <strong class="source-inline">enum</strong> constants are implicitly static and final.</p>
			<p>Because <a id="_idIndexMarker405"/>the <strong class="source-inline">enum</strong> values<a id="_idIndexMarker406"/> are constants, they exist uniquely in a JVM and can be compared by reference:</p>
			<pre class="source-code">Season season = Season.WINTER;</pre>
			<pre class="source-code">boolean b = season == Season.WINTER;</pre>
			<pre class="source-code">System.out.println(b);   //prints: true</pre>
			<p>The following are the most <a id="_idIndexMarker407"/>frequently used methods of the <strong class="source-inline">java.lang.Enum</strong> class:</p>
			<ul>
				<li><strong class="source-inline">name()</strong>: Returns the <strong class="source-inline">enum</strong> constant’s identifier as it is spelled when declared (<strong class="source-inline">WINTER</strong>, for example).</li>
				<li><strong class="source-inline">toString()</strong>: Returns the same value as the <strong class="source-inline">name()</strong> method by default but can be overridden to return any other <strong class="source-inline">String</strong> value.</li>
				<li><strong class="source-inline">ordinal()</strong>: Returns the position of the <strong class="source-inline">enum</strong> constant when declared (the first in the list has a <strong class="source-inline">0</strong> ordinal value).</li>
				<li><strong class="source-inline">valueOf(Class enumType, String name)</strong>: Returns the <strong class="source-inline">enum</strong> constant object by its name, expressed as a <strong class="source-inline">String</strong> literal.</li>
				<li><strong class="source-inline">values()</strong>: A static method, described in the documentation of the <strong class="source-inline">valueOff()</strong> method as follows: “All the constants of an <strong class="source-inline">enum</strong> class can be obtained by calling the implicit <strong class="source-inline">public static T[] values()</strong> method of that class.”</li>
			</ul>
			<p>To demonstrate the preceding methods, we <a id="_idIndexMarker408"/>are going to use the already familiar <strong class="source-inline">enum</strong>, <strong class="source-inline">Season</strong>:</p>
			<pre class="source-code">enum Season { SPRING, SUMMER, AUTUMN, WINTER }</pre>
			<p>And here is the demo code:</p>
			<pre class="source-code">System.out.println(Season.SPRING.name());      //prints: SPRING</pre>
			<pre class="source-code">System.out.println(Season.WINTER.toString());  //prints: WINTER</pre>
			<pre class="source-code">System.out.println(Season.SUMMER.ordinal());        //prints: 1</pre>
			<pre class="source-code">Season season = Enum.valueOf(Season.class, "AUTUMN");</pre>
			<pre class="source-code">System.out.println(season == Season.AUTUMN);     //prints: true</pre>
			<pre class="source-code">for(Season s: Season.values()){</pre>
			<pre class="source-code">    System.out.print(s.name() + " "); </pre>
			<pre class="source-code">                          //prints: SPRING SUMMER AUTUMN WINTER</pre>
			<pre class="source-code">}</pre>
			<p>To <a id="_idIndexMarker409"/>override <a id="_idIndexMarker410"/>the <strong class="source-inline">toString()</strong> method, let’s create the <strong class="source-inline">Season1</strong> <strong class="source-inline">enum</strong>:</p>
			<pre class="source-code">enum Season1 {</pre>
			<pre class="source-code">    SPRING, SUMMER, AUTUMN, WINTER;</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        return this.name().charAt(0) + </pre>
			<pre class="source-code">               this.name().substring(1).toLowerCase();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Here is how it works:</p>
			<pre class="source-code">for(Season1 s: Season1.values()){</pre>
			<pre class="source-code">    System.out.print(s.toString() + " "); </pre>
			<pre class="source-code">                          //prints: Spring Summer Autumn Winter</pre>
			<pre class="source-code">}</pre>
			<p>It is possible<a id="_idIndexMarker411"/> to add any other property to each <strong class="source-inline">enum</strong> constant. For example, let’s add an average<a id="_idIndexMarker412"/> temperature value to each <strong class="source-inline">enum</strong> instance:</p>
			<pre class="source-code">Enum Season2 {</pre>
			<pre class="source-code">    SPRING(42), SUMMER(67), AUTUMN(32), WINTER(20);</pre>
			<pre class="source-code">    private int temperature;</pre>
			<pre class="source-code">    Season2(int temperature){</pre>
			<pre class="source-code">    this.temperature = temperature;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getTemperature(){</pre>
			<pre class="source-code">        return this.temperature;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        return this.name().charAt(0) +</pre>
			<pre class="source-code">            this.name().substring(1).toLowerCase() +</pre>
			<pre class="source-code">                "(" + this.temperature + ")";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If we iterate over values of the <strong class="source-inline">Season2</strong> <strong class="source-inline">enum</strong>, the result will be as follows:</p>
			<pre class="source-code">for(Season2 s: Season2.values()){</pre>
			<pre class="source-code">    System.out.print(s.toString() + " "); </pre>
			<pre class="source-code">          //prints: Spring(42) Summer(67) Autumn(32) Winter(20)</pre>
			<pre class="source-code">}</pre>
			<p>In the standard Java libraries, there<a id="_idIndexMarker413"/> are several <strong class="source-inline">enum</strong> classes – for example, <strong class="source-inline">java.time.Month</strong>, <strong class="source-inline">java.time.DayOfWeek</strong>, and <strong class="source-inline">java.util.concurrent.TimeUnit</strong>. </p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Default values and literals </h2>
			<p>As we <a id="_idIndexMarker414"/>have already seen, the default value of a reference type is <strong class="source-inline">null</strong>. Some sources call it a <strong class="bold">special type null</strong>, but<a id="_idIndexMarker415"/> the Java language specification <a id="_idIndexMarker416"/>qualifies it as a literal. When an instance property or an array of a reference type is initialized automatically (when a value is not assigned explicitly), the assigned value is <strong class="source-inline">null</strong>. </p>
			<p>The only reference type that has<a id="_idIndexMarker417"/> a literal other than the <strong class="source-inline">null</strong> literal is the <strong class="source-inline">String</strong> class. We discussed strings in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>A reference type as a method parameter</h2>
			<p>When <a id="_idIndexMarker418"/>a primitive type value is passed into a method, we use it. If we do not like the value passed into the method, we change it as we see fit and do not think twice about it:</p>
			<pre class="source-code">void modifyParameter(int x){</pre>
			<pre class="source-code">    x = 2;</pre>
			<pre class="source-code">}</pre>
			<p>We have no concerns that the variable value outside the method may change:</p>
			<pre class="source-code">int x = 1;</pre>
			<pre class="source-code">modifyParameter(x);</pre>
			<pre class="source-code">System.out.println(x);  //prints: 1</pre>
			<p>It is not possible to change the parameter value of a primitive type outside the method because a primitive type parameter is passed into the method by value. This means that the copy of the value is passed into the method, so even if the code inside the method assigns a different value to it, the original value is not affected.</p>
			<p>Another issue with a reference type is that even though the reference itself is passed by value, it still points to the same original object in the memory, so the code inside the method can access the object and modify it. To demonstrate it, let’s create a <strong class="source-inline">DemoClass</strong> and the <a id="_idIndexMarker419"/>method that uses it:</p>
			<pre class="source-code">class DemoClass{</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    public DemoClass(String prop) { this.prop = prop; }</pre>
			<pre class="source-code">    public String getProp() { return prop; }</pre>
			<pre class="source-code">    public void setProp(String prop) { this.prop = prop; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">void modifyParameter(DemoClass obj){</pre>
			<pre class="source-code">    obj.setProp("Changed inside the method");</pre>
			<pre class="source-code">}</pre>
			<p>If we use the preceding method, the result will be as follows: </p>
			<pre class="source-code">DemoClass obj = new DemoClass("Is not changed");</pre>
			<pre class="source-code">modifyParameter(obj);</pre>
			<pre class="source-code">System.out.println(obj.getProp()); </pre>
			<pre class="source-code">                            //prints: Changed inside the method</pre>
			<p>That’s a big difference, isn’t it? So, you have to be careful not to modify the passed-in object in order to avoid an undesirable effect. However, this effect is occasionally used to return the result. But it does not belong to the list of best practices because it makes code less readable. Changing the passed-in object is like using a secret tunnel that is difficult to notice. So, use it only when you have to.</p>
			<p>Even if the passed-in object is a class that wraps a primitive value, this effect still holds (we will talk about the primitive values wrapping type in the <em class="italic">Converting between primitive and reference types</em> section). Here is <strong class="source-inline">DemoClass1</strong> and an overloaded version of the <strong class="source-inline">modifyParameter()</strong> method:</p>
			<pre class="source-code">class DemoClass1{</pre>
			<pre class="source-code">    private Integer prop;</pre>
			<pre class="source-code">    public DemoClass1(Integer prop) { this.prop = prop; }</pre>
			<pre class="source-code">    public Integer getProp() { return prop; }</pre>
			<pre class="source-code">    public void setProp(Integer prop) { this.prop = prop; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">void modifyParameter(DemoClass1 obj){</pre>
			<pre class="source-code">    obj.setProp(Integer.valueOf(2));</pre>
			<pre class="source-code">}</pre>
			<p>If we use the <a id="_idIndexMarker420"/>preceding method, the result will be as follows: </p>
			<pre class="source-code">DemoClass1 obj = new DemoClass1(Integer.valueOf(1));</pre>
			<pre class="source-code">modifyParameter(obj);</pre>
			<pre class="source-code">System.out.println(obj.getProp());  //prints: 2</pre>
			<p>The only exception to this behavior of reference types is an object of the <strong class="source-inline">String</strong> class. Here is another overloaded version of the <strong class="source-inline">modifyParameter()</strong> method:</p>
			<pre class="source-code">void modifyParameter(String obj){</pre>
			<pre class="source-code">    obj = "Changed inside the method";</pre>
			<pre class="source-code">}  </pre>
			<p>If we use the preceding method, the result will be as follows:</p>
			<pre class="source-code">String obj = "Is not changed";</pre>
			<pre class="source-code">modifyParameter(obj);</pre>
			<pre class="source-code">System.out.println(obj); //prints: Is not changed</pre>
			<pre class="source-code">obj = new String("Is not changed");</pre>
			<pre class="source-code">modifyParameter(obj);</pre>
			<pre class="source-code">System.out.println(obj); //prints: Is not changed</pre>
			<p>As you can see, whether we use a literal or a new <strong class="source-inline">String</strong> object, the result remains the same – the original <strong class="source-inline">String</strong> value is not changed after the method that assigns another value to it. That is exactly the purpose of the <strong class="source-inline">String</strong> value immutability feature we discussed in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>. </p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>equals() method </h2>
			<p>The <a id="_idIndexMarker421"/>equality operator (<strong class="source-inline">==</strong>), when applied to the <a id="_idIndexMarker422"/>variables of reference types, compares the references themselves, not the content (the state) of the objects. But two objects always have different memory references even if they have identical content. Even when used for <strong class="source-inline">String</strong> objects, the operator (<strong class="source-inline">==</strong>) returns <strong class="source-inline">false</strong> if at least one of them is created using a <strong class="source-inline">new</strong> operator (see the discussion about <strong class="source-inline">String</strong> value immutability in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>).</p>
			<p>To compare content, you can<a id="_idIndexMarker423"/> use the <strong class="source-inline">equals()</strong> method. Its implementation in the <strong class="source-inline">String</strong> class and numerical type wrapper classes (<strong class="source-inline">Integer</strong>, <strong class="source-inline">Float</strong>, and so on) does exactly that – compare the content of the objects. </p>
			<p>However, the <strong class="source-inline">equals()</strong> method implementation in the <strong class="source-inline">java.lang.Object</strong> class compares only references, which is understandable because the variety of possible content the descendants can have is huge, and the implementation of the generic content comparison is just not feasible. This means that every Java object that needs to have the <strong class="source-inline">equals()</strong> method comparing the object’s content – not just references – has to re-implement the <strong class="source-inline">equals()</strong> method and, thus, override its implementation in the <strong class="source-inline">java.lang.Object</strong> class, which appears as follows:</p>
			<pre class="source-code">  public boolean equals(Object obj) {</pre>
			<pre class="source-code">       return (this == obj);</pre>
			<pre class="source-code">}</pre>
			<p>By contrast, look at how the same method is implemented in the <strong class="source-inline">Integer</strong> class:</p>
			<pre class="source-code">private final int value;</pre>
			<pre class="source-code">public boolean equals(Object obj) {</pre>
			<pre class="source-code">    if (obj instanceof Integer) {</pre>
			<pre class="source-code">        return value == ((Integer)obj).intValue();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return false;</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, it extracts the primitive <strong class="source-inline">int</strong> value from the input object and compares it to the primitive value of the current object. It does not compare object references at all. </p>
			<p>The <strong class="source-inline">String</strong> class, on <a id="_idIndexMarker424"/>the other hand, compares the references first and, if the <a id="_idIndexMarker425"/>references are not the same value, compares the content of the objects:</p>
			<pre class="source-code">private final byte[] value;</pre>
			<pre class="source-code">public boolean equals(Object anObject) {</pre>
			<pre class="source-code">      if (this == anObject) {</pre>
			<pre class="source-code">            return true;</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      if (anObject instanceof String) {</pre>
			<pre class="source-code">         String aString = (String)anObject;</pre>
			<pre class="source-code">         if (coder() == aString.coder()) {</pre>
			<pre class="source-code">           return isLatin1() ? StringLatin1.equals(value, </pre>
			<pre class="source-code">             aString.value)</pre>
			<pre class="source-code">                             : StringUTF16.equals(value, </pre>
			<pre class="source-code">             aString.value);</pre>
			<pre class="source-code">         }</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      return false;</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">StringLatin1.equals()</strong> and <strong class="source-inline">StringUTF16.equals()</strong> methods compare the values character by character, not just references.</p>
			<p>Similarly, if the application code needs to compare two objects by their content, the <strong class="source-inline">equals()</strong> method in the corresponding class has to be overridden. For example, let’s look at the familiar <strong class="source-inline">DemoClass</strong> class:</p>
			<pre class="source-code">class DemoClass{</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    public DemoClass(String prop) { this.prop = prop; }</pre>
			<pre class="source-code">    public String getProp() { return prop; }</pre>
			<pre class="source-code">    public void setProp(String prop) { this.prop = prop; }</pre>
			<pre class="source-code">}</pre>
			<p>We can<a id="_idIndexMarker426"/> add to it the <strong class="source-inline">equals()</strong> method manually, but the IDE <a id="_idIndexMarker427"/>can help us to do this, as follows:</p>
			<ol>
				<li>Right-click inside the class just before the closing brace (<strong class="source-inline">}</strong>).</li>
				<li>Select <strong class="bold">Generate</strong> and then follow the prompts.</li>
			</ol>
			<p>Eventually, two methods will be generated and added to the class:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public boolean equals(Object o) {</pre>
			<pre class="source-code">    if (this == o) return true;</pre>
			<pre class="source-code">    if (!(o instanceof DemoClass)) return false;</pre>
			<pre class="source-code">    DemoClass demoClass = (DemoClass) o;</pre>
			<pre class="source-code">    return Objects.equals(getProp(), demoClass.getProp());</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public int hashCode() {</pre>
			<pre class="source-code">    return Objects.hash(getProp());</pre>
			<pre class="source-code">}</pre>
			<p>Looking at the generated code, focus your attention on the following points:</p>
			<ul>
				<li>The usage of the <strong class="source-inline">@Override</strong> annotation – this ensures that the method does override a <a id="_idIndexMarker428"/>method (with the same signature) in one of the ancestors. With this annotation in place, if you modify the method and change the signature (by mistake or intentionally), the compiler (and your IDE) will immediately raise an error, telling you that there is no method with such a signature in any of the ancestor classes. So, it helps to detect an error early.</li>
				<li>The usage of the <strong class="source-inline">java.util.Objects</strong> class – this has quite a few very helpful methods, including the <strong class="source-inline">equals()</strong> static method that not only compares <a id="_idIndexMarker429"/>references but also uses the <strong class="source-inline">equals()</strong> method:<p class="source-code">     public static boolean equals(Object a, Object b) {</p><p class="source-code">         return (a == b) || (a != null &amp;&amp; a.equals(b));</p><p class="source-code">     }</p></li>
			</ul>
			<p>As we have demonstrated earlier, the <strong class="source-inline">equals()</strong> method, implemented in the <strong class="source-inline">String</strong> class, compares strings by their content and serves this purpose because the <strong class="source-inline">getProp()</strong> method of <strong class="source-inline">DemoClass</strong> returns a string. </p>
			<p>The <strong class="source-inline">hashCode()</strong> method – the<a id="_idIndexMarker430"/> integer returned <a id="_idIndexMarker431"/>by this <a id="_idIndexMarker432"/>method uniquely identifies this particular object (but please do not expect it to be the same between different runs of the application). It is not necessary to have this method implemented if the only method needed is <strong class="source-inline">equals()</strong>. Nevertheless, it is recommended to have it just in case the object of this class is going to be collected in <strong class="source-inline">Set</strong> or another collection based on a hash code (we are going to talk about Java collections in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>). </p>
			<p>Both these methods are implemented in <strong class="source-inline">Object</strong> because many algorithms use the <strong class="source-inline">equals()</strong> and <strong class="source-inline">hashCode()</strong> methods, and your application may not work without these methods implemented. Meanwhile, your objects may not need them in your application. However, once<a id="_idIndexMarker433"/> you decide to implement the <strong class="source-inline">equals()</strong> method, it is a good idea to implement the <strong class="source-inline">hasCode()</strong> method too. Besides, as you have seen, an IDE can do this without any overhead.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Reserved and restricted keywords</h1>
			<p>The <strong class="bold">keywords</strong> are <a id="_idIndexMarker434"/>the words that have particular meaning for a compiler and cannot be used as identifiers. As of Java 17, there are 52 reserved keywords, 5 reserved identifiers, 3 reserved words,  and 10 restricted keywords. The reserved keywords cannot be used as identifiers anywhere in the Java code, while the restricted keywords cannot be used as identifiers only in the context of a module declaration.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Reserved keywords</h2>
			<p>The <a id="_idIndexMarker435"/>following<a id="_idIndexMarker436"/> is a list of all Java-reserved keywords:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18388_Table_3.1.jpg" alt=""/>
				</div>
			</div>
			<p>By now, you <a id="_idIndexMarker437"/>should feel at home with most of the preceding keywords. By way of an exercise, you can go through the list and check how many of them you remember. Up until <a id="_idIndexMarker438"/>now, we have not discussed the following eight <a id="_idIndexMarker439"/>keywords:</p>
			<ul>
				<li><strong class="source-inline">const</strong> and <strong class="source-inline">goto</strong> are reserved but not used, so far.</li>
				<li>The <strong class="source-inline">assert</strong> keyword is <a id="_idIndexMarker440"/>used in an <strong class="source-inline">assert</strong> statement (we will talk about this in <a href="B18388_04_ePub.xhtml#_idTextAnchor110"><em class="italic">Chapter 4</em></a>, <em class="italic">Exception Handling</em>).</li>
				<li>The <strong class="source-inline">synchronized</strong> keyword<a id="_idIndexMarker441"/> is used in concurrent programming (we will talk about this in <a href="B18388_08_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 8</em></a>, <em class="italic">Multithreading and Concurrent Processing</em>).</li>
				<li>The <strong class="source-inline">volatile</strong> keyword <a id="_idIndexMarker442"/>makes the value of a variable uncacheable.</li>
				<li>The <strong class="source-inline">transient</strong> keyword makes<a id="_idIndexMarker443"/> the value of a variable not serializable.</li>
				<li>The <strong class="source-inline">strictfp</strong> keyword <a id="_idIndexMarker444"/>restricts floating-point calculations, making it the same result on every platform while performing operations in the floating-point variable.</li>
				<li>The <strong class="source-inline">native</strong> keyword<a id="_idIndexMarker445"/> declares a method implemented in platform-dependent code, such as C or C++.</li>
			</ul>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Reserved identifiers</h2>
			<p>The <a id="_idIndexMarker446"/>five reserved identifiers<a id="_idIndexMarker447"/> in Java are as follows:</p>
			<ul>
				<li><strong class="source-inline">permits</strong></li>
				<li><strong class="source-inline">record</strong></li>
				<li><strong class="source-inline">sealed</strong></li>
				<li><strong class="source-inline">var</strong></li>
				<li><strong class="source-inline">yield</strong></li>
			</ul>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Reserved words for literal values</h2>
			<p>The three <a id="_idIndexMarker448"/>reserved <a id="_idIndexMarker449"/>words in Java are as follows:</p>
			<ul>
				<li><strong class="source-inline">true</strong></li>
				<li><strong class="source-inline">false</strong></li>
				<li><strong class="source-inline">null</strong></li>
			</ul>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Restricted keywords</h2>
			<p>The 10 <a id="_idIndexMarker450"/>restricted keywords in <a id="_idIndexMarker451"/>Java are as follows:</p>
			<ul>
				<li><strong class="source-inline">open</strong></li>
				<li><strong class="source-inline">module</strong></li>
				<li><strong class="source-inline">requires</strong></li>
				<li><strong class="source-inline">transitive</strong></li>
				<li><strong class="source-inline">exports</strong></li>
				<li><strong class="source-inline">opens</strong></li>
				<li><strong class="source-inline">to </strong></li>
				<li><strong class="source-inline">uses </strong></li>
				<li><strong class="source-inline">provides</strong></li>
				<li><strong class="source-inline">with</strong></li>
			</ul>
			<p>They are called <em class="italic">restricted</em> because<a id="_idIndexMarker452"/> they cannot be identifiers in the <a id="_idIndexMarker453"/>context of a module declaration, which we will not discuss in this book. In all other places, it is possible to use them as identifiers, such as the following:</p>
			<pre class="source-code">String to = "To";</pre>
			<pre class="source-code">String with = "abc";</pre>
			<p>Although you can, it is a good practice not to use them as identifiers, even outside module declaration. </p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Usage of the this and super keywords</h1>
			<p>The <strong class="source-inline">this</strong> keyword<a id="_idIndexMarker454"/> provides a reference to the current object. The <strong class="source-inline">super</strong> keyword <a id="_idIndexMarker455"/>refers to the parent class object. These keywords allow us to refer to a variable or method that has the same name in the current context and the parent object.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Usage of the this keyword</h2>
			<p>Here is the<a id="_idIndexMarker456"/> most popular example:</p>
			<pre class="source-code">class A {</pre>
			<pre class="source-code">    private int count;</pre>
			<pre class="source-code">    public void setCount(int count) {</pre>
			<pre class="source-code">        count = count;         // 1</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getCount(){</pre>
			<pre class="source-code">        return count;          // 2</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The<a id="_idIndexMarker457"/> first line looks ambiguous, but, in fact, it is not – the local variable, <strong class="source-inline">int count</strong>, hides the <strong class="source-inline">int count</strong> private property instance. We can demonstrate this by running the following code:</p>
			<pre class="source-code">A a = new A();</pre>
			<pre class="source-code">a.setCount(2);</pre>
			<pre class="source-code">System.out.println(a.getCount());     //prints: 0</pre>
			<p>Using the <strong class="source-inline">this</strong> keyword fixes the problem:</p>
			<pre class="source-code">class A {</pre>
			<pre class="source-code">    private int count;</pre>
			<pre class="source-code">    public void setCount(int count) {</pre>
			<pre class="source-code">        this.count = count;         // 1</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getCount(){</pre>
			<pre class="source-code">        return this.count;          // 2</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Adding <strong class="source-inline">this</strong> to line <strong class="source-inline">1</strong> allows the value to be assigned the instance property. Adding <strong class="source-inline">this</strong> to line <strong class="source-inline">2</strong> does not make a difference, but it is good practice to use the <strong class="source-inline">this</strong> keyword every time with the <strong class="source-inline">instance</strong> property. It makes the code more readable and helps avoid difficult-to-trace errors, such as the one we have just demonstrated.</p>
			<p>We have also seen the <strong class="source-inline">this</strong> keyword usage in the <strong class="source-inline">equals()</strong> method:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public boolean equals(Object o) {</pre>
			<pre class="source-code">    if (this == o) return true;</pre>
			<pre class="source-code">    if (!(o instanceof DemoClass)) return false;</pre>
			<pre class="source-code">    DemoClass demoClass = (DemoClass) o;</pre>
			<pre class="source-code">    return Objects.equals(getProp(), demoClass.getProp());</pre>
			<pre class="source-code">}</pre>
			<p>And, just <a id="_idIndexMarker458"/>to remind you, here are the examples of a constructor that we presented in <a href="B18388_02_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, <em class="italic">Java Object-Oriented Programming (OOP)</em>:</p>
			<pre class="source-code">class TheChildClass extends TheParentClass{</pre>
			<pre class="source-code">    private int x;</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    private String anotherProp = "abc";</pre>
			<pre class="source-code">    public TheChildClass(String prop){</pre>
			<pre class="source-code">        super(42);</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public TheChildClass(int arg1, String arg2){</pre>
			<pre class="source-code">        super(arg1);</pre>
			<pre class="source-code">        this.prop = arg2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code, you can see not only the <strong class="source-inline">this</strong> keyword but also the usage of the <strong class="source-inline">super</strong> keyword, which we are going to discuss next.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Usage of the super keyword </h2>
			<p>The <strong class="source-inline">super</strong> keyword refers to the parent object. We saw its usage in the <em class="italic">Usage of the this keyword</em> section<a id="_idIndexMarker459"/> in a constructor already, where it has to be used only in the first line because the parent class object has to be created before the current object can be created. If the first line of the constructor is not <strong class="source-inline">super()</strong>, this means the parent class has a constructor without parameters.</p>
			<p>The <strong class="source-inline">super</strong> keyword is <a id="_idIndexMarker460"/>especially helpful when a method is overridden and the method of the parent class has to be called:</p>
			<pre class="source-code">class B  {</pre>
			<pre class="source-code">    public void someMethod() {</pre>
			<pre class="source-code">        System.out.println("Method of B class");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C extends B {</pre>
			<pre class="source-code">    public void someMethod() {</pre>
			<pre class="source-code">        System.out.println("Method of C class");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void anotherMethod() {</pre>
			<pre class="source-code">        this.someMethod();    //prints: Method of C class</pre>
			<pre class="source-code">        super.someMethod();   //prints: Method of B class</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As we progress through this book, we will see more examples of using the <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Converting between primitive types</h1>
			<p>The <a id="_idIndexMarker461"/>maximum <a id="_idIndexMarker462"/>numeric value that a numeric type can hold depends on the number of bits allocated to it. The following are the number of bits for each numeric type of representation:</p>
			<ul>
				<li><strong class="source-inline">byte</strong>: 8 bits</li>
				<li><strong class="source-inline">char</strong>: 16 bits</li>
				<li><strong class="source-inline">short</strong>: 16 bits</li>
				<li><strong class="source-inline">int</strong>: 32 bits</li>
				<li><strong class="source-inline">long</strong>: 64 bits</li>
				<li><strong class="source-inline">float</strong>: 32 bits</li>
				<li><strong class="source-inline">double</strong>: 64 bits</li>
			</ul>
			<p>When a value of one numeric type is assigned to a variable of another numeric type and the new type can<a id="_idIndexMarker463"/> hold a bigger number, such a conversion is called a <strong class="bold">widening conversion</strong>. Otherwise, it<a id="_idIndexMarker464"/> is a <strong class="bold">narrowing conversion</strong>, which<a id="_idIndexMarker465"/> usually requires typecasting, using a <strong class="source-inline">cast</strong> operator. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Widening conversion</h2>
			<p>According<a id="_idIndexMarker466"/> to the Java Language Specification, there are 19 widening primitive type conversions:</p>
			<ul>
				<li><strong class="source-inline">byte</strong> to <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, or <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">short</strong> to <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, or <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">char</strong> to <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, or <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">int</strong> to <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, or <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">long</strong> to <strong class="source-inline">float</strong> or <strong class="source-inline">double</strong></li>
				<li><strong class="source-inline">float</strong> to <strong class="source-inline">double</strong></li>
			</ul>
			<p>During widening conversion<a id="_idIndexMarker467"/> between<a id="_idIndexMarker468"/> integral types, and from some integral types to a floating-point type, the resulting value matches the original one exactly. However, conversion from <strong class="source-inline">int</strong> to <strong class="source-inline">float</strong>, from <strong class="source-inline">long</strong> to <strong class="source-inline">float</strong>, or from <strong class="source-inline">long</strong> to <strong class="source-inline">double</strong> may result in a loss of precision. The resulting floating-point value may be correctly rounded using <strong class="source-inline">IEEE 754 round-to-nearest mode</strong>, according to the Java Language Specification. Here are a few examples that demonstrate the loss of precision:</p>
			<pre class="source-code">int i = 123456789;</pre>
			<pre class="source-code">double d = (double)i;</pre>
			<pre class="source-code">System.out.println(i - (int)d);       //prints: 0</pre>
			<pre class="source-code">long l1 = 12345678L;</pre>
			<pre class="source-code">float f1 = (float)l1;</pre>
			<pre class="source-code">System.out.println(l1 - (long)f1);    //prints: 0</pre>
			<pre class="source-code">long l2 = 123456789L;</pre>
			<pre class="source-code">float f2 = (float)l2;</pre>
			<pre class="source-code">System.out.println(l2 - (long)f2);    //prints: -3</pre>
			<pre class="source-code">long l3 = 1234567891111111L;</pre>
			<pre class="source-code">double d3 = (double)l3;</pre>
			<pre class="source-code">System.out.println(l3 - (long)d3);    //prints: 0</pre>
			<pre class="source-code">long l4 = 12345678999999999L;</pre>
			<pre class="source-code">double d4 = (double)l4;</pre>
			<pre class="source-code">System.out.println(l4 - (long)d4);    //prints: -1 </pre>
			<p>As you can see, conversion from <strong class="source-inline">int</strong> to <strong class="source-inline">double</strong> preserves the value, but <strong class="source-inline">long</strong> to <strong class="source-inline">float</strong>, or <strong class="source-inline">long</strong> to <strong class="source-inline">double</strong>, may lose precision. It depends on how big the value is. So, be aware and allow <a id="_idIndexMarker469"/>for some<a id="_idIndexMarker470"/> loss of precision if it is important for your calculations.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Narrowing conversion</h2>
			<p>The Java Language Specification <a id="_idIndexMarker471"/>identifies 22 <a id="_idIndexMarker472"/>narrowing primitive conversions:</p>
			<ul>
				<li><strong class="source-inline">short</strong> to <strong class="source-inline">byte</strong> or <strong class="source-inline">char</strong></li>
				<li><strong class="source-inline">char</strong> to <strong class="source-inline">byte</strong> or <strong class="source-inline">short</strong></li>
				<li><strong class="source-inline">int</strong> to <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, or <strong class="source-inline">char</strong></li>
				<li><strong class="source-inline">long</strong> to <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">char</strong>, or <strong class="source-inline">int</strong></li>
				<li><strong class="source-inline">float</strong> to <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">int</strong>, or <strong class="source-inline">long</strong></li>
				<li><strong class="source-inline">double</strong> to <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, or <strong class="source-inline">float</strong></li>
			</ul>
			<p>Similar to the <a id="_idIndexMarker473"/>widening conversion, a narrowing conversion may result in a loss of precision, or even in a loss of the value magnitude. The narrowing conversion is more complicated than a widening one, and we are not going to discuss it in this book. It is important to remember that before performing a narrowing, you must make sure that the original value is smaller than the maximum value of the target type. Otherwise, you can get a completely different value (with lost magnitude). Look at the following example:</p>
			<pre class="source-code">System.out.println(Integer.MAX_VALUE); //prints: 2147483647</pre>
			<pre class="source-code">double d1 = 1234567890.0;</pre>
			<pre class="source-code">System.out.println((int)d1);           //prints: 1234567890</pre>
			<pre class="source-code">double d2 = 12345678909999999999999.0;</pre>
			<pre class="source-code">System.out.println((int)d2);           //prints: 2147483647</pre>
			<p>As you can see from the examples, without checking first whether the target type can accommodate <a id="_idIndexMarker474"/>the value, you can get the result just equal to the maximum value of the target type. The<a id="_idIndexMarker475"/> rest will be just lost, no matter how big the difference is.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Before performing a narrowing conversion, check whether the maximum value of the target type can hold the original value.</p>
			<p>Please note that the conversion between the <strong class="source-inline">char</strong> type and the <strong class="source-inline">byte</strong> or <strong class="source-inline">short</strong> types is an even more complicated procedure because the <strong class="source-inline">char</strong> type is an unsigned numeric type, while the <strong class="source-inline">byte</strong> and <strong class="source-inline">short</strong> types are signed numeric types, so some loss of information is possible even when a value may look as though it fits in the target type.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/>Methods of conversion</h2>
			<p>In addition to the <a id="_idIndexMarker476"/>casting, each primitive type has a corresponding reference type (called a <strong class="bold">wrapper class</strong>) that has<a id="_idIndexMarker477"/> methods that convert the value of this type to any other primitive type, except <strong class="source-inline">boolean</strong> and <strong class="source-inline">char</strong>. All the wrapper classes belong to the <strong class="source-inline">java.lang</strong> package:</p>
			<ul>
				<li><strong class="source-inline">java.lang.Boolean</strong></li>
				<li><strong class="source-inline">java.lang.Byte</strong></li>
				<li><strong class="source-inline">java.lang.Character</strong></li>
				<li><strong class="source-inline">java.lang.Short</strong></li>
				<li><strong class="source-inline">java.lang.Integer</strong></li>
				<li><strong class="source-inline">java.lang.Long</strong></li>
				<li><strong class="source-inline">java.lang.Float</strong></li>
				<li><strong class="source-inline">java.lang.Double</strong></li>
			</ul>
			<p>Each of them – except the <strong class="source-inline">Boolean</strong> and <strong class="source-inline">Character</strong> classes – extends the <strong class="source-inline">java.lang.Number</strong> abstract class, which has the following abstract methods:</p>
			<ul>
				<li><strong class="source-inline">byteValue()</strong></li>
				<li><strong class="source-inline">shortValue()</strong></li>
				<li><strong class="source-inline">intValue()</strong></li>
				<li><strong class="source-inline">longValue()</strong></li>
				<li><strong class="source-inline">floatValue()</strong></li>
				<li><strong class="source-inline">doubleValue()</strong></li>
			</ul>
			<p>Such <a id="_idIndexMarker478"/>design forces the descendants of the <strong class="source-inline">Number</strong> class to implement all of them. The results they produce are the same as the <strong class="source-inline">cast</strong> operator in the previous examples:</p>
			<pre class="source-code">int i = 123456789;</pre>
			<pre class="source-code">double d = Integer.valueOf(i).doubleValue();</pre>
			<pre class="source-code">System.out.println(i - (int)d);          //prints: 0</pre>
			<pre class="source-code">long l1 = 12345678L;</pre>
			<pre class="source-code">float f1 = Long.valueOf(l1).floatValue();</pre>
			<pre class="source-code">System.out.println(l1 - (long)f1);       //prints: 0</pre>
			<pre class="source-code">long l2 = 123456789L;</pre>
			<pre class="source-code">float f2 = Long.valueOf(l2).floatValue();</pre>
			<pre class="source-code">System.out.println(l2 - (long)f2);       //prints: -3</pre>
			<pre class="source-code">long l3 = 1234567891111111L;</pre>
			<pre class="source-code">double d3 = Long.valueOf(l3).doubleValue();</pre>
			<pre class="source-code">System.out.println(l3 - (long)d3);       //prints: 0</pre>
			<pre class="source-code">long l4 = 12345678999999999L;</pre>
			<pre class="source-code">double d4 = Long.valueOf(l4).doubleValue();</pre>
			<pre class="source-code">System.out.println(l4 - (long)d4);       //prints: -1</pre>
			<pre class="source-code">double d1 = 1234567890.0;</pre>
			<pre class="source-code">System.out.println(Double.valueOf(d1)</pre>
			<pre class="source-code">                         .intValue());   //prints: 1234567890</pre>
			<pre class="source-code">double d2 = 12345678909999999999999.0;</pre>
			<pre class="source-code">System.out.println(Double.valueOf(d2)</pre>
			<pre class="source-code">                         .intValue());   //prints: 2147483647</pre>
			<p>In addition, each <a id="_idIndexMarker479"/>of the wrapper classes has methods that allow the conversion of the <strong class="source-inline">String</strong> representation of a numeric value to the corresponding primitive numeric type or reference type, such as the following:</p>
			<pre class="source-code">byte b1 = Byte.parseByte("42");</pre>
			<pre class="source-code">System.out.println(b1);             //prints: 42</pre>
			<pre class="source-code">Byte b2 = Byte.decode("42");</pre>
			<pre class="source-code">System.out.println(b2);             //prints: 42</pre>
			<pre class="source-code">boolean b3 = Boolean.getBoolean("property");</pre>
			<pre class="source-code">System.out.println(b3);            //prints: false</pre>
			<pre class="source-code">Boolean b4 = Boolean.valueOf("false");</pre>
			<pre class="source-code">System.out.println(b4);            //prints: false</pre>
			<pre class="source-code">int i1 = Integer.parseInt("42");</pre>
			<pre class="source-code">System.out.println(i1);            //prints: 42</pre>
			<pre class="source-code">Integer i2 = Integer.getInteger("property");</pre>
			<pre class="source-code">System.out.println(i2);            //prints: null</pre>
			<pre class="source-code">double d1 = Double.parseDouble("3.14");</pre>
			<pre class="source-code">System.out.println(d1);            //prints: 3.14</pre>
			<pre class="source-code">Double d2 = Double.valueOf("3.14");</pre>
			<pre class="source-code">System.out.println(d2);            //prints: 3.14</pre>
			<p>In the <a id="_idIndexMarker480"/>examples, please note the two methods that accept the <strong class="source-inline">property</strong> parameter. These two and similar methods of other wrapper classes convert a system property (if one exists) to the corresponding primitive type.</p>
			<p>Each of the wrapper classes has the <strong class="source-inline">toString(primitive value)</strong> static method to convert the primitive type value to its <strong class="source-inline">String</strong> representation, such as the following:</p>
			<pre class="source-code">String s1 = Integer.toString(42);</pre>
			<pre class="source-code">System.out.println(s1);            //prints: 42</pre>
			<pre class="source-code">String s2 = Double.toString(3.14);</pre>
			<pre class="source-code">System.out.println(s2);            //prints: 3.14</pre>
			<p>The wrapper classes have many other useful methods of conversion from one primitive type to another and to different formats. So, if you need to do something such as that, look into the corresponding wrapper class first.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Converting between primitive and reference types</h1>
			<p>The<a id="_idIndexMarker481"/> conversion of a <a id="_idIndexMarker482"/>primitive type value to an object of the corresponding wrapper class is called <strong class="bold">boxing</strong>. Also, the <a id="_idIndexMarker483"/>conversion from an object of a wrapper class to the corresponding primitive type value<a id="_idIndexMarker484"/> is called <strong class="bold">unboxing</strong>.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Boxing</h2>
			<p>The boxing of a primitive type can be done either<a id="_idIndexMarker485"/> automatically (called <strong class="bold">autoboxing</strong>) or explicitly using the <strong class="source-inline">valueOf()</strong> method available in each wrapper type:</p>
			<pre class="source-code">int i1 = 42;</pre>
			<pre class="source-code">Integer i2 = i1;              //autoboxing</pre>
			<pre class="source-code">//Long l2 = i1;               //error</pre>
			<pre class="source-code">System.out.println(i2);       //prints: 42</pre>
			<pre class="source-code">i2 = Integer.valueOf(i1);</pre>
			<pre class="source-code">System.out.println(i2);       //prints: 42</pre>
			<pre class="source-code">Byte b = Byte.valueOf((byte)i1);</pre>
			<pre class="source-code">System.out.println(b);       //prints: 42</pre>
			<pre class="source-code">Short s = Short.valueOf((short)i1);</pre>
			<pre class="source-code">System.out.println(s);       //prints: 42</pre>
			<pre class="source-code">Long l = Long.valueOf(i1);</pre>
			<pre class="source-code">System.out.println(l);       //prints: 42</pre>
			<pre class="source-code">Float f = Float.valueOf(i1);</pre>
			<pre class="source-code">System.out.println(f);       //prints: 42.0</pre>
			<pre class="source-code">Double d = Double.valueOf(i1);</pre>
			<pre class="source-code">System.out.println(d);       //prints: 42.0 </pre>
			<p>Note that <a id="_idIndexMarker486"/>autoboxing is only possible in relation to a corresponding wrapper type. Otherwise, the compiler generates an error.</p>
			<p>The input value of the <strong class="source-inline">valueOf()</strong> method of the <strong class="source-inline">Byte</strong> and <strong class="source-inline">Short</strong> wrappers required casting because it was a narrowing of a primitive type we discussed in the previous section.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Unboxing</h2>
			<p>Unboxing <a id="_idIndexMarker487"/>can be accomplished using methods of the <strong class="source-inline">Number</strong> class implemented in each wrapper class:</p>
			<pre class="source-code">Integer i1 = Integer.valueOf(42);</pre>
			<pre class="source-code">int i2 = i1.intValue();</pre>
			<pre class="source-code">System.out.println(i2);      //prints: 42</pre>
			<pre class="source-code">byte b = i1.byteValue();</pre>
			<pre class="source-code">System.out.println(b);       //prints: 42</pre>
			<pre class="source-code">short s = i1.shortValue();</pre>
			<pre class="source-code">System.out.println(s);       //prints: 42</pre>
			<pre class="source-code">long l = i1.longValue();</pre>
			<pre class="source-code">System.out.println(l);       //prints: 42</pre>
			<pre class="source-code">float f = i1.floatValue();</pre>
			<pre class="source-code">System.out.println(f);       //prints: 42.0</pre>
			<pre class="source-code">double d = i1.doubleValue();</pre>
			<pre class="source-code">System.out.println(d);       //prints: 42.0</pre>
			<pre class="source-code">Long l1 = Long.valueOf(42L);</pre>
			<pre class="source-code">long l2 = l1;                //implicit unboxing</pre>
			<pre class="source-code">System.out.println(l2);      //prints: 42</pre>
			<pre class="source-code">double d2 = l1;              //implicit unboxing</pre>
			<pre class="source-code">System.out.println(d2);      //prints: 42.0</pre>
			<pre class="source-code">long l3 = i1;                //implicit unboxing</pre>
			<pre class="source-code">System.out.println(l3);      //prints: 42</pre>
			<pre class="source-code">double d3 = i1;              //implicit unboxing</pre>
			<pre class="source-code">System.out.println(d3);      //prints: 42.0</pre>
			<p>As you can see <a id="_idIndexMarker488"/>from the comment in the example, the conversion from a wrapper type to the <a id="_idIndexMarker489"/>corresponding primitive type is not called <strong class="bold">auto-unboxing</strong>; it is called <strong class="bold">implicit unboxing</strong> instead. In contrast to <a id="_idIndexMarker490"/>autoboxing, it is possible to use implicit unboxing even between wrapping and primitive types that do not match.</p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, you learned what Java packages are and the role they play in organizing code and class accessibility, including the <strong class="source-inline">import</strong> statement and access modifiers. You also became familiar with reference types – classes, interfaces, arrays, and enums. The default value of any reference type is <strong class="source-inline">null</strong>, including the <strong class="source-inline">String</strong> type.</p>
			<p>You should now understand that the reference type is passed into a method by reference and how the <strong class="source-inline">equals()</strong> method is used and can be overridden. You also had an opportunity to study the full list of reserved and restricted keywords and learned the meaning and usage of the <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords.</p>
			<p>The chapter concluded by describing the process and methods of conversion between primitive types, wrapping types, and <strong class="source-inline">String</strong> literals.</p>
			<p>In the next chapter, we will talk about the Java exceptions framework, checked and unchecked (runtime) exceptions, <strong class="source-inline">try-catch-finally</strong> blocks, <strong class="source-inline">throws</strong> and <strong class="source-inline">throw</strong> statements, and the best practices of exception handling.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Quiz</h1>
			<ol>
				<li value="1">Select all the statements that are correct:<ol><li>The <strong class="source-inline">Package</strong> statement describes the class or interface location.</li><li>The <strong class="source-inline">Package</strong> statement describes the class or interface name.</li><li><strong class="source-inline">Package</strong> is a fully qualified name.</li><li>The <strong class="source-inline">Package</strong> name and class name compose a fully qualified name of the class.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>The <strong class="source-inline">Import</strong> statement allows the use of the fully qualified name.</li><li>The <strong class="source-inline">Import</strong> statement has to be the first in the <strong class="source-inline">.java</strong> file.</li><li>The <strong class="source-inline">Group import</strong> statement brings in the classes (and interfaces) of one package only.</li><li>The <strong class="source-inline">Import statement</strong> allows the use of the fully qualified name to be avoided.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Without an access modifier, the class is accessible only by other classes and interfaces of the same package.</li><li>The private method of a private class is accessible to other classes declared in the same <strong class="source-inline">.java</strong> file.</li><li>The public method of a private class is accessible to other classes not declared in the same <strong class="source-inline">.java</strong> file but from the same package.</li><li>The protected method is accessible only to the descendants of the class.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Private methods can be overloaded but not overridden.</li><li>Protected methods can be overridden but not overloaded.</li><li>Methods without an access modifier can be both overridden and overloaded.</li><li>Private methods can access private properties of the same class.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Narrowing and downcasting are synonyms.</li><li>Widening and downcasting are synonyms.</li><li>Widening and upcasting are synonyms.</li><li>Widening and narrowing have nothing in common with upcasting and downcasting.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li><strong class="source-inline">Array</strong> is an object.</li><li><strong class="source-inline">Array</strong> has a length that is a number of the elements it can hold.</li><li>The first element of an array has the index 1.</li><li>The second element of an array has the index 1.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li><strong class="source-inline">Enum</strong> contains constants.</li><li><strong class="source-inline">Enum</strong> always has a constructor, either default or explicit.</li><li>An <strong class="source-inline">enum</strong> constant can have properties.</li><li><strong class="source-inline">Enum</strong> can have constants of any reference type.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Any reference type passed in as a parameter can be modified.</li><li>A <strong class="source-inline">new String()</strong> object passed in as a parameter can be modified.</li><li>An object reference value passed in as a parameter cannot be modified.</li><li>An array passed in as a parameter can have elements assigned to different values.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Reserved keywords cannot be used.</li><li>Restricted keywords cannot be used as identifiers.</li><li>A reserved <strong class="source-inline">identifier</strong> keyword cannot be used as an identifier.</li><li>A reserved keyword cannot be used as an identifier.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>The <strong class="source-inline">this</strong> keyword refers to the <strong class="source-inline">current</strong> class.</li><li>The <strong class="source-inline">super</strong> keyword refers to the <strong class="source-inline">super</strong> class.</li><li>The <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords refer to objects.</li><li>The <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords refer to methods.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>The widening of a primitive type makes the value bigger.</li><li>The narrowing of a primitive type always changes the type of the value.</li><li>The widening of a primitive type can be done only after narrowing a conversion.</li><li>Narrowing makes the value smaller.</li></ol></li>
				<li>Select all the statements that are correct:<ol><li>Boxing puts a limit on the value.</li><li>Unboxing creates a new value.</li><li>Boxing creates a reference-type object.</li><li>Unboxing deletes a reference-type object.</li></ol></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer039">
			</div>
		</div>
	</body></html>