<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer077">
<h1 class="chapter-number" id="_idParaDest-191"><a id="_idTextAnchor295"/>9</h1>
<h1 id="_idParaDest-192"><a id="_idTextAnchor296"/>Opening up to OAuth 2</h1>
<p><strong class="bold">OAuth 2</strong> is <a id="_idIndexMarker592"/>a very popular form of trusted identity management that allows users to manage their identity through a single trusted provider. This convenient feature provides users with the security of storing their password and personal information with the trusted OAuth 2 provider, optionally disclosing personal information upon request. Additionally, an OAuth 2-enabled website offers the confidence that the users providing OAuth 2 credentials are who they say <span class="No-Break">they are.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Learning how to set up your own OAuth 2 application in less than <span class="No-Break">5 minutes</span></li>
<li>Configuring the <strong class="source-inline">JBCP calendar</strong> application with a very rapid implementation of <span class="No-Break">OAuth 2</span></li>
<li>Learning the conceptual architecture of OAuth 2 and how it provides your site with trustworthy <span class="No-Break">user access</span></li>
<li>Implementing OAuth 2-based <span class="No-Break">user registration</span></li>
<li>Experimenting with OAuth 2 attribute exchange for user <span class="No-Break">profile functionality</span></li>
<li>Configuring OAuth 2 support in <span class="No-Break"><strong class="source-inline">Spring Security</strong></span></li>
<li>Executing the OAuth 2 provider <span class="No-Break">connection workflow</span></li>
<li>Integrating OpenID Connect providers with <span class="No-Break"><strong class="source-inline">Spring Security</strong></span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/ejucD"><span class="No-Break">https://packt.link/ejucD</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor297"/>The Promising World of OAuth 2</h1>
<p>As an application developer, you may have heard the term OAuth 2 thrown around a lot. OAuth 2<a id="_idIndexMarker593"/> has been widely adopted by web service and software companies around the world and is integral to the way these companies interact and share information. But what exactly is it? In a nutshell, OAuth 2<a id="_idIndexMarker594"/> is a protocol that allows distinct parties to share information and resources in a secure and <span class="No-Break">reliable manner.</span></p>
<p class="callout-heading">What about OAuth 1.0?</p>
<p class="callout">Built with the same motivation, OAuth 1.0 <a id="_idIndexMarker595"/>was designed and ratified in 2007. However, it was criticized for being overly complex and also had issues with imprecise specifications, which led to insecure implementation. All of these issues contributed to the poor adoption of OAuth 1.0, and eventually led to the design and creation of <span class="No-Break">OAuth 2.</span></p>
<p class="callout">OAuth 2 is the successor to <span class="No-Break">OAuth 1.0.</span></p>
<p class="callout">It is also important to note that OAuth 2 is not backward compatible with OAuth 1.0, and so OAuth 2 applications cannot integrate with OAuth 1.0 <span class="No-Break">service providers.</span></p>
<p>This type of login—through a trusted third party—has been in existence for a long time, in many different forms (for example, <em class="italic">Google Identity Provider</em> or <em class="italic">Microsoft Entra ID</em> became two of the more notable central login services on the web for <span class="No-Break">some time).</span></p>
<p>Here are the key concepts and components of <span class="No-Break">OAuth 2.0:</span></p>
<p><span class="No-Break"><em class="italic">Roles</em></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="bold">Resource Owner (RO)</strong>: The<a id="_idIndexMarker596"/> entity that can grant access to a<a id="_idIndexMarker597"/> protected resource. Typically, this is <span class="No-Break">the end-user.</span></li>
<li><strong class="bold">Client</strong>: The application<a id="_idIndexMarker598"/> requesting access to the protected <a id="_idIndexMarker599"/>resource on behalf of the <span class="No-Break">resource owner.</span></li>
<li><strong class="bold">Authorization Server (AS)</strong>: The server<a id="_idIndexMarker600"/> that authenticates the<a id="_idIndexMarker601"/> resource owner and issues access tokens after getting <span class="No-Break">proper authorization.</span></li>
<li><strong class="bold">Resource Server (RS)</strong>: The<a id="_idIndexMarker602"/> server hosting the protected resources <a id="_idIndexMarker603"/>that are <span class="No-Break">being accessed.</span></li>
</ul>
<p><span class="No-Break"><em class="italic">Authorization Grant</em></span><span class="No-Break">:</span></p>
<ul>
<li>OAuth 2.0 defines several <a id="_idIndexMarker604"/>authorization grant<a id="_idIndexMarker605"/> types, such as Authorization Code, Implicit, Resource Owner Password Credentials, and Client Credentials. The grant type determines the flow and the way the client obtains the <span class="No-Break">access token.</span></li>
</ul>
<p><span class="No-Break"><em class="italic">Access Token</em></span><span class="No-Break">:</span></p>
<ul>
<li>The <a id="_idIndexMarker606"/>access token<a id="_idIndexMarker607"/> is a credential representing the authorization granted to the client. It is used to access protected resources on behalf of the <span class="No-Break">resource owner.</span></li>
</ul>
<p><span class="No-Break"><em class="italic">Scope</em></span><span class="No-Break">:</span></p>
<ul>
<li>Scopes<a id="_idIndexMarker608"/> define the <a id="_idIndexMarker609"/>extent of the access that a client is requesting. It specifies what actions the client intends to perform on the <span class="No-Break">resource server.</span></li>
</ul>
<p><em class="italic">Authorization Endpoint and </em><span class="No-Break"><em class="italic">Token Endpoint</em></span><span class="No-Break">:</span></p>
<ul>
<li>The <strong class="source-inline">Authorization Endpoint</strong> facilitates<a id="_idIndexMarker610"/> communication <a id="_idIndexMarker611"/>with the resource owner to secure an authorization grant, while the Token Endpoint<a id="_idIndexMarker612"/> facilitates the exchange of this <a id="_idIndexMarker613"/>grant for an <span class="No-Break">access token.</span></li>
</ul>
<p><span class="No-Break"><em class="italic">Redirect URI</em></span><span class="No-Break">:</span></p>
<ul>
<li>After the resource owner grants permission, the <strong class="source-inline">Authorization Server</strong> redirects the user back to <a id="_idIndexMarker614"/>the client application using <a id="_idIndexMarker615"/>a <span class="No-Break">redirect URI.</span></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">You can refer to the OAuth 2.0 specification<a id="_idIndexMarker616"/> <span class="No-Break">at </span><a href="https://tools.ietf.org/html/rfc6749"><span class="No-Break">https://tools.ietf.org/html/rfc6749</span></a><span class="No-Break">.</span></p>
<p>The following diagram illustrates the high-level relationship between a site integrating OAuth 2 <a id="_idIndexMarker617"/>during the login process and the Facebook OAuth 2 provider, <span class="No-Break">for</span><span class="No-Break"><a id="_idIndexMarker618"/></span><span class="No-Break"> example:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 9.1 – OAuth 2 during the login process and the Facebook OAuth 2 provider" height="847" src="image/B21757_09_01.jpg" width="1187"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – OAuth 2 during the login process and the Facebook OAuth 2 provider</p>
<p>We can see that submitting a form post will initiate a request to the OAuth provider, resulting in the provider displaying an authorization dialog asking the user to allow <strong class="source-inline">jbcpcalendar</strong> to gain permission to specific information from your OAuth provider account. This request contains a <strong class="source-inline">uri</strong> parameter called <strong class="source-inline">code</strong>. Once granted, the user is redirected back to <strong class="source-inline">jbcpcalendar</strong>, and the <strong class="source-inline">code</strong> parameter is included <span class="No-Break">in the</span></p>
<p><strong class="source-inline">uri</strong> parameter. Then, the request is redirected to the OAuth provider again, to authorize <strong class="source-inline">jbcpcalendar</strong>. The OAuth provider then responds with an <strong class="source-inline">access_token</strong> that can be used to access the user’s OAuth information that <strong class="source-inline">jbcpcalend<a id="_idTextAnchor298"/>ar</strong> was granted <span class="No-Break">access to.</span></p>
<p class="callout-heading">Don’t trust OAuth 2 unequivocally!</p>
<p class="callout">Here, you can see a fundamental assumption that can fool users of the system. It is possible for us to sign up for an OAuth 2 provider account, which would make it appear as though we were James Gosling, even though we obviously are not. Do not make the false assumption that just because a user has a convincing-sounding OAuth 2 (or OAuth 2 delegate provider), they are who they say they are without requiring additional forms of identification. Thinking about it another way, if someone came to your door just claiming he was James Gosling, would you let him in without verifying <span class="No-Break">his ID?</span></p>
<p>The OAuth 2-enabled application then redirects the user to the OAuth 2 provider, and the user presents their credentials to the provider, which is then responsible for making an access decision. Once the access decision has been made by the provider, the provider redirects the user to the originating site, which is now assured of the user’s authenticity. OAuth 2 is much easier to understand once you have tried it. Let’s add OAu<a id="_idTextAnchor299"/>th 2 to the <strong class="source-inline">JBCP calendar</strong> login <span class="No-Break">screen now!</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor300"/>Why do we need OpenID Connect?</h2>
<p><strong class="bold">OpenID Connect</strong> is an<a id="_idIndexMarker619"/> authentication protocol designed for interoperability and built upon the OAuth 2.0 framework specifications <strong class="source-inline">RFC 6749</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc6749">https://datatracker.ietf.org/doc/html/rfc6749</a>) and <strong class="source-inline">RFC 6750</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc6750">https://datatracker.ietf.org/doc/html/rfc6750</a>). Its primary goal is to streamline the process of verifying user identity through authentication performed by an <strong class="source-inline">Authorization Server</strong>, allowing for the retrieval of user profile information in a manner that is both interoperable and akin to <span class="No-Break">REST principles.</span></p>
<p>This protocol empowers developers of applications and websites to initiate sign-in processes and receive credible assertions regarding users, ensuring consistency across various platforms, including web-based, mobile, and JavaScript clients. The specification suite is adaptable, supporting a variety of optional features such as the encryption of identity data, discovery of <strong class="source-inline">OpenID Providers</strong>, and <span class="No-Break">session logout.</span></p>
<p>For developers, OpenID Connect offers a secure and verifiable means of answering the crucial question: “Who is the individual presently using the connected browser or mobile app?” Notably, it alleviates the burden of handling passwords—typically associated with data breaches—by removing the need to set, store, and <span class="No-Break">manage them.</span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor301"/>How OpenID Connect Works</h2>
<p>OpenID Connect facilitates<a id="_idIndexMarker620"/> the establishment of an Internet identity ecosystem by offering seamless integration, robust support, security, and privacy-preserving configuration. It emphasizes interoperability, extends support to a broad array of clients and <a id="_idIndexMarker621"/>devices, and allows any entity to function as an <strong class="bold">OpenID </strong><span class="No-Break"><strong class="bold">Provider</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OP</strong></span><span class="No-Break">).</span></p>
<p>Here are the key concepts and components of <span class="No-Break"><strong class="source-inline">OpenID Connect</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="bold">RP</strong>, short <strong class="bold">for Relying Party</strong>, refers<a id="_idIndexMarker622"/> to an application or website that <a id="_idIndexMarker623"/>delegates its user authentication function to an <strong class="bold">Identity </strong><span class="No-Break"><strong class="bold">Provider</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IDP</strong></span><span class="No-Break">).</span></li>
<li><strong class="bold">OP</strong> or <strong class="bold">IDP</strong>: An OP is an<a id="_idIndexMarker624"/> entity that has implemented<a id="_idIndexMarker625"/> the OpenID Connect and OAuth 2.0 protocols. Sometimes, OPs <a id="_idIndexMarker626"/>are denoted by the role they fulfill, such as <a id="_idIndexMarker627"/>a <strong class="bold">Security Token Service</strong> (<strong class="bold">STS</strong>), <strong class="bold">IDP</strong>, or <a id="_idIndexMarker628"/>an <span class="No-Break"><strong class="bold">Suthorization Server(AS)</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Identity Token</strong>: Serving as the outcome of an authentication process, an <a id="_idIndexMarker629"/>identity token<a id="_idIndexMarker630"/> includes, at a minimum, a user identifier (referred to as the <em class="italic">sub</em> or subject claim) and details about when and how the user authenticated. Additional identity data may also <span class="No-Break">be included.</span></li>
<li><strong class="bold">Client</strong>: A client<a id="_idIndexMarker631"/> is software that requests tokens, either for user authentication or<a id="_idIndexMarker632"/> resource access (<strong class="bold">RP</strong>). Clients need to be registered with the OP and can take various forms, such as web applications, native mobile and desktop <span class="No-Break">applications, etc.</span></li>
<li><strong class="bold">User</strong>: A user<a id="_idIndexMarker633"/> is an individual<a id="_idIndexMarker634"/> leveraging a registered client to <span class="No-Break">access resources.</span></li>
</ul>
<p>After highlighting the OpenID Connect principles as a protocol built on top of the OAuth 2 protocol, we will be learning how to set up OAuth 2 in our <strong class="source-inline">JBCP Calendar</strong> application using some <span class="No-Break">popular providers.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor302"/>Signing up for an OAuth 2 application</h2>
<p>To get the full value out of the<a id="_idIndexMarker635"/> exercise in this section (and be able to test logging in), you will need to create an application with a service provider. Currently, Spring Social supports Twitter, Facebook, Google, LinkedIn, and GitHub, and the list <span class="No-Break">is growing.</span></p>
<p>To get the full value out of the exercises in this chapter, we recommend you have accounts with at least Google. We have set up accounts for the <strong class="source-inline">jbcpcalendar</strong> application, which we will be using for the remainder of <span class="No-Break">this chapter.</span></p>
<p>Include the following additional dependencies in your <strong class="source-inline">build.gradle</strong> file if you are leveraging the <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> feature:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
    // OAuth2 Configuration:
    implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
...
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">You should start with the source code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.00-calendar</strong></span><span class="No-Break">.</span></p>
<p>In addition to the <strong class="source-inline">Spring Security OAuth 2</strong> dependencies, we will now explore the <strong class="bold">OAuth 2</strong> setup in the <strong class="source-inline">JBCP </strong><span class="No-Break"><strong class="source-inline">Calendar</strong></span><span class="No-Break"> application.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor303"/>Enabling OAuth 2.0 Login with Spring Security</h2>
<p>We can see a common theme among the external authentication providers examined over the next several chapters. <strong class="source-inline">Spring Security</strong> provides comprehensive OAuth 2 support. This section discusses how to integrate OAuth 2 into your <span class="No-Break">servlet-based application.</span></p>
<p>The <strong class="source-inline">OAuth 2.0 Login</strong> feature <a id="_idIndexMarker636"/>lets an application have users log in to the application by using their existing account with an OAuth 2.0 Provider (such as GitHub) or <strong class="source-inline">OpenID Connect 1.0 Provider </strong>(such <span class="No-Break">as Google).</span></p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="source-inline">OAuth 2.0 Login</strong> is implemented by using the <strong class="source-inline">Authorization Code Grant</strong>, as specified in the <strong class="source-inline">OAuth 2.0 Authorization Framework</strong>, which you can find here: <a href="https://tools.ietf.org/html/rfc6749#section-4.1">https://tools.ietf.org/html/rfc6749#section-4.1</a> and <strong class="source-inline">OpenID Connect Core 1.0</strong>, found <span class="No-Break">here: </span><a href="https://openid.net/specs/openid-connect-core-1_0.xhtml#CodeFlowAuth"><span class="No-Break">https://openid.net/specs/openid-connect-core-1_0.xhtml#CodeFlowAuth</span></a><span class="No-Break">.</span></p>
<h3>Initial Setup</h3>
<p>This section shows <a id="_idIndexMarker637"/>how to configure the <strong class="source-inline">OAuth 2.0 Login</strong> sample by using Google as the <strong class="source-inline">Authentication Provider</strong> and covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Follow the instructions on the OpenID Connect page here: <a href="https://developers.google.com/identity/openid-connect/openid-connect">https://developers.google.com/identity/openid-connect/openid-connect</a>, starting in the <em class="italic">Setting up OAuth </em><span class="No-Break"><em class="italic">2.0</em></span><span class="No-Break"> section.</span></li>
<li>After completing the <strong class="source-inline">Obtain OAuth 2.0 credentials</strong> instructions, you should have a new <strong class="source-inline">OAuth Client</strong> with credentials consisting of a <strong class="bold">Client ID</strong> and a <span class="No-Break"><strong class="bold">Client Secret</strong></span><span class="No-Break">.</span></li>
</ul>
<p>This setup is important to configure our application as an <strong class="bold">OAuth </strong><span class="No-Break"><strong class="bold">2</strong></span><span class="No-Break"> client.</span></p>
<h3>Setting the Redirect URI</h3>
<p>The redirect URI<a id="_idIndexMarker638"/> is the path in the application that the end-user’s user-agent is redirected back to after they have authenticated with Google and have granted access to the <strong class="source-inline">OAuth Client</strong> (created in the previous step) on the <span class="No-Break"><strong class="bold">Consent</strong></span><span class="No-Break"> page.</span></p>
<p>In this subsection, ensure that the Authorized redirect URIs field is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">https://localhost:8443/login/oauth2/code/google</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">The default redirect URI template is <strong class="source-inline">{baseUrl}/login/oauth2/code/{registrationId}</strong>. The <strong class="source-inline">registrationId</strong> is a unique identifier for <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ClientRegistration</strong></span><span class="No-Break">.</span></p>
<p class="callout">If the <strong class="source-inline">OAuth Client</strong> runs behind a proxy server, you should check the proxy server configuration (follow this link: <a href="https://docs.spring.io/spring-security/reference/features/exploits/http.xhtml#http-proxy-server">https://docs.spring.io/spring-security/reference/features/exploits/http.xhtml#http-proxy-server</a>) to ensure the application is correctly configured. Also, see the supported URI template variables here: <a href="https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorization-grants.xhtml#oauth2Client-auth-code-redirect-uri">https://docs.spring.io/spring-security/reference/servlet/oauth2/client/authorization-grants.xhtml#oauth2Client-auth-code-redirect-uri</a> <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">redirect-uri</strong></span><span class="No-Break">.</span></p>
<p>Once the redirect URI is established, we will proceed to set up the <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> configuration.</span></p>
<h3>Configure application.yml</h3>
<p>Now that you <a id="_idIndexMarker639"/>have a new <strong class="source-inline">OAuth Client</strong> with Google, you need to configure the application to use the <strong class="source-inline">OAuth Client</strong> for the authentication flow. To do so, go to <strong class="source-inline">application.yml</strong> and set the <span class="No-Break">following configuration:</span></p>
<pre class="source-code">
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret</pre> <p>We have configured here the following <span class="No-Break">client properties:</span></p>
<ul>
<li><strong class="source-inline">spring.security.oauth2.client.registration</strong> is the base property prefix for <strong class="source-inline">OAuth </strong><span class="No-Break"><strong class="source-inline">Client</strong></span><span class="No-Break"> properties.</span></li>
<li>Following the base property prefix is the ID for the <strong class="source-inline">ClientRegistration</strong>, such <span class="No-Break">as Google.</span></li>
</ul>
<p>After configuring the OAuth 2 client properties, we need to register a <span class="No-Break"><strong class="source-inline">SecurityFilterChain</strong></span><span class="No-Break"> bean.</span></p>
<h3>Register a SecurityFilterChain Bean</h3>
<p>The following example <a id="_idIndexMarker640"/>shows how to register a <strong class="source-inline">SecurityFilterChain</strong> bean with <strong class="source-inline">@EnableWebSecurity</strong> and enable <strong class="source-inline">OAuth 2.0 login</strong> <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">httpSecurity.oauth2Login()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, PersistentTokenRepository persistentTokenRepository) throws Exception {
       http.authorizeRequests( authz -&gt; authz
                    .requestMatchers(antMatcher("/webjars/**")).permitAll()
                    .requestMatchers(antMatcher("/css/**")).permitAll()
                    .requestMatchers(antMatcher("/favicon.ico")).permitAll()
                    // H2 console:
                    .requestMatchers(antMatcher("/admin/h2/**")).access("isFullyAuthenticated()")
                    .requestMatchers(antMatcher("/")).permitAll()
                    .requestMatchers(antMatcher("/login/*")).permitAll()
                    .requestMatchers(antMatcher("/logout")).permitAll()
                    .requestMatchers(antMatcher("/signup/*")).permitAll()
                    .requestMatchers(antMatcher("/errors/**")).permitAll()
                    .requestMatchers(antMatcher("/events/")).hasRole("ADMIN")
                    .requestMatchers(antMatcher("/**")).hasAnyAuthority("OIDC_USER", "OAUTH2_USER", "ROLE_USER"))
              .exceptionHandling(exceptions -&gt; exceptions
                    .accessDeniedPage("/errors/403"))
              .formLogin(form -&gt; form
                    .loginPage("/login/form")
                    .loginProcessingUrl("/login")
                    .failureUrl("/login/form?error")
                    .usernameParameter("username")
                    .passwordParameter("password")
                    .defaultSuccessUrl("/default", true)
                    .permitAll())
              .logout(form -&gt; form
                    .logoutUrl("/logout")
                    .logoutSuccessUrl("/login/form?logout")
                    .permitAll())
              // CSRF is enabled by default, with Java Config
              .csrf(AbstractHttpConfigurer::disable);
        // OAuth2 Config
        http
              .oauth2Login(withDefaults());
        // For H2 Console
        http.headers(headers -&gt; headers.frameOptions(FrameOptionsConfig::disable));
        return http.build();
    }
... Omitted for brevity
}</pre> <p>The next step<a id="_idIndexMarker641"/> after configuring the <strong class="source-inline">SecurityFilterChain</strong> bean is to update the <span class="No-Break"><strong class="source-inline">SpringSecurityUserContext</strong></span><span class="No-Break"> class.</span></p>
<h3>Update the SpringSecurityUserContext class</h3>
<p>The <strong class="source-inline">getCurrentUser</strong> in the <strong class="source-inline">SpringSecurityUserContext</strong> needs to reference the new<a id="_idIndexMarker642"/> authenticated user of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">DefaultOidcUser</strong></span><span class="No-Break">.</span></p>
<p>The following example shows how to adapt the current implementation to reference the <strong class="source-inline">DefaultOidcUser</strong> <span class="No-Break">user type:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/service/ SpringSecurityUserContext.java
@Component
public class SpringSecurityUserContext implements UserContext {
    private static final Logger logger = LoggerFactory
            .getLogger(SpringSecurityUserContext.class);
    private final CalendarService calendarService;
    public SpringSecurityUserContext(final CalendarService calendarService) {
      this.calendarService = calendarService;
    }
    @Override
    public CalendarUser getCurrentUser() {
       SecurityContext context = SecurityContextHolder.getContext();
       Authentication authentication = context.getAuthentication();
       if (authentication == null) {
          return null;
       }
       String email;
       if(authentication.getPrincipal() instanceof DefaultOidcUser oidcUser ) {
          email = oidcUser.getEmail();
       } else if (authentication.getPrincipal() instanceof DefaultOAuth2User oauth2User) {
          email = oauth2User.getAttribute("email");
       } else {
          User user = (User) authentication.getPrincipal();
          email = user.getUsername();
       }
       if (email == null) {
          return null;
       }
       CalendarUser result = calendarService.findUserByEmail(email);
       if (result == null) {
          throw new IllegalStateException(
                "Spring Security is not in synch with CalendarUsers. Could not find user with email " + email);
       }
       logger.info("CalendarUser: {}", result);
       return result;
    }
}</pre> <p>After completing the previous steps, we will test <span class="No-Break">the application.</span></p>
<h3>Boot up the Application</h3>
<ol>
<li>Launch the <a id="_idIndexMarker643"/>sample application and go to <strong class="source-inline">https://localhost:8443/oauth2/authorization/google</strong>. You will be redirected to the default login page, which displays a link <span class="No-Break">for Google.</span></li>
<li>Click on the Google link, and you are then redirected to Google <span class="No-Break">for authentication.</span></li>
<li>The <strong class="source-inline">OAuth Client</strong> retrieves your email address and basic profile information from the <strong class="source-inline">UserInfo Endpoint</strong> (find out more here: https://openid.net/specs/openid-connect-core-1_0.xhtml#UserInfo) and establishes an <span class="No-Break">authenticated session.</span></li>
<li>At this point, you<a id="_idIndexMarker644"/> should be able to complete a full login using the Google OAuth 2 provider. The redirects that occur are as follows. First, we initiate the OAuth 2 provider login as shown in the <span class="No-Break">following screenshot:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 9.2 – OAuth 2 Social login with Google" height="569" src="image/B21757_09_02.jpg" width="628"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – OAuth 2 Social login with Google</p>
<ol>
<li value="5">After filling in the login details, the user is redirected to the <strong class="source-inline">JBCP Calendar</strong> application and automatically logged in using the provider <span class="No-Break">display name:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 9.3 – Welcome page after successful authentication" height="773" src="image/B21757_09_03.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Welcome page after successful authentication</p>
<p>At this point, the user exists <a id="_idIndexMarker645"/>in the application and is authenticated but not authorized on all the web pages. The page <strong class="source-inline">Create Event</strong> can only be accessed by <span class="No-Break">authenticated users.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.01-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor304"/>Customize the Login Page</h2>
<p>By default, the OAuth 2.0 login page<a id="_idIndexMarker646"/> is auto-generated by the <strong class="source-inline">DefaultLoginPageGeneratingFilter</strong>. The default login page shows each configured <strong class="source-inline">OAuth Client</strong> with its <strong class="source-inline">ClientRegistration.clientName</strong> as a link, which is capable of initiating the <strong class="source-inline">Authorization Request</strong> (or OAuth <span class="No-Break">2.0 Login).</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">For <strong class="source-inline">DefaultLoginPageGeneratingFilter</strong> to show links for configured <strong class="source-inline">OAuth Clients</strong>, the registered <strong class="source-inline">ClientRegistrationRepository</strong> needs to also implement <strong class="source-inline">Iterable&lt;ClientRegistration&gt;</strong>. See <strong class="source-inline">InMemoryClientRegistrationRepository</strong> <span class="No-Break">for reference.</span></p>
<p>The link’s destination for each <strong class="source-inline">OAuth Client</strong> defaults to <span class="No-Break">the following:</span></p>
<pre class="source-code">
OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + "/{registrationId}"</pre> <p>The following <a id="_idIndexMarker647"/>code shows an example of adapting the <span class="No-Break"><strong class="source-inline">login.xhtml</strong></span><span class="No-Break"> form:</span></p>
<pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div class="mb-3"&gt;
    &lt;legend&gt;Login With Google&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-danger"
           role="button" th:href="@{/oauth2/authorization/google}"&gt;Login with Google&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre> <p>Now, you can use the login social button to authenticate your users with Google as an <span class="No-Break"><strong class="source-inline">Identity Provider</strong></span><span class="No-Break">.</span></p>
<p>We need also to make sure the user is redirected to the <strong class="source-inline">jbcpcalendar</strong> application and automatically logged in. The following example shows how to adapt a <strong class="source-inline">SecurityConfig.java</strong> to have a proper redirection after <span class="No-Break">successful authentication:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, GrantedAuthoritiesMapper grantedAuthoritiesMapper) throws Exception {
... omitted for brevity
        // OAuth2 Login
        http
                .oauth2Login(oauth2 -&gt; oauth2
                        .loginPage("/login/form")
                        .defaultSuccessUrl("/default", true));
        return http.build();
    }
}</pre> <p>At this point, you should be able to complete a full login using Google’s OAuth 2 provider. The redirects that occur are as follows. First, we initiate the OAuth 2 <span class="No-Break">provider login.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 9.4 – Login screen after successful authentication" height="146" src="image/B21757_09_04.jpg" width="894"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Login screen after successful authentication</p>
<p>We are then <a id="_idIndexMarker648"/>redirected to the <strong class="bold">provider authorization</strong> page, requesting the user to grant permission to the <strong class="source-inline">JBCP </strong><span class="No-Break"><strong class="source-inline">Calendar</strong></span><span class="No-Break"> application.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.02-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor305"/>Additional OAuth 2 providers</h1>
<p>We have <a id="_idIndexMarker649"/>successfully integrated a single OAuth 2 provider using one of the popular OAuth 2 providers. There are several other providers available; we are going to add a few more providers so our users have more than one option. <strong class="source-inline">Spring Security</strong> currently supports the <strong class="bold">Google</strong>, <strong class="bold">GitHub</strong>, <strong class="bold">Facebook</strong>, and <strong class="bold">Okta</strong> providers natively. Including additional providers will require configuring custom <span class="No-Break">provider properties.</span></p>
<p><strong class="source-inline">CommonOAuth2Provider</strong> pre-defines a set of default client properties for a number of well-known providers that <strong class="source-inline">Spring Security</strong> supports natively, as <span class="No-Break">mentioned previously.</span></p>
<p>For example, the <strong class="source-inline">authorization-uri</strong>, <strong class="source-inline">token-uri</strong>, and <strong class="source-inline">user-info-uri</strong> do not change often for a provider. Therefore, it makes sense to provide default values, to reduce the <span class="No-Break">required configuration.</span></p>
<p>As demonstrated previously when we configured a Google client, only the <strong class="source-inline">client-id</strong> and <strong class="source-inline">client-secret</strong> properties <span class="No-Break">are required.</span></p>
<p>In order to add GitHub providers to the <strong class="source-inline">JBCP </strong><span class="No-Break"><strong class="source-inline">calendar</strong></span><span class="No-Break"> application:</span></p>
<ol>
<li>Register your application in GitHub by following the steps given here: <a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app">https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app</a>. At the end, save the <strong class="source-inline">client-id</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">client-secret</strong></span><span class="No-Break">.</span><p class="list-inset">The <strong class="bold">authorization callback URL</strong> should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">https://localhost:8443/login/oauth2/code/github</strong></span><span class="No-Break">.</span></p></li>
<li>Additional application properties need to be set, and each configured provider will automatically be registered with the <strong class="source-inline">client-id</strong> and <strong class="source-inline">client-secret</strong> keys from the provider application, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/resources/application.yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret
          github:
            client-id: github-client-id
            client-secret: github -client-secret</pre></li> <li>We can now add the new login<a id="_idIndexMarker650"/> options to our <strong class="source-inline">login.xhtml</strong> file to include the new <span class="No-Break">provider </span><span class="No-Break"><strong class="source-inline">GitHub</strong></span><span class="No-Break">:</span><pre class="source-code">
//src/main/resources/templates/login.xhtml
&lt;div class="mb-3"&gt;
    &lt;legend&gt;Login With Google&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-danger"
           role="button" th:href="@{/oauth2/authorization/google}"&gt;Login with Google&lt;/a&gt;
    &lt;/div&gt;
    &lt;legend&gt;Login With Github&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-dark"
           role="button" th:href="@{/oauth2/authorization/github}"&gt;Login with Github&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre></li> <li>Now we have the required details to connect to the additional providers for the JBCP calendar, and we can restart the <strong class="source-inline">JBCP calendar</strong> application and test logging in with the other OAuth <span class="No-Break">2 providers.</span></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.03-calendar</strong></span><span class="No-Break">.</span></p>
<p class="list-inset">When logging in now, we should be presented with additional provider options, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 9.5 – Social login options with Google and GitHub" height="252" src="image/B21757_09_05.jpg" width="847"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Social login options with Google and GitHub</p>
<p class="list-inset">At this point, you<a id="_idIndexMarker651"/> should be able to complete a full login using the Google OAuth 2 provider. The redirects that occur are as follows. First, we initiate the OAuth 2 provider login as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 9.6 – OAuth 2 social login with GitHub" height="411" src="image/B21757_09_06.jpg" width="315"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – OAuth 2 social login with GitHub</p>
<ol>
<li value="5">We are then<a id="_idIndexMarker652"/> redirected to the provider authorization page, requesting the user to grant permission to the <strong class="source-inline">jbcpcalendar</strong> application as shown in the <span class="No-Break">following screenshot:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 9.7 – OAuth 2 GitHub consent screen" height="497" src="image/B21757_09_07.jpg" width="508"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – OAuth 2 GitHub consent screen</p>
<p>After authorizing the <strong class="source-inline">jbcpcalendar</strong> application, the user is redirected to the <strong class="source-inline">jbcpcalendar</strong> application and automatically logged in using the provider <span class="No-Break">display name.</span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor306"/>Configuring Custom Provider Properties</h2>
<p>There are some <a id="_idIndexMarker653"/>OAuth 2.0 Providers that support multi-tenancy, which results in different protocol endpoints for each tenant (<span class="No-Break">or sub-domain).</span></p>
<p>For example, an <strong class="source-inline">OAuth Client</strong> registered with <strong class="source-inline">OKTA</strong> is assigned to a specific sub-domain and has its own <span class="No-Break">protocol endpoints.</span></p>
<p>To get started, you’ll require<a id="_idIndexMarker654"/> an <strong class="bold">Okta developer account</strong>. You can set one up by <span class="No-Break">visiting </span><a href="https://developer.okta.com/signup"><span class="No-Break">https://developer.okta.com/signup</span></a><span class="No-Break">.</span></p>
<p>For these <a id="_idIndexMarker655"/>cases, <strong class="source-inline">Spring Boot 2.x</strong> provides the following base property for configuring custom provider <span class="No-Break">properties: </span><span class="No-Break"><strong class="source-inline">spring.security.oauth2.client.provider.[providerId]</strong></span><span class="No-Break">.</span></p>
<p>The following code snippet shows <span class="No-Break">an example:</span></p>
<pre class="source-code">
security:
  oauth2:
    client:
      registration:
        okta:
          client-id: okta-client-id
          client-secret: okta-client-secret
          scope: openid,profile,email
      provider:
        okta:
          issuer-uri: https://your-subdomain.okta.com
          authorization-uri: https://your-subdomain.okta.com/oauth2/v1/authorize
          token-uri: https://your-subdomain.okta.com/oauth2/v1/token
          user-info-uri: https://your-subdomain.okta.com/oauth2/v1/userinfo
          user-name-attribute: sub
          jwk-set-uri: https://your-subdomain.okta.com/oauth2/v1/keys</pre> <p>The base property (<strong class="source-inline">spring.security.oauth2.client.provider.okta</strong>) allows for the custom configuration of protocol <span class="No-Break">endpoint locations.</span></p>
<p>We can now add the new login options to our <strong class="source-inline">login.xhtml</strong> file, to include with the new <span class="No-Break"><strong class="source-inline">OKTA</strong></span><span class="No-Break"> provider:</span></p>
<pre class="source-code">
//src/main/resources/templates/login.xhtml
... omitted for brevity
&lt;div class="mb-3"&gt;
    &lt;legend&gt;Login With Google&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-danger"
           role="button" th:href="@{/oauth2/authorization/google}"&gt;Login with Google&lt;/a&gt;
    &lt;/div&gt;
    &lt;legend&gt;Login With Github&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-dark"
           role="button" th:href="@{/oauth2/authorization/github}"&gt;Login with Github&lt;/a&gt;
    &lt;/div&gt;
    &lt;legend&gt;Login With OKTA&lt;/legend&gt;
    &lt;div class="mb-3"&gt;
        &lt;a class="btn btn-success"
           role="button" th:href="@{/oauth2/authorization/okta}"&gt;Login with OKTA&lt;/a&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre> <p>Now we have the<a id="_idIndexMarker656"/> required details to connect to the additional providers for the JBCP calendar, and we can restart the <strong class="source-inline">JBCP calendar</strong> application and test logging in with the custom OAuth 2 <span class="No-Break"><strong class="source-inline">OKTA</strong></span><span class="No-Break"> providers.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.04-calendar</strong></span><span class="No-Break">.</span></p>
<p>When<a id="_idIndexMarker657"/> logging in now, we should be presented with additional provider options, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 9.8 – Social login options with Google, GitHub, and OKTA" height="347" src="image/B21757_09_08.jpg" width="892"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Social login options with Google, GitHub, and OKTA</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor307"/>Enabling Proof Key for Code Exchange (PKCE) support</h2>
<p><strong class="bold">PKCE</strong> stands <a id="_idIndexMarker658"/>for <strong class="bold">Proof Key for Code Exchange</strong>. It is a security feature used in OAuth 2.0 authorization<a id="_idIndexMarker659"/> flows to mitigate certain types of attacks, particularly those targeting the authorization <span class="No-Break">code flow.</span></p>
<p>The traditional OAuth 2.0 authorization code flow, a client application redirects a user to an <strong class="source-inline">Authorization Server</strong>, the user authenticates and provides consent, and the <strong class="source-inline">Authorization Server</strong> issues an authorization code to the client. The client then exchanges this code for an <span class="No-Break">access token.</span></p>
<p>PKCE is designed to prevent authorization code interception attacks. In these attacks, a malicious actor intercepts the authorization code as it’s being returned to the client, and then uses it to obtain an access token. PKCE adds an additional layer of security to <span class="No-Break">this process.</span></p>
<p>The following sequence diagram describes how <span class="No-Break">PKCE works:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 9.9 – Social login options with Google, GitHub, and OKTA" height="607" src="image/B21757_09_09.jpg" width="1142"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Social login options with Google, GitHub, and OKTA</p>
<p>Public <a id="_idIndexMarker660"/>clients receive support through the utilization of PKCE. For further information on PKCE, refer to this link: <a href="https://datatracker.ietf.org/doc/html/rfc7636">https://datatracker.ietf.org/doc/html/rfc7636</a>. PKCE is automatically employed when the client operates in an untrusted environment (e.g., native or web browser-based applications), rendering it unable to uphold the secrecy of its credentials when the following conditions <span class="No-Break">are true:</span></p>
<ul>
<li><strong class="source-inline">client-secret</strong> is omitted (<span class="No-Break">or empty)</span></li>
<li><strong class="source-inline">client-authentication-method</strong> is set to <span class="No-Break"><strong class="bold">none</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">ClientAuthenticationMethod.NONE</strong></span><span class="No-Break">)</span></li>
</ul>
<p>If the OAuth 2.0 Provider supports PKCE for confidential clients (find out more about confidential clients: <a href="https://datatracker.ietf.org/doc/html/rfc6749#section-2.1">https://datatracker.ietf.org/doc/html/rfc6749#section-2.1</a>), you may (optionally) configure it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">DefaultServerOAuth2AuthorizationRequestResolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce()</strong></span><span class="No-Break">.</span></p>
<p>The following example shows how to adapt a <strong class="source-inline">SecurityConfig.java</strong> to use PKCE by registering your <span class="No-Break">own </span><span class="No-Break"><strong class="source-inline">OAuth2AuthorizationRequestResolver</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, OAuth2AuthorizationRequestResolver pkceResolver) throws Exception {
... omitted for brevity
        // OAuth2 Login
        http
                .oauth2Login(oauth2 -&gt; oauth2
                        .loginPage("/login/form")
                        .authorizationEndpoint(authorization -&gt; authorization.authorizationRequestResolver(pkceResolver))
                        .defaultSuccessUrl("/default", true)
                .userInfoEndpoint(userInfo -&gt; userInfo
                        .userAuthoritiesMapper(grantedAuthoritiesMapper)));
        return http.build();
    }
    @Bean
    public OAuth2AuthorizationRequestResolver pkceResolver(ClientRegistrationRepository clientRegistrationRepository) {
       DefaultOAuth2AuthorizationRequestResolver resolver = new DefaultOAuth2AuthorizationRequestResolver(clientRegistrationRepository, OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI);
       resolver.setAuthorizationRequestCustomizer(OAuth2AuthorizationRequestCustomizers.withPkce());
       return resolver;
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.05-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor308"/>OpenID Connect 1.0 Logout</h2>
<p><strong class="bold">OpenID Connect Session Management 1.0</strong> provides<a id="_idIndexMarker661"/> the capability to<a id="_idIndexMarker662"/> log out the end user through the <strong class="bold">Provider</strong> with the use of the <strong class="bold">Client</strong>. One available approach is the <strong class="source-inline">RP-Initiated Logout</strong>, detailed <span class="No-Break">at </span><a href="https://openid.net/specs/openid-connect-rpinitiated-1_0.xhtml"><span class="No-Break">https://openid.net/specs/openid-connect-rpinitiated-1_0.xhtml</span></a><span class="No-Break">.</span></p>
<p>In cases where the <strong class="source-inline">OpenID Provider</strong> supports both <strong class="bold">Session Management</strong> and <strong class="bold">Discovery</strong> (refer to <a href="https://openid.net/specs/openid-connect-discovery-1_0.xhtml">https://openid.net/specs/openid-connect-discovery-1_0.xhtml</a> for more information), the client can acquire the <strong class="source-inline">end_session_endpoint</strong> URL from the <em class="italic">OpenID Provider’s Discovery Metadata</em>. You can achieve this by configuring the <strong class="source-inline">ClientRegistration</strong> with the <strong class="source-inline">issuer-uri</strong>, as outlined <span class="No-Break">in </span><a href="https://openid.net/specs/openid-connect-session-1_0.xhtml#OPMetadata"><span class="No-Break">https://openid.net/specs/openid-connect-session-1_0.xhtml#OPMetadata</span></a><span class="No-Break">:</span></p>
<pre class="source-code">
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            ...
        provider:
          okta:
            issuer-uri: https://dev-1234.oktapreview.com</pre> <p>Also, you can <a id="_idIndexMarker663"/>configure <strong class="source-inline">OidcClientInitiatedLogoutSuccessHandler</strong>, which implements RP-Initiated Logout, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    private ClientRegistrationRepository clientRegistrationRepository;
    public SecurityConfig(ClientRegistrationRepository clientRegistrationRepository) {
       this.clientRegistrationRepository = clientRegistrationRepository;
    }
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, OAuth2AuthorizationRequestResolver pkceResolver) throws Exception {
       http.authorizeRequests(authz -&gt; authz
... omitted for brevity
       // OAuth2 Login
       http
             .oauth2Login(oauth2 -&gt; oauth2
                   .loginPage("/login/form")
                   .authorizationEndpoint(authorization -&gt; authorization.authorizationRequestResolver(pkceResolver))
                   .defaultSuccessUrl("/default", true))
             .logout(logout -&gt; logout
                   .logoutSuccessHandler(oidcLogoutSuccessHandler()));
       return http.build();
    }
    private LogoutSuccessHandler oidcLogoutSuccessHandler() {
       OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler =
             new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository);
       // Sets the location that the End-User's User Agent will be redirected to
       // after the logout has been performed at the Provider
       oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}");
       return oidcLogoutSuccessHandler;
    }
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.06-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor309"/>Automatic User Registration</h2>
<p>Many applications need to <a id="_idIndexMarker664"/>hold data about their users locally, even if authentication is delegated to an external provider. This can be done in <span class="No-Break">two steps:</span></p>
<ol>
<li>Choose a backend for your database, and set up some repositories (using Spring Data, say) for a custom <strong class="source-inline">User</strong> object that suits your needs and can be populated, fully or partially, from external authentication. For our <strong class="source-inline">JBCP Calendar</strong> application, we will adapt <strong class="source-inline">CalendarUser</strong> to add the provider information <span class="No-Break">as follows:</span><pre class="source-code">
@Entity
@Table(name = "calendar_users")
public class CalendarUser implements Principal, Serializable {
... getter / setter omitted for brevity
    @Id
    @SequenceGenerator(name = "EntityTwoSequence", initialValue = 1000)
    @GeneratedValue(generator = "EntityTwoSequence")
    private Integer id;
    private String firstName;
    private String lastName;
    private String email;
    private String provider;
    private String externalId;
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "user_role",
          joinColumns = @JoinColumn(name = "user_id"),
          inverseJoinColumns = @JoinColumn(name = "role_id"))
    private Set&lt;Role&gt; roles;
    /**
}</pre></li> <li>Implement and <a id="_idIndexMarker665"/>expose <strong class="source-inline">OAuth2UserService</strong> to call the <strong class="bold">Authorization Server</strong> as well as your database. Your implementation can be delegated to the default implementation, which will do the heavy lifting of calling the <strong class="bold">Authorization Server</strong>. Your implementation should return something that extends your custom <strong class="source-inline">CalendarUser</strong> object and <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">OAuth2User</strong></span><span class="No-Break">.</span><pre class="source-code">
@Component
public class CalendarOAuth2UserService implements OAuth2UserService {
    private final CalendarService calendarService;
    public CalendarOAuth2UserService(CalendarService calendarService) {
       this.calendarService = calendarService;
    }
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
       DefaultOAuth2UserService delegate = new DefaultOAuth2UserService();
       OAuth2User user = delegate.loadUser(userRequest);
       String email = user.getAttribute("email");
       CalendarUser calendarUser = calendarService.findUserByEmail(email);
       if (calendarUser ==null) {
          calendarUser = new CalendarUser();
          calendarUser.setEmail(email);
          calendarUser.setProvider(userRequest.getClientRegistration().getRegistrationId());
          if ("github".equals(userRequest.getClientRegistration().getRegistrationId())) {
             calendarUser.setExternalId(user.getAttribute("id").toString());
             calendarUser.setFirstName( user.getAttribute("name"));
             calendarUser.setLastName(user.getAttribute("name"));
          }
       calendarService.createUser(calendarUser);
       }
       return user;
    }
}</pre></li> <li>Implement and <a id="_idIndexMarker666"/>expose <strong class="source-inline">OidcUserService</strong> to call the <strong class="source-inline">Authorization Server</strong> as well as your database. Your implementation should return something that extends your custom User object and <span class="No-Break">implements </span><span class="No-Break"><strong class="source-inline">OidcUser</strong></span><span class="No-Break">.</span><pre class="source-code">
@Component
public class CalendarOidcUserService extends OidcUserService {
    private final CalendarService calendarService;
    public CalendarOidcUserService(CalendarService calendarService) {
       this.calendarService = calendarService;
    }
    @Override
    public OidcUser loadUser(OidcUserRequest userRequest) throws OAuth2AuthenticationException {
       OidcUser user = super.loadUser(userRequest);
       String email = user.getEmail();
       CalendarUser calendarUser = calendarService.findUserByEmail(email);
       if (calendarUser == null) {
          calendarUser = new CalendarUser();
          calendarUser.setEmail(email);
          calendarUser.setProvider(userRequest.getClientRegistration().getRegistrationId());
          calendarUser.setExternalId(user.getAttribute("sub"));
          calendarUser.setFirstName(user.getGivenName());
          calendarUser.setLastName(user.getFamilyName());
       calendarService.createUser(calendarUser);
       }
       return user;
    }
}</pre></li> </ol>
<p class="callout-heading">Hint</p>
<p class="callout">Include a new attribute within the User object to establish a connection with a distinct identifier from the external provider (distinct from the user’s name, yet uniquely associated with the account on the <span class="No-Break">external platform).</span></p>
<p>One issue that <a id="_idIndexMarker667"/>would need to be resolved if supporting multiple providers is username conflicts between the various provider <span class="No-Break">details returned.</span></p>
<p>If you log in to the <strong class="source-inline">JBCP calendar</strong> application with each of the listed providers—which then query the data that was stored in <strong class="source-inline">H2 database</strong>—you will find the data could be similar, if not exactly the same, based on the user’s <span class="No-Break">account details.</span></p>
<p>In the <strong class="source-inline">CALENDAR_USERS</strong> table, we have two <span class="No-Break">possible issues:</span></p>
<ol>
<li>First, we use the email attribute of the <strong class="source-inline">UserDetails</strong> object as the <strong class="source-inline">user ID</strong> to find the <strong class="source-inline">JBCP calendar</strong> users. But the <strong class="source-inline">user ID</strong>, can be different than an email for some <span class="No-Break">other providers.</span></li>
<li>Second, it is still possible that the user identifier for two different providers will be <span class="No-Break">the same.</span></li>
</ol>
<p>We are not going to dive in<a id="_idTextAnchor310"/>to the various ways to detect and correct this possible issue, but it is worth noting for <span class="No-Break">future reference.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.07-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor311"/>Mapping User Authorities</h2>
<p>The <strong class="source-inline">GrantedAuthoritiesMapper</strong> receives a collection of granted authorities, including a unique authority of the <strong class="source-inline">OAuth2UserAuthority</strong> type with the corresponding<a id="_idIndexMarker668"/> string identifier <strong class="source-inline">OAUTH2_USER</strong> (or <strong class="source-inline">OidcUserAuthority</strong> with the string <span class="No-Break">identifier </span><span class="No-Break"><strong class="source-inline">OIDC_USER</strong></span><span class="No-Break">).</span></p>
<p>We will provide a custom implementation of <strong class="source-inline">GrantedAuthoritiesMapper</strong> and configure it, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/core/authority/ CalendarUserAuthoritiesMapper.java
@Component
public class CalendarUserAuthoritiesMapper implements GrantedAuthoritiesMapper {
    private CalendarUserRepository userRepository;
    public CalendarUserAuthoritiesMapper(CalendarUserRepository userRepository) {
       this.userRepository = userRepository;
    }
    @Override
    public Collection&lt;? extends GrantedAuthority&gt; mapAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) {
       Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();
       authorities.forEach(authority -&gt; {
          String email = null;
          if (authority instanceof OidcUserAuthority oidcUserAuthority) {
             OidcIdToken idToken = oidcUserAuthority.getIdToken();
             mappedAuthorities.add(oidcUserAuthority);
             email = idToken.getEmail();
          }
          else if (OAuth2UserAuthority.class.isInstance(authority)) {
             OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority) authority;
             mappedAuthorities.add(oauth2UserAuthority);
             Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes();
             email = (String) userAttributes.get("email");
          }
          if (email != null) {
             CalendarUser calendarUser = userRepository.findByEmail(email);
             List&lt;String&gt; roles = calendarUser.getRoles().stream().map(Role::getName).toList();
             List&lt;GrantedAuthority&gt; grantedAuthorityList = AuthorityUtils.createAuthorityList(roles.toArray(new String[0]));
             mappedAuthorities.addAll(grantedAuthorityList);
          }
       });
       return mappedAuthorities;
    }
}</pre> <p>The following<a id="_idIndexMarker669"/> example shows how to adapt a <strong class="source-inline">SecurityConfig.java</strong> to use <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">GrantedAuthoritiesMapper</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
public SecurityFilterChain filterChain(HttpSecurity http, PersistentTokenRepository persistentTokenRepository,
       GrantedAuthoritiesMapper grantedAuthoritiesMapper) throws Exception {
... omitted for brevity
      // OAuth2 Login
      http
            .oauth2Login(oauth2 -&gt; oauth2
                  .loginPage("/login/form")
                  .authorizationEndpoint(authorization -&gt; authorization.authorizationRequestResolver(pkceResolver))
                  .defaultSuccessUrl("/default", true)
            .userInfoEndpoint(userInfo -&gt; userInfo
                  .userAuthoritiesMapper(grantedAuthoritiesMapper)))
            .logout(logout -&gt; logout
                  .logoutSuccessHandler(oidcLogoutSuccessHandler()));
      return http.build();
    }
}</pre> <p>With this <a id="_idIndexMarker670"/>implementation, you need to make sure the OIDC user roles already exist in <span class="No-Break">the database.</span></p>
<p>For our <strong class="source-inline">JBCP calendar</strong> application, let’s define a user with the <span class="No-Break">admin role.</span></p>
<p><span class="No-Break">For example:</span></p>
<pre class="source-code">
//src/main/resources/data.sql
insert into calendar_users(id,email,first_name,last_name) values (1,'calendarjbcp@gmail.com','Admin','1');
insert into user_role(user_id,role_id) values (1, 1);</pre> <p>At this stage, the user <strong class="source-inline">calendarjbcp@gmail.com</strong> has the admin role and can have access to the <strong class="bold">All Events</strong> page after <span class="No-Break">successful authentication.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should now look like that <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter09.08-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor312"/>Is OAuth 2 secure?</h1>
<p>As support for OAuth 2 relies on the trustworthiness of the OAuth 2 provider and the verifiability of the provider’s response, security and authenticity are critical in order for the application to have confidence in the user’s OAuth <span class="No-Break">2-based login.</span></p>
<p>Fortunately, the designers of the OAuth 2 specification were very aware of this concern, and implemented a series of verification steps to prevent response forgery, replay attacks, and other types of tampering, which are explained <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">Response forgery</strong> is prevented<a id="_idIndexMarker671"/> due to a combination of a shared secret key (created by the OAuth 2-enabled site prior to the initial request) and a one-way hashed message signature on the response itself. A malicious user tampering with the data in any of the response fields without having access to the shared secret key—and signature algorithm—would generate an <span class="No-Break">invalid response.</span></li>
<li><strong class="bold">Replay attacks</strong> are prevented<a id="_idIndexMarker672"/> due to the inclusion of a nonce, or a one-time use, random key, which should be recorded by the OAuth 2-enabled site so that it cannot ever be reused. In this way, even a user attempting to reissue the response URL would be foiled because the receiving site would determine that the nonce had been previously used, and would invalidate <span class="No-Break">the request.</span></li>
<li>The most likely form of attack that could result in a compromised user interaction would be a <strong class="bold">man-in-the-middle attack</strong>, where a malicious user could intercept the user’s interaction between their computer and the OAuth 2 provider. A hypothetical attacker in this situation could be in a position to record the conversation between the user’s browser and the OAuth 2 provider, and record the secret key used when the request was initiated. The attacker, in this case, would need a very high level of sophistication and reasonably a complete implementation of the OAuth 2 signature specification—in short, this is not likely to occur with <span class="No-Break">any regularity.</span></li>
</ul>
<h1 id="_idParaDest-206"><a id="_idTextAnchor313"/>Summary</h1>
<p>In this chapter, we reviewed OAuth 2, a relatively recent technology for user authentication and credentials management. OAuth 2 has a very wide reach on the web and has made great strides in usability and acceptance within the past year or two. Most public-facing sites on the modern web should plan on having some form of OAuth 2 support, and the <strong class="source-inline">JBCP calendar</strong> application is <span class="No-Break">no exception!</span></p>
<p>We learned about the following topics: the OAuth 2 authentication mechanism and its high-level architecture and key terminology. We also learned about OAuth 2 login and automatic user registration with the <strong class="source-inline">JBCP calendar</strong> application. We also covered automatic login with OAuth 2 and the security of OAuth 2’s <span class="No-Break">login responses.</span></p>
<p>We covered one of the simplest single sign-on mechanisms to implement with <strong class="source-inline">Spring Security</strong>. One of the downsides is that it does not support a standard mechanism for a single logout. In the next chapter, we will explore SAML, another standard, single sign-on protocol that also supports <span class="No-Break">single logout.</span></p>
</div>
</div></body></html>