<html><head></head><body>
		<div id="_idContainer034">
			<h1 class="chapter-number" id="_idParaDest-228"><a id="_idTextAnchor227"/>13</h1>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/>Performance-Focused Libraries</h1>
			<p>The performance of modern Java applications is a paramount concern that can significantly impact the success of an application and the organization. Performance can include execution speed, network responsiveness, and data handling optimization. Regardless of the type of performance you are trying to improve, selecting and properly implementing the most ideal tools and libraries are key to bringing your performance improvement goals <span class="No-Break">to fruition.</span></p>
			<p>This chapter highlights a specific set of tools that can be instrumental in improving the performance of Java applications. The<a id="_idIndexMarker654"/> first tool reviewed is <strong class="bold">Java Microbenchmark Harness</strong> (<strong class="bold">JMH</strong>), which helps us create reliable benchmarks. Our JMH coverage will include fundamental knowledge and hands-on application. Netty, a network application framework focused on high performance, will also be covered. This framework’s greatest value is in applications that require rapid response times or scalable <span class="No-Break">network architectures.</span></p>
			<p>Our coverage of performance-focused libraries includes an examination of FasterXML Jackson, a high-speed <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) processor<a id="_idIndexMarker655"/> that, as you will have the opportunity to learn, facilitates data processing efficiencies. FasterXML Jackson, also referred to as just Jackson, has streaming and data-binding APIs that can significantly improve performance when working with JSON data. The chapter concludes with a section on other notable libraries, including Eclipse Collections, Agrona, <span class="No-Break">and Guava.</span></p>
			<p>By the end of this chapter, you should have a foundational understanding of performance-focused libraries and be able to leverage the knowledge you gained from the hands-on exercises to improve the performance of your <span class="No-Break">Java applications.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Java <span class="No-Break">Microbenchmark Harness</span></li>
				<li><span class="No-Break">Netty</span></li>
				<li><span class="No-Break">FasterXML Jackson</span></li>
				<li>Other <span class="No-Break">notable libraries</span></li>
			</ul>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor229"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need the ability to load, edit, and run Java code. If you have not set up your development environment, refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Peeking Inside the Java Virtual </em><span class="No-Break"><em class="italic">Machine (JVM)</em></span><span class="No-Break">.</span></p>
			<p>The finished code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter13</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor230"/>Java Microbenchmark Harness</h1>
			<p>Benchmarking<a id="_idIndexMarker656"/> is critical to the ability to measure performance. JMH is a toolkit used to implement rigorous benchmarks. This section explores JMH and its key features and provides <span class="No-Break">implementation examples.</span></p>
			<p class="callout-heading">Java Microbenchmark Harness (JMH)</p>
			<p class="callout">JMH is used to build and implement <a id="_idIndexMarker657"/>benchmarks to analyze the performance of Java code. It was written in Java by the team that created <a id="_idIndexMarker658"/>the <strong class="bold">Java Virtual </strong><span class="No-Break"><strong class="bold">Machine</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JVM</strong></span><span class="No-Break">).</span></p>
			<p>Developers that use JMH can measure the performance of Java code snippets with repeatable and <span class="No-Break">controlled conditions.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/>Key features</h2>
			<p>JMH is an <a id="_idIndexMarker659"/>open source toolkit used to build and implement benchmarks at the nano, micro, and macro levels. JMH is more than a performance tester; it is designed to overcome or avoid common performance measurement pitfalls, including warm-up times and the effects<a id="_idIndexMarker660"/> of <strong class="bold">just-in-time</strong> (<span class="No-Break"><strong class="bold">JIT</strong></span><span class="No-Break">)</span><span class="No-Break"> compilations.</span></p>
			<p>Key features of the JMH toolkit include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Annotations</strong>: As you will see in the next section, JMH uses Java annotations to easily define benchmarks. This feature <span class="No-Break">is developer-friendly.</span></li>
				<li><strong class="bold">JVM integration</strong>: JMH works in step with JVM intervals. This provides us with consistent and <span class="No-Break">reliable results.</span></li>
				<li><strong class="bold">Microbenchmarking support</strong>: JMH, as the name suggests, focuses on small code snippets. This helps <a id="_idIndexMarker661"/>increase the accuracy of <span class="No-Break">performance measurements.</span></li>
			</ul>
			<p>Now that you have a basic understanding of the JMH toolkit, let’s look at how to <span class="No-Break">write benchmarks.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor232"/>Adding JMH libraries to your IDE</h2>
			<p>Depending<a id="_idIndexMarker662"/> on your <strong class="bold">Integrated Development Environment</strong> (<strong class="bold">IDE</strong>) setup, you may have to manually add the JMH libraries to your Java <a id="_idIndexMarker663"/>project. The following steps can be used with Visual Studio Code to add the JMH libraries to a <span class="No-Break">Java project:</span></p>
			<ol>
				<li>Create a <strong class="bold">Maven </strong><span class="No-Break"><strong class="bold">quickstart</strong></span><span class="No-Break"> project.</span></li>
				<li>Edit the <strong class="source-inline">pom.xml</strong> file by adding the <span class="No-Break">following dependencies:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-core&lt;/artifactId&gt;
    &lt;version&gt;1.32&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt;
    &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt;
    &lt;version&gt;1.32&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Save and reload the project using <strong class="bold">Maven: Reload project</strong> via the <span class="No-Break">command palette.</span></li>
			</ol>
			<p>You might opt to <a id="_idIndexMarker664"/>use a more robust IDE, such as<a id="_idIndexMarker665"/> IntelliJ IDEA. Here are the steps to add these libraries to a project in <span class="No-Break">that IDE:</span></p>
			<ol>
				<li>Create a project in <span class="No-Break">IntelliJ IDEA.</span></li>
				<li>Select the <strong class="bold">File</strong> | <strong class="bold">Project Structure</strong> <span class="No-Break">menu option.</span></li>
				<li>In the <strong class="bold">Project Structure</strong> interface, select <strong class="bold">Project Settings</strong> | <span class="No-Break"><strong class="bold">Libraries</strong></span><span class="No-Break">.</span></li>
				<li>Click the <strong class="bold">+</strong> button to add a <span class="No-Break">new library.</span></li>
				<li>Choose the <strong class="bold">From </strong><span class="No-Break"><strong class="bold">Maven</strong></span><span class="No-Break"> option.</span></li>
				<li>Use the search feature to find the most recent version of <strong class="source-inline">org.openjdk.jmh:jmh-core</strong> and click <strong class="bold">OK</strong> to add the library to <span class="No-Break">your project.</span></li>
				<li>Use the search feature to find the most recent version of <strong class="source-inline">org.openjdk.jmh:jmh-generator-annprocess</strong> and click <strong class="bold">OK</strong> to add the library to <span class="No-Break">your project.</span></li>
				<li>Click <strong class="bold">Apply</strong> to apply the changes and then <strong class="bold">OK</strong> to close the <strong class="bold">Project Structure</strong> <span class="No-Break">dialog window.</span></li>
				<li>Lastly, ensure that the libraries have been automatically added to your module. If this is not the case, select the <strong class="bold">File</strong> | <strong class="bold">Project Structure</strong> | <strong class="bold">Modules</strong> menu option. If the new JMH libraries are not listed in the <strong class="bold">Dependencies</strong> area, use the <strong class="bold">+</strong> button to <span class="No-Break">add them.</span></li>
			</ol>
			<p>If you are not using<a id="_idIndexMarker666"/> Visual Studio Code or IntelliJ IDEA, follow the steps appropriate for <span class="No-Break">your IDE.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/>Writing benchmarks</h2>
			<p>To use <a id="_idIndexMarker667"/>JMH in Java code, we simply add the <strong class="source-inline">@Benchmark</strong> annotation and use JMH’s core APIs to configure and execute our benchmarks. Let’s look at an example in code. Our example tests two methods, both with a different approach to <span class="No-Break">string reversal:</span></p>
			<pre class="source-code">
package org.example;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;
@State(Scope.Thread)
public class Ch13StringBenchmark {
    private String sampleString;
    @Setup
    public void prepare() {
        sampleString = "The quick brown fox jumps over the lazy dog";
    }
    @Benchmark
    public String reverseWithStringBuilder() {
        return new StringBuilder(sampleString).reverse().toString();
    }
    @Benchmark
    public String reverseManually() {
        char[] strArray = sampleString.toCharArray();
        int left = 0;
        int right = strArray.length - 1;
        while (left &lt; right) {
            char temp = strArray[left];
            strArray[left] = strArray[right];
            strArray[right] = temp;
            left++;
            right--;
        }
        return new String(strArray);
    }
    public static void main(String[] args) throws Exception {
        Options opt = new OptionsBuilder()
                .include(Ch13StringBenchmark.class.getSimpleName())
                .forks(1)
                .build();
        new Runner(opt).run();
    }
}</pre>			<p>Next, let’s run our code and review <span class="No-Break">the results.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/>Running benchmarks</h2>
			<p>Once we<a id="_idIndexMarker668"/> define our benchmarks, we simply run them via the <strong class="source-inline">main()</strong> method in our Java application or, alternatively, via the command line. If our application does not contain a <strong class="source-inline">main()</strong> method, then we would run the class containing the benchmarks. In our previous code example, that would be the <strong class="source-inline">Ch13StringBenchmark()</strong> class.  JMH provides detailed output with time measurements and throughput rates. Analysis of this data can provide significant performance-related insights into the <span class="No-Break">benchmarked code.</span></p>
			<p>Even our simple test results in extensive output. The final segment of the output is provided in the following figure. The complete output is provided in the <strong class="source-inline">Ch13StringBenchmarkOutput.txt</strong> file in this chapter’s <span class="No-Break">GitHub repository.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 13.1 – Final benchmark output&#13;&#10;" src="image/B21942_13_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Final benchmark output</p>
			<p>Referring to the preceding output, let’s look at how that information can be analyzed to provide <span class="No-Break">performance insights.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/>Analyzing results</h2>
			<p>As you saw in the previous<a id="_idIndexMarker669"/> section, JMH provides extensive output. Looking at the final three lines of output illustrated in <span class="No-Break"><em class="italic">Figure 13</em></span><em class="italic">.1</em>, there are several columns that we <span class="No-Break">should understand:</span></p>
			<ul>
				<li><strong class="source-inline">Mode</strong>: This is the benchmark mode. Our mode was <strong class="source-inline">thrpt</strong> for throughput. It could have alternatively been <strong class="source-inline">avgt</strong> for <span class="No-Break">average time.</span></li>
				<li><strong class="source-inline">Cnt</strong>: This is the count of benchmark iterations. In our case, it was <strong class="source-inline">5</strong> for <span class="No-Break">each benchmark.</span></li>
				<li><strong class="source-inline">Score</strong>: This is the benchmark score that shows, in our case, the average throughput time <span class="No-Break">in microseconds.</span></li>
				<li><strong class="source-inline">Error</strong>: This column contains the margin of error for <span class="No-Break">the score.</span></li>
			</ul>
			<p>Based on the output, we can see that the first benchmark was faster than the second benchmark. Viewing these types of results can help developers decide how to implement certain functionality to achieve high performance in <span class="No-Break">their code.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/>Use cases</h2>
			<p>There are a few<a id="_idIndexMarker670"/> common JMH <span class="No-Break">use cases:</span></p>
			<ul>
				<li><span class="No-Break">Algorithm optimization</span></li>
				<li><span class="No-Break">Comparative analysis</span></li>
				<li>Performance <span class="No-Break">regression tests</span></li>
			</ul>
			<p>JMH empowers Java developers to create and implement benchmarks. Analyzing the results can help developers make informed decisions based on an analysis of empirical data. This can lead to more performant <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor237"/>Netty</h1>
			<p>Netty, cutely named for <a id="_idIndexMarker671"/>networking, is a high-performance, event-driven application framework. This framework helps developers create network applications by simplifying <a id="_idIndexMarker672"/>network<a id="_idIndexMarker673"/> functionality programming such as with <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) and <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) <span class="No-Break">socket servers.</span></p>
			<p>Network <a id="_idIndexMarker674"/>programming often involves low-level APIs and Netty provides a level of abstraction making it easier to develop with. The Netty architecture is scalable, supports many connections, and is designed to minimize latency and <span class="No-Break">resource overhead.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor238"/>Core features</h2>
			<p>Netty is the framework of <a id="_idIndexMarker675"/>choice for many network developers due to its reliability, scalability, and ease of use. The core features of Netty include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Built-in codec support</strong>: Netty has built-in encoders and decoders to help developers work with various protocols including HTTP and WebSocket. Netty negates the need for separate implementations for <span class="No-Break">supported protocols.</span></li>
				<li><strong class="bold">Customizable pipeline</strong>: The Netty framework includes a pipeline architecture that facilitates data encapsulation and handlers. It uses a modular approach, making pipeline configuration an easy task <span class="No-Break">for developers.</span></li>
				<li><strong class="bold">Event-driven</strong>: Netty’s event-driven design results in asynchronous input/output handling. This non-blocking approach minimizes <span class="No-Break">network latency.</span></li>
			</ul>
			<p>Armed with an understanding of Netty’s core features, let’s review <span class="No-Break">performance considerations.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor239"/>Performance considerations</h2>
			<p>Our focus throughout this book<a id="_idIndexMarker676"/> has been on high-performance Java applications. Netty is a great addition to our high-performance tool kit. It emphasizes high performance with<a id="_idIndexMarker677"/> its <strong class="bold">thread model flexibility</strong> and <strong class="bold">zero-copy capabilities</strong>. Let’s<a id="_idIndexMarker678"/> look at those <span class="No-Break">performance considerations:</span></p>
			<ul>
				<li><strong class="bold">Thread model flexibility</strong>: Netty’s<a id="_idIndexMarker679"/> thread management is highly configurable. Developers can configure Netty to manage their application’s threads based on specific use cases, such as scaling up or down and reducing the number <span class="No-Break">of threads.</span></li>
				<li><strong class="bold">Zero-copy capabilities</strong>: Netty’s<a id="_idIndexMarker680"/> zero-copy API helps make data processing (input and output) more efficient. This is accomplished by <a id="_idIndexMarker681"/>minimizing unnecessary <span class="No-Break">memory duplication.</span></li>
			</ul>
			<p>Let’s look at an example of using Netty to create an echo server that simply echoes data it receives to <span class="No-Break">the client.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor240"/>Implementation</h2>
			<p>The following example demonstrates the<a id="_idIndexMarker682"/> relative ease with which Netty can be used to handle network events and how Netty can facilitate high performance in network communications. Note that you will document your dependencies in the <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;
public class Ch13EchoServer {
  public static void main(String[] args) throws InterruptedException {
    EventLoopGroup bossGroup = new NioEventLoopGroup(1);
    EventLoopGroup workerGroup = new NioEventLoopGroup();
    try {
      ServerBootstrap b = new ServerBootstrap();
      b.group(bossGroup, workerGroup)
       .channel(NioServerSocketChannel.class)
       .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
        @Override
        protected void initChannel(SocketChannel ch) throws Exception {
          ChannelPipeline p = ch.pipeline();
          p.addLast(new StringDecoder(), new StringEncoder(), new 
          Ch13EchoServerHandler());
        }
      });
      ChannelFuture f = b.bind(8080).sync();
      f.channel().closeFuture().sync();
    } finally {
        workerGroup.shutdownGracefully();
        bossGroup.shutdownGracefully();
    }
  }
  static class Ch13EchoServerHandler extends 
  ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
      ctx.write(msg);
      ctx.flush();
    }
  }
}</pre>			<p>Here is simulated output of the Netty <span class="No-Break">echo server:</span></p>
			<pre class="console">
Server started on port 8080.
Client connected from IP: 192.168.1.5
Received from client: Hello Server!
Echoed back: Hello Server!
Received from client: This is a test message.
Echoed back: This is a test message.
Received from client: Netty is awesome!
Echoed back: Netty is awesome!
Client disconnected: IP 192.168.1.5
Server shutting down...</pre>			<p>Netty is a <a id="_idIndexMarker683"/>mature and robust framework for network application development. It is inherently scalable and offers performance benefits with network functionality. Netty also introduces development efficiencies and shorter <span class="No-Break">development times.</span></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor241"/>FasterXML Jackson</h1>
			<p>JSON is a file format <a id="_idIndexMarker684"/>used for interchanging data. It is structured and human-readable text used to transmit data objects. The format consists of arrays and attribute-value pairs. The example JSON object provided in the following code block represents a user profile for a social media system. As you can see, the fields contain the user’s name, age, email address, <span class="No-Break">and hobbies:</span></p>
			<pre class="source-code">
{
    "name": "Neo Anderson",
    "age": 24,
    "email": "neo.anderson@matrix.com",
    "hobbies": ["coding", "hacking", "sleeping"]
}</pre>			<p>This JSON object consists of attribute-value or key-value pairs and an array of strings for the user’s hobbies. JSON is a common method of data representation in data storage and <span class="No-Break">web applications.</span></p>
			<p><strong class="bold">FasterXML Jackson</strong> is a <a id="_idIndexMarker685"/>library with the primary ability to rapidly process and create JSON objects. These objects are read sequentially and FasterXML Jackson, referred to from this point as <strong class="bold">Jackson</strong>, uses a cursor to keep track of its place. Jackson is lauded as a performance maximizer and <span class="No-Break">memory minimizer.</span></p>
			<p>The <em class="italic">XML</em> in <em class="italic">FasterXML Jackson</em> suggests<a id="_idIndexMarker686"/> it can handle<a id="_idIndexMarker687"/> XML files too. In addition to Jackon’s ability to rapidly process JSON, it can also process <strong class="bold">Comma-Separated Values</strong> (<strong class="bold">CSV</strong>), <strong class="bold">eXtensible Markup Language</strong> (<strong class="bold">XML</strong>), <strong class="bold">YAML Ain’t Markup Language</strong> (<strong class="bold">YAML</strong>), and other<a id="_idIndexMarker688"/> <span class="No-Break">file formats.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor242"/>Core features</h2>
			<p>Core features<a id="_idIndexMarker689"/> of Jackson include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Data binding</strong>: Data binding is a Jackson feature that supports efficient and reliable conversion between Java objects and JSON text. Implementation <span class="No-Break">is straightforward.</span></li>
			</ul>
			<p class="callout-heading">Data binding</p>
			<p class="callout">A technique in computer programming that links (binds) data sources to the sender (provider) and <span class="No-Break">receiver (client).</span></p>
			<ul>
				<li><strong class="bold">Streaming API</strong>: Jackon has a highly efficient, low-level streaming API for parsing and <span class="No-Break">generating JSON.</span></li>
				<li><strong class="bold">Tree model</strong>: When flexible JSON operations are needed, Jackson’s tree model can be implemented to represent JSON documents in a tree structure – a tree of nodes. This is<a id="_idIndexMarker690"/> often used when the JSON structures <span class="No-Break">are complex.</span></li>
			</ul>
			<p>Now that you understand Jackson’s core features, let’s review <span class="No-Break">performance considerations.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor243"/>Performance considerations</h2>
			<p>The performance considerations<a id="_idIndexMarker691"/> detailed here illustrate how Jackson was designed as a <span class="No-Break">performance-focused library:</span></p>
			<ul>
				<li><strong class="bold">Custom serialization and deserialization</strong>: Jackson empowers developers to define their own serializers and deserializers for custom fields. This can lead to significant <span class="No-Break">performance enhancements.</span></li>
				<li><strong class="bold">Zero-copy</strong>: Like Netty, Jackson’s zero-copy API helps make data processing (input and output) efficient. This is accomplished by minimizing unnecessary <span class="No-Break">memory </span><span class="No-Break"><a id="_idIndexMarker692"/></span><span class="No-Break">duplication.</span></li>
			</ul>
			<p>Let’s look at an example of using Jackson to serialize and deserialize <span class="No-Break">Java objects.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor244"/>Implementation</h2>
			<p>Let’s start by adding <a id="_idIndexMarker693"/>dependencies to our <strong class="source-inline">pom.xml</strong> file to include Jackson in our project. Here is what that might <span class="No-Break">look like:</span></p>
			<pre class="source-code">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
        &lt;version&gt;2.12.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.12.3&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre>			<p>The following <a id="_idIndexMarker694"/>example illustrates how straightforward Jackson is for developing object serialization <span class="No-Break">and deserialization:</span></p>
			<pre class="source-code">
import com.fasterxml.jackson.databind.ObjectMapper;
  public class Ch13JacksonExample {
    public static void main(String[] args) throws Exception {
      ObjectMapper mapper = new ObjectMapper();
      // Example of a Plan Old Java Object (POJO)
      class User {
        public String name;
        public int age;
        // Constructors, getters, and setters have been omitted for 
        // brevity
      }
    // Serialize Java object to JSON
    User user = new User();
    user.name = "Neo Anderson";
    user.age = 24;
    String jsonOutput = mapper.writeValueAsString(user);
    System.out.println("Serialized JSON: " + jsonOutput);
    // Deserialize JSON to Java object
    String jsonInput = "{\"name\":\"Neo Anderson\",\"age\":24}";
    User userDeserialized = mapper.readValue(jsonInput, User.class);
    System.out.println("Deserialized user: " + userDeserialized.name);
  }
}</pre>			<p>In this section, we learned that Jackson is a key tool for processing JSON. It is fast, flexible, and robust. Jackson can be the first tool you think of when needing to work with JSON in your <span class="No-Break">Java applications.</span></p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor245"/>Other notable libraries</h1>
			<p>So far, we have covered JMH, Netty, and Jackson and posited that they are core libraries focused on high performance in Java. Each is designed for a specific type of task. There are other libraries available that are worth learning about. This section explores three additional libraries: <strong class="bold">Agrona</strong>, <strong class="bold">Eclipse Collections</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">Guava</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor246"/>Agrona</h2>
			<p>Agrona<a id="_idIndexMarker695"/> is a data structure collection specifically designed for creating high-performance Java applications. These data structures include maps and ring buffers. An example use case is a stock trading application whose success hinges on <span class="No-Break">low latency.</span></p>
			<p>Key features<a id="_idIndexMarker696"/> of Agrona include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Non-blocking data structures – this supports high throughput and results in <span class="No-Break">low latency</span></li>
				<li>Specifically designed for high-frequency stock and securities <span class="No-Break">trading systems</span></li>
				<li>Uses direct buffers, contributing to off-heap memory <span class="No-Break">management efficiencies</span></li>
			</ul>
			<p>Let’s look at an<a id="_idIndexMarker697"/> implementation example of Agrona that illustrates how to use a specific high-performance data structure. For our example, we will use the <strong class="source-inline">ManyToOneConcurrentArrayQueue</strong> <span class="No-Break">data structure:</span></p>
			<pre class="source-code">
import org.agrona.concurrent.ManyToOneConcurrentArrayQueue;
public class Ch13AgronaExample {
  public static void main(String[] args) {
    // Create a queue with a capacity of 10 items
    ManyToOneConcurrentArrayQueue&lt;String&gt; queue = new 
    ManyToOneConcurrentArrayQueue&lt;&gt;(10);
    // Producer thread that offers elements to the queue
    Thread producer = new Thread(() -&gt; {
      for (int i = 1; i &lt;= 5; i++) {
        String element = "Element " + i;
        while (!queue.offer(element)) {
          // Retry until the element is successfully added
          System.out.println("Queue full, retrying to add: " + 
          element);
          try {
            Thread.sleep(10); // Sleep to simulate backoff
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
        }
        System.out.println("Produced: " + element);
      }
    });
    // Consumer thread that polls elements from the queue
    Thread consumer = new Thread(() -&gt; {
      for (int i = 1; i &lt;= 5; i++) {
        String element;
        while ((element = queue.poll()) == null) {
          // Wait until an element is available
          System.out.println("Queue empty, waiting for elements...");
          try {
            Thread.sleep(10); // Sleep to simulate processing delay
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
        }
        System.out.println("Consumed: " + element);
      }
    });
    // Start both threads
    producer.start();
    consumer.start();
    // Wait for both threads to finish execution
    try {
      producer.join();
      consumer.join();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
}</pre>			<p>As you can see <a id="_idIndexMarker698"/>in the preceding code and surmise from the in-code comments, we initialize <strong class="source-inline">ManyToOneConcurrentArrayQueue</strong> with a capacity value of <strong class="source-inline">10</strong>. This type of queue is well suited for use cases where there is a single <strong class="bold">customer</strong> and multiple <strong class="bold">producers</strong>. Our example includes consumer and producer threads. The code implemented basic <span class="No-Break">thread handling.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor247"/>Eclipse Collections</h2>
			<p>Eclipse Collections<a id="_idIndexMarker699"/> is a set of memory-efficient algorithms and data structures. These collections can be used to significantly improve performance. Engineered for large-scale systems, Eclipse collections come in both mutable and immutable forms. They offer efficient <span class="No-Break">memory management.</span></p>
			<p>Key features of <a id="_idIndexMarker700"/>Eclipse collections include <span class="No-Break">the following:</span></p>
			<ul>
				<li>A comprehensive set of data structures to include bags, lists, maps, sets, stacks, <span class="No-Break">and more</span></li>
				<li>Primitive collections and <span class="No-Break">associated classes</span></li>
				<li>Utility methods that can transform collections and be used for filtering, iterating, <span class="No-Break">and </span><span class="No-Break"><a id="_idIndexMarker701"/></span><span class="No-Break">sorting</span></li>
			</ul>
			<p>Let’s demonstrate how to<a id="_idIndexMarker702"/> use an <strong class="source-inline">ImmutableList</strong> from an Eclipse collection. This is one of the more <span class="No-Break">memory-efficient collections:</span></p>
			<pre class="source-code">
import org.eclipse.collections.api.factory.Lists;
import org.eclipse.collections.api.list.ImmutableList;
public class Ch13EclipseCollectionsExample {
    public static void main(String[] args) {
        // Creating an immutable list using Eclipse Collections
        ImmutableList&lt;String&gt; immutableList = Lists.immutable.
        of("Apple", "Pear", "Cherry", "Lime");
        // Displaying the original list
        System.out.println("Original immutable list: " + 
        immutableList);
        // Adding an item to the list, which returns a new immutable 
        // list
        ImmutableList&lt;String&gt; extendedList = immutableList.
        newWith("Orange");
        // Displaying the new list
        System.out.println("Extended immutable list: " + 
        extendedList);
        // Iterating over the list to print each element
        extendedList.forEach(System.out::println);
    }
}</pre>			<p>Our example starts with the creation of an immutable list of fruits. Next, we add an element to the list, then we iterate through the list <span class="No-Break">for output.</span></p>
			<p>To use Eclipse Collections in our applications, we need to include the library in our project. With the example of Maven, we would simply add the following to our <span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.collections&lt;/groupId&gt;
    &lt;artifactId&gt;eclipse-collections-api&lt;/artifactId&gt;
    &lt;version&gt;11.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.collections&lt;/groupId&gt;
    &lt;artifactId&gt;eclipse-collections&lt;/artifactId&gt;
    &lt;version&gt;11.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>			<p>Our code <a id="_idIndexMarker703"/>snippet provided a basic introduction to using <span class="No-Break">Eclipse Collections.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor248"/>Guava</h2>
			<p>Guava is a <a id="_idIndexMarker704"/>product from Google that includes new collection types such as multimap and multiset. It also includes immutable collections, a graph library, support for primitives, and caching utilities. Here is a list of key features<a id="_idIndexMarker705"/> <span class="No-Break">of Guava:</span></p>
			<ul>
				<li>Advanced <span class="No-Break">collection types.</span></li>
				<li>Advanced <span class="No-Break">collection utilities.</span></li>
				<li>Caching support using <strong class="source-inline">CacheBuilder</strong>. This can be used to improve <span class="No-Break">application speed.</span></li>
				<li>Utilities <span class="No-Break">for concurrency.</span></li>
				<li>Utilities <span class="No-Break">for hashing.</span></li>
				<li>Utilities for <span class="No-Break">input/output operations.</span></li>
			</ul>
			<p>Here is an example <a id="_idIndexMarker706"/>application that demonstrates the use of Guava’s <strong class="source-inline">CacheBuilder</strong>. The application creates a cache that automatically loads and stores <span class="No-Break">value-based keys:</span></p>
			<pre class="source-code">
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import java.util.concurrent.TimeUnit;
public class Ch13GuavaExample {
  public static void main(String[] args) throws Exception {
    LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder()
      .maximumSize(100)
      .expireAfterWrite(10, TimeUnit.MINUTES)
      .build(
        new CacheLoader&lt;String, String&gt;() {
          public String load(String key) {
            return "Value for " + key;
          }
        }
      );
    System.out.println(cache.get("key1"));
    System.out.println(cache.get("key2"));
    System.out.println(cache.get("key3"));
  }
}</pre>			<p>Java has several libraries and frameworks that can be used to improve overall performance. Understanding what libraries are available to us and how to implement them can be crucial to an <span class="No-Break">application’s success.</span></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor249"/>Summary</h1>
			<p>This chapter explored several key high-performance libraries that we can employ to improve the performance of our Java applications. Specifically, we reviewed JMH and indicated that it provides reliable performance benchmarking. We also looked at Netty and identified its applicability to improving the performance of network applications. FastXML Jackson was also reviewed for its specialized use in handling JSON objects. Lastly, we covered three additional libraries: Agrona, Eclipse Collections, <span class="No-Break">and Guava.</span></p>
			<p>Each library featured in the chapter is tailored to a specific Java programming need. These tools are poised to help us significantly improve the performance of our Java applications. Experimenting with these libraries with your own Java projects can help solidify your understanding of them and the best use case for each of them. Furthermore, implementing these libraries appropriately can lead to overall improved performance of your <span class="No-Break">Java application.</span></p>
		</div>
	</body></html>