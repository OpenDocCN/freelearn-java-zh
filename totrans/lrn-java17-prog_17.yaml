- en: '*Chapter 14*: Java Standard Streams'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：Java标准流'
- en: In this chapter, we will talk about processing data streams, which are different
    from the I/O streams we reviewed in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. We will define what data streams are, how
    to process their elements using methods (operations) of the `java.util.stream.Stream`
    object, and how to chain (connect) stream operations in a pipeline. We will also
    discuss stream initialization and how to process streams in parallel.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论数据处理流，这些流与我们在[*第5章*](B18388_05_ePub.xhtml#_idTextAnchor121)，“字符串、输入/输出和文件”中回顾的I/O流不同。我们将定义什么是数据流，如何使用`java.util.stream.Stream`对象的方法（操作）处理它们的元素，以及如何在管道中链式（连接）流操作。我们还将讨论流的初始化以及如何并行处理流。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Streams as a source of data and operations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流作为数据和操作源
- en: Stream initialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流初始化
- en: Operations (methods)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作（方法）
- en: Numeric stream interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字流接口
- en: Parallel streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行流
- en: Creating a standalone stream-processing application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建独立的流处理应用程序
- en: By the end of the chapter, you will be able to write code that processes streams
    of data as well as create a stream-processing application as a standalone project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够编写处理数据流以及创建作为独立项目的流处理应用程序的代码。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够执行本章提供的代码示例，你需要以下内容：
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有Microsoft Windows、Apple macOS或Linux操作系统的计算机
- en: Java SE version 17 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java SE版本17或更高版本
- en: An IDE or code editor of your choice
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你选择的IDE或代码编辑器
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on the
    GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch14_streams` folder and the
    `streams` folder, which contains a standalone stream-processing application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18388_01_ePub.xhtml#_idTextAnchor015)，“开始使用Java 17”中提供了如何设置Java SE和IntelliJ
    IDEA编辑器的说明。本章的代码示例文件可在GitHub仓库[https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)的`examples/src/main/java/com/packt/learnjava/ch14_streams`文件夹和`streams`文件夹中找到，其中包含一个独立的流处理应用程序。
- en: Streams as a source of data and operations
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流作为数据和操作源
- en: Lambda expressions, described and demonstrated in the previous chapter, together
    with functional interfaces add a powerful functional programming capability to
    Java. They allow passing behavior (functions) as parameters to libraries optimized
    for the performance of data processing. This way, an application programmer can
    concentrate on the business aspects of a developed system, leaving the performance
    aspects to the specialists – the authors of the library. One example of such a
    library is `java.util.stream`, which is going to be the focus of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中描述和演示的Lambda表达式，以及函数式接口，为Java添加了强大的函数式编程能力。它们允许将行为（函数）作为参数传递给针对数据处理性能优化的库。这样，应用程序程序员可以专注于开发系统的业务方面，将性能方面留给专家——库的作者。这样的库的一个例子是`java.util.stream`，这将是本章的重点。
- en: In [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121), *Strings, Input/Output,
    and Files*, we talked about I/O streams as a source of data, but beyond that,
    they are not of much help for further processing of data. Also, they are byte-
    or character-based, not object-based. You can create a stream of objects only
    after objects have been programmatically created and serialized first. The I/O
    streams are just connections to external resources, mostly files, and not much
    else. However, sometimes it is possible to make a transition from an I/O stream
    to `java.util.stream.Stream`. For example, the `BufferedReader` class has the
    `lines()` method that converts the underlying character-based stream into a `Stream<String>`
    object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18388_05_ePub.xhtml#_idTextAnchor121)，*字符串、输入/输出和文件*中，我们讨论了I/O流作为数据源，但除此之外，它们在进一步处理数据方面帮助不大。此外，它们是基于字节或字符的，而不是基于对象的。只有当对象首先以编程方式创建和序列化后，才能创建对象流。I/O流只是连接到外部资源，主要是文件，没有其他用途。然而，有时可以从I/O流过渡到`java.util.stream.Stream`。例如，`BufferedReader`类有一个`lines()`方法，它将底层的基于字符的流转换为`Stream<String>`对象。
- en: 'On the other hand, the streams of the `java.util.stream` package are oriented
    toward processing collections of objects. In *Chapter 2*, *Data Structures, Generics,
    and Popular Utilities*, we described two methods of the `Collection` interface
    that allow you to read collection elements as elements of a stream: `default Stream<E>
    stream()` and `default Stream<E> parallelStream()`. We also mentioned the `stream()`
    method of `java.util.Arrays`. It has the following eight overloaded versions that
    convert an array or part of it into a stream of the corresponding data types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`java.util.stream`包中的流是面向处理对象集合的。在*第二章*，*数据结构、泛型和常用工具*中，我们描述了`Collection`接口的两个方法，允许您将集合元素作为流元素读取：`default
    Stream<E> stream()`和`default Stream<E> parallelStream()`。我们还提到了`java.util.Arrays`的`stream()`方法。它有以下八个重载版本，可以将数组或其部分转换为相应数据类型的流：
- en: '`static DoubleStream stream(double[] array)`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static DoubleStream stream(double[] array)`'
- en: '`static DoubleStream stream(double[] array, int startInclusive, int endExclusive)`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static DoubleStream stream(double[] array, int startInclusive, int endExclusive)`'
- en: '`static IntStream stream(int[] array)`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static IntStream stream(int[] array)`'
- en: '`static IntStream stream(int[] array, int startInclusive, int endExclusive)`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static IntStream stream(int[] array, int startInclusive, int endExclusive)`'
- en: '`static LongStream stream(long[] array)`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static LongStream stream(long[] array)`'
- en: '`static LongStream stream(long[] array, int startInclusive, int endExclusive)`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static LongStream stream(long[] array, int startInclusive, int endExclusive)`'
- en: '`static <T> Stream<T> stream(T[] array)`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static <T> Stream<T> stream(T[] array)`'
- en: '`static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`'
- en: Let’s now look closer at the streams of the `java.util.stream` package. The
    best way to understand what a stream is is to compare it with a collection. The
    latter is a data structure stored in memory. Every collection element is computed
    before being added to the collection. By contrast, an element emitted by a stream
    exists somewhere else, in the source, and is computed on demand. So, a collection
    can be a source for a stream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`java.util.stream`包中的流。理解流的最佳方式是将它与集合进行比较。后者是存储在内存中的数据结构。每个集合元素在添加到集合之前都会被计算。相比之下，流发出的元素存在于其他地方，即源，并且按需计算。因此，集合可以成为流的一个来源。
- en: A `Stream` object is an implementation of the `Stream` interface, `IntStream`,
    `LongStream`, or `DoubleStream`; the last three are called `Stream` interface
    are also available in numeric streams. Some of the numeric streams have a few
    extra methods, such as `average()` and `sum()`, which are specific numeric values.
    In this chapter, we are going to speak mostly about the `Stream` interface and
    its methods, but everything we will cover is equally applicable to numeric streams
    too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`对象是`Stream`接口、`IntStream`、`LongStream`或`DoubleStream`的实现；后三个称为`Stream`接口，也在数值流中可用。一些数值流有一些额外的方法，如`average()`和`sum()`，它们是特定的数值。在本章中，我们将主要讨论`Stream`接口及其方法，但我们所涵盖的一切同样适用于数值流。'
- en: A stream *produces* (or *emits*) stream elements as soon as a previously emitted
    element has been processed. It allows declarative presentation of methods (operations)
    that can be applied to the emitted elements, also in parallel. Today, when the
    machine learning requirements of large dataset processing are becoming ubiquitous,
    this feature reinforces the position of Java as one of the few modern programming
    languages of choice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦之前发射的元素被处理，流就会*产生*（或*发射*）流元素。它允许以声明性方式呈现可以应用于发射元素的方法（操作），也可以并行执行。如今，随着大数据集处理机器学习需求变得普遍，这一特性加强了Java作为少数现代编程语言之一的选择地位。
- en: Will all that said, we will start with a stream initialization.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我们将从流初始化开始。
- en: Stream initialization
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流初始化
- en: There are many ways to create and initialize a stream – an object of type `Stream`
    or any of the numeric interfaces. We grouped them by classes and interfaces that
    have stream-creating methods. We did it for your convenience so that it would
    be easier for you to remember and find them if need be.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和初始化流有许多方法——`Stream`类型的对象或任何数值接口。我们根据具有流创建方法的类和接口对它们进行了分组。我们这样做是为了方便您记忆，并在需要时更容易找到它们。
- en: Stream interface
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stream接口
- en: This group of `Stream` factories is composed of static methods that belong to
    the `Stream` interface.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Stream`工厂组由属于`Stream`接口的静态方法组成。
- en: empty()
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: empty()
- en: 'The `Stream<T> empty()` method creates an empty stream that does not emit any
    element:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T> empty()`方法创建一个不发射任何元素的空流：'
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `forEach()` `Stream` method acts similarly to the `forEach()` `Collection`
    method and applies the passed-in function to each of the stream elements:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()` `Stream`方法与`forEach()` `Collection`方法类似，并将传入的函数应用于流中的每个元素：'
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The result is the same as creating a stream from an empty collection:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与从空集合创建流相同：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Without any element emitted, nothing happens. We will discuss the `forEach()`
    `Stream` method in the *Terminal operations* subsection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有元素被发射，则不会发生任何操作。我们将在*终端操作*子节中讨论`forEach()` `Stream`方法。
- en: of(T... values)
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: of(T... values)
- en: 'The `of(T... values)` method accepts varargs and can also create an empty stream:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`of(T... values)`方法接受可变参数，也可以创建一个空流：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, it is most often used for initializing a non-empty stream:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它通常用于初始化非空流：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the method reference used for the invocation of the `println()` and `print()`
    methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意用于调用`println()`和`print()`方法的引用方法。
- en: 'Another way to use the `of(T... values)` method is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`of(T... values)`方法的另一种方式如下：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If there is no type specified for the `Stream` object, the compiler does not
    complain if the array contains a mix of types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为`Stream`对象指定类型，编译器不会对数组中包含的类型混合提出异议：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Adding generics that declare the expected element type causes an exception
    when at least one of the listed elements has a different type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加声明预期元素类型的泛型会导致至少有一个列表元素类型不同时抛出异常：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Generics help a programmer to avoid many mistakes, so they should be added wherever
    possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型帮助程序员避免许多错误，因此应该尽可能添加。
- en: 'The `of(T... values)` method can also be used for the concatenation of multiple
    streams. Let’s assume, for example, that we have the following four streams that
    we would like to concatenate into one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`of(T... values)`方法也可以用于多个流的连接。例如，假设我们有以下四个流，我们希望将它们连接成一个：'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We would like to concatenate them into a new stream that emits the `1,2,2,3,3,4,4,5`
    values. First, we try the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将它们连接成一个新的流，该流发射`1,2,2,3,3,4,4,5`值。首先，我们尝试以下代码：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It does not do what we hoped for. It treats each stream as an object of the
    `java.util.stream.ReferencePipeline` internal class that is used in the `Stream`
    interface implementation. So, we need to add the `flatMap()` operation to convert
    each stream element into a stream (which we will describe in the *Intermediate
    operations* subsection):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有达到我们希望的效果。它将每个流视为`Stream`接口实现中使用的`java.util.stream.ReferencePipeline`内部类的对象。因此，我们需要添加`flatMap()`操作将每个流元素转换为流（我们将在*中间操作*子节中描述）：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function we passed into `flatMap()` as a parameter (`e -> e`) looks like
    it’s doing nothing, but that is because each element of the stream is a stream
    already, so there is no need to transform it. By returning an element as the result
    of the `flatMap()` operation, we tell the pipeline to treat the return value as
    a `Stream` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`flatMap()`作为参数的函数（`e -> e`）看起来像是在做无用功，但这是因为流中的每个元素本身就是一个流，所以没有必要对其进行转换。通过将元素作为`flatMap()`操作的返回值，我们告诉管道将返回值作为`Stream`对象处理。
- en: ofNullable(T t)
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ofNullable(T t)
- en: 'The `ofNullable(T t)` method returns `Stream<T>`, emitting a single element
    if the passed-in `t` parameter is not `null`; otherwise, it returns an empty `Stream`.
    To demonstrate the usage of the `ofNullable(T t)` method, we create the following
    method:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ofNullable(T t)`方法返回`Stream<T>`，如果传入的`t`参数不是`null`，则发出单个元素；否则，它返回一个空的`Stream`。为了演示`ofNullable(T
    t)`方法的用法，我们创建以下方法：'
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We execute this method twice – with the parameter list equal to `null` and
    a `List` object. Here are the results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行此方法两次 - 参数列表等于`null`和一个`List`对象。以下是结果：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note how the first call to the `printList1()` method generates `NullPointerException`.
    To avoid the exception, we can implement the method as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一次调用`printList1()`方法会生成`NullPointerException`。为了避免异常，我们可以将方法实现如下：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The same result can be achieved with the `ofNullable(T t)` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ofNullable(T t)`方法可以达到相同的结果：
- en: '[PRE33]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note how we have added `flatMap()` because, otherwise, the `Stream` element
    that flows into `forEach()` would be a `List` object. We will talk more about
    the `flatMap()` method in the *Intermediate operations* subsection. The function
    passed into the `flatMap()` operation in the preceding code can be expressed as
    a method reference too:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何添加了`flatMap()`，因为否则流入`forEach()`的`Stream`元素将是一个`List`对象。我们将在*中间操作*子节中更多地讨论`flatMap()`方法。在前面代码中传递给`flatMap()`操作的函数也可以表示为一个方法引用：
- en: '[PRE37]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Iterate (Objectand UnaryOperator)
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代（对象和一元操作符）
- en: 'Two static methods of the `Stream` interface allow you to generate a stream
    of values using an iterative process similar to the traditional `for` loop, as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口的两种静态方法允许您使用类似于传统`for`循环的迭代过程生成值流，如下所示：'
- en: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: This creates an infinite
    sequential stream based on the iterative application of the second parameter,
    the `func` function, to the first `seed` parameter, producing a stream of values:
    `seed`, `f(seed)`, `f(f(seed))`, and so on.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: 这根据第二个参数`func`函数对第一个`seed`参数的迭代应用创建了一个无限顺序流，产生一个值流：`seed`，`f(seed)`，`f(f(seed))`，等等。'
- en: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: This
    creates a finite sequential stream based on the iterative application of the third
    parameter, the `next` function, to the first `seed` parameter, producing a stream
    of values: `seed`, `f(seed)`, `f(f(seed))`, and so on, as long as the third parameter,
    the `hasNext` function, returns `true`.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: 这根据第三个参数`next`函数对第一个`seed`参数的迭代应用创建了一个有限顺序流，产生一个值流：`seed`，`f(seed)`，`f(f(seed))`，等等，只要第三个参数`hasNext`函数返回`true`。'
- en: 'The following code demonstrates the usage of these methods, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些方法的用法，如下所示：
- en: '[PRE41]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that we were forced to add an intermediate operator, `limit(int n)`, to
    the first pipeline to avoid generating an infinite number of generated values.
    We will talk more about this method in the *Intermediate operations* subsection.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们被迫向第一个管道添加了一个中间操作符`limit(int n)`，以避免生成无限数量的生成值。我们将在*中间操作*子节中更多地讨论此方法。
- en: concat (stream a and stream b)
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接（流a和流b）
- en: 'The `Stream<T> concat(Stream<> a, Stream<T> b)` static method of the `Stream`
    interface creates a stream of values based on two streams, `a` and `b`, passed
    in as parameters. The newly created stream consists of all the elements of the
    first parameter, `a`, followed by all the elements of the second parameter, `b`.
    The following code demonstrates this method:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T> concat(Stream<> a, Stream<T> b)`的静态方法`Stream`接口根据传入的参数`a`和`b`创建一个值流。新创建的流由第一个参数`a`的所有元素组成，后面跟着第二个参数`b`的所有元素。以下代码演示了此方法：'
- en: '[PRE45]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note that the `2` element is present in both original streams and consequently
    is emitted twice by the resulting stream.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`2`元素在原始流中都有，因此结果流会发出两次。
- en: generate (Supplier)
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成（供应商）
- en: 'The `Stream<T> generate(Supplier<T> supplier)` static method of the `Stream`
    interface creates an infinite stream, where each element is generated by the provided
    `Supplier<T>` function. The following are two examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口的`generate(Supplier<T> supplier)`静态方法创建一个无限流，其中每个元素都是由提供的`Supplier<T>`函数生成的。以下有两个示例：'
- en: '[PRE49]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you run this code, you will probably get different results because of the
    random (pseudo-random) nature of the generated values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你可能会因为生成的值具有随机（伪随机）性质而得到不同的结果。
- en: Since the created stream is infinite, we have added a `limit(int n)` operation
    that allows only the specified number of stream elements to flow through. We will
    talk more about this method in the *Intermediate operations* subsection.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建的流是无限的，我们添加了一个`limit(int n)`操作，它只允许指定的流元素数量通过。我们将在*中间操作*子节中更多地讨论此方法。
- en: The Stream.Builder interface
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Stream.Builder`接口'
- en: 'The `Stream.Builder<T> builder()` static method returns an internal (located
    inside the `Stream` interface) `Builder` interface that can be used to construct
    a `Stream` object. The interface `Builder` extends the `Consumer` interface and
    has the following methods:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.Builder<T> builder()`静态方法返回一个内部（位于`Stream`接口内部）的`Builder`接口，可以用来构建`Stream`对象。`Builder`接口扩展了`Consumer`接口，并具有以下方法：'
- en: '`default Stream.Builder<T> add(T t)`: This calls the `accept(T)` method and
    returns the `Builder` object, thus allowing you to chain the `add (T t)` methods
    in a fluent dot-connected style.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Stream.Builder<T> add(T t)`: 这个方法调用`accept(T)`方法并返回`Builder`对象，从而允许你以流畅的点连接方式链式调用`add(T
    t)`方法。'
- en: '`void accept(T t)`: This adds an element to the stream (this method comes from
    the `Consumer` interface).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void accept(T t)`: 这个方法向流中添加一个元素（此方法来自`Consumer`接口）。'
- en: '`Stream<T> build()`: This transitions this builder from the constructing state
    to the `built` state. After this method is called, no new elements can be added
    to this stream.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> build()`: 这个方法将构建器从构建状态转换为`built`状态。调用此方法后，无法向此流中添加新元素。'
- en: 'The usage of the `add(T t)` method is straightforward:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`add(T t)`方法的用法很简单：'
- en: '[PRE57]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note how we have added the `<String>` generics in front of the `builder()` method.
    This way, we tell the builder that the stream we are creating will have `String`-type
    elements. Otherwise, it will add the elements as `Object` types and not make sure
    that the added elements are of the `String` type.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何在`builder()`方法前添加了`<String>`泛型。这样，我们告诉构建器，我们创建的流将包含`String`类型的元素。否则，它将添加`Object`类型的元素，并且无法确保添加的元素是`String`类型。
- en: 'The `accept(T t)` method is used when the builder is passed as a parameter
    of the `Consumer<T>` type or when you do not need to chain the methods that add
    the elements. The following is a code example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建器作为`Consumer<T>`类型的参数传递，或者你不需要链式调用添加元素的方法时，会使用`accept(T t)`方法。以下是一个代码示例：
- en: '[PRE59]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `forEach(Consumer<T> consumer)` method accepts a `Consumer` function that
    has the `accept(T t)` method. Every time an element is emitted by the stream,
    the `forEach()` method receives it and passes it to the `accept(T t)` method of
    the `Builder` object. Then, when the `build()` method is called in the next line,
    the `Stream` object is created and starts emitting the elements added earlier
    by the `accept(T t)` method. The emitted elements are passed to the `forEach()`
    method, which then prints them one by one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach(Consumer<T> consumer)`方法接受一个具有`accept(T t)`方法的`Consumer`函数。每当流发出一个元素时，`forEach()`方法接收它并将其传递给`Builder`对象的`accept(T
    t)`方法。然后，在下一行调用`build()`方法时，创建`Stream`对象并开始发出之前通过`accept(T t)`方法添加的元素。发出的元素传递给`forEach()`方法，然后逐个打印它们。'
- en: 'Here is an example of an explicit usage of the `accept(T t)` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`accept(T t)`方法的一个显式使用示例：
- en: '[PRE62]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This time, we decided not to add all the list elements to the stream but only
    those that contain the `a` character. As expected, the created stream contains
    only the `cat` and `bear` elements. Also, note how we use `<String>` generics
    to make sure that all the stream elements are of the `String` type.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们决定不将所有列表元素添加到流中，而只添加包含`a`字符的元素。正如预期的那样，创建的流只包含`cat`和`bear`元素。同时，注意我们如何使用`<String>`泛型来确保所有流元素都是`String`类型。
- en: Other classes and interfaces
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类和接口
- en: 'In Java 8, two default methods were added to the `java.util.Collection` interface,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，向`java.util.Collection`接口添加了两个默认方法，如下所示：
- en: '`Stream<E> stream()`: This returns a stream of the elements of this collection.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<E> stream()`: 这将返回此集合的元素流。'
- en: '`Stream<E> parallelStream()`: This returns (possibly) a parallel stream of
    the elements of this collection – we say *possibly*, because the JVM attempts
    to split the stream into several chunks and process them in parallel (if there
    are several CPUs) or virtually parallel (using CPU time-sharing). However, it
    is not always possible and depends, in part, on the nature of the requested processing.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<E> parallelStream()`: 这将返回（可能）一个并行流，包含此集合的元素 – 我们说“可能”，因为 JVM 尝试将流分割成几个块，并在多个
    CPU 上并行处理（如果有多个 CPU）或使用 CPU 时间共享进行虚拟并行处理。然而，这并不总是可能的，部分取决于请求处理的性质。'
- en: 'This means that all the collection interfaces that extend this interface, including
    `Set` and `List`, have these methods, as shown in this example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有扩展此接口的集合接口，包括 `Set` 和 `List`，都有这些方法，如本示例所示：
- en: '[PRE70]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We will talk about parallel streams in the *Parallel streams* section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“并行流”部分讨论并行流。
- en: 'We described eight static overloaded `stream()` methods of the `java.util.Arrays`
    class at the beginning of the *Streams as a source of data and operations* section.
    Here is an example of another way of creating a stream, using the subset of an
    array:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在“流作为数据源和操作”部分的开始，我们描述了 `java.util.Arrays` 类的八个静态重载 `stream()` 方法。以下是通过数组子集创建流的一种另一种方法示例：
- en: '[PRE72]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `java.util.Random` class allows you to create numeric streams of pseudo-random
    values, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Random` 类允许您创建伪随机数值的数值流，如下所示：'
- en: '`DoubleStream doubles()`: Creates an unlimited stream of `double` values between
    `0` (inclusive) and `1` (exclusive)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream doubles()`: 创建一个无限流，包含 `double` 值，介于 `0`（包含）和 `1`（不包含）'
- en: '`IntStream ints()` and `LongStream longs()`: Creates an unlimited stream of
    corresponding type values'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints()` 和 `LongStream longs()`: 创建一个无限流，包含相应类型的值'
- en: '`DoubleStream doubles(long streamSize)`: Creates a stream (of the specified
    size) of `double` values between `0` (inclusive) and `1` (exclusive)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream doubles(long streamSize)`: 创建一个大小为指定值的 `double` 值流，介于 `0`（包含）和
    `1`（不包含）'
- en: '`IntStream ints(long streamSize)` and `LongStream longs(long streamSize)`:
    Creates a stream of the specified size of the corresponding type values'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints(long streamSize)` 和 `LongStream longs(long streamSize)`: 创建一个大小为指定类型值的流'
- en: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`: Creates an
    unlimited stream of `int` values between `randomNumberOrigin` (inclusive) and
    `randomNumberBound` (exclusive)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`: 创建一个无限流，包含
    `int` 值，介于 `randomNumberOrigin`（包含）和 `randomNumberBound`（不包含）'
- en: '`LongStream longs(long randomNumberOrigin, long randomNumberBound)`: Creates
    an unlimited stream of `long` values between `randomNumberOrigin` (inclusive)
    and `randomNumberBound` (exclusive)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream longs(long randomNumberOrigin, long randomNumberBound)`: 创建一个无限流，包含
    `long` 值，介于 `randomNumberOrigin`（包含）和 `randomNumberBound`（不包含）'
- en: '`DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)`:
    Creates a stream of the specified size of `double` values between `randomNumberOrigin`
    (inclusive) and `randomNumberBound` (exclusive)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)`:
    创建一个大小为指定值的 `double` 值流，这些值介于 `randomNumberOrigin`（包含）和 `randomNumberBound`（不包含）'
- en: 'Here is an example of one of the preceding methods:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个前面方法的示例：
- en: '[PRE75]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Due to the use of `random`, every execution may (and probably will) generate
    a different result.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了 `random`，每次执行都可能（并且很可能）生成不同的结果。
- en: 'The `java.nio.file.Files` class has six static methods creating streams of
    lines and paths, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file.Files` 类有六个静态方法创建行和路径流，如下所示：'
- en: '`Stream<String> lines(Path path)`: Creates a stream of lines from the file
    specified by the provided path'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> lines(Path path)`: 从提供的路径指定的文件创建行流'
- en: '`Stream<String> lines(Path path, Charset cs)`: Creates a stream of lines from
    the file specified by the provided path; bytes from the file are decoded into
    characters using the provided `charset`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> lines(Path path, Charset cs)`: 从提供的路径指定的文件创建行流；使用提供的 `charset`
    将文件字节解码为字符'
- en: '`Stream<Path> list(Path dir)`: Creates a stream of files and directories in
    the specified directory'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> list(Path dir)`: 创建指定目录中的文件和目录流'
- en: '`Stream<Path> walk(Path start, FileVisitOption... options)`: Creates a stream
    of files and directories of the file tree that starts with `Path start`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> walk(Path start, FileVisitOption... options)`: 创建从 `Path start`
    开始的文件树中的文件和目录流'
- en: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    Creates a stream of files and directories of the file tree that starts with `Path
    start`, down to the specified `maxDepth` depth'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    创建从 `Path start` 开始的文件和目录的文件树流，直到指定的 `maxDepth` 深度'
- en: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: Creates a stream of files and directories
    (that match the provided predicate) of the file tree that starts with `Path start`,
    down to the specified depth, specified by the `maxDepth` value'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: 创建从 `Path start` 开始的文件和目录（匹配提供的谓词）的文件树流，直到指定的
    `maxDepth` 深度'
- en: 'Other classes and methods that create streams include the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 其他创建流的类和方法包括以下内容：
- en: The `java.util.BitSet` class has the `IntStream stream()` method, which creates
    a stream of indices, for which this `BitSet` contains a bit in the `set` state.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.BitSet` 类具有 `IntStream stream()` 方法，该方法创建一个索引流，对于这个 `BitSet`，它包含在
    `set` 状态下的位。'
- en: The `java.io.BufferedReader` class has the `Stream<String> lines()` method,
    which creates a stream of lines from this `BufferedReader` object, typically from
    a file.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io.BufferedReader` 类具有 `Stream<String> lines()` 方法，该方法从这个 `BufferedReader`
    对象创建一个流，通常是来自文件。'
- en: The `java.util.jar.JarFile` class has the `Stream<JarEntry> stream()` method
    that creates a stream of ZIP file entries.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.jar.JarFile` 类具有 `Stream<JarEntry> stream()` 方法，该方法创建一个 ZIP 文件条目的流。'
- en: The `java.util.regex.Pattern` class has the `Stream<String> splitAsStream(CharSequence
    input)` method, which creates a stream from the provided sequence around matches
    of this pattern.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.regex.Pattern` 类具有 `Stream<String> splitAsStream(CharSequence input)`
    方法，该方法从提供的序列中创建一个流，围绕此模式的匹配项。'
- en: 'A `java.lang.CharSequence` interface has two methods, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.CharSequence` 接口有两个方法，如下所示：'
- en: '`default IntStream chars()`: Creates a stream of `int`, zero-extending the
    `char` values'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default IntStream chars()`: 创建一个 `int` 流，将 `char` 值零扩展'
- en: '`default IntStream codePoints()`: Creates a stream of code point values from
    this sequence'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default IntStream codePoints()`: 从这个序列创建一个代码点值的流'
- en: There is also a `java.util.stream.StreamSupport` class that contains static
    low-level utility methods for library developers. However, we won’t be reviewing
    it, as this is outside the scope of this book.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `java.util.stream.StreamSupport` 类，它包含用于库开发者的静态低级实用方法。然而，我们不会对其进行审查，因为这超出了本书的范围。
- en: Operations (methods)
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作（方法）
- en: Many methods of the `Stream` interface, including those that have a functional
    interface type as a parameter, are called `parameter` method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 接口中的许多方法，包括那些参数为函数接口类型的方法，被称为 `parameter` 方法。'
- en: 'For example, let’s look at the `Stream<T> filter (Predicate<T> predicate)`
    method. Its implementation is based on the call to the `test(T t)` method Boolean
    of the `Predicate<T>` function. So, instead of saying, *we use the* `filter()`
    *method of the* `Stream` *object to select some of the stream elements and skip
    others,* programmers prefer to say, *we apply an operation filter that allows
    some of the stream elements to get through and skip others*. It describes the
    nature of the action (operation), not the particular algorithm, which is unknown
    until the method receives a particular function. There are two groups of operations
    in the `Stream` interface, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看 `Stream<T> filter (Predicate<T> predicate)` 方法。它的实现基于对 `Predicate<T>`
    函数的 `test(T t)` 方法 Boolean 的调用。因此，与其说“我们使用 `Stream` 对象的 `filter()` 方法来选择一些流元素并跳过其他元素”，程序员更愿意说“我们应用一个过滤操作，允许一些流元素通过并跳过其他元素”。这描述了操作（操作）的本质，而不是特定的算法，直到方法接收到特定的函数才知道。`Stream`
    接口中有两组操作，如下所示：
- en: '`Stream` object'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream` 对象'
- en: '`Stream`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`'
- en: Stream processing is organized typically as a pipeline, using a fluent (dot-connected)
    style. A `Stream`-creating method or another stream source starts such a pipeline.
    A terminal operation produces the final result or a side effect and eponymously
    ends the pipeline. An intermediate operation can be placed between the originating
    `Stream` object and the terminal operation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理通常组织成一个管道，使用流畅（点连接）风格。一个创建 `Stream` 的方法或另一个流源开始这样一个管道。终端操作产生最终结果或副作用，并以此结束管道。中间操作可以放置在原始
    `Stream` 对象和终端操作之间。
- en: 'An intermediate operation processes stream elements (or not, in some cases)
    and returns the modified (or not) `Stream` object, so the next intermediate or
    terminal operation can be applied. Examples of intermediate operations are the
    following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作处理流元素（在某些情况下可能不处理）并返回修改后的（或未修改的）`Stream`对象，以便下一个中间或终端操作可以应用。以下是一些中间操作的例子：
- en: '`Stream<T> filter(Predicate<T> predicate)`: Selects only elements matching
    a criterion.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> filter(Predicate<T> predicate)`: 仅选择符合特定标准的元素。'
- en: '`Stream<R> map(Function<T,R> mapper)`: Transforms elements according to the
    passed-in function. Note that the type of the returned `Stream` object may be
    quite different from the input type.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<R> map(Function<T,R> mapper)`: 根据传入的函数转换元素。注意，返回的`Stream`对象类型可能与输入类型大不相同。'
- en: '`Stream<T> distinct()`: Removes duplicates.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> distinct()`: 删除重复项。'
- en: '`Stream<T> limit(long maxSize)`: Limits a stream to the specified number of
    elements.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> limit(long maxSize)`: 限制流到指定的元素数量。'
- en: '`Stream<T> sorted()`: Arranges the stream elements in a certain order.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> sorted()`: 按特定顺序排列流元素。'
- en: We will discuss some other intermediate operations in the *Intermediate operations*
    section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*中间操作*节中讨论一些其他中间操作。
- en: The processing of the stream elements actually begins only when a terminal operation
    starts executing. Then, all the intermediate operations (if present) start processing
    in sequence. As soon as the terminal operation has finished execution, the stream
    closes and cannot be reopened.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 流元素的真正处理实际上只有在终端操作开始执行时才开始。然后，所有中间操作（如果有的话）按顺序开始处理。一旦终端操作完成执行，流就会关闭，无法重新打开。
- en: Examples of terminal operations are `forEach()`, `findFirst()`, `reduce()`,
    `collect()`, `sum()`, `max()`, and other methods of the `Stream` interface that
    do not return the `Stream` object. We will discuss them in the *Terminal operations*
    subsection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作的例子有`forEach()`、`findFirst()`、`reduce()`、`collect()`、`sum()`、`max()`以及`Stream`接口的其他不返回`Stream`对象的方法。我们将在*终端操作*子节中讨论它们。
- en: All the `Stream` operations support parallel processing, which is especially
    helpful in the case of a large amount of data processed on a multi-core computer.
    We will discuss it in the *Parallel streams* subsection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Stream`操作都支持并行处理，这在处理多核计算机上的大量数据时特别有帮助。我们将在*并行流*子节中讨论它。
- en: Intermediate operations
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间操作
- en: As we mentioned already, an intermediate operation returns a `Stream` object
    that emits the same or modified values and may even be of a different type than
    the stream source.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，中间操作返回一个`Stream`对象，该对象发出相同的或修改后的值，甚至可能不同于流源的类型。
- en: The intermediate operations can be grouped by their functionality into four
    categories of operations that perform **filtering**, **mapping**, **sorting**,
    or **peeking**.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作可以根据其功能分为四个类别，这些类别执行**过滤**、**映射**、**排序**或**查看**操作。
- en: Filtering
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 过滤
- en: 'This group includes operations that remove duplicates, skip some of the elements,
    limit the number of processed elements, and select for further processing only
    those that pass certain criteria, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包括以下操作，用于删除重复项、跳过一些元素、限制处理元素的数量，以及仅选择通过某些标准筛选的元素：
- en: '`Stream<T> distinct()`: Compares stream elements using `Object.equals(Object)`
    method and skips duplicates'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> distinct()`: 使用`Object.equals(Object)`方法比较流元素并跳过重复项'
- en: '`Stream<T> skip(long n)`: Ignores the provided number of stream elements that
    are emitted first'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> skip(long n)`: 忽略提供的第一个指定数量的流元素'
- en: '`Stream<T> limit(long maxSize)`: Allows only the provided number of stream
    elements to be processed'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> limit(long maxSize)`: 仅允许处理提供的指定数量的流元素'
- en: '`Stream<T> filter(Predicate<T> predicate)`: Allows only those elements to be
    processed that result in `true` when processed by the provided `Predicate` function'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> filter(Predicate<T> predicate)`: 仅允许通过提供的`Predicate`函数处理结果为`true`的元素被处理'
- en: '`default Stream<T> dropWhile(Predicate<T> predicate)`: Skips those first elements
    of the stream that result in `true` when processed by the provided `Predicate`
    function'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Stream<T> dropWhile(Predicate<T> predicate)`: 跳过流中那些通过提供的`Predicate`函数处理结果为`true`的第一个元素'
- en: '`default Stream<T> takeWhile(Predicate<T> predicate)`: Allows only those first
    elements of the stream to be processed that result in `true` when processed by
    the provided `Predicate` function'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Stream<T> takeWhile(Predicate<T> predicate)`: 仅允许流中那些通过提供的`Predicate`函数处理结果为`true`的第一个元素被处理'
- en: 'The following is code that demonstrates how the operations just described work:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了刚刚描述的操作是如何工作的：
- en: '[PRE77]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that we were able to reuse the source `List<String>` object but could not
    reuse the `Stream` object. Once a `Stream` object is closed, it cannot be reopened.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够重用源 `List<String>` 对象，但不能重用 `Stream` 对象。一旦 `Stream` 对象关闭，就无法重新打开。
- en: Mapping
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: 'This group includes arguably the most important intermediate operations. They
    are the only intermediate operations that modify the elements of the stream. They
    **map** (transform) the original stream element value to a new one, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这组操作可能是最重要的中间操作。它们是唯一修改流元素的中间操作。它们 **映射**（转换）原始流元素值到一个新的值，如下所示：
- en: '`Stream<R> map(Function<T, R> mapper)`: Applies the provided function to each
    element of type `T` of the stream and produces a new element value of type `R`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<R> map(Function<T, R> mapper)`: 将提供的函数应用于流中每个类型为 `T` 的元素，并生成一个类型为 `R`
    的新元素值'
- en: '`IntStream mapToInt(ToIntFunction<T> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a new element value of
    type `int`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream mapToInt(ToIntFunction<T> mapper)`: 将提供的函数应用于流中每个类型为 `T` 的元素，并生成一个类型为
    `int` 的新元素值'
- en: '`LongStream mapToLong(ToLongFunction<T> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a new element value of
    type `long`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream mapToLong(ToLongFunction<T> mapper)`: 将提供的函数应用于流中每个类型为 `T` 的元素，并生成一个类型为
    `long` 的新元素值'
- en: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a new element
    value of type `double`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: 将提供的函数应用于流中每个类型为 `T`
    的元素，并生成一个类型为 `double` 的新元素值'
- en: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a `Stream<R>` object that
    emits elements of type `R`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: 将提供的函数应用于流中每个类型为 `T` 的元素，并生成一个发出类型为
    `R` 的元素的 `Stream<R>` 对象'
- en: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a `IntStream`
    object that emits elements of type `int`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: 将提供的函数应用于流中每个类型为 `T`
    的元素，并生成一个发出类型为 `int` 的元素的 `IntStream` 对象'
- en: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a `LongStream`
    object that emits elements of type `long`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: 将提供的函数应用于流中每个类型为
    `T` 的元素，并生成一个发出类型为 `long` 的 `LongStream` 对象'
- en: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: Applies the
    provided function to each element of type `T` of the stream and produces a `DoubleStream`
    object that emits elements of type `double`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: 将提供的函数应用于流中每个类型为
    `T` 的元素，并生成一个发出类型为 `double` 的 `DoubleStream` 对象'
- en: 'The following are examples of the usage of these operations, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用这些操作的示例，如下所示：
- en: '[PRE89]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In the last example, by converting the stream to `DoubleStream`, we transformed
    each numeric value to a `String` object and added white space, so the result can
    be printed with whitespace between the numbers. These examples are very simple
    – just conversion with minimal processing. But in real life, each `map()` or `flatMap()`
    operation typically accepts a more complex function that does something more useful.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，通过将流转换为 `DoubleStream`，我们将每个数值转换为 `String` 对象并添加空格，因此结果可以在数字之间打印空格。这些示例非常简单——只是转换，处理最少。但在现实生活中，每个
    `map()` 或 `flatMap()` 操作通常接受一个更复杂的函数，执行更有用的操作。
- en: Sorting
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: 'The following two intermediate operations sort the stream elements, as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个中间操作按顺序对流元素进行排序，如下所示：
- en: '`Stream<T> sorted()`: Sorts stream elements in natural order (according to
    their `Comparable` interface implementation)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> sorted()`: 按自然顺序（根据其 `Comparable` 接口的实现）对流元素进行排序'
- en: '`Stream<T> sorted(Comparator<T> comparator)`: Sorts stream elements in order
    according to the provided `Comparator<T>` object'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> sorted(Comparator<T> comparator)`: 按提供的 `Comparator<T>` 对象的顺序对流元素进行排序'
- en: Naturally, these operations cannot be finished until all the elements are emitted,
    so such processing creates a lot of overhead, slows down performance, and has
    to be used for small streams.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这些操作必须在所有元素发出后才能完成，因此这种处理会产生大量开销，降低性能，并且必须用于小流。
- en: 'Here is some demo code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些演示代码：
- en: '[PRE116]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Peeking
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预览
- en: 'An intermediate `Stream<T> peek(Consumer<T> action)` operation applies the
    provided `Consumer<T>` function to each stream element but does not change the
    stream values (`Consumer<T>` returns `void`). This operation is used for debugging.
    The following code shows how it works:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作`Stream<T> peek(Consumer<T> action)`将提供的`Consumer<T>`函数应用于每个流元素，但不更改流值（`Consumer<T>`返回`void`）。此操作用于调试。以下代码显示了它是如何工作的：
- en: '[PRE121]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Terminal operations
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端操作
- en: '**Terminal operations** are the most important operations in a stream pipeline.
    It is possible to accomplish everything in them without using any other operations.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端操作**是流管道中最重要的操作。可以在其中完成所有操作，而无需使用任何其他操作。'
- en: We have already used the `forEach(Consumer<T>)` terminal operation to print
    each element. It does not return a value, thus it is used for its side effects.
    However, the `Stream` interface has many more powerful terminal operations that
    do return values.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`forEach(Consumer<T>)`终端操作来打印每个元素。它不返回值，因此它用于其副作用。然而，`Stream`接口有许多更强大的终端操作，它们确实返回值。
- en: 'Chief among them is the `collect()` operation, which has two forms, as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最重要的是`collect()`操作，它有两种形式，如下所示：
- en: '`R collect(Collector<T, A, R> collector)`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Collector<T, A, R> collector)`'
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`'
- en: 'This allows you to compose practically any process that can be applied to a
    stream. The classic example is as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您编写可以应用于流的任何过程。以下是一个经典示例：
- en: '[PRE125]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This example is used in such a way as to be suitable for parallel processing.
    The first parameter of the `collect()` operation is a function that produces a
    value based on the stream element. The second parameter is the function that accumulates
    the result. The third parameter is the function that combines the accumulated
    results from all the threads that processed the stream.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的使用方式使其适合并行处理。`collect()`操作的第一个参数是一个基于流元素的函数，它产生一个值。第二个参数是累积结果的函数。第三个参数是结合所有处理流的所有线程的累积结果的函数。
- en: However, having only one such generic terminal operation will force programmers
    to write the same functions repeatedly. That is why the API authors added the
    `Collectors` class, which generates many specialized `Collector` objects without
    the need to create three functions for every `collect()` operation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有一个这样的通用终端操作将迫使程序员反复编写相同的函数。这就是为什么API作者添加了`Collectors`类，它可以在不需要为每个`collect()`操作创建三个函数的情况下生成许多专门的`Collector`对象。
- en: In addition to that, the API authors added to the `Stream` interface various
    even more specialized terminal operations that are much simpler and easier to
    use. In this section, we will review all the terminal operations of the `Stream`
    interface and, in the `Collect` subsection, look at the plethora of `Collector`
    objects produced by the `Collectors` class. We will start with the most simple
    terminal operation that allows you to process each element of this stream one
    at a time.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，API作者还向`Stream`接口添加了各种更加专业的终端操作，这些操作更加简单且易于使用。在本节中，我们将回顾`Stream`接口的所有终端操作，并在`Collect`子节中查看由`Collectors`类产生的众多`Collector`对象。我们将从最简单的终端操作开始，该操作允许您逐个处理此流中的每个元素。
- en: 'In our examples, we are going to use the following class, `Person`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用以下类，`Person`：
- en: '[PRE130]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Processing each element
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理每个元素
- en: 'There are two terminal operations in this group, as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 该组中有两个终端操作，如下所示：
- en: '`void forEach(Consumer<T> action)`: Applies the provided action for each element
    of this stream'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEach(Consumer<T> action)`: 对此流中的每个元素应用提供的操作'
- en: '`void forEachOrdered(Consumer<T> action)`: Applies the provided action for
    each element of this stream in the order defined by the source, regardless of
    whether the stream is sequential or parallel'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEachOrdered(Consumer<T> action)`: 对此流中的每个元素应用提供的操作，顺序由源定义，无论流是顺序的还是并行的'
- en: If the order in which you need the elements to be processed is important and
    has to be the order in which values are arranged at the source, use the second
    method, especially if you can foresee that it is possible your code is going to
    be executed on a computer with several CPUs. Otherwise, use the first one, as
    we did in all our examples.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理元素顺序并且这个顺序必须与源中值排列的顺序一致，请使用第二种方法，尤其是如果你能预见你的代码可能会在具有多个CPU的计算机上执行。否则，使用第一种方法，就像我们在所有示例中所做的那样。
- en: 'Let’s see an example of the `forEach()` operation in use for reading comma-separated
    values (age and name) from a file and creating `Person` objects. We have placed
    the following `persons.csv` file (`resources` folder:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`forEach()`操作的一个示例，用于从文件中读取逗号分隔的值（年龄和姓名）并创建`Person`对象。我们放置了以下`persons.csv`文件（`resources`文件夹中）：
- en: '[PRE145]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: We have added spaces inside and outside the values in order to take this opportunity
    to show you some simple but very useful tips for working with real-life data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在值内部和外部添加了空格，以便利用这个机会向您展示一些简单但非常实用的技巧，用于处理现实生活中的数据。
- en: 'First, we will just read the file and display its content line by line, but
    only those lines that contain the letter `J` (adjust the path value or set it
    to `absolute` if the code cannot find the `persons.csv` file):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将只读取文件并逐行显示其内容，但只显示包含字母`J`的行（调整路径值或将其设置为`绝对路径`，如果代码找不到`persons.csv`文件）：
- en: '[PRE149]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: That is a typical way of using the `forEach()` operation – processing each element
    independently. This code also provides an example of a try-with-resources construct
    that closes the `BufferedReader` object automatically.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的使用`forEach()`操作的方式——独立处理每个元素。此代码还提供了一个try-with-resources结构的示例，该结构会自动关闭`BufferedReader`对象。
- en: 'The following is how an inexperienced programmer might write code that reads
    the stream elements from the `Stream<String> lines` object and creates a list
    of `Person` objects:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有经验的程序员可能会编写的代码，用于从`Stream<String> lines`对象中读取流元素并创建`Person`对象列表：
- en: '[PRE157]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: You can see how the `split()` method is used to break each line by a comma that
    separates the values and how the `org.apache.commons.lang3.StringUtils.remove()`
    method removes spaces from each value. Although this code works well in small
    examples on a single-core computer, it might create unexpected results with a
    long stream and parallel processing.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`split()`方法是如何被用来通过分隔值的逗号来分割每一行的，以及`org.apache.commons.lang3.StringUtils.remove()`方法是如何从每个值中删除空格的。尽管这段代码在单核计算机上的小示例中运行良好，但它可能在长流和并行处理中产生意外的结果。
- en: This is the reason that lambda expressions require all variables to be final
    or effectively final – so that the same function can be executed in a different
    context.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么lambda表达式要求所有变量必须是final或实际上是final的原因——这样相同的函数就可以在不同的上下文中执行。
- en: 'The following is a correct implementation of the preceding code:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的正确实现：
- en: '[PRE164]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'To improve readability, we can create a method that does the job of mapping:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，我们可以创建一个执行映射工作的方法：
- en: '[PRE171]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Now, we can use it as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样使用它：
- en: '[PRE175]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: As you can see, we have used the `collect()` operator and the `Collector` function
    created by the `Collectors.toList()` method. We will see more functions created
    by the `Collectors` class in the *Collect* subsection.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用了`collect()`操作符和由`Collectors.toList()`方法创建的`Collector`函数。我们将在*收集*子部分中看到由`Collectors`类创建的更多函数。
- en: Counting all elements
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数所有元素
- en: 'The `long count()` terminal operation of the `Stream` interface looks straightforward
    and benign. It returns the number of elements in this stream. Those who are used
    to working with collections and arrays may use the `count()` operation without
    thinking twice. The following code snippet demonstrates a caveat:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口的`long count()`终端操作看起来简单且无害。它返回此流中的元素数量。那些习惯于使用集合和数组的人可能会不加思考地使用`count()`操作。以下代码片段演示了一个注意事项：'
- en: '[PRE179]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'If we run the preceding code, the result will look as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，结果将如下所示：
- en: '![](img/B18388_Figure_14.1.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_14.1.jpg)'
- en: As you see, the code that implements the `count()` method was able to determine
    the stream size without executing all the pipelines. The `peek()` operation did
    not print anything, which proves that elements were not emitted. So, if you expected
    to see the values of the stream printed, you might be puzzled and expect that
    the code has some kind of defect.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，实现`count()`方法的代码能够确定流的大小而不需要执行所有管道。`peek()`操作没有打印任何内容，这证明了元素没有被发出。所以，如果你期望看到流中的值被打印出来，你可能会感到困惑，并期望代码存在某种缺陷。
- en: Another caveat is that it is not always possible to determine the stream size
    at the source. Besides, the stream may be infinite. So, you have to use `count()`
    with care.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个注意事项是，在源处并不总是可以确定流的大小。此外，流可能是无限的。因此，你必须小心使用`count()`。
- en: 'Another possible way to determine the stream size is by using the `collect()`
    operation:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 确定流大小的另一种可能方法是使用`collect()`操作：
- en: '[PRE183]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The following screenshot shows what happens after the preceding code example
    has been run:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在运行前面的代码示例之后发生的情况：
- en: '![](img/B18388_Figure_14.2.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18388_Figure_14.2.jpg)'
- en: As you can see, the `collect()` operation does not calculate the stream size
    at the source. That is because the `collect()` operation is not as specialized
    as the `count()` operation. It just applies the passed-in collector to the stream.
    The collector just counts the elements provided to it by the `collect()` operation.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`collect()`操作没有在源处计算流的大小。这是因为`collect()`操作不像`count()`操作那样专门化。它只是将传入的收集器应用于流。收集器只是计算`collect()`操作提供的元素数量。
- en: Match all, any, or none
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配全部、任意或没有
- en: 'There are three seemingly very similar terminal operations that allow us to
    assess whether all, any, or none of the stream elements have a certain value,
    as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种看似非常相似的终端操作，允许我们评估流中的元素是否全部、任意或没有任何一个具有特定的值，如下所示：
- en: '`boolean allMatch(Predicate<T> predicate)`: Returns `true` when each of the
    stream elements returns `true` when used as a parameter of the provided `Predicate<T>`
    function'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean allMatch(Predicate<T> predicate)`: 当流中的每个元素作为提供的`Predicate<T>`函数的参数返回`true`时，返回`true`'
- en: '`boolean anyMatch(Predicate<T> predicate)`: Returns `true` when one of the
    stream elements returns `true` when used as a parameter of the provided `Predicate<T>`
    function'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean anyMatch(Predicate<T> predicate)`: 当流中的某个元素作为提供的`Predicate<T>`函数的参数返回`true`时，返回`true`'
- en: '`boolean noneMatch(Predicate<T> predicate)`: Returns `true` when none of the
    stream elements return `true` when used as a parameter of the provided `Predicate<T>`
    function'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean noneMatch(Predicate<T> predicate)`: 当流中的没有任何元素作为提供的`Predicate<T>`函数的参数返回`true`时，返回`true`'
- en: 'The following are examples of their usage:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用示例：
- en: '[PRE187]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Please note that all these operations are optimized so as not to process all
    the stream elements if the result can be determined early.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些操作都进行了优化，以便在结果可以提前确定的情况下，不会处理所有流元素。
- en: Find any or first
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找任意或第一个
- en: 'The following terminal operations allow you to find any element or the first
    element of the stream correspondingly, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 以下终端操作允许你找到流中的任意元素或第一个元素，如下所示：
- en: '`Optional<T> findAny()`: Returns `Optional` with the value of any element of
    the stream, or an empty `Optional` if the stream is empty'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> findAny()`: 返回流中任意元素的`Optional`值，如果流为空则返回一个空的`Optional`'
- en: '`Optional<T> findFirst()`: Returns an `Optional` with the value of the first
    element of the stream, or an empty `Optional` if the stream is empty'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> findFirst()`: 返回流中第一个元素的`Optional`值，如果流为空则返回一个空的`Optional`'
- en: 'The following examples illustrate these operations:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这些操作：
- en: '[PRE200]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: In the first and third of the preceding examples, the `findAny()` and `findFirst()`
    operations produce the same result – they both find the first element of the stream.
    But in parallel processing, the result may be different.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中的第一个和第三个例子中，`findAny()`和`findFirst()`操作产生相同的结果——它们都找到了流中的第一个元素。但在并行处理中，结果可能会有所不同。
- en: When the stream is broken into several parts for parallel processing, the `findFirst()`
    operation always returns the first element of the stream, while the `findAny()`
    operation returns the first element only in one of the processing threads.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当流被分成几个部分进行并行处理时，`findFirst()`操作总是返回流中的第一个元素，而`findAny()`操作只在其中一个处理线程中返回第一个元素。
- en: Now, let’s talk about `class java.util.Optional` in more detail.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地谈谈`class java.util.Optional`。
- en: Optional class
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Optional类
- en: 'The object of `java.util.Optional` is used to avoid returning `null` (as it
    may cause `NullPointerException`). Instead, an `Optional` object provides methods
    that allow you to check for the presence of a value and substitute it with a predefined
    value if the return value is `null`, as shown in the following example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Optional` 对象用于避免返回 `null`（因为它可能引发 `NullPointerException`）。相反，`Optional`
    对象提供了允许你检查值是否存在，并在返回值为 `null` 时用预定义值替换它的方法，如下例所示：'
- en: '[PRE212]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'As you can see, if the `Optional` object is empty, then the following applies,
    as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果 `Optional` 对象为空，则以下适用，如下所示：
- en: The `or()` method of the `Optional` class allows you to return an alternative
    `Optional` object.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional` 类的 `or()` 方法允许你返回一个替代的 `Optional` 对象。'
- en: The `orElse()` method allows you to return an alternative value.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse()` 方法允许你返回一个替代值。'
- en: The `orElseGet()` method allows you to provide the `Supplier` function, which
    returns an alternative value.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet()` 方法允许你提供 `Supplier` 函数，该函数返回一个替代值。'
- en: The `ifPresentOrElse()` method allows you to provide two functions – one that
    consumes the value from the `Optional` object, and another one that does something
    else if the `Optional` object is empty.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse()` 方法允许你提供两个函数——一个用于从 `Optional` 对象中消费值，另一个在 `Optional` 对象为空时执行其他操作。'
- en: Minimum and maximum
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小值和最大值
- en: 'The following terminal operations return the minimum or maximum value of stream
    elements, if present, as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下终端操作返回流元素的最小值或最大值，如果存在，如下所示：
- en: '`Optional<T> min(Comparator<T> comparator)`: Returns the minimum element of
    this stream using the provided `Comparator` object'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> min(Comparator<T> comparator)`: 使用提供的 `Comparator` 对象返回此流的最小元素'
- en: '`Optional<T> max(Comparator<T> comparator)`: Returns the maximum element of
    this stream using the provided `Comparator` object'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> max(Comparator<T> comparator)`: 使用提供的 `Comparator` 对象返回此流的最大元素'
- en: 'The following code demonstrates this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这一点：
- en: '[PRE239]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'As you can see, in the case of non-numerical values, the minimum element is
    the one that is first when ordered from left to right, according to the provided
    comparator. The maximum, accordingly, is the last element. In the case of numeric
    values, the minimum and maximum are just that – the smallest and biggest numbers
    among the stream elements:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在非数值的情况下，最小元素是按照提供的比较器从左到右排序时第一个出现的元素。相应地，最大值是最后一个元素。在数值的情况下，最小值和最大值只是流元素中的最小和最大数字：
- en: '[PRE248]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'Let’s look at another example, using the `Person` class. The task is to find
    the oldest person in the following list:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子，使用 `Person` 类。任务是找到以下列表中的最年长者：
- en: '[PRE256]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'In order to do that, we can create the following `Comparator<Person>` that
    compares `Person` objects only by age:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以创建以下 `Comparator<Person>`，它仅通过年龄比较 `Person` 对象：
- en: '[PRE260]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Then, using this comparator, we can find the oldest person:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用此比较器，我们可以找到最年长者：
- en: '[PRE261]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: To array
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转为数组
- en: 'The following two terminal operations generate an array that contains stream
    elements, as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个终端操作生成一个包含流元素的数组，如下所示：
- en: '`Object[] toArray()`: Creates an array of objects; each object is an element
    of the stream'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object[] toArray()`: 创建一个对象数组；每个对象都是流中的一个元素'
- en: '`A[] toArray(IntFunction<A[]> generator)`: Creates an array of stream elements
    using the provided function'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A[] toArray(IntFunction<A[]> generator)`: 使用提供的函数创建一个流元素数组'
- en: 'Let’s look at some examples:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: '[PRE266]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'The first example is straightforward. It converts elements to an array of the
    same type. As for the second example, the representation of `IntFunction` as `String[]::new`
    is probably not obvious, so let’s walk through it. `String[]::new` is a method
    reference that represents the `i -> new String[i]` lambda expression because the
    `toArray()` operation receives from the stream not the elements but their count:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子很简单。它将元素转换为相同类型的数组。至于第二个例子，`IntFunction` 作为 `String[]::new` 的表示可能并不明显，所以让我们来分析一下。`String[]::new`
    是一个方法引用，它表示 `i -> new String[i]` lambda 表达式，因为 `toArray()` 操作接收的不是流中的元素，而是它们的数量：
- en: '[PRE271]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'We can prove it by printing an `i` value:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打印一个 `i` 值来证明这一点：
- en: '[PRE272]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'The `i -> new String[i]` expression is `IntFunction<String[]>` that, according
    to its documentation, accepts an `int` parameter and returns the result of the
    specified type. It can be defined using an anonymous class, as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`i -> new String[i]` 表达式是 `IntFunction<String[]>`，根据其文档，它接受一个 `int` 参数并返回指定类型的值。它可以定义为匿名类，如下所示：'
- en: '[PRE277]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'The `java.util.Collection` interface has a very similar method that converts
    a collection to an array:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Collection`接口有一个非常类似的方法，可以将集合转换为数组：'
- en: '[PRE283]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: The only difference is that `toArray()` of the `Stream` interface accepts a
    function, while the `toArray()` of the `Collection` interface takes an array.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是`Stream`接口的`toArray()`接受一个函数，而`Collection`接口的`toArray()`接受一个数组。
- en: Reduce
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少
- en: This terminal operation is called `reduce` because it processes all the stream
    elements and produces one value, thus reducing all the stream elements to one
    value. However, this is not the only operation that does it. The `collect` operation
    reduces all the values of the stream element to one result as well. In a way,
    all terminal operations are reductive. They produce one value after processing
    many elements.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这个终端操作被称为`reduce`，因为它处理所有流元素并产生一个值，从而将所有流元素减少到一个值。然而，这并不是唯一执行此操作的运算。`collect`操作也将流元素的值减少到一个结果。从某种意义上说，所有终端操作都是减少性的。它们在处理许多元素后产生一个值。
- en: So, you can view `reduce` and `collect` as synonyms that help to add structure
    and classification to many operations available in the `Stream` interface. Also,
    operations in the `reduce` group can be viewed as specialized versions of the
    `collect` operation because `collect()` can be tailored to provide the same functionality
    as the `reduce()` operation.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以将`reduce`和`collect`视为同义词，它们有助于为`Stream`接口中许多操作添加结构和分类。此外，`reduce`组中的操作可以看作是`collect`操作的专用版本，因为`collect()`可以根据需要提供与`reduce()`操作相同的功能。
- en: 'With all that said, let’s look at a group of `reduce` operations, as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们看看一组`reduce`操作，如下所示：
- en: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: Reduces the elements of
    the stream using the provided associative function that aggregates the elements;
    returns an `Optional` with the reduced value if available'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: 使用提供的关联函数来减少流元素，该函数聚合元素；如果可用，返回包含减少值的`Optional`'
- en: '`T reduce(T identity, BinaryOperator<T> accumulator)`: Provides the same functionality
    as the previous `reduce()` version but with the identity parameter used as the
    initial value for an accumulator or a default value if a stream is empty'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T reduce(T identity, BinaryOperator<T> accumulator)`: 提供与之前`reduce()`版本相同的功能，但使用身份参数作为累加器的初始值或如果流为空时的默认值'
- en: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    Provides the same functionality as the previous `reduce()` versions but, in addition,
    uses the `combiner` function to aggregate the results when this operation is applied
    to a parallel stream; if the stream is not parallel, the `combiner` function is
    not used'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    提供与之前`reduce()`版本相同的功能，但除此之外，当此操作应用于并行流时，它还使用`combiner`函数来聚合结果；如果流不是并行的，则不使用`combiner`函数'
- en: 'To demonstrate the `reduce()` operation, we are going to use the same `Person`
    class we have used before and the same list of `Person` objects as the source
    for our stream examples:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`reduce()`操作，我们将使用之前使用过的相同的`Person`类和相同的`Person`对象列表作为流示例的来源：
- en: '[PRE286]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Let’s find the oldest person in this list using the `reduce()` operation:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`reduce()`操作来找出这个列表中最年长的人：
- en: '[PRE290]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: The implementation is somewhat surprising, isn’t it? The `reduce()` operation
    takes an accumulator, but it seems it did not accumulate anything. Instead, it
    compares all stream elements. Well, the accumulator saves the result of the comparison
    and provides it as the first parameter for the next comparison (with the next
    element). You can say that the accumulator, in this case, accumulates the results
    of all previous comparisons.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 实现有些令人惊讶，不是吗？`reduce()`操作接受一个累加器，但它似乎没有累加任何东西。相反，它比较所有流元素。嗯，累加器保存比较的结果并将其作为下一次比较（与下一个元素）的第一个参数提供。你可以这样说，在这个例子中，累加器累积了所有先前比较的结果。
- en: 'Let’s now accumulate something explicitly. Let’s assemble all the names from
    a list of persons in one comma-separated list:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来明确地累加一些东西。让我们将人员名单中的所有名字组装成一个以逗号分隔的列表：
- en: '[PRE295]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: The notion of accumulation, in this case, makes a bit more sense, doesn’t it?
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，累积的概念更有意义，不是吗？
- en: 'Now, let’s use the `identity` value to provide some initial value:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`identity`值来提供一个初始值：
- en: '[PRE300]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'Note that this version of the `reduce()` operation returns `value`, not the
    `Optional` object. That is because, by providing the initial value, we guarantee
    that at least this value will be present in the result if the stream turns out
    to be empty. But the resulting string does not look as pretty as we hoped. Apparently,
    the provided initial value is treated as any other stream element, and a comma
    is added after it by the accumulator we have created. To make the result look
    pretty again, we can use the first version of the `reduce()` operation again and
    add the initial value this way:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个版本的 `reduce()` 操作返回 `value`，而不是 `Optional` 对象。这是因为，通过提供初始值，我们保证如果流为空，至少这个值将出现在结果中。但结果字符串看起来并不像我们希望的那样漂亮。显然，提供的初始值被当作任何其他流元素处理，并且由我们创建的累加器在其后添加了逗号。为了使结果再次看起来漂亮，我们可以再次使用
    `reduce()` 操作的第一种形式，并这样添加初始值：
- en: '[PRE305]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Alternatively, we can use a space as a separator instead of a comma:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用空格作为分隔符而不是逗号：
- en: '[PRE311]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: Now, the result looks better. While demonstrating the `collect()` operation
    in the next subsection, we will show a better way to create a comma-separated
    list of values with a prefix.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果看起来更好。在下一小节中演示 `collect()` 操作时，我们将展示一种更好的方法来创建带有前缀的逗号分隔值列表。
- en: 'Meanwhile, let’s continue to review the `reduce()` operation and look at its
    third form – the one with three parameters: `identity`, `accumulator`, and `combiner`.
    Adding combiner to the `reduce()` operation does not change the result:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们继续回顾 `reduce()` 操作，并看看它的第三种形式——带有三个参数的形式：`identity`（单位元）、`accumulator`（累加器）和`combiner`（组合器）。向
    `reduce()` 操作中添加组合器并不会改变结果：
- en: '[PRE316]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'This is because the stream is not parallel and the combiner is used only with
    a parallel stream. If we make the stream parallel, the result changes:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为流不是并行的，组合器只与并行流一起使用。如果我们使流并行，结果就会改变：
- en: '[PRE322]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Apparently, for a parallel stream, the sequence of elements is broken into
    subsequences, each processed independently, and their results aggregated by the
    combiner. While doing that, the combiner adds the initial value (identity) to
    each of the results. Even if we remove the combiner, the result of the parallel
    stream processing remains the same because a default combiner behavior is provided:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于并行流，元素序列被分割成子序列，每个子序列独立处理，然后由组合器聚合其结果。在这个过程中，组合器将初始值（单位元）添加到每个结果中。即使我们移除了组合器，并行流处理的结果仍然相同，因为默认组合器行为已经提供：
- en: '[PRE329]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'In the previous two forms of the `reduce()` operations, the identity value
    was used by the accumulator. In the third form, the `identity` value is used by
    the combiner (note that the `U` type is the combiner type). To get rid of the
    repetitive `identity` value in the result, we have decided to remove it (and the
    trailing space) from the second parameter in the combiner:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reduce()` 操作的前两种形式中，单位元值被累加器使用。在第三种形式中，`identity` 值被组合器使用（注意，`U` 类型是组合器类型）。为了从结果中去除重复的
    `identity` 值，我们决定从组合器的第二个参数中移除它（以及尾随空格）：
- en: '[PRE335]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: The result is as expected.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 结果正如预期的那样。
- en: 'In our string-based examples so far, the identity has not just been an initial
    value. It also served as an identifier (a label) in the resulting string. However,
    when the elements of the stream are numeric, the identity looks more like just
    an initial value. Let’s look at the following example:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的基于字符串的示例中，单位元不仅仅是一个初始值。它还在结果字符串中充当了一个标识符（标签）。然而，当流中的元素是数值时，单位元看起来更像只是一个初始值。让我们看看以下示例：
- en: '[PRE339]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'The first two of the pipelines are exactly the same, except that the second
    pipeline uses a method reference. The third and fourth pipelines have the same
    functionality too. They both use an initial value of `10`. Now, the first parameter
    makes more sense as the initial value than the identity, doesn’t it? In the fourth
    pipeline, we added a combiner, but it is not used because the stream is not parallel.
    Let’s make it parallel and see what happens:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个管道的前两个部分完全相同，只是第二个管道使用了方法引用。第三和第四个管道的功能也相同。它们都使用了一个初始值 `10`。现在，第一个参数作为初始值比作为单位元更有意义，不是吗？在第四个管道中，我们添加了一个组合器，但由于流不是并行的，所以它没有被使用。让我们将其变为并行，看看会发生什么：
- en: '[PRE354]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'The result is `36` because the initial value of `10` was added three times,
    with each partial result. Apparently, the stream was broken into three subsequences.
    However, it is not always the case, as the number of subsequences changes as the
    stream grows and the number of CPUs on the computer increases. This is why you
    cannot rely on a certain fixed number of subsequences, and it is better to not
    use a non-zero initial value with parallel streams:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `36`，因为初始值 `10` 被添加了三次，每次都是部分结果。显然，流被分成了三个子序列。然而，情况并不总是如此，因为随着流的增长和计算机上
    CPU 数量的增加，子序列的数量也会变化。这就是为什么你不能依赖于某个固定的子序列数量，并且最好在并行流中不使用非零初始值：
- en: '[PRE358]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: As you can see, we have set the identity to `0`, so every subsequence will get
    it, but the total is not affected when the result from all the processing threads
    is assembled by the combinator.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们将恒等值设置为 `0`，因此每个子序列都会得到它，但当所有处理线程的结果由组合器组装时，总和不会受到影响。
- en: Collect
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集
- en: Some of the usages of the `collect()` operation are very simple and can be easily
    mastered by any beginner, while other cases can be complex and not easy to understand,
    even for a seasoned programmer. Together with the operations discussed already,
    the most popular cases of `collect()` usage we present in this section are more
    than enough for all the needs a beginner may have and will cover most of the needs
    of a more experienced professional. Together with the operations of numeric streams
    (see the *Numeric stream interfaces* section), they cover all the needs a mainstream
    programmer will ever have.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()` 操作的一些用法非常简单，任何初学者都可以轻松掌握，而其他情况可能很复杂，即使对于经验丰富的程序员来说也不容易理解。结合已经讨论的操作，本节中我们展示的
    `collect()` 操作的流行用例已经足够满足初学者的所有需求，并将涵盖大多数经验更丰富的专业人士的需求。结合数值流操作（参见 *数值流接口* 部分），它们将涵盖主流程序员可能需要的所有需求。'
- en: 'As we have mentioned already, the `collect()` operation is very flexible and
    allows us to customize stream processing. It has two forms, as follows:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，`collect()` 操作非常灵活，允许我们自定义流处理。它有两种形式，如下所示：
- en: '`R collect(Collector<T, A, R> collector)`: Processes the stream elements of
    type `T` using the provided `Collector` and produces the result of type `R` via
    an intermediate accumulation of type `A`'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Collector<T, A, R> collector)`: 使用提供的 `Collector` 处理类型为 `T` 的流元素，并通过中间累积类型
    `A` 产生类型为 `R` 的结果'
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: Processes the stream elements of type `T` using the provided functions:'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: 使用提供的函数处理类型为 `T` 的流元素：'
- en: '`Supplier<R> supplier`: Creates a new result container'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier<R> supplier`: 创建一个新的结果容器'
- en: '`BiConsumer<R, T> accumulator`: A stateless function that adds an element to
    the result container'
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiConsumer<R, T> accumulator`: 一个无状态的函数，用于将一个元素添加到结果容器中'
- en: '`BiConsumer<R, R> combiner`: A stateless function that merges two partial result
    containers – it adds the elements from the second result container to the first
    result container'
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiConsumer<R, R> combiner`: 一个无状态的函数，用于合并两个部分结果容器——它将第二个结果容器中的元素添加到第一个结果容器中'
- en: 'Let’s look at the second form of the `collect()` operation first. It is very
    similar to the `reduce()` operation with the three parameters we have just demonstrated:
    `supplier`, `accumulator`, and `combiner`. The biggest difference is that the
    first parameter in the `collect()` operation is not an identity or the initial
    value but instead the container, an object, that is going to be passed between
    functions and which maintains the state of the processing.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看 `collect()` 操作的第二种形式。它与刚刚展示的具有三个参数的 `reduce()` 操作非常相似：`supplier`、`accumulator`
    和 `combiner`。最大的区别是 `collect()` 操作的第一个参数不是恒等函数或初始值，而是一个容器，一个对象，它将在函数之间传递并保持处理状态。
- en: 'Let’s demonstrate how it works by selecting the oldest person from the list
    of `Person` objects. For the following example, we are going to use the familiar
    `Person` class as the container but add to it a constructor without parameters
    with two setters:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过从 `Person` 对象列表中选择最年长的人来演示它是如何工作的。在以下示例中，我们将使用熟悉的 `Person` 类作为容器，但为其添加一个无参数的构造函数和两个设置器：
- en: '[PRE365]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'Adding a constructor without parameters and setters is necessary because the
    `Person` object as a container should be creatable at any moment without any parameters
    and should be able to receive and keep the partial results: the `name` and `age`
    of the person who is the oldest, so far. The `collect()` operation will use this
    container while processing each element and, after the last element is processed,
    contain the name and age of the oldest person.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个不带参数的构造函数和设置器是必要的，因为`Person`对象作为一个容器，应该能够在任何时刻不带任何参数地创建，并且能够接收并保持部分结果：迄今为止最年长的人的`name`和`age`。在处理每个元素时，`collect()`操作将使用这个容器，并在处理完最后一个元素后，包含最年长的人的姓名和年龄。
- en: 'We will use again the same list of persons:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用相同的人员列表：
- en: '[PRE368]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'Here is the `collect()` operation that finds the oldest person in the list:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是找到列表中最年长人的`collect()`操作：
- en: '[PRE372]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: We tried to inline the functions in the operation call, but it looked a bit
    difficult to read, so we decided to create functions first and then use them in
    the `collect()` operation. The container, a `Person` object, is created only once
    before the first element is processed. In this sense, it is similar to the initial
    value of the `reduce()` operation. Then, it is passed to the accumulator, which
    compares it to the first element. The `age` field in the container was initialized
    to the default value of zero, and thus the `age` and `name` of the first element
    were set in the container as the parameters of the oldest person, so far. When
    the second stream element (the `Person` object) is emitted, its `age` value is
    compared to the `age` value currently stored in the container, and so on, until
    all elements of the stream are processed. The result is shown in the previous
    comments.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在操作调用中内联函数，但看起来有点难以阅读，所以我们决定首先创建函数，然后再在`collect()`操作中使用它们。容器，一个`Person`对象，只在处理第一个元素之前创建一次。从这个意义上说，它类似于`reduce()`操作的初始值。然后，它被传递给累加器，与第一个元素进行比较。容器中的`age`字段被初始化为零的默认值，因此第一个元素的`age`和`name`被设置为迄今为止最年长的人的参数。当第二个流元素（`Person`对象）被发射时，它的`age`值与容器中当前存储的`age`值进行比较，依此类推，直到处理完流中的所有元素。结果在之前的注释中显示。
- en: When the stream is sequential, the combiner is never called. But when we make
    it parallel (`list.parallelStream()`), the `reduce()` operation, the number of
    partial results may vary, depending on the number of CPUs and the internal logic
    of the `collect()` operation implementation. So, the **Combiner is called!** message
    can be printed any number of times.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 当流是顺序的时，组合器永远不会被调用。但当我们将其并行化（`list.parallelStream()`）时，`reduce()`操作中部分结果的数目可能会根据CPU的数量和`collect()`操作实现的内部逻辑而变化。因此，“**组合器被调用**！”消息可以打印任意次数。
- en: 'Now, let’s look at the first form of the `collect()` operation. It requires
    an object of the class that implements the `java.util.stream.Collector<T,A,R>`
    interface, where `T` is the stream type, `A` is the container type, and `R` is
    the result type. You can use one of the following `of()` methods (from the `Collector`
    interface) to create the necessary `Collector` object:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`collect()`操作的第一种形式。它需要一个实现了`java.util.stream.Collector<T,A,R>`接口的类的对象，其中`T`是流类型，`A`是容器类型，`R`是结果类型。你可以使用以下`of()`方法（来自`Collector`接口）来创建必要的`Collector`对象：
- en: '[PRE389]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'Alternatively, you can use this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下方法：
- en: '[PRE393]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: The functions you have to pass to the preceding methods are similar to those
    we have demonstrated already. But we are not going to do this, for two reasons.
    First, it is more involved and pushes us beyond the scope of this book, and, second,
    before doing that, you have to look in the `java.util.stream.Collectors` class,
    which provides many ready-to-use collectors.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须传递给前面方法的函数与我们之前演示的函数类似。但我们不会这样做，有两个原因。首先，这更加复杂，超出了本书的范围，其次，在这样做之前，你必须查看`java.util.stream.Collectors`类，它提供了许多现成的收集器。
- en: As we have mentioned already, together with the operations discussed so far
    and the numeric streams operations we are going to present in the next section,
    ready-to-use collectors cover the vast majority of processing needs in mainstream
    programming, and there is a good chance you will never need to create a custom
    collector.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，连同我们将在下一节中讨论的操作和数值流操作，现成的收集器涵盖了主流编程中的大多数处理需求，你很可能永远不需要创建自定义收集器。
- en: Collectors
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集器
- en: 'The `java.util.stream.Collectors` class provides more than 40 methods that
    create `Collector` objects. We are going to demonstrate only the simplest and
    most popular ones, as follows:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.Collectors`类提供了超过40种方法来创建`Collector`对象。我们将只演示最简单和最受欢迎的几个，如下所示：'
- en: '`Collector<T,?,List<T>> toList()`: Creates a collector that generates a `List`
    object from stream elements'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,List<T>> toList()`: 创建一个收集器，从流元素生成`List`对象'
- en: '`Collector<T,?,Set<T>> toSet()`: Creates a collector that generates a `Set`
    object from stream elements'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Set<T>> toSet()`: 创建一个收集器，从流元素生成`Set`对象'
- en: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    Creates a collector that generates a `Map` object from stream elements'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    创建一个收集器，从流元素生成`Map`对象'
- en: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`: Creates a
    collector that generates a `Collection` object of the type provided by `Supplier<C>
    collectionFactory`'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`: 创建一个收集器，生成由`Supplier<C>
    collectionFactory`提供的类型的`Collection`对象'
- en: '`Collector<CharSequence,?,String> joining()`: Creates a collector that generates
    a `String` object by concatenating stream elements'
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining()`: 创建一个收集器，通过连接流元素生成`String`对象'
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`: Creates
    a collector that generates a delimiter-separated `String` object from stream elements'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`: 创建一个收集器，从流元素生成以分隔符分隔的`String`对象'
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`: Creates a collector that generates a delimiter-separated
    `String` object from the stream elements and adds the specified `prefix` and `suffix`'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`: 创建一个收集器，从流元素生成以分隔符分隔的`String`对象，并添加指定的`prefix`和`suffix`'
- en: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`: Creates a collector
    that calculates the sum of the results generated by the provided function applied
    to each element; the same method exists for `long` and `double` types'
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`: 创建一个收集器，计算由提供的函数应用于每个元素生成的结果的总和；对于`long`和`double`类型也存在相同的方法'
- en: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`: Creates
    a collector that calculates the sum, minimum, maximum, count, and average of the
    results generated by the provided function applied to each element; the same method
    exists for `long` and `double` types'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`: 创建一个收集器，该收集器计算由提供的函数应用于每个元素生成的结果的总和、最小值、最大值、计数和平均值；对于`long`和`double`类型也存在相同的方法'
- en: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`:
    Creates a collector that separates the elements using the provided `Predicate`
    function'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`:
    创建一个收集器，使用提供的`Predicate`函数分离元素'
- en: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`: Creates a collector
    that groups elements into `Map` with keys generated by the provided function'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`: 创建一个收集器，将元素分组到由提供的函数生成的键的`Map`中'
- en: 'The following demo code shows how to use the collectors created by the methods
    listed earlier. First, we will demonstrate usage of the `toList()`, `toSet()`,
    t`oMap()`, and `toCollection()` methods:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示代码展示了如何使用前面列出的方法创建的收集器。首先，我们将演示`toList()`、`toSet()`、`toMap()`和`toCollection()`方法的用法：
- en: '[PRE398]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'The `joining()` method allows you to concatenate the `Character` and `String`
    values in a delimited list with `prefix` and `suffix`:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`joining()`方法允许您使用`prefix`和`suffix`将分隔列表中的`Character`和`String`值连接起来：'
- en: '[PRE425]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: 'Now, let’s turn to the `summingInt()` and `summarizingInt()` methods. They
    create collectors that calculate the sum and other statistics of the `int` values
    produced by the provided functions applied to each element:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向`summingInt()`和`summarizingInt()`方法。它们创建收集器，计算由提供的函数应用于每个元素生成的`int`值的总和和其他统计信息：
- en: '[PRE440]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: There are also the `summingLong()`, `summarizingLong()`, `summingDouble()`,
    and `summarizingDouble()` methods.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`summingLong()`、`summarizingLong()`、`summingDouble()`和`summarizingDouble()`方法。
- en: 'The `partitioningBy()` method creates a collector that groups the elements
    by the provided criteria and put the groups (lists) in a `Map` object, with a
    Boolean value as the key:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '`partitioningBy()`方法创建一个收集器，该收集器根据提供的标准对元素进行分组，并将组（列表）放入一个`Map`对象中，以布尔值作为键：'
- en: '[PRE456]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: 'As you can see, using the `p.getAge() > 27` criteria, we were able to put all
    the persons in two groups: one is below or equal to `27` years of `age` (the key
    is `false`), and another is above `27` (the key is `true`).'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用 `p.getAge() > 27` 条件，我们能够将所有人分为两组：一组年龄在 `27` 岁以下或等于 `27` 岁（键为 `false`），另一组年龄在
    `27` 岁以上（键为 `true`）。
- en: 'Finally, the `groupingBy()` method allows you to group elements by a value
    and put the groups (lists) in a `Map` object, with this value as a key:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`groupingBy()` 方法允许您按值对元素进行分组，并将组（列表）放入以该值作为键的 `Map` 对象中：
- en: '[PRE461]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: To be able to demonstrate this method, we changed our list of `Person` objects
    by setting `age` on each of them to either `23` or `33`. The result is two groups
    ordered by their `age`.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够演示此方法，我们通过将每个 `Person` 对象的 `age` 设置为 `23` 或 `33` 来更改我们的 `Person` 对象列表。结果是按年龄排序的两个组。
- en: 'There are also overloaded `toMap()`, `groupingBy()`, and `partitioningBy()`
    methods as well as the following, often overloaded, methods that create corresponding
    `Collector` objects, as follows:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有重载的 `toMap()`、`groupingBy()` 和 `partitioningBy()` 方法以及以下方法，这些方法通常被重载，用于创建相应的
    `Collector` 对象，如下所示：
- en: '`counting()`'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counting()`'
- en: '`reducing()`'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducing()`'
- en: '`filtering()`'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtering()`'
- en: '`toConcurrentMap()`'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toConcurrentMap()`'
- en: '`collectingAndThen()`'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectingAndThen()`'
- en: '`maxBy()`, `minBy()`'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxBy()`, `minBy()`'
- en: '`mapping()`, `flatMapping()`'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping()`, `flatMapping()`'
- en: '`averagingInt()`, `averagingLong()`, `averagingDouble()`'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`averagingInt()`, `averagingLong()`, `averagingDouble()`'
- en: '`toUnmodifiableList()`, `toUnmodifiableMap()`, `toUnmodifiableSet()`'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUnmodifiableList()`, `toUnmodifiableMap()`, `toUnmodifiableSet()`'
- en: If you cannot find the operation you need among those discussed in this book,
    search the `Collectors` API first, before building your own `Collector` object.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本书中找不到所需的操作，请在构建自己的 `Collector` 对象之前，首先在 `Collectors` API 中进行搜索。
- en: Numeric stream interfaces
  id: totrans-788
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值流接口
- en: 'As we have mentioned already, all three numeric interfaces, `IntStream`, `LongStream`,
    and `DoubleStream`, have methods similar to the methods in the `Stream` interface,
    including the methods of the `Stream.Builder` interface. This means that everything
    we have discussed so far in this chapter equally applies to any numeric stream
    interfaces. That is why, in this section, we will only talk about those methods
    that are not present in the `Stream` interface, as follows:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，所有三个数值接口 `IntStream`, `LongStream`, 和 `DoubleStream` 都有与 `Stream` 接口中的方法类似的方法，包括
    `Stream.Builder` 接口中的方法。这意味着我们在这章中讨论的所有内容都同样适用于任何数值流接口。这就是为什么在本节中，我们只会讨论那些不在 `Stream`
    接口中的方法，如下所示：
- en: The `range(lower,upper)` and `rangeClosed(lower,upper)` methods in the `IntStream`
    and `LongStream` interfaces allow you to create a stream from the values in the
    specified range.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream` 和 `LongStream` 接口中的 `range(lower,upper)` 和 `rangeClosed(lower,upper)`
    方法允许您从指定范围内的值创建一个流。'
- en: The `boxed()` and `mapToObj()` intermediate operations convert a numeric stream
    to `Stream`
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boxed()` 和 `mapToObj()` 中间操作将数值流转换为 `Stream`'
- en: The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations
    convert a numeric stream of one type to a numeric stream of another type.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapToInt()`, `mapToLong()`, 和 `mapToDouble()` 中间操作将一种类型的数值流转换为另一种类型的数值流。'
- en: The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations convert a stream to a numeric stream.
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMapToInt()`, `flatMapToLong()`, 和 `flatMapToDouble()` 中间操作将流转换为数值流。'
- en: The `sum()` and `average()` terminal operations calculate the sum and average
    of numeric stream elements.
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()` 和 `average()` 终端操作计算数值流元素的求和和平均值。'
- en: Creating a stream
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个流
- en: In addition to the methods of the `Stream` interface that create streams, the
    `IntStream` and `LongStream` interfaces allow you to create a stream from the
    values in the specified range.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建流的 `Stream` 接口方法之外，`IntStream` 和 `LongStream` 接口还允许您从指定范围内的值创建一个流。
- en: range() and rangeClosed()
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`range()` 和 `rangeClosed()`'
- en: 'The `range(lower, upper)` method generates all values sequentially, starting
    from the `lower` value and ending with the value just before `upper`:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`range(lower, upper)` 方法按顺序生成所有值，从 `lower` 值开始，以 `upper` 值之前的一个值结束：'
- en: '[PRE469]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: 'The `rangeClosed(lower, upper)` method generates all the values sequentially,
    starting from the `lower` value and ending with the `upper` value:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`rangeClosed(lower, upper)` 方法按顺序生成所有值，从 `lower` 值开始，以 `upper` 值结束：'
- en: '[PRE471]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: Intermediate operations
  id: totrans-806
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间操作
- en: 'In addition to the intermediate operations of the `Stream` interface, the `IntStream`,
    `LongStream`, and `DoubleStream` interfaces also have number-specific intermediate
    operations: `boxed()`, `mapToObj()`, `mapToInt()`, `mapToLong()`, `mapToDouble()`,
    `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()`.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Stream` 接口的中间操作外，`IntStream`、`LongStream` 和 `DoubleStream` 接口还有特定于数字的中间操作：`boxed()`、`mapToObj()`、`mapToInt()`、`mapToLong()`、`mapToDouble()`、`flatMapToInt()`、`flatMapToLong()`
    和 `flatMapToDouble()`。
- en: boxed() and mapToObj()
  id: totrans-808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boxed() 和 mapToObj()
- en: 'The `boxed()` intermediate operation converts (boxes) elements of the primitive
    numeric type to the corresponding wrapper type:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`boxed()` 中间操作将（装箱）原始数值类型的元素转换为相应的包装类型：'
- en: '[PRE475]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: 'In the preceding code, we have commented out the lines that generate compilation
    errors because the elements generated by the `range()` method are primitive types.
    The `boxed()` operation converts a primitive value to the corresponding wrapping
    type, so it can be processed as a reference type. The `mapToObj()` intermediate
    operation does a similar transformation, but it is not as specialized as the `boxed()`
    operation and allows you to use an element of primitive type to produce an object
    of any type:'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已注释掉产生编译错误的行，因为这些由 `range()` 方法生成的元素是原始类型。`boxed()` 操作将原始值转换为相应的包装类型，因此它可以作为引用类型进行处理。`mapToObj()`
    中间操作执行类似的转换，但它不如 `boxed()` 操作专业化，并允许您使用原始类型的元素生成任何类型的对象：
- en: '[PRE496]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: In the preceding code, we have added the `map()` operation just to prove that
    the `mapToObj()` operation does the job and creates an object of the wrapping
    type, as expected. Also, by adding the pipeline that produces `Person` objects,
    we have demonstrated how the `mapToObj()` operation can be used to create an object
    of any type.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了 `map()` 操作只是为了证明 `mapToObj()` 操作完成了工作并创建了预期的包装类型对象。此外，通过添加生成 `Person`
    对象的管道，我们展示了如何使用 `mapToObj()` 操作创建任何类型的对象。
- en: mapToInt(), mapToLong(), and mapToDouble()
  id: totrans-849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mapToInt(), mapToLong(), 和 mapToDouble()
- en: 'The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations
    allow you to convert a numeric stream of one type to a numeric stream of another
    type. For the sake of example, we will convert a list of `String` values to a
    numeric stream of different types by mapping each `String` value to its length:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapToInt()`, `mapToLong()`, 和 `mapToDouble()` 中间操作允许您将一种类型的数值流转换为另一种类型的数值流。为了举例，我们将通过将每个
    `String` 值映射为其长度，将 `String` 值的列表转换为不同类型的数值流：'
- en: '[PRE512]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: 'The elements of the created numeric streams are of the primitive type:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的数值流元素是原始类型：
- en: '[PRE527]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: 'As we are on this topic, if you would like to convert elements to a numeric
    wrapping type, the intermediate `map()` operation is the way to do it (instead
    of `mapToInt()`):'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这个话题上，如果您想将元素转换为数值包装类型，中间的 `map()` 操作是完成这项工作的方法（而不是 `mapToInt()`）：
- en: '[PRE530]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: flatMapToInt(), flatMapToLong(), and flatMapToDouble()
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: flatMapToInt(), flatMapToLong(), 和 flatMapToDouble()
- en: 'The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations produce a numeric stream of the following corresponding type:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMapToInt()`, `flatMapToLong()`, 和 `flatMapToDouble()` 中间操作产生以下对应类型的数值流：'
- en: '[PRE533]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: 'As you can see in the preceding code, we have used `int` values in the original
    stream, but it can be a stream of any type:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，我们使用了原始流中的 `int` 值，但它可以是任何类型的流：
- en: '[PRE544]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: Terminal operations
  id: totrans-892
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端操作
- en: 'Numeric-specific terminal operations are pretty straightforward. There are
    two of them, as follows:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 数值特定终端操作相当简单。有两个，如下所示：
- en: '`sum()`: Calculates the sum of numeric stream elements'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`: 计算数值流元素的总和'
- en: '`average()`: Calculates the average of numeric stream elements'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average()`: 计算数值流元素的平均值'
- en: sum() and average()
  id: totrans-896
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sum() 和 average()
- en: 'If you need to calculate a sum or an average of the values of numeric stream
    elements, the only requirement for the stream is that it should not be infinite.
    Otherwise, the calculation never finishes. The following are examples of these
    operational usages:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要计算数值流元素值的总和或平均值，对流的唯一要求是它不应是无限的。否则，计算永远不会完成。以下是一些这些操作用法的示例：
- en: '[PRE548]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: As you can see, using these operations on an empty stream is not a problem.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在空流上使用这些操作不是问题。
- en: Parallel streams
  id: totrans-915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行流
- en: We have seen that changing from a sequential stream to a parallel stream can
    lead to incorrect results if code was not written and tested to process a parallel
    stream. The following are a few more considerations related to parallel streams.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，如果代码没有编写和测试以处理并行流，那么从顺序流更改为并行流可能会导致错误的结果。以下是与并行流相关的一些更多考虑因素。
- en: Stateless and stateful operations
  id: totrans-917
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态和有状态的操作
- en: There are `filter()`, `map()`, and `flatMap()`, which do not keep data around
    (do not maintain state) while moving processing from one stream element to the
    next. Also, there are stateful operations, such as `distinct()`, `limit()`, `sorted()`,
    `reduce()`, and `collect()`, that can pass a state from previously processed elements
    to the processing of the next element.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 有 `filter()`、`map()` 和 `flatMap()`，这些操作在从流的一个元素移动到下一个元素的过程中不会保留数据（不维护状态）。此外，还有一些有状态的运算，如
    `distinct()`、`limit()`、`sorted()`、`reduce()` 和 `collect()`，可以将之前处理过的元素的状态传递给下一个元素的处理。
- en: Stateless operations usually do not pose a problem while switching from a sequential
    stream to a parallel one. Each element is processed independently, and the stream
    can be broken into any number of substreams for independent processing. With stateful
    operations, the situation is different. To start with, using them for an infinite
    stream may never finish processing. Also, while discussing the `reduce()` and
    `collect()` stateful operations, we have demonstrated how switching to a parallel
    stream can produce a different result if the initial value (or identity) is set
    without parallel processing in mind.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态操作在从顺序流切换到并行流时通常不会引起问题。每个元素都是独立处理的，流可以被分割成任意数量的子流以进行独立处理。对于有状态操作，情况就不同了。首先，对于无限流，使用它们可能永远不会完成处理。此外，在讨论
    `reduce()` 和 `collect()` 有状态操作时，我们已经展示了如果没有考虑到并行处理，切换到并行流可能会产生不同的结果。
- en: There are performance considerations too. Stateful operations often require
    you to process all the stream elements in several passes, using buffering. For
    large streams, it may tax JVM resources and slow down, if not completely shut
    down, an application.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，还有一些性能考虑因素。有状态的运算通常需要你多次遍历所有流元素，使用缓冲。对于大型流，这可能会消耗 JVM 资源并减慢速度，如果不是很完全地关闭应用程序。
- en: This is why a programmer should not take switching from sequential to parallel
    streams lightly. If stateful operations are involved, code has to be designed
    and tested to be able to perform parallel stream processing without negative effects.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员不应该轻率地从顺序流切换到并行流。如果涉及到有状态操作，代码必须被设计和测试，以便能够执行并行流处理而不会产生负面影响。
- en: Sequential or parallel processing?
  id: totrans-922
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序或并行处理？
- en: As we indicated in the previous section, parallel processing may or may not
    produce better performance. You have to test every use case before deciding on
    using parallel streams. Parallelism can yield better performance, but code has
    to be designed and possibly optimized to do it. Also, each assumption has to be
    tested in an environment that is as close to production as possible.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中指出的，并行处理可能或可能不会产生更好的性能。在使用并行流之前，你必须测试每一个用例。
- en: 'However, there are a few considerations you can take into account while deciding
    between sequential and parallel processing, as follows:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在决定使用顺序处理还是并行处理时，你可以考虑以下一些因素：
- en: Small streams are typically processed faster sequentially (although, what is
    *small* for your environment should be determined through testing and by measuring
    performance).
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型流通常以顺序方式处理得更快（尽管，对于你的环境来说什么是“小”应该通过测试和性能测量来确定）。
- en: If stateful operations cannot be replaced with stateless ones, carefully design
    your code for parallel processing or just avoid it.
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法用无状态操作替换有状态操作，请仔细设计你的代码以进行并行处理，或者简单地避免它。
- en: 'Consider parallel processing for procedures that require extensive calculations,
    but think about bringing the partial results together for the final result. Look
    in the `streams` folder. It contains a standalone stream-processing application.
    To simulate a stream of data, we created an `input.csv` file that contains a header
    and 14 lines, each line representing data of one person: first name, last name,
    age, street address, city, state, and zip code.'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对需要进行大量计算的程序使用并行处理，但也要考虑将部分结果汇总以得到最终结果。查看`streams`文件夹。它包含一个独立的流处理应用程序。为了模拟数据流，我们创建了一个包含标题和14行的`input.csv`文件，每行代表一个人的数据：名字、姓氏、年龄、街道地址、城市、州和邮政编码。
- en: 'The application reads this file as a stream of lines, skips the first line
    (header), and processes the rest of the lines by converting each of them to a
    `Person` class object:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将此文件作为行流读取，跳过第一行（标题），并将其余行转换为`Person`类对象进行处理：
- en: '[PRE564]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: 'Since the sequence of processing the lines does not affect the result, we can
    process the stream of lines in parallel. Also, note that we stop processing (by
    throwing an exception) if a line does not have enough data or some data does not
    match the expected format:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理行的顺序不影响结果，我们可以并行处理行流。此外，请注意，如果某行数据不足或某些数据不符合预期的格式，我们将停止处理（通过抛出异常）：
- en: '[PRE578]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: 'Then, we process the resulting list of `Person` class objects as follows:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式处理`Person`类对象的列表：
- en: '[PRE607]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: 'In the preceding code, we create the `Set` and `Map` objects that contain results
    that we print later, as follows:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了包含我们稍后打印的结果的`Set`和`Map`对象，如下所示：
- en: '[PRE632]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: 'The output is demonstrated in the following screenshot:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果在下面的屏幕截图中进行展示：
- en: '![](img/B18388_Figure_14.3.jpg)'
  id: totrans-1012
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18388_Figure_14.3.jpg)'
- en: As you can see, it shows in alphabetical order all the cities, all the states,
    and all the zip codes listed in the `input.csv` file, as well as the oldest person
    for each zip code.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它按字母顺序显示了`input.csv`文件中列出的所有城市、所有州和所有邮政编码，以及每个邮政编码的最年长者。
- en: The same result can be achieved by using a `for-`loop instead of each stream
    in this application, so using Java standard streams is more a matter of style
    than necessity. We prefer using streams because it allows for more compact code.
    In [*Chapter 15*](B18388_15_ePub.xhtml#_idTextAnchor315), *Reactive Programming*,
    we will present and discuss another type of stream (called a *reactive stream*)
    that cannot be replaced by `for-`loops, at least not easily. Reactive streams
    are used primarily for asynchronous processing, which will also be explored in
    the next chapter.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`for`循环而不是此应用程序中的每个流，也可以达到相同的结果，所以使用Java标准流更多的是一种风格问题，而不是必要性。我们更喜欢使用流，因为它可以使代码更加紧凑。在[*第15章*](B18388_15_ePub.xhtml#_idTextAnchor315)“响应式编程”中，我们将介绍并讨论另一种类型的流（称为*响应式流*），这种流不能轻易地被`for`循环所替代。响应式流主要用于异步处理，这将在下一章中探讨。
- en: Summary
  id: totrans-1015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have talked about data-stream processing, which is different
    from processing the I/O streams we reviewed in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. We defined what data streams are, how to process
    their elements using stream operations, and how to chain (connect) stream operations
    in a pipeline. We also discussed stream initialization and how to process streams
    in parallel.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了数据流处理，这与我们在[*第5章*](B18388_05_ePub.xhtml#_idTextAnchor121)“字符串、输入/输出和文件”中回顾的I/O流处理不同。我们定义了数据流是什么，如何使用流操作处理它们的元素，以及如何在管道中链式（连接）流操作。我们还讨论了流初始化以及如何并行处理流。
- en: Now, you know how to write code that processes streams of data, as well as create
    a stream-processing application as a standalone project.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何编写处理数据流代码，以及如何创建一个作为独立项目的流处理应用程序。
- en: In the next chapter, you will be introduced to the **Reactive Manifesto**, its
    purpose, and examples of its implementations. We will discuss the difference between
    reactive and responsive systems and what **asynchronous** and **non-blocking**
    processing are. We will also talk about **Reactive Streams** and **RxJava**.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解到**响应式宣言**、其目的以及其实施示例。我们将讨论响应式系统和响应式系统之间的区别，以及**异步**和**非阻塞**处理是什么。我们还将讨论**响应式流**和**RxJava**。
- en: Quiz
  id: totrans-1019
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: 'What is the difference between I/O streams and `java.util.stream.Stream`? Select
    all that apply:'
  id: totrans-1020
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: I/O流和`java.util.stream.Stream`之间的区别是什么？选择所有适用的：
- en: I/O streams are oriented toward data delivery, while `Stream` is oriented toward
    data processing.
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: I/O流面向数据传输，而`Stream`面向数据处理。
- en: Some I/O streams can be transformed into `Stream`.
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些I/O流可以被转换成`Stream`。
- en: I/O streams can read from a file, while `Stream` cannot.
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: I/O流可以从文件中读取，而`Stream`不能。
- en: I/O streams can write to a file, while `Stream` cannot.
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: I/O流可以写入文件，而`Stream`不能。
- en: What do the `empty()` and `of(T... values)` `Stream` methods have in common?
  id: totrans-1025
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`empty()`和`of(T... values)` `Stream`方法有什么共同点？'
- en: What type are the elements emitted by the `Stream.ofNullable(Set.of(1,2,3 )`
    stream?
  id: totrans-1026
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream.ofNullable(Set.of(1,2,3 )`流发出的元素类型是什么？'
- en: What does the following code print?
  id: totrans-1027
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码打印了什么？
- en: '[PRE643]'
  id: totrans-1028
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE643]'
- en: What does the following code print?
  id: totrans-1029
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码打印了什么？
- en: '[PRE644]'
  id: totrans-1030
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE644]'
- en: What does the following code print?
  id: totrans-1031
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码打印了什么？
- en: '[PRE645]'
  id: totrans-1032
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE645]'
- en: Is `Stream.Builder` a functional interface?
  id: totrans-1033
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream.Builder`是否是一个函数式接口？'
- en: How many elements does the following stream emit?
  id: totrans-1034
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下流发出了多少个元素？
- en: '[PRE646]'
  id: totrans-1035
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE646]'
- en: What does the following code print?
  id: totrans-1036
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码打印了什么？
- en: '[PRE647]'
  id: totrans-1037
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE647]'
- en: What is the value of `d` in the following code?
  id: totrans-1038
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`d`的值是多少？
- en: '[PRE648]'
  id: totrans-1039
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE648]'
- en: What is the value of the `s` string in the following code?
  id: totrans-1040
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`s`字符串的值是多少？
- en: '[PRE649]'
  id: totrans-1041
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE649]'
- en: What is the result of the following code?
  id: totrans-1042
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的结果是什么？
- en: '[PRE650]'
  id: totrans-1043
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE650]'
- en: How many stream elements does the `peek()` operation print in the following
    code?
  id: totrans-1044
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`peek()`操作打印了多少个流元素？
- en: '[PRE651]'
  id: totrans-1045
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE651]'
- en: What does the `or()` method return when the `Optional` object is empty?
  id: totrans-1046
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`Optional`对象为空时，`or()`方法返回什么？
- en: What is the value of the `s` string in the following code?
  id: totrans-1047
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，`s`字符串的值是多少？
- en: '[PRE652]'
  id: totrans-1048
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE652]'
- en: How many elements does the `IntStream.rangeClosed(42, 42)` stream emit?
  id: totrans-1049
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IntStream.rangeClosed(42, 42)`流发出了多少个元素？'
- en: Name two stateless operations.
  id: totrans-1050
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个无状态操作。
- en: Name two stateful operations.
  id: totrans-1051
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个有状态操作。
