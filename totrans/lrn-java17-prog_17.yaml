- en: '*Chapter 14*: Java Standard Streams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will talk about processing data streams, which are different
    from the I/O streams we reviewed in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. We will define what data streams are, how
    to process their elements using methods (operations) of the `java.util.stream.Stream`
    object, and how to chain (connect) stream operations in a pipeline. We will also
    discuss stream initialization and how to process streams in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Streams as a source of data and operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations (methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric stream interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a standalone stream-processing application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to write code that processes streams
    of data as well as create a stream-processing application as a standalone project.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to execute the code examples provided in this chapter, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A computer with a Microsoft Windows, Apple macOS, or Linux operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java SE version 17 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IDE or code editor of your choice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided
    in [*Chapter 1*](B18388_01_ePub.xhtml#_idTextAnchor015), *Getting Started with
    Java 17*. The files with the code examples for this chapter are available on the
    GitHub repository at [https://github.com/PacktPublishing/Learn-Java-17-Programming.git](https://github.com/PacktPublishing/Learn-Java-17-Programming.git)
    in the `examples/src/main/java/com/packt/learnjava/ch14_streams` folder and the
    `streams` folder, which contains a standalone stream-processing application.
  prefs: []
  type: TYPE_NORMAL
- en: Streams as a source of data and operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions, described and demonstrated in the previous chapter, together
    with functional interfaces add a powerful functional programming capability to
    Java. They allow passing behavior (functions) as parameters to libraries optimized
    for the performance of data processing. This way, an application programmer can
    concentrate on the business aspects of a developed system, leaving the performance
    aspects to the specialists – the authors of the library. One example of such a
    library is `java.util.stream`, which is going to be the focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121), *Strings, Input/Output,
    and Files*, we talked about I/O streams as a source of data, but beyond that,
    they are not of much help for further processing of data. Also, they are byte-
    or character-based, not object-based. You can create a stream of objects only
    after objects have been programmatically created and serialized first. The I/O
    streams are just connections to external resources, mostly files, and not much
    else. However, sometimes it is possible to make a transition from an I/O stream
    to `java.util.stream.Stream`. For example, the `BufferedReader` class has the
    `lines()` method that converts the underlying character-based stream into a `Stream<String>`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the streams of the `java.util.stream` package are oriented
    toward processing collections of objects. In *Chapter 2*, *Data Structures, Generics,
    and Popular Utilities*, we described two methods of the `Collection` interface
    that allow you to read collection elements as elements of a stream: `default Stream<E>
    stream()` and `default Stream<E> parallelStream()`. We also mentioned the `stream()`
    method of `java.util.Arrays`. It has the following eight overloaded versions that
    convert an array or part of it into a stream of the corresponding data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static DoubleStream stream(double[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static DoubleStream stream(double[] array, int startInclusive, int endExclusive)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static IntStream stream(int[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static IntStream stream(int[] array, int startInclusive, int endExclusive)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static LongStream stream(long[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static LongStream stream(long[] array, int startInclusive, int endExclusive)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static <T> Stream<T> stream(T[] array)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static <T> Stream<T> stream(T[] array, int startInclusive, int endExclusive)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now look closer at the streams of the `java.util.stream` package. The
    best way to understand what a stream is is to compare it with a collection. The
    latter is a data structure stored in memory. Every collection element is computed
    before being added to the collection. By contrast, an element emitted by a stream
    exists somewhere else, in the source, and is computed on demand. So, a collection
    can be a source for a stream.
  prefs: []
  type: TYPE_NORMAL
- en: A `Stream` object is an implementation of the `Stream` interface, `IntStream`,
    `LongStream`, or `DoubleStream`; the last three are called `Stream` interface
    are also available in numeric streams. Some of the numeric streams have a few
    extra methods, such as `average()` and `sum()`, which are specific numeric values.
    In this chapter, we are going to speak mostly about the `Stream` interface and
    its methods, but everything we will cover is equally applicable to numeric streams
    too.
  prefs: []
  type: TYPE_NORMAL
- en: A stream *produces* (or *emits*) stream elements as soon as a previously emitted
    element has been processed. It allows declarative presentation of methods (operations)
    that can be applied to the emitted elements, also in parallel. Today, when the
    machine learning requirements of large dataset processing are becoming ubiquitous,
    this feature reinforces the position of Java as one of the few modern programming
    languages of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Will all that said, we will start with a stream initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Stream initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to create and initialize a stream – an object of type `Stream`
    or any of the numeric interfaces. We grouped them by classes and interfaces that
    have stream-creating methods. We did it for your convenience so that it would
    be easier for you to remember and find them if need be.
  prefs: []
  type: TYPE_NORMAL
- en: Stream interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This group of `Stream` factories is composed of static methods that belong to
    the `Stream` interface.
  prefs: []
  type: TYPE_NORMAL
- en: empty()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stream<T> empty()` method creates an empty stream that does not emit any
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `forEach()` `Stream` method acts similarly to the `forEach()` `Collection`
    method and applies the passed-in function to each of the stream elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the same as creating a stream from an empty collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Without any element emitted, nothing happens. We will discuss the `forEach()`
    `Stream` method in the *Terminal operations* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: of(T... values)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `of(T... values)` method accepts varargs and can also create an empty stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is most often used for initializing a non-empty stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the method reference used for the invocation of the `println()` and `print()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use the `of(T... values)` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is no type specified for the `Stream` object, the compiler does not
    complain if the array contains a mix of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding generics that declare the expected element type causes an exception
    when at least one of the listed elements has a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Generics help a programmer to avoid many mistakes, so they should be added wherever
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `of(T... values)` method can also be used for the concatenation of multiple
    streams. Let’s assume, for example, that we have the following four streams that
    we would like to concatenate into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to concatenate them into a new stream that emits the `1,2,2,3,3,4,4,5`
    values. First, we try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It does not do what we hoped for. It treats each stream as an object of the
    `java.util.stream.ReferencePipeline` internal class that is used in the `Stream`
    interface implementation. So, we need to add the `flatMap()` operation to convert
    each stream element into a stream (which we will describe in the *Intermediate
    operations* subsection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function we passed into `flatMap()` as a parameter (`e -> e`) looks like
    it’s doing nothing, but that is because each element of the stream is a stream
    already, so there is no need to transform it. By returning an element as the result
    of the `flatMap()` operation, we tell the pipeline to treat the return value as
    a `Stream` object.
  prefs: []
  type: TYPE_NORMAL
- en: ofNullable(T t)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ofNullable(T t)` method returns `Stream<T>`, emitting a single element
    if the passed-in `t` parameter is not `null`; otherwise, it returns an empty `Stream`.
    To demonstrate the usage of the `ofNullable(T t)` method, we create the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We execute this method twice – with the parameter list equal to `null` and
    a `List` object. Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the first call to the `printList1()` method generates `NullPointerException`.
    To avoid the exception, we can implement the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The same result can be achieved with the `ofNullable(T t)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we have added `flatMap()` because, otherwise, the `Stream` element
    that flows into `forEach()` would be a `List` object. We will talk more about
    the `flatMap()` method in the *Intermediate operations* subsection. The function
    passed into the `flatMap()` operation in the preceding code can be expressed as
    a method reference too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Iterate (Objectand UnaryOperator)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two static methods of the `Stream` interface allow you to generate a stream
    of values using an iterative process similar to the traditional `for` loop, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: This creates an infinite
    sequential stream based on the iterative application of the second parameter,
    the `func` function, to the first `seed` parameter, producing a stream of values:
    `seed`, `f(seed)`, `f(f(seed))`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: This
    creates a finite sequential stream based on the iterative application of the third
    parameter, the `next` function, to the first `seed` parameter, producing a stream
    of values: `seed`, `f(seed)`, `f(f(seed))`, and so on, as long as the third parameter,
    the `hasNext` function, returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the usage of these methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that we were forced to add an intermediate operator, `limit(int n)`, to
    the first pipeline to avoid generating an infinite number of generated values.
    We will talk more about this method in the *Intermediate operations* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: concat (stream a and stream b)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stream<T> concat(Stream<> a, Stream<T> b)` static method of the `Stream`
    interface creates a stream of values based on two streams, `a` and `b`, passed
    in as parameters. The newly created stream consists of all the elements of the
    first parameter, `a`, followed by all the elements of the second parameter, `b`.
    The following code demonstrates this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `2` element is present in both original streams and consequently
    is emitted twice by the resulting stream.
  prefs: []
  type: TYPE_NORMAL
- en: generate (Supplier)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Stream<T> generate(Supplier<T> supplier)` static method of the `Stream`
    interface creates an infinite stream, where each element is generated by the provided
    `Supplier<T>` function. The following are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you will probably get different results because of the
    random (pseudo-random) nature of the generated values.
  prefs: []
  type: TYPE_NORMAL
- en: Since the created stream is infinite, we have added a `limit(int n)` operation
    that allows only the specified number of stream elements to flow through. We will
    talk more about this method in the *Intermediate operations* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: The Stream.Builder interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Stream.Builder<T> builder()` static method returns an internal (located
    inside the `Stream` interface) `Builder` interface that can be used to construct
    a `Stream` object. The interface `Builder` extends the `Consumer` interface and
    has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default Stream.Builder<T> add(T t)`: This calls the `accept(T)` method and
    returns the `Builder` object, thus allowing you to chain the `add (T t)` methods
    in a fluent dot-connected style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void accept(T t)`: This adds an element to the stream (this method comes from
    the `Consumer` interface).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> build()`: This transitions this builder from the constructing state
    to the `built` state. After this method is called, no new elements can be added
    to this stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage of the `add(T t)` method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note how we have added the `<String>` generics in front of the `builder()` method.
    This way, we tell the builder that the stream we are creating will have `String`-type
    elements. Otherwise, it will add the elements as `Object` types and not make sure
    that the added elements are of the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `accept(T t)` method is used when the builder is passed as a parameter
    of the `Consumer<T>` type or when you do not need to chain the methods that add
    the elements. The following is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `forEach(Consumer<T> consumer)` method accepts a `Consumer` function that
    has the `accept(T t)` method. Every time an element is emitted by the stream,
    the `forEach()` method receives it and passes it to the `accept(T t)` method of
    the `Builder` object. Then, when the `build()` method is called in the next line,
    the `Stream` object is created and starts emitting the elements added earlier
    by the `accept(T t)` method. The emitted elements are passed to the `forEach()`
    method, which then prints them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an explicit usage of the `accept(T t)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This time, we decided not to add all the list elements to the stream but only
    those that contain the `a` character. As expected, the created stream contains
    only the `cat` and `bear` elements. Also, note how we use `<String>` generics
    to make sure that all the stream elements are of the `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: Other classes and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java 8, two default methods were added to the `java.util.Collection` interface,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<E> stream()`: This returns a stream of the elements of this collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<E> parallelStream()`: This returns (possibly) a parallel stream of
    the elements of this collection – we say *possibly*, because the JVM attempts
    to split the stream into several chunks and process them in parallel (if there
    are several CPUs) or virtually parallel (using CPU time-sharing). However, it
    is not always possible and depends, in part, on the nature of the requested processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that all the collection interfaces that extend this interface, including
    `Set` and `List`, have these methods, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about parallel streams in the *Parallel streams* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We described eight static overloaded `stream()` methods of the `java.util.Arrays`
    class at the beginning of the *Streams as a source of data and operations* section.
    Here is an example of another way of creating a stream, using the subset of an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `java.util.Random` class allows you to create numeric streams of pseudo-random
    values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DoubleStream doubles()`: Creates an unlimited stream of `double` values between
    `0` (inclusive) and `1` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream ints()` and `LongStream longs()`: Creates an unlimited stream of
    corresponding type values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream doubles(long streamSize)`: Creates a stream (of the specified
    size) of `double` values between `0` (inclusive) and `1` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream ints(long streamSize)` and `LongStream longs(long streamSize)`:
    Creates a stream of the specified size of the corresponding type values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`: Creates an
    unlimited stream of `int` values between `randomNumberOrigin` (inclusive) and
    `randomNumberBound` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream longs(long randomNumberOrigin, long randomNumberBound)`: Creates
    an unlimited stream of `long` values between `randomNumberOrigin` (inclusive)
    and `randomNumberBound` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound)`:
    Creates a stream of the specified size of `double` values between `randomNumberOrigin`
    (inclusive) and `randomNumberBound` (exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of one of the preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Due to the use of `random`, every execution may (and probably will) generate
    a different result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.nio.file.Files` class has six static methods creating streams of
    lines and paths, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<String> lines(Path path)`: Creates a stream of lines from the file
    specified by the provided path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<String> lines(Path path, Charset cs)`: Creates a stream of lines from
    the file specified by the provided path; bytes from the file are decoded into
    characters using the provided `charset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> list(Path dir)`: Creates a stream of files and directories in
    the specified directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> walk(Path start, FileVisitOption... options)`: Creates a stream
    of files and directories of the file tree that starts with `Path start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    Creates a stream of files and directories of the file tree that starts with `Path
    start`, down to the specified `maxDepth` depth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: Creates a stream of files and directories
    (that match the provided predicate) of the file tree that starts with `Path start`,
    down to the specified depth, specified by the `maxDepth` value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other classes and methods that create streams include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.util.BitSet` class has the `IntStream stream()` method, which creates
    a stream of indices, for which this `BitSet` contains a bit in the `set` state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.io.BufferedReader` class has the `Stream<String> lines()` method,
    which creates a stream of lines from this `BufferedReader` object, typically from
    a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.util.jar.JarFile` class has the `Stream<JarEntry> stream()` method
    that creates a stream of ZIP file entries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.util.regex.Pattern` class has the `Stream<String> splitAsStream(CharSequence
    input)` method, which creates a stream from the provided sequence around matches
    of this pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `java.lang.CharSequence` interface has two methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`default IntStream chars()`: Creates a stream of `int`, zero-extending the
    `char` values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default IntStream codePoints()`: Creates a stream of code point values from
    this sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a `java.util.stream.StreamSupport` class that contains static
    low-level utility methods for library developers. However, we won’t be reviewing
    it, as this is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Operations (methods)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many methods of the `Stream` interface, including those that have a functional
    interface type as a parameter, are called `parameter` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s look at the `Stream<T> filter (Predicate<T> predicate)`
    method. Its implementation is based on the call to the `test(T t)` method Boolean
    of the `Predicate<T>` function. So, instead of saying, *we use the* `filter()`
    *method of the* `Stream` *object to select some of the stream elements and skip
    others,* programmers prefer to say, *we apply an operation filter that allows
    some of the stream elements to get through and skip others*. It describes the
    nature of the action (operation), not the particular algorithm, which is unknown
    until the method receives a particular function. There are two groups of operations
    in the `Stream` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream processing is organized typically as a pipeline, using a fluent (dot-connected)
    style. A `Stream`-creating method or another stream source starts such a pipeline.
    A terminal operation produces the final result or a side effect and eponymously
    ends the pipeline. An intermediate operation can be placed between the originating
    `Stream` object and the terminal operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An intermediate operation processes stream elements (or not, in some cases)
    and returns the modified (or not) `Stream` object, so the next intermediate or
    terminal operation can be applied. Examples of intermediate operations are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> filter(Predicate<T> predicate)`: Selects only elements matching
    a criterion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<R> map(Function<T,R> mapper)`: Transforms elements according to the
    passed-in function. Note that the type of the returned `Stream` object may be
    quite different from the input type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> distinct()`: Removes duplicates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> limit(long maxSize)`: Limits a stream to the specified number of
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> sorted()`: Arranges the stream elements in a certain order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss some other intermediate operations in the *Intermediate operations*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The processing of the stream elements actually begins only when a terminal operation
    starts executing. Then, all the intermediate operations (if present) start processing
    in sequence. As soon as the terminal operation has finished execution, the stream
    closes and cannot be reopened.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of terminal operations are `forEach()`, `findFirst()`, `reduce()`,
    `collect()`, `sum()`, `max()`, and other methods of the `Stream` interface that
    do not return the `Stream` object. We will discuss them in the *Terminal operations*
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: All the `Stream` operations support parallel processing, which is especially
    helpful in the case of a large amount of data processed on a multi-core computer.
    We will discuss it in the *Parallel streams* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned already, an intermediate operation returns a `Stream` object
    that emits the same or modified values and may even be of a different type than
    the stream source.
  prefs: []
  type: TYPE_NORMAL
- en: The intermediate operations can be grouped by their functionality into four
    categories of operations that perform **filtering**, **mapping**, **sorting**,
    or **peeking**.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This group includes operations that remove duplicates, skip some of the elements,
    limit the number of processed elements, and select for further processing only
    those that pass certain criteria, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> distinct()`: Compares stream elements using `Object.equals(Object)`
    method and skips duplicates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> skip(long n)`: Ignores the provided number of stream elements that
    are emitted first'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> limit(long maxSize)`: Allows only the provided number of stream
    elements to be processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> filter(Predicate<T> predicate)`: Allows only those elements to be
    processed that result in `true` when processed by the provided `Predicate` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Stream<T> dropWhile(Predicate<T> predicate)`: Skips those first elements
    of the stream that result in `true` when processed by the provided `Predicate`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default Stream<T> takeWhile(Predicate<T> predicate)`: Allows only those first
    elements of the stream to be processed that result in `true` when processed by
    the provided `Predicate` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is code that demonstrates how the operations just described work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note that we were able to reuse the source `List<String>` object but could not
    reuse the `Stream` object. Once a `Stream` object is closed, it cannot be reopened.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This group includes arguably the most important intermediate operations. They
    are the only intermediate operations that modify the elements of the stream. They
    **map** (transform) the original stream element value to a new one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<R> map(Function<T, R> mapper)`: Applies the provided function to each
    element of type `T` of the stream and produces a new element value of type `R`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream mapToInt(ToIntFunction<T> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a new element value of
    type `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream mapToLong(ToLongFunction<T> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a new element value of
    type `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a new element
    value of type `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: Applies the provided function
    to each element of type `T` of the stream and produces a `Stream<R>` object that
    emits elements of type `R`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a `IntStream`
    object that emits elements of type `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: Applies the provided
    function to each element of type `T` of the stream and produces a `LongStream`
    object that emits elements of type `long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: Applies the
    provided function to each element of type `T` of the stream and produces a `DoubleStream`
    object that emits elements of type `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of the usage of these operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In the last example, by converting the stream to `DoubleStream`, we transformed
    each numeric value to a `String` object and added white space, so the result can
    be printed with whitespace between the numbers. These examples are very simple
    – just conversion with minimal processing. But in real life, each `map()` or `flatMap()`
    operation typically accepts a more complex function that does something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two intermediate operations sort the stream elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream<T> sorted()`: Sorts stream elements in natural order (according to
    their `Comparable` interface implementation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream<T> sorted(Comparator<T> comparator)`: Sorts stream elements in order
    according to the provided `Comparator<T>` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naturally, these operations cannot be finished until all the elements are emitted,
    so such processing creates a lot of overhead, slows down performance, and has
    to be used for small streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some demo code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Peeking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An intermediate `Stream<T> peek(Consumer<T> action)` operation applies the
    provided `Consumer<T>` function to each stream element but does not change the
    stream values (`Consumer<T>` returns `void`). This operation is used for debugging.
    The following code shows how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Terminal operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Terminal operations** are the most important operations in a stream pipeline.
    It is possible to accomplish everything in them without using any other operations.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already used the `forEach(Consumer<T>)` terminal operation to print
    each element. It does not return a value, thus it is used for its side effects.
    However, the `Stream` interface has many more powerful terminal operations that
    do return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chief among them is the `collect()` operation, which has two forms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R collect(Collector<T, A, R> collector)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This allows you to compose practically any process that can be applied to a
    stream. The classic example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This example is used in such a way as to be suitable for parallel processing.
    The first parameter of the `collect()` operation is a function that produces a
    value based on the stream element. The second parameter is the function that accumulates
    the result. The third parameter is the function that combines the accumulated
    results from all the threads that processed the stream.
  prefs: []
  type: TYPE_NORMAL
- en: However, having only one such generic terminal operation will force programmers
    to write the same functions repeatedly. That is why the API authors added the
    `Collectors` class, which generates many specialized `Collector` objects without
    the need to create three functions for every `collect()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, the API authors added to the `Stream` interface various
    even more specialized terminal operations that are much simpler and easier to
    use. In this section, we will review all the terminal operations of the `Stream`
    interface and, in the `Collect` subsection, look at the plethora of `Collector`
    objects produced by the `Collectors` class. We will start with the most simple
    terminal operation that allows you to process each element of this stream one
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples, we are going to use the following class, `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Processing each element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two terminal operations in this group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void forEach(Consumer<T> action)`: Applies the provided action for each element
    of this stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void forEachOrdered(Consumer<T> action)`: Applies the provided action for
    each element of this stream in the order defined by the source, regardless of
    whether the stream is sequential or parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order in which you need the elements to be processed is important and
    has to be the order in which values are arranged at the source, use the second
    method, especially if you can foresee that it is possible your code is going to
    be executed on a computer with several CPUs. Otherwise, use the first one, as
    we did in all our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of the `forEach()` operation in use for reading comma-separated
    values (age and name) from a file and creating `Person` objects. We have placed
    the following `persons.csv` file (`resources` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: We have added spaces inside and outside the values in order to take this opportunity
    to show you some simple but very useful tips for working with real-life data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will just read the file and display its content line by line, but
    only those lines that contain the letter `J` (adjust the path value or set it
    to `absolute` if the code cannot find the `persons.csv` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: That is a typical way of using the `forEach()` operation – processing each element
    independently. This code also provides an example of a try-with-resources construct
    that closes the `BufferedReader` object automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how an inexperienced programmer might write code that reads
    the stream elements from the `Stream<String> lines` object and creates a list
    of `Person` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the `split()` method is used to break each line by a comma that
    separates the values and how the `org.apache.commons.lang3.StringUtils.remove()`
    method removes spaces from each value. Although this code works well in small
    examples on a single-core computer, it might create unexpected results with a
    long stream and parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason that lambda expressions require all variables to be final
    or effectively final – so that the same function can be executed in a different
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a correct implementation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve readability, we can create a method that does the job of mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the `collect()` operator and the `Collector` function
    created by the `Collectors.toList()` method. We will see more functions created
    by the `Collectors` class in the *Collect* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Counting all elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `long count()` terminal operation of the `Stream` interface looks straightforward
    and benign. It returns the number of elements in this stream. Those who are used
    to working with collections and arrays may use the `count()` operation without
    thinking twice. The following code snippet demonstrates a caveat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the result will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_14.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you see, the code that implements the `count()` method was able to determine
    the stream size without executing all the pipelines. The `peek()` operation did
    not print anything, which proves that elements were not emitted. So, if you expected
    to see the values of the stream printed, you might be puzzled and expect that
    the code has some kind of defect.
  prefs: []
  type: TYPE_NORMAL
- en: Another caveat is that it is not always possible to determine the stream size
    at the source. Besides, the stream may be infinite. So, you have to use `count()`
    with care.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible way to determine the stream size is by using the `collect()`
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what happens after the preceding code example
    has been run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_14.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `collect()` operation does not calculate the stream size
    at the source. That is because the `collect()` operation is not as specialized
    as the `count()` operation. It just applies the passed-in collector to the stream.
    The collector just counts the elements provided to it by the `collect()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Match all, any, or none
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three seemingly very similar terminal operations that allow us to
    assess whether all, any, or none of the stream elements have a certain value,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean allMatch(Predicate<T> predicate)`: Returns `true` when each of the
    stream elements returns `true` when used as a parameter of the provided `Predicate<T>`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean anyMatch(Predicate<T> predicate)`: Returns `true` when one of the
    stream elements returns `true` when used as a parameter of the provided `Predicate<T>`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean noneMatch(Predicate<T> predicate)`: Returns `true` when none of the
    stream elements return `true` when used as a parameter of the provided `Predicate<T>`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples of their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Please note that all these operations are optimized so as not to process all
    the stream elements if the result can be determined early.
  prefs: []
  type: TYPE_NORMAL
- en: Find any or first
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following terminal operations allow you to find any element or the first
    element of the stream correspondingly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> findAny()`: Returns `Optional` with the value of any element of
    the stream, or an empty `Optional` if the stream is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<T> findFirst()`: Returns an `Optional` with the value of the first
    element of the stream, or an empty `Optional` if the stream is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following examples illustrate these operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: In the first and third of the preceding examples, the `findAny()` and `findFirst()`
    operations produce the same result – they both find the first element of the stream.
    But in parallel processing, the result may be different.
  prefs: []
  type: TYPE_NORMAL
- en: When the stream is broken into several parts for parallel processing, the `findFirst()`
    operation always returns the first element of the stream, while the `findAny()`
    operation returns the first element only in one of the processing threads.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s talk about `class java.util.Optional` in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Optional class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The object of `java.util.Optional` is used to avoid returning `null` (as it
    may cause `NullPointerException`). Instead, an `Optional` object provides methods
    that allow you to check for the presence of a value and substitute it with a predefined
    value if the return value is `null`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if the `Optional` object is empty, then the following applies,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `or()` method of the `Optional` class allows you to return an alternative
    `Optional` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orElse()` method allows you to return an alternative value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `orElseGet()` method allows you to provide the `Supplier` function, which
    returns an alternative value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ifPresentOrElse()` method allows you to provide two functions – one that
    consumes the value from the `Optional` object, and another one that does something
    else if the `Optional` object is empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum and maximum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following terminal operations return the minimum or maximum value of stream
    elements, if present, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> min(Comparator<T> comparator)`: Returns the minimum element of
    this stream using the provided `Comparator` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Optional<T> max(Comparator<T> comparator)`: Returns the maximum element of
    this stream using the provided `Comparator` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the case of non-numerical values, the minimum element is
    the one that is first when ordered from left to right, according to the provided
    comparator. The maximum, accordingly, is the last element. In the case of numeric
    values, the minimum and maximum are just that – the smallest and biggest numbers
    among the stream elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at another example, using the `Person` class. The task is to find
    the oldest person in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to do that, we can create the following `Comparator<Person>` that
    compares `Person` objects only by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, using this comparator, we can find the oldest person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: To array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following two terminal operations generate an array that contains stream
    elements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object[] toArray()`: Creates an array of objects; each object is an element
    of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A[] toArray(IntFunction<A[]> generator)`: Creates an array of stream elements
    using the provided function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'The first example is straightforward. It converts elements to an array of the
    same type. As for the second example, the representation of `IntFunction` as `String[]::new`
    is probably not obvious, so let’s walk through it. `String[]::new` is a method
    reference that represents the `i -> new String[i]` lambda expression because the
    `toArray()` operation receives from the stream not the elements but their count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: 'We can prove it by printing an `i` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: 'The `i -> new String[i]` expression is `IntFunction<String[]>` that, according
    to its documentation, accepts an `int` parameter and returns the result of the
    specified type. It can be defined using an anonymous class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'The `java.util.Collection` interface has a very similar method that converts
    a collection to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that `toArray()` of the `Stream` interface accepts a
    function, while the `toArray()` of the `Collection` interface takes an array.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This terminal operation is called `reduce` because it processes all the stream
    elements and produces one value, thus reducing all the stream elements to one
    value. However, this is not the only operation that does it. The `collect` operation
    reduces all the values of the stream element to one result as well. In a way,
    all terminal operations are reductive. They produce one value after processing
    many elements.
  prefs: []
  type: TYPE_NORMAL
- en: So, you can view `reduce` and `collect` as synonyms that help to add structure
    and classification to many operations available in the `Stream` interface. Also,
    operations in the `reduce` group can be viewed as specialized versions of the
    `collect` operation because `collect()` can be tailored to provide the same functionality
    as the `reduce()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all that said, let’s look at a group of `reduce` operations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: Reduces the elements of
    the stream using the provided associative function that aggregates the elements;
    returns an `Optional` with the reduced value if available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T reduce(T identity, BinaryOperator<T> accumulator)`: Provides the same functionality
    as the previous `reduce()` version but with the identity parameter used as the
    initial value for an accumulator or a default value if a stream is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    Provides the same functionality as the previous `reduce()` versions but, in addition,
    uses the `combiner` function to aggregate the results when this operation is applied
    to a parallel stream; if the stream is not parallel, the `combiner` function is
    not used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate the `reduce()` operation, we are going to use the same `Person`
    class we have used before and the same list of `Person` objects as the source
    for our stream examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s find the oldest person in this list using the `reduce()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is somewhat surprising, isn’t it? The `reduce()` operation
    takes an accumulator, but it seems it did not accumulate anything. Instead, it
    compares all stream elements. Well, the accumulator saves the result of the comparison
    and provides it as the first parameter for the next comparison (with the next
    element). You can say that the accumulator, in this case, accumulates the results
    of all previous comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now accumulate something explicitly. Let’s assemble all the names from
    a list of persons in one comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: The notion of accumulation, in this case, makes a bit more sense, doesn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the `identity` value to provide some initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this version of the `reduce()` operation returns `value`, not the
    `Optional` object. That is because, by providing the initial value, we guarantee
    that at least this value will be present in the result if the stream turns out
    to be empty. But the resulting string does not look as pretty as we hoped. Apparently,
    the provided initial value is treated as any other stream element, and a comma
    is added after it by the accumulator we have created. To make the result look
    pretty again, we can use the first version of the `reduce()` operation again and
    add the initial value this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use a space as a separator instead of a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Now, the result looks better. While demonstrating the `collect()` operation
    in the next subsection, we will show a better way to create a comma-separated
    list of values with a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, let’s continue to review the `reduce()` operation and look at its
    third form – the one with three parameters: `identity`, `accumulator`, and `combiner`.
    Adding combiner to the `reduce()` operation does not change the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the stream is not parallel and the combiner is used only with
    a parallel stream. If we make the stream parallel, the result changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Apparently, for a parallel stream, the sequence of elements is broken into
    subsequences, each processed independently, and their results aggregated by the
    combiner. While doing that, the combiner adds the initial value (identity) to
    each of the results. Even if we remove the combiner, the result of the parallel
    stream processing remains the same because a default combiner behavior is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous two forms of the `reduce()` operations, the identity value
    was used by the accumulator. In the third form, the `identity` value is used by
    the combiner (note that the `U` type is the combiner type). To get rid of the
    repetitive `identity` value in the result, we have decided to remove it (and the
    trailing space) from the second parameter in the combiner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: The result is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our string-based examples so far, the identity has not just been an initial
    value. It also served as an identifier (a label) in the resulting string. However,
    when the elements of the stream are numeric, the identity looks more like just
    an initial value. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two of the pipelines are exactly the same, except that the second
    pipeline uses a method reference. The third and fourth pipelines have the same
    functionality too. They both use an initial value of `10`. Now, the first parameter
    makes more sense as the initial value than the identity, doesn’t it? In the fourth
    pipeline, we added a combiner, but it is not used because the stream is not parallel.
    Let’s make it parallel and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is `36` because the initial value of `10` was added three times,
    with each partial result. Apparently, the stream was broken into three subsequences.
    However, it is not always the case, as the number of subsequences changes as the
    stream grows and the number of CPUs on the computer increases. This is why you
    cannot rely on a certain fixed number of subsequences, and it is better to not
    use a non-zero initial value with parallel streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have set the identity to `0`, so every subsequence will get
    it, but the total is not affected when the result from all the processing threads
    is assembled by the combinator.
  prefs: []
  type: TYPE_NORMAL
- en: Collect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the usages of the `collect()` operation are very simple and can be easily
    mastered by any beginner, while other cases can be complex and not easy to understand,
    even for a seasoned programmer. Together with the operations discussed already,
    the most popular cases of `collect()` usage we present in this section are more
    than enough for all the needs a beginner may have and will cover most of the needs
    of a more experienced professional. Together with the operations of numeric streams
    (see the *Numeric stream interfaces* section), they cover all the needs a mainstream
    programmer will ever have.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have mentioned already, the `collect()` operation is very flexible and
    allows us to customize stream processing. It has two forms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R collect(Collector<T, A, R> collector)`: Processes the stream elements of
    type `T` using the provided `Collector` and produces the result of type `R` via
    an intermediate accumulation of type `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: Processes the stream elements of type `T` using the provided functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Supplier<R> supplier`: Creates a new result container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiConsumer<R, T> accumulator`: A stateless function that adds an element to
    the result container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BiConsumer<R, R> combiner`: A stateless function that merges two partial result
    containers – it adds the elements from the second result container to the first
    result container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at the second form of the `collect()` operation first. It is very
    similar to the `reduce()` operation with the three parameters we have just demonstrated:
    `supplier`, `accumulator`, and `combiner`. The biggest difference is that the
    first parameter in the `collect()` operation is not an identity or the initial
    value but instead the container, an object, that is going to be passed between
    functions and which maintains the state of the processing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s demonstrate how it works by selecting the oldest person from the list
    of `Person` objects. For the following example, we are going to use the familiar
    `Person` class as the container but add to it a constructor without parameters
    with two setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a constructor without parameters and setters is necessary because the
    `Person` object as a container should be creatable at any moment without any parameters
    and should be able to receive and keep the partial results: the `name` and `age`
    of the person who is the oldest, so far. The `collect()` operation will use this
    container while processing each element and, after the last element is processed,
    contain the name and age of the oldest person.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use again the same list of persons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `collect()` operation that finds the oldest person in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: We tried to inline the functions in the operation call, but it looked a bit
    difficult to read, so we decided to create functions first and then use them in
    the `collect()` operation. The container, a `Person` object, is created only once
    before the first element is processed. In this sense, it is similar to the initial
    value of the `reduce()` operation. Then, it is passed to the accumulator, which
    compares it to the first element. The `age` field in the container was initialized
    to the default value of zero, and thus the `age` and `name` of the first element
    were set in the container as the parameters of the oldest person, so far. When
    the second stream element (the `Person` object) is emitted, its `age` value is
    compared to the `age` value currently stored in the container, and so on, until
    all elements of the stream are processed. The result is shown in the previous
    comments.
  prefs: []
  type: TYPE_NORMAL
- en: When the stream is sequential, the combiner is never called. But when we make
    it parallel (`list.parallelStream()`), the `reduce()` operation, the number of
    partial results may vary, depending on the number of CPUs and the internal logic
    of the `collect()` operation implementation. So, the **Combiner is called!** message
    can be printed any number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the first form of the `collect()` operation. It requires
    an object of the class that implements the `java.util.stream.Collector<T,A,R>`
    interface, where `T` is the stream type, `A` is the container type, and `R` is
    the result type. You can use one of the following `of()` methods (from the `Collector`
    interface) to create the necessary `Collector` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: The functions you have to pass to the preceding methods are similar to those
    we have demonstrated already. But we are not going to do this, for two reasons.
    First, it is more involved and pushes us beyond the scope of this book, and, second,
    before doing that, you have to look in the `java.util.stream.Collectors` class,
    which provides many ready-to-use collectors.
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned already, together with the operations discussed so far
    and the numeric streams operations we are going to present in the next section,
    ready-to-use collectors cover the vast majority of processing needs in mainstream
    programming, and there is a good chance you will never need to create a custom
    collector.
  prefs: []
  type: TYPE_NORMAL
- en: Collectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `java.util.stream.Collectors` class provides more than 40 methods that
    create `Collector` objects. We are going to demonstrate only the simplest and
    most popular ones, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collector<T,?,List<T>> toList()`: Creates a collector that generates a `List`
    object from stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Set<T>> toSet()`: Creates a collector that generates a `Set`
    object from stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    Creates a collector that generates a `Map` object from stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`: Creates a
    collector that generates a `Collection` object of the type provided by `Supplier<C>
    collectionFactory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining()`: Creates a collector that generates
    a `String` object by concatenating stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`: Creates
    a collector that generates a delimiter-separated `String` object from stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`: Creates a collector that generates a delimiter-separated
    `String` object from the stream elements and adds the specified `prefix` and `suffix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`: Creates a collector
    that calculates the sum of the results generated by the provided function applied
    to each element; the same method exists for `long` and `double` types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`: Creates
    a collector that calculates the sum, minimum, maximum, count, and average of the
    results generated by the provided function applied to each element; the same method
    exists for `long` and `double` types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`:
    Creates a collector that separates the elements using the provided `Predicate`
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`: Creates a collector
    that groups elements into `Map` with keys generated by the provided function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following demo code shows how to use the collectors created by the methods
    listed earlier. First, we will demonstrate usage of the `toList()`, `toSet()`,
    t`oMap()`, and `toCollection()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'The `joining()` method allows you to concatenate the `Character` and `String`
    values in a delimited list with `prefix` and `suffix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s turn to the `summingInt()` and `summarizingInt()` methods. They
    create collectors that calculate the sum and other statistics of the `int` values
    produced by the provided functions applied to each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: There are also the `summingLong()`, `summarizingLong()`, `summingDouble()`,
    and `summarizingDouble()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `partitioningBy()` method creates a collector that groups the elements
    by the provided criteria and put the groups (lists) in a `Map` object, with a
    Boolean value as the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, using the `p.getAge() > 27` criteria, we were able to put all
    the persons in two groups: one is below or equal to `27` years of `age` (the key
    is `false`), and another is above `27` (the key is `true`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `groupingBy()` method allows you to group elements by a value
    and put the groups (lists) in a `Map` object, with this value as a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: To be able to demonstrate this method, we changed our list of `Person` objects
    by setting `age` on each of them to either `23` or `33`. The result is two groups
    ordered by their `age`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also overloaded `toMap()`, `groupingBy()`, and `partitioningBy()`
    methods as well as the following, often overloaded, methods that create corresponding
    `Collector` objects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`counting()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reducing()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filtering()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectingAndThen()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxBy()`, `minBy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapping()`, `flatMapping()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`averagingInt()`, `averagingLong()`, `averagingDouble()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUnmodifiableList()`, `toUnmodifiableMap()`, `toUnmodifiableSet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you cannot find the operation you need among those discussed in this book,
    search the `Collectors` API first, before building your own `Collector` object.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric stream interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have mentioned already, all three numeric interfaces, `IntStream`, `LongStream`,
    and `DoubleStream`, have methods similar to the methods in the `Stream` interface,
    including the methods of the `Stream.Builder` interface. This means that everything
    we have discussed so far in this chapter equally applies to any numeric stream
    interfaces. That is why, in this section, we will only talk about those methods
    that are not present in the `Stream` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `range(lower,upper)` and `rangeClosed(lower,upper)` methods in the `IntStream`
    and `LongStream` interfaces allow you to create a stream from the values in the
    specified range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boxed()` and `mapToObj()` intermediate operations convert a numeric stream
    to `Stream`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations
    convert a numeric stream of one type to a numeric stream of another type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations convert a stream to a numeric stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sum()` and `average()` terminal operations calculate the sum and average
    of numeric stream elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the methods of the `Stream` interface that create streams, the
    `IntStream` and `LongStream` interfaces allow you to create a stream from the
    values in the specified range.
  prefs: []
  type: TYPE_NORMAL
- en: range() and rangeClosed()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `range(lower, upper)` method generates all values sequentially, starting
    from the `lower` value and ending with the value just before `upper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rangeClosed(lower, upper)` method generates all the values sequentially,
    starting from the `lower` value and ending with the `upper` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Intermediate operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the intermediate operations of the `Stream` interface, the `IntStream`,
    `LongStream`, and `DoubleStream` interfaces also have number-specific intermediate
    operations: `boxed()`, `mapToObj()`, `mapToInt()`, `mapToLong()`, `mapToDouble()`,
    `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()`.'
  prefs: []
  type: TYPE_NORMAL
- en: boxed() and mapToObj()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `boxed()` intermediate operation converts (boxes) elements of the primitive
    numeric type to the corresponding wrapper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have commented out the lines that generate compilation
    errors because the elements generated by the `range()` method are primitive types.
    The `boxed()` operation converts a primitive value to the corresponding wrapping
    type, so it can be processed as a reference type. The `mapToObj()` intermediate
    operation does a similar transformation, but it is not as specialized as the `boxed()`
    operation and allows you to use an element of primitive type to produce an object
    of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added the `map()` operation just to prove that
    the `mapToObj()` operation does the job and creates an object of the wrapping
    type, as expected. Also, by adding the pipeline that produces `Person` objects,
    we have demonstrated how the `mapToObj()` operation can be used to create an object
    of any type.
  prefs: []
  type: TYPE_NORMAL
- en: mapToInt(), mapToLong(), and mapToDouble()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations
    allow you to convert a numeric stream of one type to a numeric stream of another
    type. For the sake of example, we will convert a list of `String` values to a
    numeric stream of different types by mapping each `String` value to its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of the created numeric streams are of the primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are on this topic, if you would like to convert elements to a numeric
    wrapping type, the intermediate `map()` operation is the way to do it (instead
    of `mapToInt()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: flatMapToInt(), flatMapToLong(), and flatMapToDouble()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations produce a numeric stream of the following corresponding type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we have used `int` values in the original
    stream, but it can be a stream of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: Terminal operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numeric-specific terminal operations are pretty straightforward. There are
    two of them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum()`: Calculates the sum of numeric stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`average()`: Calculates the average of numeric stream elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sum() and average()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to calculate a sum or an average of the values of numeric stream
    elements, the only requirement for the stream is that it should not be infinite.
    Otherwise, the calculation never finishes. The following are examples of these
    operational usages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using these operations on an empty stream is not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that changing from a sequential stream to a parallel stream can
    lead to incorrect results if code was not written and tested to process a parallel
    stream. The following are a few more considerations related to parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless and stateful operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are `filter()`, `map()`, and `flatMap()`, which do not keep data around
    (do not maintain state) while moving processing from one stream element to the
    next. Also, there are stateful operations, such as `distinct()`, `limit()`, `sorted()`,
    `reduce()`, and `collect()`, that can pass a state from previously processed elements
    to the processing of the next element.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless operations usually do not pose a problem while switching from a sequential
    stream to a parallel one. Each element is processed independently, and the stream
    can be broken into any number of substreams for independent processing. With stateful
    operations, the situation is different. To start with, using them for an infinite
    stream may never finish processing. Also, while discussing the `reduce()` and
    `collect()` stateful operations, we have demonstrated how switching to a parallel
    stream can produce a different result if the initial value (or identity) is set
    without parallel processing in mind.
  prefs: []
  type: TYPE_NORMAL
- en: There are performance considerations too. Stateful operations often require
    you to process all the stream elements in several passes, using buffering. For
    large streams, it may tax JVM resources and slow down, if not completely shut
    down, an application.
  prefs: []
  type: TYPE_NORMAL
- en: This is why a programmer should not take switching from sequential to parallel
    streams lightly. If stateful operations are involved, code has to be designed
    and tested to be able to perform parallel stream processing without negative effects.
  prefs: []
  type: TYPE_NORMAL
- en: Sequential or parallel processing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we indicated in the previous section, parallel processing may or may not
    produce better performance. You have to test every use case before deciding on
    using parallel streams. Parallelism can yield better performance, but code has
    to be designed and possibly optimized to do it. Also, each assumption has to be
    tested in an environment that is as close to production as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few considerations you can take into account while deciding
    between sequential and parallel processing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Small streams are typically processed faster sequentially (although, what is
    *small* for your environment should be determined through testing and by measuring
    performance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If stateful operations cannot be replaced with stateless ones, carefully design
    your code for parallel processing or just avoid it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider parallel processing for procedures that require extensive calculations,
    but think about bringing the partial results together for the final result. Look
    in the `streams` folder. It contains a standalone stream-processing application.
    To simulate a stream of data, we created an `input.csv` file that contains a header
    and 14 lines, each line representing data of one person: first name, last name,
    age, street address, city, state, and zip code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The application reads this file as a stream of lines, skips the first line
    (header), and processes the rest of the lines by converting each of them to a
    `Person` class object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the sequence of processing the lines does not affect the result, we can
    process the stream of lines in parallel. Also, note that we stop processing (by
    throwing an exception) if a line does not have enough data or some data does not
    match the expected format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we process the resulting list of `Person` class objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create the `Set` and `Map` objects that contain results
    that we print later, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18388_Figure_14.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it shows in alphabetical order all the cities, all the states,
    and all the zip codes listed in the `input.csv` file, as well as the oldest person
    for each zip code.
  prefs: []
  type: TYPE_NORMAL
- en: The same result can be achieved by using a `for-`loop instead of each stream
    in this application, so using Java standard streams is more a matter of style
    than necessity. We prefer using streams because it allows for more compact code.
    In [*Chapter 15*](B18388_15_ePub.xhtml#_idTextAnchor315), *Reactive Programming*,
    we will present and discuss another type of stream (called a *reactive stream*)
    that cannot be replaced by `for-`loops, at least not easily. Reactive streams
    are used primarily for asynchronous processing, which will also be explored in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have talked about data-stream processing, which is different
    from processing the I/O streams we reviewed in [*Chapter 5*](B18388_05_ePub.xhtml#_idTextAnchor121),
    *Strings, Input/Output, and Files*. We defined what data streams are, how to process
    their elements using stream operations, and how to chain (connect) stream operations
    in a pipeline. We also discussed stream initialization and how to process streams
    in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to write code that processes streams of data, as well as create
    a stream-processing application as a standalone project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be introduced to the **Reactive Manifesto**, its
    purpose, and examples of its implementations. We will discuss the difference between
    reactive and responsive systems and what **asynchronous** and **non-blocking**
    processing are. We will also talk about **Reactive Streams** and **RxJava**.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the difference between I/O streams and `java.util.stream.Stream`? Select
    all that apply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I/O streams are oriented toward data delivery, while `Stream` is oriented toward
    data processing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Some I/O streams can be transformed into `Stream`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: I/O streams can read from a file, while `Stream` cannot.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: I/O streams can write to a file, while `Stream` cannot.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the `empty()` and `of(T... values)` `Stream` methods have in common?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type are the elements emitted by the `Stream.ofNullable(Set.of(1,2,3 )`
    stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Is `Stream.Builder` a functional interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many elements does the following stream emit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the following code print?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the value of `d` in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the value of the `s` string in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the result of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many stream elements does the `peek()` operation print in the following
    code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What does the `or()` method return when the `Optional` object is empty?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the value of the `s` string in the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many elements does the `IntStream.rangeClosed(42, 42)` stream emit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two stateless operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two stateful operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
