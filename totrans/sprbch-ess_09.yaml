- en: Chapter 9. Testing the Spring Batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the importance of performance and scaling
    batch applications through different configurations (namely, thread model, parallel
    processing, remote chunking, and partitioning techniques) and how to choose the
    right strategy to scale the batch application with the available infrastructure.
    Spring Batch applications are developed and configured with individual components
    and different integrations, and hence it is important to test the individual features
    as well as the integrated project for its expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Types of testing for Spring Batch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of testing for Spring Batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of any software testing is to detect software failures and
    correct them. The scope of software testing can be established from validating
    the software components to verifying the software functionality and the software
    functioning in various environments and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the types of software testing that we might want to perform
    on Spring Batch applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Also known as component testing, this refers to verifying
    the functionality of a specific piece of code. Unit testing is generally written
    by the developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: This identifies the defects in the interfaces and
    the interaction between integrated components. As the software components are
    integrated in an iteratively incremental fashion, integration testing is an important
    testing aspect in larger projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional testing**: This verifies the functionality of a specific code
    component or group of code components, as defined in the functional specification
    of a particular application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing**: This verifies if the entire system is meeting the
    performance standards expected from the specified environment or run conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing and performance testing are usually covered together in system
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is the component-level testing performed by developers, with the
    source code and test plan prepared by developers. If the unit test fails, developers
    can fix the issues of the component and perform the unit test again. The following
    figure depicts the unit test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![Unit testing](img/3372OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JUnit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JUnit is the standard Java framework to perform unit testing. Most IDEs have
    in-built support for JUnit. TestNG can also be used as a JUnit analog.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit test cases can be written as simple Java classes to be executed with the
    `@Test` annotation on a method that performs the test operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of JUnit on a Java String concatenation operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Junit` class to test this Java class can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding class, the `testConcatenate` method with the `@Test` annotation
    verified the `MyClass java component`. The `assertEquals()` method does the actual
    testing by comparing the `MyClass.concatenate()` method output with the expected
    output. If the comparison fails, the `assertEquals()` method throws an exception.
    We can also write methods to set up operations before the unit test method execution
    with `@Before` annotation and clean up tasks after the unit test operation with
    the `@After` annotation. A detailed list of JUnit classes and their usage can
    be referred to from JUnit API ([http://junit.sourceforge.net/javadoc/](http://junit.sourceforge.net/javadoc/)).
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we need to perform batch application testing, each component can access the
    other with some dependency. Replicating all those classes needs to create the
    instances of such objects and provide to the component under test. Mockito is
    an open source Java framework that lets us create test double objects (mock objects)
    easily for the purpose of testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mockito can be added to the application with an easy Maven dependency, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In a batch application, we have the `EmployeeReader` class that we need to
    create an object during the test execution. This can be performed with the help
    of `Mockito` within the `JUnit` test class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we created the `EmployeeReader` object with the
    help of the `mock()` method from `Mockito` within the JUnit `@Before` (setup)
    method. We shall utilize this object in the `@Test` method to validate the functionality
    of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, any Spring Batch components, such as listeners and validator must
    be unit tested to verify functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration testing identifies the defects in the software components as they
    are integrated in an iteratively incremental fashion. Integration testing is an
    important testing aspect in larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: The modules that are unit tested are grouped to the larger aggregation, tested
    according to the integration test plan, and then the tested application is ready
    for its next level of testing as a system for functional testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Integration testing](img/3372OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following are the two ways to perform component testing with Spring Batch.
  prefs: []
  type: TYPE_NORMAL
- en: Listener-based approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class-level annotations help in testing the Spring Batch components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RunWith`(`SpringJUnit4ClassRunner.class`): This annotation indicates that
    the class should use the Spring support for JUnit facilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ContextConfiguration`: This lets the program know about the configuration
    properties that contain the application context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@TestExecutionListeners`: This helps in configuring listeners to help the
    test execution to set up the abilities such as dependency injection and step scope
    test execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a sample configuration using these annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The StepScopeTestUtils approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StepScopeTestUtils` utility class is used to create and manipulate `StepScope`
    in unit tests. This helps in using the Spring test support and injecting dependencies
    into the test case being the step scoped in the application context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `doInStepScope()` method of `StepScopeTestUtils` takes in `stepExecution`
    and the callable implementation; it automatically takes the runtime dependency
    injection and returns the result. The rest of the test is about validating the
    number of `empReads` with the expected number, with the `assertEquals()` method
    of `JUnit`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional testing verifies the functionality of a specific code component or
    a group of code components, as defined in the functional specification of the
    particular application with input data for the components and the output behavior
    is compared with the expected behaviour. Functional testing is the "black box"
    testing, as we deal with only the external system behavior for the specific input
    with the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Functional testing](img/3372OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a Spring Batch application, the entire job is considered as a unit of execution
    and it can be tested for its functionality with the help of `JobLauncherTestUtils`,
    a utility class to test Spring Batch jobs. `JobLauncherTestUtils` provides methods
    to launch an entire `AbstractJob`, allowing for end-to-end testing of individual
    steps without having to run every step in the job. `JobLauncherTestUtils` also
    provides the ability to run steps individually from `FlowJob` or `SimpleJob`.
    By launching steps within a job on their own, end-to-end testing of individual
    steps can be performed without having to run every step in the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of using `JobLauncherTestUtils` to
    perform job and step launching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, with the help of `JobLauncherTestUtils`, we are able
    to launch the batch job, a particular step, with the help of a simple API as part
    of the JUnit `@Test` method. The `@Before` (setup) method prepares the `JobLaunchParameters`
    with the details of the input `employeeData` file to be processed and output result
    file location to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, we learned the importance of software testing and the
    types of software testing we might want to perform on a Spring Batch application.
    We also learned about different open source frameworks, such as JUnit and Mockito,
    to perform unit testing on Spring Batch components. We finished this chapter with
    an understanding of Spring support, APIs to perform unit testing, integration
    testing, and functional testing on Spring Batch applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Appendix](apa.xhtml "Appendix A. Appendix") section, we discuss in detail
    about setting up the development environment, project configurations, and Spring
    Batch administration.
  prefs: []
  type: TYPE_NORMAL
