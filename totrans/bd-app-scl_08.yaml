- en: Chapter 8. Developing a Chat with Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we persisted data into MySQL using Slick and wrote
    PDF reports using Jasper reports. Now we will add more features in our app using
    Akka.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create Actors using the Akka framework.
    We will use Actors in combination with the Play framework and WebSockets in order
    to have a chat capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Actor model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actor systems, Actor routing, and dispatchers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mailboxes, Actor configuration, and persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Chat Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our Actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the new UI introduction to Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Akka ([http://akka.io/](http://akka.io/)) is a framework to build concurrent,
    distributed, and resilient message-driven applications in Scala, Java, and .NET.
    Building applications with Akka has several advantages, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High performance**: Akka delivers up to 50 million messages per second on
    a commodity hardware having ~2.5 million Actors per GB of RAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient by design**: Akka systems have self-healing properties for local
    and remote Actors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed and elastic**: Akka has all the mechanisms to scale your application,
    such as cluster, load balancing, partitioning, and sharding. Akka lets you grow
    or shrink your Actors on demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Akka framework provides good abstractions for concurrent, asynchronous,
    and distributed programming, such as Actors, Streams, and Futures. There are plenty
    of great success cases in production, such as BBC, Amazon, eBay, Cisco, The Guardian,
    Blizzard, Gilt, HP, HSBC, Netflix, and so many others.
  prefs: []
  type: TYPE_NORMAL
- en: Akka is a truly reactive framework because everything, in the sense of sending
    and receiving messages to Actors, is lockless, non-blocking IO, and asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Actor model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key for concurrency programming is to avoid a shared mutable state. A shared
    state often requires locks and synchronization, which makes your code less concurrent
    and more complex. Actors share nothing; they have internal state, but they don't
    share their internal state.
  prefs: []
  type: TYPE_NORMAL
- en: Actors have location transparency; they can run in a local or remote system
    and a cluster. It's also possible to mix local and remote actors - this is great
    for scalability and fits perfectly into a cloud environment. Actors can run anywhere,
    from your local box, the cloud, bare-metal datacenter, and Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: What is an Actor?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actors can be alternatives to threads, callback listeners, singleton services,
    **Enterprise Java Beans **(**EJB**), routers, load balancer or pool, and a **finite-state
    machine** (**FSM**). The Actor model concept is not new at all; it was created
    by Carl Hewitt in 1973\. The Actor model is heavily used in the telecom industry
    in rock-solid technologies such as Erlang. Erlang and the Actor model had immense
    success with companies such as Ericsson and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors have a simple way of working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit of code organization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They manage the internal states
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They have a mailbox
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They communicate with other actors using messages
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They can change the behavior at runtime
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Message exchange and mailboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actors talk with each other via messaging. There are two patterns: one is called
    ask and the other is called fire and forget. Both methods are asynchronous and
    non-blocking IO. When an Actor sends a message to another Actor, it does not send
    the message directly to the other Actor; it actually sends it to the Actor''s
    mailbox.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Messages are enqueued in the Actor mailbox in a time-ordered fashion. There
    are different mailboxes implementations in Akka. The default is **First In First
    Out** (**FIFO**) based. This is a good default; however, you might need a different
    algorithm, which is fine as you can change the mailbox if you need to. More details
    can be found in the official documentation ([http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala](http://doc.akka.io/docs/akka/2.4.9/scala/mailboxes.html#mailboxes-scala)).
    Actors live in an Actor system. You can have multiple Actor systems in a cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message exchange and mailboxes](img/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Akka encapsulates the actor state in mailbox and decouples it from the Actor
    behavior. The Actor behavior is the code you will have inside your Actor. You
    will need to see Actors and Akka as a protocol. So, basically, you will need to
    define how many Actors you will have and what each Actor will do in the sense
    of code, responsibility, and behavior. The Actor system has Actors and supervisors.
    Supervisors are one of the Akka mechanisms to deliver fault tolerance and resiliency.
    Supervisors take care of the Actor instances, and they can restart, kill, or create
    more Actors as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The Actor model is great for concurrency and scalability; however, like every
    single thing in computer science, there are tradeoffs and cons. For instance,
    Actors require a new mindset and a different way of thinking.
  prefs: []
  type: TYPE_NORMAL
- en: There is no silver bullet. Once you have your protocol, it might be hard to
    reuse your Actors outside your protocol. In general, Actors can be harder to compose,
    as compared to object-oriented classes or functions in Functional Programming,
    for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Coding actors with Akka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following Actor code using the Akka framework and
    Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this Akka code on `sbt` in your console, you will see an output
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Coding actors with Akka](img/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a closer look at this Akka code we just wrote, in which we defined
    a Scala class called `HelloWorldActor`. In order for this class be an Actor, we
    will need to extend Actor. Actors are reactive by default, which means that they
    are waiting to receive messages to react to the messages. You will need to code
    your behavior in an event loop. In Akka, this is done by coding the `receive`
    function with a pattern matcher in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern matcher will define what the actor can do. You will need to code
    all the possible kinds of messages you want that actor to handle. As I mentioned
    earlier, you will need to have a protocol; so your protocol has a message called
    `HelloMessage`. It's a common practice in Akka to use Scala objects as messages.
    However, you can pass pretty much all types as messages. It's even possible to
    send case classes with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have our protocol, which is our Actors, and the messages they can
    exchange. Now we will need to create an Actor system and start our application.
    As you can see, we will use the `ActorSystem` object to create an Actor system.
    Actor systems need to have a name, which can be any string you like, as long as
    it contains any letter [a-z, A-Z, 0-9] and non-leading '-' or '_'.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the system, you can create Actors. The system has a function
    called `actorOf`, which can be used to create Actors. You will need to use a special
    object called `Props` and pass the `actor` class. Why do we need it this way?
    It's because Akka manages the Actor state. You should not try to manage the Actor
    instance by yourself. This is dangerous because you can break referential transparency
    and your code might not work.
  prefs: []
  type: TYPE_NORMAL
- en: For this code, we are using the ask pattern. We will use this to send messages
    to the Actor, and we want to know what the Actor will return. Akka does everything
    in an async and non-blocking way , as mentioned previously. However, sometimes
    you want to get the answer now and then, unfortunately, you will need to block.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the answer now, we will need to define a timeout and use the
    `Await` object. When you send a message to an Actor using `?` (the ask pattern),
    Akka will return a Future for you. Then, you can pass the Future with a timeout
    to `Await`, and if the answer comes back before the timeout, you will have the
    response from the Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we are blocking here because we want to get the answer now, and we are
    outside the Actor system. Keep in mind that when an Actor talks with another Actor
    inside the Actor system, it should not block ever. So be careful with the usage
    of `Await`.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing in this code is that the `sender()` method inside of
    the Actor receives a function. This means that you want to get the reference of
    the Actor who sends the message to you. As we are performing `sender() !` method,
    we are sending an answer back to the caller. The `sender()` function is an Akka
    abstraction to deal with response messages to other Actors or function callers.
  prefs: []
  type: TYPE_NORMAL
- en: We also have another case, with `Any`, which means all other messages will be
    handled by that case code.
  prefs: []
  type: TYPE_NORMAL
- en: The ask pattern is one way to send messages to Actors. There is another pattern
    called `FireAndForget "!"`. Fire and forget will send a message and will not block
    and wait for the answer. So, there is no answer - in other words, Unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code with the `FireAndForget` message exchange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code with `$ sbt run`, you will see an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding actors with Akka](img/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have a `PrinterActor` method, which accepts pretty much anything and
    prints on the console. Then, we will create an Actor system and just send a message
    to our Actor with the fire and forget pattern, a.k.a "!", and as you can see,
    we will receive Unit; finally, we will await the shutdown of the Actor system
    using the `terminate` option.
  prefs: []
  type: TYPE_NORMAL
- en: Actor routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka provides routing functionality. This is useful from a business point of
    view because you can route to the right Actor in the sense of business logic and
    behavior. For architecture, we can use this as load balancing and route messages
    to more Actors to achieve fault tolerance and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Akka has several options for routing, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RoundRobin**: This is a random logic to every different Actor on the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SmallestMailbox**: This sends the message to the Actor with fewer messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent Hashing**: This partitions the Actors per hash ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ScatterGather**: This sends message to all actors, and the first to reply
    wins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TailChopping**: This sends to a route randomly, and if a reply doesn''t come
    back in a second, it chooses a new route and sends again, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the following code in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code in sbt doing `$ sbt run`, you will get an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Actor routing](img/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, here we have an `ActorUppercasePrinter` function that prints whatever it
    receives and calls the `toString` function, and then `toUpperCase`. Finally, it
    also prints the `self.path` Actor, which will be the address of the Actor. Actors
    are structured in a hierarchical structure, similar to a file system.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways to use Akka - Akka supports code or configuration (`application.conf`
    file). Here, we are creating a round-robin pool actor that has five routes. We
    are passing the target Actor to the router that will be our printer Actor.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when we send messages using the fire and forget pattern, every
    message is delivered to a different Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Akka works on memory. However, it is possible to use persistence. Persistence
    is still kind of experimental in Akka. However, it is stable. For production,
    you can use advanced persistence plugins, such as Apache Cassandra. For the sake
    of development and education, we will use Google leveldb in our file system. Akka
    has multiple persistence options, such as views and persistent Actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a persistent actor using the Google leveldb and file
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the `$ sbt run` command will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistence](img/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you run this code with `$ sbt run`, and stop and run again, you will see
    the data is being stored and recovered every time you stop and start again.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, your Actor needs to extend `PersistentActor` in order to have
    persistence support. You will also need to provide a `persistenceID`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will need to implement two receive functions. One is for commands
    (also known as messages), and the other one is for recovery. The command's receive
    loop will be activated when this Actor receives messages, while the recover one
    will be activated when the Actor boots up and will read the persistent data from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: So, this Actor here has a counter to count each message it receives, and prints
    every message it gets on the console. That's it; as you can see, it is pretty
    simple. In order to use this functionality, you will also need to configure your
    `application.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `application.conf` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, here we are defining a simple Akka system (local mode), and we are configuring
    the persistence for Google leveldb. As you can see, we will need to provide a
    path for persistence, and this path must exist on the OS.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using an additional functionality, we will also need to change `build.sbt`
    in order to import all jars that we will need in the sense of Akka, persistence,
    and leveldb.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `build.sbt` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it. That's all we need to persist the Actor's state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Akka has way more functionalities. For more, check out the default documentation
    at [http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365](http://doc.akka.io/docs/akka/2.4/scala.html?_ga=1.12480951.247092618.1472108365).
  prefs: []
  type: TYPE_NORMAL
- en: Creating our chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know Akka better, we will continue to develop our application. Akka
    has a great integration with the Play framework. We will use Actors with the Akka
    and Play framework right now. Let's build a simple chat feature for our app. We
    will change the code to add a new UI and, using the Akka testkit, we will test
    out actors.
  prefs: []
  type: TYPE_NORMAL
- en: The Play framework already includes Akka on the classpath for us, so we don't
    need to worry about it. However, we will need to add the Akka testkit dependency
    to the `build.sbt` file in order to have the classes in our classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `build.sbt` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now you can go to the console and type `$ activator`, `$ reload`, and
    then `$ compile`. This will force sbt to download the new dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will need to create a package called Actors. This package needs to be
    located at `ReactiveWebStore/app/`. We will start creating an `ActorHelper` utility
    object in order to have a generic function for the ask pattern that we saw earlier.
    It is an Actor helper generic ask pattern utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `ActorHelper.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ActorHelper` has just one function: `get`. This function will get an answer
    from any Actor given in any message. However, as you can see, we have a timeout
    of five seconds. If the result does not come back in this time, an exception will
    be raised.'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we are also mapping the Actor result to a String calling the `toString`
    function in the result future. This is not a lot of code; however, there are lots
    of imports, and it makes the code cleaner and we can get answers from Actors with
    less code and fewer imports.
  prefs: []
  type: TYPE_NORMAL
- en: The chat protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will need to define our protocol. For this functionality, we will need
    three Actors. The Actors that we create will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ChatRoom**: This will have a reference for all users in the chat room'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ChatUser**: This will have one instance per user (active browser)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ChatBotAdmin**: This simple Bot Admin will provide stats about the chat room'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChatUserActor` will need to join `JoinChatRoom` object in order to start chatting.
    `ChatUserActor` will also need to send messages to `ChatMessage` class to the
    `ChatRoomActor` that will broadcast messages to all users. The `ChatBotAdmin`
    will get a report from  `GetStats` object from `ChatRoomActor`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start coding this protocol. First, we will need to define the messages
    that will be exchanged between these Actors, as shown in the following piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we have a `ChatMessage` class with a name and a text. This
    will be the message each user will send on the chat. Then, we will have a stats
    class, which has a set of users--this will be all the users logged into the chat
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have some action messages, such as `JoinChatRoom`, `Tick`, and `GetStats`.
    So, `JoinChatRoom` will be sent by `ChatUserActor` to `ChatRoomActor` in order
    to join the chat. `Tick` will be a scheduled message that will happen from time
    to time in order to make `ChatBotAdmin` send stats about the chat room to all
    logged users. `GetStats` is the message that `ChatBotAdminActor` will send to
    `ChatRoomActor` in order to get information about who is in the room.
  prefs: []
  type: TYPE_NORMAL
- en: Let's code our three actors now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChatRoomActor.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`ChatRoomActor` has a var called `users`, which is a set of `ActorRef`. `ActorRef`
    is a generic reference to any actor. We have the receive function with three cases:
    `ChatMessage`, `JoinChatRoom`, and `GetStats`.'
  prefs: []
  type: TYPE_NORMAL
- en: A `JoinChatRoom` will be sent by the `ChatUserActor` method in order to join
    the room. As you can see, we are getting the `ActorRef` method from the sender
    Actor using the `sender()`function, and we are adding this reference to the set
    of users. In this way, the set of `ActorRef` represents the online logged-in users
    in the chat room right now.
  prefs: []
  type: TYPE_NORMAL
- en: The other case is with the `ChatMessage` method. Basically, we will broadcast
    the message to all users in the chat. We do this because we have the reference
    for all actors in users. Then, we will call the `foreach` function in order to
    iterate all users one by one, and then we will send the message using `FireAndForget
    "!"` to each user Actor represented by the operator underscore `_`.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetStats` case creates a string with all chat room stats. For now, the
    stats are just the number of online users, which is computed by calling the size
    function on the users object. We are also showing all the hash codes that identify
    all Actors logged in, just for fun.
  prefs: []
  type: TYPE_NORMAL
- en: That's our `ChatRoomActor` implementation. As you can see, it is hard to talk
    about one Actor without describing the other, as the protocol will always be kind
    of coupled. You might also be wondering why we have a companion object for the
    `ChatRoomActor` method.
  prefs: []
  type: TYPE_NORMAL
- en: This object is to provide an easy way to create Actor instances. We are creating
    a single room for our design; we don't want to have multiple chat rooms, so that's
    why we will need to control the creation of the room Actor.
  prefs: []
  type: TYPE_NORMAL
- en: If the room is null, we will create a new room; otherwise, we will return the
    cached instance of the room that we already got in the memory. We will need an
    instance of the Actor system in order to create actors, so that's why we are receiving
    the system on the `apply` function. The `apply` function will be called when someone
    writes a code like `ChatRoomActor(mySystem)`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move to the ChatUserActor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChatUserActor.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This Actor is a little bit easier than the previous one. `ChatUserActor` receives,
    as a parameter, the room actor reference and also an out actor. The room will
    be an instance of the room that the user will use to communicate with other users.
    The `ActorRef` method called out is the Play framework Actor responsible for sending
    the answer back to the controllers and UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pretty much just have two cases: one where we receive a `ChatMessage` and
    the other is the `ChatUserActors` method in the chat room. So, we will just need
    to send back to the UI using the out Actor. That''s why there is a fire and forget
    message for the out Actor with a result. Using a new Actor model can be dangerous,
    please read more at [http://doc.akka.io/docs/akka/current/scala/actors.html](http://doc.akka.io/docs/akka/current/scala/actors.html).'
  prefs: []
  type: TYPE_NORMAL
- en: There is another case that just receives a string that will be the message from
    that Actor itself. Remember that each Actor represents a user and a browser full
    of duplex connections via WebSockets. Don't worry about WebSockets now; we will
    cover it in more detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this case function, we are sending the `ChatMessage` method to the room.
    We will split the messages in two parts: the username and the text, which is split
    by `:`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we also have a companion object for the sake of good practice. So, you
    can call `ChatUserActor`, passing the Actor system and a curried parameter for
    the out actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will move to the last Actor: the Bot Admin Actor, which should look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this Actor receives the reference of the chat room as a parameter.
    Using the Actor system, it gets the reference of the chat room Actor. This Actor
    receives an `ActorSystem` message by now.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Actor system variable called system, we will also schedule a `Tick`
    for this Actor for every ten seconds. This time, the window interval will be the
    time in which the bot will notify the chat room about the current status.
  prefs: []
  type: TYPE_NORMAL
- en: We will also override the `preStart` function. Akka will call this function
    when the Actor is created on the actor system. This implementation will send a
    message to the room, which is `JoinChatRoom`.
  prefs: []
  type: TYPE_NORMAL
- en: Like all Actors, there is the receive function implementation. First case with
    `ChatMessage` is returning Unit. If you want to make this bot respond to people,
    remove Unit and write the proper Scala code as you wish.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we will have the String message that will be sent to the
    chat room. Finally, after this case, we will have the `Tick` method, which will
    appear every ten seconds. So, we will use the `ActorHelper` to get the stats from
    the room, and then we will send a string message with the information about the
    room. This will trigger the second case and broadcast the message to the whole
    room.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a companion object. We don't want to have two instances of
    the bot, which is why we will control this object creation by design. We're done
    with the actors implementations. Next, we will need to work a new controller for
    the chat actors.
  prefs: []
  type: TYPE_NORMAL
- en: The chat controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need to create a new controller. This controller will be located at
    `ReactiveWebStore/app/controllers`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chat controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ChatController.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `ChatController` method will use Google Guice to get injected instances
    of Actor System and an Actor materializer instance. A materializer is needed because
    it will provide the instance of the out Actor for each user in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we will create an instance of the `ChatBotAdmin` method passing
    through the actor system, which Google Guice injected for us. For this controller,
    we will just have two functions: one function to render the chat UI, and the other
    one to serve the WebSocket.'
  prefs: []
  type: TYPE_NORMAL
- en: The Play framework already provides built-in integration with Akka and WebSockets.
    So, we will just need to use the `ActorFlow` method using the `actorRef` function
    in order to obtain an out Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will call the `ChatUserActor` companion object and create a chat user
    for the websocket passing out the Actor system the controller has. As you can
    see, this returns `WebSocket.accept`, which is a full duplex connection between
    the web browser and the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will need to expose our controller functions to the UI. We will need
    to add more routes to the `ReactiveWebStore/conf/routes` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The routes are done now.
  prefs: []
  type: TYPE_NORMAL
- en: Working on the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to code on the UI on both the HTML layout and the WebSocket
    code in JavaScript. We will need to create a new file, located at `ReactiveWebStore/app/views`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `chat_index.scala.html` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The UI is very simple. There is an input text for you to put your name and there
    is another one for the text message itself, and a send button. As you can see
    in the JavaScript code, the first thing that we will do is open a WebSocket connection
    to the `ws://localhost:9000/chat/ws` URL. Then, we will register the `init` function
    to run once the browser is ready.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function in JavaScript will create two functions for our WebSocket.
    One function will run when any error occurs and the other function will run for
    each message emitted by the Akka backend.
  prefs: []
  type: TYPE_NORMAL
- en: We will have a `doSend` function in JavaScript in order to send a message to
    the WebSocket. This message will be delivered to the controller and then to the
    Akka actors. You can also see some JQuery and HTML code in order to create new
    elements on the UI. This is done in order to display the message in the chat room.
  prefs: []
  type: TYPE_NORMAL
- en: OK, there is one more thing that we will need to do - add a reference to the
    chat UI on the main page of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Index.scala.html` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also use the opportunity to improve a little bit of the UI design using
    Twitter Bootstrap column design. In the last row, you can see our link to the
    chat UI. Now, we can run the application and see our chat working. Run `$ activator
    run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working on the UI](img/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, our new chat UI link is there. Now, let''s have fun with this
    new feature. Open four new browsers (simulate four different users), then go to
    the `http://localhost:9000/chat/index_socket` url and let''s have a little chat.
    You should see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working on the UI](img/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Almost done. Our chat feature works; however, we will need to do more than just
    a functional black box test on the UI. We will need unit tests. Luckily for us,
    we have the Akka testkit, which allows us to easily test actors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Akka tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create three more tests: one for each actor that we have. They are
    located at `ReactiveWebStore/test/`.'
  prefs: []
  type: TYPE_NORMAL
- en: Scala test for Akka Actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ChatUserActorSpec.scala` should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Akka testkit is very cool as it allows us to test actors with a very easy
    **Domain Specific Language** (**DSL**). It's possible to check the Actor mailbox,
    the Actor internal state, and so much more. There is one trick that we will need
    to do because we need to extend one class; in order to have Play working with
    the Scala test, we will need to use PlaySpec. However, we will also need to extend
    one class to make the Akka testkit work, which is `TestKit`. We can't extend both
    at the same time, but no worries, there is always a workaround.
  prefs: []
  type: TYPE_NORMAL
- en: The workaround here is to create a case class, make that case class extend `TestKit`,
    and then use it in a spec context, that is, in a new `Actor {}`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are checking if `ChatUserActor` can join the chat room properly. This
    is done by simply creating the Actor, as the Actor has a `preStart` method that
    will auto-join the room.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create a fake implementation of the out Actor here, which is
    why we have the `OutActor` implementation. We will create a probe to test the
    actor system, and we will also use a special function to test the Actors, called
    `TestActorRef`. This abstraction provides a way to access the Actor's state via
    `actorRef.underlyingActor`, and this is useful because you can check the Actor
    internal state to validate the code. The rest of the code is normal Akka and Scala
    test code. Let's move to the next test.
  prefs: []
  type: TYPE_NORMAL
- en: Chat room Actor test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ChatRoonActorSpec.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, here we have the same concepts as the other test. However, we have more
    usage of the Akka testkit DSL. For instance, we are using `expectMsg` on the probe
    to check if an Actor received a specific message. We are also using `awaitCond`
    to check the Actor's internal state in an assertion.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to test the last Actor method.
  prefs: []
  type: TYPE_NORMAL
- en: Chat Bot Admin Actor test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ChatBotAdminActorSpec.scala` file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For this test, we will check if the actor context was not null, and also if
    the room was created and the scheduler was also not null. All good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, that's it! This is the last actor test. Now we are completely done.
    You can run this test with `$ activator test`, or, if you prefer the activator,
    then use `"test-only TESTCLASSNAME" -Dsbt.task.forcegc=false` to run a specific
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with Akka actors and created a web
    chat using Akka, the Play framework, and WebSockets. Akka is a really powerful
    solution that can be used with or without the Play framework. Additionally, you
    learned about the Actor model, mailboxes, routing, persistence, Akka configuration,
    message patterns, and how to write code with actors in Scala and Play.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about REST, JSON, and how to model
    a REST API, as well as how to create a Scala client for your REST services.
  prefs: []
  type: TYPE_NORMAL
