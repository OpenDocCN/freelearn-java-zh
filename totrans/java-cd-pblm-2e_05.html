<html><head></head><body>
  <div id="_idContainer182" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-218" class="chapterTitle">Arrays, Collections, and Data Structures</h1>
    <p class="normal">This chapter includes 24 problems covering three main topics. We start with several problems related to the new Vector API dedicated to parallel data processing. We continue with several data structures, including Rope, Skip List, K-D Tree, Zipper, Binomial Heap, Fibonacci Heap, Pairing Heap, Huffman Coding, and so on. Finally, we discuss the three most popular join algorithms.</p>
    <p class="normal">At the end of this chapter, you’ll know how to write code for exploiting data parallel processing, exploiting a bunch of cool and lesser-known data structures, and how join operations work. And, as a bonus, you’ll be familiar with the JDK 21 Sequenced Collections API.</p>
    <h1 id="_idParaDest-219" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess on Java arrays, collections, and data structures. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="107"><strong class="keyWord">Introducing parallel computations with arrays</strong>: Explain in a few paragraphs what data parallel processing is and how it works.</li>
      <li class="numberedList"><strong class="keyWord">Covering the Vector API’s structure and terminology</strong>: Explain with examples the Vector API terminology. Cover notions such as element type, shape, species, lanes, and so on.</li>
      <li class="numberedList"><strong class="keyWord">Summing two arrays via the Vector API</strong>: Write an application that uses the Vector API for summing up two Java arrays.</li>
      <li class="numberedList"><strong class="keyWord">Summing two arrays unrolled via the Vector API</strong>: Write an application that uses the Vector API for summing two Java arrays using the <em class="italic">unrolled</em> technique. </li>
      <li class="numberedList"><strong class="keyWord">Benchmarking the Vector API</strong>: Given two arrays, <code class="inlineCode">x[]</code> and <code class="inlineCode">y[]</code>, write an application that benchmarks the computation <code class="inlineCode">z[] = x[] + y[]</code>, <code class="inlineCode">w[] = x[] * z[] * y[]</code>, <code class="inlineCode">k[] = z[] + w[] * y[]</code> using plain Java and the Vector API.</li>
      <li class="numberedList"><strong class="keyWord">Applying the Vector API to compute FMA</strong>: Provide a Vector API implementation of the famous Fused Multiply Add (FMA).</li>
      <li class="numberedList"><strong class="keyWord">Multiplying matrices via the Vector API</strong>: Write a Vector API implementation for multiplying two matrices. </li>
      <li class="numberedList"><strong class="keyWord">Hooking the image negative filter with the Vector API</strong>: Write a program that uses the Vector API to apply the negative filter to an image.</li>
      <li class="numberedList"><strong class="keyWord">Dissecting factory methods for collections</strong>: Exemplify several approaches for creating unmodifiable/immutable maps, lists, and sets in Java.</li>
      <li class="numberedList"><strong class="keyWord">Getting a list from a stream</strong>: Provide several snippets of code useful for collecting <code class="inlineCode">Stream</code> content into a Java <code class="inlineCode">List</code>.</li>
      <li class="numberedList"><strong class="keyWord">Handling map capacity</strong>: Explain what the capacity of a Java <code class="inlineCode">Map</code> is and how it can be used to control the number of effective mappings.</li>
      <li class="numberedList"><strong class="keyWord">Tackling Sequenced Collections</strong>: Provide in-depth dive into the JDK 21 Sequenced Collections API. Exemplify this API on your favorite Java collections and explain what the alternatives before this API are.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Rope data structure</strong>: Explain what the Rope data structure is and provide a Java implementation for its main operations (index, insert, delete, concatenation, and split).</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Skip List data structure</strong>: Explain and exemplify the Skip List data structure.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the K-D Tree data structure</strong>: Provide a brief introduction of K-D Trees and a Java implementation for 2-D Trees.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Zipper data structure</strong>: Explain and exemplify on a tree the Zipper data structure.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Binomial Heap data structure</strong>: Provide a deep coverage of a Binomial Heap data structure. Explain its main operations and exemplify them in a Java implementation.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Fibonacci Heap data structure</strong>: Explain and exemplify the Fibonacci Heap data structure.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Pairing Heap data structure</strong>: Explain and exemplify the Pairing Heap data structure.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Huffman Coding data structure</strong>: The Huffman Coding algorithm was developed by David A. Huffman in 1950. Explain its usage and exemplify it via a Java implementation.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Splay Tree data structure</strong>: A Splay Tree is a flavor of <strong class="keyWord">Binary Search Tree</strong> (<strong class="keyWord">BST</strong>). Explain what its particularities are and provide an implementation of its main operations.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Interval Tree data structure</strong>: An Interval Tree is another flavor of <strong class="keyWord">Binary Search Tree</strong> (<strong class="keyWord">BST</strong>). Highlight its usage and exemplify it via a Java implementation.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the Unrolled Linked List data structure</strong>: Explain and exemplify the Unrolled Linked List data structure.</li>
      <li class="numberedList"><strong class="keyWord">Implementing join algorithms</strong>: There are three famous join algorithms: Nested Loop Join, Hash Join, and Sort Merge Join. Explain and exemplify each of them in two tables that are involved in a one-to-many relationship.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter05</span></a>.</p>
    <h1 id="_idParaDest-220" class="heading-1">107. Introducing parallel computations with arrays</h1>
    <p class="normal">There was a time when CPUs were<a id="_idIndexMarker517"/> only capable of performing operations on data in the<a id="_idIndexMarker518"/> traditional mode known as <strong class="keyWord">Single Instruction, Single Data</strong> (<strong class="keyWord">SISD</strong>) or von Neumann architecture. In other words, one <a id="_idIndexMarker519"/>CPU cycle can process a single instruction and a single piece of data. The processor applies that instruction to that data and returns a result.</p>
    <p class="normal">Modern CPUs are capable of performing parallel computations and working in a mode known as <strong class="keyWord">Single Instruction, Multiple Data</strong> (<strong class="keyWord">SIMD</strong>). This<a id="_idIndexMarker520"/> time, one CPU cycle can apply a single instruction on multiple pieces of data simultaneously, which theoretically should speed things up and improve performance. The following diagram highlights these statements:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_01.png" alt="Figure 5.1.png"/></figure>
    <p class="packt_figref">Figure 5.1: SISD vs. SIMD</p>
    <p class="normal">If we add two arrays <em class="italic">X</em> and <em class="italic">Y</em> via an SISD-based CPU, then we expect that each CPU cycle will add an element from <em class="italic">X</em> with <a id="_idIndexMarker521"/>an element from <em class="italic">Y</em>. If we do the same task on a SIMD-based CPU, then each CPU cycle will simultaneously perform the addition on chunks from <em class="italic">X</em> and <em class="italic">Y</em>. This means that an SIMD CPU should complete the task<a id="_idIndexMarker522"/> faster than the SISD CPU.</p>
    <p class="normal">This is the big picture! When we come closer, we see that CPU architectures come in many flavors, so it is quite challenging to develop an application capable of leveraging the best performance of a specific platform.</p>
    <p class="normal">The two big competitors in the market, Intel and AMD, come with different SIMD implementations. It is not our goal to dissect this topic in detail, but it can be useful to know that the first popular desktop SIMD was introduced in 1996 by Intel under the name MMX (x86 architecture). In response, the AIM alliance (made up of Apple, IBM, and Freescale Semiconductor) promoted AltiVec – an integer and single-precision floating-point SIMD implementation. Later on, in 1999, Intel introduced the new SSE system (using 128-bit registers). </p>
    <p class="normal">Since then, SIMD has evolved via extensions such as Advanced Vector Extensions (AVX, AVX2 (256-bit registers) and AVX-512 (512-bit registers)). While AVX and AVX2 are supported by Intel and AMD, the AVX-512 introduced in 2022 is supported only by the latest Intel processors. The following figure helps illustrate all of this:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_02.png" alt="Figure 5.2.png"/></figure>
    <p class="packt_figref">Figure 5.2: SIMD implementation history</p>
    <p class="normal"><em class="italic">Figure 5.2</em> is just the SIMD representation of a CPU structure. In reality, the platforms are much more complex and come in many flavors. There is no silver bullet and each platform has its strong and weak <a id="_idIndexMarker523"/>points. Trying to explore the strong points and avoid the weaknesses is a real challenge for any programming language trying to leverage the performance of a specific <a id="_idIndexMarker524"/>platform with high expectations. </p>
    <p class="normal">For instance, what is the proper set of instructions that JVM should generate in order to squeeze out the best performance from a specific platform on computations that involve vectors (arrays)? Well, starting with JDK 16 (JEP 338), Java provides an incubator module, <code class="inlineCode">jdk.incubator.vector</code>, known as the <a id="_idIndexMarker525"/>Vector API. The goal of this API is to allow developers to express, in a very platform-agnostic way, vector computations that are transformed at runtime in optimal vector hardware instructions on supported CPU architectures.</p>
    <p class="normal">Starting with JDK 21 (JEP 448), the Vector API reached the sixth incubator, so we can try out some examples that take advantage of data-parallel accelerated code in contrast to scalar implementation. Running examples based on this incubator API can be done by adding the <code class="inlineCode">--add-modules=jdk.incubator.vector</code> and <code class="inlineCode">--enable-preview</code> VM options.</p>
    <p class="normal">But, before that, let’s cover the Vector API structure and terminology.</p>
    <h1 id="_idParaDest-221" class="heading-1">108. Covering the Vector API’s structure and terminology</h1>
    <p class="normal">The Vector API is mapped by the <code class="inlineCode">jdk.incubator.vector</code> module (and a package with the same name). A <code class="inlineCode">jdk.incubator.vector.Vector</code> instance starts from a generic abstract combination<a id="_idIndexMarker526"/> characterized by a <em class="italic">type</em> and a <em class="italic">shape</em>. A vector is an instance of the <code class="inlineCode">Vector&lt;E&gt;</code> class.</p>
    <h2 id="_idParaDest-222" class="heading-2">The vector element type</h2>
    <p class="normal">A <code class="inlineCode">Vector&lt;E&gt;</code> has an <em class="italic">element type</em> (<code class="inlineCode">ETYPE</code>), which is one of the Java primitive types: <code class="inlineCode">byte</code>, <code class="inlineCode">float</code>, <code class="inlineCode">double</code>, <code class="inlineCode">short</code>, <code class="inlineCode">int</code>, or <code class="inlineCode">long</code>. When<a id="_idIndexMarker527"/> we write <code class="inlineCode">Vector&lt;E&gt;</code>, we say that <code class="inlineCode">E</code> is the boxed version of <code class="inlineCode">ETYPE</code> (for instance, when we write <code class="inlineCode">Vector&lt;Float&gt;</code>, <code class="inlineCode">E</code> is <code class="inlineCode">Float</code>, and <code class="inlineCode">ETYPE</code> is <code class="inlineCode">float</code>). For more convenience, Java declares a specialized subtype for each <em class="italic">element type</em>, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_03.png" alt="Figure 5.3.png"/></figure>
    <p class="packt_figref">Figure 5.3: Specialized vector subtypes</p>
    <p class="normal">Even if <code class="inlineCode">E</code> is a boxed type, there is no boxing-unboxing overhead because <code class="inlineCode">Vector&lt;E&gt;</code> works internally on <code class="inlineCode">ETYPE</code> and thus on primitive types.</p>
    <p class="normal">Besides the <em class="italic">element type</em>, a vector is also characterized by a <em class="italic">shape</em>.</p>
    <h2 id="_idParaDest-223" class="heading-2">The vector shape</h2>
    <p class="normal">A vector is also characterized by a <em class="italic">shape</em> (also referred to as <code class="inlineCode">VSHAPE</code>) representing the size or capacity in bits<a id="_idIndexMarker528"/> of the vector. It can be 64, 128, 256, or 512 bits. Each of these values is wrapped by the <code class="inlineCode">VectorShape</code> enumeration (for instance, the <code class="inlineCode">S_128_BIT</code> enum item represents a shape of length 128 bits) next to an extra enum item representing the maximum length supported on the platform (<code class="inlineCode">S_Max_BIT</code>). This is determined automatically on the currently running Java platform.</p>
    <h2 id="_idParaDest-224" class="heading-2">The vector species</h2>
    <p class="normal">A vector characterized by its <em class="italic">element type</em> and <em class="italic">shape </em>determines a unique <em class="italic">vector species, </em>which is a fixed instance of <code class="inlineCode">VectorSpecies&lt;E&gt;</code>. This instance is shared by all vectors having the same <a id="_idIndexMarker529"/>shape and <code class="inlineCode">ETYPE</code>. We can think of <code class="inlineCode">VectorSpecies&lt;E&gt;</code> as a factory used to create vectors of the required <em class="italic">element type</em> and <em class="italic">shape</em>. For instance, we can define a factory for creating vectors of the <code class="inlineCode">double</code> type having a size of 512 bits as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = VectorSpecies.of(
<span class="hljs-type">  double</span>.class, VectorShape.S_512_BIT);
</code></pre>
    <p class="normal">If you just need a factory for vectors of the maximal bit-size supported by the current platform independent of the element type, then rely on <code class="inlineCode">S_Max_BIT</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = VectorSpecies.of(
<span class="hljs-type">  double</span>.class, VectorShape.S_Max_BIT);
</code></pre>
    <p class="normal">If you just need the largest vector <em class="italic">species</em> for your <em class="italic">element type</em> (here, <code class="inlineCode">double</code>) for the current platform, then rely on <code class="inlineCode">ofLargestShape()</code>. This vector <em class="italic">species</em> is chosen by the platform and it has a <em class="italic">shape</em> with the largest possible bit-size for your <em class="italic">element type</em> (don’t confuse this with <code class="inlineCode">S_Max_BIT</code>, which is independent of the <em class="italic">element type</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = 
  VectorSpecies.ofLargestShape(<span class="hljs-type">double</span>.class);
</code></pre>
    <p class="normal">Or, maybe you need the vector <em class="italic">species </em>preferred by the current platform for your <em class="italic">element type</em>. This can be achieved via <code class="inlineCode">ofPreferred()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = 
  VectorSpecies.ofPreferred(<span class="hljs-type">double</span>.class);
</code></pre>
    <p class="normal">The preferred <em class="italic">species</em> is the most convenient approach when you don’t want to bother specifying an explicit <em class="italic">shape</em>.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The preferred <em class="italic">species</em> is the most optimal <em class="italic">shape</em> for the given <em class="italic">element type</em> on the current platform (runtime).</p>
    </div>
    <p class="normal">Moreover, for convenience, each specialized vector (<code class="inlineCode">IntVector</code>, <code class="inlineCode">FloatVector</code>, and so on) defines a set of static<a id="_idIndexMarker530"/> fields for covering all possible <em class="italic">species</em>. For example, the static field <code class="inlineCode">DoubleVector.SPECIES_512</code> can be used for <em class="italic">species</em> representing <code class="inlineCode">DoubleVector</code> instances of 512-bit size (<code class="inlineCode">VectorShape.S_512_BIT</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = 
  DoubleVector.SPECIES_512;
</code></pre>
    <p class="normal">If you want the maximal <em class="italic">species</em>,<em class="italic"> </em>then rely on <code class="inlineCode">SPECIES_MAX</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = 
  DoubleVector.SPECIES_MAX;
</code></pre>
    <p class="normal">Or, if you want the preferred <em class="italic">species</em>,<em class="italic"> </em>then rely on <code class="inlineCode">SPECIES_PREFERRED</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Double&gt; VS = 
  DoubleVector.SPECIES_PREFERRED;
</code></pre>
    <p class="normal">You can easily inspect the <em class="italic">element type</em> and <em class="italic">shape</em> of a <code class="inlineCode">VectorSpecies</code> instance via the <code class="inlineCode">elementType()</code> and <code class="inlineCode">vectorShape()</code> methods as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">System.out.println(<span class="hljs-string">"Element type: "</span> + VS.elementType());
System.out.println(<span class="hljs-string">"Shape: "</span> + VS.vectorShape());
</code></pre>
    <p class="normal">So far, you know how to create vector <em class="italic">species</em> (vector factories). But, before starting to create vectors and apply operations on them, let’s talk about vector <em class="italic">lanes</em>.</p>
    <h2 id="_idParaDest-225" class="heading-2">Vector lanes</h2>
    <p class="normal">A <code class="inlineCode">Vector&lt;E&gt;</code> is like a fixed-sized Java array made of <em class="italic">lanes</em>. The <em class="italic">lane count</em> is returned by the <code class="inlineCode">length()</code> method <a id="_idIndexMarker531"/>and is called <code class="inlineCode">VLENGTH</code>. The <em class="italic">lane count</em> is equal to the number of scalar elements stored in that vector.</p>
    <p class="normal">If you know the <em class="italic">element size</em> and the <em class="italic">shape</em> of the vector, then you can compute the number of <em class="italic">lanes</em> as (<em class="italic">shape</em>/<em class="italic">element size</em>). You should get the same result as returned by <code class="inlineCode">length()</code>. The <em class="italic">element size</em> is returned by <code class="inlineCode">elementSize()</code>, and the <em class="italic">shape</em> is returned by <code class="inlineCode">vectorBitSize()</code> or <code class="inlineCode">vectorShape().vectorBitSize()</code>. </p>
    <p class="normal">For instance, a vector whose <em class="italic">shape</em> is 256 bits with an <em class="italic">element type</em> of <code class="inlineCode">float</code> (which is 32 bits (4 bytes) in Java) holds 8 <code class="inlineCode">float</code> scalar elements, so it has 8 <em class="italic">lanes</em>. The following figure illustrates this statement:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_04.png" alt="Figure 5.4.png"/></figure>
    <p class="packt_figref">Figure 5.4: Computing the number of lanes</p>
    <p class="normal">Based on this example, you <a id="_idIndexMarker532"/>can easily compute the number of <em class="italic">lanes</em> for any other vector configuration. Next, let’s see why it is important to know about <em class="italic">lanes</em>.</p>
    <h2 id="_idParaDest-226" class="heading-2">Vector operations</h2>
    <p class="normal">Applying operations on vectors is the climax of our efforts. The number of <em class="italic">lanes </em>estimates the SIMD performance<a id="_idIndexMarker533"/> because vector operations operate on <em class="italic">lanes</em>. A single vector operation affects a <em class="italic">lane</em> as a unit of work. For instance, if our vector has 8 <em class="italic">lanes</em>, it means that SIMD will perform 8 <em class="italic">lanewise </em>operations at once. </p>
    <p class="normal">In the following figure, you can see a comparison of SISD vs. SIMD in this context:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_05.png" alt="Figure 5.5.png"/></figure>
    <p class="packt_figref">Figure 5.5: SISD vs. SIMD</p>
    <p class="normal">While SISD has a <a id="_idIndexMarker534"/>single scalar as a unit of work, SIMD has 8 scalars (8 <em class="italic">lanes</em>), which explains why SIMD offers a significant performance bump over SISD.</p>
    <p class="normal">So, a <code class="inlineCode">Vector&lt;E&gt;</code> is operated on <em class="italic">lanes</em>. Mainly, we have <em class="italic">lanewise</em> operations (such as addition, division, and bit shifts) and <em class="italic">cross-lane</em> operations that reduce all <em class="italic">lanes</em> to a single scalar (for instance, summing all <em class="italic">lanes</em>). The following figure depicts these statements:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_06.png" alt="Figure 5.6.png"/></figure>
    <p class="packt_figref">Figure 5.6: Lanewise and cross-lane operations</p>
    <p class="normal">Moreover, a <code class="inlineCode">Vector&lt;E&gt;</code> can be operated on with a <code class="inlineCode">VectorMask&lt;E&gt;</code>. This is a sequence of <code class="inlineCode">boolean</code> values that can be used by some vector operations to filter the selection and operation of lane elements of the given input vectors. Check out the following figure (the addition operation is applied only when the mask contains 1):</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_07.png" alt="Figure 5.7.png"/></figure>
    <p class="packt_figref">Figure 5.7: Lanewise addition with mask</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Note that masks are not supported by all CPUs. A CPU that doesn’t support masks may face degradation in performance.</p>
    </div>
    <p class="normal">Speaking about vector<a id="_idIndexMarker535"/> operations, you should definitely take a look at the <code class="inlineCode">Vector</code> and <code class="inlineCode">VectorOperators</code> documentation. In the <code class="inlineCode">Vector</code> class, we have methods that apply operations between two vectors. For instance, we have methods for binary operations (such as <code class="inlineCode">add()</code>, <code class="inlineCode">div()</code>, <code class="inlineCode">sub()</code>, and <code class="inlineCode">mul()</code>), for comparisons (such as <code class="inlineCode">eq()</code>, <code class="inlineCode">lt()</code>, and <code class="inlineCode">compare()</code>), for mathematical operations (such as <code class="inlineCode">abs()</code>), and so on. Moreover, in <code class="inlineCode">VectorOperators</code> we have a bunch of nested classes (for instance, <code class="inlineCode">VectorOperators.Associative</code>) and several constants representing <em class="italic">lanewise</em> operations such as trigonometric functions (<code class="inlineCode">SIN</code>, <code class="inlineCode">COS</code>, and so on), bitwise shifting operations (<code class="inlineCode">LSHL</code> and <code class="inlineCode">LSHR</code>), mathematical operations (<code class="inlineCode">ABS</code>, <code class="inlineCode">SQRT</code>, and <code class="inlineCode">POW</code>), and so on.</p>
    <p class="normal">In the following <a id="_idIndexMarker536"/>problems, you’ll see a part of these operations at work, but for now let’s touch on the last essential topic, creating vectors.</p>
    <h2 id="_idParaDest-227" class="heading-2">Creating vectors</h2>
    <p class="normal">We already know that having a <code class="inlineCode">VectorSpecies</code> is like having a factory for creating vectors of the required <em class="italic">element type</em> and <em class="italic">shape</em>. Now, let’s see how we can use such a factory to effectively <a id="_idIndexMarker537"/>create vectors (fill them up with scalars) that get involved in solving real problems.</p>
    <p class="normal">Let’s assume the following <em class="italic">species</em> (a vector of 8 <em class="italic">lanes</em>, 32*8=256):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Integer&gt; VS256 
  = IntVector.SPECIES_256;
</code></pre>
    <p class="normal">Next, let’s create the most common types of vectors.</p>
    <h3 id="_idParaDest-228" class="heading-3">Creating vectors of zeros</h3>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker538"/> need a vector containing only zeros. A quick approach relies on the <code class="inlineCode">zero()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// [0, 0, 0, 0, 0, 0, 0, 0]</span>
Vector&lt;Integer&gt; v = VS256.zero();
</code></pre>
    <p class="normal">This produced a vector with 8 <em class="italic">lanes</em> of 0.0. The same thing can be obtained from the specialized <code class="inlineCode">IntVector</code> class as well via <code class="inlineCode">zero(VectorSpecies&lt;Integer&gt; species)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.zero(VS256);
</code></pre>
    <p class="normal">You can easily extrapolate this example to <code class="inlineCode">FloatVector</code>, <code class="inlineCode">DoubleVector</code>, and so on.</p>
    <h3 id="_idParaDest-229" class="heading-3">Creating vectors of the same primitive value</h3>
    <p class="normal">Creating a vector<a id="_idIndexMarker539"/> and loading it up with a primitive value can quickly be accomplished via the <code class="inlineCode">broadcast()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// [5, </span><span class="hljs-comment">5, 5, 5, 5, 5, 5, 5]</span>
Vector&lt;Integer&gt; v = VS256.broadcast(<span class="hljs-number">5</span>);
</code></pre>
    <p class="normal">The same thing can be obtained from the specialized <code class="inlineCode">IntVector</code> class as well via <code class="inlineCode">broadcast(VectorSpecies&lt;Integer&gt; species, int e)</code> or <code class="inlineCode">broadcast(VectorSpecies&lt;Integer&gt; species, long e)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.broadcast(VS256, <span class="hljs-number">5</span>);
</code></pre>
    <p class="normal">Of course, we can<a id="_idIndexMarker540"/> use it to broadcast a vector of zeros as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// [0, 0, 0, 0</span><span class="hljs-comment">, 0, 0, 0, 0]</span>
Vector&lt;Integer&gt; v = VS256.broadcast(<span class="hljs-number">0</span>);
IntVectorv = IntVector.broadcast(VS256, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">Finally, let’s see the most common use case for creating a vector.</p>
    <h3 id="_idParaDest-230" class="heading-3">Creating vectors from Java arrays</h3>
    <p class="normal">Creating vectors from<a id="_idIndexMarker541"/> Java arrays is the most common use case. Practically, we start from a Java array and call the <code class="inlineCode">fromArray()</code> method name. </p>
    <h4 class="heading-4">Using fromArray() from VectorSpecies</h4>
    <p class="normal">The <code class="inlineCode">fromArray()</code> method is available in <code class="inlineCode">VectorSpecies</code> as <code class="inlineCode">fromArray(Object a, int offset)</code>. Here is an example <a id="_idIndexMarker542"/>of creating a vector from an array of integers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};  
Vector&lt;Integer&gt; v = VS256.fromArray(varr, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">Since the <code class="inlineCode">varr</code> length (8) is equal to the vector length and we start from index 0, the resulting vector will contain all the scalars from the array. This is no longer true in the following example where the last 4 scalars will not be part of the resulting vector:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>};
Vector&lt;Integer&gt; v = VS256.fromArray(varr, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">The scalars 8, 9, 10, and 11 are not present in the resulting array. Here is another example, using <code class="inlineCode">offset</code> = 2:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>};
Vector&lt;Integer&gt; v = VS256.fromArray(varr, <span class="hljs-number">2</span>);
</code></pre>
    <p class="normal">This time, the scalars 0, 1, 10, and 11 are not present in the resulting array.</p>
    <p class="normal">Pay attention that the length of the Java array shouldn’t be less than the vector’s length. For instance, the following example will cause an exception:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
<span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, varr, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">Since the Java array<a id="_idIndexMarker543"/> length is 6 (less than 8), this will cause a <code class="inlineCode">java.lang.IndexOutOfBoundsException</code> instance. So, the minimum accepted length for <code class="inlineCode">varr</code> is 8.</p>
    <h4 class="heading-4">Using fromArray() from specialized vectors</h4>
    <p class="normal">Each specialized vector class <a id="_idIndexMarker544"/>provides a bunch of <code class="inlineCode">fromArray()</code> flavors. For instance, the <code class="inlineCode">IntVector</code> exposes the popular <code class="inlineCode">fromArray(VectorSpecies&lt;Integer&gt; species, int[] a, int offset)</code> method, which can be used in a straightforward way:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[] {<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, varr, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">If we prefer the <code class="inlineCode">fromArray(VectorSpecies&lt;Integer&gt; species, int[] a, int offset, VectorMask&lt;Integer&gt; m)</code> flavor, then we can filter the selected scalars from the Java array via <code class="inlineCode">VectorMask</code>. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>};
<span class="hljs-type">boolean</span>[] bm = <span class="hljs-keyword">new</span> <span class="hljs-title">boolean</span>[]{
  <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>};
<span class="hljs-type">VectorMask</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> VectorMask.fromArray(VS256, bm, <span class="hljs-number">0</span>);
<span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, varr, <span class="hljs-number">0</span>, m);
</code></pre>
    <p class="normal">Based on a one-to-one match, we can easily observe that the resulting vector will fetch only the scalars 2, 5, and 6. The resulting vector will be: [0, 0, 2, 0, 0, 5, 6, 0].</p>
    <p class="normal">Another flavor of <code class="inlineCode">fromArray()</code> is <code class="inlineCode">fromArray(VectorSpecies&lt;Integer&gt; species, int[] a, int offset, int[] indexMap, int mapOffset)</code>. This time, we use a map of indexes to filter the selected scalars:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">29</span>};
<span class="hljs-type">int</span>[] imap = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>};
<span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, varr, <span class="hljs-number">0</span>, imap, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">The resulting array will be: [11, 11, 11, 12, 12, 29, 29, 29]. We have 11 from index 0, 12 from index 1, and 29<a id="_idIndexMarker545"/> from index 6.</p>
    <p class="normal">In addition, we can apply <code class="inlineCode">VectorMask</code> to the previous index map via <code class="inlineCode">fromArray(VectorSpecies&lt;Integer&gt; species, int[] a, int offset, int[] indexMap, int mapOffset, VectorMask&lt;Integer&gt; m)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] varr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">17</span>, <span class="hljs-number">20</span>, <span class="hljs-number">22</span>, <span class="hljs-number">29</span>};
<span class="hljs-type">boolean</span>[] bm = <span class="hljs-keyword">new</span> <span class="hljs-title">boolean</span>[]{
  <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>};
<span class="hljs-type">int</span>[] imap = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>};
<span class="hljs-type">VectorMask</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> VectorMask.fromArray(VS256, bm, <span class="hljs-number">0</span>);
<span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, varr, <span class="hljs-number">0</span>, imap, <span class="hljs-number">0</span>, m);
</code></pre>
    <p class="normal">The resulting vector is: <code class="inlineCode">[0, 0, 11, 0, 0, 29, 29, 0]</code>.</p>
    <h3 id="_idParaDest-231" class="heading-3">Creating vectors from memory segments</h3>
    <p class="normal"><em class="italic">Memory segments</em> are a topic covered in detail in <em class="italic">Chapter 7</em> as part of the Foreign Function and Memory API, but as<a id="_idIndexMarker546"/> a quick teaser, here is an example of creating a vector from a memory segment via <code class="inlineCode">IntVector.fromMemorySegment()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">v</span>;
<span class="hljs-type">MemorySegment</span> <span class="hljs-variable">segment</span>;
<span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">arena</span> <span class="hljs-operator">=</span> Arena.ofConfined()) { 
  segment = arena.allocate(<span class="hljs-number">32</span>);
  segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>);
  segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">1</span>, <span class="hljs-number">21</span>);
  <span class="hljs-comment">// continue set: 12, 7, 33, 1, 3</span>
  segment.setAtIndex(ValueLayout.JAVA_INT, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>);
  v = IntVector.fromMemorySegment(VS256, segment, 
    <span class="hljs-number">0</span>, ByteOrder.nativeOrder());
}
</code></pre>
    <p class="normal">The created vector is: [11, 21, 12, 7, 33, 1, 3, 6].</p>
    <p class="normal">In the bundled code, you can find several more examples for manipulating data across lane boundaries such as slicing, un-slicing, shuffling/rearranging, compressing, expanding, converting, casting, and reinterpreting shapes.</p>
    <p class="normal">In the next problem, we<a id="_idIndexMarker547"/> start creating complete examples that exploit what we’ve learned so far.</p>
    <h1 id="_idParaDest-232" class="heading-1">109. Summing two arrays via the Vector API</h1>
    <p class="normal">Summing two <a id="_idIndexMarker548"/>arrays is the perfect start for applying what we’ve learned in the preceding two problems. Let’s assume that we have the following Java arrays:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>};
<span class="hljs-type">int</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>};
</code></pre>
    <p class="normal">For computing <code class="inlineCode">z=x+y</code> via the Vector API, we have to create two <code class="inlineCode">Vector</code> instances and rely on the <code class="inlineCode">add()</code> operation, <code class="inlineCode">z=x.add(y)</code>. Since the Java arrays hold integer scalars, we can use the <code class="inlineCode">IntVector</code> specialization as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">xVector</span> = IntVector.fromArray(
  IntVector.SPECIES_256, x, <span class="hljs-number">0</span>);
<span class="hljs-type">IntVector</span> <span class="hljs-variable">yVector</span> = IntVector.fromArray(
  IntVector.SPECIES_256, y, <span class="hljs-number">0</span>);
</code></pre>
    <p class="normal">In Java, an integer needs 4 bytes, so 32 bits. Since <code class="inlineCode">x</code> and <code class="inlineCode">y</code> hold 8 integers, we need 8*32=256 bits to represent them in our vector. So, relying on <code class="inlineCode">SPECIES_256</code> is the right choice.</p>
    <p class="normal">Next, we can apply the <code class="inlineCode">add()</code> operation as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">IntVector</span> <span class="hljs-variable">zVector</span> <span class="hljs-operator">=</span> xVector.add(yVector);
</code></pre>
    <p class="normal">Done! It is time for JVM to generate the optimal set of instructions (data-parallel accelerated code) that will compute our addition. The result will be a vector as [5, 7, 5, 9, 6, 9, 15, 15].</p>
    <p class="normal">This was a simple case but not quite realistic. Who would employ parallel computational capabilities for summing up two arrays having a couple of elements?! In the real world, <code class="inlineCode">x</code> and <code class="inlineCode">y</code> may have much more than 8 elements. Most probably, <code class="inlineCode">x</code> and <code class="inlineCode">y</code> have millions of items and are involved in multiple calculation cycles. That is exactly when we can leverage the power of parallel computation.</p>
    <p class="normal">But, for now, let’s assume that <code class="inlineCode">x</code> and <code class="inlineCode">y</code> are as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">x = {<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, 
     <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
y = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, 
     <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>};
</code></pre>
    <p class="normal">If we apply the previous code (based on <code class="inlineCode">SPECIES_256</code>), the result will be the same because our vectors<a id="_idIndexMarker549"/> can accommodate only the first 8 scalars and will ignore the rest. If we apply the same logic but use <code class="inlineCode">SPECIES_PREFERRED</code>, then the result is unpredictable since the vector’s shape is specific to the current platform. However, we can intuit that we will accommodate the first <code class="inlineCode">n</code> (whatever that <code class="inlineCode">n</code> is) scalars but not all.</p>
    <p class="normal">This time, we need to chunk the arrays and use a loop to traverse the arrays and compute <code class="inlineCode">z_chunk = x_chunk + y_chunk</code>. The result of summing two chunks is collected in a third array (<code class="inlineCode">z</code>) until all chunks are processed. We define a method that starts as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x[], </span><span class="hljs-type">int</span><span class="hljs-params"> y[], </span><span class="hljs-type">int</span><span class="hljs-params"> z[])</span> {
  ...
</code></pre>
    <p class="normal">But, how big should a chunk be? The first challenge is represented by the loop design. The loop should start from 0, but what are the upper bound and the step? Typically, the upper bound is the length of <code class="inlineCode">x</code>, so 34. But, using <code class="inlineCode">x.length</code> is not exactly useful because it doesn’t guarantee that our vectors will accommodate as many scalars as possible from the arrays. What we are looking for is the largest multiple of <code class="inlineCode">VLENGTH</code> (vector’s length) that is less than or equal to <code class="inlineCode">x.length</code>. In our case, that is the largest multiple of 8 that is less than 34, so 32. This is exactly what the <code class="inlineCode">loopBound()</code> method returns, so we can write the loop as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Integer&gt; VS256 
  = IntVector.SPECIES_256;
  
<span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS256.loopBound(x.length); 
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; upperBound; i += VS256.length()) {
  ...
}
</code></pre>
    <p class="normal">The loop step is the vector’s length. The following diagram pre-visualizes the code:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_08.png" alt="Figure 5.8.png"/></figure>
    <p class="packt_figref">Figure 5.8: Computing z = x + y in chunks</p>
    <p class="normal">So, at the first iteration, our vectors will accommodate the scalars from index 0 to 7. At the second iteration, the<a id="_idIndexMarker550"/> scalars are from index 8 to 15, and so on. Here is the complete code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Integer&gt; VS256 
  = IntVector.SPECIES_256;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sum</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x[], </span><span class="hljs-type">int</span><span class="hljs-params"> y[], </span><span class="hljs-type">int</span><span class="hljs-params"> z[])</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS256.loopBound(x.length);   
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; upperBound; i += VS256.length()) {
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">xVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, y, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">zVector</span> <span class="hljs-operator">=</span> xVector.add(yVector);
    zVector.intoArray(z, i);
  }
}
</code></pre>
    <p class="normal">The <code class="inlineCode">intoArray(int[] a, int offset)</code> transfers the scalars from a vector to a Java array. This method comes in different flavors next to <code class="inlineCode">intoMemorySegment()</code>.</p>
    <p class="normal">The resulting array will be: [7, 11, 7, 10, 2, 5, 11, 11, 6, 12, 9, 11, 4, 8, 8, 9, 6, 8, 10, 12, 8, 12, 12, 13, 4, 8, 8, 9, 6, 8, 10, 12, <strong class="keyWord">0</strong>, <strong class="keyWord">0</strong>]. Check out the last two items … they are equal to 0. These are the items that result from <code class="inlineCode">x.length - upperBound</code> = 34 – 32 = 2. When the largest multiple of <code class="inlineCode">VLENGTH</code> (vector’s length) is equal to <code class="inlineCode">x.length</code>, this difference will be 0, otherwise, we will have <a id="_idIndexMarker551"/>the rest of the items that have not been computed. So, the previous code will work as expected only in the particular case when <code class="inlineCode">VLENGTH</code> (vector’s length) is equal to <code class="inlineCode">x.length</code>.</p>
    <p class="normal">Covering the remaining items can be accomplished in at least two ways. First, we can rely on a <code class="inlineCode">VectorMask</code> as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumMask</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x[], </span><span class="hljs-type">int</span><span class="hljs-params"> y[], </span><span class="hljs-type">int</span><span class="hljs-params"> z[])</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS256.loopBound(x.length);
  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (; i &lt; upperBound; i += VS256.length()) {
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">xVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, y, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">zVector</span> <span class="hljs-operator">=</span> xVector.add(yVector);
    zVector.intoArray(z, i);
  }
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (i &lt;= (x.length - </strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">)) { </strong></span>
<span class="code-highlight"><strong class="hljs-slc">    VectorMask&lt;Integer&gt; mask </strong></span>
<span class="code-highlight"><strong class="hljs-slc">      = VS256.indexInRange(i, x.length);</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-type-slc">IntVector</strong><strong class="hljs-slc"> </strong><strong class="hljs-variable-slc">zVector</strong><strong class="hljs-slc"> </strong><strong class="hljs-operator-slc">=</strong><strong class="hljs-slc"> IntVector.fromArray(VS256, x, i, mask)</strong></span>
<span class="code-highlight"><strong class="hljs-slc">          .add(IntVector.fromArray(VS256, y, i, mask));</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    zVector.intoArray(z, i, mask);</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  }</strong></span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">indexInRange()</code> computes a mask in the range <code class="inlineCode">[i, x.length-1]</code>. Applying this mask will result in the following <code class="inlineCode">z</code> array: [7, 11, 7, 10, 2, 5, 11, 11, 6, 12, 9, 11, 4, 8, 8, 9, 6, 8, 10, 12, 8, 12, 12, 13, 4, 8, 8, 9, 6, 8, 10, 12, 5, 12]. Now, the last two items are computed as expected.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">As a rule of thumb, avoid using <code class="inlineCode">VectorMask</code> in loops. They are quite expensive and may lead to a significant degradation in performance.</p>
    </div>
    <p class="normal">Another approach for <a id="_idIndexMarker552"/>dealing with these remaining items is to go for a piece of traditional Java code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumPlus</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x[], </span><span class="hljs-type">int</span><span class="hljs-params"> y[], </span><span class="hljs-type">int</span><span class="hljs-params"> z[])</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS256.loopBound(x.length);
  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (; i &lt; upperBound; i += VS256.length()) {
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">xVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, y, i);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">zVector</span> <span class="hljs-operator">=</span> xVector.add(yVector);
    zVector.intoArray(z, i);
  }
  <span class="hljs-keyword">for</span> (; i &lt; x.length; i++) {
    z[i] = x[i] + y[i];
  }
}
</code></pre>
    <p class="normal">Practically, we sum up the remaining items in a Java traditional loop outside the vectors loop. You can check these examples in the bundled code.</p>
    <h1 id="_idParaDest-233" class="heading-1">110. Summing two arrays unrolled via the Vector API</h1>
    <p class="normal">In this problem, we take<a id="_idIndexMarker553"/> the example of summing two arrays from the previous problem and re-write the loop in an <em class="italic">unrolled</em> fashion. </p>
    <p class="normal"><em class="italic">Loop unrolling</em> can be applied manually (as we will do here) or by the compiler, and it stands for an optimization technique meant to reduce the loop iteration count. </p>
    <p class="normal">In our case, in order to reduce the loop iteration count, we use more vectors to repeat the sequence of loop body statements that are responsible for summing the items. If we know that our arrays are long enough to always require at least 4 loop iterations, then rewriting the code as<a id="_idIndexMarker554"/> follows will reduce the loop iterations by 4 times:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sumUnrolled</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> x[], </span><span class="hljs-type">int</span><span class="hljs-params"> y[], </span><span class="hljs-type">int</span><span class="hljs-params"> z[])</span> {
 <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> VS256.length();
 <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span> (; i &lt;= (x.length - width * <span class="hljs-number">4</span>); i += width * <span class="hljs-number">4</span>) {
<span class="hljs-type">  IntVector</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i)
      .add(IntVector.fromArray(VS256, y, i));
<span class="hljs-type">  IntVector</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i + width)
      .add(IntVector.fromArray(VS256, y, i + width));
<span class="hljs-type">  IntVector</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i + width * <span class="hljs-number">2</span>)
      .add(IntVector.fromArray(VS256, y, i + width * <span class="hljs-number">2</span>));
<span class="hljs-type">  IntVector</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS256, x, i + width * <span class="hljs-number">3</span>)
      .add(IntVector.fromArray(VS256, y, i + width * <span class="hljs-number">3</span>));
  s1.intoArray(z, i);
  s2.intoArray(z, i + width);
  s3.intoArray(z, i + width * <span class="hljs-number">2</span>);
  s4.intoArray(z, i + width * <span class="hljs-number">3</span>);
 }
 <span class="hljs-keyword">for</span> (; i &lt; x.length; i++) {
  z[i] = x[i] + y[i];
 }
}
</code></pre>
    <p class="normal">Consider the following <code class="inlineCode">x</code> and <code class="inlineCode">y</code> vectors:</p>
    <pre class="programlisting code"><code class="hljs-code">x = {<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, 
<span class="hljs-number">     4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
y = {<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, 
<span class="hljs-number">     8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>};
<span class="hljs-type">int</span>[] z = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[x.length];
</code></pre>
    <p class="normal">Calling the <code class="inlineCode">sumPlus(x, y, z)</code> method written in the previous problem will require 4 loop iterations to complete. Calling <code class="inlineCode">sumUnrolled(x, y, z)</code> will require a single iteration to complete. </p>
    <h1 id="_idParaDest-234" class="heading-1">111. Benchmarking the Vector API</h1>
    <p class="normal">Benchmarking the <a id="_idIndexMarker555"/>Vector API can be accomplished via JMH. Let’s consider three Java arrays (<code class="inlineCode">x</code>, <code class="inlineCode">y</code>, <code class="inlineCode">z</code>) each of 50,000,000 integers, and the following computation:</p>
    <pre class="programlisting code"><code class="hljs-code">z[i] = x[i] + y[i];
w[i] = x[i] * z[i] * y[i];
k[i] = z[i] + w[i] * y[i];
</code></pre>
    <p class="normal">So, the final result is stored in a Java array named <code class="inlineCode">k</code>. And, let’s consider the following benchmark containing four different implementations of this computation (using a mask, no mask, <em class="italic">unrolled</em>, and plain scalar Java with arrays):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>
<span class="hljs-meta">@BenchmarkMode({Mode.AverageTime, Mode.Throughput})</span>
<span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span>
<span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span>
<span class="hljs-meta">@State(Scope.Benchmark)</span>
<span class="hljs-meta">@Fork(value = 1, warmups = 0, </span>
<span class="hljs-meta">    jvmArgsPrepend = {"--add-modules=jdk.incubator.vector"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Integer&gt; VS 
    = IntVector.SPECIES_PREFERRED;
  ...
  <span class="hljs-meta">@Benchmark</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeWithMask</span><span class="hljs-params">(Blackhole blackhole)</span> {…}
  <span class="hljs-meta">@Benchmark</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeNoMask</span><span class="hljs-params">(Blackhole blackhole)</span> {…}
  <span class="hljs-meta">@Benchmark</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeUnrolled</span><span class="hljs-params">(Blackhole blackhole)</span> {…}
  <span class="hljs-meta">@Benchmark</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">computeArrays</span><span class="hljs-params">(Blackhole blackhole)</span> {…}
}
</code></pre>
    <p class="normal">Running this benchmark on an Intel(R) Core(TM) i7-3612QM CPU @ 2.10GHz machine running Windows 10 produced the following results:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_09.png" alt="Figure 5.9.png"/></figure>
    <p class="packt_figref">Figure 5.9: Benchmark results</p>
    <p class="normal">Overall, executing the <a id="_idIndexMarker556"/>computation using data-parallel capabilities gives the best performance, highest throughput, and best average time.</p>
    <h1 id="_idParaDest-235" class="heading-1">112. Applying the Vector API to compute FMA</h1>
    <p class="normal">In a nutshell, <strong class="keyWord">Fused Multiply Add</strong> (<strong class="keyWord">FMA</strong>) is the mathematical computation (a*b) + c, which is heavily <a id="_idIndexMarker557"/>exploited in matrix multiplications. That’s all we <a id="_idIndexMarker558"/>need to cover for this problem, but if you need a primer on FMA, consider <em class="italic">Java Coding Problems, First Edition</em>, <em class="italic">Chapter 1</em>,<em class="italic"> problem 38</em>.</p>
    <p class="normal">Implementing FMA via the Vector API can be done via the <code class="inlineCode">fma(float b, float c)</code> or <code class="inlineCode">fma(Vector&lt;Float&gt; b, Vector&lt;Float&gt; c)</code> operation, the latter is the one you’ll see in an example shortly. </p>
    <p class="normal">Let’s assume that we have the following two arrays:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">float</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-title">float</span>[]{<span class="hljs-number">1f</span>, <span class="hljs-number">2f</span>, <span class="hljs-number">3f</span>, <span class="hljs-number">5f</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">8f</span>};
<span class="hljs-type">float</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-title">float</span>[]{<span class="hljs-number">4f</span>, <span class="hljs-number">5f</span>, <span class="hljs-number">2f</span>, <span class="hljs-number">8f</span>, <span class="hljs-number">5f</span>, <span class="hljs-number">4f</span>};
</code></pre>
    <p class="normal">Computing FMA(<code class="inlineCode">x</code>, <code class="inlineCode">y</code>) can be expressed as the following sequence: 4+0=4 → 10+4=14 → 6+14=20 → 40+20=60 → 5+60=65 → 32+65=97. So, FMA(<code class="inlineCode">x</code>, <code class="inlineCode">y</code>) = 97. Expressing this sequence via the Vector API can be done as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Float&gt; VS 
  = FloatVector.SPECIES_PREFERRED;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title">vectorFma</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params">[] x, </span><span class="hljs-type">float</span><span class="hljs-params">[] y)</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS.loopBound(x.length);
  <span class="hljs-type">FloatVector</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> FloatVector.zero(VS);
  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (; i &lt; upperBound; i += VS.length()) {
    <span class="hljs-type">FloatVector</span> <span class="hljs-variable">xVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(VS, x, i);
    <span class="hljs-type">FloatVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(VS, y, i);
    sum = xVector.fma(yVector, sum); 
  }
  <span class="hljs-keyword">if</span> (i &lt;= (x.length - <span class="hljs-number">1</span>)) {
    VectorMask&lt;Float&gt; mask = VS.indexInRange(i, x.length);
    <span class="hljs-type">FloatVector</span> <span class="hljs-variable">xVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(
      VS, x, i, mask);
    <span class="hljs-type">FloatVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(
      VS, y, i, mask);
    sum = xVector.fma(yVector, sum);
  }
  <span class="hljs-type">float</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sum.reduceLanes(VectorOperators.ADD);
  <span class="hljs-keyword">return</span> result;
}
</code></pre>
    <p class="normal">Have you noticed the <a id="_idIndexMarker559"/>code line <code class="inlineCode">sum = xVector.fma(yVector, sum)</code>? This is equivalent to <code class="inlineCode">sum = xVector.mul(yVector).add(sum)</code>.</p>
    <p class="normal">The novelty here consists<a id="_idIndexMarker560"/> of the following line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">float</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sum.reduceLanes(VectorOperators.ADD);
</code></pre>
    <p class="normal">This is an associative <em class="italic">cross-lane</em> reduction operation (see <em class="italic">Figure 5.6</em>). Before this line, the sum vector looks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">sum= [<span class="hljs-number">9.0</span>, <span class="hljs-number">42.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">40.0</span>]
</code></pre>
    <p class="normal">By applying the <code class="inlineCode">reduceLanes(VectorOperators.ADD)</code>, we sum the values of this vector and reduce it to the final result, 97.0. Cool, right?!</p>
    <h1 id="_idParaDest-236" class="heading-1">113. Multiplying matrices via the Vector API</h1>
    <p class="normal">Let’s consider<a id="_idIndexMarker561"/> two matrices of 4x4 denoted as <code class="inlineCode">X</code> and <code class="inlineCode">Y</code>. <code class="inlineCode">Z=X*Y</code> is as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_10.png" alt="Figure 5.10.png"/></figure>
    <p class="packt_figref">Figure 5.10: Multiplying two matrices (X * Y = Z)</p>
    <p class="normal">Multiplying <code class="inlineCode">X</code> with <code class="inlineCode">Y</code> means <a id="_idIndexMarker562"/>multiplying the first row from <code class="inlineCode">X</code> with the first column from <code class="inlineCode">Y</code>, the second row from <code class="inlineCode">X</code> with the second column from <code class="inlineCode">Y</code>, and so on. For instance, (1 x 3) + (2 x 7) + (5 x 5) + (4 x 5) = 3 + 14 + 25 + 20 = 62. Basically, we repeatedly apply FMA computation and fill up <code class="inlineCode">Z</code> with the results.</p>
    <p class="normal">In this context, and based on the previous problem about computing FMA, we can produce the following code for multiplying <code class="inlineCode">X</code> with <code class="inlineCode">Y</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Float&gt; VS 
  = FloatVector.SPECIES_PREFERRED;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">float</span>[] mulMatrix(
<span class="hljs-type">    float</span>[] x, <span class="hljs-type">float</span>[] y, <span class="hljs-type">int</span> size) {
<span class="hljs-keyword">  final</span> <span class="hljs-type">int</span> <span class="hljs-variable">upperBound</span> <span class="hljs-operator">=</span> VS.loopBound(size);
<span class="hljs-type">  float</span>[] z = <span class="hljs-keyword">new</span> <span class="hljs-title">float</span>[size * size];
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; size; k++) {
      <span class="hljs-type">float</span> <span class="hljs-variable">elem</span> <span class="hljs-operator">=</span> x[i * size + k];
      <span class="hljs-type">FloatVector</span> <span class="hljs-variable">eVector</span> <span class="hljs-operator">=</span> FloatVector.broadcast(VS, elem);
      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; upperBound; j += VS.length()) {
<span class="hljs-type">        FloatVector</span> <span class="hljs-variable">yVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(
            VS, y, k * size + j);
<span class="hljs-type">        FloatVector</span> <span class="hljs-variable">zVector</span> <span class="hljs-operator">=</span> FloatVector.fromArray(
            VS, z, i * size + j);
        zVector = eVector.fma(yVector, zVector);
        zVector.intoArray(z, i * size + j);
      }
    }
  }
  <span class="hljs-keyword">return</span> z;
}
</code></pre>
    <p class="normal">In the bundled code, you<a id="_idIndexMarker563"/> can find this example next to another one<a id="_idIndexMarker564"/> using <code class="inlineCode">SPECIES_512</code>.</p>
    <h1 id="_idParaDest-237" class="heading-1">114. Hooking the image negative filter with the Vector API</h1>
    <p class="normal">An image is basically <a id="_idIndexMarker565"/>a matrix of pixels <a id="_idIndexMarker566"/>represented in the <strong class="keyWord">Alpha, Red, Green, Blue</strong> (<strong class="keyWord">ARGB</strong>) spectrum. For instance, an image of 232x290 can be represented as a matrix of 67,280 pixels. Applying <a id="_idIndexMarker567"/>specific filters (sepia, negative, grayscale, and so on) to an image typically requires processing each pixel from this matrix and performing certain calculations. For instance, the algorithm for applying the negative filter to an image can be used as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_11.png" alt="Figure 5.11.png"/></figure>
    <p class="packt_figref">Figure 5.11: Apply the negative filter effect to an image</p>
    <p class="normal">For each pixel, we extract the color components A, R, G, and B. We subtract the R, G, and B values from 255, and finally, we set the new value to the current pixel.</p>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker568"/> have an array (<code class="inlineCode">pixel[]</code>) containing all pixels of an image. Next, we want to pass <code class="inlineCode">pixel[]</code> as an argument to a method powered by the Vector API capable of applying the negative <a id="_idIndexMarker569"/>filter and setting the new values directly in <code class="inlineCode">pixel[]</code>.</p>
    <p class="normal">Here is a possible implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VectorSpecies&lt;Integer&gt; VS 
  = IntVector.SPECIES_PREFERRED;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">negativeFilter</span><span class="hljs-params">(</span>
<span class="hljs-params">   </span><span class="hljs-type">int</span><span class="hljs-params"> pixel[], </span><span class="hljs-type">int</span><span class="hljs-params"> width, </span><span class="hljs-type">int</span><span class="hljs-params"> height)</span> {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= (width * height - VS.length()); 
           i += VS.length()) {
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">alphaVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS, pixel, i)
      .lanewise(VectorOperators.LSHR, <span class="hljs-number">24</span>).and(<span class="hljs-number">0xff</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">redVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS, pixel, i)
      .lanewise(VectorOperators.LSHR, <span class="hljs-number">16</span>).and(<span class="hljs-number">0xff</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">greenVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS, pixel, i)
      .lanewise(VectorOperators.LSHR, <span class="hljs-number">8</span>).and(<span class="hljs-number">0xff</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">blueVector</span> <span class="hljs-operator">=</span> IntVector.fromArray(VS, pixel, i)
      .and(<span class="hljs-number">0xff</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">subAlphaVector</span>
      <span class="hljs-operator">=</span> alphaVector.lanewise(VectorOperators.LSHL, <span class="hljs-number">24</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">subRedVector</span> <span class="hljs-operator">=</span> redVector.broadcast(<span class="hljs-number">255</span>)
      .sub(redVector).lanewise(VectorOperators.LSHL, <span class="hljs-number">16</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">subGreenVector</span> <span class="hljs-operator">=</span> greenVector.broadcast(<span class="hljs-number">255</span>)
      .sub(greenVector).lanewise(VectorOperators.LSHL, <span class="hljs-number">8</span>);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">subBlueVector</span>
      <span class="hljs-operator">=</span> blueVector.broadcast(<span class="hljs-number">255</span>).sub(blueVector);
    <span class="hljs-type">IntVector</span> <span class="hljs-variable">resultVector</span> <span class="hljs-operator">=</span> subAlphaVector.or(subRedVector)
      .or(subGreenVector).or(subBlueVector);
    resultVector.intoArray(pixel, i);
  } 
}
</code></pre>
    <p class="normal">In the first part, we extract A, R, G, and B into four vectors (<code class="inlineCode">alphaVector</code>, <code class="inlineCode">redVector</code>, <code class="inlineCode">greenVector</code>, and <code class="inlineCode">blueVector</code>) by applying the <code class="inlineCode">LSHR</code> <em class="italic">lanewise</em> operation. Afterward, we subtract R, G, and B from 255 and compute the new R, G, and B by applying the <code class="inlineCode">LSHL</code> <em class="italic">lanewise</em> operation. Next, we <a id="_idIndexMarker570"/>compute the new color by applying the bitwise logical disjunction (<code class="inlineCode">|</code>) between<a id="_idIndexMarker571"/> the new A, R, G, and B values. Finally, we set the new color in the <code class="inlineCode">pixel[]</code> array.</p>
    <h1 id="_idParaDest-238" class="heading-1">115. Dissecting factory methods for collections</h1>
    <p class="normal">Using factory methods for<a id="_idIndexMarker572"/> collections is a must-have skill. It is very convenient to be able to quickly and effortlessly create and populate unmodifiable/immutable collections before putting them to work.</p>
    <h2 id="_idParaDest-239" class="heading-2">Factory methods for maps</h2>
    <p class="normal">For instance, before<a id="_idIndexMarker573"/> JDK 9, creating an unmodifiable map could be <a id="_idIndexMarker574"/>accomplished like this:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>);
map.put(<span class="hljs-number">2</span>, <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>);
map.put(<span class="hljs-number">3</span>, <span class="hljs-string">"jOOQ Masterclass"</span>);
Map&lt;Integer, String&gt; imap = Collections.unmodifiableMap(map);
</code></pre>
    <p class="normal">This is useful if, at some point in time, you need an unmodifiable map from a modifiable one. Otherwise, you can take a shortcut as<a id="_idIndexMarker575"/> follows (this is known as the <em class="italic">double-brace initialization</em> technique and, generally, an anti-pattern):</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; imap = Collections.unmodifiableMap(
<span class="hljs-keyword">  new</span> <span class="hljs-title">HashMap</span>&lt;Integer, String&gt;() {
    {
      put(<span class="hljs-number">1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>);
      put(<span class="hljs-number">2</span>, <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>);
      put(<span class="hljs-number">3</span>, <span class="hljs-string">"jOOQ Masterclass"</span>);
    }
  });
</code></pre>
    <p class="normal">If you need to return an unmodifiable/immutable map from a <code class="inlineCode">Stream</code> of <code class="inlineCode">java.util.Map.entry</code> then here you go:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; imap = Stream.of(
  entry(<span class="hljs-number">1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>),
  entry(<span class="hljs-number">2</span>, <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>),
  entry(<span class="hljs-number">3</span>, <span class="hljs-string">"jOOQ Masterclass"</span>))
  .collect(collectingAndThen(
   toMap(e -&gt; e.getKey(), e -&gt; e.getValue()), 
   Collections::unmodifiableMap));
</code></pre>
    <p class="normal">Moreover, let’s not<a id="_idIndexMarker576"/> forget the empty and singleton maps (quite useful to<a id="_idIndexMarker577"/> return a map from a method instead of <code class="inlineCode">null</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; imap = Collections.emptyMap();
Map&lt;Integer, String&gt; imap = Collections.singletonMap(
<span class="hljs-number">  1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>);
</code></pre>
    <p class="normal">Starting with JDK 9, we can rely on a more convenient approach for creating unmodifiable/immutable maps thanks to JEP 269: <em class="italic">Convenience Factory Methods for Collections</em>. This approach consists of <code class="inlineCode">Map.of()</code>, which is available from 0 to 10 mappings or, in other words, is overloaded to support 0 to 10 key-value pairs. Here, we use <code class="inlineCode">Map.of()</code> for three mappings:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; imap = Map.of(
  <span class="hljs-number">1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>,
  <span class="hljs-number">2</span>, <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>,
  <span class="hljs-number">3</span>, <span class="hljs-string">"jOOQ Masterclass"</span>
);
</code></pre>
    <p class="normal">Maps created via <code class="inlineCode">Map.of()</code> don’t allow <code class="inlineCode">null</code> keys or values. Such attempts will end up in a <code class="inlineCode">NullPointerException</code>.</p>
    <p class="normal">If you need more than 10 mappings then you can rely on <code class="inlineCode">static &lt;K,V&gt; Map&lt;K,V&gt; ofEntries(Entry&lt;? Extends K,? extends V&gt;... entries)</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.util.Map.entry;
...
Map&lt;Integer, String&gt; imap2jdk9 = Map.ofEntries(
  entry(<span class="hljs-number">1</span>, <span class="hljs-string">"Java Coding Problems, First Edition"</span>),
  entry(<span class="hljs-number">2</span>, <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>),
  entry(<span class="hljs-number">3</span>, <span class="hljs-string">"jOOQ Masterclass"</span>)
);
</code></pre>
    <p class="normal">Finally, creating an unmodifiable/immutable map from an existing one can be done via <code class="inlineCode">static &lt;K,V&gt; Map&lt;K,V&gt; copyOf(Map&lt;? extends K,? extends V&gt; map)</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; imap = Map.copyOf(map);
</code></pre>
    <p class="normal">If the given map is unmodifiable then Java will most probably not create a copy and will return an existing instance. In other <a id="_idIndexMarker578"/>words, <code class="inlineCode">imap == map</code> will return <code class="inlineCode">true</code>. If the given map is modifiable then<a id="_idIndexMarker579"/> most probably the factory will return a new instance, so <code class="inlineCode">imap == map</code> will return <code class="inlineCode">false</code>.</p>
    <h2 id="_idParaDest-240" class="heading-2">Factory methods for lists</h2>
    <p class="normal">Before JDK 9, a modifiable <code class="inlineCode">List</code> could be <a id="_idIndexMarker580"/>used for creating an<a id="_idIndexMarker581"/> unmodifiable <code class="inlineCode">List</code> with the same content as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
list.add(<span class="hljs-string">"Java Coding Problems, First Edition"</span>);
list.add(<span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>);
list.add(<span class="hljs-string">"jOOQ Masterclass"</span>);
List&lt;String&gt; ilist = Collections.unmodifiableList(list);
</code></pre>
    <p class="normal">A common approach for creating a <code class="inlineCode">List</code> consists of using <code class="inlineCode">Arrays.asList()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; ilist = Arrays.asList(
  <span class="hljs-string">"Java Coding Problems, First Edition"</span>,
  <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>,
  <span class="hljs-string">"</span><span class="hljs-string">jOOQ Masterclass"</span>
);
</code></pre>
    <p class="normal">However, keep in mind that this is a fixed-size list, not an unmodifiable/immutable list. In other words, operations that attempt to modify the list size (for instance, <code class="inlineCode">ilist.add(…)</code>) will result in <code class="inlineCode">UnsupportedOperationException</code>, while operations that modify the current content of the list (for instance, <code class="inlineCode">ilist.set(…)</code>) are allowed.</p>
    <p class="normal">If you need to return an unmodifiable/immutable <code class="inlineCode">List</code> from a <code class="inlineCode">Stream</code> then here you go:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; ilist = Stream.of(
  <span class="hljs-string">"Java Coding Problems, First Edition"</span>,
  <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>,
  <span class="hljs-string">"jOOQ Masterclass"</span>)
  .collect(collectingAndThen(toList(), 
           Collections::unmodifiableList));
</code></pre>
    <p class="normal">Moreover, creating an empty/singleton list can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; ilist = Collections.emptyList();
List&lt;String&gt; ilist = Collections.singletonList(
  <span class="hljs-string">"Java Coding Problems, First Edition"</span>);
</code></pre>
    <p class="normal">Starting with JDK 9+, it is more<a id="_idIndexMarker582"/> convenient to rely on the <code class="inlineCode">List.of()</code> factory methods available for 0 to<a id="_idIndexMarker583"/> 10 elements (<code class="inlineCode">null</code> elements are not allowed):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; ilist = List.of(
  <span class="hljs-string">"Java Coding Problems, First Edition"</span>,
  <span class="hljs-string">"The Complete Coding Interview Guide in Java"</span>,
  <span class="hljs-string">"jOOQ Masterclass"</span>);
</code></pre>
    <p class="normal">If you need a copy of an existing list then rely on <code class="inlineCode">List.copyOf()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; ilist = List.copyOf(list);
</code></pre>
    <p class="normal">If the given list is unmodifiable then Java will most probably not create a copy and will return an existing instance. In other words, <code class="inlineCode">ilist == list</code> will return <code class="inlineCode">true</code>. If the given list is modifiable then the factory will most likely return a new instance, so <code class="inlineCode">ilist == list</code> will return <code class="inlineCode">false</code>.</p>
    <h2 id="_idParaDest-241" class="heading-2">Factory methods for sets</h2>
    <p class="normal">Creating <code class="inlineCode">Set</code> instances follows <a id="_idIndexMarker584"/>the same path as <code class="inlineCode">List</code> instances. However, note that there is no <code class="inlineCode">singletonSet()</code>. To create a singleton set, simply<a id="_idIndexMarker585"/> call <code class="inlineCode">singleton()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Set&lt;String&gt; iset = Collections.singleton(
  <span class="hljs-string">"</span><span class="hljs-string">Java Coding Problems, First Edition"</span>);
</code></pre>
    <p class="normal">You can find more examples in the bundled code. You may also be interested in <em class="italic">Problem 109</em> from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, which covers unmodifiable versus immutable collections. Moreover, please consider the next problem presented here as well, since it provides more info on this context.</p>
    <h1 id="_idParaDest-242" class="heading-1">116. Getting a list from a stream</h1>
    <p class="normal">Collecting a <code class="inlineCode">Stream</code> into a <code class="inlineCode">List</code> is a<a id="_idIndexMarker586"/> popular task that occurs all over the place in applications that <a id="_idIndexMarker587"/>manipulate streams and collections. </p>
    <p class="normal">In JDK 8, collecting a <code class="inlineCode">Stream</code> into a <code class="inlineCode">List</code> can be done via the <code class="inlineCode">toList()</code> collector as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;File&gt; roots = Stream.of(File.listRoots())
  .collect(Collectors.toList());
</code></pre>
    <p class="normal">Starting with JDK 10, we can rely on the <code class="inlineCode">toUnmodifiableList()</code> collector (for maps, use <code class="inlineCode">toUnmodifiableMap()</code>, and for sets, <code class="inlineCode">toUnmodifiableSet()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;File&gt; roots = Stream.of(File.listRoots())
  .collect(Collectors.toUnmodifiableList());
</code></pre>
    <p class="normal">Obviously, the returned list is an<a id="_idIndexMarker588"/> unmodifiable/immutable list.</p>
    <p class="normal">JDK 16 has introduced the<a id="_idIndexMarker589"/> following <code class="inlineCode">toList()</code> default method in the <code class="inlineCode">Stream</code> interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">default</span> List&lt;T&gt; toList() {
  <span class="hljs-keyword">return</span> (List&lt;T&gt;) Collections.unmodifiableList(
    <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-built_in">this</span>.toArray())));
}
</code></pre>
    <p class="normal">Using this method to collect a <code class="inlineCode">Stream</code> into an unmodifiable/immutable list is straightforward (pay attention that this is not like <code class="inlineCode">Collectors.toList()</code>, which returns a modifiable list):</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;File&gt; roots = Stream.of(File.listRoots()).toList();
</code></pre>
    <p class="normal">In the bundled code, you can also find an example of combining <code class="inlineCode">flatMap()</code> and <code class="inlineCode">toList()</code>.</p>
    <h1 id="_idParaDest-243" class="heading-1">117. Handling map capacity</h1>
    <p class="normal">Let’s assume that <a id="_idIndexMarker590"/>we need a <code class="inlineCode">List</code> capable of holding 260 items. We can do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(<span class="hljs-number">260</span>);
</code></pre>
    <p class="normal">The array underlying <code class="inlineCode">ArrayList</code> is created directly to accommodate 260 items. In other words, we can insert 260 items without worrying about resizing or enlarging the list several times in order to hold these 260 items.</p>
    <p class="normal">Following this logic, we can reproduce it for a map as well:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;(<span class="hljs-number">260</span>);
</code></pre>
    <p class="normal">So, now we can assume that we have a map capable of accommodating 260 mappings. Actually, no, this assumption is not true! A <code class="inlineCode">HashMap</code> works on the <em class="italic">hashing</em> principle and is initialized with an initial capacity (16 if no explicit initial capacity is provided) representing the number of internal buckets and a default <em class="italic">load factor</em> of 0.75. What does that mean? It means that when a <code class="inlineCode">HashMap</code> reaches 75% of its current capacity, it is doubled in size and a rehashing takes place. This guarantees that the mappings are evenly distributed in the <a id="_idIndexMarker591"/>internal buckets. But, for significantly large maps, this is an expensive operation. Javadoc states that “<em class="italic">creating a HashMap with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table</em>.”</p>
    <p class="normal">In our case, it means that a map can hold 260 x 0.75 = 195 mappings. In other words, when we insert the 195<sup class="superscript">th</sup> mapping, the map will be automatically resized to 260 * 2 = 520 mappings.</p>
    <p class="normal">To create a <code class="inlineCode">HashMap</code> for 260 mappings, we have to calculate the initial capacity as the number of mappings/load factor: 260 / 0.75 = 347 mappings:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// accommodate 260 mappings without resizing</span>
Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;(<span class="hljs-number">347</span>);
</code></pre>
    <p class="normal">Or, if we want to express it as a formula, we can do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;(
  (<span class="hljs-type">int</span>) Math.ceil(<span class="hljs-number">260</span> / (<span class="hljs-type">double</span>) <span class="hljs-number">0.75</span>));
</code></pre>
    <p class="normal">Starting with JDK 19, this formula has been hidden behind the <code class="inlineCode">static &lt;K,V&gt; HashMap&lt;K,V&gt; newHashMap(int numMappings)</code> method. This time, <code class="inlineCode">numMappings</code> represents the number of mappings, so we can write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// accommodate 260 mappings without resizing</span>
Map&lt;Integer, String&gt; map = HashMap.newHashMap(<span class="hljs-number">260</span>);
</code></pre>
    <p class="normal">Analog methods exist for <code class="inlineCode">HashSet</code>, <code class="inlineCode">LinkedHashSet</code>, <code class="inlineCode">LinkedHashMap</code>, and <code class="inlineCode">WeakHashMap</code>.</p>
    <h1 id="_idParaDest-244" class="heading-1">118. Tackling Sequenced Collections</h1>
    <p class="normal">The Sequenced Collections API was added as a final feature in JDK 21 under JEP 431. Its main goal is to make the navigation of<a id="_idIndexMarker592"/> Java collections easier by providing a common API to all collections having a well-defined encounter order.</p>
    <p class="normal">A Java collection with a well-defined encounter order has a well-defined first element, second element, and so on, until the last element. The encounter order is the order in which an <code class="inlineCode">Iterator</code> will iterate the elements of a collection (list, set, sorted set, map, and so on). The encounter order can take advantage of stability over time (lists) or not (sets).</p>
    <p class="normal">This API consists of 3 interfaces named <code class="inlineCode">SequencedCollection</code> (valid for any collection that has a well-defined encounter order), <code class="inlineCode">SequencedSet</code> (extends <code class="inlineCode">SequencedCollection</code> and <code class="inlineCode">Set</code> to provide support for Java sets), and <code class="inlineCode">SequencedMap</code> (extends <code class="inlineCode">Map</code> to give support to any Java map that has a well-defined encounter order). In the following diagram, you can see the locations of these 3 interfaces in the collections type hierarchy:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_12.png" alt="aFigure1.png"/></figure>
    <p class="packt_figref">Figure 5.12: The location of the Sequenced Collections API in the collections type hierarchy</p>
    <p class="normal">The <code class="inlineCode">SequencedCollection</code> API targets four main operations on a collection: getting the first/last element, adding a new element in the first/last position, removing the first/last element, and reversing a collection.</p>
    <p class="normal">The <code class="inlineCode">SequencedCollection</code> API defines 7 methods, as follows:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">getFirst()</code> gets the first element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">getLast()</code> gets the last element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">addFirst(E e)</code> adds the given element <code class="inlineCode">e</code> as the first element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">addLast(E e)</code> adds the given element <code class="inlineCode">e</code> as the last element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">removeFirst()</code> removes the first element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">removeLast()</code> removes the last element of the current collection</li>
      <li class="bulletList"><code class="inlineCode">reversed()</code> returns the reverse collection of the current collection</li>
    </ul>
    <p class="normal"><code class="inlineCode">SequencedSet</code> extends <code class="inlineCode">SequencedCollection</code> and overrides the <code class="inlineCode">reversed()</code> method to return <code class="inlineCode">SequencedSet</code>.</p>
    <p class="normal"><code class="inlineCode">SequencedMap</code> defines the following<a id="_idIndexMarker593"/> methods:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">firstEntry()</code> returns the first entry (first key-value mapping) from the current map</li>
      <li class="bulletList"><code class="inlineCode">lastEntry()</code> returns the last entry (last key-value mapping) from the current map</li>
      <li class="bulletList"><code class="inlineCode">putFirst(K k, V v)</code> attempts to insert (or replace) the given key-value mapping as the first mapping in the current map</li>
      <li class="bulletList"><code class="inlineCode">putLast(K k, V v)</code> attempts to insert (or replace) the given key-value mapping as the last mapping in the current map</li>
      <li class="bulletList"><code class="inlineCode">pollFirstEntry()</code> removes and returns the first entry (first key-value mapping) from the current map (if no entry is present then it returns <code class="inlineCode">null</code>)</li>
      <li class="bulletList"><code class="inlineCode">pollLastEntry()</code> removes and returns the last entry (last key-value mapping) from the current map (if no entry is present then it returns <code class="inlineCode">null</code>)</li>
      <li class="bulletList"><code class="inlineCode">reversed()</code> returns the reverse map of the current map</li>
      <li class="bulletList"><code class="inlineCode">sequencedEntrySet()</code> returns a <code class="inlineCode">SequencedSet</code> view of the entry set (<code class="inlineCode">entrySet()</code>) of the current map</li>
      <li class="bulletList"><code class="inlineCode">sequencedKeySet()</code> returns a <code class="inlineCode">SequencedSet</code> view of the key set (<code class="inlineCode">keyset()</code>) of the current map</li>
      <li class="bulletList"><code class="inlineCode">sequencedValues()</code> returns a <code class="inlineCode">SequencedCollection</code> view of the values (<code class="inlineCode">values()</code>) of the current map</li>
    </ul>
    <p class="normal">The well-defined encounter order is a property spread across the collections type hierarchy, so we have to consider that the Sequenced Collections API works completely with some collections, partially with others, and not at all with yet others. Let’s tackle a few common collections and<a id="_idIndexMarker594"/> try out this new API.</p>
    <h2 id="_idParaDest-245" class="heading-2">Applying the Sequenced Collections API to lists</h2>
    <p class="normal">Java lists (implementations of <code class="inlineCode">List</code>) rely on<a id="_idIndexMarker595"/> indexes to support a well-defined (stable) encounter order, so they are a perfect candidate for the Sequenced Collections API.</p>
    <p class="normal">Next, let’s see how we can <a id="_idIndexMarker596"/>exploit the Sequenced Collections API for two of the most popular implementations of <code class="inlineCode">List</code>. Obviously, we are talking about <code class="inlineCode">ArrayList</code> and <code class="inlineCode">LinkedList</code>. <code class="inlineCode">ArrayList</code> and <code class="inlineCode">LinkedList</code> implement <code class="inlineCode">SequencedCollection</code>.</p>
    <h3 id="_idParaDest-246" class="heading-3">Applying the Sequenced Collections API to ArrayList and LinkedList</h3>
    <p class="normal">Let’s assume that we have the <a id="_idIndexMarker597"/>following <code class="inlineCode">ArrayList</code> and <code class="inlineCode">LinkedList</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(
  Arrays.asList(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>));
List&lt;String&gt; linkedlist = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>&lt;&gt;(
  Arrays.asList(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>));
</code></pre>
    <p class="normal">Getting the first element from <code class="inlineCode">ArrayList</code> is quite simple. The first element is at index 0, so calling <code class="inlineCode">get(0)</code> is all we need to do:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// one</span>
</code></pre>
    <p class="normal">Getting the last element is a little trickier. We don’t know the index of the last element but we know the size of the list, so we can write this (it is not neat, but it works):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> list.get(list.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// five</span>
</code></pre>
    <p class="normal">On the other hand, if we rely on the JDK 21 Sequenced Collections API then we can get the first and last elements as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> list.getFirst(); <span class="hljs-comment">// one</span>
<span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> list.getLast();  <span class="hljs-comment">// five</span>
</code></pre>
    <p class="normal">That’s really neat and applies to the <code class="inlineCode">LinkedList</code> as well! We don’t involve any explicit indexes.</p>
    <p class="normal">Adding an element in the first position means adding an element at index 0 via the well-known <code class="inlineCode">add(index, element)</code>. Moreover, adding an element in the last position means calling the <code class="inlineCode">add(element)</code> method without an explicit index as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list.add(<span class="hljs-number">0</span>, <span class="hljs-string">"zero"</span>); <span class="hljs-comment">// add on the first position</span>
list.add(<span class="hljs-string">"six"</span>);     <span class="hljs-comment">// add on the last position</span>
</code></pre>
    <p class="normal">Adding the same elements <a id="_idIndexMarker598"/>via the Sequenced Collections API can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list.addFirst(<span class="hljs-string">"zero"</span>);
list.addLast(<span class="hljs-string">"</span><span class="hljs-string">six"</span>);
</code></pre>
    <p class="normal">Removing the first/last element can be done via the <code class="inlineCode">remove()</code> method and the proper indexes as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list.remove(<span class="hljs-number">0</span>);                <span class="hljs-comment">// remove the first element</span>
list.remove(list.size() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// remove the last element</span>
</code></pre>
    <p class="normal">If we know the value of the last element then we can remove it without an explicit index as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list.remove(<span class="hljs-string">"five"</span>);
</code></pre>
    <p class="normal">Removing the same elements via the Sequenced Collections API can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">list.removeFirst();
list.removeLast();
</code></pre>
    <p class="normal">So, using the Sequenced Collections API is straightforward. No arguments are involved. And, this works for <code class="inlineCode">LinkedList</code> as well.</p>
    <p class="normal">Reversing the list can be done via the <code class="inlineCode">Collections.reverse()</code> helper. This method reverses the given list:</p>
    <pre class="programlisting code"><code class="hljs-code">Collections.reverse(list);
</code></pre>
    <p class="normal">On the other hand, the Sequenced Collections API returns a new list representing the reverse of the given list as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;String&gt; reversedList = list.reversed();
</code></pre>
    <p class="normal">Again, the same code <a id="_idIndexMarker599"/>works for <code class="inlineCode">LinkedList</code> as well. So, the Sequenced Collections API works perfectly for lists.</p>
    <h2 id="_idParaDest-247" class="heading-2">Applying the Sequenced Collections API to sets</h2>
    <p class="normal">Java sets (implementations of <code class="inlineCode">Set</code>) can be split into two categories. We have sorted sets (implementations of <code class="inlineCode">SortedSet</code>) that <a id="_idIndexMarker600"/>support a well-defined (stable) encounter order and sets that make no guarantees as to the iteration order (<code class="inlineCode">HashSet</code>).</p>
    <p class="normal">A <code class="inlineCode">SortedSet</code> has an order dictated by <a id="_idIndexMarker601"/>the logic of a comparator (<em class="italic">natural ordering</em> or <code class="inlineCode">Comparator</code>). When we insert a new element in a sorted set, the comparator logic decides where this element will land, so we don’t know the index value of an element. However, a sorted set has the notion of first and last elements and an <code class="inlineCode">Iterator</code> will iterate the elements in the order settled by the comparator.</p>
    <p class="normal">On the other hand, a set such as <code class="inlineCode">HashSet</code> has no guarantees as to the iteration order. The elements of a <code class="inlineCode">HashSet</code> are ordered by its internal hashing algorithms. An <code class="inlineCode">Iterator</code> over a <code class="inlineCode">HashSet</code> iterates its elements in no particular order and, when we insert a new element, we have no idea where this element will land in the <code class="inlineCode">HashSet</code>.</p>
    <p class="normal">Next, let’s see how we can exploit the Sequenced Collections API for three of the most popular sets. We choose <code class="inlineCode">HashSet</code> (an implementation of <code class="inlineCode">Set</code>), <code class="inlineCode">LinkedHashSet</code> (an extension of <code class="inlineCode">HashSet</code>), and <code class="inlineCode">TreeSet</code> (an implementation of <code class="inlineCode">NavigableSet</code> that extends <code class="inlineCode">SortedSet</code>).</p>
    <h3 id="_idParaDest-248" class="heading-3">Applying the Sequenced Collections API to HashSet</h3>
    <p class="normal">A <code class="inlineCode">HashSet</code> iterates its elements in no particular order, which means that a <code class="inlineCode">HashSet</code> has no idea (stability) of the first, second, or<a id="_idIndexMarker602"/> last elements. Iterating the same <code class="inlineCode">HashSet</code> multiple times may result in different outputs. In this context, we can add an element to a set via the <code class="inlineCode">add(E e)</code> method. The element will be added only if it doesn’t exist already and will land in a position computed by the <code class="inlineCode">HashSet</code> internal hashing algorithms. Moreover, we can remove an element by its value via <code class="inlineCode">remove(Object o)</code>. Since the order of elements is not stable, it doesn’t make sense to reverse <code class="inlineCode">HashSet</code>. In this context, the Sequenced Collections API doesn’t work at all, so <code class="inlineCode">HashSet</code> doesn’t take advantage of this API.</p>
    <h3 id="_idParaDest-249" class="heading-3">Applying the Sequenced Collections API to LinkedHashSet</h3>
    <p class="normal">A <code class="inlineCode">LinkedHashSet</code> is a <code class="inlineCode">HashSet</code> that relies on<a id="_idIndexMarker603"/> a doubly-linked list to maintain a well-defined encounter order. A <code class="inlineCode">LinkedHashSet</code> implements <code class="inlineCode">SequencedSet</code>, so it can take advantage of the Sequenced Collections API. Let’s deep dive into the following <code class="inlineCode">LinkedHashSet</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedSet&lt;String&gt; linkedhashset = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedHashSet</span>&lt;&gt;(
  Arrays.asList(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>));
</code></pre>
    <p class="normal">The <code class="inlineCode">LinkedHashSet</code> doesn’t expose an API for getting the first/last elements. However, we can rely on the well-defined encounter order and on the <code class="inlineCode">Iterator</code> (or <code class="inlineCode">Stream</code>) API to get the first element as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.iterator().next();
linkedhashset.stream().findFirst().get();
</code></pre>
    <p class="normal">This is not neat, and for the last element it is even worse:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.stream().skip(
  linkedhashset.size() - <span class="hljs-number">1</span>).findFirst().get();
<span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> (String) linkedhashset.toArray()
  [linkedhashset.size() - <span class="hljs-number">1</span>];
</code></pre>
    <p class="normal">Fortunately, JDK 21 simplifies this task via the <code class="inlineCode">getFirst()</code> and <code class="inlineCode">getLast()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.getFirst();
linkedhashset.getLast();
</code></pre>
    <p class="normal">Adding an element into <code class="inlineCode">LinkedHashSet</code> is possible only if that element doesn’t exist. This is normal since sets don’t accept doubles as lists. However, adding on the first position is not an easy task (we can do it if we transform <code class="inlineCode">LinkedHashSet</code> into another collection, add the element on the first position, and convert back to <code class="inlineCode">LinkedHashSet</code>) so we skipped that here. Adding an element to the last position is easy via the <code class="inlineCode">add()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// cannot add on first position</span>
linkedhashset.add(<span class="hljs-string">"six"</span>); <span class="hljs-comment">//  add on last position</span>
</code></pre>
    <p class="normal">But if we rely on the Sequenced Collections API, then we can add on the first/last position via <code class="inlineCode">addFirst()</code>/<code class="inlineCode">addLast()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.addFirst(<span class="hljs-string">"zero"</span>);
linkedhashset.addLast(<span class="hljs-string">"six"</span>);
</code></pre>
    <p class="normal">Removing the first/last<a id="_idIndexMarker604"/> element is possible only if we know the values of those elements:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.remove(<span class="hljs-string">"one"</span>);
linkedhashset.remove(<span class="hljs-string">"five"</span>);
</code></pre>
    <p class="normal">Obviously, this approach is not robust and safe and you’ll prefer to get the first/last elements as you saw earlier via <code class="inlineCode">Iterator</code>/<code class="inlineCode">Stream</code>, and call <code class="inlineCode">remove()</code> on those elements afterward. However, the more appropriate option is to rely on the Sequenced Collections API:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashset.removeFirst();
linkedhashset.removeLast();
</code></pre>
    <p class="normal">There is no other straightforward solution to reverse <code class="inlineCode">LinkedHashSet</code> than using the Sequenced Collections API:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedSet&lt;String&gt; reversedLhs = linkedhashset.reversed();
</code></pre>
    <p class="normal">So, as you can see, the Sequenced Collections API really simplifies the usage of <code class="inlineCode">LinkedHashSet</code>. Cool!</p>
    <h3 id="_idParaDest-250" class="heading-3">Applying the Sequenced Collections API to TreeSet</h3>
    <p class="normal">A <code class="inlineCode">TreeSet</code> is a sorted set that implements <code class="inlineCode">NavigableSet</code> (an extension of <code class="inlineCode">SortedSet</code>) so it takes advantage of all methods <a id="_idIndexMarker605"/>of a sorted set plus some navigation methods. It also implements <code class="inlineCode">SequencedCollection</code> and <code class="inlineCode">SequencedSet</code>.</p>
    <p class="normal">Let’s consider the following <code class="inlineCode">TreeSet</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SortedSet&lt;String&gt; sortedset = <span class="hljs-keyword">new</span> <span class="hljs-title">TreeSet</span>&lt;&gt;(
  Arrays.asList(<span class="hljs-string">"one"</span>, <span class="hljs-string">"two"</span>, <span class="hljs-string">"three"</span>, <span class="hljs-string">"four"</span>, <span class="hljs-string">"five"</span>));
</code></pre>
    <p class="normal">Relying on the default comparator for strings (that is, natural ordering, which compares two strings lexicographically), the sorted set will be <em class="italic">five</em>, <em class="italic">four</em>, <em class="italic">one</em>, <em class="italic">three</em>, <em class="italic">two</em>. So, the first element is <em class="italic">five</em>, and the last element is <em class="italic">two</em>. Getting the first/last element of a sorted set can be done via the <code class="inlineCode">first()</code> and <code class="inlineCode">last()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedset.first();
sortedset.last();
</code></pre>
    <p class="normal">So, the Sequenced Collections API doesn’t bring significant value in this case:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedset.getFirst();
sortedset.getLast();
</code></pre>
    <p class="normal">Adding a new element to the first/last position in a sorted set is not possible. Since the order of elements is dictated by a comparator (natural ordering or an explicit <code class="inlineCode">Comparator</code>), we cannot guarantee that an added element will land in the first or last position. For instance, the<a id="_idIndexMarker606"/> following code will not add the elements as we may expect (zero as the first element, and six as the last element):</p>
    <pre class="programlisting code"><code class="hljs-code">sortedset.add(<span class="hljs-string">"zero"</span>);
sortedset.add(<span class="hljs-string">"six"</span>);
</code></pre>
    <p class="normal">After applying the lexicographical criteria, the resulting sorted set will be <em class="italic">five</em>, <em class="italic">four</em>, <em class="italic">one</em>, <em class="italic">six</em>, <em class="italic">three</em>, <em class="italic">two</em>, <em class="italic">zero</em>. So, <em class="italic">zero</em> is actually the last element and <em class="italic">six</em> is the fourth element.</p>
    <p class="normal">Trying to apply the Sequenced Collections API (<code class="inlineCode">addFirst()</code>/<code class="inlineCode">addLast()</code>) will throw an <code class="inlineCode">UnsupportedOperationException</code> exception.</p>
    <p class="normal">How about removing the first/last elements from a sorted set? Since we can get the first/last elements of a tree set, we can also remove them as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> sortedset.first();
sortedset.remove(first);
<span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> sortedset.last();
sortedset.remove(last);
</code></pre>
    <p class="normal">The Sequenced Collections API implementation represents a shortcut of the previous code:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedset.removeFirst();
sortedset.removeLast();
</code></pre>
    <p class="normal">Reversing a sorted set can be done via <code class="inlineCode">descendingSet()</code> or <code class="inlineCode">descendingIterator()</code>. Both of them are available in <code class="inlineCode">TreeSet</code>, so here is the usage of <code class="inlineCode">descendingSet()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SortedSet&lt;String&gt; reversedSortedSet
  = <span class="hljs-keyword">new</span> <span class="hljs-title">TreeSet</span>&lt;&gt;(sortedset).descendingSet();
</code></pre>
    <p class="normal">It is much neater to rely on the Sequenced Collections API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">SortedSet&lt;String&gt; reversedSortedSet = sortedset.reversed();
</code></pre>
    <p class="normal">Cool, right?!</p>
    <h2 id="_idParaDest-251" class="heading-2">Applying the Sequenced Collections API to maps</h2>
    <p class="normal">Java maps (implementations of <code class="inlineCode">Map</code>) may<a id="_idIndexMarker607"/> have a well-defined encounter order (for instance, <code class="inlineCode">LinkedHashMap</code> (implementation of <code class="inlineCode">Map</code> and <code class="inlineCode">SequencedMap</code>), <code class="inlineCode">TreeMap</code> (implementation of <code class="inlineCode">SortedMap</code> and <code class="inlineCode">SequencedMap</code>)) or an unstable order over<a id="_idIndexMarker608"/> time (for instance, <code class="inlineCode">HashMap</code> implementation of <code class="inlineCode">Map</code>). Exactly as in the case of <code class="inlineCode">HashSet</code>, <code class="inlineCode">HashMap</code> cannot take advantage of the Sequenced Collections API.</p>
    <h3 id="_idParaDest-252" class="heading-3">Applying the Sequenced Collections API to LinkedHashMap</h3>
    <p class="normal"><code class="inlineCode">LinkedHashMap</code> is a map with a well-defined<a id="_idIndexMarker609"/> encounter order. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedMap&lt;Integer, String&gt; linkedhashmap
  = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedHashMap</span>&lt;&gt;();
linkedhashmap.put(<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>);
linkedhashmap.put(<span class="hljs-number">2</span>, <span class="hljs-string">"two"</span>);
linkedhashmap.put(<span class="hljs-number">3</span>, <span class="hljs-string">"three"</span>);
linkedhashmap.put(<span class="hljs-number">4</span>, <span class="hljs-string">"four"</span>);
linkedhashmap.put(<span class="hljs-number">5</span>, <span class="hljs-string">"five"</span>);
</code></pre>
    <p class="normal">Getting the first entry (<code class="inlineCode">Map.Entry</code>) from a linked hash map can be done via the <code class="inlineCode">Iterator</code>/<code class="inlineCode">Stream</code> API as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashmap.entrySet().iterator().next();
linkedhashmap.entrySet().stream().findFirst().get();
</code></pre>
    <p class="normal">The same logic can be applied to get the first key (via <code class="inlineCode">keyset()</code>) or the first value (via <code class="inlineCode">values()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashmap.keySet().iterator().next();
linkedhashmap.keySet().stream().findFirst().get();
linkedhashmap.values().iterator().next();
linkedhashmap.values().stream().findFirst().get();
</code></pre>
    <p class="normal">Getting the last entry/key/value requires code that is even uglier than the previous code:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashmap.entrySet().stream()
  .skip(linkedhashmap.size() - <span class="hljs-number">1</span>).findFirst().get();
Entry&lt;Integer, String&gt; lastEntryLhm = (Entry&lt;Integer, String&gt;)
  linkedhashmap.entrySet().toArray()[linkedhashmap.size() - <span class="hljs-number">1</span>];
linkedhashmap.keySet().stream()
  .skip(linkedhashmap.size() - <span class="hljs-number">1</span>).findFirst().get();
<span class="hljs-type">Integer</span> <span class="hljs-variable">lastKeyLhm</span> <span class="hljs-operator">=</span> (Integer) linkedhashmap.keySet()
  .toArray()[linkedhashmap.size() - <span class="hljs-number">1</span>];
linkedhashmap.values().stream()
  .skip(linkedhashmap.size() - <span class="hljs-number">1</span>).findFirst().get();
<span class="hljs-type">String</span> <span class="hljs-variable">lastValueLhm</span> <span class="hljs-operator">=</span> (String) linkedhashmap.values()
  .toArray()[linkedhashmap.size() - <span class="hljs-number">1</span>];
</code></pre>
    <p class="normal">In this case, the Sequenced<a id="_idIndexMarker610"/> Collections API is really useful for avoiding such painful and cumbersome code. For instance, getting the first element from <code class="inlineCode">LinkedHashMap</code> via the Sequenced Collections API can be done via <code class="inlineCode">firstEntry()</code>/<code class="inlineCode">lastEntry()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Entry&lt;Integer, String&gt; fe = linkedhashmap.firstEntry();
Entry&lt;Integer, String&gt; le = linkedhashmap.lastEntry();
</code></pre>
    <p class="normal">While there is no <code class="inlineCode">firstKey()</code>/<code class="inlineCode">lastKey()</code> or <code class="inlineCode">firstValue()</code>/<code class="inlineCode">lastValue()</code>, we can get the first key/value via <code class="inlineCode">sequencedKeySet()</code> and <code class="inlineCode">sequencedValues()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedSet&lt;Integer&gt; keysLinkedHashMap
  = linkedhashmap.sequencedKeySet();
keysLinkedHashMap.getFirst();
keysLinkedHashMap.getLast();
SequencedCollection&lt;String&gt; valuesLinkedHashMap
  = linkedhashmap.sequencedValues();
valuesLinkedHashMap.getFirst();
valuesLinkedHashMap.getLast();
</code></pre>
    <p class="normal">The same logic can be applied for entries as well via <code class="inlineCode">sequencedEntrySet()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedSet&lt;Entry&lt;Integer, String&gt;&gt; entriesLinkedHashMap
  = linkedhashmap.sequencedEntrySet();
entriesLinkedHashMap.getFirst();
entriesLinkedHashMap.getLast();
</code></pre>
    <p class="normal">But, obviously, using <code class="inlineCode">firsEntry()</code>/<code class="inlineCode">lastEntry()</code> is neater.</p>
    <p class="normal">Adding a new entry on the last position is possible by simply calling <code class="inlineCode">put(K key, V value)</code>. However, adding a new entry to the first position cannot be done that easily. But, we can create a<a id="_idIndexMarker611"/> new <code class="inlineCode">LinkedHashMap</code> and put the new entry into it. Afterwards, we copy the entries from the original <code class="inlineCode">LinkedHashMap</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedMap&lt;Integer, String&gt; slinkedhashmap
  = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedHashMap</span>&lt;&gt;();
slinkedhashmap.put(<span class="hljs-number">0</span>, <span class="hljs-string">"zero"</span>); <span class="hljs-comment">// add the first entry</span>
slinkedhashmap.putAll(linkedhashmap);
slinkedhashmap.put(<span class="hljs-number">6</span>, <span class="hljs-string">"six"</span>);  <span class="hljs-comment">// add the last entry</span>
</code></pre>
    <p class="normal">The resulting <code class="inlineCode">slinkedhashmap</code> will contain the following entries: <em class="italic">0=zero, 1=one, 2=two, 3=three, 4=four, 5=five, 6=six</em>.</p>
    <p class="normal">Obviously, this is far from an optimal and elegant approach. We would do better to rely on the Sequenced Collections API’s <code class="inlineCode">putFirst()</code>/<code class="inlineCode">putLast()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashmap.putFirst(<span class="hljs-number">0</span>, <span class="hljs-string">"zero"</span>);
linkedhashmap.putLast(<span class="hljs-number">6</span>, <span class="hljs-string">"six"</span>);
</code></pre>
    <p class="normal">That’s quite neat!</p>
    <p class="normal">Removing the first/last entry can be done in two steps. First, we get the first/last entry from <code class="inlineCode">LinkedHashMap</code> via the <code class="inlineCode">Iterator</code>/<code class="inlineCode">Stream</code> APIs. Second, we rely on the <code class="inlineCode">remove()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Entry&lt;Integer, String&gt; firstentrylhm
  = linkedhashmap.entrySet().iterator().next();
linkedhashmap.remove(firstentrylhm.getKey());
<span class="hljs-comment">// or, like this</span>
linkedhashmap.remove(
  firstentrylhm.getKey(), firstentrylhm.getValue());
Entry&lt;Integer, String&gt; lastEntryLhm
  = linkedhashmap.entrySet().stream().skip(
      linkedhashmap.size() - <span class="hljs-number">1</span>).findFirst().get();
linkedhashmap.remove(lastEntryLhm.getKey());
<span class="hljs-comment">// or, like this</span>
linkedhashmap.remove(
  lastEntryLhm.getKey(), lastEntryLhm.getValue());
</code></pre>
    <p class="normal">Wow! That’s ugly, right?! Fortunately, the Sequenced Collections API exposes <code class="inlineCode">pollFirstEntry()</code>/<code class="inlineCode">pollLastEntry()</code> precisely<a id="_idIndexMarker612"/> for this purpose:</p>
    <pre class="programlisting code"><code class="hljs-code">linkedhashmap.pollFirstEntry();
linkedhashmap.pollLastEntry();
</code></pre>
    <p class="normal">Reversing <code class="inlineCode">LinkedHashMap</code> is also tricky. There are multiple cumbersome approaches, one of which is to create a new <code class="inlineCode">LinkedHashMap</code>. Then, employ the <code class="inlineCode">descendingIterator()</code> API to iterate the original <code class="inlineCode">LinkedHashMap</code> from end to start while adding to the new <code class="inlineCode">LinkedHashMap</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedMap&lt;Integer, String&gt; reversedlinkedhashmap
  = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedHashMap</span>&lt;&gt;();
Set&lt;Integer&gt; setKeys = linkedhashmap.keySet();
LinkedList&lt;Integer&gt; listKeys = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>&lt;&gt;(setKeys);
Iterator&lt;Integer&gt; iterator = listKeys.descendingIterator();
<span class="hljs-keyword">while</span> (iterator.hasNext()) {
  <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();
  reversedlinkedhashmap.put(key, linkedhashmap.get(key));
}
</code></pre>
    <p class="normal">This code is hard to digest! It would be better to use the Sequenced Collections API, which exposes the <code class="inlineCode">reversed()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedMap&lt;Integer, String&gt; reversedMap
  = linkedhashmap.reversed();
</code></pre>
    <p class="normal">That’s simple!</p>
    <h3 id="_idParaDest-253" class="heading-3">Applying the Sequenced Collections API to SortedMap (TreeMap)</h3>
    <p class="normal"><code class="inlineCode">SortedMap</code> extends <code class="inlineCode">SequencedMap</code> and keeps<a id="_idIndexMarker613"/> its entries sorted by the natural ordering or by an explicit <code class="inlineCode">Comparator</code>. Let’s give it a try on a <code class="inlineCode">TreeMap</code> implementation of <code class="inlineCode">SortedMap</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">SortedMap&lt;Integer, String&gt; sortedmap = <span class="hljs-keyword">new</span> <span class="hljs-title">TreeMap</span>&lt;&gt;();
sortedmap.put(<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>);
sortedmap.put(<span class="hljs-number">2</span>, <span class="hljs-string">"two"</span>);
sortedmap.put(<span class="hljs-number">3</span>, <span class="hljs-string">"three"</span>);
sortedmap.put(<span class="hljs-number">4</span>, <span class="hljs-string">"four"</span>);
sortedmap.put(<span class="hljs-number">5</span>, <span class="hljs-string">"five"</span>);
</code></pre>
    <p class="normal">Getting the first/last entry from <code class="inlineCode">TreeMap</code> can be done via the <code class="inlineCode">firstKey()</code> and <code class="inlineCode">lastKey()</code> methods <a id="_idIndexMarker614"/>respectively, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Integer</span> <span class="hljs-variable">fkey</span> <span class="hljs-operator">=</span> sortedmap.firstKey(); <span class="hljs-comment">// first key</span>
<span class="hljs-type">String</span> <span class="hljs-variable">fval</span> <span class="hljs-operator">=</span> sortedmap.get(fkey);   <span class="hljs-comment">// first value</span>
<span class="hljs-type">Integer</span> <span class="hljs-variable">lkey</span> <span class="hljs-operator">=</span> sortedmap.lastKey();  <span class="hljs-comment">// last key</span>
<span class="hljs-type">String</span> <span class="hljs-variable">lval</span> <span class="hljs-operator">=</span> sortedmap.get(lkey);   <span class="hljs-comment">// last value</span>
</code></pre>
    <p class="normal">If we prefer the Sequenced Collections API, then we can use <code class="inlineCode">firstEntry()</code>/<code class="inlineCode">lastEntry()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedmap.firstEntry();
sortedmap.firstEntry().getKey();
sortedmap.firstEntry().getValue();
sortedmap.lastEntry();
sortedmap.lastEntry().getKey();
sortedmap.lastEntry().getValue();
</code></pre>
    <p class="normal">In addition, sorted maps can take advantage of <code class="inlineCode">sequencedKeySet()</code>, <code class="inlineCode">sequencedValues()</code>, and <code class="inlineCode">sequencedEntrySet()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">SequencedSet&lt;Integer&gt; keysSortedMap
  = sortedmap.sequencedKeySet();
keysSortedMap.getFirst();
keysSortedMap.getLast();
SequencedCollection&lt;String&gt; valuesSortedMap
  = sortedmap.sequencedValues();
valuesSortedMap.getFirst();
valuesSortedMap.getLast();
SequencedSet&lt;Entry&lt;Integer, String&gt;&gt; entriesSortedMap
  = sortedmap.sequencedEntrySet();
entriesSortedMap.getFirst();
entriesSortedMap.getLast();
</code></pre>
    <p class="normal">Since a sorted map keeps its entries ordered based on the natural ordering or an explicit <code class="inlineCode">Comparator</code>, we cannot add an entry on the first/last position. In other words, what we want to insert on the first/last position may land anywhere in the sorted map depending on the <code class="inlineCode">Comparator</code> logic. In<a id="_idIndexMarker615"/> this context, the Sequenced Collections API represented by <code class="inlineCode">putFirst()</code>/<code class="inlineCode">putLast()</code> will throw <code class="inlineCode">UnsupportedOperationException</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedmap.putFirst(<span class="hljs-number">0</span>, <span class="hljs-string">"zero"</span>); <span class="hljs-comment">//UnsupportedOperationException</span>
sortedmap.putLast(<span class="hljs-number">6</span>, <span class="hljs-string">"six"</span>);   <span class="hljs-comment">//UnsupportedOperationException</span>
</code></pre>
    <p class="normal">Removing the first/last entry can be done via the <code class="inlineCode">remove()</code> methods as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Integer</span> <span class="hljs-variable">fkey</span> <span class="hljs-operator">=</span> sortedmap.firstKey();
<span class="hljs-type">String</span> <span class="hljs-variable">fval</span> <span class="hljs-operator">=</span> sortedmap.get(fkey);
<span class="hljs-type">Integer</span> <span class="hljs-variable">lkey</span> <span class="hljs-operator">=</span> sortedmap.lastKey();
<span class="hljs-type">String</span> <span class="hljs-variable">lval</span> <span class="hljs-operator">=</span> sortedmap.get(lkey);
sortedmap.remove(fkey);
sortedmap.remove(fkey, fval);
sortedmap.remove(lkey);
sortedmap.remove(lkey, lval);
</code></pre>
    <p class="normal">The Sequenced Collections API can significantly reduce this code via <code class="inlineCode">pollFirstEntry()</code> and <code class="inlineCode">pollLastEntry()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">sortedmap.pollFirstEntry();
sortedmap.pollLastEntry();
</code></pre>
    <p class="normal">Reversing a sorted map can be done via <code class="inlineCode">descendingMap()</code> (or <code class="inlineCode">descendingKeySet()</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">NavigableMap&lt;Integer, String&gt; reversednavigablemap
  = ((TreeMap) sortedmap).descendingMap();
</code></pre>
    <p class="normal">Or, we can keep things simple via the Sequenced Collections API, which exposes the <code class="inlineCode">reversed()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">SortedMap&lt;Integer, String&gt; reversedsortedmap
  = sortedmap.reversed();
</code></pre>
    <p class="normal">Done! As you have just seen, the Sequenced Collections API is quite useful and easy to use. Feel free to exploit it on other collections as well.</p>
    <h1 id="_idParaDest-254" class="heading-1">119. Introducing the Rope data structure</h1>
    <p class="normal"><strong class="keyWord">Prerequisite</strong>: Starting with this problem, we will cover a bunch of complex data structures that require previous experience with binary trees, lists, heaps, queues, stacks, and so on. If you are a novice in<a id="_idIndexMarker616"/> the data structure field, then I strongly recommend you postpone the following problems until you manage to read <em class="italic">The Complete Coding Interview Guide in Java</em>, which provides deep coverage of these preliminary topics.</p>
    <p class="normal">When we need to handle large amounts of text (for instance, if we were developing a text editor or a powerful text search engine), we have to deal with a significant number of complex tasks. Among these tasks, we have to consider appending/concatenating strings and memory consumption.</p>
    <p class="normal">The Rope data structure is a special binary tree that aims to improve string operations while using memory efficiently (which is especially useful for large strings). Its Big O goals are listed in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_13.png" alt="Figure 5.12.png"/></figure>
    <p class="packt_figref">Figure 5.13: Big O for Rope</p>
    <p class="normal">Being a binary tree, a Rope can be shaped via the classical <code class="inlineCode">Node</code> class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {
  <span class="hljs-keyword">private</span> Node left;
  <span class="hljs-keyword">private</span> Node right;
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> weight;
  <span class="hljs-keyword">private</span> String str;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(String str)</span> {
    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, str.length(), str);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Node left, Node right, </span><span class="hljs-type">int</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-built_in">this</span>(left, right, weight, <span class="hljs-literal">null</span>);
  }
  <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Node left, Node right, </span><span class="hljs-type">int</span><span class="hljs-params"> weight, String str)</span> {
    <span class="hljs-built_in">this</span>.left = left;
    <span class="hljs-built_in">this</span>.right = right;
    <span class="hljs-built_in">this</span>.str = str;
    <span class="hljs-built_in">this</span>.weight = weight;
  }
}
</code></pre>
    <p class="normal">Each node holds pointers to its <a id="_idIndexMarker617"/>children (left and right) and the total weight of the nodes in its left subtree (<code class="inlineCode">weight</code>). Leaf nodes store small chunks of the large string (<code class="inlineCode">str</code>). Here is a Rope for the text <em class="italic">I am a very cool rope</em>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_14.png" alt="Figure 5.13.png"/></figure>
    <p class="packt_figref">Figure 5.14: Rope sample</p>
    <p class="normal">Next, let’s implement the main operations of a Rope, starting with searching by index. <code class="inlineCode">Rope</code> is a static class containing all the following operations.</p>
    <h2 id="_idParaDest-255" class="heading-2">Implementing indexAt(Node node, int index)</h2>
    <p class="normal">The <code class="inlineCode">indexAt(Node node, int index)</code> method<a id="_idIndexMarker618"/> attempts to find the character at the given <code class="inlineCode">index</code>. This is a recursive process based on a simple rule, as follows:</p>
    <ul>
      <li class="bulletList">If <code class="inlineCode">index &gt; (weight - 1)</code> then <code class="inlineCode">index = index - weight</code> and move to the right node.</li>
      <li class="bulletList">If <code class="inlineCode">index &lt; weight</code> then just move to the left node.</li>
    </ul>
    <p class="normal">These two steps are repeated until we hit a leaf node and we return the character at the current <code class="inlineCode">index</code>.</p>
    <p class="normal">Let’s assume that we want to<a id="_idIndexMarker619"/> return the character from <code class="inlineCode">index</code> 5, which is <code class="inlineCode">e</code> (see <em class="italic">Figure 5.14</em>):</p>
    <ul>
      <li class="bulletList">Starting from the root, we have <code class="inlineCode">index</code> = 5, <code class="inlineCode">index </code>&lt; 8, so we move left. </li>
      <li class="bulletList">Next, <code class="inlineCode">index</code> = 5, 5 &gt; 3, so <code class="inlineCode">index</code> = 5 – 3 = 2 and we move right.</li>
      <li class="bulletList">Next, <code class="inlineCode">index</code> = 2, 2 &gt; 1, so <code class="inlineCode">index</code> = 2 – 1 = 1 and we move right.</li>
      <li class="bulletList">The right node is a leaf node, so we return <code class="inlineCode">charAt(1)</code>, which is <code class="inlineCode">e</code>.</li>
    </ul>
    <figure class="mediaobject"><img src="../Images/B19665_05_15.png" alt="Figure 5.14.png"/></figure>
    <p class="packt_figref">Figure 5.15: Implementing indexAt()</p>
    <p class="normal">In code form, this algorithm is quite simple:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span> <span class="hljs-title">indexAt</span><span class="hljs-params">(Node node, </span><span class="hljs-type">int</span><span class="hljs-params"> index)</span> {
   <span class="hljs-keyword">if</span> (index &gt; node.weight - <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> indexAt(node.right, index - node.weight);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> indexAt(node.left, index);
  } <span class="hljs-keyword">else</span> {            
    <span class="hljs-keyword">return</span> node.str.charAt(index);
  }
}
</code></pre>
    <p class="normal">Next, let’s talk about concatenating two Ropes.</p>
    <h2 id="_idParaDest-256" class="heading-2">Implementing concat(Node node1, Node node2)</h2>
    <p class="normal">Concatenating two Ropes (<code class="inlineCode">node1</code> and <code class="inlineCode">node2</code>) is a straightforward step-by-step algorithm:</p>
    <ul>
      <li class="bulletList">Create a new root <a id="_idIndexMarker620"/>node that has the weight of the leaf nodes in <code class="inlineCode">node1</code>.</li>
      <li class="bulletList">The new root node has <code class="inlineCode">node1</code> as its left child and <code class="inlineCode">node2</code> as its right child.</li>
      <li class="bulletList">Optional rebalancing (this isn’t implemented here, but takes the form of classic binary tree rebalancing).</li>
    </ul>
    <p class="normal">The following diagram represents the concatenation of two Ropes:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_16.png" alt="Figure 5.15.png"/></figure>
    <p class="packt_figref">Figure 5.16: Concatenating two Ropes</p>
    <p class="normal">In code form, we have the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">concat</span><span class="hljs-params">(Node node1, Node node2)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(node1, node2, getLength(node1));
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(Node node)</span> {
  <span class="hljs-keyword">if</span> (node.str != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> node.weight;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> getLength(node.left) + (node.right == <span class="hljs-literal">null</span> ? 
      <span class="hljs-number">0</span> : getLength(node.right));
  }
}
</code></pre>
    <p class="normal">Next, let’s insert a new node.</p>
    <h2 id="_idParaDest-257" class="heading-2">Implementing insert(Node node, int index, String str)</h2>
    <p class="normal">In order to insert a piece of a string at a <a id="_idIndexMarker621"/>certain index in the original string, we have to split the original string and perform two concatenations. The algorithm has three steps, as follows:</p>
    <ul>
      <li class="bulletList">Split the original string at a given index into two strings, <code class="inlineCode">s1</code> and <code class="inlineCode">s2</code>.</li>
      <li class="bulletList">Concatenate <code class="inlineCode">s1</code> and the given <code class="inlineCode">str</code> into <code class="inlineCode">s3</code>.</li>
      <li class="bulletList">Concatenate <code class="inlineCode">s1</code> with the new <code class="inlineCode">s3</code>.</li>
    </ul>
    <p class="normal">In code form, we get the following implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(Node node, </span><span class="hljs-type">int</span><span class="hljs-params"> index, String str)</span> {
  List&lt;Node&gt; splitRopes = Rope.split(node, index);
  <span class="hljs-type">Node</span> <span class="hljs-variable">insertNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, str.length(), str);
  Node resultNode;
  <span class="hljs-keyword">if</span> (splitRopes.size() == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) {
      resultNode = Rope.concat(insertNode, splitRopes.get(<span class="hljs-number">0</span>));
    } <span class="hljs-keyword">else</span> {
      resultNode = Rope.concat(splitRopes.get(<span class="hljs-number">0</span>), insertNode);
    }
  } <span class="hljs-keyword">else</span> { 
    resultNode = Rope.concat(splitRopes.get(<span class="hljs-number">0</span>), insertNode);
    resultNode = Rope.concat(resultNode, splitRopes.get(<span class="hljs-number">1</span>));
  }
  <span class="hljs-keyword">return</span> resultNode;
}
</code></pre>
    <p class="normal">Next, let’s see how to delete a substring.</p>
    <h2 id="_idParaDest-258" class="heading-2">Implementing delete(Node node, int start, int end)</h2>
    <p class="normal">Deleting a substring from the<a id="_idIndexMarker622"/> original string between <code class="inlineCode">start</code> and <code class="inlineCode">end</code> requires two splits and one concatenation. The algorithm consists of three steps, as follows:</p>
    <ul>
      <li class="bulletList">Split the original string at <code class="inlineCode">start</code> into <code class="inlineCode">s1</code> and <code class="inlineCode">s2</code>.</li>
      <li class="bulletList">Split <code class="inlineCode">s2</code> at <code class="inlineCode">end</code> into <code class="inlineCode">s3</code> and <code class="inlineCode">s4</code>.</li>
      <li class="bulletList">Concatenate <code class="inlineCode">s1</code> and <code class="inlineCode">s4</code>.</li>
    </ul>
    <p class="normal">In code form, we have the<a id="_idIndexMarker623"/> following implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">delete</span><span class="hljs-params">(Node node, </span><span class="hljs-type">int</span><span class="hljs-params"> start, </span><span class="hljs-type">int</span><span class="hljs-params"> end)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">beforeNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
  Node afterNode;
  List&lt;Node&gt; splitRopes1 = Rope.split(node, start);
  <span class="hljs-keyword">if</span> (splitRopes1.size() == <span class="hljs-number">1</span>) {
    afterNode = splitRopes1.get(<span class="hljs-number">0</span>);
  } <span class="hljs-keyword">else</span> {
    beforeNode = splitRopes1.get(<span class="hljs-number">0</span>);
    afterNode = splitRopes1.get(<span class="hljs-number">1</span>);
  }
  List&lt;Node&gt; splitRopes2 = Rope.split(afterNode, end - start);
  <span class="hljs-keyword">if</span> (splitRopes2.size() == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> beforeNode;
  }
  <span class="hljs-keyword">return</span> beforeNode == <span class="hljs-literal">null</span> ? splitRopes2.get(<span class="hljs-number">1</span>) : 
    Rope.concat(beforeNode, splitRopes2.get(<span class="hljs-number">1</span>));
}
</code></pre>
    <p class="normal">Finally, let’s talk about splitting a Rope.</p>
    <h2 id="_idParaDest-259" class="heading-2">Implementing split(Node node, int index)</h2>
    <p class="normal">Splitting a Rope into two Ropes is an<a id="_idIndexMarker624"/> operation that should come with two considerations:</p>
    <ul>
      <li class="bulletList">The split should take place at the last character (index).</li>
      <li class="bulletList">The split should take place at the middle character (index).</li>
    </ul>
    <p class="normal">Both of these cases are considered in the implementation listed in the bundled code. Since this code is simple but quite large, we skipped it here for brevity.</p>
    <h1 id="_idParaDest-260" class="heading-1">120. Introducing the Skip List data structure</h1>
    <p class="normal">The Skip List data structure is a probabilistic data <a id="_idIndexMarker625"/>structure built on top of a linked list. A Skip List uses an underlying linked list to keep a sorted list of items, but it also provides the capability to skip certain items in order to speed up operations such as insert, delete, and find. Its Big O goals are listed in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_17.png" alt="Figure 5.16.png"/></figure>
    <p class="packt_figref">Figure 5.17: Big (O) for Skip List</p>
    <p class="normal">A Skip List has two types of layers. The base layer (or the lower layer, or layer 0) consists of a regular linked list that holds the sorted list of all items. The rest of the layers contain sparse items and act as an “express line” meant to speed up the search, insert, and delete items. The following figure helps us to visualize a Skip List with three layers:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_18.png" alt="Figure 5.17.png"/></figure>
    <p class="packt_figref">Figure 5.18: Skip List sample</p>
    <p class="normal">So, this Skip List holds on layer 0 the items 1, 2, 3, 4, 5, 8, 9, 10, 11, and 34 and has two express lines (layer 1 and layer 2) containing sparse items. Next, let’s see how we can find a certain item.</p>
    <h2 id="_idParaDest-261" class="heading-2">Implementing contains(Integer data)</h2>
    <p class="normal">Searching certain items <a id="_idIndexMarker626"/>starts on layer <em class="italic">n</em>, continues layer <em class="italic">n</em>-1, and so on until layer 0. For instance, let’s assume that we want to find item 11.</p>
    <p class="normal">We start on layer 2 and continue running on this layer until we find a node &gt;= 11. Since the value 11 doesn’t exist on layer 2, we search for an item less than 11 and we find 10.</p>
    <p class="normal">We get down on layer 1 and continue searching. Based on the same logic we find item 10 again. Layer 1 doesn’t contain item 11 either. If it had contained it, then we would have stopped the search.</p>
    <p class="normal">We go down again, this time to layer 0 (the base layer containing all items), and continue searching until we find item 11. The following figure depicts our search path:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_19.png" alt="Figure 5.18.png"/></figure>
    <p class="packt_figref">Figure 5.19: Finding an item in a Skip List</p>
    <p class="normal">By following the highlighted path, we can see that we skipped a significant number of items until we found item 11.</p>
    <p class="normal">In code form, this operation can be implemented as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Integer data)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">cursorNode</span> <span class="hljs-operator">=</span> head;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> topLayer - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">while</span> (cursorNode.next[i] != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (cursorNode.next[i].getData() &gt; data) {
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (cursorNode.next[i].getData().equals(data)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      cursorNode = cursorNode.next[i];
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
    <p class="normal">Next, let’s see how we can<a id="_idIndexMarker627"/> insert a new item.</p>
    <h2 id="_idParaDest-262" class="heading-2">Implementing insert(Integer data)</h2>
    <p class="normal">Inserting a new item takes place on a randomly chosen layer. In other words, the layer of an item is chosen randomly at<a id="_idIndexMarker628"/> insertion time. We can insert it into an existing layer or create a new layer specially for this new item. We can create new layers until we hit an arbitrary chosen <code class="inlineCode">MAX_NUMBER_OF_LAYERS</code> (we have <code class="inlineCode">MAX_NUMBER_OF_LAYERS</code> = 10).</p>
    <p class="normal">During the insertion algorithm, we apply the following steps to search for the proper place for the item to insert:</p>
    <ul>
      <li class="bulletList">If the item of the next node is less than the item to insert, then we continue moving forward on the same layer.</li>
      <li class="bulletList">If the item of the next node is greater than the item to insert, then we save the pointer to the current node and continue by moving one layer down. The search continues from here.</li>
      <li class="bulletList">At some point, we will reach the base layer (layer 0). Since this layer holds all items, we know for sure that we will find a slot here for the new item.</li>
    </ul>
    <p class="normal">In the following figure, item 7 was inserted on Layer 1:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_20.png" alt="Figure 5.19.png"/></figure>
    <p class="packt_figref">Figure 5.20: Inserting an item in a Skip List</p>
    <p class="normal">The implementation is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Integer data)</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">layer</span> <span class="hljs-operator">=</span> incrementLayerNo();
  <span class="hljs-type">Node</span> <span class="hljs-variable">newNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(data, layer);
  <span class="hljs-type">Node</span> <span class="hljs-variable">cursorNode</span> <span class="hljs-operator">=</span> head;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> topLayer - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">while</span> (cursorNode.next[i] != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (cursorNode.next[i].getData() &gt; data) {
        <span class="hljs-keyword">break</span>;
      }
      cursorNode = cursorNode.next[i];
    }
    <span class="hljs-keyword">if</span> (i &lt;= layer) {
      newNode.next[i] = cursorNode.next[i];
      cursorNode.next[i] = newNode;
    }
  }
  size++;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">incrementLayerNo()</code> is a method<a id="_idIndexMarker629"/> that randomly decides the layer on which the new item will be inserted.</p>
    <h2 id="_idParaDest-263" class="heading-2">Implementing delete(Integer data)</h2>
    <p class="normal">Deleting an item is a simple operation. We start<a id="_idIndexMarker630"/> from the top layer, find the item to delete, and then delete it. The challenge is to pay attention to only eliminating the item by correctly linking the remaining nodes. The implementation is simple:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(Integer data)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">cursorNode</span> <span class="hljs-operator">=</span> head;
  <span class="hljs-type">boolean</span> <span class="hljs-variable">deleted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> topLayer - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
    <span class="hljs-keyword">while</span> (cursorNode.next[i] != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (cursorNode.next[i].getData() &gt; data) {
        <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (cursorNode.next[i].getData().equals(data)) { 
        cursorNode.next[i] = cursorNode.next[i].next[i];
        deleted = <span class="hljs-literal">true</span>;
        size--;
        <span class="hljs-keyword">break</span>;
      }
      cursorNode = cursorNode.next[i];
    }
  }
  <span class="hljs-keyword">return</span> deleted;
}
</code></pre>
    <p class="normal">Challenge yourself to <a id="_idIndexMarker631"/>implement a Skip List on top of the Java built-in <code class="inlineCode">LinkedList</code>. It will be fun and give you the chance to explore the Skip List data structure a step further.</p>
    <h1 id="_idParaDest-264" class="heading-1">121. Introducing the K-D Tree data structure</h1>
    <p class="normal">A K-D Tree (also referred to as a<a id="_idIndexMarker632"/> K-dimensional tree) is a data structure that is a flavor of <strong class="keyWord">Binary Search Tree</strong> (<strong class="keyWord">BST</strong>) dedicated to holding and organizing points/coordinates in a<a id="_idIndexMarker633"/> K-dimensional space (2-D, 3-D, and so on). Each node of a K-D Tree holds a point representing a multi-dimensional space. The following snippet shapes a node of a 2-D Tree:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span>[] coords;
  <span class="hljs-keyword">private</span> Node left;
  <span class="hljs-keyword">private</span> Node right;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params">[] coords)</span> {
    <span class="hljs-built_in">this</span>.coords = coords;
  }
  ...
}
</code></pre>
    <p class="normal">Instead of a <code class="inlineCode">double[]</code> array, you may prefer <code class="inlineCode">java.awt.geom.Point2D</code>, which is dedicated to representing a location in <em class="italic">(x, y)</em> coordinate space.</p>
    <p class="normal">Commonly, K-D Trees are useful for performing different kinds of searches such as nearest-neighbor searches <a id="_idIndexMarker634"/>and range queries. For instance, let’s assume a 2-D space and a bunch of <em class="italic">(x, y)</em> coordinates in this space:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">double</span>[][] coords = {
  {<span class="hljs-number">3</span>, <span class="hljs-number">5</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">5</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">4</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">3</span>, <span class="hljs-number">2</span>}, 
  {<span class="hljs-number">5</span>, <span class="hljs-number">2</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">4</span>}, {<span class="hljs-number">2</span>, <span class="hljs-number">5</span>}
};
</code></pre>
    <p class="normal">We can represent these coordinates using the well-known X-Y coordinates system, but we can also store them in a K-2D Tree as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_21.png" alt="Figure 5.20.png"/></figure>
    <p class="packt_figref">Figure 5.21: A 2D space represented in X-Y coordinates system and K-2D Tree</p>
    <p class="normal">But, how did we build the K-D Tree? </p>
    <h2 id="_idParaDest-265" class="heading-2">Inserting into a K-D Tree</h2>
    <p class="normal">We insert our <a id="_idIndexMarker635"/>coordinates (<code class="inlineCode">cords</code>) one by one starting with <code class="inlineCode">coords[0]</code> = (3,5). The (3,5) pair becomes the root of the K-D Tree. The next pair of coordinates is (1,4). We compare <em class="italic">x</em> of the root with <em class="italic">x</em> of this pair and we notice that 1 &lt; 3, which means that (1,4) becomes the left child of the root. The next pair is (5,4). At the first level, we compare the <em class="italic">x</em> of the root with 5 and we see that 5 &gt; 3, so (5,4) becomes the right child of the root. The following figure illustrates the insertion of (3,5), (1,4), and (5,4).</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_22.png" alt="Figure 5.21.png"/></figure>
    <p class="packt_figref">Figure 5.22: Inserting (3,5), (1,4), and (5,4)</p>
    <p class="normal">Next, we insert the pair (2,3). We compare the <em class="italic">x</em> components of (2,3) and (3,5) and we see that 2 &lt; 3, so (2,3) goes to the left of the root. Next, we compare the <em class="italic">y</em> component of (2,3) and (1,4) and we see <a id="_idIndexMarker636"/>that 3 &lt; 4, so (2,3) goes to the left of (1,4). </p>
    <p class="normal">Next, we insert the pair (4,2). We compare the <em class="italic">x</em> components of (4,2) and (3,5) and we see that 4 &gt; 3, so (4,2) goes to the right of the root. Next, we compare the <em class="italic">y</em> component of (4,2) and (5,4) and we see that 2 &lt; 4, so (4,2) goes to the left of (5,4). The following figure illustrates the insertion of (2, 3), and (4,2).</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_23.png" alt="Figure 5.22.png"/></figure>
    <p class="packt_figref">Figure 5.23: Inserting (2,3) and (4,2)</p>
    <p class="normal">Next, we insert the pair (3,2). We compare the <em class="italic">x</em> components of (3,2) and (3,5) and we see that 3 = 3, so (3,2) goes to the right of the root. Next, we compare the <em class="italic">y</em> component of (3,2) and (5,4) and we see that 2 &lt; 4, so (3,2) goes to the left of (5,4). Next, we compare the <em class="italic">x</em> component of (3,2) and (4,2) and we see that 3 &lt; 4, so (3,2) goes to the left of (4,2).</p>
    <p class="normal">Next, we insert the pair (5,2). We compare the <em class="italic">x</em> components of (5,2) and (3,5) and we see that 5 &gt; 3, so (5,2) goes to the right of the root. Next, we compare the<em class="italic"> y</em> component of (5,2) and (5,4) and we see that 2 &lt; 4, so (5,2) goes to the left of (5,4). Next, we compare the <em class="italic">x</em> component<a id="_idIndexMarker637"/> of (5,2) and (4,2) and we see that 5 &gt; 4, so (5,2) goes to the right of (4,2). The following figure outlines the insertion of (3,2), and (5,2).</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_24.png" alt="Figure 5.23.png"/></figure>
    <p class="packt_figref">Figure 5.24: Inserting (3,2) and (5,2)</p>
    <p class="normal">Next, we insert the pair (2,1). We compare the <em class="italic">x</em> components of (2,1) and (3,5) and we see that 2 &lt; 3, so (2,1) goes to the left of the root. Next, we compare the <em class="italic">y</em> component of (2,1) and (1,4) and we see that 1 &lt; 4, so (2,1) goes to the left of (1,4). Next, we compare the <em class="italic">x</em> component of (2,1) and (2,3) and we see that 2 = 2, so (2,1) goes to the right of (2,3).</p>
    <p class="normal">Next, we insert the pair (2,4). We compare the <em class="italic">x </em>components of (2,4) and (3,5) and we see that 2 &lt; 3, so (2,4) goes to the left of the root. Next, we compare the <em class="italic">y</em> component of (2,4) and (1,4) and we see that 4 = 4, so (2,4) goes to the right of (1,4).</p>
    <p class="normal">Finally, we insert the pair (2,5). We compare the <em class="italic">x</em> components of (2,5) and (3,5) and we see that 2 &lt; 3, so (2,5) goes to the left of the root. Next, we compare the <em class="italic">y</em> component of (2,5) and (1,4) and we see that 5 &gt; 4, so (2,5) goes to the right of (1,4). Next, we compare the <em class="italic">x</em> component of (2,5) and (2,4) and we see that 2 = 2, so (2,5) goes to the right of (2,4). The following figure illustrates the insertion of (2,1), (2,4), and (2,5).</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_25.png" alt="Figure 5.24.png"/></figure>
    <p class="packt_figref">Figure 5.25: Inserting (2,1), (2,4), and (2,5)</p>
    <p class="normal">Done! So inserting has two simple rules:</p>
    <ul>
      <li class="bulletList">We compare components <a id="_idIndexMarker638"/>alternatively starting with <em class="italic">x</em>. At level one, we compare <em class="italic">x</em>, at level two, we compare <em class="italic">y</em>, at level three we compare <em class="italic">x</em>, at level four we compare <em class="italic">y</em>, and so on.</li>
      <li class="bulletList">When comparing (<em class="italic">x1</em>, <em class="italic">y1</em>) with (<em class="italic">x2</em>, <em class="italic">y2</em>), if <em class="italic">x2</em>&gt;= <em class="italic">x1</em> or <em class="italic">y2</em>&gt;= <em class="italic">y1</em> (depending on which component is being compared) then the (<em class="italic">x2</em>,<em class="italic">y2</em>) node goes to the right (<em class="italic">x1</em>,<em class="italic">y1</em>), otherwise to the left.</li>
    </ul>
    <p class="normal">Based on these statements, the implementation of a 2-D model is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params">[] coords)</span> {
  root = insert(root, coords, <span class="hljs-number">0</span>);
}
<span class="hljs-keyword">private</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(Node root, </span><span class="hljs-type">double</span><span class="hljs-params">[] coords, </span><span class="hljs-type">int</span><span class="hljs-params"> depth)</span> {
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> newNode(coords);
  }
  <span class="hljs-type">int</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> depth % <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span> (coords[cd] &lt; root.coords[cd]) {
    root.left = insert(root.left, coords, depth + <span class="hljs-number">1</span>);
  } <span class="hljs-keyword">else</span> {
    root.right = insert(root.right, coords, depth + <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
    <p class="normal">Another approach for inserting in a K-D Tree relies on a sorting algorithm for sorting the coordinates. This<a id="_idIndexMarker639"/> implementation is not provided here.</p>
    <h2 id="_idParaDest-266" class="heading-2">Finding the nearest neighbor</h2>
    <p class="normal">Finding the nearest neighbor is the<a id="_idIndexMarker640"/> classical operation performed on a K-D Tree. We have a given point (<em class="italic">x</em>,<em class="italic">y</em>), and we want to know what the nearest point is from the K-D Tree. For instance, we may want to find the nearest neighbor of (4,4) – check the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_26.png" alt="Figure 5.25.png"/></figure>
    <p class="packt_figref">Figure 5.26: Find the nearest neighbor of (4,4)</p>
    <p class="normal">The nearest neighbor of (4,4) is (5,4). In a nutshell, finding the nearest neighbor is about finding the shortest distance from the given point to any other point present in the K-D Tree. We start from the root and compute the distance between the given point (or target node) and the current node. The shortest distance wins. The implementation starts like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span>[] findNearest(<span class="hljs-type">double</span>[] coords) {
  <span class="hljs-type">Node</span> <span class="hljs-variable">targetNode</span> <span class="hljs-operator">=</span> newNode(coords);
  visited = <span class="hljs-number">0</span>;
  foundDistance = <span class="hljs-number">0</span>;
  found = <span class="hljs-literal">null</span>;
  nearest(root, targetNode, <span class="hljs-number">0</span>);
  <span class="hljs-keyword">return</span> found.coords.clone();
}
</code></pre>
    <p class="normal">The <code class="inlineCode">nearest()</code> method is a<a id="_idIndexMarker641"/> recursive solution for finding the minimum distance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nearest</span><span class="hljs-params">(Node root, Node targetNode, </span><span class="hljs-type">int</span><span class="hljs-params"> index)</span> {
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  visited++;
  <span class="hljs-type">double</span> <span class="hljs-variable">theDistance</span> <span class="hljs-operator">=</span> root.theDistance(targetNode);
  <span class="hljs-keyword">if</span> (found == <span class="hljs-literal">null</span> || theDistance &lt; foundDistance) {
    foundDistance = theDistance;
    found = root;
  }
  <span class="hljs-keyword">if</span> (foundDistance == <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-type">double</span> <span class="hljs-variable">rootTargetDistance</span> <span class="hljs-operator">=</span> root.get(index) -
    targetNode.get(index);
  index = (index + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;
  nearest(rootTargetDistance &gt; <span class="hljs-number">0</span> ? 
    root.left : root.right, targetNode, index);
  <span class="hljs-keyword">if</span> (rootTargetDistance * 
          rootTargetDistance &gt;= foundDistance) {
    <span class="hljs-keyword">return</span>;
  }
  nearest(rootTargetDistance &gt; <span class="hljs-number">0</span> ? 
    root.right : root.left, targetNode, index);
}
</code></pre>
    <p class="normal">In the bundled code, you can find the missing parts of the preceding code, such as the method for computing the distance between two points.</p>
    <p class="normal">Searching and deleting items<a id="_idIndexMarker642"/> from a K-D Tree is similar to performing these operations on a BST, so nothing new.</p>
    <p class="normal">Challenge yourself to implement a 3-D Tree.</p>
    <h1 id="_idParaDest-267" class="heading-1">122. Introducing the Zipper data structure</h1>
    <p class="normal">The Zipper data structure is meant to facilitate cursor-like navigation capabilities over another data structure such as a tree. Moreover, it may provide capabilities for manipulating the tree like adding nodes, removing nodes, and so on. </p>
    <p class="normal">The Zipper is created on the top of a tree and is characterized by the current position of the cursor and the current range<a id="_idIndexMarker643"/> or the current visibility area. At any moment, the Zipper doesn’t see or act on the entire tree; its actions are available only on a subtree or a range of the tree relative to its current position. The modification accomplished via the Zipper is visible only in this range, not in the entire tree.</p>
    <p class="normal">In order to navigate and determine the current range, a Zipper must be aware of the tree structure. For instance, it must be aware of all the children of each node, which is why we start from an interface that must be implemented by any tree that wants to take advantage of a Zipper:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Zippable</span> {
  <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; getChildren();
}
</code></pre>
    <p class="normal">A tree that implements <code class="inlineCode">Zippable</code> ensures that it exposes its children to the Zipper. For instance, a tree <code class="inlineCode">Node</code> implementation can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Zippable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Node&gt; children;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> String name, </span><span class="hljs-keyword">final</span><span class="hljs-params"> Node... children)</span> {
    <span class="hljs-built_in">this</span>.name = name;
    <span class="hljs-built_in">this</span>.children = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>&lt;&gt;(Arrays.asList(children));
  }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> name;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Collection&lt;Node&gt; getChildren() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.children;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Node{"</span> + <span class="hljs-string">"name="</span> + name 
      + <span class="hljs-string">", children="</span> + children + <span class="hljs-string">'}'</span>;
  } 
}
</code></pre>
    <p class="normal">The following figure illustrates<a id="_idIndexMarker644"/> the characteristics of a Zipper at some moment in time:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_27.png" alt="Figure 5.26.png"/></figure>
    <p class="packt_figref">Figure 5.27: The Zipper position and range on an arbitrary tree</p>
    <p class="normal">The Zipper’s current position is represented by the node labeled <strong class="keyWord">55</strong> – the Zipper cursor is on position 55. The highlighted gray area is the zipper’s current range/visibility. Everything that happens in this area is invisible outside of it. From the current position, the Zipper can move <code class="inlineCode">down()</code>, <code class="inlineCode">up()</code>, <code class="inlineCode">left()</code>, and <code class="inlineCode">right()</code>. Every move will refine the Zipper range accordingly.</p>
    <p class="normal">When the Zipper is applied to a tree, each node of the tree (<code class="inlineCode">Node</code>) becomes a Zipper-node, represented here by the <code class="inlineCode">ZipNode</code> class. As you can see in the following code, a <code class="inlineCode">ZipNode</code> acts as a wrapper of a <code class="inlineCode">Node</code> and represents the unit of work for the Zipper:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZipNode</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt;
     <span class="hljs-keyword">implements</span> <span class="hljs-title">Zippable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Zippable[] DUMMY = <span class="hljs-keyword">new</span> <span class="hljs-title">Zippable</span>[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T node;        <span class="hljs-comment">// wrap the original tree node</span>
  <span class="hljs-keyword">private</span> Zippable[] children; <span class="hljs-comment">// list of children </span>
  <span class="hljs-comment">// wrap a ZipNode without children    </span>
  <span class="hljs-keyword">protected</span> <span class="hljs-title">ZipNode</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> T node)</span> {
    <span class="hljs-built_in">this</span>(node, DUMMY);
  }
  <span class="hljs-comment">// wrap a ZipNode and its children    </span>
  <span class="hljs-keyword">protected</span> <span class="hljs-title">ZipNode</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> T node, Zippable[] children)</span> {
    <span class="hljs-keyword">if</span> (children == <span class="hljs-literal">null</span>) {
      children = <span class="hljs-keyword">new</span> <span class="hljs-title">Zippable</span>[<span class="hljs-number">0</span>];
    }
    <span class="hljs-built_in">this</span>.node = node;
    <span class="hljs-built_in">this</span>.children = children;
  }
</code></pre>
    <p class="normal">The remaining code handles the<a id="_idIndexMarker645"/> initialization of children in a lazy fashion (on demand):</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; getChildren() {
    lazyGetChildren();
    <span class="hljs-keyword">return</span> (children != <span class="hljs-literal">null</span>) ? 
      <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>&lt;&gt;(Arrays.asList(children)) : <span class="hljs-literal">null</span>;
  } 
  <span class="hljs-comment">// return the original node</span>
  <span class="hljs-keyword">public</span> T <span class="hljs-title">unwrap</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isLeaf</span><span class="hljs-params">()</span> { 
    lazyGetChildren();
    <span class="hljs-keyword">return</span> children == <span class="hljs-literal">null</span> || children.length == <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">hasChildren</span><span class="hljs-params">()</span> {
    lazyGetChildren(); 
    <span class="hljs-keyword">return</span> children != <span class="hljs-literal">null</span> &amp;&amp; children.length &gt; <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">protected</span> Zippable[] children() {
    lazyGetChildren();
    <span class="hljs-keyword">return</span> children;
  }
  <span class="hljs-keyword">protected</span> ZipNode&lt;T&gt; <span class="hljs-title">replaceNode</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> T node)</span> {
    lazyGetChildren();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ZipNode</span>&lt;&gt;(node, children);
  }        
  <span class="hljs-comment">// lazy initialization of children</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lazyGetChildren</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">if</span> (children == DUMMY) {           
      Collection&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; nodeChildren
        = node.getChildren();
      children = (nodeChildren == <span class="hljs-literal">null</span>) ?
        <span class="hljs-literal">null</span> : nodeChildren.toArray(Zippable[]::<span class="hljs-keyword">new</span>);
    }
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> { 
    <span class="hljs-keyword">return</span> node.toString(); <span class="hljs-comment">// call the original toString()</span>
  }
}
</code></pre>
    <p class="normal">All the Zipper operations act <a id="_idIndexMarker646"/>on a <code class="inlineCode">ZipNode</code>, not on a <code class="inlineCode">Node</code>.</p>
    <p class="normal">Next, we have the Zipper range implementation, which basically defines the gray part of <em class="italic">Figure 5.27</em>. We have the parent node and the left/right siblings of the current range:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ZipperRange</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZipperRange parentRange;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZipNode&lt;?&gt; parentZipNode;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Zippable[] leftSiblings;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Zippable[] rightSiblings;
  <span class="hljs-keyword">protected</span> <span class="hljs-title">ZipperRange</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> ZipNode&lt;?&gt; parentZipNode, </span>
<span class="hljs-params">      </span><span class="hljs-keyword">final</span><span class="hljs-params"> ZipperRange parentRange, </span><span class="hljs-keyword">final</span><span class="hljs-params"> Zippable[]  </span>
<span class="hljs-params">      leftSiblings, </span><span class="hljs-keyword">final</span><span class="hljs-params"> Zippable[] rightSiblings)</span> {
    <span class="hljs-built_in">this</span>.parentZipNode = parentZipNode;
    <span class="hljs-built_in">this</span>.parentRange = parentRange;
    <span class="hljs-built_in">this</span>.leftSiblings = (leftSiblings == <span class="hljs-literal">null</span>) ? 
      <span class="hljs-keyword">new</span> <span class="hljs-title">Zippable</span>[<span class="hljs-number">0</span>] : leftSiblings;
    <span class="hljs-built_in">this</span>.rightSiblings = (rightSiblings == <span class="hljs-literal">null</span>) ? 
      <span class="hljs-keyword">new</span> <span class="hljs-title">Zippable</span>[<span class="hljs-number">0</span>] : rightSiblings;
  }
  <span class="hljs-comment">// getters omitted for brevity</span>
}
</code></pre>
    <p class="normal"><code class="inlineCode">ZipperRange</code> works in tandem <a id="_idIndexMarker647"/>with <code class="inlineCode">Cursor</code>, which contains the implementation of the Zipper actions (<code class="inlineCode">down()</code>, <code class="inlineCode">up()</code>, <code class="inlineCode">left()</code>, <code class="inlineCode">right()</code>, <code class="inlineCode">rightMost()</code>, <code class="inlineCode">leftMost()</code>, <code class="inlineCode">clear()</code>, <code class="inlineCode">add()</code>, <code class="inlineCode">addAll()</code>, <code class="inlineCode">insertLeft()</code>, <code class="inlineCode">insertRight()</code>, <code class="inlineCode">remove()</code>, <code class="inlineCode">removeLeft()</code>, <code class="inlineCode">removeRight()</code>, and so on):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cursor</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZipNode&lt;T&gt; zipNode;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ZipperRange range;
  <span class="hljs-keyword">protected</span> <span class="hljs-title">Cursor</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> ZipNode&lt;T&gt; zipNode, </span>
<span class="hljs-params">                   </span><span class="hljs-keyword">final</span><span class="hljs-params"> ZipperRange range)</span> {
    <span class="hljs-built_in">this</span>.zipNode = zipNode;
    <span class="hljs-built_in">this</span>.range = range;
  }
  ...
}
</code></pre>
    <p class="normal">Since this code is significantly large, the remainder was skipped here. You can find it in the bundled code.</p>
    <p class="normal">Finally, we have the <code class="inlineCode">Zipper</code> class. This class is used for creating a Zipper via the <code class="inlineCode">createZipper()</code> method. It is also used for recreating/updating the tree based on the modifications done via the Zipper. This is done in the <code class="inlineCode">unwrapZipper()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Zipper</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt;
        Cursor&lt;T&gt; <span class="hljs-title">createZipper</span><span class="hljs-params">(</span><span class="hljs-keyword">final</span><span class="hljs-params"> T node)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Cursor</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title">ZipNode</span>&lt;&gt;(node),
      <span class="hljs-keyword">new</span> <span class="hljs-title">ZipperRange</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)); <span class="hljs-comment">// root range</span>
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; T <span class="hljs-title">unwrapZipper</span><span class="hljs-params">(</span>
<span class="hljs-params">        </span><span class="hljs-keyword">final</span><span class="hljs-params"> Cursor&lt;T&gt; tree)</span> {
    <span class="hljs-keyword">return</span> Zipper.&lt;T&gt;unwrapZipper(tree.root().zipNode());
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Zippable</span>&gt; T <span class="hljs-title">unwrapZipper</span><span class="hljs-params">(</span>
<span class="hljs-params">        </span><span class="hljs-keyword">final</span><span class="hljs-params"> Zippable node)</span> {
    <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> ZipNode&lt;?&gt;) {
      ZipNode&lt;T&gt; zipNode = (ZipNode&lt;T&gt;) node;
      <span class="hljs-type">T</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> zipNode.unwrap();
      <span class="hljs-keyword">if</span> (!zipNode.isLeaf()) {
        Collection&lt;T&gt; children 
          = (Collection&lt;T&gt;) original.getChildren();
        original.getChildren().clear();
        <span class="hljs-keyword">for</span> (Zippable zipped : zipNode.children()) {
          children.add((T) unwrapZipper(zipped));
        }
      }
    <span class="hljs-keyword">return</span> original;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> (T) node;
    }
  }
}
</code></pre>
    <p class="normal">In the bundled code, you can<a id="_idIndexMarker648"/> find the complete implementation and an example of using the Zipper on a given tree.</p>
    <h1 id="_idParaDest-268" class="heading-1">123. Introducing the Binomial Heap data structure</h1>
    <p class="normal">A Binomial Heap data structure is a set<a id="_idIndexMarker649"/> composed of Binomial Trees. Each Binomial Tree is a Min Heap, which means that it follows the <em class="italic">min-heap</em> property. In a nutshell, a heap is a Min Heap if its items are in descending order, meaning that the minimum item is the root (more details are available in <em class="italic">The Complete Coding Interview Guide in Java</em> book).</p>
    <p class="normal">In a nutshell, a Binomial Tree is ordered and typically defined in a recursive fashion. It is denoted as B<sub class="subscript">k</sub>, where k implies the following properties:</p>
    <ul>
      <li class="bulletList">A Binomial Tree has 2<sup class="superscript">k</sup> nodes.</li>
      <li class="bulletList">The height of a Binomial Tree is equal to k.</li>
      <li class="bulletList">The root of a Binomial Tree has the degree k, which is the greatest degree.</li>
    </ul>
    <p class="normal">A B<sub class="subscript">0</sub> Binomial Tree has a single node. A B<sub class="subscript">1</sub> Binomial Tree has two B<sub class="subscript">0</sub> Trees, and one of them is a left subtree of the other one. A B<sub class="subscript">2</sub> Tree has two B<sub class="subscript">1</sub>, one of which is the left subtree of the other. In general, a B<sub class="subscript">k</sub> Binomial Tree contains two B<sub class="subscript">k-1</sub> Binomial Trees, one of which is the left subtree of the other (two B<sub class="subscript">k-1</sub> Trees are linked to the composed B<sub class="subscript">k</sub>). In the following figure, you can see B<sub class="subscript">0</sub>, B<sub class="subscript">1</sub>, B<sub class="subscript">2</sub>, B<sub class="subscript">3</sub>, and B<sub class="subscript">4</sub>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_28.png" alt="Figure 5.27.png"/></figure>
    <p class="packt_figref">Figure 5.28: B<sub class="subscript">0</sub>-B<sub class="subscript">4</sub> Binomial Trees</p>
    <p class="normal">The goals of a Binomial Heap from a Big O perspective are listed in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_29.png" alt="Figure 5.28.png"/></figure>
    <p class="packt_figref">Figure 5.29: Big O for Binomial Heap</p>
    <p class="normal">In the following figure, you can see <a id="_idIndexMarker650"/>a sample of a Binomial Heap. The roots of the Binomial Trees (here, 9, 1, and 7) within a Binomial Heap are represented via a<a id="_idIndexMarker651"/> linked list referred to as the <em class="italic">root list</em>.</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_30.png" alt="Figure 5.27.png"/></figure>
    <p class="packt_figref">Figure 5.30: Binomial Heap sample</p>
    <p class="normal">In other words, as you can easily intuit from this figure, a Binomial Heap is an extension (or a flavor) of a Binary Heap, which provides high performance for merging or unioning two heaps and is a perfect fit for the task of implementing priority queues.</p>
    <p class="normal">Based on this figure, we can define the skeleton of a Binomial Heap as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BinomialHeap</span> {
  <span class="hljs-keyword">private</span> Node head;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> key;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> degree;
    <span class="hljs-keyword">private</span> Node parent;
    <span class="hljs-keyword">private</span> Node child;
    <span class="hljs-keyword">private</span> Node sibling;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> {
      key = Integer.MIN_VALUE;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> key)</span> {
      <span class="hljs-built_in">this</span>.key = key;
    }
    ...
  }
  ...
}
</code></pre>
    <p class="normal">If we represent the<a id="_idIndexMarker652"/> relevant part of a <code class="inlineCode">Node</code> as a diagram, we obtain the following figure (here, you can see the internal structure of a <code class="inlineCode">Node</code> for items 11 and 25):</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_31.png" alt="Figure 5.30.png"/></figure>
    <p class="packt_figref">Figure 5.31: Expanding a Node</p>
    <p class="normal">Now that we have the main structure of a Binomial Heap, let’s cover several operations.</p>
    <h2 id="_idParaDest-269" class="heading-2">Implementing insert(int key)</h2>
    <p class="normal">Inserting a new key into a Binomial Heap is a two-step operation. In the first step, we create a new heap containing <a id="_idIndexMarker653"/>only the given key (a <code class="inlineCode">Node</code> wrapping the given key). Second, we union the current heap with this newly created heap as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> key)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(key);
  <span class="hljs-type">BinomialHeap</span> <span class="hljs-variable">newHeap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BinomialHeap</span>(node);
  head = unionHeap(newHeap);
}
</code></pre>
    <p class="normal">The union operation is depicted as the last operation of this problem.</p>
    <h2 id="_idParaDest-270" class="heading-2">Implementing findMin()</h2>
    <p class="normal">Finding the minimum key of<a id="_idIndexMarker654"/> a Binomial Heap requires us to loop through the <em class="italic">root list </em>(which is a linked list) and find the smallest key. This can be optimized from <em class="italic">O(log n)</em> to <em class="italic">O(1)</em> if we decide to maintain a pointer to the minimum root. However, the <em class="italic">O(log n)</em> approach is listed here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> Integer.MIN_VALUE;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Node</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> head;
    <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> min.sibling;
    <span class="hljs-keyword">while</span> (nextNode != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (nextNode.key &lt; min.key) {
        min = nextNode;
      }
      nextNode = nextNode.sibling;
    }
    <span class="hljs-keyword">return</span> min.key;
  }
}
</code></pre>
    <p class="normal">Since our Binomial Heap holds primitive integers, we use <code class="inlineCode">Integer.MIN_VALUE</code> as an equivalent to “no value.” If you <a id="_idIndexMarker655"/>adjust the implementation to use <code class="inlineCode">Integer</code> or generic <code class="inlineCode">T</code>, then you can replace <code class="inlineCode">Integer.MIN_VALUE</code> with <code class="inlineCode">null</code>.</p>
    <h2 id="_idParaDest-271" class="heading-2">Implementing extractMin()</h2>
    <p class="normal">Before extracting the minimum key, we have to find it. Afterward, we delete it. Finally, we have to union the resulting <a id="_idIndexMarker656"/>subtrees as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">extractMin</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> Integer.MIN_VALUE;
  }
  <span class="hljs-type">Node</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> head;
  <span class="hljs-type">Node</span> <span class="hljs-variable">minPrev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
  <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> min.sibling;
  <span class="hljs-type">Node</span> <span class="hljs-variable">nextNodePrev</span> <span class="hljs-operator">=</span> min;
  <span class="hljs-keyword">while</span> (nextNode != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (nextNode.key &lt; min.key) {
      min = nextNode;
      minPrev = nextNodePrev;
    }
    nextNodePrev = nextNode;
    nextNode = nextNode.sibling;
  }
  deleteTreeRoot(min, minPrev);
  <span class="hljs-keyword">return</span> min.key;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">deleteTreeRoot()</code> is a helper method useful for deleting the given root and performing a union on the remaining sub-trees:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteTreeRoot</span><span class="hljs-params">(Node root, Node previousNode)</span> {
  <span class="hljs-keyword">if</span> (root == head) {
    head = root.sibling;
  } <span class="hljs-keyword">else</span> {
    previousNode.sibling = root.sibling;
  }
  <span class="hljs-type">Node</span> <span class="hljs-variable">unionHeap</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
  <span class="hljs-type">Node</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> root.child;
  <span class="hljs-keyword">while</span> (child != <span class="hljs-literal">null</span>) {
    <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> child.sibling;
    child.sibling = unionHeap;
    child.parent = <span class="hljs-literal">null</span>;
    unionHeap = child;
    child = nextNode;
  }
<span class="hljs-type">BinomialHeap</span> <span class="hljs-variable">toUnionHeap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BinomialHeap</span>(unionHeap);
  head = unionHeap(toUnionHeap);
}
</code></pre>
    <h2 id="_idParaDest-272" class="heading-2">Implementing decreaseKey(int key, int newKey)</h2>
    <p class="normal">Decreasing a key value means replacing an existing key with a smaller one. When this operation happens, the new key <a id="_idIndexMarker657"/>may be smaller than the key of its parent, which means that the <em class="italic">min-heap</em> property is violated. This scenario requires us to swap the current node with its parent, its parent with its grandparent, and so on until we reestablish compliance with the <em class="italic">min-heap</em> property. The implementation starts as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> key, </span><span class="hljs-type">int</span><span class="hljs-params"> newKey)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">found</span>  <span class="hljs-operator">= </span>findByKey(key);
  <span class="hljs-keyword">if</span> (found != <span class="hljs-literal">null</span>) {
    decreaseKey(found, newKey);
  }
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decreaseKey</span><span class="hljs-params">(Node node, </span><span class="hljs-type">int</span><span class="hljs-params"> newKey)</span> {
  node.key = newKey;
  goUp(node, <span class="hljs-literal">false</span>);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">goUp()</code> method is a helper method used to reestablish the <em class="italic">min-heap</em> property:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> Node <span class="hljs-title">goUp</span><span class="hljs-params">(Node node, boolean goToRoot)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> node.parent;
  <span class="hljs-keyword">while</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; (goToRoot
      || node.key &lt; parent.key)) {
    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> node.key;
    node.key = parent.key;
    parent.key = t;
    node = parent;
    parent = parent.parent;
  }
  <span class="hljs-keyword">return</span> node;
}
</code></pre>
    <p class="normal">As you will see next, this<a id="_idIndexMarker658"/> helper is useful for deleting a node as well.</p>
    <h2 id="_idParaDest-273" class="heading-2">Implementing delete(int key)</h2>
    <p class="normal">Deleting a key is done by first finding <a id="_idIndexMarker659"/>the corresponding <code class="inlineCode">Node</code> and decreasing it to the minimum (<code class="inlineCode">Integer.MIN_VALUE</code>). Next, we delete the minimum from the heap and connect the remaining sub-trees. The implementation relies on the <code class="inlineCode">goUp()</code> and <code class="inlineCode">deleteTreeRoot()</code> helpers listed in the previous sections:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> key)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> findByKey(key);
  <span class="hljs-keyword">if</span> (found != <span class="hljs-literal">null</span>) {
    delete(found);
  }
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(Node node)</span> {
  node = goUp(node, <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">if</span> (head == node) {
    deleteTreeRoot(node, <span class="hljs-literal">null</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Node</span> <span class="hljs-variable">previousNode</span> <span class="hljs-operator">=</span> head;
    <span class="hljs-keyword">while</span> (previousNode.sibling.key != node.key) {
      previousNode = previousNode.sibling;
    }
    deleteTreeRoot(node, previousNode);
  }
}
</code></pre>
    <p class="normal">Finally, let’s talk about <a id="_idIndexMarker660"/>union heaps.</p>
    <h2 id="_idParaDest-274" class="heading-2">Implementing unionHeap(BinomialHeap heap)</h2>
    <p class="normal">Consider two Binomial Heaps (H1 and H2). The goal of the union operation is to create H3 by unifying H1 with <a id="_idIndexMarker661"/>H2. Let’s assume that H1 (having a conventional string representation used by our application as 31 22 [ 40 ] 8 [ 13 [ 24 ] 11 ]) and H2 (55 24 [ 45 ] 3 [ 7 [ 29 [ 40 ] 9 ] 5 [ 37 ] 18 ]) are those from the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_32.png" alt="Figure 5.31.png"/></figure>
    <p class="packt_figref">Figure 5.32: Two Binomial Heaps, H1 and H2</p>
    <p class="normal">The contract of unification starts with an initial merging of H1 and H2 in the order of their degrees. In our case, the merge operation produces the following output:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_33.png" alt="Figure 5.32.png"/></figure>
    <p class="packt_figref">Figure 5.33: Merging H1 and H2</p>
    <p class="normal">This operation is performed<a id="_idIndexMarker662"/> by the following helper method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> Node <span class="hljs-title">merge</span><span class="hljs-params">(BinomialHeap h1, BinomialHeap h2)</span> {
  <span class="hljs-keyword">if</span> (h1.head == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> h2.head;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (h2.head == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> h1.head;
  } <span class="hljs-keyword">else</span> {
    Node headIt;
    <span class="hljs-type">Node</span> <span class="hljs-variable">h1Next</span> <span class="hljs-operator">=</span> h1.head;
    <span class="hljs-type">Node</span> <span class="hljs-variable">h2Next</span> <span class="hljs-operator">=</span> h2.head;
    <span class="hljs-keyword">if</span> (h1.head.degree &lt;= h2.head.degree) {
      headIt = h1.head;
      h1Next = h1Next.sibling;
    } <span class="hljs-keyword">else</span> {
      headIt = h2.head;
      h2Next = h2Next.sibling;
    }
    <span class="hljs-type">Node</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> headIt;
    <span class="hljs-keyword">while</span> (h1Next != <span class="hljs-literal">null</span> &amp;&amp; h2Next != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (h1Next.degree &lt;= h2Next.degree) {
        tail.sibling = h1Next;
        h1Next = h1Next.sibling;
      } <span class="hljs-keyword">else</span> {
        tail.sibling = h2Next;
        h2Next = h2Next.sibling;
      }
      tail = tail.sibling;
    }
    <span class="hljs-keyword">if</span> (h1Next != <span class="hljs-literal">null</span>) {
      tail.sibling = h1Next;
    } <span class="hljs-keyword">else</span> {
      tail.sibling = h2Next;
    }
    <span class="hljs-keyword">return</span> headIt;
  }
}
</code></pre>
    <p class="normal">Next, we need to<a id="_idIndexMarker663"/> combine the Binomial Trees of the same order. While we traverse the roots of the merged heaps (here, 31, 55, 22, 24, 8, and 3), we use three pointers denoted as PREV-X (the previous node of the current node), X (the current node), and NEXT-X (the next node of the current node). These pointers help us to solve the following four cases:</p>
    <ul>
      <li class="bulletList"><em class="italic">Case 1</em>: X and NEXT-X have different orders. In this case, we just move the X pointer ahead.</li>
      <li class="bulletList"><em class="italic">Case 2</em>: X, NEXT-X, and NEXT-NEXT-X have the same order. In this case, we just move the X pointer ahead.</li>
      <li class="bulletList"><em class="italic">Case 3</em>: X and NEXT-X have the same order, different from NEXT-NEXT-X. And if X.KEY&lt;= NEXT-X.KEY, then NEXT-X becomes the child of X.</li>
      <li class="bulletList"><em class="italic">Case 4</em>: X and NEXT-X have the same order, different from NEXT-NEXT-X. And if X.KEY&gt;NEXT-X.KEY, then X becomes the child of NEXT-X.</li>
    </ul>
    <p class="normal">If we apply these four cases to our example, we notice that after merging H1 and H2, we are in <em class="italic">Case 3</em> since X and NEXT-X have the same order (B<sub class="subscript">0</sub>), which is different from the order of NEXT-NEXT-X (which is B<sub class="subscript">1</sub>) and X.KEY = 31 &lt; 55 = NEXT-X.KEY. So, NEXT-X becomes the child of X, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_34.png" alt="Figure 5.33.png"/></figure>
    <p class="packt_figref">Figure 5.34: Applying Case 3</p>
    <p class="normal">Going further, we notice that X, NEXT-X, and NEXT-NEXT-X have the same order B<sub class="subscript">1</sub>. This means that we are in <em class="italic">Case 2</em>, so we have to<a id="_idIndexMarker664"/> move the X pointer forward, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_35.png" alt="Figure 5.34.png"/></figure>
    <p class="packt_figref">Figure 5.35: Applying Case 2</p>
    <p class="normal">Next, we are in <em class="italic">Case 3</em> again. We see that X and NEXT-X have the same order (B<sub class="subscript">1</sub>), which is different from the order of<a id="_idIndexMarker665"/> NEXT-NEXT-X (B<sub class="subscript">2</sub>). And, we also see that X.KEY = 22 &lt; 24 = NEXT-X.KEY, so NEXT-X becomes the child of X, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_36.png" alt="Figure 5.35.png"/></figure>
    <p class="packt_figref">Figure 5.36: Applying Case 3 again</p>
    <p class="normal">Next, we are in <em class="italic">Case 4</em>. We see that X and NEXT-X have the same order (B<sub class="subscript">2</sub>) which is different from the order of NEXT-NEXT-X (B<sub class="subscript">3</sub>). And, we also see that X.KEY = 22 &gt; 8 = NEXT-X.KEY, so X becomes the child of NEXT-X, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_37.png" alt="Figure 5.36.png"/></figure>
    <p class="packt_figref">Figure 5.37: Applying Case 4</p>
    <p class="normal">Next, we are in <em class="italic">Case 4</em> again. We see that X and NEXT-X have the same order (B<sub class="subscript">3</sub>), which is different from the order <a id="_idIndexMarker666"/>of NEXT-NEXT-X (null). And, we also see that X.KEY = 8 &gt; 3 = NEXT-X.KEY, so X becomes the child of NEXT-X, as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_38.png" alt="Figure 5.37.png"/></figure>
    <p class="packt_figref">Figure 5.38: Applying Case 4 again</p>
    <p class="normal">At this point, none of the four cases is valid so this is the final form of the Binomial Heap.</p>
    <p class="normal">Based on this example, we<a id="_idIndexMarker667"/> can implement the union operation as follows (notice the highlighted cases in the following code):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> Node <span class="hljs-title">unionHeap</span><span class="hljs-params">(BinomialHeap heap)</span> {
  <span class="hljs-type">Node</span> <span class="hljs-variable">mergeHeap</span> <span class="hljs-operator">=</span> merge(<span class="hljs-built_in">this</span>, heap); 
  head = <span class="hljs-literal">null</span>;
  heap.head = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">if</span> (mergeHeap == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-type">Node</span> <span class="hljs-variable">previousNode</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
  <span class="hljs-type">Node</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> mergeHeap;
  <span class="hljs-type">Node</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> mergeHeap.sibling;
  <span class="hljs-keyword">while</span> (nextNode != <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">if</span> (currentNode.degree != nextNode.degree
        || (nextNode.sibling != <span class="hljs-literal">null</span>
        &amp;&amp; nextNode.sibling.degree == currentNode.degree)) {
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">,</strong><strong class="hljs-number-slc">2</strong><strong class="hljs-slc">]</strong></span> previousNode = currentNode;
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">1</strong><strong class="hljs-slc">,</strong><strong class="hljs-number-slc">2</strong><strong class="hljs-slc">]</strong></span> currentNode = nextNode;
     } <span class="hljs-keyword">else</span> {
       <span class="hljs-keyword">if</span> (currentNode.key &lt; nextNode.key) {
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">]</strong></span>    currentNode.sibling = nextNode.sibling;
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">3</strong><strong class="hljs-slc">]</strong></span>    linkNodes(currentNode, nextNode);
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>  } <span class="hljs-keyword">else</span> {
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>    <span class="hljs-keyword">if</span> (previousNode == <span class="hljs-literal">null</span>) {
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>      mergeHeap = nextNode;
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>    } <span class="hljs-keyword">else</span> {
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>      previousNode.sibling = nextNode;
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>   }
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>     linkNodes(nextNode, currentNode);
<span class="code-highlight"><strong class="hljs-slc">[C:</strong><strong class="hljs-number-slc">4</strong><strong class="hljs-slc">]</strong></span>     currentNode = nextNode;
       }
    }
    nextNode = currentNode.sibling;
  }
  <span class="hljs-keyword">return</span> mergeHeap;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">linkNodes()</code> method is a <a id="_idIndexMarker668"/>helper method that links the current node with the next node:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">linkNodes</span><span class="hljs-params">(Node minNodeTree, Node other)</span> {
  other.parent = minNodeTree;
  other.sibling = minNodeTree.child;
  minNodeTree.child = other;
  minNodeTree.degree++;
}
</code></pre>
    <p class="normal">Done! You can find the complete application in the bundled code.</p>
    <h1 id="_idParaDest-275" class="heading-1">124. Introducing the Fibonacci Heap data structure</h1>
    <p class="normal">A Fibonacci Heap is a flavor of Binomial Heap with excellent performance in <em class="italic">amortized time</em> for operations such as insert, extract <a id="_idIndexMarker669"/>minimum, and merge. It is an optimal choice for implementing priority queues. A Fibonacci Heap is made of trees, and each tree has a single root and multiple children arranged in a heap-ordered fashion. The root node with the smallest key is always placed at the beginning of the list of trees.</p>
    <p class="normal">It is called a Fibonacci Heap because<a id="_idIndexMarker670"/> each tree of order <em class="italic">k</em> has at least F<sub class="subscript">k+2</sub> nodes, where F<sub class="subscript">k+2</sub> is the (<em class="italic">k</em>+2)<sup class="superscript">th</sup> Fibonacci number.</p>
    <p class="normal">In the following figure, you can see a Fibonacci Heap sample:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_39.png" alt="Figure 5.39.png"/></figure>
    <p class="packt_figref">Figure 5.39: Fibonacci Heap sample</p>
    <p class="normal">The main operations in a Fibonacci Heap are (Big O represents the <em class="italic">amortized time</em>): insert (O(1)), decrease key (O(1)), find the minimum (O(1)), extract minimum (O(log n)), deletion (O(log n)), and merge (O(1)). You can find an implementation of these operations in the bundled code.</p>
    <h1 id="_idParaDest-276" class="heading-1">125. Introducing the Pairing Heap data structure</h1>
    <p class="normal">The Pairing Heap is a flavor of Binomial Heap<a id="_idIndexMarker671"/> with the capability of self-adjusting/rearranging to keep itself balanced. It has very good performance in <em class="italic">amortized time</em> and is a good fit for the task of implementing priority queues.</p>
    <p class="normal">A Pairing Heap is a pairing tree with a root and children. Each heap of a Pairing Heap represents a value and has a set of children that are also heaps. The value of a heap is always less than (<em class="italic">min-heap</em> property) or greater than (<em class="italic">max-heap</em> property) the value of its children heaps. </p>
    <p class="normal">In the following figure, you can see a Min Pairing Heap:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_40.png" alt="Figure 5.38.png"/></figure>
    <p class="packt_figref">Figure 5.40: A Min Pairing Heap sample</p>
    <p class="normal">The main operations in a Pairing Heap are: insert (O(1)), decrease key (actual time: O(1), amortized time O(log n)), find the minimum (O(1)), extract the minimum (actual time: O(n), amortized time (O (log n)), and merge (actual time: O(1), amortized time (O(log n)). You can find an <a id="_idIndexMarker672"/>implementation of these operations in the bundled code.</p>
    <h1 id="_idParaDest-277" class="heading-1">126. Introducing the Huffman Coding data structure</h1>
    <p class="normal">The Huffman Coding algorithm<a id="_idIndexMarker673"/> was developed by David A. Huffman in 1950 and can easily be understood via an example. Let’s assume that we have the string shown in the following figure.</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_41.png" alt="Figure 5.40.png"/></figure>
    <p class="packt_figref">Figure 5.41: Initial string</p>
    <p class="normal">Let’s assume that each character needs 8 bits to be represented. Since we have 14 characters, we can say that we need 8*14=112 bits to send this string over a network.</p>
    <h2 id="_idParaDest-278" class="heading-2">Encoding the string</h2>
    <p class="normal">The idea of Huffman Coding is to <a id="_idIndexMarker674"/>compress (shrink) such strings to a smaller size. For this, we create a tree of character frequencies. A <code class="inlineCode">Node</code> of this tree can be shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span> {
  <span class="hljs-keyword">private</span> Node root;
  <span class="hljs-keyword">private</span> String str;
  <span class="hljs-keyword">private</span> StringBuilder encodedStr;
  <span class="hljs-keyword">private</span> StringBuilder decodedStr;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {
    <span class="hljs-keyword">private</span> Node left;
    <span class="hljs-keyword">private</span> Node right;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Character character;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer frequency;
    <span class="hljs-comment">//  constructors</span>
  }
  ...
}
</code></pre>
    <p class="normal">For instance, the following figure shows the calculation of the frequency of each character from our string in ascending order:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_42.png" alt="Figure 5.41.png"/></figure>
    <p class="packt_figref">Figure 5.42: Calculating the frequency of each character</p>
    <p class="normal">After sorting, these characters are<a id="_idIndexMarker675"/> stored in a <strong class="keyWord">priority queue</strong> (<strong class="keyWord">PQ</strong>). Each character will become a leaf node in a tree by<a id="_idIndexMarker676"/> following several steps:</p>
    <ul>
      <li class="bulletList"><em class="italic">Step 1</em>: Create a node with two children (a partial tree). The left child holds the minimum frequency, and the right child holds the next minimum frequency. The node itself holds the sum of its left and right children.</li>
      <li class="bulletList"><em class="italic">Step 2</em>: Remove these two frequencies from the PQ.</li>
      <li class="bulletList"><em class="italic">Step 3</em>: Insert this partial <a id="_idIndexMarker677"/>tree into the PQ.</li>
      <li class="bulletList"><em class="italic">Step 4</em>: Repeat steps 1-3 until the PQ is empty and we obtain a single tree from these partial trees.</li>
    </ul>
    <p class="normal">If we apply <em class="italic">steps 1-3 </em>twice, we obtain the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_43.png" alt="Figure 5.42.png"/></figure>
    <p class="packt_figref">Figure 5.43: Applying steps 1-3 twice</p>
    <p class="normal">In code form, these steps appear as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tree</span><span class="hljs-params">(String str)</span> {
  <span class="hljs-built_in">this</span>.str = str;
  <span class="hljs-built_in">this</span>.root = <span class="hljs-literal">null</span>;
  <span class="hljs-built_in">this</span>.encodedStr = <span class="hljs-literal">null</span>;
  <span class="hljs-built_in">this</span>.decodedStr = <span class="hljs-literal">null</span>;
  Map&lt;Character, Integer&gt; frequency = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> character : str.toCharArray()) {
    frequency.put(character, 
           frequency.getOrDefault(character, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
  }
  PriorityQueue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title">PriorityQueue</span>&lt;&gt;(
    Comparator.comparingInt(ch -&gt; ch.frequency));
  <span class="hljs-keyword">for</span> (Entry&lt;Character, Integer&gt; entry : frequency.entrySet()) {
    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(entry.getKey(), entry.getValue()));
  }
  <span class="hljs-keyword">while</span> (queue.size() != <span class="hljs-number">1</span>) {
    <span class="hljs-type">Node</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> queue.poll();
    <span class="hljs-type">Node</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> queue.poll();
    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> left.frequency + right.frequency;
    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(<span class="hljs-literal">null</span>, sum, left, right)); 
  }
  <span class="hljs-built_in">this</span>.root = queue.peek();
}
</code></pre>
    <p class="normal">By repeating these steps until the PQ is empty, we obtain the final tree. Next, for each node of this tree that is not a<a id="_idIndexMarker678"/> leaf, we assign the value 0 to the left edge and 1 to the right edge. This is the encoding step that can be coded as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">encode</span><span class="hljs-params">()</span> {
  Map&lt;Character, String&gt; codes = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  encode(<span class="hljs-built_in">this</span>.root, <span class="hljs-string">""</span>, codes);
  <span class="hljs-built_in">this</span>.encodedStr = <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> character : <span class="hljs-built_in">this</span>.str.toCharArray()) {
    <span class="hljs-built_in">this</span>.encodedStr.append(codes.get(character));
  }
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.encodedStr.toString();
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node root, String str, </span>
<span class="hljs-params">                    Map&lt;Character, String&gt; codes)</span> {
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">if</span> (isLeaf(root)) {
    codes.put(root.character, str.length() &gt; <span class="hljs-number">0</span> ? str : <span class="hljs-string">"1"</span>);
  }
  encode(root.left, str + <span class="hljs-string">'0'</span>, codes);
  encode(root.right, str + <span class="hljs-string">'1'</span>, codes);
}
</code></pre>
    <p class="normal">The final result looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_44.png" alt="Figure 5.43.png"/></figure>
    <p class="packt_figref">Figure 5.44: The final tree</p>
    <p class="normal">Now, sending this tree<a id="_idIndexMarker679"/> over the network will send the compressed string. The next figure gives us the new size of this string:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_45.png" alt="Figure 5.44.png"/></figure>
    <p class="packt_figref">Figure 5.45: The size of the compressed string</p>
    <p class="normal">So, we reduce the size of the string from 112 bits to 41 bits. This is the compressed or encoded<a id="_idIndexMarker680"/> string.</p>
    <h2 id="_idParaDest-279" class="heading-2">Decoding the string</h2>
    <p class="normal">Decoding the string is a simple step. We<a id="_idIndexMarker681"/> take each code and traverse the tree to find the assigned character. For instance, we take <em class="italic">0111</em> and we find <em class="italic">d</em>, we take <em class="italic">110</em> and we find <em class="italic">a</em>, and so on. Decoding can be implemented as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> String <span class="hljs-title">decode</span><span class="hljs-params">()</span> {
<span class="hljs-built_in">  this</span>.decodedStr = <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
  <span class="hljs-keyword">if</span> (isLeaf(<span class="hljs-built_in">this</span>.root)) { 
    <span class="hljs-type">int</span> <span class="hljs-variable">copyFrequency</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.root.frequency;
    <span class="hljs-keyword">while</span> (copyFrequency-- &gt; <span class="hljs-number">0</span>) {
      decodedStr.append(root.character);
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (index &lt; <span class="hljs-built_in">this</span>.encodedStr.length() - <span class="hljs-number">1</span>) {
      index = decode(<span class="hljs-built_in">this</span>.root, index);
    }
  }
  <span class="hljs-keyword">return</span> decodedStr.toString();
}
<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node root, </span><span class="hljs-type">int</span><span class="hljs-params"> index)</span> {
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> index;
  }
  <span class="hljs-keyword">if</span> (isLeaf(root)) {
    decodedStr.append(root.character);
    <span class="hljs-keyword">return</span> index;
  }
  index++;
  root = (<span class="hljs-built_in">this</span>.encodedStr.charAt(index) == <span class="hljs-string">'0'</span>) 
    ? root.left : root.right;
  index = decode(root, index);
  <span class="hljs-keyword">return</span> index;
}
<span class="hljs-keyword">private</span> <span class="hljs-title">booleanisLeaf</span><span class="hljs-params">(Node root)</span> {
  <span class="hljs-keyword">return</span> root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>;
}
</code></pre>
    <p class="normal">After processing all of the<a id="_idIndexMarker682"/> code, we should obtain the decoded string.</p>
    <h1 id="_idParaDest-280" class="heading-1">127. Introducing the Splay Tree data structure</h1>
    <p class="normal">A Splay Tree is a flavor of <strong class="keyWord">Binary Search Tree</strong> (<strong class="keyWord">BST</strong>). Its particularity consists of the fact that it is a self-balancing tree that <a id="_idIndexMarker683"/>places the recently accessed items at the root level.</p>
    <p class="normal">The <em class="italic">splaying</em> operation or <em class="italic">splaying</em> an item is a<a id="_idIndexMarker684"/> process that relies on tree rotations meant to bring the item to the root position. Every operation on the tree is followed by <em class="italic">splaying</em>.</p>
    <p class="normal">So, the goal of <em class="italic">splaying</em> is to bring the most recently used item closer to the root. This means that subsequent operations on these items will be performed faster.</p>
    <p class="normal">The <em class="italic">splaying</em> operation relies on six rotations:</p>
    <ul>
      <li class="bulletList">Zig rotation – the tree rotates to the right (every node rotates to the right)</li>
      <li class="bulletList">Zag rotation – the tree rotates to the left (every node rotates to the left)</li>
      <li class="bulletList">Zig-Zig rotation – double Zig rotation (every node moves twice to the right)</li>
      <li class="bulletList">Zag-Zag rotation – double Zag rotation (every node moves twice to the left)</li>
      <li class="bulletList">Zig-Zag rotation – a Zig rotation followed by a Zag</li>
      <li class="bulletList">Zag-Zig rotation – a Zag rotation followed by a Zig</li>
    </ul>
    <p class="normal">In the bundled code, you can find an implementation of a Splay Tree. Moreover, you can use this visualizer: <a href="https://www.cs.usfca.edu/~galles/visualization/SplayTree.html"><span class="url">https://www.cs.usfca.edu/~galles/visualization/SplayTree.html</span></a>.</p>
    <h1 id="_idParaDest-281" class="heading-1">128. Introducing the Interval Tree data structure</h1>
    <p class="normal">An Interval Tree is a flavor of <strong class="keyWord">Binary Search Tree</strong> (<strong class="keyWord">BST</strong>). Its <a id="_idIndexMarker685"/>particularity consists of the fact that it holds intervals of values. Beside the interval itself, a <code class="inlineCode">Node</code> of an Interval Tree holds the maximum value of the current<a id="_idIndexMarker686"/> interval and the maximum value of the subtree rooted with this <code class="inlineCode">Node</code>.</p>
    <p class="normal">In code form, an Interval Tree is shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntervalTree</span> {
  <span class="hljs-keyword">private</span> Node root;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Interval</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> min, max;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Interval</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> min, </span><span class="hljs-type">int</span><span class="hljs-params"> max)</span> {
      <span class="hljs-built_in">this</span>.min = min;
      <span class="hljs-built_in">this</span>.max = max;
    }
    ...
  }
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Interval interval;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer maxInterval;
    <span class="hljs-keyword">private</span> Node left;
    <span class="hljs-keyword">private</span> Node right;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSubstree;
    Node(Interval interval, Integer maxInterval) {
      <span class="hljs-built_in">this</span>.interval = interval;
      <span class="hljs-built_in">this</span>.maxInterval = maxInterval;
      <span class="hljs-built_in">this</span>.size = <span class="hljs-number">1</span>;
      <span class="hljs-built_in">this</span>.maxSubstree = interval.max;
    }
  }
...
}
</code></pre>
    <p class="normal">Let’s consider that we<a id="_idIndexMarker687"/> have the following intervals of integers: [4, 7], [1, 10], [7, 23], [6, 8], [9, 13], and [2, 24]. </p>
    <h2 id="_idParaDest-282" class="heading-2">Implementing insert(Interval interval)</h2>
    <p class="normal">The first interval ([4, 7]) becomes the <a id="_idIndexMarker688"/>root of the tree. Next, we compare the interval [1, 10] to [4, 7] by comparing the left side of the interval. Since 1 &lt; 4, the interval [1, 10] goes to the left of the root. </p>
    <p class="normal">Next, we compare the interval [7, 23] with [4, 7]. Since 7 &gt; 4, the interval [7, 23] goes to the right of [4, 7]. Applying the same logic for the rest of the interval will result in the following tree:</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_46.png" alt="Figure 5.45.png"/></figure>
    <p class="packt_figref">Figure 5.46: The interval tree</p>
    <p class="normal">The previous logic (insert operation, O(log n)) is materialized in code form as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Interval interval)</span> {
  root = insert(root, interval);
}
<span class="hljs-keyword">private</span> Node <span class="hljs-title">insert</span><span class="hljs-params">(Node root, Interval interval)</span> {
  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(interval, interval.max);
  }
  <span class="hljs-keyword">if</span> (interval.min &lt; root.interval.min) {
    root.left = insert(root.left, interval);
  } <span class="hljs-keyword">else</span> {
    root.right = insert(root.right, interval);
  }
  <span class="hljs-keyword">if</span> (root.maxSubstree &lt; interval.max) {
    root.maxSubstree = interval.max;
  }
  <span class="hljs-keyword">return</span> root;
}
</code></pre>
    <p class="normal">Other operations specific to<a id="_idIndexMarker689"/> an interval tree are searching the intervals that overlap the given interval (O(log n)) and deleting (O (log n)). You can find the implementations in the bundled code.</p>
    <h1 id="_idParaDest-283" class="heading-1">129. Introducing the Unrolled Linked List data structure</h1>
    <p class="normal">An Unrolled Linked List is a flavor of a linked list<a id="_idIndexMarker690"/> that stores arrays (multiple items). Each node of an Unrolled Linked List can store an array. It is like combining the powers of an array with those of a linked list. In other words, an Unrolled Linked List is a data structure with a low memory footprint and high performance on insertion and deletion.</p>
    <p class="normal">Insertion and deletion from an Unrolled Linked List have different implementations.</p>
    <p class="normal">For instance, we can insert arrays (<code class="inlineCode">insert(int[] arr)</code>), which means that for each insertion, we create a new node and insert that array into it.</p>
    <p class="normal">Deleting an item is equivalent to removing the item from the specified index in the proper array. If, after deletion, the array is empty, then it is removed from the list as well.</p>
    <p class="normal">Another approach assumes that the Unrolled Linked List has a fixed capacity (each node holds an array of this capacity). Further, we insert items one by one by following a low-water mark of 50%. This means that if we insert an item that cannot be added to the current node (array), then we create a new node and insert into it half of the original node’s items plus this item.</p>
    <p class="normal">Deleting an item uses the reverse logic. If the number of items in a node drops below 50%, then we move the items from the neighboring array over to get back to a low-water mark above 50%. If the neighboring array also drops below 50%, then we have to merge these two nodes.</p>
    <p class="normal">You can find both approaches in<a id="_idIndexMarker691"/> the bundled code. On the other hand, you can challenge yourself to provide an Unrolled Linked List implementation that extends the JVM Collections API. You can start from either of the following two approaches:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnrolledLinkedList</span>&lt;E&gt;
<span class="hljs-keyword">       extends</span> <span class="hljs-title">AbstractList</span>&lt;E&gt;
       <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;E&gt;, Serializable { ... }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnrolledLinkedList</span>&lt;E&gt;
       <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;E&gt;
       <span class="hljs-keyword">implements</span> <span class="hljs-title">Deque</span>&lt;E&gt;, Cloneable, Serializable { ... }
</code></pre>
    <p class="normal">Add this implementation to your GitHub portfolio and you’ll impress your interviewer.</p>
    <h1 id="_idParaDest-284" class="heading-1">130. Implementing join algorithms</h1>
    <p class="normal">Join algorithms are typically <a id="_idIndexMarker692"/>used in databases, mainly when we have two tables in a one-to-many relationship and we want to fetch a result set containing this mapping based on a join predicate. In the following figure, we have the <code class="inlineCode">author</code> and <code class="inlineCode">book</code> tables. An author can have multiple books and we want to join these tables to obtain a result set as the third table.</p>
    <figure class="mediaobject"><img src="../Images/B19665_05_47.png" alt="Figure 5.46.png"/></figure>
    <p class="packt_figref">Figure 5.47: Joining two tables (author and book)</p>
    <p class="normal">There are three popular join algorithms for solving this problem: Nested Loop Join, Hash Join, and Sort Merge Join. While databases are optimized to choose the most appropriate join for the<a id="_idIndexMarker693"/> given query, let’s try to implement them in plain Java on the following two tables expressed as records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Author</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> authorId, String name)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Book</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> bookId, String title, </span><span class="hljs-type">int</span><span class="hljs-params"> authorId)</span> {}
List&lt;Author&gt; authorsTable = Arrays.asList(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Author</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"Author_1"</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Author</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Author_2"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Author</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"Author_3"</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Author</span>(<span class="hljs-number">4</span>, <span class="hljs-string">"Author_4"</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Author</span>(<span class="hljs-number">5</span>, <span class="hljs-string">"Author_5"</span>));
List&lt;Book&gt; booksTable = Arrays.asList(
  <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">1</span>, <span class="hljs-string">"Book_1"</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">2</span>, <span class="hljs-string">"Book_2"</span>, <span class="hljs-number">1</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">3</span>, <span class="hljs-string">"Book_3"</span>, <span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">4</span>, <span class="hljs-string">"Book_4"</span>, <span class="hljs-number">3</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">5</span>, <span class="hljs-string">"Book_5"</span>, <span class="hljs-number">3</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">6</span>, <span class="hljs-string">"Book_6"</span>, <span class="hljs-number">3</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">7</span>, <span class="hljs-string">"Book_7"</span>, <span class="hljs-number">4</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">8</span>, <span class="hljs-string">"Book_8"</span>, <span class="hljs-number">5</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">Book</span>(<span class="hljs-number">9</span>, <span class="hljs-string">"Book_9"</span>, <span class="hljs-number">5</span>));
</code></pre>
    <p class="normal">Our goal is to join the <code class="inlineCode">Author</code> and <code class="inlineCode">Book</code> records by matching the <code class="inlineCode">Author.authorId</code> and <code class="inlineCode">Book.authorId</code> attributes. The result should be a projection (<code class="inlineCode">ResultRow</code>) that contains <code class="inlineCode">authorId</code>, <code class="inlineCode">name</code>, <code class="inlineCode">title</code>, and <code class="inlineCode">bookId</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">ResultRow</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> authorId, String name, </span>
<span class="hljs-params">                        String title, </span><span class="hljs-type">int</span><span class="hljs-params"> bookId)</span> {}
</code></pre>
    <p class="normal">Next, let’s talk about Nested Loop Join.</p>
    <h2 id="_idParaDest-285" class="heading-2">Nested Loop Join</h2>
    <p class="normal">The Nested Loop Join algorithm relies on two loops <a id="_idIndexMarker694"/>that traverse both relations to find records that match<a id="_idIndexMarker695"/> the joining predicate:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;ResultRow&gt; nestedLoopJoin(
    List&lt;Author&gt; authorsTable, List&lt;Book&gt; booksTable) {
  List&lt;ResultRow&gt; resultSet = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>();
  <span class="hljs-keyword">for</span> (Author author : authorsTable) {
    <span class="hljs-keyword">for</span> (Book book : booksTable) {
      <span class="hljs-keyword">if</span> (book.authorId() == author.authorId()) {
        resultSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title">ResultRow</span>(
        author.authorId(), author.name(), 
          book.title(), book.bookId()));
      }
    }
  }
  <span class="hljs-keyword">return</span> resultSet;
}
</code></pre>
    <p class="normal">The time complexity of this <a id="_idIndexMarker696"/>algorithm is O(n*m) where <em class="italic">n</em> is the size of <code class="inlineCode">authorsTable</code> and <em class="italic">m</em> is the size of <code class="inlineCode">booksTable</code>. This is quadratic <a id="_idIndexMarker697"/>complexity, which makes this algorithm useful only for small datasets.</p>
    <h2 id="_idParaDest-286" class="heading-2">Hash Join</h2>
    <p class="normal">As the name suggests, Hash Join relies on <em class="italic">hashing</em>. So, we have to create a hash table from the authors table (the table <a id="_idIndexMarker698"/>with fewer records) and afterward we<a id="_idIndexMarker699"/> loop through the books table to find their authors in the created hash table as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;ResultRow&gt; hashJoin(
   List&lt;Author&gt; authorsTable, List&lt;Book&gt; booksTable) {
  Map&lt;Integer, Author&gt; authorMap = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  <span class="hljs-keyword">for</span> (Author author : authorsTable) {
    authorMap.put(author.authorId(), author);
  }
  List&lt;ResultRow&gt; resultSet = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>();
  <span class="hljs-keyword">for</span> (Book book : booksTable) {
    <span class="hljs-type">Integer</span> <span class="hljs-variable">authorId</span> <span class="hljs-operator">=</span> book.authorId();
    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorMap.get(authorId);
    <span class="hljs-keyword">if</span> (author != <span class="hljs-literal">null</span>) {
      resultSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title">ResultRow</span>(author.authorId(), 
        author.name(), book.title(), book.bookId()));
    }
  }
  <span class="hljs-keyword">return</span> resultSet;
}
</code></pre>
    <p class="normal">The time complexity of this algorithm is O(n+m), where <em class="italic">n</em> is the size of <code class="inlineCode">authorsTable</code> and <em class="italic">m</em> is the size of <code class="inlineCode">booksTable</code>. So, this is<a id="_idIndexMarker700"/> better than Nested<a id="_idIndexMarker701"/> Loop Join.</p>
    <h2 id="_idParaDest-287" class="heading-2">Sort Merge Join</h2>
    <p class="normal">As the name suggests, Sort Merge Join starts <a id="_idIndexMarker702"/>by sorting the two tables by the attribute of the join. Afterward, we loop the two tables and apply the join <a id="_idIndexMarker703"/>predicate as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;ResultRow&gt; sortMergeJoin(
    List&lt;Author&gt; authorsTable, List&lt;Book&gt; booksTable) {
  authorsTable.sort(Comparator.comparing(Author::authorId));
  booksTable.sort((b1, b2) -&gt; {
    <span class="hljs-type">int</span> <span class="hljs-variable">sortResult</span> <span class="hljs-operator">=</span> Comparator
           .comparing(Book::authorId)
           .compare(b1, b2);
    <span class="hljs-keyword">return</span> sortResult != <span class="hljs-number">0</span> ? sortResult : Comparator
            .comparing(Book::bookId)
            .compare(b1, b2);
  });
  List&lt;ResultRow&gt; resultSet = <span class="hljs-keyword">new</span> <span class="hljs-title">LinkedList</span>();
  <span class="hljs-type">int</span> <span class="hljs-variable">authorCount</span> <span class="hljs-operator">=</span> authorsTable.size();
  <span class="hljs-type">int</span> <span class="hljs-variable">bookCount</span> <span class="hljs-operator">=</span> booksTable.size();
  <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (p &lt;authorCount &amp;&amp; q &lt; bookCount) {
    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorsTable.get(p);
    <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> booksTable.get(q);
    <span class="hljs-keyword">if</span> (author.authorId() == book.authorId()) {
      resultSet.add(<span class="hljs-keyword">new</span> <span class="hljs-title">ResultRow</span>(author.authorId(), 
        author.name(), book.title(), book.bookId()));
      q++;
    } <span class="hljs-keyword">else</span> {
      p++;
    }
  }
  <span class="hljs-keyword">return</span> resultSet;
}
</code></pre>
    <p class="normal">The time complexity <a id="_idIndexMarker704"/>of the Sort Merge Join algorithm is <a id="_idIndexMarker705"/>O(nlog(n) + mlog(m)) where <em class="italic">n</em> is the size of <code class="inlineCode">authorsTable</code> and <em class="italic">m</em> is the size of <code class="inlineCode">booksTable</code>. So, this is better than Nested Loop Join and Hash Join.</p>
    <h1 id="_idParaDest-288" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we covered a lot of interesting topics. We started with the new Vector API for empowering parallel data processing, then we continued with a bunch of cool data structures like Zipper, K-D Trees, Skip List, Binomial Heap, and so on. We finished with a nice overview of the three main join algorithms. Moreover, we’ve covered the JDK 21 Sequenced Collections API.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>