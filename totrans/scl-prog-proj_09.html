<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Interactive Browser</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will introduce the actor model by extending our shopping project. The extension will consist of a notification, provided to anyone connected to the website, about who is adding/removing a product to/from the cart.</p>
<p>Indeed, each time someone acts on the cart, a message will be broadcast to all of the connected browsers, and it will include the name of the user, the action (add or remove), and the product name.</p>
<p>The workflow will be as follows. When someone is connected to the website, a web socket will be opened between the browser and the server; a reference to that web socket will be kept at the server level, inside of an Actor.</p>
<p>As soon as an action is performed on the cart, a message with the username, action, and product name will be sent to the server through the web socket; the server will receive this message, transform it in to an alarm message, and broadcast it to all of the connected browsers. Each browser will then show the alarm as a notification. As soon as the browser disconnects (or the web socket timeout is reached), the web socket reference will be removed from the server.</p>
<p>As you may have noticed, the term Actor was used in the preceding workflow. The theory of the actor model originated in 1973 (<a href="https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask">https://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask</a>), and multiple implementations have been created since, in many languages.</p>
<p>In this book, we are going to use the Akka framework. It was written by Jonas Bonér in 2009 and is based on the Scala Actor implementation created by Philipp Haller. We will only scratch the surface of the framework by providing an introduction to it. This framework would require an entire book to explain all of its features and possible patterns.</p>
<p>In this chapter, we will explain how to communicate between the client and the server using a web socket.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li><span>Actor models</span></li>
<li>Implementing the server side</li>
<li>Implementing the client side</li>
</ul>
<p>The objectives of this chapter are to establish asynchronous communication between the browser and the server using a web socket and to use Actors to handle the communication at the server level. You will learn the following:</p>
<ul>
<li><span>How to create asynchronous communication between the client and the server</span></li>
<li>How to use Actors</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Actors</h1>
                </header>
            
            <article>
                
<p>How can we define the term  Actor? In our first attempt, we considered explaining it technically, using a threading model, concurrency, call stacks, a mailbox, and so on. Then, we realized that a technical description doesn't reflect the essence of a solution based on Actors.</p>
<p>In fact, every time we have to design a solution based on Actors, we can see the Actor as a human working in a company; this person has a name, and maybe an email address (<strong>Actor reference</strong>). The first important fact is that he is not alone; he is going to interact with others (<strong>messaging</strong>), receiving messages from his hierarchy and transmitting other messages to colleagues or subordinates (<strong>supervisors</strong>).</p>
<p>The imaginary company is structured using a hierarchy; a supervisor (<strong>user guardian</strong>) is looking at the health of its subordinate, and, when a problem is raised, if the supervisor can handle it, they will perform actions to fix it. If the error is unmanageable, the supervisor will escalate it to their own superior (<strong>supervisor strategy</strong>), and so on, until it reaches the director (<strong>root guardian</strong>).</p>
<p>Another similarity to communication between humans is that when you ask a colleague to do something and they do not answer. After a certain amount of time (a <strong>timeout</strong>), you might decide to ask again. If you still do not receive an answer, you might think that they are too busy and ask someone else. All of this protocol is performed asynchronously and is based on how long you are prepared to wait (<strong>latency</strong>).</p>
<p>Now, with these concepts in mind, technically, we could define an Actor as a lightweight unit of a process running on only one thread and handling messages one after the other; the Actor receives messages, processes them, and perhaps changes their internal states, based on the message. It then sends another message to the initial sender or any other Actor.</p>
<p>To perform all of this workflow, the Actor needs the following:</p>
<ul>
<li><span>A reference, to be reached from within the same room (JVM) or remotely</span></li>
<li>A mailbox, to queue incoming messages</li>
<li>A state, to save its private state</li>
<li>A behavior, to act based on the received messages and current state</li>
<li>A child Actor, as each Actor could potentially be a supervisor</li>
</ul>
<p>The purpose of this book is not to make you an expert on the Akka framework; instead, this book should provide you with the basic knowledge to feel comfortable with the fundamental concepts. The concepts that you will learn will allow you to build an application, and, if you wish, to go deeper into other components of the framework.</p>
<p>As a reference, the complete Akka documentation <span>can be found directly on the website of the Akka project at </span><a href="https://doc.akka.io/docs/akka/current/general/index.html">https://doc.akka.io/docs/akka/current/general/index.html</a>.</p>
<p>Let's get straight to work and look at how this can be implemented in the real world.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up</h1>
                </header>
            
            <article>
                
<p>To set up our project, we will need the Akka library, in order to create Actors on the server, and Notify.js. Notify.js is a JavaScript library used to pop up notifications on the browser; we picked this library because it does not have any dependencies on other frameworks.</p>
<p class="mce-root">To add this JavaScript library, just add <span>the following</span> to <kbd>build.sbt</kbd>, under <kbd><span>jsDependencies</span></kbd> in the <kbd>client</kbd> variable:</p>
<pre>jsDependencies ++= Seq(
        ...,
  "org.webjars" % "notifyjs" % "0.4.2" / "notify.js")</pre>
<p>The preceding code is for the configuration of the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the server side</h1>
                </header>
            
            <article>
                
<p>At the server level, we need to open a communication channel between the server and the browser; once the communication is open, we need to implement the message reception and broadcast it to all of the connected browsers using Actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the web socket route</h1>
                </header>
            
            <article>
                
<p>To create the route, the <span><kbd>conf/routes</kbd> file needs to be modified by adding the following:</span></p>
<pre>GET /v1/cart/events controllers.WebSockets.cartEventWS </pre>
<p>Notice that the route is defined in the same way as a regular web service call; so, the <kbd>GET</kbd> call on <kbd>/v1/cart/events</kbd> is routed to the <kbd>cartEventWS</kbd> method of the <kbd>controllers.WebSockets</kbd> instance.</p>
<p class="mce-root">Next, we need to create the <kbd>WebSockets</kbd> class in the <kbd>controllers</kbd> package of the server module, and add the <kbd>cartEventsWS</kbd> method, as follows:</p>
<pre>@Singleton
class WebSockets @Inject()(
  implicit actorSystem: ActorSystem,
  materializer: Materializer,
  cc: ControllerComponents) extends AbstractController(cc) {

  def cartEventWS = WebSocket.accept[String, String] { <br/>    implicit request <br/>  =&gt;
        ActorFlow.actorRef { out =&gt;
        // handle upstream
      }
    }
  }
}</pre>
<p>There are not many lines of code, but a lot is happening in this snippet.</p>
<p>On the class constructor, Google Guice (the dependency injection used in Play) is going to inject <kbd>ActorSystem</kbd>. <kbd>ActorSystem</kbd> is the root guardian of the system; this is the top level in the hierarchy of Actors and is unique for every JVM.</p>
<p>Play uses <span>Akka-stream underneath; a</span> materializer is needed. First, let us explain these new terms. Akka-stream is an Akka component used to nicely handle streams, and it is exactly what we need to take care of our stream between the server and the browser. Akka-stream is well engineered; there is a clear separation between the definitions in the stream, such as where the data should be taken, how to process it and where to move it, and the stream runtime. To define the stream, a <strong>Domain-Specific Language</strong> (<strong>DSL</strong>) is available, and the materializer is the runtime of the stream. That is why we need to provide <kbd>Materializer</kbd> in our code.</p>
<p>The upstream is created with <kbd>ActorFlow.actorRef { out =&gt; }</kbd>, where <kbd>out</kbd> is an Actor representing the browser. This function should return an Actor handling messages from the browser. We will come back to the implementation later.</p>
<p class="mce-root">To summarize, at this point, our server opens a new route on <kbd>/v1/cart/events</kbd>. At that entry point, a web socket connection is expected, and for each new connection, a new communication stream is started.</p>
<p class="mce-root">Well, it is time to code the communication handling; but what do we want to do?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing BrowserManager</h1>
                </header>
            
            <article>
                
<p>Each time a new connection is accepted (representing a new browser), we would like to keep a reference to that connection, so that events can be sent to it later. This connection container is handled by an Actor. This Actor will need an internal state with the list of connected browsers; we should add a new browser, and remove it once it is disconnected.</p>
<p>To create an Actor, we use the <kbd>Props</kbd> class from Akka, as follows:</p>
<pre>val managerActor = actorSystem.actorOf(
  BrowserManagerActor.props(),
  "manager-actor")</pre>
<p>This Actor is created from the guardian root Actor; in our case, it is named <kbd>actorSystem</kbd>. From the system Actor, the <kbd>actorOf</kbd> method is called; this method expects <kbd>Props</kbd> as the first parameter, representing our Actor factory, and the name of the Actor as the second parameter. <kbd>BrowserManagerActor</kbd> is composed of a class and its companion object. The companion object is used to create an instance of the Actor, and it is a good practice to also define the messages related to that Actor, as follows:</p>
<pre>object BrowserManagerActor {
  def props() = Props(new BrowserManagerActor())
  
  case class AddBrowser(browser: ActorRef)
}</pre>
<p>We define the <kbd>props()</kbd> method used to create the Actor instance. There is nothing special here; the factory is defined on the companion object and is the best pattern to create an Actor. In this class, we also define the specific messages of this Actor; in this case, we only have one, named <kbd>AddBrowser</kbd>.</p>
<p>The <kbd>BrowserManagerActor</kbd> class implementation is as follows:</p>
<pre>private class BrowserManagerActor() extends Actor with ActorLogging {

  val browsers: ListBuffer[ActorRef] = ListBuffer.empty[ActorRef]

  def receive: Receive = {
    
    case AddBrowser(b) =&gt;
      context.watch(b)
      browsers +=b
      log.info("websocket {} added", b.path)
     
    case CartEvent(user, product, action) =&gt;
      val messageText = s"The user '$user' ${action.toString} <br/>      ${product.name}"
      log.info("Sending alarm to all the browser with '{}' action: {}",
               messageText,
               action)
      browsers.foreach(_ ! Alarm(messageText, action).asJson.noSpaces)
    
    case Terminated(b) =&gt;
      browsers -= b
      log.info("websocket {} removed", b.path)
  }
}</pre>
<p>To become an Actor, the class needs to extend the <kbd>Actor</kbd> class; we also extend <kbd>ActorLogging</kbd>. This will provide a <kbd>log</kbd> object in our class, which can be used to log interesting information.</p>
<p class="mce-root">As noted earlier, we would like to keep the list of browsers connected to the server. For that purpose, we use the <kbd>browsers</kbd> variable, with <kbd>ListBuffer[ActorRef]</kbd> as the type.</p>
<p>Notice that we are using a mutable collection to define this list; this is completely fine in this context, as it is only accessible by this Actor and is guaranteed to be thread-safe.</p>
<p>It is possible to avoid this mutable variable by using another component from the Akka framework. This component is named <strong>Final State Machine</strong> (<strong>FSM</strong>). The full details of the FSM implementation are out of the scope of this book. If you are interested, the link to the full documentation can be found at <a href="https://doc.akka.io/docs/akka/current/fsm.html">https://doc.akka.io/docs/akka/current/fsm.html</a>.</p>
<p>Earlier, we mentioned that an Actor receives messages; this is the purpose of the <kbd>receive</kbd> method. It is a partial function, with <kbd>Any -&gt; Unit</kbd> as a signature. To implement this function, we define the cases that we would like to handle; putting it in a different way, we define the messages <span>that</span> the Actor is handling.</p>
<p>Our manager Actor handles three messages, as follows:</p>
<ul>
<li class="mce-root"><kbd>case AddBrowser(b)</kbd><span>: Here, a new connection is created, and <kbd>b</kbd> represents the browser Actor. </span><span>First, by performing</span> <kbd>context.watch(b)</kbd><span>, we ask the Akka framework to watch the</span> <kbd>b</kbd><span> A</span><span>ctor and inform us when it dies by sending a</span><span> terminated</span> <span>message.</span></li>
<li><kbd>case CartEvent(user, product, action)</kbd>: <span>Here, a message comes from a browser, namely,</span> <kbd>CartEvent</kbd><span>. We would like to inform all of the connected browsers about this event. This is done by sending</span> <span>an a</span>larm <span>message </span><span>to all of the browsers in our browser list. Notice that we convert the message to a JSON format using Circe.</span></li>
<li><kbd>case Terminate(b)</kbd>: <span>This message is received because we are supervising the browser Actor. The</span> <kbd>b</kbd> <span>Actor dies, and the only thing to do is remove it from our list of</span> browsers<span>.</span></li>
</ul>
<p>We are almost done. With this Actor, we keep track of the connected browsers and send an alarm when any of them emits an event.</p>
<p>But wait; something looks suspicious. Indeed, we never sent the <kbd>AddBrowser</kbd> and <kbd>CartEvent</kbd> messages to our manager. Who should send them? The answer is in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling WebSocket</h1>
                </header>
            
            <article>
                
<p>Going back to the <kbd>Websockets</kbd> class, and, more specifically, to the <kbd>cartEventWS</kbd> method, we can finish the implementation, as follows:</p>
<pre>def cartEventWS = WebSocket.accept[String, String] { implicit request =&gt;
      ActorFlow.actorRef{out =&gt;
        Logger.info(s"Got a new websocket connection from <br/>        ${request.host}")
        managerActor ! BrowserManagerActor.AddBrowser(out)
        BrowserActor.props(managerActor)
      }
    }</pre>
<p class="mce-root">After logging, we send the <kbd>AddBrowser</kbd> <span>message  </span>to the manager by using the <kbd>!</kbd> command (pronounced bang); this is syntactic sugar, and we could also use the <kbd>.tell()</kbd> method.</p>
<p class="mce-root"><kbd>ActorFlow.actorRef</kbd> needs <kbd>ActorRef</kbd> to handle the upstream of the web socket; for that purpose, we create <kbd>BrowserActor</kbd> by using the <kbd>props</kbd> function of the <kbd>BrowserActor</kbd> companion object, as follows:</p>
<pre>object BrowserActor {
  def props(browserManager :ActorRef) = 
      Props(new BrowserActor(browserManager))
}</pre>
<p><kbd>BrowserActor</kbd> references the manager; indeed, the manager has the responsibility of sending the message to all of the browsers. The <kbd>BrowserActor</kbd> class implementation is as follows:</p>
<pre>class BrowserActor(browserManager: ActorRef) extends Actor with ActorLogging {
  def receive = {
    case msg: String =&gt;
      log.info("Received JSON message: {}", msg)
      decode[CartEvent](msg) match {
        case Right(cartEvent) =&gt;
          log.info("Got {} message", cartEvent)
          browserManager forward cartEvent
        case Left(error) =&gt; log.info("Unhandled message : {}", error)
      }
  }
}</pre>
<p>This implementation gets all of the messages coming from the socket in string format, converts them into <kbd>CartEvent</kbd> using Circe, and forwards them to the browser manager.</p>
<p>Keep in mind that the message flow can become more complicated; that is why it is a good idea to create a diagram of the system of Actors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A diagram of Actors</h1>
                </header>
            
            <article>
                
<p>It is sometimes necessary to represent the Actor flow using a diagram. The more Actors there are in your system, the more difficult it is to picture the entire workflow, especially if you do not work on the code for a while and then come back to it.</p>
<p>The following is a diagram of our project, illustrating the workflow when a new browser is connected:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/118a6e42-ea30-4374-b0af-39334cb6520a.png" style="width:53.08em;height:44.92em;"/></p>
<p>With this kind of diagram, you can clearly understand who is creating the Actors, and can also understand the sequences of messages between them.</p>
<p>The following diagram illustrates a message being sent from the browser:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/efd7d5c8-f33b-475d-8733-db94eeae5bee.png" style="width:38.67em;height:47.67em;"/></p>
<p>Notice that the start of the third message indicates that the alarm is sent to multiple instances of the web socket.</p>
<div class="packt_infobox">For OmniGraffle users, you can find a stencil to create these diagrams at <span class="packt_screen">Diagramming Reactive Systems</span> | <span class="packt_screen">Graffletopia</span> (<a href="https://www.graffletopia.com/stencils/1540">https://www.graffletopia.com/stencils/1540</a>).<a href="https://www.graffletopia.com/stencils/1540"/></div>
<p>We have now finished looking at Actors; we are missing many features, but the aim was to provide you with enough knowledge to understand the basics of this beautiful framework.</p>
<p>The server is now completely implemented, and we can safely move to the client side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the client side</h1>
                </header>
            
            <article>
                
<p>In the following sections, we will look at the client side. On the client side, we have to initiate the web socket connection with the server, send a <kbd>CartEvent</kbd> when a product is added or removed from the cart, and show alerts when other browsers make changes to the cart.</p>
<p>First, let's create the connection with the server using a web socket.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the web socket</h1>
                </header>
            
            <article>
                
<p>To add the web socket to the client, we are going to use the <kbd>UIManager</kbd> object, which is the entry point of the client. In Scala.js, <kbd>WebSocket</kbd> is part of the framework; edit the <kbd>UIManager</kbd> and add the web socket property to it, as follows:</p>
<pre>val webSocket: WebSocket = getWebSocket</pre>
<p>Some configuration is needed to create the <kbd>WebSocket</kbd>. We encapsulate all of the initializations into a function named <kbd>getWebSocket</kbd>, as follows:</p>
<pre>private def getWebSocket: WebSocket = {
  val ws = new WebSocket(getWebsocketUri(dom.document, <br/>  "v1/cart/events"))
    
  ws.onopen = { (event: Event) ⇒
    println(s"webSocket.onOpen '${event.`type`}'")
    event.preventDefault()
  }

  ws.onerror = { (event: Event) =&gt;
    System.err.println(s"webSocket.onError '${event.getClass}'")
  }

  ws.onmessage = { (event: MessageEvent) =&gt;
    println(s"[webSocket.onMessage] '${event.data.toString}'...")
    val msg = decode[Alarm](event.data.toString)
    msg match {
      case Right(alarm) =&gt;
        println(s"[webSocket.onMessage]  Got alarm event : $alarm)")
        notify(alarm)
      case Left(e) =&gt;
        println(s"[webSocket.onMessage] Got a unknown event : $msg)")
    }
  }

  ws.onclose = { (event: CloseEvent) ⇒
    println(s"webSocket.onClose '${event.`type`}'")
  }
  ws
}</pre>
<p>To create a <kbd>WebSocket</kbd>, we first need to give the URL of the server and then handle all of the events happening in the socket. To get the URL of the server, we use a utility function named <kbd>getWebsocketUri</kbd>:</p>
<pre>private def getWebsocketUri(document: Document, context: String): String = {
  val wsProtocol = <br/>    if (dom.document.location.protocol == "https:") 
      "wss"
    else
      "ws"
  s"$wsProtocol://${
    dom.document.location.host
  }/$context"
}</pre>
<p>This function just checks the protocol and defines the <kbd>WebSocket</kbd> protocol as <kbd>wss</kbd> if encrypted or <kbd>ws</kbd> if not encrypted. Then, the full URL is built by using string interpolation. In production, we usually use SSL, but when developing, we do not use encryption.</p>
<p>Once the URL is defined, we define all of the <span>socket</span> event handlers as follows:</p>
<ul>
<li class="mce-root"><kbd>onopen</kbd><span>: </span><span>When a new connection is created, we just log it and mark the event as canceled, so it will not be taken into consideration if another handler receives it.</span></li>
<li><kbd>onerror</kbd>: <span><span>Just log the error in the error pipe.</span></span></li>
<li><kbd>onmessage</kbd>: <span>When a message is received, we use Circe to decode it and check whether it is an</span> alarm <span>message. If that is the case, we call <kbd>notify(alarm)</kbd>, otherwise, we just log the fact that we received an unknown message. The <kbd>notify(alarm)</kbd> will be explained later.</span></li>
<li><kbd>onclose</kbd>: <span>Again, we just log this event.</span></li>
</ul>
<p>Now, we have defined the socket and it is ready to be used; if this code is run, a connection to the server will be created as soon as the page is browsed. But before that, we need to define the notification system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Notifying the user</h1>
                </header>
            
            <article>
                
<p>To notify the user, we picked a JavaScript library called Notify.js. Notify.js is a jQuery plugin without any dependencies, and it has a simple interface. We will implement only one method: <kbd>$.notify(string, options)</kbd>.</p>
<p>As Notify.js is a jQuery plugin, we need to extend jQuery with this function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending jQuery</h1>
                </header>
            
            <article>
                
<p>Extending jQuery using Scala.js is done by extending the famous jQuery <kbd>$</kbd> symbol. We can create a file named <kbd>Notify.scala</kbd> in the <kbd>io.fscala.shopping.client</kbd> <span>package</span>, in the client project.</p>
<p>In this file, we can first define the extension with the following piece of code:</p>
<pre>@js.native
@JSGlobal("$")
object NotifyJS extends js.Object {
  def notify(msg: String, option: Options): String = js.native
}</pre>
<p>An object named <kbd>NotifyJS</kbd> is defined, extending the Scala.js object named <kbd>js.Object</kbd>. It is necessary to inform the compiler that we are creating a facade of an existing JavaScript library.</p>
<p>The first annotation is <kbd>@js.native</kbd>; this annotation tells the compiler that the implementation is completely done in JavaScript. The second annotation is <kbd>@JSGlobal("$") </kbd>; this is to express the fact that the API we are extending is a JavaScript class, and this class is named <kbd>$</kbd>. The last thing is to define the signature of the function that we would like to call and to use <kbd>js.native</kbd> as implementation; again, the compiler is going to make the bridge between our code and the JavaScript implementation.</p>
<p>The parameters of the function are <kbd>String</kbd> (for the first one) and <kbd>Options</kbd> (for the second). <kbd>Options</kbd> need to be defined, as this is part of the facade.</p>
<p>By reading the Notify.js documentation (<a href="https://notifyjs.jpillora.com/">https://notifyjs.jpillora.com/</a>), you can see that there are a lot of options available, such as the positioning of the notification and the animation of the notification.</p>
<p>From the Notify.js documentation, we can get the definitions of all of the options, as follows:</p>
<pre>{
  // whether to hide the notification on click
  clickToHide: true,
  // whether to auto-hide the notification
  autoHide: true,
  // if autoHide, hide after milliseconds
  autoHideDelay: 5000,
  // show the arrow pointing at the element
  arrowShow: true,
  // arrow size in pixels
  arrowSize: 5,
  // position defines the notification position though uses the <br/>  defaults below
  position: '...',
  // default positions
  elementPosition: 'bottom left',
  globalPosition: 'top right',
  // default style
  style: 'bootstrap',
  // default class (string or [string])
  className: 'error',
  // show animation
  showAnimation: 'slideDown',
  // show animation duration
  showDuration: 400,
  // hide animation
  hideAnimation: 'slideUp',
  // hide animation duration
  hideDuration: 200,
  // padding between element and notification
  gap: 2
}</pre>
<p>We can create an <kbd>Options</kbd> class in Scala, as follows:</p>
<pre>@ScalaJSDefined
trait Options extends js.Object {
  // whether to hide the notification on click
  var clickToHide: js.UndefOr[Boolean] = js.undefined
  // whether to auto-hide the notification
  var autoHide: js.UndefOr[Boolean] = js.undefined
  // if autoHide, hide after milliseconds
  var autoHideDelay: js.UndefOr[Int] = js.undefined
  // show the arrow pointing at the element
  var arrowShow: js.UndefOr[Boolean] = js.undefined
  // arrow size in pixels
  var arrowSize: js.UndefOr[Int] = js.undefined
  // position defines the notification position <br/>  // though uses the defaults below
  var position: js.UndefOr[String] = js.undefined
  // default positions
  var elementPosition: js.UndefOr[String] = js.undefined
  var globalPosition: js.UndefOr[String] = js.undefined
  // default style
  var style: js.UndefOr[String] = js.undefined
  // default class (string or [string])
  var className: js.UndefOr[String] = js.undefined
  // show animation
  var showAnimation: js.UndefOr[String] = js.undefined
  // show animation duration
  var showDuration: js.UndefOr[Int] = js.undefined
  // hide animation
  var hideAnimation: js.UndefOr[String] = js.undefined
  // hide animation duration
  var hideDuration: js.UndefOr[Int] = js.undefined
  // padding between element and notification
  var gap: js.UndefOr[Int] = js.undefined
}</pre>
<p>The <kbd>@ScalaJSDefined</kbd> <span>annotation </span>tells the compiler that this is a type defined in Scala, and not in JavaScript.</p>
<p>Then, for each property, we check the type candidate in the documentation and define it using <kbd>js.UndefOr[Int]</kbd>; this type acts like a bridge between the <kbd>undefinedJavaScript</kbd> and <kbd>Options</kbd> types in Scala.</p>
<p>Everything is now defined for our facade; we can use this facade and implement the missing <kbd>notify(alarm)</kbd> function of the <kbd>UIManager</kbd> class, as follows:</p>
<pre>private def notify(alarm: Alarm): Unit = {
  val notifyClass = if (alarm.action == Add) "info" else "warn"
  NotifyJS.notify(alarm.message, new Options {
    className = notifyClass
    globalPosition = "right bottom"
  })
}</pre>
<p>First, we check the type of action to set the class name of the notification, and then we use the <kbd>notify</kbd> native call by passing the message and the notification's options.</p>
<p>We are all done. Now, if the server is running, each time you add or remove a product in the cart, a notification will be sent to all of the connected browsers, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/24ff428f-867b-498e-a8d4-908fa9102bb8.png" style="width:48.50em;height:33.75em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The shopping page with the notification for cart updates</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to create a WebSocket communication between the server and the browser. At the server level, we kept a reference to all the browsers connected, so that events could be dispatched to all the browsers. An important piece of the system is the actor model, defined at the server level. We learned that the actor model programming paradigm is adequate as soon as we have an interaction between asynchronous systems.</p>
<p>You learned that a diagram of the interactions between Actors can be helpful as your system is growing. It is particularly useful when someone needs to go back to the code after being away for a while. As we are not calling methods but sending messages to <kbd>ActorRef</kbd>, the navigation in the IDE is not easy, so it is difficult to understand the flow just by reading the code.</p>
<p>Once the first steps in this framework are made, development is natural and close to real-world interaction.</p>
<p>We also introduced Akka. <span>Akka is </span><span>a complete framework, separated into different modules.</span> We strongly encourage you to take a spin in the Akka website at <a href="https://akka.io/">https://akka.io/</a>.</p>
<p>On the client side, thanks to Scala.js, the integration of a framework is completed with only a few lines of code; once defined in Scala, we can use all of the knowledge learned from a backend system and apply it to the front. This is especially true when we are sharing the code between the backend and frontend.</p>
<p>This ends the chapter. At this point, you should have the necessary information to build your own client-server program. In the next chapters, we will introduce you to how to use Scala to process and analyze large amounts of data, using Apache Spark, Kafka and Zeppelin.</p>


            </article>

            
        </section>
    </body></html>