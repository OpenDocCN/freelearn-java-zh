<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Lazy Loading</h1>
                </header>
            
            <article>
                
<p><span><em>Lazy loading</em> is a technique for lowering memory consumption and, possibly, processing time. This technique delays the loading of data until the moment when it's actually needed in the UI. For example, if you have a</span><span> </span><kbd>Grid</kbd><span> component </span><span>with, say 10,000 rows, only a bunch of them are visible at a given time. Loading the full set of 10,000 rows might be a waste of resources. The idea behind lazy loading is the same as the behavior of a lazy person: if you delay doing something until the last moment, you will end up saving time if, for some reason, it turns out that you don't have to do the task anymore. It's the same in a web application. For example, if a user leaves certain views without scrolling through the data, the application won't need to load anything other than a few visible items, saving it from having to load potentially thousands or millions of items from the data source; something that could become a serious problem when many users are on the same view at the same time.</span></p>
<p>In this chapter, we will discuss how to implement lazy loading with the <kbd>Grid</kbd> component. However, <span>the same principles apply to any other kind of UI components that show data from large datasets.</span></p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Adding lazy loading capabilities to backend services</li>
<li>Implementing a <kbd>DataProvider</kbd> with lambda expressions</li>
<li>Filtering</li>
<li>Ordering</li>
<li>Infinite lazy loading</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>You will be required to have Java SE Development Kit and Java EE SDK version 8 or later. You also need Maven version 3 or later. A Java IDE with Maven support, such as IntelliJ IDEA, Eclipse, or NetBeans is recommended. Finally, to use the Git repository of this book, you need to install Git.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09">https://github.com/PacktPublishing/Data-centric-Applications-with-Vaadin-8/tree/master/chapter-09</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/GLTkjq">https://goo.gl/GLTkjq</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The example application</h1>
                </header>
            
            <article>
                
<p>We will develop a simple application to test Vaadin's capability to show hundreds of thousands of rows in a <kbd>Grid</kbd> component. The users can filter the data in the <kbd>Grid</kbd> by typing a filter text that the application matches against three of the columns (<span class="packt_screen">C</span><span class="packt_screen">lient</span>, <span class="packt_screen">Phone Number</span>, and <span class="packt_screen">City</span>). The users can also change the position of the columns (by dragging them from the header) and order the rows (by clicking on the column headers). The following is a screenshot of the example application:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-218 image-border" src="assets/0c0c951c-db66-4037-a125-96b6890bf1bf.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The data model</h1>
                </header>
            
            <article>
                
<p>This chapter uses the same data model used in <a href="245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml" target="_blank">Chapter 8</a>, <em>Adding Reporting Capabilities</em>. The data model is based on a simple SQL table, <kbd>Call</kbd>. We'll use JPA to connect to a file-based H2 database. The JPA logic is encapsulated in a <kbd>CallRepository</kbd> class. For more details about the data model, please refer to <a href="245d238e-02e9-4888-a0c7-37aa3f4cc536.xhtml" target="_blank">Chapter 8</a>, <em>Adding Reporting Capabilities</em>.</p>
<div class="mce-root packt_infobox"><span>You can find the complete source code of this chapter's example in the</span><span> </span><kbd>Data-centric-Applications-with-Vaadin-8\chapter-09</kbd><span> </span><span>Maven project of the source code that accompanies this book.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Vaadin UI</h1>
                </header>
            
            <article>
                
<p><kbd>VaadinServlet</kbd><span> is configured in the</span><span> </span><kbd>WebConfig</kbd><span> class. The</span><span> </span><kbd>UI</kbd><span> </span><span>implementation is realized in the</span><span> </span><kbd>VaadinUI</kbd><span> </span><span>class. For reference, the following is the implementation of the <kbd>VaadinUI</kbd> class:</span></p>
<pre><span>@Title</span>(<span>"Call Browser"</span>)<br/><span>public class </span><strong>VaadinUI</strong> <span>extends </span>UI {<br/><br/>    <span>@Override<br/></span><span>    </span><span>protected void </span>init(VaadinRequest vaadinRequest) {<br/>        VerticalLayout mainLayout = <span>new </span>VerticalLayout();<br/>        mainLayout.addComponentsAndExpand(<span>new </span><strong>CallsBrowser</strong>());<br/>        setContent(mainLayout);<br/>    }<br/>}</pre>
<p>Notice how the UI consists of a <kbd>VerticalLayout</kbd> that contains only a <kbd>CallsBrowser</kbd> component. We'll start with the following implementation of the <kbd>CallsBrowser</kbd> custom component:</p>
<pre>public class <strong>CallsBrowser</strong> extends Composite {<br/><br/>    public CallsBrowser() {<br/>        TextField <strong>filter</strong> = new TextField();<br/>        filter.setPlaceholder("Client / Phone / City");<br/>        filter.focus();<br/><br/>        Button <strong>search</strong> = new Button(VaadinIcons.SEARCH);<br/>        search.setClickShortcut(ShortcutAction.KeyCode.ENTER);<br/><br/>        Button <strong>clear</strong> = new Button(VaadinIcons.CLOSE_SMALL);<br/><br/>        CssLayout filterLayout = new CssLayout(filter, search, clear);<br/>        filterLayout.addStyleName(ValoTheme.LAYOUT_COMPONENT_GROUP);<br/><br/>        Label <strong>countLabel</strong> = new Label();<br/>        countLabel.addStyleNames(<br/>                ValoTheme.LABEL_LIGHT, ValoTheme.LABEL_SMALL);<br/><br/>        HorizontalLayout headerLayout = new HorizontalLayout(<br/>                filterLayout, countLabel);<br/>        headerLayout.setComponentAlignment(countLabel, Alignment.MIDDLE_LEFT);<br/><br/>        Grid&lt;Call&gt; <strong>grid</strong> = new Grid&lt;&gt;(Call.class);<br/>        grid.setColumns("id", "client", "phoneNumber", "city", "startTime",<br/>                "duration", "status");<br/>        grid.setSizeFull();<br/><br/>        VerticalLayout mainLayout = new VerticalLayout(headerLayout);<br/>        mainLayout.setMargin(false);<br/>        mainLayout.addComponentsAndExpand(grid);<br/>        setCompositionRoot(mainLayout);<br/>    }<br/>}</pre>
<p>The previous class can be used as a starting point if you want to implement the concepts of this chapter yourself. At this point, the UI doesn't show any data in the <kbd>Grid</kbd> and it has no behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the backend for lazy loading</h1>
                </header>
            
            <article>
                
<p><span>Lazy loading (and filtering) capabilities should be delegated to the backend as much as possible. Although the <kbd>Grid</kbd> class itself is able to cache some of the data and send it to the client only when needed, it cannot prevent you from querying the whole database, for example. </span>In order to support lazy loading, backend services should provide the means to lazily load the data.</p>
<p>Typically, the UI gets the data from a service or repository class. Let's see an example of how a repository class can provide methods with lazy loading capabilities. The <kbd>CallRepository</kbd> class could define a <kbd>findAll</kbd> method that queries a <em>slice</em> of the rows in the <kbd>Call</kbd> table, as follows:</p>
<pre class="programlisting">public class CallRepository {

    public static List&lt;Call&gt; findAll(int <strong>offset</strong>, int <strong>limit</strong>) {
        ...
    }<br/><br/>    public static int count() {<br/>        ...<br/>    }
}</pre>
<p>In the previous code, <kbd>limit</kbd> is used to <em>limit</em> the number of rows (actually, instances of <kbd>User</kbd>) that should be returned. When using SQL, this can be used as the <kbd>LIMIT</kbd> clause in a SQL query. <kbd>offset</kbd> is used to <em>skip</em> a number of rows, which is equivalent to the starting row number. For example, if the SQL table has 100 rows, and we use <kbd>offset=10</kbd> and <kbd>limit=5</kbd>, the method should return only the rows 10 to 15. If we use <kbd>offset=98</kbd> and <kbd>limit=5</kbd>, the method should return rows 98 to 100 (there are not enough rows left after 98 to complete a set of five rows).</p>
<p>For reference, here's what a JPA implementation of these methods could look like:</p>
<pre><span>public class </span>CallRepository {<br/>    ...<br/><br/>    <span>public static </span>List&lt;Call&gt; <strong>find</strong>(<span>int </span>offset, <span>int </span>limit) {<br/>        <span>return </span>JPAService.<span>runInTransaction</span>(em -&gt; {<br/>            Query query = em.createQuery("<strong>select c from Call c</strong>");<br/>            <strong>query.setFirstResult(offset)</strong>;<br/>            <strong>query.setMaxResults(limit)</strong>;<br/><br/>            List&lt;Call&gt; resultList = query.getResultList();<br/>            <span>return </span>resultList;<br/>        });<br/>    }<br/><br/>    <span>public static int </span><strong>count</strong>() {<br/>        <span>return </span>JPAService.<span>runInTransaction</span>(em -&gt; {<br/>            Query query = em.createQuery(<span>"<strong>select count(c.id) from Call c</strong>"</span>);<br/><br/>            Long count = (Long) query.getSingleResult();<br/>            <span>return </span>count.intValue();<br/>        });<br/>    }<br/>}</pre>
<p>Notice how we included a <kbd>count</kbd> method in the previous snippet of code. This is required in some situations, such as when using lazy loading with the <kbd>Grid</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy loading with the Grid component</h1>
                </header>
            
            <article>
                
<p>A<span> </span><kbd>Grid</kbd><span> </span>component can take advantage of the<span> </span><kbd>offset</kbd><span> </span>and<span> </span><kbd>limit</kbd><span> </span>parameters described in the previous section by using the<span> </span><kbd>setDataProvider</kbd><span> </span>method, as follows:</p>
<pre class="programlisting">grid.<strong>setDataProvider</strong>(
    (sortOrders, <strong>offset</strong>, <strong>limit</strong>) -&gt;
            CallRepository.findAll(<strong>offset</strong>, <strong>limit</strong>).stream(),
    () -&gt; CallRepository.<strong>count</strong>()
);</pre>
<p>The previous code defines two lambda expressions:</p>
<ul>
<li><kbd>(sortOrders, offset, limit) -&gt; service.find(...)</kbd>: This lambda expression should return all the items used in <em>slice</em> defined by the <kbd>offset</kbd> and <kbd>limit</kbd> parameters (we will see how to use the <kbd>sortOrders</kbd> parameters later)</li>
<li><kbd>() -&gt; service.count()</kbd>: This lambda expression should return the total count of items available with no <em>slices</em></li>
</ul>
<p>The <kbd>setDataProvider</kbd> method we used in the previous example receives an instance of <kbd>FetchItemsCallback</kbd>, a functional interface that defines a method to fetch the items (or rows):</p>
<pre><span>@FunctionalInterface<br/></span><span>public interface </span><strong>FetchItemsCallback</strong>&lt;<span>T</span>&gt; <span>extends </span>Serializable {<br/><br/><span>    </span><span>public </span>Stream&lt;<span>T</span>&gt; fetchItems(<br/>            List&lt;QuerySortOrder&gt; sortOrder, <span>int </span><strong>offset</strong>, <span>int </span><strong>limit</strong>);<br/>}</pre>
<p>You can also use another version of the <kbd>setDataProvider</kbd> method that accepts an instance of <kbd>DataProvider</kbd>. There's a static helper method in the <kbd>DataProvider</kbd> interface that allows you to implement it from lambda expressions similar to the ones we used before:</p>
<pre>DataProvider&lt;Call, Void&gt; <strong>dataProvider</strong> = DataProvider.<strong>fromCallbacks</strong>(<br/>        <strong>query</strong> -&gt; CallRepository.<span>find</span>(<br/>                query.<strong>getOffset()</strong>,<br/>                query.<strong>getLimit()</strong>).stream(),<br/>        query -&gt; CallRepository.<span>count</span>()<br/>);<br/><br/>grid.setDataProvider(<strong>dataProvider</strong>);</pre>
<p>The difference with the previous version is that we get the <kbd>offset</kbd> and <kbd>limit</kbd> values from a <kbd>Query</kbd> instance, so we need to use the corresponding getters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding filters</h1>
                </header>
            
            <article>
                
<p><span>Filtering should be done with the help of backend services as well. We can implement this in the same way as we did in <a href="8981e1f2-5502-4d2f-b0c6-c1116d23f0bc.xhtml" target="_blank">Chapter 7</a>, <em>Implementing CRUD User Interfaces</em>. First, the backend service method should accept the filter input. In the example application, the filter value is a <kbd>String</kbd>, but in other situations, you may need a custom object containing all the values that can be used for filtering. Here is the new <kbd>find</kbd> method, which accepts a filter <kbd>String</kbd>:</span></p>
<pre><span>public static </span>List&lt;Call&gt; <strong><span>find</span></strong>(<span>int </span>offset<span>, int </span>limit<span>, </span>String <strong>filter</strong><span>,<br/></span>        Map&lt;String<span>, </span>Boolean&gt; sort) {<br/>    <span>return </span>JPAService.<span>runInTransaction</span>(em -&gt; {<br/><span>        </span>Query query = em.createQuery("select c from Call c <strong>where lower(c.client) like :filter or c.phoneNumber like :filter or lower(c.city) like :filter</strong>")<span>;<br/></span><span>        </span>query.setParameter(<span>"filter"</span><span>,<br/></span><strong><span>                "%" </span>+ <span>filter</span>.trim().toLowerCase() + <span>"%"</span></strong>)<span>;<br/></span><span>        </span>query.setFirstResult(<span>offset</span>)<span>;<br/></span><span>        </span>query.setMaxResults(<span>limit</span>)<span>;<br/></span><span><br/></span><span>        </span>List&lt;Call&gt; resultList = query.getResultList()<span>;<br/></span><span>        return </span>resultList<span>;<br/></span><span>    </span>})<span>;<br/></span>}</pre>
<p>Notice how we make the filter case-insensitive by using the <kbd>lower</kbd> <span>JPQL function </span>and converting the filter value to lowercase using the <kbd>toLowerCase</kbd> method. We are also using the <kbd>%</kbd> operator to allow matches in the middle of the values in the database. We have to do something similar with the <kbd>count</kbd> method:</p>
<pre><span>public static int </span><strong><span>count</span></strong>(String filter) {<br/>    <span>return </span>JPAService.<span>runInTransaction</span>(em -&gt; {<br/>        Query query = em.createQuery(<span>"select count(c.id) from Call c <strong>where lower(c.client) like :filter or c.phoneNumber like :filter or lower(c.city) like :filter</strong>"</span>)<span>;<br/></span><span>        </span><strong>query.setParameter(<span>"filter"</span><span>, </span><span>"%" </span>+ <span>filter</span>.trim().toLowerCase() + <span>"%"</span>)</strong><span><strong>;</strong><br/></span><span><br/></span><span>        </span>Long count = (Long) query.getSingleResult()<span>;<br/></span><span>        return </span>count.intValue()<span>;<br/></span><span>    </span>})<span>;<br/></span>}</pre>
<p>On the UI side of the implementation, we need to send the filter value to the service method. This value comes from the <kbd>filter</kbd> text field:</p>
<pre>DataProvider&lt;Call<span>, </span>Void&gt; dataProvider = DataProvider.<span>fromFilteringCallbacks</span>(<br/>        query -&gt; CallRepository.<span>find</span>(query.getOffset()<span>, </span>query.getLimit()<span>,<br/></span><strong><span>                filter</span>.getValue()</strong>).stream()<span>,<br/></span><span>        </span>query -&gt; CallRepository.<span>count</span>(<strong><span>filter</span>.getValue()</strong>)<br/>)<span>;<br/></span></pre>
<p>We also need to refresh the <kbd>DataProvider</kbd> when the <span class="packt_screen">Search</span> button is clicked. This can be done using a <kbd>ClickListener</kbd> and the <kbd>refreshAll</kbd> method of the <kbd>DataProvider</kbd> interface:</p>
<pre>search.addClickListener(e -&gt; <span>dataProvider</span>.<strong>refreshAll()</strong>)<span>;</span></pre>
<p><span>Something similar can be done for the</span> <kbd>clear</kbd> <span>button, which removes the filter introduced by the user:</span></p>
<pre>clear.addClickListener(e -&gt; {<br/>    <span>filter</span>.clear()<span>;<br/></span><span>    </span><span>dataProvider</span>.refreshAll()<span>;<br/></span>})<span>;<br/></span></pre>
<p>When the<span> </span><kbd>refreshAll</kbd><span> </span>method is invoked, the lambda expressions we previously defined are called again and the new data is fetched from the service class.</p>
<p>It's generally a good idea to add database indexes to the columns the application uses to filter data. In the example application, we allow filtering on the <kbd>client</kbd>, <kbd>phoneNumber</kbd>, and <kbd>city</kbd> columns. You can let JPA create these indexes by using the <kbd>@Index</kbd> annotation, as follows:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>indexes </span>= {<br/>        <span>@Index</span>(<span>name </span>= <span>"client_index"</span><span>, </span><span>columnList </span>= <span>"client"</span>)<span>,<br/></span><span>        </span><span>@Index</span>(<span>name </span>= <span>"phoneNumber_index"</span><span>, </span><span>columnList </span>= <span>"phoneNumber"</span>)<span>,<br/></span><span>        </span><span>@Index</span>(<span>name </span>= <span>"city_index"</span><span>, </span><span>columnList </span>= <span>"city"</span>)<br/>})<br/><span>@Data<br/></span><span>public class </span>Call {<br/>    ...<br/>}</pre>
<div class="packt_tip"><span>By default, the example application generates around 500,000 rows in the </span><kbd>Call</kbd><span> table. Unfortunately, the </span><kbd>Grid</kbd><span> class cannot handle this amount of rows. See the following issues on GitHub for more information about these limitations: </span><a href="https://github.com/vaadin/framework/issues/6290">https://github.com/vaadin/framework/issues/6290</a><span>, and </span><a href="https://github.com/vaadin/framework/issues/9751">https://github.com/vaadin/framework/issues/9751</a><span>. One way to overcome these issues is by making the filter show results in the </span><kbd>Grid</kbd><span> only when the number of rows the query returns is less than an established threshold.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ordering rows in Grid components</h1>
                </header>
            
            <article>
                
<p>As you can guess, ordering (or sorting) is another task that should be delegated to the backend services when possible. Moreover, it is most likely required when you are implementing pagination (that is, lazy loading using <kbd>limit</kbd> and <kbd>offset</kbd> parameters) in the backend service as well.</p>
<p>The service method should include a parameter that specifies how to perform the ordering. The <kbd>Grid</kbd> component allows users to click on the column headers to activate ordering by that column. These columns that need ordering are passed to the <kbd>DataProvider</kbd> in a <kbd>Query</kbd> object. You can get these by calling the <kbd>Query.getSortOrders()</kbd> method, which returns a <kbd>List</kbd> of <kbd>QuerySortOrder</kbd> objects. You could pass this <kbd>List</kbd> to the service method, but it's always a good idea to avoid coupling the backend services with frontend technologies. <kbd>QuerySortOrder</kbd> is a class included in Vaadin Framework, so you would need to include Vaadin dependencies in your backend services if they are deployed in a separate artifact, for example. To avoid this coupling, we can implement a utility method that converts between <kbd>QuerySortOrder</kbd> objects to framework-independent objects. In the backend services, we can use a <kbd>Map&lt;String, Boolean&gt;</kbd>, where the key is a <kbd>String</kbd> containing the name of the property, and the value is a <kbd>Boolean</kbd> that tells the method whether to order in an ascending mode or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the backend services</h1>
                </header>
            
            <article>
                
<p>Let's start, then, by adding a parameter for the ordering configuration to the <kbd>find</kbd> method of the <kbd>CallRepository</kbd> in the example application:</p>
<pre><span>public static </span>List&lt;Call&gt; <strong><span>find</span></strong>(<span>int </span>offset<span>, int </span>limit<span>,<br/></span>        String filter<span>, </span><strong>Map&lt;String<span>, </span>Boolean&gt; order</strong>) {<br/>    <span>return </span>JPAService.<span>runInTransaction</span>(em -&gt; {<br/>        String <strong>jpql</strong> = <span>"select c from Call c where lower(c.client) like :filter or c.phoneNumber like :filter or lower(c.city) like :filter" </span><strong>+ <span>buildOrderByClause</span>(<span>sort</span>)</strong><span>;<br/></span><span>        </span>Query query = em.createQuery(jpql)<span>;<br/></span><span>        </span>query.setParameter(<span>"filter"</span><span>, </span><span>"%" </span>+ <span>filter</span>.trim().toLowerCase() + <span>"%"</span>)<span>;<br/></span><span>        </span>query.setFirstResult(<span>offset</span>)<span>;<br/></span><span>        </span>query.setMaxResults(<span>limit</span>)<span>;<br/></span><span><br/></span><span>        </span>List&lt;Call&gt; resultList = query.getResultList()<span>;<br/></span><span>        return </span>resultList<span>;<br/></span><span>    </span>})<span>;<br/></span>}</pre>
<p>The <kbd>order</kbd> parameter contains the name of the properties we need to sort by. We need to convert this <kbd>Map</kbd> to an <kbd>order by</kbd> clause (in a <kbd>String</kbd> form) in JPQL. This is done in the <kbd>buildOrderByClause</kbd> method:</p>
<pre><span>private static </span><strong>String</strong> <strong><span>buildOrderByClause</span></strong>(<strong>Map&lt;String<span>, </span>Boolean&gt;</strong> order) {<br/>    StringBuilder orderBy = <span>new </span>StringBuilder()<span>;<br/></span><span>    </span>order.forEach((property<span>, </span>isAscending) -&gt; <span>orderBy</span>.append(property + (isAscending ? <span>"" </span>: <span>" desc"</span>) + <span>","</span>))<span>;<br/></span><span><br/></span><span>    if </span>(orderBy.length() &gt; <span>0</span>) {<br/>        orderBy.delete(orderBy.length() - <span>1</span><span>, </span>orderBy.length())<span>;<br/></span><span>        return </span><span>" order by " </span>+ orderBy.toString()<span>;<br/></span><span>    </span>} <span>else </span>{<br/>        <span>return </span><span>""</span><span>;<br/></span><span>    </span>}<br/>}</pre>
<p>If the user clicks the <span class="packt_screen">Client</span> header in the <kbd>Grid</kbd>, the <kbd>buildOrderByClause</kbd> method will return the following string:</p>
<pre>" order by client"</pre>
<p>This string would be concatenated to the end of the JPQL query, which in turn would be executed in the <kbd>find</kbd> method.</p>
<p>The <kbd>Grid</kbd> component also supports ordering by multiple columns. To add a column to the order configuration, users have to press and hold the <em>Shift</em> key down while clicking the column header. For example, if the user clicks the <span class="packt_screen">Client</span> header and presses and holds the <em>Shift</em> key down while clicking the <span class="packt_screen">City</span> header, the <kbd>buildOrderByClause</kbd> method would return the following string:</p>
<pre>" order by client,city"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enabling ordering in the UI</h1>
                </header>
            
            <article>
                
<p>As we have previously discussed, the <kbd>DataProvider</kbd> interface uses an object of type <kbd>List&lt;QuerySortOrder&gt;</kbd> to provide the ordering configuration. However, the backend service requires an object of type <kbd>Map&lt;String, Boolean&gt;</kbd>. We have to implement a helper method that translates between these two types. We can add this method to a separate <kbd>DataUtils</kbd> class and implement it as follows:</p>
<pre><span>public class </span><strong>DataUtils</strong> {<br/><br/>    <span>public static </span>&lt;<span>T</span><span>, </span><span>F</span>&gt; Map&lt;String<span>, </span>Boolean&gt; <strong><span>getOrderMap</span></strong>(<br/>            Query&lt;<span>T</span><span>, </span><span>F</span>&gt; query) {<br/>        Map&lt;String<span>, </span>Boolean&gt; map = <span>new </span><strong>LinkedHashMap</strong>&lt;&gt;()<span>;<br/></span><span><br/></span><span>        for </span>(QuerySortOrder order : <strong>query.getSortOrders()</strong>) {<br/>            String property = order.getSorted()<span>;<br/></span><span>            boolean </span>isAscending = SortDirection.<span>ASCENDING</span>.equals(<br/>                    order.getDirection())<span>;<br/></span><span>            </span><strong>map.put(property<span>, </span>isAscending)</strong><span>;<br/></span><span>        </span>}<br/><br/>        <span>return </span>map<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>The <kbd>getOrderMap</kbd> method iterates over the <kbd>QuerySortOrder</kbd> objects returned by the <kbd>query.getSortOrders()</kbd> method and maps them to entries in a map of type <kbd>Map&lt;String, Boolean&gt;</kbd>. Notice how we used the <kbd>LinkedHasMap</kbd> type. This allows us to keep the entries in the map in the same order in which they come from the <kbd>List</kbd> provided by the <kbd>query</kbd> object, something we need if we want to support multiple-column ordering in the <kbd>Grid</kbd> (the <kbd>order by</kbd> clause should reflect the sequence used when the user clicked the headers in the browser).</p>
<p>We can use this utility method in the <kbd>DataProvider</kbd>, as follows:</p>
<pre>DataProvider&lt;Call<span>, </span>Void&gt; dataProvider = DataProvider.<span>fromFilteringCallbacks</span>(<br/>        query -&gt; CallRepository.<span>find</span>(query.getOffset()<span>, </span>query.getLimit()<span>, </span><span>filter</span>.getValue()<span>, </span><strong>DataUtils.<span>getOrderMap</span>(query)</strong>).stream()<span>,<br/></span><span>        </span>query -&gt; {<br/>            <span>int </span>count = CallRepository.<span>count</span>(<span>filter</span>.getValue())<span>;<br/></span><span>            </span><span>countLabel</span>.setValue(count + <span>" calls found"</span>)<span>;<br/></span><span>            return </span>count<span>;<br/></span><span>        </span>}<br/>)<span>;<br/></span></pre>
<p>The final result is illustrated in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-219 image-border" src="assets/273da231-c17c-4128-b7fe-f409ae9d35ec.png" style=""/></div>
<p>To complete this chapter's example, we can enable column reordering (the users can drag the columns in the browser to reposition them) as follows:</p>
<pre>grid.setColumnReorderingAllowed(<span>true</span>)<span>;</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">UX and large datasets</h1>
                </header>
            
            <article>
                
<p>To close this chapter, let me share some thoughts about the convenience (or inconvenience) of having a<span> </span><kbd>Grid</kbd><span> </span>with 10,000 (or more) rows in it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lazy loading Grid versus direct search</h1>
                </header>
            
            <article>
                
<p>In the<span> </span>screen<span> </span>I'm using to develop the examples of this chapter, I can see around 15 rows at a time in a<span> </span><kbd>Grid</kbd><span> </span>component. If I want to see the row 5,390, for example, I have to scroll down and try to find the rows around 5,390. That takes me 1 or 2 seconds if I'm lucky. After this, I have to do some fine-tuned scrolling to get to the exact row. Something that can take 1 or 2 seconds again. This scrolling-through to search data is possible with this example application because the demo data is generated with consecutive numbers for the values in the fields. There are no missing numbers. In other situations, this might not be possible at all. Even in the cases where this is possible, scrolling through thousands of rows is not a good user experience.</p>
<p>Filters aim to help; clicking on a<span> </span><kbd>TextField</kbd><span> </span>and typing 5,390 is faster than scrolling through the data. However, if the user is supposed to type 5,390, we could argue that rendering thousands of rows is not even required. The whole UI could potentially be redesigned to better fit the use case. When you encounter this kind of<span> </span><kbd>Grid</kbd> with thousands of rows in it, put yourself in others' shoes; in the users' shoes. Consider wizard-like interfaces, infinite lazy loading on scroll (like Facebook or Twitter), or any other event, and splitting the view into several views, each one for a more specific use case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Infinite lazy loading</h1>
                </header>
            
            <article>
                
<p>Even though we have explained lazy loading by using the<span> </span><kbd>Grid</kbd><span> </span>component, we can use the same backend service method to implement custom UI components that support lazy loading. For example, you can use a<span> </span><kbd>VerticalLayout</kbd><span> </span>to add sets of, say, 10 components any time the user clicks a <em>load more</em><span> </span>button at the bottom of the layout. In this case, you would need to keep track of the current offset and keep incrementing it until the service method returns less than 10 items.</p>
<p>The following is a simple UI component that shows how to implement this type of infinite lazy loading:</p>
<pre>public class <strong>LazyLoadingVerticalLayout</strong> extends Composite {<br/><br/>    private CssLayout content = new CssLayout();<br/>    private Button button = new Button("Load more...");<br/><br/>    private int offset;<br/>    private int pageSize;<br/><br/>    public LazyLoadingVerticalLayout(int pageSize) {<br/>        this.pageSize = pageSize;<br/><br/>        button.setStyleName(ValoTheme.BUTTON_BORDERLESS_COLORED);<br/><br/>        VerticalLayout mainLayout = new VerticalLayout(content, button);<br/>        setCompositionRoot(mainLayout);<br/><br/>        button.addClickListener(e -&gt; <strong>loadMore()</strong>);<br/>        loadMore();<br/>    }<br/><br/>    public void <strong>loadMore</strong>() {<br/>        List&lt;Call&gt; calls = CallRepository.find(<br/>                offset, pageSize, "", new HashMap&lt;&gt;());<br/><br/>        if (<strong>calls.size() &lt; pageSize</strong>) {<br/>            <strong>button.setVisible(false)</strong>;<br/>        }<br/><br/>        calls.stream()<br/>                .map(call -&gt; new Label(call.toString()))<br/>                .forEach(content::addComponent);<br/><br/>        <strong>offset += pageSize</strong>;<br/>    }<br/>}</pre>
<p>Notice how the <kbd>loadMore</kbd> method keeps adding components to the <kbd>content</kbd> layout until there are no more results to add, at which point the <span class="packt_screen">Load more...</span> button is hidden from the UI.</p>
<p>The following screenshot shows this component in action:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-220 image-border" src="assets/9d7a1acd-a0cd-4ff7-ae4f-29be424ec488.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how to implement lazy loading by enhancing the backend service methods to support it. We learned how to use a lazy-loaded <kbd>Grid</kbd> component with filtering and ordering capabilities. We implemented a <kbd>DataProvider</kbd> by providing two lambda expressions: one for getting slices of data and one for counting the total number of items. We also discussed UX aspects to take into consideration when dealing with large datasets and learned how to implement infinite lazy loading as an alternative to having a <kbd>Grid</kbd> with thousands of rows.</p>
<p>This chapter closes the journey through many interesting topics related to modularization, API design, UI design, and data management in applications developed with Vaadin. There is much more to this subjects that we cannot cover in this book. Hopefully, this book inspired you to find good solutions to some of the challenges you may encounter when developing data-centric web applications with Vaadin. Happy coding!</p>


            </article>

            
        </section>
    </body></html>