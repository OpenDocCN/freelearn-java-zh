- en: Chapter 12. Play in Production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application deployment, configurations, and so on are slightly different in
    a production environment since it is affected by various factors, such as security,
    load/traffic (which is expected to handle), network issues, and so on. In this
    chapter, we will see how to get our Play application up and running in production.
    This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a Play application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Play Framework provides commands to package and deploy Play applications in
    production.
  prefs: []
  type: TYPE_NORMAL
- en: The `run` command, which we used earlier, starts the application in `DEV` mode
    and watches the code for changes. When there is a change in the code, the application
    is recompiled and reloaded. Being watchful is handy during development, but is
    an unnecessary overhead in production. Also, the default error pages shown in
    `PROD` mode are different from the ones shown in `DEV` mode, that is, they have
    less information about the errors that are occurring (for security reasons).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the different ways in which we can deploy an application in production.
  prefs: []
  type: TYPE_NORMAL
- en: Using the start command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start an application in `PROD` mode, we can use the `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The process ID can be used later to stop the application. By pressing *Ctrl*
    + *D*, we do not lose the logs, since they are also captured in `logs/application.log`
    by default (that is, when there's been no change in the logger configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `start` command optionally accepts the port number at which the application
    should be deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using a distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the `start` command is good enough to deploy the application, in scenarios
    where a portable version of the application is required, it may not be sufficient.
    In this section, we will see how to build a standalone distribution of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play Framework supports building a distribution of an application using
    the `sbt-native-packager` plugin (refer to [http://www.scala-sbt.org/sbt-native-packager/](http://www.scala-sbt.org/sbt-native-packager/)).
    The plugin can be used to create the `.msi` (Windows), `.deb` (Debian), `.rpm`
    (Red Hat Package Manager), and `.zip` (universal) files, as well as the Docker
    images of our application. The plugin also supports defining settings for the
    package in the application''s build file. Some of the settings are common while
    others are OS-specific. The common ones are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `packageName` | Name of the created output package without the extension
    | Project name transformed from mixed case and spaces to lowercase and dash-separated
    |'
  prefs: []
  type: TYPE_TB
- en: '| `packageDescription` | The description of the package | Project name |'
  prefs: []
  type: TYPE_TB
- en: '| `packageSummary` | Summary of the contents of a Linux package | Project name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `executableScriptName` | Name of the executing script | Project name transformed
    from mixed case and spaces to lowercase and dash-separated |'
  prefs: []
  type: TYPE_TB
- en: '| `maintainer` | The name/e-mail address of a maintainer for the native package
    |   |'
  prefs: []
  type: TYPE_TB
- en: Now, let's see how we can build packages for different OSes and use them.
  prefs: []
  type: TYPE_NORMAL
- en: Universal distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A universal distribution is compatible with all/most operating systems. The
    generated packages are located at `projectHome/target/universal`. We can use any
    of the following commands to create a package as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`universal:packageBin` – This command creates an `appname-appVersion.zip` file
    of the packaged application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`universal:packageZipTarball` – This command creates an `appname-appVersion.tgz`
    file of the packaged application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`universal:packageOsxDmg` – This command creates an `appname-appVersion.dmg`
    file of the packaged application (the command only works on OS X)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `universal:packageZipTarball` command requires the `gzip`, `xz`, and `tar`
    command-line tools, while `universal:packageOsxDmg` requires OS X or systems installed
    with `hdiutil`.
  prefs: []
  type: TYPE_NORMAL
- en: To use the package built through these commands, extract the files and execute
    `bin/appname` for the Unix-based systems and `bin/appname.bat` for systems with
    Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Play application, we can use the `dist` command instead of `universal:packageBin`.
    The `dist` command deletes unnecessary intermediate files created while packaging
    the application using the `universal:packageBin` command.
  prefs: []
  type: TYPE_NORMAL
- en: Debian distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create a distribution that can be installed on Debian-based systems using
    the `debian:packageBin` command. The `.deb` file is located at `projectHome/target`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To build the Debian package, the value for `packageDescription` in the Debian
    setting should be set in the `build` file. Other Debian package settings can also
    be set in the `build` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'After packaging, we can install the application using `dpkg-deb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s installed, we can start the application by executing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The rpm distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `rpm` package of the application can be created using the `rpm:packageBin`
    command. Some of the settings available for the `rpm` package are shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `rpmVendor` | Name of the vendor for this `rpm` package |'
  prefs: []
  type: TYPE_TB
- en: '| `rpmLicense` | License of the code within the `rpm` package |'
  prefs: []
  type: TYPE_TB
- en: '| `rpmUrl` | URL to include in the `rpm` package |'
  prefs: []
  type: TYPE_TB
- en: '| `rpmDescription` | Description of this `rpm` package |'
  prefs: []
  type: TYPE_TB
- en: '| `rpmRelease` | Special release number for this `rpm` package |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The values for `rpmVendor` in `rpm`, `packageSummary` in `rpm`, and `packageDescription`
    in `rpm` must be set in the `build` file to successfully create an `rpm` package
    of the application where `rpm` is the scope, for example the name in `rpm:= "SampleProject"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `rpm` package is generated, we can install it using `yum` or an equivalent
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the installation is completed, we can start the application by executing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Windows distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Windows installer of the application, `appname-appVersion.msi`, can be created
    using the `windows:packageBin` command. The file is located at `projectHome/target`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Play Framework understands that applications may require changes in configuration
    prior to deployment in production. To simplify deploying, the command to deploy
    the application also accepts application-level configurations as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the application''s HTTP port as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In some projects, the production and development configuration are maintained
    in two separate files. We could either pass one or more configurations or a different
    file altogether. There are three ways of specifying a configuration file explicitly.
    It can be achieved by using one of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`config.resource`: This option is used when the file is within the class path
    (a file in `application/conf`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.file`: This option is used when the file is available on the local
    filesystem but not bundled with the application''s resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config.url`: This option is used when the file is to be loaded from a URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose our application uses `conf/application-prod.conf` in production, we
    can specify the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can also modify the logger configuration by replacing the `config`
    key with `logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can also configure the underlying Netty server by passing the settings as
    arguments and this not possible through `application.conf`. The following table
    lists some of the settings related to the server that can be configured in one
    or more ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties related to the address and port are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http.address` | The address at which the application will be deployed |
    `0.0.0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `http.port` | The port at which the application will be available | `9000`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `https.port` | The `sslPort` port at which the application will be available
    |   |'
  prefs: []
  type: TYPE_TB
- en: 'The properties related to the HTTP requests (`HttpRequestDecoder`) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.maxInitialLineLength` | The maximum length of the initial line
    (for example, `GET / HTTP/1.0`) | `4096` |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.maxHeaderSize` | The maximum length of all the headers combined
    together | `8192` |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.maxChunkSize` | The maximum length of the body or each chunk
    of it. If the length of the body exceeds this value, the content will be split
    into chunks of this size or less (in case of the last one). If the request sends
    the chunked data and the length of a chunk exceeds this value, it will be split
    into smaller chunks. | `8192` |'
  prefs: []
  type: TYPE_TB
- en: 'The properties related to the TCP socket options are shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.backlog` | The maximum size for queued incoming connections
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.reuseAddress` | Reuse address |   |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.receiveBufferSize` | The size of the socket that receives
    a buffer |   |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.sendBufferSize` | The size of the socket that sends a
    buffer |   |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.child.keepAlive` | Keeps connections alive | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.child.soLinger` | Lingers on closing if the data is present
    | Negative integer (disabled) |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.tcpNoDelay` | Disables Nagle''s algorithm. TCP/IP uses
    an algorithm known as Nagle''s algorithm to coalesce short segments and improve
    network efficiency. | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| `http.netty.option.trafficClass` | The **Type of Service** (**ToS**) octet
    in the **Internet Protocol** (IP) header. | 0 |'
  prefs: []
  type: TYPE_TB
- en: Enabling SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways of enabling SSL for our application. We can either serve
    an HTTPS application by the providing the required configuration for it on start,
    or by proxying the requests through an SSL-enabled web server. In this section,
    we will see how the first option can be used and the latter will be covered in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose to run both the HTTP and HTTPS versions or just opt for one of
    them using the `http.port` and `https.port` settings. By default, HTTPS is disabled
    and we can enable it by specifying `https.port` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Play generates self-signed certificates if we do not provide them, and starts
    the application with SSL enabled in it. However, these certificates are unsuitable
    for an actual application and we need to specify the details of the key store
    using the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Purpose | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `https.keyStore` | The path to the key store containing a private key and
    certificate | This value is dynamically generated |'
  prefs: []
  type: TYPE_TB
- en: '| `https.keyStoreType` | The key store type | **JavaKeyStore** (**JKS**) |'
  prefs: []
  type: TYPE_TB
- en: '| `https.keyStorePassword` | The password | Blank password |'
  prefs: []
  type: TYPE_TB
- en: '| `https.keyStoreAlgorithm` | The key store algorithm | The platform''s default
    algorithm |'
  prefs: []
  type: TYPE_TB
- en: In addition to this, we can also specify `SSLEngine` through the `play.http.sslengineprovider`
    setting. The prerequisite for this is that the custom `SSLEngine` should implement
    the `play.server.api.SSLEngineProvider` trait.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended to use JDK 1.8 when a Play application with SSL enabled is
    running in production, since Play uses some of the features of JDK 1.8 to facilitate
    it. If using JDK 1.8 is not feasible, a reverse proxy with SSL enabled should
    be used instead. Refer to [https://www.playframework.com/documentation/2.3.x/ConfiguringHttps](https://www.playframework.com/documentation/2.3.x/ConfiguringHttps)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Using a load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Websites that deal with huge traffic generally use a technique called load balancing
    to improve the availability and responsiveness of applications. A load balancer
    distributes incoming traffic among multiple servers hosting same content. The
    distribution of load is determined by various scheduler algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to add a load balancer in front of our application
    servers (assuming that they are running on the IPs `127.0.0.1`, `127.0.0.2`, and
    `127.0.0.3` on the port `9000`) using different HTTP web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Apache HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Apache HTTP server provides a secure, efficient, and extensible server that
    supports HTTP services. The Apache HTTP server can be used as a load balancer
    through its `mod_proxy` and `mod_proxy_balance` modules.
  prefs: []
  type: TYPE_NORMAL
- en: To use Apache HTTP as a load balancer, `mod_proxy` and `mod_proxy_balancer`
    have to be present in the server. To set up the load balancer, all we need to
    do is update `/etc/httpd/conf/httpd.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the configuration step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare `VirtualHost`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Disable the forward proxy for `VirtualHost` so that our server cannot be used
    for masking the identities of clients from the source servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of a document root, we should add a proxy with balancer identifier
    and `BalanceMembers`. Also, if we want to use the **round-robin** strategy, we
    also need to set it as `lbmethod` (**load balancing method**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add the access permissions for the proxy, which should be accessible
    to everyone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to map the proxy to the path that we want to load the application
    on the server to. This can be done with a single line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The configuration that needs to be added to the Apache HTTP configuration file
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable SSL, we will need to add the following code to the `VirtualHost`
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration has been tried on Apache/2.4.10 on July 31, 2014.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Apache HTTP's `mod_proxy` module, refer to [http://httpd.apache.org/docs/2.2/mod/mod_proxy.html](http://httpd.apache.org/docs/2.2/mod/mod_proxy.html).
  prefs: []
  type: TYPE_NORMAL
- en: The nginx server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **nginx** server is a high performance HTTP server and a reverse proxy as
    well. It is also an IMAP/POP3 proxy server. We can configure nginx to act as a
    load balancer using two modules—`proxy` and `upstream`. These two modules are
    part of the nginx core and are available by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nginx configuration file, `nginx.conf`, is generally located at `/etc/nginx`.
    Let''s update it to use nginx as a load balancer for our application step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define an `upstream` module for our cluster of application
    servers. The syntax is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The default load balancing method is round-robin. So, we need not specify it
    explicitly when we wish to use it. Now, for our application, the `upstream` module
    will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, all that we need to do is proxy all the requests. To do this, we must
    update the `server` module''s location module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The nginx server also supports proxying **WebSocket**. To enable WebSocket
    connections, we need to add two headers to the `location` module. So, if our Play
    application uses WebSocket, we can define the `location` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable SSL, we need to add the following settings to the server definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration has been tested on nginx/1.4.7.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the nginx documentation at [http://nginx.org/en/docs/http/load_balancing.html#nginx_load_balancing_configuration](http://nginx.org/en/docs/http/load_balancing.html#nginx_load_balancing_configuration)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: lighttpd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lighttpd` server is a lightweight web server designed and optimized for
    high performance environments. All the utilities that may be required are available
    as modules and can be included as per our requirements. We can set `lighttpd`
    as a frontend server for our Play application using the `mod_proxy` module. We
    need to make a few configuration changes to achieve this. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `lighttpd.conf` file (generally located at `/etc/lighttpd/`) to load
    additional modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, loading modules is disabled. This can be enabled by uncommenting
    this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update `modules.conf` (located in the same directory as `lighttpd.conf`) to
    load the `mod_proxy` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, only `mod_access` is enabled. Update `server.modules` to the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, enable loading the settings for `mod_proxy` by uncommenting this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `proxy.conf` file (generally located at `/etc/lighttpd/conf.d/`)
    with the server proxy configuration. The `q` module has only three settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`proxy.debug`: This setting enables/disables the log level'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy.balance`: This setting is a load balancing algorithm (round-robin, hash,
    and fair)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy.server`: This setting is where requests are sent'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected format of defining a `proxy.server` setting is as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The terms in this code are explained as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<extension>`: This term is the file extension or prefix (if started with `"/"`);
    empty quotes, `""`, match all the requests'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<name>`:This term is the optional name that shows up in the generated statistics
    of `mod_status`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: This term is used to specify the IP address of the proxy server'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: This term is used to set the TCP port on its corresponding host (the
    default value is `80`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Update the proxy settings as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration has been tried on lighttpd/1.4.35 on March 12, 2014.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more information on the configuration settings of `mod_proxy`, refer to
    [http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModProxy](http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModProxy).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: High Availability Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**High Availability** **Proxy** (**HAProxy**) offers high availability, load
    balancing, and proxying for TCP and HTTP-based applications. We can set HAProxy
    as a load balancer by updating the `haproxy.cfg` configuration file (it is generally
    located at `/etc/haproxy/`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the required configuration changes step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the backend cluster. The syntax for defining a backend
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, the backend for our application will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we just need to point requests to the backend cluster. We can do this
    by updating the frontend section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: No additional configuration is required for an application using WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This configuration has been tried on HAProxy version 1.5.9 2014/11/25.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some corner cases you might encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to deploy our application on Tomcat. How can we package the application
    as WAR?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although this is not supported by default in Play, we can use the `play2-war-plugin`
    module (refer to [https://github.com/play2war/play2-war-plugin/](https://github.com/play2war/play2-war-plugin/))
    to achieve this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Is there a simpler way to deploy the application on PaaS?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Play applications on Heroku, Clever Cloud, Cloud Foundry and/or AppFog
    are documented at [https://www.playframework.com/documentation/2.3.x/DeployingCloud](https://www.playframework.com/documentation/2.3.x/DeployingCloud).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to deploy a Play application in production. While
    deploying it, we saw the different packaging options (such as `rpm`, `deb`, `zip`,
    `windows`, and so on) available by default. We also saw different configuration
    settings, such as the HTTP port, maximum size of the request header, and so on,
    which we can specify when starting the application in production. We also discussed
    how to send requests to the application using a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how the Play plugins work, and how we can
    build custom Play plugins to meet different requirements.
  prefs: []
  type: TYPE_NORMAL
