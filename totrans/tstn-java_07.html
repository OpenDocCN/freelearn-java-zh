<html><head></head><body>
		<div id="_idContainer050">
			<h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor154"/>7</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor155"/>Java Syntax and Exceptions</h1>
			<p>In this chapter, we will begin by looking at the syntax of the Java language. It might seem strange that it took till this chapter to look at syntax. To understand why, I must let you in on a secret: you already know how to code. This is the audience this book is for – you can program but have little or no experience with Java. I have no doubt that you could understand what was happening in every code sample you have seen so far. We will now formalize the <span class="No-Break">Java syntax.</span></p>
			<p>Here are the topics we <span class="No-Break">will cover:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">coding structures</span></li>
				<li><span class="No-Break">Handling exceptions</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to organize Java code into methods and classes. Decision-making and iteration in Java code are presented. When things go wrong, there can be, in many situations, the need to leave the code that caused the error and either carry out additional processing to solve the problem or exit the program. This is the role <span class="No-Break">of exceptions.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor156"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java <span class="No-Break">17 installed</span></li>
				<li><span class="No-Break">Text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>You can find the code from this chapter in the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter07</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor157"/>Understanding coding structures</h1>
			<p>When we write code in any language, we know that it must be organized in very specific ways. You are familiar with this concept from <a id="_idIndexMarker502"/>whichever language or languages you already know, so all we must do is examine how they are coded in Java. We begin with <span class="No-Break">code blocks.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor158"/>Code blocks</h2>
			<p>Every language has a structure for <a id="_idIndexMarker503"/>organizing the lines of code you write, and this is<a id="_idIndexMarker504"/> commonly called a <strong class="bold">block</strong>. The Python language uses indenting to define a block, and Pascal uses the <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> keywords. Java uses opening (<strong class="source-inline">{</strong>) and closing (<strong class="source-inline">}</strong>) braces, as do C, C++, C#, <span class="No-Break">and JavaScript.</span></p>
			<p>In Java, all classes and <a id="_idIndexMarker505"/>methods must have an opening and closing brace. Blocks may be nested, as we will see when we examine iteration and decisions later in this section. Blocks also serve another purpose when it comes to variables. This is called the variable’s scope. Let’s look at this in practice in <span class="No-Break">an example:</span></p>
			<pre class="source-code">
public class Blocks {
 2
 3     private int classScope;
 4     private static int staticVar;
 5    
 6     static {
 7        staticVar = 42;
 8        System.out.printf(
              "static block staticVar is %d%n",staticVar);
 9     }
10    
11     public Blocks() {
12        System.out.printf("constructor method block%n");
13     }
14    
15     public void perform() {
16        int methodScope;
17        
18        if (classScope &gt; 0) {
19           int blockScope = 4;
20        }
21          
22        {
23           int classScope = 3;
24           this.classScope = classScope;
25        }
26     }
27  }</pre>
			<p>We’ll discuss each line <span class="No-Break">in detail.</span></p>
			<p><em class="italic">Line 1</em> declares a class named <strong class="source-inline">Blocks</strong>, and an opening brace appears on this line. C/C++ programmers typically place opening braces on their own line, and Java is fine with this. The Java <a id="_idIndexMarker506"/>style is to place an<a id="_idIndexMarker507"/> opening brace on the same line that names <span class="No-Break">the block.</span></p>
			<p><em class="italic">Line 3</em> declares an instance field. We know this because it is declared inside the class block and is not static. For every object, there will be a unique <strong class="source-inline">classScope</strong> variable. As this field is in the class block, it is visible to all non-static methods in the class. It is also available to any inner blocks in any method. It only goes out of scope when the object instantiated from this class goes out <span class="No-Break">of scope.</span></p>
			<p><em class="italic">Line 4</em> declares a static or class variable. This variable will be shared by all instances of the class. It is visible in all blocks in the class. One thing it cannot be is a local method variable. Static variables can only be declared in the class block <span class="No-Break">or scope.</span></p>
			<p><em class="italic">Lines 6</em> through <em class="italic">9</em> declare a static block. The code in this block is only ever executed once when the first instance of this object is created. You cannot declare fields in this block. You cannot interact with instance (non-static) variables, but you can interact with class (static) variables. You may<a id="_idIndexMarker508"/> also call upon static methods such as <strong class="source-inline">System.out.print</strong> or any static methods in this class. An interesting characteristic of static blocks is that they execute before the constructor. This is why they cannot access non-static variables and <a id="_idIndexMarker509"/>methods. These non-static variables are only valid after the constructor executes, <span class="No-Break">not before.</span></p>
			<p><em class="italic">Lines 11</em> through <em class="italic">13</em> are just a constructor. If you add a <strong class="source-inline">main</strong> method to this example, you will be able to see that the static block always executes before <span class="No-Break">the constructor.</span></p>
			<p><em class="italic">Lines 15</em> through <em class="italic">26</em> are a non-static method block named <strong class="source-inline">perform</strong> that in turn contains two additional blocks. In the <strong class="source-inline">method</strong> block, we have the <strong class="source-inline">methodScope</strong> local variable that is visible and accessible in the method and in any inner blocks. This variable will go out of scope when the execution of the method reaches the closing brace of the <span class="No-Break"><strong class="source-inline">method</strong></span><span class="No-Break"> block.</span></p>
			<p><em class="italic">Lines 18</em> through <em class="italic">20</em> consist of an <strong class="source-inline">if</strong> statement followed by a block that is executed should the <strong class="source-inline">if</strong> statement be <strong class="source-inline">true</strong>. In this block, we have declared a variable named <strong class="source-inline">blockScope</strong>. This variable comes into scope after the opening brace is encountered and the declaration is found. When the block ends, this variable goes out <span class="No-Break">of scope.</span></p>
			<p><em class="italic">Lines 22</em> through <em class="italic">25</em> are another block. In here, we are declaring a variable of the same name and type as the class-scoped variable. When this occurs, the block version of a variable hides any variable declared in an outer block, which in this case is the class itself. To access the class block variable, as we have seen when we discussed methods, we use the <strong class="source-inline">this</strong> reference. If you create more blocks in blocks, which is not really a good idea, you can only access the class level variable with <strong class="source-inline">this</strong>, and any variable of the same name and the type in outer blocks <span class="No-Break">becomes inaccessible.</span></p>
			<p>Moving on, let’s briefly review the meaning of the terms <em class="italic">statement</em> and <em class="italic">expression</em> <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor159"/>Statements</h2>
			<p>In Java, any line of code that <a id="_idIndexMarker510"/>performs a task and ends in a semicolon is a statement. Here are a <span class="No-Break">few </span><span class="No-Break"><a id="_idIndexMarker511"/></span><span class="No-Break">examples:</span></p>
			<pre class="source-code">
1  int x = 4;
2  printHeader();
3  d = Math.sqrt(aDoubleValue);</pre>
			<p>These are all statements. <em class="italic">Line 1</em> is a declaration statement where an integer variable is assigned space in memory and a value is assigned to it. <em class="italic">Line 2</em> is a call to a method. <em class="italic">Line 3</em> uses the square root method from the <strong class="source-inline">Math</strong> library to compute a result that you are assigning to <span class="No-Break">a variable.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor160"/>Expressions</h2>
			<p>An expression in Java is any <a id="_idIndexMarker512"/>code that returns a result as part of a statement. The result may be from an assignment, some <a id="_idIndexMarker513"/>simple math, or as the return value from another method or Java construct, such as the <strong class="source-inline">switch</strong> expression that we will <span class="No-Break">see shortly.</span></p>
			<p>In the examples in the <em class="italic">Statements</em> section, we can see that the <em class="italic">line 1</em> statement includes an expression that assigns a value to a variable. <em class="italic">Line 2</em> is just a statement as there is no value that is changing. <em class="italic">Line 3</em> takes the value returned by the call to <strong class="source-inline">Math.sqrt</strong> and assigns it to a variable. When we assign a new value to a variable, we describe this as changing its state. Statements that change the state of a variable do this with <span class="No-Break">an expression.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor161"/>Operators</h2>
			<p>Java’s family of operators is<a id="_idIndexMarker514"/> quite like what is found in C and most other languages derived from C/C++ or modeled on them. The rules of precedence are respected, and <a id="_idIndexMarker515"/>expressions inside parentheses are always carried out first. All the standard logical operators exist. As Java does not have pointers, operators that deal with pointers, such as the address of (<strong class="source-inline">&amp;</strong>) and the indirection (<strong class="source-inline">*</strong>), do not exist in this language. There is one group of operators that I do want <span class="No-Break">to highlight.</span></p>
			<p>In C/C++, we express the outcome of combining multiple Boolean expressions in one of two ways—either logical <strong class="source-inline">AND</strong> or logical <strong class="source-inline">OR</strong>. They are expressed as a double ampersand (<strong class="source-inline">&amp;&amp;</strong>) and a double pipe (<strong class="source-inline">||</strong>). They employ short-circuit evaluation, which means if there’s a condition that validates or invalidates the statement in the first comparison, then there is no need to carry out a second comparison. The values on each side of the operator must be Booleans. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
numberOfTrees &gt; 10 &amp;&amp; numberOfSquirrels &gt; 20</pre>
			<p>There is a matching set that <a id="_idIndexMarker516"/>can perform the same task but without short-circuit evaluation. These are the single ampersand (<strong class="source-inline">&amp;</strong>) and the single pipe (<strong class="source-inline">|</strong>). When working<a id="_idIndexMarker517"/> with primitive types, they perform a bitwise operation. For the single ampersand (<strong class="source-inline">&amp;</strong>), there must be a binary 1 in the same position in each value that becomes a binary 1 in the new value. Otherwise, a binary 0 is placed in the new value. For the single pipe (<strong class="source-inline">|</strong>), the matching bits must have one of the bits as a <span class="No-Break">binary 1.</span></p>
			<p>There is one more operator in this family worth mentioning and that is the caret (<strong class="source-inline">^</strong>). This is the <strong class="source-inline">XOR</strong> operator. As used with the primitive types, the new value takes a binary 1 only if one of the two values being compared has a binary 1 in the same position. Otherwise, the result <span class="No-Break">is 0.</span></p>
			<p>In Java, there is a hierarchy of the numeric primitive types—as listed next—based on their size in memory and the range of allowable values. We saw this earlier in <a href="B19088_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Language Fundamentals – Data Types </em><span class="No-Break"><em class="italic">and Variables</em></span><span class="No-Break">:</span></p>
			<ol>
				<li><span class="No-Break"><strong class="source-inline">byte</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">char</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">short</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">int</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">long</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">float</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">double</strong></span></li>
			</ol>
			<p>Assignment statements have a right-hand side and a left-hand side, <span class="No-Break">such as:</span></p>
			<p><em class="italic">LHS = </em><span class="No-Break"><em class="italic">RHS</em></span></p>
			<p>Based on this list, you can only have a type on the LHS that has a larger range of values than the type on the RHS. This means you can write something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
int intValue = 27;
double doubleValue = intValue;</pre>
			<p>This works because the conversion from <strong class="source-inline">int</strong> on the RHS to <strong class="source-inline">double</strong> on the LHS is lossless. In the other direction, as shown next, it will be an error because the fractional part of <strong class="source-inline">double</strong> will <span class="No-Break">be lost:</span></p>
			<pre class="source-code">
double doubleValue = 23.76;
int intValue = doubleValue;</pre>
			<p>This all leads to the casting<a id="_idIndexMarker518"/> operator—the parenthesis plus type. The <a id="_idIndexMarker519"/>parenthesis is also used in other ways but when used here, it becomes an operator. To make the previous example work, you can cast <strong class="source-inline">double</strong> to <strong class="source-inline">int</strong>, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
int intValue = (int) doubleValue;</pre>
			<p>This is a lossy conversion as the fractional component of the <strong class="source-inline">double</strong> value is sliced off, with no rounding. The value that ends up in <strong class="source-inline">intValue</strong> will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">23</strong></span><span class="No-Break">.</span></p>
			<p>There is one more operator—the arrow operator (<strong class="source-inline">-&gt;</strong>), which we will encounter when we examine the modern switch <a id="_idIndexMarker520"/>and functional programming. Let’s now move on and examine iteration, commonly <span class="No-Break">called looping.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor162"/>Iteration</h2>
			<p>Java provides us with two <a id="_idIndexMarker521"/>approaches to iteration. The first, which we will look at <a id="_idIndexMarker522"/>now, is the classical looping technique. We will examine using streams to iterate over every member of a collection in the next chapter. </p>
			<h3>The for loop</h3>
			<p>Let’s begin with the C-style <strong class="source-inline">for</strong> loop. This is <a id="_idIndexMarker523"/>a loop where the conditions <a id="_idIndexMarker524"/>for iteration are in the first line of the loop <span class="No-Break">inside parentheses:</span></p>
			<pre class="source-code">
        For (int x = 0; x &lt; 10; ++x) {
            System.out.printf("Value of x is %d%n", x);
        }</pre>
			<p>The entire <strong class="source-inline">for</strong> loop is considered a block. This means that an <strong class="source-inline">x</strong> variable is created when the <strong class="source-inline">for</strong> loop is entered, and it goes out of scope when the loop ends. If you need access to <strong class="source-inline">x</strong> after the loop ends, then declare it before the loop, <span class="No-Break">as shown:</span></p>
			<pre class="source-code">
        int x;
        for (x = 0; x &lt; 10; ++x, doMethod()) {
            System.out.printf("Value of x is %d%n", x);
        }</pre>
			<p>There are two special statements <a id="_idIndexMarker525"/>available in <span class="No-Break">classic loops:</span></p>
			<ul>
				<li>The <strong class="source-inline">break</strong> statement <a id="_idIndexMarker526"/>will end a loop before it <span class="No-Break">finishes iterating</span></li>
				<li>The <strong class="source-inline">continue</strong> statement ends the current iteration of the loop and moves on to the <span class="No-Break">next iteration</span></li>
			</ul>
			<h3>The foreach loop</h3>
			<p>There is one more style of the <strong class="source-inline">for</strong> loop, called the <strong class="source-inline">foreach</strong> loop. It is predicated on the fact that every<a id="_idIndexMarker527"/> element in an <a id="_idIndexMarker528"/>array or collection will be processed. We will examine the <strong class="source-inline">foreach</strong> loop when we look at collections in the <span class="No-Break">next chapter.</span></p>
			<h3>The while and do/while loops</h3>
			<p>When a <strong class="source-inline">for</strong> loop is written, the <a id="_idIndexMarker529"/>maximum number of iterations is known right away. For our next loops, <strong class="source-inline">while</strong> and <strong class="source-inline">do</strong>/<strong class="source-inline">while</strong>, the number of iterations cannot be predicted as it will depend <a id="_idIndexMarker530"/>on something changing in the body of <span class="No-Break">the loop.</span></p>
			<p>In using <strong class="source-inline">while</strong> and <strong class="source-inline">do</strong>/<strong class="source-inline">while</strong>, the loop is<a id="_idIndexMarker531"/> dependent on something happening inside the loop block, which may change the variable that is being logically examined. Here is an example with an <span class="No-Break">unpredictable ending:</span></p>
			<pre class="source-code">
        var rand = new Random();
        int x = rand.nextInt(12);
        while (x &lt; 10) {
            x = rand.nextInt(12);
            System.out.printf("x = %d%n", x);
        }</pre>
			<p>The first line instantiates the <strong class="source-inline">java.util.Random</strong> object. Next, we instantiate the variable that will be the basis of the logical test and give it a random value. The method call to <strong class="source-inline">rand.nextInt(12)</strong> will return a value with a range of 12 possible integers between 0 to 11 inclusively. This points <a id="_idIndexMarker532"/>out that a <strong class="source-inline">while</strong> loop can iterate zero or more times, but it is not possible to predict <a id="_idIndexMarker533"/>how many iterations. We express the logical test in the parentheses of the <strong class="source-inline">while</strong> statement. Inside the loop, we must perform some action that alters the <a id="_idIndexMarker534"/>state of the <strong class="source-inline">x</strong> loop variable. There are no restrictions on what you can code in the <span class="No-Break"><strong class="source-inline">while</strong></span><span class="No-Break"> block.</span></p>
			<p>A variation of the <strong class="source-inline">while</strong> loop is the <strong class="source-inline">do</strong>/<strong class="source-inline">while</strong> loop. This loop is guaranteed to iterate at least once as the logical test occurs at the end of the loop. You can see it in <span class="No-Break">action here:</span></p>
			<pre class="source-code">
        Var rand = new Random();
        int x;
        do {
            x = rand.nextInt(12);
            System.out.printf("x = %d%n", x);
        } while (x &lt; 10);</pre>
			<p>Notice that, unlike the <strong class="source-inline">while</strong> loop, there is no need to initialize the loop variable as it will get its first value inside <span class="No-Break">the loop.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor163"/>Decision-making</h2>
			<p>Decision-making syntax in <a id="_idIndexMarker535"/>Java supports three structures available in C/C++ and <a id="_idIndexMarker536"/>other languages. They are the <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> statement, the <strong class="source-inline">switch</strong> statement, and the <span class="No-Break">ternary operator.</span></p>
			<p>A simple <strong class="source-inline">if</strong> statement does not require an <span class="No-Break"><strong class="source-inline">else</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
if (age &gt;= 65) {
    designation = "Senior";
}</pre>
			<p>You can create an either/or expression <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">else</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if (age &gt;= 65) {
    designation = "Senior";
} else {
    designation = "Adult";
}</pre>
			<p>You can simplify this example by using the ternary operator, which uses a question mark and <span class="No-Break">a colon:</span></p>
			<pre class="source-code">
String designation = (age &gt;= 65) ? "Senior" : "Adult";</pre>
			<p>It begins with the logical test. While using parentheses in this situation is optional, I strongly recommend <a id="_idIndexMarker537"/>using them. After the question mark and on either side of the colon are the values that will be returned by the expression. You may also call a method if it returns a value of the <span class="No-Break">appropriate type.</span></p>
			<p>Should you need to define a test for ranges of value, you can use the <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">else</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> syntax:</span></p>
			<pre class="source-code">
        if (age &lt; 12) {
            designation = "child";
        } else if (age &lt; 18) {
            designation = "teenager";
        } else if (age &lt; 25) {
            designation = "young adult";
        } else if (age &lt; 65) {
            designation = "adult";
        } else {
            designation = "senior";
        }</pre>
			<p>Next up is the C-style <a id="_idIndexMarker538"/>switch. As of Java 17, the syntax of the C-style switch can be considered obsolete. The fact that the new versions of the switch are recent additions makes it important that you understand the C-style version. A switch is a logical structure for comparing the <strong class="source-inline">switch</strong> variable to <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <span class="No-Break">literal integer</span></li>
				<li>An integer <span class="No-Break">constant variable</span></li>
				<li>A <span class="No-Break">literal string</span></li>
			</ul>
			<p>Here is a switch to<a id="_idIndexMarker539"/> determine the postal rate, which depends on the zone the mail is being <span class="No-Break">sent to:</span></p>
			<pre class="source-code">
        double postage;
        int zone = 3;
        switch (zone) {
            case 1:
                postage = 2.25;
                break;
            case 2:
                postage = 4.50;
                break;
            case 3:
                postage = 7.75;
                break;
            default:
                postage = 10.00;
        }</pre>
			<p>The lines that end in a colon are referred to as conditional labels. Should the <strong class="source-inline">zone</strong> variable’s value match the literal, then the code that follows the matching case is performed. When such a match with a case is found, all subsequent cases become <strong class="source-inline">true</strong>, regardless of the case value. Therefore, there is a <strong class="source-inline">break</strong> statement at the end of every case. You can <a id="_idIndexMarker540"/>simulate a test against a limited range of values by purposely not using a break everywhere, as illustrated in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
        String continent;
        String country = "Japan";
        
        switch (country) {
            case "UK":
            case "France":
            case "Germany":
                continent = "Europe";
                break;
            case "Canada":
            case "USA":
            case "Mexico":
                continent = "North America";
                break;
            default:
                continent = "Not found";
        }</pre>
			<p>As of Java 14, two new versions of the switch were introduced. These are the new <strong class="source-inline">switch</strong> expression<a id="_idIndexMarker541"/> and new <strong class="source-inline">switch</strong> statement. This will also<a id="_idIndexMarker542"/> be the first time we see the new arrow operator. Here is the expression version of <span class="No-Break">the switches:</span></p>
			<pre class="source-code">
        postage = switch (zone) {
            case 1 -&gt; 2.25;
            case 2 -&gt; 4.50;
            case 3 -&gt; 7.75;
            default -&gt; 10.00;
        };</pre>
			<p>The break is gone as any match will end the switch. To match one of multiple items, we can use the comma operator to create a list. The arrow operator (<strong class="source-inline">-&gt;</strong>) points at the value that will be <a id="_idIndexMarker543"/>assigned <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">continent</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        continent = switch (country) {
            case "UK", "France", "Germany" -&gt; "Europe";
            case "Canada", "USA", "Mexico" -&gt; "North America";
            default -&gt; "Not found";
        };</pre>
			<p>Unlike a <strong class="source-inline">switch</strong> expression, a <strong class="source-inline">switch</strong> statement does not return a value, but the matching case performs some action such as calling <span class="No-Break">a method:</span></p>
			<pre class="source-code">
        switch (continent) {
           case "Europe":
                showEuropeMap();
                break;
            case "North America":
                showNorthAmericaMap();
                break;
            default:
                showNotFound();
        }</pre>
			<p>Here is the new <span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
        switch (continent) {
            case "Europe" -&gt; showEuropeMap();
            case "North America" -&gt; showNorthAmericaMap();
            default -&gt; showNotFound();
        }</pre>
			<p>There is another type of switch that, as<a id="_idIndexMarker544"/> of this writing, is only available as a preview feature in Java 19, and that is the pattern-matching switch. As a preview feature, it may change when it becomes<a id="_idIndexMarker545"/> formally part of the language or even dropped from the language. I see this as an exciting new type of switch—you can see it in <span class="No-Break">action here:</span></p>
			<pre class="source-code">
        String designation;
        Object value = 4;
        designation = switch (value) {
            case Integer I when i &lt; 12 -&gt;
               "child";
            case Integer i when i &lt; 18 -&gt;
               "teenage";
            case Integer i when i &lt; 25 -&gt;
               "young adult";
            case Integer i when i &lt; 65 -&gt;
               "adult";
            default -&gt;
               "senior";
        };</pre>
			<p>Pattern matching will only work with objects and not primitives unless they are in one of Java’s primitive wrapper classes. When we assign the value <strong class="source-inline">4</strong> to the variable value of type <strong class="source-inline">Object</strong>, the compiler will auto-box the <strong class="source-inline">int</strong> primitive into an object of type <strong class="source-inline">Integer</strong>. Each <strong class="source-inline">case</strong> statement uses the class type in the case rather than a literal value. It also allows you to assign an identifier—in our <span class="No-Break">case, </span><span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break">.</span>
Following the identifier is the new <strong class="source-inline">when</strong> keyword, after which you can write any valid Boolean expression. Only if the type matches and the logical expression after the <strong class="source-inline">when</strong> keyword is <strong class="source-inline">true</strong> is the case <strong class="source-inline">true</strong>. This should reduce the number of <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> <strong class="source-inline">if</strong>/ <strong class="source-inline">else</strong> <strong class="source-inline">if</strong>/ <strong class="source-inline">else</strong> <strong class="source-inline">if</strong> structures in your program. You will<a id="_idIndexMarker546"/> need Java 19 installed on your computer to experiment with this <span class="No-Break">preview feature.</span></p>
			<p>With how Java handles <a id="_idIndexMarker547"/>decisions out of the way, we can now look at how Java <span class="No-Break">handles exceptions.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor164"/>Handling exceptions</h1>
			<p>In Java, when things go <a id="_idIndexMarker548"/>wrong, they can be classified as errors or exceptions. An error is a problem that cannot be recovered from. An exception is an error that can be detected in your<a id="_idIndexMarker549"/> code such that you can possibly recover from it. For example, a recursion that never ends will result in a <strong class="source-inline">StackOverflowError</strong>-type error. Converting the <strong class="source-inline">Bob</strong> string to an integer will result in a <span class="No-Break"><strong class="source-inline">NumberFormatException</strong></span><span class="No-Break"> exception.</span></p>
			<p>Here is a diagram of the primary <span class="No-Break">exception classes:</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B19088_07_01.jpg" alt="Figure 7.1 – The exception hierarchy"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The exception hierarchy</p>
			<p>Exceptions are objects of classes named after the type of exception that has occurred. In the diagram, you can see that at the root of the hierarchy is the <strong class="source-inline">Throwable</strong> class. From <strong class="source-inline">Throwable</strong>, we have two subclasses: <strong class="source-inline">Error</strong> and <strong class="source-inline">Exception</strong>. The subclasses of <strong class="source-inline">Error</strong> are named after the <a id="_idIndexMarker550"/>errors that may occur during program execution. These are errors that generally cannot be recovered from and should lead to the <span class="No-Break">program ending.</span></p>
			<p>As it may be possible to recover from an exception as opposed to an error, these types of problems belong to the <strong class="source-inline">Exception</strong> branch. This branch is divided into two categories: <strong class="bold">checked</strong> and <strong class="bold">unchecked</strong>. A checked exception<a id="_idIndexMarker551"/> must come from a block of code called <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong>. Failing to use a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block will generate a compiler error. You must resolve this; otherwise, you cannot compile <span class="No-Break">your code.</span></p>
			<p>Unchecked exceptions <a id="_idIndexMarker552"/>do not require a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. The compiler will happily compile code that might generate an unchecked exception without this code in a try/catch block. Should you decide not to handle an unchecked exception, your program <span class="No-Break">will end.</span></p>
			<p>Let’s look at code that could have both types <span class="No-Break">of exceptions:</span></p>
			<pre class="source-code">
public class FileException {
2    
3      public void doCheckedException() {
4          List&lt;String&gt; fileContents = null;
5          Path path2 = Paths.get("c:/temp/textfile.tx"");
6          try {
7              fileContents = Files.readAllLines(path2);
8                 System.out.printf("%s%", fileContents);
9          } catch (NoSuchFileException ex) {
10              ex.printStackTrace();
11         } catch(IOException ex) {
12              ex.printStackTrace();
13         }
14      }
15
16      public void doUncheckedException() {
17          int dividend = 8;
18          int divisor = 0;
19          int result = dividend / divisor;
20          System.out.printf("%d%", result);
21      }
22    
23      public void perform() {
24          checkedException();
25          uncheckedException();
26      }
27
28      public static void main(String[] args) {
29          new FileException().perform();
30      }
31  }</pre>
			<p>Let’s review the important <span class="No-Break">code lines.</span></p>
			<p><em class="italic">Line 3</em> is the first method that contains code that could result in a checked exception <span class="No-Break">being thrown.</span></p>
			<p><em class="italic">Line 4</em> declares a <strong class="source-inline">List</strong> variable <a id="_idIndexMarker553"/>and sets it to <strong class="source-inline">null</strong>, which sets the <strong class="source-inline">List</strong> reference to zero. Local variables are not initialized, so they may already contain a value based on where in memory the reference is placed. If you do not properly allocate the <strong class="source-inline">List</strong> reference, usually done with <strong class="source-inline">null</strong>, there will be a compiler error in <em class="italic">line 11</em>. This will end <span class="No-Break">the program.</span></p>
			<p><em class="italic">Line 5</em> defines a path to a file. The <strong class="source-inline">Paths.get()</strong> method does not verify that the file exists, so no exception is thrown if the file does <span class="No-Break">not exist.</span></p>
			<p><em class="italic">Line 6</em> is the beginning of our <strong class="source-inline">try</strong> block where any code that may throw a checked exception is written. You may have lines of code in a <strong class="source-inline">try</strong> block that do not throw <span class="No-Break">an exception.</span></p>
			<p>In <em class="italic">line 7</em>, using <strong class="source-inline">Files.readAllLines()</strong>, each line in the file is added to the <strong class="source-inline">List</strong> variable. This is where an invalid file <strong class="source-inline">Path</strong> object can result in a checked exception <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">IOException</strong></span><span class="No-Break">.</span></p>
			<p><em class="italic">Line 8</em> is the end of the <strong class="source-inline">try</strong> block and the beginning of the first <strong class="source-inline">catch</strong> block. A <strong class="source-inline">catch</strong> block takes as a parameter a reference to an <strong class="source-inline">Exception</strong> object that is created by the JVM when the exception is detected in the code inside the <strong class="source-inline">try</strong> block while the program executes. The <strong class="source-inline">NoSuchFileException</strong> exception is a subclass of <strong class="source-inline">IOException</strong>. Subclass exceptions must be handled before the <span class="No-Break">superclass exception.</span></p>
			<p><em class="italic">Line 9</em> is the body of a <strong class="source-inline">catch</strong> block, where you can write code to handle the error in such a way that the program does not need to end. All <strong class="source-inline">Exception</strong> objects have a method that displays the stack trace. You will not handle errors this way in production. When we discuss logging in the next chapter, we will see a <span class="No-Break">best-practice approach.</span></p>
			<p>In <em class="italic">line 10</em>, we have a second <strong class="source-inline">catch</strong> block. This is the <strong class="source-inline">IOException</strong> class. The code that reads the file can throw either a <strong class="source-inline">NoSuchFileException</strong> exception or an <strong class="source-inline">IOException</strong> exception. Some programmers may just catch <strong class="source-inline">IOException</strong>. As <strong class="source-inline">NoSuchFileException</strong> is a subclass of <strong class="source-inline">IOException</strong>, polymorphism allows you have both exceptions caught in one <strong class="source-inline">catch</strong> block that expects <strong class="source-inline">IOException</strong>. My preference is to use specific exception classes <span class="No-Break">where possible.</span></p>
			<p>Just as in <em class="italic">line 9</em>, here, in <em class="italic">line 11</em>, we are just printing the stack trace if this exception is <span class="No-Break">caught here.</span></p>
			<p>It is in <em class="italic">line 13</em> that a compiler<a id="_idIndexMarker554"/> error can occur if the <strong class="source-inline">fileContents</strong> variable is either not assigned <strong class="source-inline">null</strong> or assigned a reference from calling the <span class="No-Break"><strong class="source-inline">File.readAllLines</strong></span><span class="No-Break"> method.</span></p>
			<p>During development, the use of the <strong class="source-inline">printStackTrace</strong> method in an <strong class="source-inline">Exception</strong> object can be useful. When we move to production code, we should never make this method call. In the next chapter, we will see how to use logging to preserve this information without it appearing in <span class="No-Break">the console.</span></p>
			<p><em class="italic">Line 16</em> is a method that will perform division by zero. This will generate an unchecked <strong class="source-inline">ArithmeticException</strong> exception. For this reason, you are not required to use a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block. As the code is dividing by zero, an exception will be thrown, a stack trace will appear if this is a console application, and the program will end. A GUI program has no place to show a stack trace, so it will appear to just <span class="No-Break">end suddenly.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor165"/>The stack trace</h2>
			<p>When your program ends due to an <a id="_idIndexMarker555"/>exception or after catching an exception, you can <a id="_idIndexMarker556"/>display a stack trace. The stack trace will appear in the console window. It is a list of every line of code that led to the exception before being caught or after the program ends. Here is the stack trace from the <strong class="source-inline">doCheckedException</strong> method when the filename in the <strong class="source-inline">Path</strong> object cannot <span class="No-Break">be found:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B19088_07_02.jpg" alt="Figure 7.2 – The stack trace explicitly displayed when an exception occurs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The stack trace explicitly displayed when an exception occurs</p>
			<p>As you can see, the<a id="_idIndexMarker557"/> exception has traveled through several methods, many of which occurred in a Java library and not your code. To use this information to locate the <a id="_idIndexMarker558"/>possibly offending source code, go through the list and locate the first entry that comes from your code, starting from the beginning of <span class="No-Break">the trace:</span></p>
			<pre class="source-code">
at com.kenfogel.FileException.doCheckedException(FileException.java:17)</pre>
			<p>This line tells us that the exception happened in the <strong class="source-inline">doCheckedException</strong> method on <span class="No-Break"><em class="italic">line 17</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor166"/>Ending the program</h2>
			<p>In some situations, you <a id="_idIndexMarker559"/>may wish to end a program after catching its exception. You can end most programs with <strong class="source-inline">System.exit(n)</strong>, where <strong class="source-inline">n</strong> is a number you assign to <span class="No-Break">this error:</span></p>
			<pre class="source-code">
        } catch(IOException ex) {
            ex.printStackTrace();
            System.exit(12);
        }</pre>
			<p>The number—in this example, <strong class="source-inline">12</strong>—maps to a known error condition that must end the program. Here, after the stack trace is displayed, the <span class="No-Break">program ends.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor167"/>The throw and throws statements</h2>
			<p>If an exception is thrown in a method, Java looks for a <strong class="source-inline">catch</strong> block. If there is no <strong class="source-inline">catch</strong> block in the method that threw the exception, then Java looks into the method that called the offending method. This <a id="_idIndexMarker560"/>continues until it gets to the <strong class="source-inline">main</strong> method, and at that point, the program ends. There are<a id="_idIndexMarker561"/> situations where you will want to catch an exception where it happens, but then you want to re-throw it to whatever <a id="_idIndexMarker562"/>method that<a id="_idIndexMarker563"/> came before it that has a <strong class="source-inline">catch</strong> block. In this <strong class="source-inline">catch</strong> block, we are<a id="_idIndexMarker564"/> displaying the stack trace to the console and then re-throwing <span class="No-Break">the exception:</span></p>
			<pre class="source-code">
        } catch(IOException ex) {
            ex.printStackTrace();
            throw ex;
        }</pre>
			<p>To be able to re-throw, we must add to the method a <span class="No-Break"><strong class="source-inline">throws</strong></span><span class="No-Break"> clause:</span></p>
			<pre class="source-code">
    public void doCheckedException() throws IOException {</pre>
			<p>When you use <strong class="source-inline">throws</strong>, whichever method calls <strong class="source-inline">doCheckedException</strong> must do this in a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block, <span class="No-Break">as shown:</span></p>
			<pre class="source-code">
        try {
            checkedException();
        } catch(IOException ex) {
            ex.printStackTrace();
        }</pre>
			<p>We can also use the <strong class="source-inline">throws</strong> clause to define that a method has a checked exception, but it will not be handled in the method. This means we can just call <strong class="source-inline">checkedException()</strong> without a <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block, as the method shows that it will be thrown to whichever <strong class="source-inline">try</strong>/<strong class="source-inline">catch</strong> block in another method called <span class="No-Break">this method.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor168"/>The finally block</h2>
			<p>There can be a third block for <a id="_idIndexMarker565"/>handling exceptions, called the <strong class="source-inline">finally</strong> block. In this block, you can write any code that you wish to execute if an exception is thrown <a id="_idIndexMarker566"/>or not. In this example, a message is displayed regardless of whether an exception is thrown <span class="No-Break">or not:</span></p>
			<pre class="source-code">
public void doFinallyExample(int dividend, int divisor) {
    int result = 0;
    try {
        result = dividend / divisor;
    } catch (ArithmeticException ex) {
        ex.printStackTrace();
    } finally {
        System.out.printf(
            "Finally block is always executed%n");
    }
}</pre>
			<p>If the divisor is valid—not zero—then the code in the <strong class="source-inline">finally</strong> block is executed. If the divisor is invalid—is zero—the code in the <strong class="source-inline">catch</strong> block is executed followed by the code in the <span class="No-Break"><strong class="source-inline">finally</strong></span><span class="No-Break"> block.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not confuse <strong class="source-inline">finally</strong> with the <strong class="source-inline">finalize</strong> method. The <strong class="source-inline">finally</strong> block is useful. The <strong class="source-inline">finalize</strong> method is not useful and should not <span class="No-Break">be used.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor169"/>Creating your own exception classes</h2>
			<p>The name of an exception class is the description of the problem that led to the exception being thrown. You can create your own exceptions and then throw your custom exception when you<a id="_idIndexMarker567"/> detect a serious problem in your code. The<a id="_idIndexMarker568"/> first step is to create an exception class, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
public class NegativeNumberException extends Exception{}</pre>
			<p>This is a checked exception class. If you do not want it to be checked, then extend <strong class="source-inline">RuntimeException</strong>. You can add additional methods or override methods in <strong class="source-inline">Exception</strong>, but this is not necessary. You create custom exceptions to define exceptions unique to your program that are not sufficiently described in the existing family of <span class="No-Break">exception classes.</span></p>
			<p>Now, we need some code that will throw <span class="No-Break">this exception:</span></p>
			<pre class="source-code">
    public void doCustomException(int value) 
                     throws NegativeNumberException {
        if (value &lt; 0) {
            throw new NegativeNumberException();
        }
        System.out.printf("value = %d%n", value);
    }</pre>
			<p>Now, we need code that will call this method. As the method we are calling has a <strong class="source-inline">throws</strong> clause, we must treat it as a checked exception, and we must use a <span class="No-Break"><strong class="source-inline">try</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">catch</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
    public void makeCustomException() {
        try {
            doCustomException(-1);
        } catch (NegativeNumberException ex) {
            ex.printStackTrace();
        }
    }</pre>
			<p>Here is the stack trace that occurred when this <span class="No-Break">code executed:</span></p>
			<pre class="source-code">
com.kenfogel.NegativeNumberException
  at com.kenfogel.FileException.doCustomException(FileException.java:39)
  at com.kenfogel.FileException.makeCustomException(FileException.java:46)
  at com.kenfogel.FileException.perform(FileException.java:69)
  at com.kenfogel.FileException.main(FileException.java:73)</pre>
			<p>You can see that the<a id="_idIndexMarker569"/> exception class we created is the exception reported in the <span class="No-Break">stack trace.</span></p>
			<p>There is one last issue to point out in regard to exceptions. Many languages such as C# and JavaScript do not have checked exceptions. The decision to catch these exceptions is solely at the discretion<a id="_idIndexMarker570"/> of <span class="No-Break">the developer.</span></p>
			<p>Throwing an exception is a slow process in the JVM. It is not something you might notice, but if it happens often enough, it will result in slower execution of the program. For this reason, never use exception handling as part of the program logic. Exceptions are serious issues that, in most cases, imply an error or bug that can affect the outcome of the program. If you can detect an error in your code, typically by testing a value with an <strong class="source-inline">if</strong> statement, you should handle it with the code you write and not by expecting or throwing <span class="No-Break">an exception.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor170"/>Summary</h1>
			<p>In this chapter, we learned about how Java code is organized into blocks as defined by an opening and closing brace. The blocks can be an entire class, each method in the class, and a body of iteration and decision statements. From there, we learned how to classify lines of code as statements <span class="No-Break">or expressions.</span></p>
			<p>Operators were the next topic. We reviewed the math and logic operators and how they are combined. The <strong class="source-inline">cast</strong> operator for converting from one type to another was <span class="No-Break">also shown.</span></p>
			<p>Next up were the two most common coding structures: iterations and decisions. The classic <strong class="source-inline">for</strong> loop, a loop where the number of iterations is known before the loop begins, was presented. The second style of loops was <strong class="source-inline">while</strong> and <strong class="source-inline">do</strong>/<strong class="source-inline">while</strong> loops. These loops do not know how many iterations there will be. This is determined in the repeating block <span class="No-Break">of code.</span></p>
			<p>Decision-making was next up. We looked at the <strong class="source-inline">if</strong> and <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> statements. These are effectively the same as found in any language that traces its lineage to the C language. The second decision structure we covered was the <strong class="source-inline">switch</strong> statement. As with <strong class="source-inline">if</strong>, it is virtually unchanged from its C roots. The good news is that this style of switch has been enhanced with three new versions. </p>
			<p>The last topic we looked at was exceptions. We looked at what exception classes and objects are and which category, checked or unchecked, they fall into. How we can handle exceptions rather than just let the program end was presented as well. Creating our own named exceptions and how we can use them was the last topic <span class="No-Break">we covered.</span></p>
			<p>At this point, you should feel comfortable reading Java code. In our next chapter, we will look at additional features of the language and how they can be used to write <span class="No-Break">cleaner code.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor171"/>Further reading</h1>
			<ul>
				<li><em class="italic">Exceptions in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45"><span class="No-Break">https://medium.com/interviewnoodle/exception-in-java-89a0b41e0c45</span></a></li>
			</ul>
		</div>
	</body></html>