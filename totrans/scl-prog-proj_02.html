<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Developing a Retirement Calculator</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will put into practice the features of the Scala language seen in the first chapter. We will also introduce other elements of the Scala language and SDK to develop the model and logic for a retirement calculator. This calculator will help people work out how long and how much to save to have a comfortable retirement.</p>
<p>We will use the <strong>test-driven development</strong> (<strong>TDD</strong>) technique to develop the different functions. I encourage you to try writing the body of the functions yourself before looking at the solution. Also, it would be better to retype the code rather than copy/pasting it. You will remember it more and will have a sense of what it feels like to use IntelliJ's completion and editor. Do abuse the autocompletion with <em>Ctrl</em> + spacebar. You will not only type faster, but you will also discover what functions are available in a given class.</p>
<p>You are going to get a strong foundation for building more complex applications using the Scala language.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Calculating the future capital</li>
<li>Calculating when you can retire</li>
<li>Using market rates</li>
<li>Packaging the application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project overview</h1>
                </header>
            
            <article>
                
<p class="mce-root">Using some parameters such as your net income, your expenses, your initial capital, and so on, we will create functions to calculate the following:</p>
<ul>
<li class="mce-root">Your future capital at retirement</li>
<li>Your capital after a number of years in retirement</li>
<li>How long you need to save to be able to retire</li>
</ul>
<p>We will first use a fixed interest rate for these calculations. After that, we will load market data from <kbd>.tsv</kbd> files, then refactor the previous functions to simulate what could happen during the investment period.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating the future capital</h1>
                </header>
            
            <article>
                
<p>The first thing you need to know when planning for retirement is how much capital you can get at your chosen retirement date. For now, we will assume that you invest your savings every month at a constant rate. To simplify things, we will ignore the effects of inflation, hence the capital calculated will be in today's money and the interest rate will be calculated as<em> real rate</em> = <em>nominal interest rate</em> - <em>inflation rate</em>.</p>
<p>We intentionally do not mention any currency in the rest of this chapter. You can consider that the amounts are in USD, EUR, or any other currency. It will not change the results as long as all the amounts are expressed in the same currency.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a unit test for the accumulation phase</h1>
                </header>
            
            <article>
                
<p>We want a function that behaves similarly to the <kbd>FV</kbd> function in Excel: it calculates the future value of an investment based on a constant interest rate. As we follow a TDD approach, the first thing to do is create a failing test:</p>
<ol>
<li>Create a new Scala project called <kbd>retirement_calculator</kbd>. Follow the same instructions as in <a href="db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml" target="_blank">Chapter 1</a>, <em>Writing Your First Program</em>.</li>
</ol>
<ol start="2">
<li>Right-click on the directory <kbd>src/main/scala</kbd> and select <span class="packt_screen">New</span> | <span class="packt_screen">P</span><span class="packt_screen">ackage</span>. Name it <kbd>retcalc</kbd>.</li>
<li>Right-click on the new package and select <span class="packt_screen">New</span> | <span class="packt_screen">Scala class</span>. Name it <kbd>RetCalcSpec</kbd>.</li>
<li>Enter the following code:</li>
</ol>
<pre><span>package </span>retcalc<br/><br/><span>import </span>org.scalactic.{Equality<span>, </span>TolerantNumerics<span>, </span>TypeCheckedTripleEquals}<br/><span>import </span>org.scalatest.{Matchers<span>, </span>WordSpec}<br/><br/><span>class </span>RetCalcSpec <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals {<br/><br/>  <span>implicit val </span><span>doubleEquality</span>: Equality[<span>Double</span>] = <br/>    TolerantNumerics.tolerantDoubleEquality(<span>0.0001</span>)<br/><span><br/></span><span>  </span><span>"RetCalc.futureCapital" </span>should {<br/>    <span>"calculate the amount of savings I will have in n months" </span>in {<span><br/>      </span><span>val </span>actual = RetCalc.<span>futureCapital</span>(<br/>        interestRate = <span>0.04 </span>/ <span>12</span><span>, </span>nbOfMonths = <span>25 </span>* <span>12</span><span>, <br/>        </span>netIncome = <span>3000</span><span>, </span>currentExpenses = <span>2000</span><span>, <br/></span><span>        </span>initialCapital = <span>10000</span>)<br/>      <span>val </span>expected = <span>541267.1990<br/></span><span>      </span>actual should ===(expected)<br/>  }<br/>}</pre>
<p>As seen in <a href="db4d7854-92ff-43c8-a87b-2d605bf88d1b.xhtml">Chapter 1</a>, <em>Writing Your First Program</em>, in the section <em>Creating my first project</em>, we used the <kbd>WordSpec</kbd> ScalaTest style. We also used a handy feature called <kbd>TypeCheckedTripleEquals</kbd>. It provides a powerful assertion, <kbd>should ===</kbd>, that ensures at compile time that both sides of the equality have the same type. The default ScalaTest assertion <kbd>should</kbd> verifies the type equality at runtime. We encourage you to always use <kbd>should ===</kbd>, as it will save a lot of time when refactoring code.</p>
<p>Besides, it lets us use a certain amount of tolerance when comparing double values. Consider the following declaration:</p>
<pre><span>implicit val </span><span>doubleEquality</span>: Equality[<span>Double</span>] =<br/>  TolerantNumerics.tolerantDoubleEquality(<span>0.0001</span>)</pre>
<p>It will let a <kbd>double1 should === (double2)</kbd> assertion pass if the absolute difference between <kbd>double1</kbd> and <kbd>double2</kbd> is lower than <kbd>0.0001</kbd>. This allows us to specify expected values to only the fourth digit after the decimal point. It also avoids hitting floating point calculation issues. For instance, enter the following code in the Scala Console:</p>
<pre>scala&gt; val double1 = 0.01 -0.001 + 0.001<br/>double1: Double = 0.010000000000000002<br/><br/>scala&gt; double1 == 0.01<br/>res2: Boolean = false</pre>
<p>It can be a bit surprising, but this is a well-known problem in any language that encodes floating point numbers in binary. We could have used <kbd>BigDecimal</kbd> instead of <kbd>Double</kbd> to avoid this kind of issue, but for our purposes, we do not need the additional precision offered by <kbd>BigDecimal</kbd>, and <kbd>BigDecimal</kbd> computations are much slower.</p>
<p>The body of the test is quite straightforward; we call a function and expect a value. As we wrote the test first, we had to work out what would be the expected result before writing the production code. For non-trivial calculations, I generally use Excel or LibreOffice. For this function, the expected value can be obtained by using the formula <span><kbd>=-FV(0.04/12,25*12,1000,10000,0)</kbd>. We assume that the user saves the full difference between his or her income and his/her expenses every month. Hence, the</span> PMT <span>parameter in the <kbd>FV</kbd> function is</span> <kbd>1,000 = netIncome - currentExpenses</kbd><span>.<br/></span></p>
<p>We now have a failing test, but it does not compile, as the <kbd>RetCalc</kbd> object and its <kbd>futureCapital</kbd> function do not exist yet. Create a <kbd>RetCalc</kbd> object in a new package <kbd>retcalc</kbd> in <kbd>src/main/scala</kbd>, then select the red <kbd>futureCapital</kbd> call in the unit test and hit <em>Alt</em> + <em>Enter</em> to generate the function body. Fill in the names and types of the parameters. You should end up with the following code in <kbd>RetCalc.scala</kbd>:</p>
<pre><span>package </span>retcalc<br/><br/><span>object </span>RetCalc {<br/>  <span>def </span><span>futureCapital</span>(interestRate: <span>Double, </span>nbOfMonths: <span>Int, </span>netIncome:     <br/><span>  Int, </span>currentExpenses: <span>Int, </span>initialCapital: <span>Double</span>): <span>Double </span>= ???<br/>}</pre>
<p>Open <kbd>RetCalcSpec</kbd>, and type <em>Ctrl</em> + <em>Shift</em> + <em>R</em> to compile and run it. Everything should compile and the test should fail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing futureCapital</h1>
                </header>
            
            <article>
                
<p>We now have a failing test, so it is time to make it pass by writing the production code. If we use <kbd>initialCapital = 10,000</kbd> and <kbd>monthlySavings = 1,000</kbd>, the computation we need to perform can be decomposed as follows:</p>
<ul>
<li>For month <kbd>0</kbd>, before any savings, we have <kbd>capital0 = initialCapital = 10,000</kbd>.</li>
<li>For month <kbd>1</kbd>, our initial capital generated some interest. We also saved 1,000 more. We therefore have <kbd>capital1 = capital0 *(1 + monthlyInterestRate) + 1,000</kbd></li>
<li>For month <kbd>2</kbd>, we have <kbd>capital2 = capital1 *(1 + monthlyInterestRate) + 1,000</kbd></li>
</ul>
<p>There is a mathematical formula to compute <kbd>capitalN</kbd> from the parameters, but we will not use it here. This formula works well for fixed interest rates, but we will use variable interest rates later in this chapter.</p>
<p>Here is the body of the function:</p>
<pre><span>def </span><span>futureCapital</span>(interestRate: <span>Double, </span>nbOfMonths: <span>Int, </span>netIncome: <span>Int,</span><span> </span>currentExpenses: <span>Int, </span>initialCapital: <span>Double</span>): <span>Double </span>= {<br/>  <span>val </span>monthlySavings = netIncome - currentExpenses<br/><br/>  <span>def nextC</span><span>apital</span>(accumulated: <span>Double, </span>month: <span>Int</span>): <span>Double </span>=<br/>    accumulated * (<span>1 </span>+ interestRate) + monthlySavings<br/><br/>  (<span>0 until</span> nbOfMonths).foldLeft(initialCapital)(nextCapital)<br/>}</pre>
<p>We first generate a collection of integers using <kbd>0 to nbOfMonths</kbd>, and we then iterate through it using <kbd>foldLeft</kbd>. <kbd>foldLeft</kbd> is one of the most powerful functions in the Scala collection library. Many other functions in the <kbd>collections</kbd> library could be implemented just by using <kbd>foldLeft</kbd>, such as <kbd>reverse</kbd>, <kbd>last</kbd>, <kbd>contains</kbd>, <kbd>sum</kbd>, and so on.</p>
<p>In the Scala SDK, the signature of <kbd>foldLeft</kbd> is as follows:</p>
<pre><span>def </span><span>foldLeft</span>[<span>B</span>](z: <span>B</span>)(op: (<span>B</span><span>, </span><span>A</span>) =&gt; <span>B</span>): <span>B</span></pre>
<p>You can see its definition in IntelliJ by pointing at it with the mouse and using cmd + left-click. This introduces some new syntax:</p>
<ul>
<li><kbd>[B]</kbd> means that the function has a <strong>type parameter</strong> named <kbd>B</kbd>. When we call the function, the compiler automatically infers what <kbd>B</kbd> is, depending on the type of the <kbd>z: B</kbd> argument. In our code, the <kbd>z</kbd> argument is <kbd>initialCapital</kbd>, of type <kbd>Double</kbd>. Therefore, our call to <kbd>foldLeft</kbd> in <kbd>futureCapital</kbd> will behave as if the function was defined with <kbd>B = Double</kbd>:</li>
</ul>
<p style="padding-left: 90px"><kbd>def foldLeft(z: Double)(op: (Double, A) =&gt; Double): Double</kbd>.</p>
<ul>
<li>The function has two parameter lists. Scala allows you to have many parameter lists. Each list can have one or many parameters. This does not change the behavior of the function; it is just a way of separating the concerns of each parameter list.</li>
<li><kbd>op: (B, A) =&gt; B</kbd> means that <kbd>op</kbd> must be a function that has two parameters of type <kbd>B</kbd> and <kbd>A</kbd> and returns a value of type <kbd>B</kbd>. Since <kbd>foldLeft</kbd> is a function that takes another function as an argument, we say that <kbd>foldLeft</kbd> is a <strong>higher order function</strong>.</li>
</ul>
<p>If we consider a <kbd>coll</kbd> collection, <kbd>foldLeft</kbd> works as follows:</p>
<ol>
<li>It creates a <kbd>var acc = z</kbd> accumulator then calls the <kbd>op</kbd> function:</li>
</ol>
<p style="padding-left: 90px"><kbd>acc = op(acc, coll(0))</kbd> </p>
<ol start="2">
<li>It carries on calling <kbd>op</kbd> with each element of the collection:</li>
</ol>
<p style="padding-left: 90px"><kbd>acc = op(acc, coll(i))</kbd></p>
<ol start="3">
<li>It returns <kbd>acc</kbd> once it has iterated through all elements of the collection</li>
</ol>
<p>In our <kbd>futureCapital</kbd> function, we pass <kbd>op = nextCapital</kbd>. The <kbd>foldLeft</kbd> will iterate through all <kbd>Int</kbd> between <kbd>1</kbd> and <kbd>nbOfMonths</kbd>, each time computing the capital using the previous capital. Note that, for now, we do not use the <kbd>month</kbd> parameter in <kbd>nextCapital</kbd>. We must declare it, though, because the <kbd>op</kbd> <span>function</span> in <kbd>foldLeft</kbd> must have two parameters.</p>
<p>You can now run the <kbd>RetCalcSpec</kbd> unit test again. It should pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring the production code</h1>
                </header>
            
            <article>
                
<p>In the TDD approach, it is common to refactor the code once we have passing tests. If our test coverage is good, we should not have any fear of changing the code, because any mishap should be flagged by a failing test. This is known as a <strong>Red-Green-Refactor</strong> cycle.</p>
<p>Change the body of <kbd>futureCapital</kbd> with the following code:</p>
<pre><span>def </span><span>futureCapital</span>(interestRate: <span>Double, </span>nbOfMonths: <span>Int, </span>netIncome: <span>Int,</span><span> </span>currentExpenses: <span>Int, </span>initialCapital: <span>Double</span>): <span>Double </span>= {<br/>  <span>val </span>monthlySavings = netIncome - currentExpenses<br/>  (0<span> until</span> nbOfMonths).foldLeft(initialCapital)(<br/>    (accumulated<span>, </span>_) =&gt; accumulated * (<span>1 </span>+ interestRate) + <br/>     monthlySavings)<br/>}</pre>
<p>Here, we have inlined the <kbd>nextCapital</kbd> function in the <kbd>foldLeft</kbd> call. In Scala, we can define an <strong>anonymous function</strong> using the syntax:</p>
<pre>(param1, param2, ..., paramN) =&gt; function body.</pre>
<p>We saw earlier that the <kbd>month</kbd> parameter in <kbd>nextCapital</kbd> was not used. In an anonymous function, it is a good practice to name any unused parameter with <kbd>_</kbd>. A parameter named <kbd>_</kbd> cannot be used in the function body. If you try to replace the <kbd>_</kbd> character with a name, IntelliJ will underline it. If you hover the mouse over it, you will see a popup stating <kbd>Declaration is never used</kbd>. You can then hit <em>Alt</em> + <em>Enter</em> and choose to remove the unused element to automatically change it back to <kbd>_</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a test for the decumulation phase</h1>
                </header>
            
            <article>
                
<p>Now you know how much capital you can expect at your retirement date. It turns out you can reuse the same <kbd>futureCapital</kbd> <span>function,</span> to work out how much capital will be left for your heirs.</p>
<p>Add the following test in <kbd>RetCalcSpec</kbd>, underneath the previous unit test, and run it. It should pass:</p>
<pre><span>"RetCalc.futureCapital" </span>should {<br/>  <span>"calculate how much savings will be left after having taken a pension <br/>    for n months" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>futureCapital</span>(<br/>      interestRate = <span>0.04</span>/<span>12</span><span>, </span>nbOfMonths = <span>40 </span>* <span>12</span><span>,<br/></span><span>      </span>netIncome = <span>0</span><span>, </span>currentExpenses = <span>2000</span><span>, </span>initialCapital = <br/>      <span>541267.1990</span>)<br/>    <span>val </span>expected = <span>309867.53176<br/></span><span>    </span>actual should ===(expected)<br/>  }<br/>}</pre>
<p>So, if you live for 40 years after your retirement date, spend the same amount every month, and don't have any other income, you will still have a significant capital left for your heirs. If the remaining capital was negative, that would have meant that you would have run out of money at some point during your retirement and it is an outcome we want to avoid.</p>
<p>Feel free to call the function from the Scala Console and try different values that would match more closely to your personal situation. Try different values for the interest rate and observe how you can end up with a negative capital if the rate is low.</p>
<p>Note that, in a production system, you would certainly add more unit tests to cover some other edge cases and make sure that the function will not crash. As we will cover error handling in <a href="f7fa24eb-8f31-4201-ba7c-c1e32518df8b.xhtml" target="_blank">Chapter 3</a>, <em>Handling Errors</em>, we can assume that the test coverage of <kbd>futureCapital</kbd> is good enough for now.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Simulating a retirement plan</h1>
                </header>
            
            <article>
                
<p>Now that we know how to calculate the capital at retirement and after death, it would be useful to combine the two calls in a single function. This function will simulate a retirement plan in one go.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a failing unit test</h1>
                </header>
            
            <article>
                
<p>Here is the unit test you need to add to <kbd>RetCalcSpec</kbd>:</p>
<pre><span>"RetCalc.simulatePlan" </span>should {<br/>  <span>"calculate the capital at retirement and the capital after death" </span>in {<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <br/>    RetCalc.<span>simulatePlan</span>(<br/>      interestRate = <span>0.04 </span>/ <span>12</span><span>,<br/></span><span>      </span>nbOfMonthsSaving = <span>25 </span>* <span>12</span><span>, </span>nbOfMonthsInRetirement = <span>40 </span>* <span>12</span><span>,<br/></span><span>      </span>netIncome = <span>3000</span><span>, </span>currentExpenses = <span>2000</span><span>,<br/></span><span>      </span>initialCapital = <span>10000</span>)<br/>    capitalAtRetirement should === (<span>541267.1990</span>)<br/>    capitalAfterDeath should === (<span>309867.5316</span>)<br/>  }<br/>}</pre>
<p>Select the call to <kbd>simulatePlan</kbd>, and hit <em>Alt</em> + <em>Enter</em> to let IntelliJ create the function for you in <kbd>RetCalc</kbd>. It should have the following signature:</p>
<pre><span>def </span><span>simulatePlan</span>(interestRate: <span>Double,<br/></span><span>                 </span>nbOfMonthsSavings: <span>Int, </span>nbOfMonthsInRetirement: <span>Int,<br/></span><span>                 </span>netIncome: <span>Int, </span>currentExpenses: <span>Int, </span>initialCapital: <br/>                 <span>Double</span>) : (<span>Double, Double</span>) = ???</pre>
<p>Now compile the project with cmd + <em>F9</em>, and run <kbd>RetCalcSpec</kbd>. It should fail since the <kbd>simulatePlan</kbd> <span>function</span> must return two values. The simplest way of modeling the return type is to use <kbd>Tuple2</kbd>. In Scala, a tuple is an immutable data structure which holds several objects of different types. The number of objects contained in a tuple is fixed. It is akin to a case class, which does not have specific names for its attributes. In type theory, we say that a tuple or a case class is a <strong>product type</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with tuples</h1>
                </header>
            
            <article>
                
<p>Type the following in the Scala Console to get more familiar with tuples. Feel free to experiment with different types and sizes of tuples:</p>
<pre>scala&gt; val tuple3 = (1, "hello", 2.0)<br/>tuple3: (Int, String, Double) = (1,hello,2.0)<br/><br/>scala&gt; tuple3._1<br/>res1: Int = 1<br/><br/>scala&gt; tuple3._2<br/>res2: String = hello<br/><br/>scala&gt; val (a, b, c) = tuple3<br/><br/>a: Int = 1<br/>b: String = hello<br/>c: Double = 2.0</pre>
<p>You can create tuples of any length up to 22, and access their elements using <kbd>_1</kbd>, <kbd>_2</kbd>, and so on. You can also declare several variables in one go for each element of the tuple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing simulatePlan</h1>
                </header>
            
            <article>
                
<p>The implementation for <kbd>simulatePlan</kbd> is straightforward;<span> </span>we call <kbd>futureCapital</kbd> twice with different arguments:</p>
<pre><span>def </span><span>simulatePlan</span>(interestRate: <span>Double,<br/></span><span>                 </span>nbOfMonthsSaving: <span>Int, </span>nbOfMonthsInRetirement: <span>Int,<br/></span><span>                 </span>netIncome: <span>Int, </span>currentExpenses: <span>Int, </span>initialCapital: <br/><span>                  Double</span>) : (<span>Double, Double</span>) = {<br/>  <span>val </span>capitalAtRetirement = <span>futureCapital</span>(<br/>    interestRate = interestRate<span>, </span>nbOfMonths = nbOfMonthsSaving<span>,<br/></span><span>    </span>netIncome = netIncome<span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>    </span>initialCapital = initialCapital)<br/><br/>  <span>val </span>capitalAfterDeath = <span>futureCapital</span>(<br/>    interestRate = interestRate<span>, </span>nbOfMonths = nbOfMonthsInRetirement<span>,<br/></span><span>    </span>netIncome = <span>0</span><span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>    </span>initialCapital = capitalAtRetirement)<br/><br/>  (capitalAtRetirement<span>, </span>capitalAfterDeath)<br/>}</pre>
<p>Run <kbd>RetCalcSpec</kbd> again, and it should pass now. Feel free to experiment calling <kbd>simulatePlan</kbd> from the Scala Console with different values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Calculating when you can retire</h1>
                </header>
            
            <article>
                
<p>If you have tried to call <kbd>simulatePlan</kbd> from the Scala Console, you probably tried different values for <kbd>nbOfMonths</kbd> and observed the resulting capital at retirement and after death. It would be useful to have a function that finds the optimal <kbd>nbOfMonths</kbd> so that you have enough capital to never run out of money during your retirement.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a failing test for nbOfMonthsSaving</h1>
                </header>
            
            <article>
                
<p>As usual, let's start with a new unit test to clarify what we expect from this function:</p>
<pre><span>"RetCalc.nbOfMonthsSaving" </span>should {<br/>  <span>"calculate how long I need to save before I can retire" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<br/>      interestRate = <span>0.04 </span>/ <span>12</span><span>, </span>nbOfMonthsInRetirement = <span>40 </span>* <span>12</span><span>,<br/></span><span>      </span>netIncome = <span>3000</span><span>, </span>currentExpenses = <span>2000</span><span>, </span>initialCapital = <span>10000</span>)<br/>    <span>val </span>expected = <span>23 </span>* <span>12 </span>+ <span>1<br/></span><span>    </span>actual should ===(expected)<br/>  }<br/>}</pre>
<p>In this test, the expected value can be a bit difficult to figure out. One way would be to use the <kbd>NPM</kbd> function in Excel. Alternatively, you could call <kbd>simulatePlan</kbd> many times in the Scala Console, and increase <kbd>nbOfMonthsSaving</kbd> to gradually find out what the optimal value is.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the function body</h1>
                </header>
            
            <article>
                
<p>In functional programming, we avoid mutating variables. In an imperative language, you would typically implement <kbd>nbOfMonthsSaving</kbd> by using a <kbd>while</kbd> loop. It is also possible to do so in Scala, but it is a better practice to only use immutable variables. One way of solving this problem is to use recursion:</p>
<pre><span>def </span><span>nbOfMonthsSaving</span>(interestRate: <span>Double, </span>nbOfMonthsInRetirement: <span>Int,<br/></span><span>                     </span>netIncome: <span>Int, </span>currentExpenses: <span>Int, </span>initialCapital: <span>Double</span>): <span>Int </span>= {<br/>  <span>def </span><span>loop</span>(months: <span>Int</span>): <span>Int </span>= {<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <span>simulatePlan</span>(<br/>      interestRate = interestRate<span>,<br/></span><span>      </span>nbOfMonthsSaving = months<span>, </span>nbOfMonthsInRetirement = <br/>      nbOfMonthsInRetirement<span>,<br/></span><span>      </span>netIncome = netIncome<span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = initialCapital)<br/><br/>    <span>val </span>returnValue =<br/>      <span>if </span>(capitalAfterDeath &gt; <span>0.0</span>)<br/>        months<br/>      <span>else<br/></span><span>        </span>loop(months + <span>1</span>)<br/>    returnValue<br/>  }<br/>  loop(<span>0</span>)<br/>}</pre>
<p>We declare the recursive function inside the body of the function, as it is not meant to be used anywhere else. The <kbd>loop</kbd> function increments <kbd>months</kbd> by <kbd>1</kbd> until the calculated <kbd>capitalAfterDeath</kbd> is positive. The <kbd>loop</kbd> function is initiated in the body of <kbd>nbMonthsSaving</kbd> with <kbd>months = 0</kbd>. Note that IntelliJ highlights the fact that the <kbd>loop</kbd> function is recursive with a kind of <kbd>@</kbd> sign.</p>
<p>Now, we can run our unit test again, and it should pass. However, we are not quite done yet. What happens if you can never reach a month that would satisfy the condition <kbd>capitalAfterDeath &gt; 0.0</kbd><span>? Let's find out by writing another test.<br/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding tail-recursion</h1>
                </header>
            
            <article>
                
<p>Add the following tests underneath the previous one:</p>
<pre><span>"RetCalc.nbOfMonthsSaving" </span>should {<br/>  <span>"calculate how long I need to save before I can retire" </span>in {...}<br/><br/>  <span>"not crash if the resulting nbOfMonths is very high" </span>in {<br/>     <span>val </span>actual = RetCalc.<span>nbOfMonthsSaving</span>(<br/>      interestRate = <span>0.01 </span>/ <span>12</span><span>, </span>nbOfMonthsInRetirement = <span>40 </span>* <span>12</span><span>,<br/></span><span>      </span>netIncome = <span>3000</span><span>, </span>currentExpenses = <span>2999</span><span>, </span>initialCapital = <span>0</span>)<br/>    <span>val </span>expected = <span>8280<br/></span><span>    </span>actual should ===(expected)<br/>  }<br/><br/>  <span>"not loop forever if I enter bad parameters" </span>in pending</pre>
<p>We will implement the <kbd>not loop forever</kbd> later on. It is a good practice to write pending tests as soon as you think about new edge cases or other use cases for your function. It helps to keep a direction toward the end goal, and gives some momentum—as soon as you have made the previous test pass, you know exactly what test you need to write next.</p>
<p>Run the test, and it will fail with <kbd>StackOverflowError</kbd>. This is because each time <kbd>loop</kbd> is called recursively, local variables are saved onto the JVM stack. The size of the stack is quite small, and as we can see, it is quite easy to fill it up. Fortunately, there is a mechanism in the Scala compiler to automatically transform tail-recursive calls into a <kbd>while</kbd> loop. We say that a recursive call (the call to the <kbd>loop</kbd> function inside the <kbd>loop</kbd> function) is tail-recursive when it is the last instruction of the function.</p>
<p>We can easily change our previous code to make it tail-recursive. Select <kbd>returnValue</kbd>, and hit cmd + <em>O</em> to inline the variable. The body of the <kbd>loop</kbd> function should look like this:</p>
<pre><span>@tailrec<br/>def </span><span>loop</span>(months: <span>Int</span>): <span>Int </span>= {<br/>  <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <span>simulatePlan</span>(<br/>    interestRate = interestRate<span>,<br/></span><span>    </span>nbOfMonthsSaving = months<span>, </span>nbOfMonthsInRetirement = <br/>    nbOfMonthsInRetirement<span>,<br/></span><span>    </span>netIncome = netIncome<span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>    </span>initialCapital = initialCapital)<br/><br/>  <span>if </span>(capitalAfterDeath &gt; <span>0.0</span>)<br/>    months<br/>  <span>else<br/></span><span>    </span>loop(months + <span>1</span>)</pre>
<p>IntelliJ changed the small symbol in the editor's margin to highlight the fact that our function is now tail-recursive. Run the test again and it should pass. It is a good practice to also put an annotation <kbd>@tailrec</kbd> before the function definition. This tells the compiler that it must verify that the function is indeed tail-recursive. If you annotate a <kbd>@tailrec</kbd> function that is not tail-recursive, the compiler will raise an error.</p>
<div class="packt_tip">When you know that the depth of a recursive call can be high (more than 100), always make sure it is tail-recursive.<br/>
When you write a tail-recursive function, always annotate it with <kbd>@tailrec</kbd> to let the compiler verify it.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ensuring termination</h1>
                </header>
            
            <article>
                
<p>We are not quite done yet because our function might loop indefinitely. Imagine that you always spend more than what you earn. You will never be able to save enough to retire, even if you live a million years! Here is a unit test highlighting this:</p>
<pre><span>"RetCalc.nbOfMonthsSaving" </span>should {<br/>  <span>"calculate how long I need to save before I can retire" </span>in {...}<br/><br/>  <span>"not crash if the resulting nbOfMonths is very high" </span>in {...}<br/><span><br/></span><span>  </span><span>"not loop forever if I enter bad parameters" </span>in {<br/>    <span>val </span>actual = RetCalc.<span>nbOfMonthsSavingV2</span>(<br/>      interestRate = <span>0.04 </span>/ <span>12</span><span>, </span>nbOfMonthsInRetirement = <span>40 </span>* <span>12</span><span>,<br/></span><span>      </span>netIncome = <span>1000</span><span>, </span>currentExpenses = <span>2000</span><span>, </span>initialCapital = <span>10000</span>)<span><br/></span><span>    </span>actual should === (<span>Int</span>.<span>MaxValue</span>)<br/>  }<br/>}</pre>
<p>We decided to use a special value <kbd>Int.MaxValue</kbd> to indicate that <kbd>nbOfMonths</kbd> is infinite. This is not very pretty, but we will see in the next chapter how we can model this better with <kbd>Option</kbd> or <kbd>Either</kbd>. This is good enough for now.</p>
<p>To make the test pass, we just need to add an <kbd>if</kbd> statement:</p>
<pre><span>def </span><span>nbOfMonthsSaving</span>(interestRate: <span>Double, </span>nbOfMonthsInRetirement: <span>Int,<br/></span><span>                     </span>netIncome: <span>Int, </span>currentExpenses: <span>Int, </span>initialCapital: <span>Double</span>): <span>Int </span>= {<br/>  <span>@tailrec<br/></span><span>  </span><span>def </span><span>loop</span>(nbOfMonthsSaving: <span>Int</span>): <span>Int </span>= {...}<br/><br/>  <span>if </span>(netIncome &gt; currentExpenses)<br/>    loop(<span>0</span>)<br/>  <span>else<br/></span><span>    </span><span>Int</span>.<span>MaxValue<br/></span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using market rates</h1>
                </header>
            
            <article>
                
<p>In our calculations, we have always assumed that the interest rate of return was constant, but the reality is more complex. It would be more accurate to use real rates from market data to gain more confidence with our retirement plan. For this, we first need to change our code to be able to perform the same calculations using variable interest rates. Then, we will load real market data to simulate regular investments in a fund by tracking the S &amp; P 500 index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining an algebraic data type</h1>
                </header>
            
            <article>
                
<p>In order to support variable rates, we need to change the signature of all functions that accept <kbd>interestRate: Double</kbd>. Instead of a double, we need a type that can represent either a constant rate or a sequence of rates.</p>
<p>Considering two types <kbd>A</kbd> and <kbd>B</kbd>, we previously saw how to define a type that can hold a value of type <kbd>A</kbd> and a value of type <kbd><span><span>B</span></span></kbd>. This is a product type, and we can define it using a tuple, such as <kbd>ab: (A, B)</kbd>, or a case class, such as <kbd>case class MyProduct(a: A, b: B)</kbd>.</p>
<p>On the other hand, a type that can hold either <kbd>A</kbd> <strong>or</strong> <kbd>B</kbd> is a sum type, and in Scala, we declare it using a <kbd>sealed</kbd> trait inheritance:</p>
<pre><span>sealed trait </span>Shape<br/><span>case class </span>Circle(diameter: <span>Double</span>) <span>extends </span>Shape<br/><span>case class </span>Rectangle(width: <span>Double, height: Double</span>) <span>extends </span>Shape</pre>
<p>An <strong>Algebraic Data Type</strong> (<strong>ADT</strong>) is a type that composes sum types and product types to define a data structure. In the preceding code, we defined a <kbd>Shape</kbd> ADT, which composes a sum type (a <kbd>Shape</kbd> can be a <kbd>Circle</kbd> or a <kbd>Rectangle</kbd>), with a product type <kbd>Rectangle</kbd> (a <kbd>Rectangle</kbd> holds a width and a height).</p>
<p>The <kbd>sealed</kbd> keyword indicates that all subclasses of the trait must be declared in the same <kbd>.scala</kbd> file. If you attempt to declare a class that extends a <kbd>sealed</kbd> trait in another file, the compiler will reject it. This is used to guarantee that our inheritance tree is complete, and as we will see later on, it has interesting benefits when it comes to using pattern matching.</p>
<p>Going back to our problem, we can define a <kbd>Returns</kbd> ADT as follows. Create a new Scala class in the <kbd>retcalc</kbd> package in <kbd>src/main/scala</kbd>:</p>
<pre><span>package retcalc<br/><br/>sealed trait Returns<br/>case class </span>FixedReturns(annualRate: <span>Double</span>) <span>extends </span>Returns<span><br/></span><span>case class </span>VariableReturns(returns: <span>Vector</span>[VariableReturn]) <span>extends </span>Returns<br/><span>case class </span>VariableReturn(monthId: <span>String</span><span>, </span>monthlyRate: <span>Double)</span></pre>
<p>For <kbd>VariableReturn</kbd>, we keep the monthly interest rate and an identifier <kbd>monthId</kbd> that will have the form <em>2017.02</em>, for February 2017. I recommend that you use <kbd>Vector</kbd> whenever you need to model a sequence of elements. <kbd>Vector</kbd> is faster than <kbd>List</kbd> for appending/inserting elements or accessing an element by index.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering returns for a specific period</h1>
                </header>
            
            <article>
                
<p>When we have <kbd><span>VariableReturns</span></kbd> over a long period, for instance, 1900 to 2017, it can be interesting to use a smaller period to simulate what would happen if the historical returns in a smaller period, say 50 years, would be repeated.</p>
<p>We are going to create a method in the <kbd>VariableReturns</kbd> class that will keep only the returns contained in a specific period. Here is the unit test in <kbd>ReturnsSpec.scala</kbd>:</p>
<pre><span>"VariableReturns.fromUntil" </span>should {<br/>  <span>"keep only a window of the returns" </span>in {<br/>    <span>val </span>variableReturns = <span>VariableReturns</span>(<span>Vector</span>.tabulate(<span>12</span>) { i =&gt;<br/>      <span>val </span>d = (i + <span>1</span>).toDouble<br/>      <span>VariableReturn</span>(<span>f"2017.</span><span>$</span>d<span>%02.0f"</span><span>, </span>d)<br/>    })<br/><br/>    variableReturns.fromUntil(<span>"2017.07"</span><span>, </span><span>"2017.09"</span>).returns should ===<br/>    (<span>Vector</span>(<br/>      <span>VariableReturn</span>(<span>"2017.07"</span><span>, </span><span>7.0</span>)<span>,<br/></span><span>      </span><span>VariableReturn</span>(<span>"2017.08"</span><span>, </span><span>8.0</span>)<br/>    ))<br/><br/>    variableReturns.fromUntil(<span>"2017.10"</span><span>, </span><span>"2018.01"</span>).returns should ===<br/>    (<span>Vector</span>(<br/>      <span>VariableReturn</span>(<span>"2017.10"</span><span>, </span><span>10.0</span>)<span>,<br/></span><span>      </span><span>VariableReturn</span>(<span>"2017.11"</span><span>, </span><span>11.0</span>)<span>,<br/></span><span>      </span><span>VariableReturn</span>(<span>"2017.12"</span><span>, </span><span>12.0</span>)<br/>    ))<br/>  }<br/>}</pre>
<p>First, we generate a sequence of returns and assign them to <kbd>variableReturns</kbd> using the function <kbd>Vector.tabulate</kbd>. It generates 12 elements, and each element is produced by an anonymous function, taking a parameter <kbd>i</kbd> that will go from <kbd>0</kbd> to <kbd>11</kbd>. In the call to the <kbd>VariableReturn</kbd> constructor, for the <kbd>monthId</kbd> argument, we use the <kbd>f</kbd> interpolator to generate a string in the form <kbd>2017.01</kbd> when <kbd>d = 1</kbd>, <kbd>2017.02</kbd> when <kbd>d = 2</kbd>, and so on.</p>
<p>The function <kbd>fromUntil</kbd> that we are specifying will return a <kbd>VariableReturns</kbd> type that contains a specific window inside the original returns. For now, we assume that the arguments passed to <kbd>fromUntil</kbd> are valid months that are present in <kbd>variableReturns</kbd>. Ideally, we should add unit tests to specify what should happen if they are not.</p>
<p>Here is the implementation in <kbd>Returns.scala</kbd>:</p>
<pre><span>case class </span>VariableReturns(returns: <span>Vector</span>[VariableReturn]) <span>extends </span>Returns {<br/>  <span>def </span><span>fromUntil</span>(monthIdFrom: <span>String</span><span>, </span>monthIdUntil: <span>String</span>): <br/>    VariableReturns =<br/>    <span>VariableReturns</span>(<br/>      returns<br/>        .dropWhile(_.monthId != monthIdFrom)<br/>        .takeWhile(_.monthId != monthIdUntil))<br/>}</pre>
<p>We use the higher order function <kbd>dropWhile</kbd> to drop elements until we reach the condition <kbd>monthId == monthIdFrom</kbd>. Then, we call <kbd>takeWhile</kbd> on the resulting collection to keep all elements until <kbd>monthId == monthIdUntil</kbd>. This will return a collection that keeps only the elements in a window that starts at <kbd>monthIdFrom</kbd> and ends just before <kbd>monthIdUntil</kbd>.</p>
<p>Run <kbd>ReturnsSpec</kbd>, and it should pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>Now that we have a way of expressing variable returns, we need to change our <kbd>futureCapital</kbd> function to accept a <kbd>Returns</kbd> type instead of a monthly interest rate of type <kbd>Double</kbd>. Change the tests first:</p>
<pre>"RetCalc.futureCapital" should {<br/>    "calculate the amount of savings I will have in n months" in {<br/>      // Excel =-FV(0.04/12,25*12,1000,10000,0)<br/>      val actual = RetCalc.futureCapital(FixedReturns(0.04), <br/>        nbOfMonths = 25 * 12, netIncome = 3000, <br/>        currentExpenses = 2000, initialCapital = 10000).right.value<br/>      val expected = 541267.1990<br/>      actual should ===(expected)<br/>    }<br/><br/>    "calculate how much savings will be left after having taken a <br/>     pension for n months" in {<br/>      val actual = RetCalc.futureCapital(FixedReturns(0.04), <br/>        nbOfMonths = 40 * 12, netIncome = 0, currentExpenses = 2000, <br/>        initialCapital = 541267.198962).right.value<br/>      val expected = 309867.5316<br/>      actual should ===(expected)<br/>    }<br/>  }</pre>
<p>Then, change the <kbd>futureCapital</kbd> function in <kbd>RetCalc</kbd> as follows:</p>
<pre><span>def </span><span>futureCapital</span>(returns: Returns<span>, </span>nbOfMonths: <span>Int, </span>netIncome: <span>Int, </span>currentExpenses: <span>Int,<br/></span><span>                  </span>initialCapital: <span>Double</span>): <span>Double </span>= {<br/>  <span>val </span>monthlySavings = netIncome - currentExpenses<br/>  (<span>0 until</span> nbOfMonths).foldLeft(initialCapital) {<br/>    <span>case </span>(accumulated<span>, </span>month) =&gt;<br/>      accumulated * (<span>1 </span>+ Returns.<span>monthlyRate</span>(returns<span>, </span>month)) + <br/>      monthlySavings<br/>  }<br/>}</pre>
<p>Here, instead of just using the <kbd>interestRate</kbd> in the formula, we introduced a new function called <kbd>Returns.monthlyRate</kbd> which we must now create. As we follow a rather strict TDD approach, we will only create its signature first, then write the unit test, and finally implement it.</p>
<p>Write the function signature in <kbd>Returns.scala</kbd>:</p>
<pre>object Returns {<br/>  <span>def </span><span>monthlyRate</span>(returns: Returns<span>, </span>month: <span>Int</span>): <span>Double </span>= ???<br/>}</pre>
<p>Create a new unit test <kbd>ReturnsSpec</kbd> in the <kbd>retcalc</kbd> package in <kbd>src/test/scala</kbd>:</p>
<pre><span>class </span>ReturnsSpec <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals {<br/><br/>  <span>implicit val </span><span>doubleEquality</span>: Equality[<span>Double</span>] =<br/>    TolerantNumerics.tolerantDoubleEquality(<span>0.0001</span>)<br/><br/>  <span>"Returns.monthlyRate" </span>should {<br/>    <span>"return a fixed rate for a FixedReturn" </span>in {<br/>      Returns.<span>monthlyRate</span>(<span>FixedReturns</span>(<span>0.04</span>)<span>, </span><span>0</span>) should ===(<span>0.04 </span>/ <span>12</span>)<br/>      Returns.<span>monthlyRate</span>(<span>FixedReturns</span>(<span>0.04</span>)<span>, </span><span>10</span>) should ===(<span>0.04 </span>/ <span>12</span>)<br/>    }<br/><br/>    val variableReturns = VariableReturns(Vector(<br/>      VariableReturn("2000.01", 0.1), <br/>      VariableReturn("2000.02", 0.2)))<br/>    <span>"return the nth rate for VariableReturn" </span>in {<br/>      Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>0</span>) should ===(<span>0.1</span>)<br/>      Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>1</span>) should ===(<span>0.2</span>)<br/>    }<br/><br/>    <span>"roll over from the first rate if n &gt; length" </span>in {<br/>      Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>2</span>) should ===(<span>0.1</span>)<br/>      Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>3</span>) should ===(<span>0.2</span>)<br/>      Returns.<span>monthlyRate</span>(variableReturns<span>, </span><span>4</span>) should ===(<span>0.1</span>)<br/>    }<br/>  }</pre>
<p><span>These tests act as a specification for our <kbd>monthlyRate</kbd> function. For <kbd>VariableRate</kbd>, the <kbd>monthlyRate</kbd> must return the <em>n<sup>th</sup></em> rate stored in the</span> returned <kbd>Vector</kbd><span>. If <em>n</em> is greater than the number of rates, we decide that <kbd>monthlyRate</kbd> should go back to the beginning of <kbd>Vector</kbd>, as if the history of our variable</span> returns <span>would repeat itself infinitely. We could have made a different choice here, for instance, we could have taken a mirror of the returns, or we could have just returned some error if we reached the end. To implement this rotation, we are taking the month value and applying the modulo ( <kbd><em>%</em></kbd> in Scala ) of the length of the vector.</span></p>
<p>The implementation introduces a new element of syntax, called <strong>pattern matching</strong>:</p>
<pre><span>def </span><span>monthlyRate</span>(returns: Returns<span>, </span>month: <span>Int</span>): <span>Double </span>= returns <span>match </span>{<br/>  <span>case </span><span>FixedReturns</span>(r) =&gt; r / <span>12<br/></span><span>  </span><span>case </span><span>VariableReturns</span>(rs) =&gt; rs(month % rs.length).monthlyRate<br/>}</pre>
<p>You can now run <kbd>ReturnsSpec</kbd>, and all tests should pass. Pattern matching allows you to deconstruct an ADT and evaluate some expression when it matches one of the patterns. You can also assign variables along the way and use them in the expression. In the preceding example, <kbd>case FixedReturns(r) =&gt; r/12</kbd> can be interpreted as "if the variable <kbd>returns</kbd> is of type <kbd>FixedReturns</kbd>, assign <kbd>r = returns.annualRate</kbd>, and return the result of the expression <kbd>r/12</kbd>".</p>
<p>This is a simple example, but you can use much more complicated patterns. This feature is very powerful, and can often replace lots of <kbd>if</kbd>/<kbd>else</kbd> expressions. You can try some more complex patterns in the Scala Console:</p>
<pre>scala&gt; Vector(1, 2, 3, 4) match {<br/>  case head +: second +: tail =&gt; tail<br/>}<br/>res0: scala.collection.immutable.Vector[Int] = Vector(3, 4)<br/><br/>scala&gt; Vector(1, 2, 3, 4) match {<br/>  case head +: second +: tail =&gt; second<br/>}<br/><br/>scala&gt; ("0", 1, (2.0, 3.0)) match {<br/>  case ("0", int, (d0, d1)) =&gt; d0 + d1<br/>}<br/>res2: Double = 5.0<br/><br/>scala&gt; "hello" match {<br/>  case "hello" | "world" =&gt; 1<br/>  case "hello world" =&gt; 2<br/>}<br/>res3: Int = 1<br/><br/>scala&gt; def present(p: Person): String = p match {<br/>  case Person(name, age) if age &lt; 18 =&gt; s"$name is a child"<br/>  case p =&gt; s"${p.name} is an adult" <br/>}<br/>present: (p: Person)String</pre>
<p>It is a good practice to exhaustively match all possible patterns for your value. Otherwise, if no pattern matches the value, Scala will raise a runtime exception, and it might crash your program. However, when you use <kbd>sealed</kbd> traits, the compiler is aware of all the possible classes for a trait and will issue a warning if you do not match all cases.</p>
<p>In <kbd>Returns.scala</kbd>, try to comment out this line with cmd + <em>/</em>:</p>
<pre>  <span>def </span><span>monthlyRate</span>(returns: Returns<span>, </span>month: <span>Int</span>): <span>Double </span>= returns <span>match </span>{<br/><span>//    case FixedReturns(r) =&gt; r / 12<br/></span><span>    </span><span>case </span><span>VariableReturns</span>(rs) =&gt; rs(month % rs.length).monthlyRate<br/>  }</pre>
<p>Recompile the project with cmd + <em>F9</em>. The compiler will warn you that you are doing something wrong:</p>
<pre>Warning:(27, 59) match may not be exhaustive.<br/>It would fail on the following input: FixedReturns(_)<br/>  def monthlyRate(returns: Returns, month: Int): Double = returns match {</pre>
<p>If you then try to remove the <kbd>sealed</kbd> keyword and recompile, the compiler will not issue any warning.</p>
<p class="mce-root">We now have a good grasp of how to use pattern matching. Keep the <kbd>sealed</kbd> keyword, revert the comment in <kbd>monthlyRate</kbd>, and run <kbd>ReturnsSpec</kbd> to make sure everything is green again.</p>
<p>If you are coming from an object-oriented language, you might wonder why we did not implement <kbd>monthlyRate</kbd> using an abstract method with implementations in <kbd>FixedRate</kbd> and <kbd>VariableRate</kbd>. This is perfectly feasible in Scala, and some people might prefer this design choice.</p>
<p>However, as I am an advocate of a functional programming style, I prefer using pure functions in objects:</p>
<ul>
<li>They are easier to reason about, as the whole dispatching logic is in one place.</li>
<li>They can be moved to other objects easily, which facilitates refactoring.</li>
<li>They have a more limited scope. In class methods, you always have all the attributes of the class in scope. In a function, you only have the parameters of the function. This helps unit testing and readability, as you know that the function cannot use anything else but its parameters. Also, it can avoid side effects when the class has mutable attributes.</li>
<li>Sometimes in object-oriented design, when a method manipulates two objects, <kbd>A</kbd> and <kbd>B</kbd>, it is not clear if the method should be in class <kbd>A</kbd> or class <kbd>B</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refactoring simulatePlan</h1>
                </header>
            
            <article>
                
<p>As we changed the signature of <kbd>futureCapital</kbd>, we also need to change the callers of that function. The only caller is <kbd>simulatePlan</kbd>. Before introducing variable rates, the implementation was straightforward: we just had to call <kbd>futureCapital</kbd> for the accumulation and decumulation phases with the same fixed rate argument. However, with variable rate, we must make sure that the decumulation phase uses the rates that follow the rates of the accumulation phase.</p>
<p class="mce-root">For instance, consider that you started saving in 1950, and retired in 1975. For the accumulation phase, you need to use the returns from 1950 to 1975, and for the decumulation, you must use the returns from 1975. We created a new unit test to make sure that we are using different returns for the two phases:</p>
<pre><span>val params = RetCalcParams(<br/>  nbOfMonthsInRetirement = 40 * 12,<br/>  netIncome = 3000,<br/>  currentExpenses = 2000,<br/>  initialCapital = 10000)<br/><br/>"RetCalc.simulatePlan" </span>should {<br/>  <span>"calculate the capital at retirement and the capital after death" </span>in {<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <br/>    RetCalc.<span>simulatePlan</span>(<br/>      returns = <span>FixedReturns</span>(<span>0.04</span>)<span>, </span><span>params</span><span>, </span>nbOfMonthsSavings = <span>25</span>*<span>12</span>)<br/><br/>    capitalAtRetirement should === (<span>541267.1990</span>)<br/>    capitalAfterDeath should === (<span>309867.5316</span>)<br/>  }<br/><br/>  <span>"use different returns for capitalisation and drawdown" </span>in {<br/>    <span>val </span>nbOfMonthsSavings = <span>25 </span>* <span>12<br/></span><span>    </span><span>val </span>returns = <span>VariableReturns</span>(<br/>      <span>Vector</span>.tabulate(nbOfMonthsSavings + <br/>        <span>params</span>.nbOfMonthsInRetirement)(i =&gt;<br/>        <span>if </span>(i &lt; nbOfMonthsSavings)<br/>          <span>VariableReturn</span>(i.toString<span>, </span><span>0.04 </span>/ <span>12</span>)<br/>        <span>else<br/></span><span>          </span><span>VariableReturn</span>(i.toString<span>, </span><span>0.03 </span>/ <span>12</span>)))<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) =<br/>      RetCalc.<span>simulatePlan</span>(returns<span>, </span><span>params</span><span>, </span>nbOfMonthsSavings)<span><br/></span><span>    </span>capitalAtRetirement should ===(<span>541267.1990</span>)<span><br/></span><span>    </span>capitalAfterDeath should ===(-<span>57737.7227</span>)<br/>  }<br/>}</pre>
<p>Since <kbd>simulatePlan</kbd> has quite a lot of parameters apart from the <kbd>returns</kbd> parameter, we decided to put them in a case class called <kbd>RetCalcParams</kbd>. This way, we are able to reuse the same parameters for different unit tests. We will also be able to reuse it in <kbd>nbMonthsSaving</kbd>. As seen previously, we use the function <kbd>tabulate</kbd> to generate values for our variable returns.</p>
<p>The expected value for <kbd>capitalAtRetirement</kbd> can be obtained with Excel by using <span><kbd>-FV(0.04/12, 25*12, 1000, 10000)</kbd>. The expected value for <kbd>capitalAfterDeath</kbd> can be obtained by using</span> <kbd><span>-FV(0.03/12, 40*12, -2000, 541267.20)</span></kbd>.</p>
<p>Here is the implementation in <kbd>RetCalc</kbd>:</p>
<pre><span>case class </span>RetCalcParams(nbOfMonthsInRetirement: <span>Int,<br/></span><span>                         </span>netIncome: <span>Int,<br/></span><span>                         </span>currentExpenses: <span>Int,<br/></span><span>                         </span>initialCapital: <span>Double</span>)<br/><br/><span>object </span>RetCalc {<br/>  <span>def </span><span>simulatePlan</span>(returns: Returns<span>, </span>params: RetCalcParams<span>, <br/>  </span>nbOfMonthsSavings: <span>Int</span>)<br/>  : (<span>Double, Double</span>) = {<br/>    <span>import </span>params._<br/>    <span>val </span>capitalAtRetirement = <span>futureCapital</span>(<br/>      returns = returns<span>,<br/></span><span>      </span>nbOfMonths = nbOfMonthsSavings<span>,<br/></span><span>      </span>netIncome = netIncome<span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = initialCapital)<br/><br/>    <span>val </span>capitalAfterDeath = <span>futureCapital</span>(<br/>      returns = <span>OffsetReturns</span>(returns<span>, </span>nbOfMonthsSavings)<span>,<br/></span><span>      </span>nbOfMonths = nbOfMonthsInRetirement<span>,<br/></span><span>      </span>netIncome = <span>0</span><span>, </span>currentExpenses = currentExpenses<span>,<br/></span><span>      </span>initialCapital = capitalAtRetirement)<br/><br/>    (capitalAtRetirement<span>, </span>capitalAfterDeath)<br/>  }</pre>
<p>The first line, <kbd>import params._</kbd>, brings all the parameters of <kbd>RetCalcParams</kbd> into scope. This way, you can directly use, for instance, <kbd>netIncome</kbd> without having to prefix it with <kbd>params.netIncome</kbd> . In Scala, you can not only import classes from a package, but also functions or values from an object.</p>
<p>In the second call to <kbd>futureCapital</kbd>, we introduce a new subclass called <kbd>OffsetReturns</kbd>, which will shift the starting month. We need to write a new unit test for it in <kbd>ReturnsSpec</kbd>:</p>
<pre><span>"Returns.monthlyReturn" </span>should {<br/>  <span>"return a fixed rate for a FixedReturn" </span>in {...}<br/><br/>  <span>val </span>variableReturns = <span>VariableReturns</span>(<br/>    <span>Vector</span>(<span>VariableReturn</span>(<span>"2000.01"</span><span>, </span><span>0.1</span>)<span>, </span><span>VariableReturn</span>(<span>"2000.02"</span><span>, </span><span>0.2</span>)))<br/><br/>  <span>"return the nth rate for VariableReturn" </span>in {...}<br/><br/>  <span>"return an error if n &gt; length" </span>in {...}<br/><br/>  <strong>"return the n+offset th rate for OffsetReturn"</strong> in {<br/>      val returns = OffsetReturns(variableReturns, 1)<br/>      Returns.monthlyRate(returns, 0).right.value should ===(0.2)<br/>    }<br/>}</pre>
<p class="mce-root">And the corresponding implementation in <kbd>Returns.scala</kbd> is as follows:</p>
<pre><span>sealed trait </span>Returns<span><br/>case class </span>FixedReturns(annualRate: <span>Double</span>) <span>extends </span>Returns<span><br/>case class </span>VariableReturn(monthId: <span>String</span><span>, </span>monthlyRate: <span>Double</span>)<span><br/>case class </span>OffsetReturns(orig: Returns<span>, </span>offset: <span>Int</span>) <span>extends </span>Returns<br/><br/>object Returns {<br/>  def monthlyRate(returns: Returns, month: Int): Double = returns match {<br/>    case FixedReturns(r) =&gt; r / 12<br/>    case VariableReturns(rs) =&gt; rs(month % rs.length).monthlyRate<br/>    case OffsetReturns(rs, offset) =&gt; monthlyRate(rs, month + offset)<br/>  }<br/>}</pre>
<p>For an offset return, we call <kbd>monthlyRate</kbd> recursively and add the offset to the requested month.</p>
<p>Now, you can compile everything with cmd + <em>F9</em> and rerun the unit tests. They should all pass.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading market data</h1>
                </header>
            
            <article>
                
<p>In order to calculate the real monthly returns of our investments in a fund tracking the S &amp; P 500, we are going to load a tab-separated file containing the S &amp; P 500 prices and dividends, and another file containing the consumer price index. This will let us calculate a real rate of return, stripped out of inflation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing the unit test using the column selection mode</h1>
                </header>
            
            <article>
                
<p>First, copy <kbd>sp500_2017.tsv</kbd> from <a href="https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv">https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv</a> to <kbd>src/test/resources</kbd>. Then, create a new unit test called <kbd>EquityDataSpec</kbd> in the <kbd>retcalc</kbd> package. If you retype this example, try the column selection mode (<em>Alt</em> + <em>Shift</em> + <em>Insert</em>). Copy the content of the <kbd>.tsv</kbd> file in the test, then select the first column with <em>Shift</em> + <em>Down</em> 13 times, and then type <kbd>EquityData("</kbd>. Finally, edit the rest of the lines using the arrow keys, delete, comma, and so on:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>org.scalatest.{Matchers<span>, </span>WordSpec}<br/><br/><span>class </span>EquityDataSpec <span>extends </span>WordSpec <span>with </span>Matchers {<br/>  <span>"EquityData.fromResource" </span>should {<br/>    <span>"load market data from a tsv file" </span>in {<br/>      <span>val </span>data = EquityData.<span>fromResource</span>(<span>"sp500_2017.tsv"</span>)<br/>      data should ===(<span>Vector</span>(<br/>        <span>EquityData</span>(<span>"2016.09"</span><span>, </span><span>2157.69</span><span>, </span><span>45.03</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2016.10"</span><span>, </span><span>2143.02</span><span>, </span><span>45.25</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2016.11"</span><span>, </span><span>2164.99</span><span>, </span><span>45.48</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2016.12"</span><span>, </span><span>2246.63</span><span>, </span><span>45.7</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.01"</span><span>, </span><span>2275.12</span><span>, </span><span>45.93</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.02"</span><span>, </span><span>2329.91</span><span>, </span><span>46.15</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.03"</span><span>, </span><span>2366.82</span><span>, </span><span>46.38</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.04"</span><span>, </span><span>2359.31</span><span>, </span><span>46.66</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.05"</span><span>, </span><span>2395.35</span><span>, </span><span>46.94</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.06"</span><span>, </span><span>2433.99</span><span>, </span><span>47.22</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.07"</span><span>, </span><span>2454.10</span><span>, </span><span>47.54</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.08"</span><span>, </span><span>2456.22</span><span>, </span><span>47.85</span>)<span>,<br/></span><span>        </span><span>EquityData</span>(<span>"2017.09"</span><span>, </span><span>2492.84</span><span>, </span><span>48.17</span>)<br/>      ))<br/>    }<br/>  }<br/><br/>  <span>"EquityData.monthlyDividend" </span>should {<br/>    <span>"return a monthly dividend" </span>in {<br/>      EquityData(<span>"2016.09"</span><span>, </span><span>2157.69</span><span>, </span><span>45.03</span>).<span>monthlyDividend </span>should === <br/>      (<span>45.03 </span>/ <span>12</span>)<br/>    }<br/>  }<br/>}</pre>
<p>The first lines of <kbd>sp500_2017.tsv</kbd> look like this:</p>
<pre>month   SP500  dividend<br/>2016.09    2157.69    45.03<br/>2016.10    2143.02    45.25<br/>2016.11    2164.99    45.48</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading the file with Source</h1>
                </header>
            
            <article>
                
<p>Our implementation must drop the first line which contains the headers, then for each line, split and create a new instance of <kbd>EquityData</kbd>:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>scala.io.Source<br/><br/><span>case class </span>EquityData(monthId: <span>String</span><span>, </span>value: <span>Double, </span>annualDividend: <span>Double</span>) {<br/>  <span>val </span><span>monthlyDividend</span>: <span>Double </span>= annualDividend / <span>12</span><br/>}<br/><br/><span>object </span>EquityData {<br/>  <span>def </span><span>fromResource</span>(resource: <span>String</span>): <span>Vector</span>[EquityData] =<br/>    Source.<span>fromResource</span>(resource).getLines().drop(<span>1</span>).map { line =&gt;<br/>      <span>val </span>fields = line.split(<span>"</span><span>\t</span><span>"</span>)<br/>      <span>EquityData</span>(<br/>        monthId = fields(<span>0</span>)<span>, <br/></span><span>        </span>value = fields(<span>1</span>).toDouble<span>, <br/></span><span>        </span>annualDividend = fields(<span>2</span>).toDouble)<br/>    }.toVector<br/>}</pre>
<p>This code is quite compact, and you might lose a sense of what types are returned by intermediate calls. In IntelliJ, you can select a portion of code and hit <em>Alt</em> + <em>=</em> to show the inferred type of the expression.</p>
<p>We first load the <kbd>.tsv</kbd> file using <kbd>scala.io.Source.fromResource</kbd>. This takes the name of a file located in a <kbd>resource</kbd> folder and returns a <kbd>Source</kbd> object. It can be in <kbd>src/test/resources</kbd> or <kbd>src/main/resources</kbd>. When you run a test, both folders will be searched. If you run the production code, only the files in <kbd>src/main/resources</kbd> will be accessible.</p>
<p><kbd>getLines</kbd> returns <kbd>Iterator[String]</kbd>. An <strong>iterator</strong> is a <strong>mutable</strong> data structure that allows you to iterate over a sequence of elements. It provides many functions that are common to other collections. Here, we drop the first line, which contains the header, and transforms each line using an anonymous function passed to <kbd>map</kbd>.</p>
<p>The anonymous function takes <kbd>line</kbd> of type string, transforms it into <kbd>Array[String]</kbd> using <kbd>split</kbd>, and instantiates a new <kbd>EquityData</kbd> object.</p>
<p>Finally, we convert the resulting <kbd>Iterator[EquityData]</kbd> into <kbd>Vector[EquityData]</kbd> using <kbd>.toVector</kbd>. This step is very important: we convert the mutable, unsafe, iterator into an immutable, safe <kbd>Vector</kbd>. Public functions should, in general, not accept or return mutable data structures:</p>
<ul>
<li>It makes the code harder to reason about, as you have to remember the state the mutable structure is in.</li>
<li>The program will behave differently depending on the order/repetition of the function calls. In the case of an iterator, it can be iterated only once. If you need to iterate again, you won't get any data:</li>
</ul>
<pre style="padding-left: 60px">scala&gt; val iterator = (1 to 3).iterator<br/>iterator: Iterator[Int] = non-empty iterator<br/><br/>scala&gt; iterator foreach println<br/>1<br/>2<br/>3<br/><br/>scala&gt; iterator foreach println<br/><br/>scala&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading inflation data</h1>
                </header>
            
            <article>
                
<p>Now that we can load some equity data, we need to load inflation data so that we're able to compute inflation-adjusted returns. It is very similar to the loading of equity data.</p>
<p class="mce-root"/>
<p>First, copy <kbd>cpi_2017.tsv</kbd> from <a href="https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv">https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv</a> to <kbd>src/test/resources</kbd>. Then, create a new unit test called <kbd>InflationDataSpec</kbd> in the <kbd>retcalc</kbd> package:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>org.scalatest.{Matchers<span>, </span>WordSpec}<br/><br/><span>class </span>InflationDataSpec <span>extends </span>WordSpec <span>with </span>Matchers {<br/>  <span>"InflationData.fromResource" </span>should {<br/>    <span>"load CPI data from a tsv file" </span>in {<br/>      <span>val </span>data = InflationData.<span>fromResource</span>(<span>"cpi_2017.tsv"</span>)<br/>      data should ===(<span>Vector</span>(<br/>        <span>InflationData</span>(<span>"2016.09"</span><span>, </span><span>241.428</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2016.10"</span><span>, </span><span>241.729</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2016.11"</span><span>, </span><span>241.353</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2016.12"</span><span>, </span><span>241.432</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.01"</span><span>, </span><span>242.839</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.02"</span><span>, </span><span>243.603</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.03"</span><span>, </span><span>243.801</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.04"</span><span>, </span><span>244.524</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.05"</span><span>, </span><span>244.733</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.06"</span><span>, </span><span>244.955</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.07"</span><span>, </span><span>244.786</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.08"</span><span>, </span><span>245.519</span>)<span>,<br/></span><span>        </span><span>InflationData</span>(<span>"2017.09"</span><span>, </span><span>246.819</span>)<br/>      ))<br/>    }<br/>  }<br/>}</pre>
<p>Then, create the corresponding <kbd>InflationData</kbd> class and companion object:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>scala.io.Source<br/><br/><span>case class </span>InflationData(monthId: <span>String</span><span>, </span>value: <span>Double</span>)<br/><br/><span>object </span>InflationData {<br/>  <span>def </span><span>fromResource</span>(resource: <span>String</span>): <span>Vector</span>[InflationData] =<br/>    Source.<span>fromResource</span>(resource).getLines().drop(<span>1</span>).map { line =&gt;<br/>      <span>val </span>fields = line.split(<span>"</span><span>\t</span><span>"</span>)<br/>      <span>InflationData</span>(monthId = fields(<span>0</span>)<span>, </span>value = fields(<span>1</span>).toDouble)<br/>    }.toVector<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computing real returns</h1>
                </header>
            
            <article>
                
<p>For a given month, <em>n</em>, the real return is <em>return</em><sub>n</sub> <em>- inflationRate</em><sub>n</sub>, hence the following formula:</p>
<p class="CDPAlignCenter CDPAlign"><img class="fm-editor-equation" src="assets/e0504af4-084c-4252-b1b8-74ab19365329.png" style="width:30.42em;height:3.33em;"/></p>
<p>We are going to create a new function in <kbd>Returns</kbd> that creates <kbd>VariableReturns</kbd> using <kbd>Vector[EquityData]</kbd> and <kbd>Vector[InflationData]</kbd>. Add the following unit test to <kbd>ReturnsSpec</kbd>:</p>
<pre><span>"Returns.fromEquityAndInflationData" </span>should {<br/>  <span>"compute real total returns from equity and inflation data" </span>in {<br/>    <span>val </span>equities = <span>Vector</span>(<br/>      <span>EquityData</span>(<span>"2117.01"</span><span>, </span><span>100.0</span><span>, </span><span>10.0</span>)<span>,<br/></span><span>      </span><span>EquityData</span>(<span>"2117.02"</span><span>, </span><span>101.0</span><span>, </span><span>12.0</span>)<span>,<br/></span><span>      </span><span>EquityData</span>(<span>"2117.03"</span><span>, </span><span>102.0</span><span>, </span><span>12.0</span>))<br/><br/>    <span>val </span>inflations = <span>Vector</span>(<br/>      <span>InflationData</span>(<span>"2117.01"</span><span>, </span><span>100.0</span>)<span>,<br/></span><span>      </span><span>InflationData</span>(<span>"2117.02"</span><span>, </span><span>102.0</span>)<span>,<br/></span><span>      </span><span>InflationData</span>(<span>"2117.03"</span><span>, </span><span>102.0</span>))<br/><br/>    <span>val </span>returns = Returns.<span>fromEquityAndInflationData</span>(equities<span>, <br/>    </span>inflations)<span><br/></span><span>    </span>returns should ===(VariableReturns(<span>Vector</span>(<br/>      <span>VariableReturn</span>(<span>"2117.02"</span><span>, </span>(<span>101.0 </span>+ <span>12.0 </span>/ <span>12</span>) / <span>100.0 </span>- <span>102.0 </span>/ <br/>      <span>100.0</span>)<span>,<br/></span><span>      </span><span>VariableReturn</span>(<span>"2117.03"</span><span>, </span>(<span>102.0 </span>+ <span>12.0 </span>/ <span>12</span>) / <span>101.0 </span>- <span>102.0 </span>/ <br/>      <span>102.0</span>))))<br/>  }<br/>}</pre>
<p>We create two small <kbd>Vector</kbd> instances of <kbd>EquityData</kbd> and <kbd>InflationData</kbd>, and calculate the expected value using the preceding formula.</p>
<p>Here is the implementation of <kbd>fromEquityAndInflationData</kbd> in <kbd>Returns.scala</kbd>:</p>
<pre><span>object Returns {<br/>  def fromEquityAndInflationData(equities: Vector[EquityData],<br/>    inflations: Vector[InflationData]):<br/>      VariableReturns = {<br/>        VariableReturns(equities.zip(inflations).sliding(2).collect {<br/>          case (prevEquity, prevInflation) +: (equity, inflation) +:<br/>            Vector() =&gt;<br/>            val inflationRate = inflation.value / prevInflation.value<br/>            val totalReturn =<br/>            (equity.value + equity.monthlyDividend) / prevEquity.value<br/>            val realTotalReturn = totalReturn - inflationRate<br/><br/>            VariableReturn(equity.monthId, realTotalReturn)<br/>          }.toVector)<br/>}</span></pre>
<p>Firstly, we <kbd>zip</kbd> the two <kbd>Vectors</kbd> to create a collection of tuples, <kbd>(EquityData, InflationData)</kbd>. This operation brings our two collections together as if we were zipping a jacket. It is a good habit to play around with the Scala Console to get a sense of what it does:</p>
<pre>scala&gt; Vector(1,2).zip(Vector("a", "b", "c"))<br/>res0: scala.collection.immutable.Vector[(Int, String)] = Vector((1,a), (2,b))</pre>
<p>Note that the resulting <kbd>Vector</kbd> has a size that is the minimum size of the two arguments. The last element, <kbd>"c"</kbd>, is lost, because there is nothing to zip it with!</p>
<p>This is a good start, as we could now iterate through a collection that can give us <em>price<sup>n</sup></em>, <em>dividends<sup>n</sup></em>, and <em>inflation<sup>n</sup></em>. But in order to calculate our formula, we also need the previous data on <em>n-1</em>. For this, we use <kbd>sliding(2)</kbd>. I encourage you to read the documentation on sliding. Let's try it in the console:</p>
<pre>scala&gt; val it = Vector(1, 2, 3, 4).sliding(2)<br/>it: Iterator[scala.collection.immutable.Vector[Int]] = non-empty iterator<br/><br/>scala&gt; it.toVector<br/>res0: Vector[scala.collection.immutable.Vector[Int]] = <br/>Vector(Vector(1, 2), Vector(2, 3), Vector(3, 4))<br/><br/>scala&gt; Vector(1).sliding(2).toVector<br/>res12: Vector[scala.collection.immutable.Vector[Int]] = Vector(Vector(1))</pre>
<p><kbd>sliding(p)</kbd> creates an <kbd>Iterator</kbd> which will produce collections of size <kbd>p</kbd>. Each collection will have a new iterated element plus all the previous <kbd>p-1</kbd> elements. Notice that if the collection size <em>n</em> is lower than <kbd>p</kbd>, the produced collection will have a size of <em>n</em>.</p>
<p>Next, we iterate through the sliding collections using <kbd>collect</kbd>. <kbd>collect</kbd> is similar to <kbd>map</kbd>: it allows you to transform the elements of a collection, but with the added capability of filtering them. Basically, whenever you want to <kbd>filter</kbd> and <kbd>map</kbd> a collection, you can use <kbd>collect</kbd> instead. The filtering is performed using pattern matching. Anything that does not match any pattern is filtered out:</p>
<pre>scala&gt; val v = Vector(1, 2, 3)<br/>v: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)<br/><br/>scala&gt; v.filter(i =&gt; i != 2).map(_ + 1)<br/>res15: scala.collection.immutable.Vector[Int] = Vector(2, 4)<br/><br/>scala&gt; v.collect { case i if i != 2 =&gt; i + 1 }<br/>res16: scala.collection.immutable.Vector[Int] = Vector(2, 4)</pre>
<p>Notice that, in the preceding code, we used <kbd>map(_ + 1)</kbd> instead of <kbd>map(i =&gt; i + 1)</kbd>. This is a shorthand notation for an anonymous function. Whenever you use a parameter once in your anonymous function, you can replace it with <kbd>_</kbd>.</p>
<p>Finally, we pattern match on our zipped and sliding elements using the following:</p>
<pre>case (prevEquity<span>, </span>prevInflation) <span>+: </span>(equity<span>, </span>inflation) <span>+: </span>Vector() =&gt;</pre>
<p>This has the benefit of filtering out sliding elements of size <kbd>0</kbd> or <kbd>1</kbd>, if we were passing equities or inflation arguments of size <kbd>0</kbd> or <kbd>1</kbd>. We will not write a unit test for this edge case in this book, but I encourage you to do so as an excercise.</p>
<p>The rest of the function is straightforward: we use the matched variables to compute the formula and create a new <kbd>VariableReturn</kbd> instance. The resulting iterator is converted to <kbd>Vector</kbd>, and we instantiate a <kbd>VariableReturns</kbd> case class using it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packaging the application</h1>
                </header>
            
            <article>
                
<p>We have now implemented some useful building blocks, and it is time to create an executable so that end users can use our calculator with their own parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the App object</h1>
                </header>
            
            <article>
                
<p>We are going to build a simple executable around <kbd>RetCalc.simulatePlan</kbd>. It will take a list of parameters separated by spaces, and print the results on the console.</p>
<p>The test we are going to write integrates several components together and will use a full market data set. As such, it is not really a unit test anymore; <span>i</span>t is an integration test. For this reason, we suffixed it with IT instead of Spec.</p>
<p>First, copy <kbd>sp500.tsv</kbd> and <kbd>cpi.tsv</kbd> from <a href="https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv">https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/sp500.tsv</a> and <a href="https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv">https://github.com/PacktPublishing/Scala-Programming-Projects/blob/master/Chapter02/retirement-calculator/src/main/resources/cpi.tsv</a> to <kbd>src/main/resources</kbd>, then create a new unit test called <kbd>SimulatePlanIT</kbd> in <kbd>src/test/scala</kbd>:</p>
<pre><span>package </span>retcalc<br/><br/><span>import </span>org.scalactic.TypeCheckedTripleEquals<br/><span>import </span>org.scalatest.{Matchers<span>, </span>WordSpec}<br/><br/><span>class </span>SimulatePlanAppIT <span>extends </span>WordSpec <span>with </span>Matchers <span>with </span>TypeCheckedTripleEquals {<br/>  <span>"SimulatePlanApp.strMain" </span>should {<br/>    <span>"simulate a retirement plan using market returns" </span>in {<span><br/></span><span>      </span><span>val </span>actualResult = SimulatePlanApp.<span>strMain</span>(<br/>        <span>Array</span>(<span>"1997.09,2017.09"</span><span>, </span><span>"25"</span><span>, </span><span>"40"</span><span>, </span><span>"3000"</span><span>, </span><span>"2000"</span><span>, </span><span>"10000"</span>))<br/><br/>      <span>val </span>expectedResult =<br/>        <span>s"""<br/></span><span>          |Capital after 25 years of savings:    499923<br/></span><span>          |Capital after 40 years in retirement: 586435<br/></span><span>        """</span>.stripMargin<br/>      actualResult should === (expectedResult)<br/>    }<br/>  }<br/>}</pre>
<p>We call a function called <kbd>strMain</kbd> which will return a string instead of printing it to the console. This way, we can assert on the content printed to the console. To keep things simple, we assume that the arguments are passed in a specific order. We will develop a more user-friendly interface in the next chapter. The arguments are as follows:</p>
<ol>
<li>A period that we will use in the variables returns, separated by a comma</li>
<li>The number of years of savings</li>
<li>The number of years in retirement</li>
<li>Income</li>
<li>Expenses</li>
<li>Initial capital</li>
</ol>
<p>The expected value is a string that we define using triple quotes. In Scala, a string enclosed in triple quotes lets you enter special characters such as a quote or newline. It is very convenient to enter multiline strings while keeping a good indentation. The <kbd>|</kbd> characters allow you to mark the beginning of each line, and the <kbd>.stripMargin</kbd> function removes the white spaces before the <kbd>|</kbd>, as well as the <kbd>|</kbd> itself in order. In IntelliJ, when you type <kbd>"""</kbd> and then hit <em>Enter</em>, it automatically adds the <kbd>|</kbd> and <kbd>.stripMargin</kbd> after the closing triple quote.</p>
<p>The implementation calls the different functions we implemented earlier. Notice that IntelliJ can autocomplete the name of the files using <em>Ctrl</em> + spacebar, for instance, after <kbd>EquityData.fromResource("Create a new object SimulatePlanApp in the package retcalc</kbd>:</p>
<pre><span>package </span>retcalc<br/><br/><span>object </span>SimulatePlanApp <span>extends </span>App {<br/>  <span>println</span>(<span>strMain</span>(args))<br/><br/>  <span>def </span><span>strMain</span>(args: Array[<span>String</span>]): <span>String </span>= {<br/>    <span>val </span>(from <span>+: </span>until <span>+: </span><span>Nil</span>) = args(<span>0</span>).split(<span>","</span>).toList<br/>    <span>val </span>nbOfYearsSaving = args(<span>1</span>).toInt<br/>    <span>val </span>nbOfYearsInRetirement = args(<span>2</span>).toInt<br/><br/>    <span>val </span>allReturns = Returns.<span>fromEquityAndInflationData</span>(<br/>      equities = EquityData.<span>fromResource</span>(<span>"sp500.tsv"</span>)<span>,<br/></span><span>      </span>inflations = InflationData.<span>fromResource</span>(<span>"cpi.tsv"</span>))<br/>    <span>val </span>(capitalAtRetirement<span>, </span>capitalAfterDeath) = <br/>    RetCalc.<span>simulatePlan</span>(<br/>      returns = allReturns.fromUntil(from<span>, </span>until)<span>,<br/></span><span>      </span>params = <span>RetCalcParams</span>(<br/>        nbOfMonthsInRetirement = nbOfYearsInRetirement * <span>12</span><span>,<br/></span><span>        </span>netIncome = args(<span>3</span>).toInt<span>,<br/></span><span>        </span>currentExpenses = args(<span>4</span>).toInt<span>,<br/></span><span>        </span>initialCapital = args(<span>5</span>).toInt)<span>,<br/></span><span>      </span>nbOfMonthsSavings = nbOfYearsSaving * <span>12</span>)<br/><br/>    <span>s"""<br/></span><span>       |Capital after </span><span>$</span>nbOfYearsSaving<span> years of savings:    <br/>    </span><span>$</span>{capitalAtRetirement.round}<span><br/></span><span>       |Capital after </span><span>$</span>nbOfYearsInRetirement<span> years in retirement: <br/>    </span><span>$</span>{capitalAfterDeath.round}<br/>        <span>"""</span>.stripMargin<br/>  }<br/>}</pre>
<p>The only code executed when we run our executable will be <kbd><span>println</span>(<span>strMain</span>(args))</kbd>. It is a good practice to keep this code as short as possible because it is not covered by any test. Our function <kbd>strMain</kbd> is covered, so we are fairly sure there won't be any unexpected behavior from a single <kbd>println</kbd>. <kbd>args</kbd> is an <kbd>Array[String]</kbd> containing all the arguments passed to the executable.</p>
<p>The first line of <kbd>strMain</kbd> uses a pattern matching on <kbd>List</kbd> to assign <kbd>from</kbd> and <kbd>until</kbd>. The variables will be assigned only if the split first argument, in our test <kbd>"1997.09,2017.09"</kbd>, is a <kbd>List</kbd> of two elements.</p>
<p>Then, we load the equity and inflation data from our <kbd>.tsv</kbd> files. They contain data from 1900.01 until 2017.09. We then call <kbd>Returns.fromEquityAndInflationData</kbd> to compute the real returns.</p>
<p>After having assigned the returns to <kbd>allReturns</kbd>, we call <kbd>simulatePlan</kbd> with the right arguments. The returns are filtered for a specific period using <kbd>from</kbd> and <kbd>until</kbd>. Finally, we return <kbd>String</kbd> using a string interpolation and triple quotes.</p>
<p>This implementation is the first draft and is quite brittle. It will indeed crash with a horrible <kbd>ArrayIndexOutOfBoundsException</kbd> if we do not pass enough parameters to our executable, or with a <kbd>NumberFormatException</kbd> if some strings cannot be converted to <kbd>Int</kbd> or <kbd>Double</kbd>. We will see in the next chapter how we can handle these error cases gracefully, but for now, our calculator does the job as long as we feed it with the right arguments.</p>
<p>You can now run <kbd>SimulatePlanIT</kbd>, and it should pass.</p>
<p>Since we built an application, we can also run it as such. Move your cursor to <kbd>SimulatePlanApp</kbd>, and hit <em>Ctrl</em> + <em>Shift</em> + <em>R</em>. The app should run and crash with an exception because we did not pass any arguments. Click on the launcher for <kbd>SimulatePlanApp</kbd> (underneath the <span class="packt_screen">Build</span> menu), then click <span class="packt_screen">Edit Configurations</span>. Put the following in program arguments:</p>
<pre>1997.09,2017.09 25 40 3000 2000 10000</pre>
<p>Then, click <span class="packt_screen">OK</span>, and run <kbd>SimulatePlanApp</kbd> again. It should print the same content as what we had in our unit test. You can try calling the application with different parameters and observe the resulting calculated capitals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Packaging the application</h1>
                </header>
            
            <article>
                
<p>So far so good, but what if we want to send this application to uncle Bob so that he can plan for his retirement too? It would not be very convenient to ask him to download IntelliJ or SBT. We are going to package our application in a <kbd>.jar</kbd> file so that we can run it with a single command.</p>
<p>SBT provides a package task that can create a <kbd>.jar</kbd> file, but this file will not contain the dependencies. In order to package our own classes as well as the classes coming from the dependent libraries, we are going to use the <kbd>sbt-assembly</kbd> plugin. Create a new file called <kbd>project/assembly.sbt</kbd> containing the following:</p>
<pre>addSbtPlugin(<span>"com.eed3si9n" </span>% <span>"sbt-assembly" </span>% <span>"0.14.6")</span></pre>
<p>Then, edit <kbd>build.sbt</kbd> to define the name of our main class:</p>
<pre><span>name </span>:= <span>"retirement_calculator"<br/></span><span><br/></span><span>version </span>:= <span>"0.1"<br/></span><span><br/></span><span>scalaVersion </span>:= <span>"2.12.4"<br/></span><span><br/></span><span>libraryDependencies </span>+= <span>"org.scalatest" </span>%% <span>"scalatest" </span>% <span>"3.0.4" </span>% <span>"test"<br/></span><span><br/></span><span>mainClass </span>in <span>Compile </span>:= <span>Some</span>(<span>"retcalc.SimulatePlanApp"</span>)</pre>
<p>Click on the <span class="packt_screen">SBT</span> tab on the top-right and then on the <span class="packt_screen">Refresh</span> button. Then, expand the project and double-click on the <span class="packt_screen">a</span><span class="packt_screen">ssembly</span> task:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/536aabaa-077d-46d6-af9c-bbd39c9d0cc1.png" style="width:19.08em;height:19.58em;"/></p>
<p>The <span class="packt_screen">assembly</span> task will compile all the classes, run all the tests, and if they all pass, package a fat JAR. You should see an output similar to this at the bottom of the SBT console:</p>
<pre>[info] Checking every *.class/*.jar file's SHA-1.<br/>[info] Merging files...<br/>[warn] Merging 'META-INF/MANIFEST.MF' with strategy 'discard'<br/>[warn] Strategy 'discard' was applied to a file<br/>[info] SHA-1: 7b7710bf370159c549a11754bf66302a76c209b2<br/>[info] Packaging /home/mikael/projects/scala_fundamentals/retirement_calculator/target/scala-2.12/retirement_calculator-assembly-0.1.jar ...<br/>[info] Done packaging.<br/>[success] Total time: 11 s, completed 14-Jan-2018 12:23:39</pre>
<p>Copy the location of the <kbd>.jar</kbd> file in your clipboard. Now, you can use a Unix terminal or a Windows command prompt and run the application as follows:</p>
<pre>$ java -jar &lt;path to your .jar file&gt; 1997.09,2017.09 25 40 3000 2000 10000<br/><br/>Capital after 25 years of savings: 499923<br/>Capital after 40 years in retirement: 586435</pre>
<p>It is now easier to try different parameters. It is interesting to see that some periods are much more lucrative than others:</p>
<pre>$ java -jar &lt;path to your .jar file&gt; 2000.01,2010.01 25 40 3000 2000 10000<br/><br/>Capital after 25 years of savings:    225209<br/>Capital after 40 years in retirement: -510074<br/>        <br/>$ java -jar &lt;path to your .jar file&gt; 1950.01,1960.01 25 40 3000 2000 10000<br/><br/>Capital after 25 years of savings:    4505196<br/>Capital after 40 years in retirement: 2077953853</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have covered how to create a small project in Scala from scratch to packaging. We used TDD along the way so that it is guaranteed that our code was well-designed and robust. It gives us confidence when we refactor code: as long as all tests pass, we know that our code stills works. We modeled our domain with immutable data structures and processed them using pure functions that have no side effects.</p>
<p>We used some basic features of the language that are used in most projects, and you should now be familiar with enough building blocks to implement a wide variety of projects.</p>
<p>As a further exercise, you could enhance this calculator with one or many of these features:</p>
<ul>
<li>Create an app for the function <kbd>RetCalc.nbOfMonthsSaving</kbd>, which calculates how long you need to save before you can retire.</li>
<li>Create a function called <kbd>RetCalc.annualizedTotalReturn</kbd>, which calculates the geometric average of a sequence of returns. See <a href="https://www.investopedia.com/terms/a/annualized-total-return.asp">https://www.investopedia.com/terms/a/annualized-total-return.asp</a><a href="https://www.investopedia.com/terms/a/annualized-total-return.asp"> </a>for more details.</li>
<li>Create a function called <kbd>monthlyPension</kbd>, which calculates how much you will get in retirement if you save a given amount every month for a given number of months.</li>
<li>Incorporate other streams of income. Maybe you will get a state pension after a number of years, or you might get an inheritance.</li>
<li>Load a different index, such as STOXX Europe 600, MSCI World Index, and so on.</li>
<li>Most people do not invest all their savings in the stock market, but wisely diversify with bonds, that is, typically 60% stocks, 40% bonds. You could add a new function in <kbd>Returns.scala</kbd> to calculate the returns of a mixed portfolio.</li>
<li>We observed that some periods have much higher returns than others. As it is difficult to predict the future, you could run multiple simulations using different periods, and calculate a probability of success.</li>
</ul>
<p>In the next chapter, we will improve our calculator further by handling errors in a functional way.</p>


            </article>

            
        </section>
    </body></html>