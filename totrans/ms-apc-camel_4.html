<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Beans"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Beans</h1></div></div></div><p>In the previous chapter, we saw one of the key, and very helpful, Camel components—the processor. However, a processor is tied to Camel as it extends the <code class="literal">org.apache.camel.Processor</code> interface.</p><p>This means that in order to reuse some existing beans in your application, you have to wrap it in a processor, meaning additional code to be maintained.</p><p>Fortunately, Camel has extensive support for POJO and beans, and bean model frameworks such as Spring or Blueprint.</p><p>In this chapter, we will see:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Camel looks for beans in different registries and the different registry implementations</li><li class="listitem" style="list-style-type: disc">How Camel acts as a service activator to load the beans and bind the parameters</li><li class="listitem" style="list-style-type: disc">The Camel annotations that enables <span class="emphasis"><em>advanced</em></span> binding</li><li class="listitem" style="list-style-type: disc">The Camel language annotations that allow the usage of code in parameter binding</li></ul></div><div class="section" title="Registry"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Registry</h1></div></div></div><p>It's possible to use a bean exactly as<a id="id108" class="indexterm"/> a processor, meaning, directly inline in a route. This allows us to use a lightweight, simple programming model, reusing existing components in Camel routes.</p><p>When a bean is used in a Camel route, the bean must be registered in a registry. Depending on which environment is running, Camel bootstraps different registries. When Camel works with beans, it looks them up in the registry to locate them.</p><p>The registry is defined at the <code class="literal">CamelContext</code> level. A registry is automatically created for you by Camel with the <code class="literal">CamelContext</code>. If you create the <code class="literal">CamelContext</code> manually, you can instantiate a registry and put this registry in the <code class="literal">CamelContext</code>.</p><p>The following registry implementations<a id="id109" class="indexterm"/> are shipped with Camel:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SimpleRegistry</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">JndiRegistry</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ApplicationContextRegistry</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">OsgiServiceRegistry</code></li></ul></div><p>Let's have a look at each one of these in detail.</p><div class="section" title="SimpleRegistry"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>SimpleRegistry</h2></div></div></div><p>
<code class="literal">SimpleRegistry</code> is a simple implementation, mostly used for testing where only a limited number of JDK classes are available. It's basically a simple <code class="literal">Map</code>.</p><p>You have to<a id="id110" class="indexterm"/> create an instance of <code class="literal">SimpleRegistry</code> by hand before using it. Camel <a id="id111" class="indexterm"/>doesn't load any <code class="literal">SimpleRegistry</code> by default.</p><p>The following example in (<code class="literal">chapter4a</code> folder) shows how to create a <code class="literal">SimpleRegistry</code>, register a bean, and use it in a Camel route.</p><p>In this example, we instantiate a <code class="literal">SimpleRegistry</code> that we put in a <code class="literal">CamelContext</code> that we create as well.</p><p>We populate the <code class="literal">SimpleRegistry</code> with a <code class="literal">SimpleBean</code>.</p><p>In the <code class="literal">CamelContext</code>, we add a route that calls the <code class="literal">SimpleBean</code>.</p><p>To simplify the execution, we embed this code in a main method that we execute via a Maven plugin.</p><p>The Maven <code class="literal">pom.xml</code> is the following:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.packt.camel&lt;/groupId&gt;
    &lt;artifactId&gt;chapter4a&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
            &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
            &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.2&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;launch&lt;/id&gt;
                        &lt;phase&gt;verify&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;java&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;mainClass&gt;com.packt.camel.chapter4a.Main&lt;/mainClass&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;</pre></div><p>In the <code class="literal">src/main/java</code> folder of the project, we create the <code class="literal">com.packt.camel.chapter4a</code> package.</p><p>In this <a id="id112" class="indexterm"/>package, we have:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <code class="literal">SimpleBean</code> <a id="id113" class="indexterm"/>class</li><li class="listitem" style="list-style-type: disc">A <code class="literal">Main</code> class</li></ul></div><p>The <code class="literal">SimpleBean</code> class is pretty simple; it just says hello:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4a;

public class SimpleBean {

    public String hello(String message) {
        System.out.println("***** Hello " + message + " *****");
        return "Hello" + message;
    }
}</pre></div><p>The <code class="literal">Main</code> class contains only the main method. It's in this method that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We create a <code class="literal">SimpleRegistry</code></li><li class="listitem" style="list-style-type: disc">We populate the registry with an instance of the <code class="literal">SimpleBean</code></li><li class="listitem" style="list-style-type: disc">We create a <code class="literal">CamelContext</code>, which uses our <code class="literal">SimpleRegistry</code></li><li class="listitem" style="list-style-type: disc">We <a id="id114" class="indexterm"/>create and add a route in the <code class="literal">CamelContext</code>. This route uses the <code class="literal">SimpleBean</code> from the registry</li></ul></div><p>Here's the<a id="id115" class="indexterm"/> code:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4a;

import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.SimpleRegistry;

public final class Main {

  public static void main(String[] args) throws Exception {
    SimpleRegistry registry = new SimpleRegistry();
    registry.put("simpleBean", new SimpleBean());

    CamelContext camelContext = new DefaultCamelContext(registry);
    camelContext.addRoutes(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        from("direct:start").to("bean:simpleBean").to("mock:stop");
      }
    }
    );

  camelContext.start();

   ProducerTemplate producerTemplate = camelContext.createProducerTemplate();
  producerTemplate.sendBody("direct:start", "Packt");
  camelContext.stop();
  }
}</pre></div><p>To run the project, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div><p>You should see the execution:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] --- exec-maven-plugin:1.3.2:java (launch) @ chapter4a ---</strong></span>
<span class="strong"><strong>Hello Packt</strong></span>
<span class="strong"><strong>[INFO] </strong></span>
</pre></div><p>This proves<a id="id116" class="indexterm"/> that the <code class="literal">SimpleRegistry</code> has been used by our <code class="literal">CamelContext</code>. Camel <a id="id117" class="indexterm"/>succeeded in looking for the bean in the registry and using it.</p></div><div class="section" title="JndiRegistry"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>JndiRegistry</h2></div></div></div><p>
<code class="literal">JndiRegistry</code> is an<a id="id118" class="indexterm"/> implementation that uses an existing <span class="strong"><strong>Java Naming and Directory</strong></span> (<span class="strong"><strong>JNDI</strong></span>) registry<a id="id119" class="indexterm"/> to look up beans. It's the default registry used by Camel when using the Camel Java DSL.</p><p>A <code class="literal">JndiRegistry</code> can be constructed using a JNDI InitialContext. It gives the flexibility to use existing JNDI InitialContext. Camel itself provides a simple <code class="literal">JndiContext</code> that you can use with the <code class="literal">JndiRegistry</code>.</p><p>We can illustrate the usage of a <code class="literal">JndiRegistry</code> by implementing an example very similar to the previous one (using a <code class="literal">SimpleRegistry</code>).</p><p>The Maven <code class="literal">pom.xml</code> is basically the same as in the previous example:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.packt.camel&lt;/groupId&gt;
  &lt;artifactId&gt;chapter4b&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
          &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
          &lt;version&gt;2.12.4&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
              &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
              &lt;version&gt;1.3.2&lt;/version&gt;
              &lt;executions&gt;
                  &lt;execution&gt;
                      &lt;id&gt;launch&lt;/id&gt;
                      &lt;phase&gt;verify&lt;/phase&gt;
                      &lt;goals&gt;
                          &lt;goal&gt;java&lt;/goal&gt;
                      &lt;/goals&gt;
                      &lt;configuration&gt;
                          &lt;mainClass&gt;com.packt.camel.chapter4b.Main&lt;/mainClass&gt;
                      &lt;/configuration&gt;
                  &lt;/execution&gt;
              &lt;/executions&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;</pre></div><p>In the <code class="literal">src/main/java</code> directory of the project, we create the <code class="literal">com.packt.camel.chapter4b</code> package.</p><p>This package<a id="id120" class="indexterm"/> contains a <code class="literal">SimpleBean</code> class similar to the one in the<a id="id121" class="indexterm"/> previous example:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4b;

public class SimpleBean {

  public String hello(String message) {
    System.out.println("Hello " + message);
    return "Hello" + message;
  }
}</pre></div><p>Finally, the main difference is in the <code class="literal">Main</code> class; we just replace the <code class="literal">SimpleRegistry</code> with a <code class="literal">JndiRegistry</code>:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4b;

import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.util.jndi.JndiContext;

public final class Main {

  public static void main(String[] args) throws Exception {
    JndiRegistry registry = new JndiRegistry(new JndiContext());
    registry.bind("simpleBean", new SimpleBean());

    CamelContext camelContext = new DefaultCamelContext(registry);
    camelContext.addRoutes(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
             from("direct:start").to("bean:simpleBean").to("mock:stop");
      }
    }
    );

  camelContext.start();

    ProducerTemplate producerTemplate = camelContext.createProducerTemplate();
    producerTemplate.sendBody("direct:start", "Packt");

    camelContext.stop();
  }
}</pre></div><p>To<a id="id122" class="indexterm"/> run the<a id="id123" class="indexterm"/> project, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div><p>The execution gives basically the same result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] --- exec-maven-plugin:1.3.2:java (launch) @ chapter4b ---</strong></span>
<span class="strong"><strong>[WARNING] Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6.</strong></span>



<span class="strong"><strong>Hello Packt</strong></span>
</pre></div><p>We switched to another registry implementation without any impact on the execution.</p><p>As a reminder, the <code class="literal">JndiRegistry</code> is implicitly created by Camel when you use the Java DSL for <a id="id124" class="indexterm"/>your route.</p></div><div class="section" title="ApplicationContextRegistry"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>ApplicationContextRegistry</h2></div></div></div><p>
<code class="literal">ApplicationContextRegistry</code> is a Spring-based implementation to look up beans from the Spring<a id="id125" class="indexterm"/> <code class="literal">ApplicationContext</code>. This implementation is<a id="id126" class="indexterm"/> automatically used when you are using Camel in a Spring environment.</p></div><div class="section" title="OsgiServiceRegistry"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec14"/>OsgiServiceRegistry</h2></div></div></div><p>
<code class="literal">OsgiServiceRegistry</code> is a<a id="id127" class="indexterm"/> hook to the OSGi Service Registry. It's used by Camel when running in OSGi<a id="id128" class="indexterm"/> environment.</p></div></div></div>
<div class="section" title="Creating CompositeRegistry"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Creating CompositeRegistry</h1></div></div></div><p>These registries<a id="id129" class="indexterm"/> can be composed to create a multilayer registry<a id="id130" class="indexterm"/> using a <code class="literal">CompositeRegistry</code>.</p><p>You can create a <code class="literal">CompositeRegistry</code> by adding other registries.</p><p>To illustrate the usage of a <code class="literal">CompositeRegistry</code>, we create a new example.</p><p>Again, the Maven <code class="literal">pom.xml</code> is basically the same:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.packt.camel&lt;/groupId&gt;
    &lt;artifactId&gt;chapter4c&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
            &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
            &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
                &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.2&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;launch&lt;/id&gt;
                        &lt;phase&gt;verify&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;java&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;mainClass&gt;com.packt.camel.chapter4c.Main&lt;/mainClass&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</pre></div><p>In the <code class="literal">src/main/java</code> directory of the project, we have a <code class="literal">com.packt.camel.chapter4c</code> package.</p><p>We again have<a id="id131" class="indexterm"/> the sample <code class="literal">SimpleBean</code> class:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4c;

public class SimpleBean {

    public static String hello(String message) {
        System.out.println("Hello " + message);
        return "Hello" + message;
    }
}</pre></div><p>But this time, in the <code class="literal">Main</code> class, we create two registries that we gather in a composite registry.</p><p>To illustrate the usage, we create two instances of the <code class="literal">SimpleBean</code> in each registry part of the composite, each instance having a different name in the registries.</p><p>We now create two routes in the <code class="literal">CamelContext</code>; one route uses the <code class="literal">SimpleBean</code> instance, and the other uses the <code class="literal">otherBean</code> instance:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4c;

import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.CompositeRegistry;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.impl.SimpleRegistry;
import org.apache.camel.util.jndi.JndiContext;

public final class Main {

  public static void main(String[] args) throws Exception {
    SimpleRegistry simpleRegistry = new SimpleRegistry();
    simpleRegistry.put("simpleBean", new SimpleBean());
    JndiRegistry jndiRegistry = new JndiRegistry(new JndiContext());
    jndiRegistry.bind("otherBean", new SimpleBean());
    CompositeRegistry registry = new CompositeRegistry();
    registry.addRegistry(simpleRegistry);
    registry.addRegistry(jndiRegistry);

    CamelContext camelContext = new DefaultCamelContext(registry);
    camelContext.addRoutes(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        from("direct:start").to("bean:simpleBean").to("mock:stop");
        from("direct:other").to("bean:otherBean").to("mock:stop");
      }
    }
    );

    camelContext.start();

    ProducerTemplate producerTemplate = camelContext.createProducerTemplate();
    producerTemplate.sendBody("direct:start", "Packt");
    producerTemplate.sendBody("direct:other", "Other");

    camelContext.stop();
  }
}</pre></div><p>To run the project, use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mvn clean install</strong></span>
</pre></div><p>Now, at<a id="id132" class="indexterm"/> execution time, we can see that the two routes have been executed, each route using the <code class="literal">bean</code> instance in the registry. But actually, each instance is in a different registry:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[INFO] --- exec-maven-plugin:1.3.2:java (launch) @ chapter4c ---</strong></span>
<span class="strong"><strong>[WARNING] Warning: killAfter is now deprecated. Do you need it ? Please comment on MEXEC-6.</strong></span>



<span class="strong"><strong>Hello Packt</strong></span>
<span class="strong"><strong>Hello Other</strong></span>
</pre></div></div>
<div class="section" title="Service activator"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Service activator</h1></div></div></div><p>Camel acts as a service activator, using <code class="literal">BeanProcessor</code>, which sits between the caller and the actual bean.</p><p>The <code class="literal">BeanProcessor</code> is a special processor that converts the inbound exchange to a method invocation on a bean (POJO).</p><p>The <code class="literal">BeanProcessor</code> performs<a id="id133" class="indexterm"/> the following steps when called:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It looks up the bean in the registry.</li><li class="listitem">It selects the method to invoke the bean.</li><li class="listitem">It binds to the parameters of the selected method.</li><li class="listitem">It actually invokes the method.</li><li class="listitem">It possibly handles any invocation errors that occurred.</li><li class="listitem">It sets the method's reply as the body of the output message.</li></ol></div></div>
<div class="section" title="Bean and method bindings"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Bean and method bindings</h1></div></div></div><p>During step 2, when the<a id="id134" class="indexterm"/> <code class="literal">BeanProcessor</code> selects the method to invoke, the message/method<a id="id135" class="indexterm"/> bindings can occur in different ways. Camel tries the following steps to resolve the bean method:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If the incoming message (<code class="literal">in</code> message) contains the <code class="literal">CamelBeanMethodName</code> header, then this method is invoked, converting the <code class="literal">in</code> message body to the type of the method's argument.</li><li class="listitem">You can specify the method name directly in the route definition (on the bean endpoint).</li><li class="listitem">If the bean contains a method annotated with <code class="literal">@Handler</code>, then this method is invoked.</li><li class="listitem">If the bean can be converted to a processor (containing the <code class="literal">process()</code> method), we fall back to the regular processor usage as seen in the previous chapter.</li><li class="listitem">If the<a id="id136" class="indexterm"/> body of the in message can be converted to a <code class="literal">org.apache.camel.component.bean.BeanInvocation</code> component, then it's the result of the <code class="literal">getMethod()</code> method, which is used as the method name.</li><li class="listitem">Otherwise, the body type of the in message is used to find a matching method.</li></ol></div><p>Several exceptions <a id="id137" class="indexterm"/>can occur during the method lookup. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If Camel cannot find the method, it throws a <code class="literal">MethodNotFoundException</code> exception</li><li class="listitem" style="list-style-type: disc">If Camel cannot uniquely resolve a method (for instance, depending on the method argument), it throws an <code class="literal">AmbigiousMethodCallException</code> exception.</li><li class="listitem" style="list-style-type: disc">Before Camel invokes the selected method, it must convert the in message body to the parameter type required by the method. If this fails, a <code class="literal">NoTypeConversionAvailableException</code> exception is thrown.</li></ul></div><p>Once the method name has been identified, Camel populates the method parameters; it's what we name method parameters binding.</p><p>Some Camel types are automatically bound, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">org.apache.camel.Exchange</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.apache.camel.Message</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.apache.camel.CamelContext</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.apache.camel.TypeConverter</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">org.apache.camel.spi.Registry</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.lang.Exception</code></li></ul></div><p>It means that you can directly use any of these types in the method parameters.</p><p>For instance, your bean may contain a single method:</p><div class="informalexample"><pre class="programlisting">public void doMyStuff(Exchange exchange);</pre></div><p>Camel will provide the current exchange to your method.</p><p>By default, Camel will try<a id="id138" class="indexterm"/> to convert the <code class="literal">in</code> message body as the first parameter of the method.</p><p>The return <a id="id139" class="indexterm"/>statement of the <code class="literal">bean</code> method is used to populate the body of the <code class="literal">in</code> message (in case the bean is used via the Camel bean component) or a header value (in case the bean is used via the <code class="literal">setHeader</code> Camel statement).</p><p>However, depending on your bean, you might have some ambiguity. Camel gives you fine-grained control of the method parameters by providing a set of annotations, which we will cover in the following section.</p></div>
<div class="section" title="Annotations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Annotations</h1></div></div></div><p>Depending on your bean, you might have some ambiguity. Camel gives you fine-grained control of the method parameters by providing a set of annotations.</p><p>Thanks to the <a id="id140" class="indexterm"/>annotations, you can describe the expected binding for both method binding and parameter binding.</p><p>For method binding, Camel provides the <code class="literal">@Handler</code> annotation. This annotation allows you to specify the method that Camel will use during execution.</p><p>For instance, you may have the following bean:</p><div class="informalexample"><pre class="programlisting">public class MyBean {
  public void other(String class) {  }

public void doMyStuff(String class) { ... }
}</pre></div><p>In that case, Camel (without specifying the method to use in the route definition) will fail to find the method to call.</p><p>The <code class="literal">@Handler</code> annotation removes the ambiguity:</p><div class="informalexample"><pre class="programlisting">public class MyBean {
  public void other(String class) { … }
  @Handler
public void doMyStuff(String class) { ... }
}</pre></div><p>Camel also provides annotations for the method parameters binding. The <code class="literal">@Body</code> binds the parameter to the <code class="literal">in</code> message body. It allows to bind type like directly a POJO:</p><div class="informalexample"><pre class="programlisting">@Handler
public void doMyLogic(@Body MyPojo pojo) { … }</pre></div><p>Camel will use a converter to transform the actual in message body to the expected type of the method parameter. The <code class="literal">@ExchangeException</code> binds the parameter to the <code class="literal">Exchange</code> exception. This annotation allows you to directly inject the <code class="literal">Exchange</code> exception in your method. For instance, you can test if the exception is not null and react accordingly.</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @ExchangeException Exception exception) {
  if (exception != null) { … } else { … }
}</pre></div><p>The <code class="literal">@Header</code> binds the parameter to a header of the in message. You can specify the header name on<a id="id141" class="indexterm"/> the annotation as follows:</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Header("FirstHeader") String firstHeader, @Header("SecondHeader") String second header) { … }</pre></div><p>The <code class="literal">@Headers</code> binds the parameter to the <code class="literal">Map</code> containing all headers of the <code class="literal">in</code> message. It's especially interesting when you have to manipulate multiple headers in your method. Using this annotation, the parameter has to be of the <code class="literal">Map</code> type.</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Headers Map headers) { … }</pre></div><p>On the other hand, like <code class="literal">@Headers</code> for the in message, the <code class="literal">@OutHeaders</code> annotation binds the parameter to the <code class="literal">Map</code> containing all headers of the <code class="literal">out</code> message. It's especially interesting when you have to populate some headers (using the <code class="literal">put()</code> method on the Map):</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Headers Map inHeaders, @OutHeaders Map outHeaders) { … }</pre></div><p>The <code class="literal">@Property</code> binds a property of the <code class="literal">Exchange</code>. As a reminder, the lifetime of a property is the <code class="literal">Exchange</code>, whereas a header is related to a message. The name of the property is directly provided on the annotation.</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Property("TheProperty") String exProperty) { … }</pre></div><p>As for the headers, <code class="literal">@Properties</code> binds a property to the <code class="literal">Map</code> containing all the properties of the <code class="literal">Exchange</code>. Again, it's interesting to add new properties to the method (using the <code class="literal">put()</code> method of the <code class="literal">Map</code>):</p><div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Properties Map exProperties) { … }</pre></div><div class="section" title="Annotations for expression languages"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Annotations for expression languages</h2></div></div></div><p>It's also possible to directly leverage the languages supported by Camel to populate the method parameters.</p><p>The following<a id="id142" class="indexterm"/> annotations are provided:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">@Bean</code> binds another bean<a id="id143" class="indexterm"/> to the parameter. It allows you to inject a bean into a bean. Camel will look for the bean with<a id="id144" class="indexterm"/> the ID provided in the annotation:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Bean("anotherBean") AnotherBean anotherBean) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@BeanShell</code> binds the<a id="id145" class="indexterm"/> result of a bean method call to the parameter. BeanShell is a convenient language allowing you to explicitly <a id="id146" class="indexterm"/>call a bean method. The bean scripting is defined directly on the annotation:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @BeanShell("myBean.thisIsMyMethod()") methodResult) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Constant</code> binds<a id="id147" class="indexterm"/> a static String to<a id="id148" class="indexterm"/> the parameter:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Constant("It doesn't change") String myConstant) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@EL</code> binds the result of <a id="id149" class="indexterm"/>an expression<a id="id150" class="indexterm"/> language (JUEL) to the parameter. The expression is defined in the annotation:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @EL("in.header.myHeader == 'expectedValue') boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Groovy</code> binds the<a id="id151" class="indexterm"/> result of a Groovy <a id="id152" class="indexterm"/>expression to the parameter. The expression is defined in the annotation. The request keyword corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Groovy("request.attribute") String attributeValue) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@JavaScript</code> binds<a id="id153" class="indexterm"/> the result of a<a id="id154" class="indexterm"/> JavaScript expression to the parameter. The expression is defined in the annotation:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @JavaScript(in.headers.get('myHeader') == 'expectedValue') boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@MVEL</code> binds the result <a id="id155" class="indexterm"/>of a MVEL expression to the parameter. The expression is defined in the annotation. The request<a id="id156" class="indexterm"/> keyword corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @MVEL("in.headers.myHeader == 'expectedValue'") boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@OGNL</code> binds the result <a id="id157" class="indexterm"/>of a OGNL expression to the parameter. The expression is defined in the annotation. The<a id="id158" class="indexterm"/> request keyword corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @OGNL("in.headers.myHeader == 'expectedValue'") boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@PHP</code> binds the result of <a id="id159" class="indexterm"/>a PHP expression to the parameter. The expression is defined in the annotation. The request keyword<a id="id160" class="indexterm"/> corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @PHP("in.headers.myHeader == 'expectedValue'") boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Python</code> binds the result of a Python expression to the parameter. The expression is defined in<a id="id161" class="indexterm"/> the annotation. The<a id="id162" class="indexterm"/> request keyword corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Python("in.headers.myHeader == 'expectedValue'") boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Ruby</code> binds the result of a Ruby expression to the parameter. The expression is defined in<a id="id163" class="indexterm"/> the annotation. The request Ruby variable <a id="id164" class="indexterm"/>corresponds to the <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Ruby("$request.headers['myHeader'] == 'expectedValue'") boolean matched) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@Simple</code> binds the result<a id="id165" class="indexterm"/> of a simple expression to the parameter. The expression is defined in the annotation. Simple is a Camel language allowing you to define<a id="id166" class="indexterm"/> simple expressions directly using the Camel objects:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@Body String body, @Simple("${in.header.myHeader}") String myHeader) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@XPath</code> binds the result of a XPath expression to the parameter. The expression is defined<a id="id167" class="indexterm"/> in the annotation. It's <a id="id168" class="indexterm"/>very convenient to extract part of an XML <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@XPath("//person/name") String name) { … }</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">@XQuery</code> binds the<a id="id169" class="indexterm"/> result of a XQuery <a id="id170" class="indexterm"/>expression to the parameter. The expression is defined in the annotation. Like XPath, it's very convenient to extract part of a XML <code class="literal">in</code> message:<div class="informalexample"><pre class="programlisting">public void doMyLogic(@XQuery("/person/@name") String name) { … }</pre></div></li></ul></div><p>Of course, it's possible to combine the different annotations with multiple parameters.</p><p>Camel gives you great flexibility, irrespective of the language that you already know, you can use it in the expressions and predicates definition.</p></div></div>
<div class="section" title="Example &#x2013; creating an OSGi bundle with a bean"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Example – creating an OSGi bundle with a bean</h1></div></div></div><p>We illustrate the use of beans in a simple example. This example will create an OSGi bundle containing a<a id="id171" class="indexterm"/> bean called by a Camel route.</p><p>We will create <a id="id172" class="indexterm"/>a bean used in two parts of a route:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One that directly uses the Camel bean component to change the body of the in message</li><li class="listitem" style="list-style-type: disc">Another to define a header in the route</li></ul></div><p>First, we create the Maven project <code class="literal">pom.xml</code> for our bundle:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.packt.camel&lt;/groupId&gt;
  &lt;artifactId&gt;chapter4&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;bundle&lt;/packaging&gt;

  &lt;dependencies&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
          &lt;artifactId&gt;camel-core&lt;/artifactId&gt;
          &lt;version&gt;2.12.4&lt;/version&gt;
      &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
      &lt;plugins&gt;
          &lt;plugin&gt;
              &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
              &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
              &lt;version&gt;2.3.7&lt;/version&gt;
              &lt;extensions&gt;true&lt;/extensions&gt;
              &lt;configuration&gt;
                  &lt;instructions&gt;
                      &lt;Import-Package&gt;*&lt;/Import-Package&gt;
                  &lt;/instructions&gt;
              &lt;/configuration&gt;
          &lt;/plugin&gt;
      &lt;/plugins&gt;
  &lt;/build&gt;

&lt;/project&gt;</pre></div><p>This <code class="literal">pom.xml</code> is pretty simple:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It defines<a id="id173" class="indexterm"/> the Camel core dependency in order to get the bean annotations</li><li class="listitem" style="list-style-type: disc">It uses the<a id="id174" class="indexterm"/> Maven bundle plugin to package the bean and the route as an OSGi bundle</li></ul></div><div class="section" title="Creating the MyBean class"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Creating the MyBean class</h2></div></div></div><p>We<a id="id175" class="indexterm"/> create the <code class="literal">MyBean</code> class<a id="id176" class="indexterm"/> containing two methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">doMyLogic()</code> method is annotated as <code class="literal">@Handler</code> as described previously. It's the one that will be<a id="id177" class="indexterm"/> used by the Camel Bean component. This method has a unique parameter <code class="literal">body</code> of the <code class="literal">String</code> type. Thanks to the <code class="literal">@Body</code> annotation, this parameter will be populated by Camel with the body of the in message.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">setMyHeader()</code> method just<a id="id178" class="indexterm"/> returns <code class="literal">String</code>. This method will be used by Camel to populate a header of the in message.</li></ul></div><p>The code of <code class="literal">MyBean</code> class is as follows:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.chapter4;
  
import org.apache.camel.Body;
import org.apache.camel.Handler;

public class MyBean {

  @Handler
  public String doMyLogic(@Body String body) {
      return "My Logic got " + body;
  }

  public String setMyHeader() {
      return "Here's my header definition, whatever the logic is";
  }

}</pre></div><p>We can note that the doMyLogic() method defines the bean as a message translator: it transforms the body <a id="id179" class="indexterm"/>of the in message in another message body. It looks like the <code class="literal">PrefixerProcessor</code> used in the previous chapter.</p></div><div class="section" title="Writing a route definition using the Camel Blueprint DSL"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Writing a route definition using the Camel Blueprint DSL</h2></div></div></div><p>We are going to use Blueprint DSL to write the definition of the route. Thanks to this, we don't have to<a id="id180" class="indexterm"/> provide all the plumbing code to create the <code class="literal">CamelContext</code> and reference it as an OSGi service.</p><p>The <code class="literal">CamelContext</code> is implicitly<a id="id181" class="indexterm"/> created by Camel, and we describe the route directly using XML.</p><p>In the <code class="literal">OSGI-INF/blueprint</code> folder of our bundle, we create the following <code class="literal">route.xml</code> definition:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

  &lt;bean id="myBean" class="com.packt.camel.chapter4.MyBean"/&gt;

  &lt;camelContext &gt;
      &lt;route&gt;
          &lt;from uri="timer:fire?period=5000"/&gt;
          &lt;setBody&gt;&lt;constant&gt;Hello Chapter4&lt;/constant&gt;&lt;/setBody&gt;
          &lt;to uri="bean:myBean"/&gt;
          &lt;setHeader headerName="myHeaderSetByTheBean"&gt;
              &lt;method bean="myBean" method="setMyHeader"/&gt;
          &lt;/setHeader&gt;
          &lt;to uri="log:blueprintRoute"/&gt;
      &lt;/route&gt;
  &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>First, we declare our bean in the Blueprint container. It means that the Blueprint container will use our class to create an instance of this bean and give it an ID.</p><p>When using the Blueprint DSL, Camel uses a Blueprint container registry; this means that Camel will<a id="id182" class="indexterm"/> lookup the beans using the ID in the Blueprint container.</p><p>Using Camel, DSL would use exactly the same behavior.</p><p>The <code class="literal">&lt;route/&gt;</code> element defines the following route:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The route starts with a timer that creates an empty exchange every 5 seconds.</li><li class="listitem">We define a static content Hello Chapter4 for the body of the <code class="literal">in</code> message using <code class="literal">&lt;setBody/&gt;</code>.</li><li class="listitem">The exchange is sent to our bean. We use the Camel Bean component to directly call <code class="literal">myBean</code>. Camel will look for a bean named myBean in the Blueprint container. Once found, it will use the <code class="literal">doMyLogic()</code> method as it's the one with the <code class="literal">@Handler</code> annotation. Camel will bind the body of the in message with the <code class="literal">doMyLogic()</code> body parameter.</li><li class="listitem">After the<a id="id183" class="indexterm"/> bean processor, we can see another use of the bean. This time, we use the bean (the same instance) to define the <code class="literal">myHeaderSetByTheBean</code> header of the in message. Here we use the <code class="literal">&lt;method/&gt;</code> syntax providing the <code class="literal">myBean</code> bean ID and the <a id="id184" class="indexterm"/><code class="literal">setMyHeader()</code> method. Camel will look for the bean with the <code class="literal">myBean</code> ID in the Blueprint container, and it will call the <code class="literal">setMyHeader()</code> method. The return value of this method will be used to populate the <code class="literal">myHeaderSetByTheBean</code> header.</li><li class="listitem">Finally, we send the exchange to a log endpoint.</li></ol></div></div></div>
<div class="section" title="Building and deploying"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Building and deploying</h1></div></div></div><p>We are now<a id="id185" class="indexterm"/> ready<a id="id186" class="indexterm"/> to build our bundle.</p><p>Using Maven, we run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mvn clean install</strong></span>
<span class="strong"><strong>[INFO] Scanning for projects...</strong></span>
<span class="strong"><strong>[INFO]                                                                       </strong></span>
<span class="strong"><strong>[INFO] ------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Building chapter4 1.0-SNAPSHOT</strong></span>
<span class="strong"><strong>[INFO] ------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-clean-plugin:2.4.1:clean (default-clean) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] Deleting /home/jbonofre/Workspace/sample/chapter4/target</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ chapter4 ---</strong></span>
<span class="strong"><strong>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] Copying 1 resource</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-compiler-plugin:3.2:compile (default-compile) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] Changes detected - recompiling the module!</strong></span>
<span class="strong"><strong>[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] Compiling 1 source file to /home/jbonofre/Workspace/sample/chapter4/target/classes</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ chapter4 ---</strong></span>
<span class="strong"><strong>[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</strong></span>
<span class="strong"><strong>[INFO] skip non existing resourceDirectory /home/jbonofre/Workspace/sample/chapter4/src/test/resources</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-compiler-plugin:3.2:testCompile (default-testCompile) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] No sources to compile</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-surefire-plugin:2.17:test (default-test) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] No tests to run.</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-bundle-plugin:2.3.7:bundle (default-bundle) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-install-plugin:2.5.1:install (default-install) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] Installing /home/jbonofre/Workspace/sample/chapter4/target/chapter4-1.0-SNAPSHOT.jar to /home/jbonofre/.m2/repository/com/packt/camel/chapter4/1.0-SNAPSHOT/chapter4-1.0-SNAPSHOT.jar</strong></span>
<span class="strong"><strong>[INFO] Installing /home/jbonofre/Workspace/sample/chapter4/pom.xml to /home/jbonofre/.m2/repository/com/packt/camel/chapter4/1.0-SNAPSHOT/chapter4-1.0-SNAPSHOT.pom</strong></span>
<span class="strong"><strong>[INFO]</strong></span>
<span class="strong"><strong>[INFO] --- maven-bundle-plugin:2.3.7:install (default-install) @ chapter4 ---</strong></span>
<span class="strong"><strong>[INFO] Installing com/packt/camel/chapter4/1.0-SNAPSHOT/chapter4-1.0-SNAPSHOT.jar</strong></span>
<span class="strong"><strong>[INFO] Writing OBR metadata</strong></span>
<span class="strong"><strong>[INFO] ------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] ------------------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 7.037s</strong></span>
<span class="strong"><strong>[INFO] Finished at: Sun Nov 30 23:07:59 CET 2014</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 32M/1343M</strong></span>
<span class="strong"><strong>[INFO] ------------------------------------------------------------------------</strong></span>
</pre></div><p>Our bundle is now available in our local Maven repository (by default in the <code class="literal">.m2/repository</code> folder of the home directory).</p><p>We can deploy this<a id="id187" class="indexterm"/> bundle in a Karaf OSGi container.</p><p>After having<a id="id188" class="indexterm"/> started Karaf (with <code class="literal">bin/karaf</code> script for instance), we add the Camel features using the <code class="literal">feature:repo-add</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:repo-add camel 2.12.4</strong></span>
<span class="strong"><strong>Adding feature url mvn:org.apache.camel.karaf/apache-camel/2.12.4/xml/features</strong></span>
</pre></div><p>We install the camel-blueprint feature:	</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; feature:install -v camel-blueprint</strong></span>
<span class="strong"><strong>Installing feature camel-blueprint 2.12.4</strong></span>
<span class="strong"><strong>Installing feature camel-core 2.12.4</strong></span>
<span class="strong"><strong>Installing feature xml-specs-api 2.2.0</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.servicemix.specs.activation-api-1.1 [64]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.servicemix.specs.stax-api-1.0 [65]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.servicemix.specs.jaxb-api-2.2 [66]</strong></span>
<span class="strong"><strong>Found installed bundle: stax2-api [67]</strong></span>
<span class="strong"><strong>Found installed bundle: woodstox-core-asl [68]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.servicemix.bundles.jaxb-impl [69]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.camel.camel-core [70]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.camel.karaf.camel-karaf-commands [71]</strong></span>
<span class="strong"><strong>Found installed bundle: org.apache.camel.camel-blueprint [72]</strong></span>
</pre></div><p>We can now install our bundle and start it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; bundle:install mvn:com.packt.camel/chapter4/1.0-SNAPSHOT</strong></span>
<span class="strong"><strong>Bundle ID: 73</strong></span>
<span class="strong"><strong>karaf@root()&gt; bundle:start 73</strong></span>
</pre></div><p>We can see that <a id="id189" class="indexterm"/>our routes are running, since we can see the log<a id="id190" class="indexterm"/> messages (using the <code class="literal">log:display</code> command):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; log:display</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>2014-11-30 23:13:52,944 | INFO  | 1 - timer://fire | blueprintRoute                 | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: My Logic got Hello Chapter4]</strong></span>
<span class="strong"><strong>2014-11-30 23:13:57,943 | INFO  | 1 - timer://fire | blueprintRoute                 | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: My Logic got Hello Chapter4]</strong></span>
<span class="strong"><strong>2014-11-30 23:14:02,945 | INFO  | 1 - timer://fire | blueprintRoute                 | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: My Logic got Hello Chapter4]</strong></span>
<span class="strong"><strong>2014-11-30 23:14:07,944 | INFO  | 1 - timer://fire | blueprintRoute                 | 70 - org.apache.camel.camel-core - 2.12.4 | Exchange[ExchangePattern: InOnly, BodyType: String, Body: My Logic got Hello Chapter4]</strong></span>
</pre></div><p>We can see our route using the <code class="literal">camel:route-list</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; camel:route-list</strong></span>
<span class="strong"><strong> Context      Route        Status   </strong></span>
<span class="strong"><strong> -------      -----        ------   </strong></span>
<span class="strong"><strong> 73-camel-3   route1       Started  </strong></span>
</pre></div><p>The <code class="literal">camel:route-info</code> command gives<a id="id191" class="indexterm"/> details about our route, as<a id="id192" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>karaf@root()&gt; camel:route-info route1</strong></span>
<span class="strong"><strong>Camel Route route1</strong></span>
<span class="strong"><strong>      Camel Context: 73-camel-3</strong></span>

<span class="strong"><strong>Properties</strong></span>
<span class="strong"><strong>              id = route1</strong></span>
<span class="strong"><strong>              parent = 58a5a53e</strong></span>

<span class="strong"><strong>Statistics</strong></span>
<span class="strong"><strong>      Inflight Exchanges: 0</strong></span>
<span class="strong"><strong>      Exchanges Total: 32</strong></span>
<span class="strong"><strong>      Exchanges Completed: 32</strong></span>
<span class="strong"><strong>      Exchanges Failed: 0</strong></span>
<span class="strong"><strong>      Min Processing Time: 1 ms</strong></span>
<span class="strong"><strong>      Max Processing Time: 13 ms</strong></span>
<span class="strong"><strong>      Mean Processing Time: 2 ms</strong></span>
<span class="strong"><strong>      Total Processing Time: 92 ms</strong></span>
<span class="strong"><strong>      Last Processing Time: 3 ms</strong></span>
<span class="strong"><strong>      Delta Processing Time: 0 ms</strong></span>
<span class="strong"><strong>      Load Avg: 0.00, 0.00, 0.00</strong></span>
<span class="strong"><strong>      Reset Statistics Date: 2014-11-30 23:13:36</strong></span>
<span class="strong"><strong>      First Exchange Date: 2014-11-30 23:13:37</strong></span>
<span class="strong"><strong>      Last Exchange Completed Date: 2014-11-30 23:16:12</strong></span>

<span class="strong"><strong>Definition</strong></span>
<span class="strong"><strong>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</strong></span>
<span class="strong"><strong>&lt;route id="route1" &gt;</strong></span>
<span class="strong"><strong>  &lt;from uri="timer:fire?period=5000"/&gt;</strong></span>
<span class="strong"><strong>  &lt;setBody id="setBody1"&gt;</strong></span>
<span class="strong"><strong>      &lt;constant&gt;Hello Chapter4&lt;/constant&gt;</strong></span>
<span class="strong"><strong>  &lt;/setBody&gt;</strong></span>
<span class="strong"><strong>  &lt;to uri="bean:myBean" id="to1"/&gt;</strong></span>
<span class="strong"><strong>  &lt;setHeader headerName="myHeaderSetByTheBean" id="setHeader1"&gt;</strong></span>
<span class="strong"><strong>      &lt;method bean="myBean" method="setMyHeader"&gt;&lt;/method&gt;</strong></span>
<span class="strong"><strong>  &lt;/setHeader&gt;</strong></span>
<span class="strong"><strong>  &lt;to uri="log:blueprintRoute" id="to2"/&gt;</strong></span>
<span class="strong"><strong>&lt;/route&gt;</strong></span>
</pre></div><p>Thanks to the bean support, it's possible to easily use an existing code in Camel routes.</p><p>Moreover, with the wide range of annotations and the supported languages, you have complete control over the usage of your beans.</p><p>Using the DSL<a id="id193" class="indexterm"/> used to write the route definition, Camel knows on which system it's running, and so, it loads different bean registry implementations, making it possible to define the bean in<a id="id194" class="indexterm"/> a standard way.</p><p>The Camel bean support is a great complement to the Camel processors.</p><p>If most of the EIPs that we will see in the next chapter are implemented using Camel processors, some EIPs can be implemented using a bean (such as MessageTranslator EIP).</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to use beans in Camel routes.</p><p>First, we saw the different registries supported, where Camel looks for beans. Specifically, we saw the mapping between the Camel DSL used and the default registry loaded. We saw examples of different registries in action, including the composite registry. For this lookup, Camel acts as a service activator. The example showed how to leverage the Spring or Blueprint service registry.</p><p>We also saw the usage of the annotations to qualify the method and arguments binding. Those annotations can be combined with language annotations, allowing a very powerful way to populate method arguments.</p><p>In the next chapter, we will see one of the Camel key features—routing and Enterprise Integration Patterns support. We will see ready-to-use processors and DSL implementing different EIPs.</p></div></body></html>