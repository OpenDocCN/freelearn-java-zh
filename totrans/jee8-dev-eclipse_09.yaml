- en: Asynchronous Programming with JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we learned how to create web services in JEE. We learned
    to create both RESTful and SOAP-based web services. In this chapter, we will learn
    how to work with messaging systems in JEE. Thus far, we have seen examples of
    clients making requests to the JEE server and waiting till the server sends a
    response back. This is the synchronous model of programming. This model of programming
    may not be suitable when the server takes a long time to process requests. In
    such cases, a client might want to send a request to the server and return immediately
    without waiting for the response. The server would process the request and somehow
    make the result available to the client. Requests and responses in such scenarios
    are sent through messages. Furthermore, there is a message broker that makes sure
    that messages are sent to the appropriate recipients. This is also known as a
    **message-oriented architecture**. The following are some of the advantages of
    adopting a message-oriented architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: It can greatly improve the scalability of the application. Requests are put
    in a queue at one end, and at the other end there could be many handlers listening
    to the queue and processing the requests. As the load increases, more handlers
    can be added, and when the load reduces, some of the handlers can be taken off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging systems can act as glue between disparate software applications. An
    application developed using PHP can put a JSON or XML message in a messaging system,
    which can be processed by a JEE application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to implement an event-driven program. Events can be put as messages
    in a messaging system, and any number of listeners can process events at the other
    end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can reduce the impact of system outages in your application because messages
    are persisted till they are processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many enterprise messaging systems, such as Apache ActiveMQ ([http://activemq.apache.org/](http://activemq.apache.org/)),
    RabbitMQ ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)), and MSMQ ([https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx)).
    The **Java Messaging Service** (**JMS**) specification provides a uniform interface
    for working with many different messaging systems. JMS is also a part of the overall
    Java EE specifications. Refer to [https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ](https://javaee.github.io/tutorial/jms-concepts.html#BNCDQ) for
    an overview of JMS APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of message containers in any messaging system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queue**: This is used for point-to-point messaging. One message producer
    puts a message in a queue, and only one message consumer receives the message.
    There can be multiple listeners for a queue, but only one listener receives the
    message. However, the same listener doesn''t necessarily get all the messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topic**: This is used in the publish-subscribe type of scenario. One message
    producer puts a message in a topic, and many subscribers receive the message.
    Topics are useful for broadcasting messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving messages to and from queues and topics using JMS APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating JMS applications using JSP, JSF, and CDI beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming messages using MDBs (message-driven beans)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see examples of how to use queues and topics in this chapter. We will
    use a GlassFish Server, which has a built-in JMS provider. We will use JMS APIs
    to implement a use case in the *Course Management* application, the same application
    that we have been building in the other chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to send and receive messages using JMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, before we start using JMS APIs, let''s take a look at the generic
    steps involved in using them. The following steps show how to send a message to
    a queue and receive it. Although the steps focus on queues, the steps for topics
    are similar, but with appropriate topic-related classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look up `ConnectionFactory` using JNDI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a JMS connection and start it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a JMS session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Look up JMS `Queue`/`Topic`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For sending messages, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a sender:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the message. It can be of any of the following types: `TextMessage`/`ObjectMessage`/`MapMessage`/`BytesMessage`/`StreamMessage`:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the message:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the connection when no longer needed:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For receiving messages, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a receiver:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Register a message listener or call the `receive` method:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use any variation of the receive method:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use this:'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use this:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In a JEE application that uses EJB, it is recommended to use MDBs. We will see
    an example of MDBs later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When done, close the connection. This stops message listeners too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some of the steps can be skipped when JMS annotations are used or when MDBs
    are used to receive messages. We will see examples later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a working example of sending and receiving messages using
    JMS. Make sure that you have installed the GlassFish application server (refer
    to the *Installing the GlassFish Server* section in [Chapter 1](part0008.html#7K4G0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Introducing JEE and Eclipse*) and configured it in Eclipse JEE (refer to the
    *Configuring the GlassFish Server in Eclipse* section in [Chapter 7](part0129.html#3R0OI0-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating JEE Applications with EJB*). The use case that we will implement in
    this example is of adding a new course. Although this is not a strong use case
    for asynchronous processing, we will assume that this operation takes a long time
    and needs to be handled asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Creating queues and topics in GlassFish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create one queue and one topic in GlassFish. Make sure that the GlassFish
    Server is running. Open the GlassFish admin console. You can right-click the GlassFish
    Server instance configured in Eclipse (in the Servers view) and select GlassFish
    | View Admin Console. This opens the admin console in the built-in Eclipse browser.
    If you want to open it outside Eclipse, in a browser, then browse to `http://localhost:4848/`
    (assuming the default GlassFish installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first create a JMS connection factory. In the admin console, go to the Resources
    | JMS Resources | Connection Factories page. Click the New button to create a
    new connection factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00199.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1: Create a JMS connection factory
  prefs: []
  type: TYPE_NORMAL
- en: Enter JNDI Name of the factory as `jms/CourseManagementCF` and select javax.jms.ConnectionFactory
    as the Resource Type. Leave the default values for Pool Settings. Click OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create queues and topics, go to the Resources | JMS Resources | Destination
    Resources page. Click the New button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Create a JMS queue'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the JNDI Name of the queue as `jms/courseManagementQueue`, Physical Destination
    Name as `CourseManagementQueue`, and select javax.jms.Queue as the Resource Type.
    Click OK to create the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, create the topic by entering the JNDI Name as `jms/courseManagementTopic`, Physical
    Destination Name as `CourseManagementTopic`, and select javax.jms.Topic as the Resource
    Type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have one queue and one topic configured in the Destination Resources
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00201.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Queue and topic created in GlassFish'
  prefs: []
  type: TYPE_NORMAL
- en: Creating JEE project for a JMS application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will see examples of using JMS APIs in three different ways.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, we will create a simple `addCourse.jsp` page, one JSP
    bean, and one `Service` class that actually performs JMS tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we will use JSF and managed beans. We will use JMS APIs
    in the managed beans. We will also see how to use JMS annotations in JSF managed
    beans.
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we will use MDBs to consume JMS messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the first example, which uses JSP, bean, and JMS APIs. Create
    a web project by selecting File | New | Dynamic Web Project or File | New | Other
    and then Web | Dynamic Web Project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00202.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Create a dynamic web project for a JMS app'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the Project name as `CourseManagementJMSWeb`. Make sure that Target runtime
    is GlassFish . Click Next, and accept all the default options. Click Finish to
    create the project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating JMS application using JSP and JSP bean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first create a JSP that displays the form to enter course details. We
    will also create a JSP bean to process the form data. Right-click on the `WebContent`
    folder under the project in the Project Explorer view and select New | JSP File.
    Create the JSP file named `addCourse.jsp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create `CourseDTO` and the JSP bean called `CourseJSPBean`. Create the `CourseDTO`
    class in the `packt.jee.eclipse.jms.dto` package. Add the `id`, `name`, and `credits`
    properties, and the getters and setters for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `CourseJSPBean` in the `packt.jee.eclipse.jms.jsp.beans` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will implement the code to send the `CourseDTO` object to the JMS queue
    later in the `addCourse` method. For now, add the following code to `addCourse.jsp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the JSP file, we check whether the form is submitted. If yes,
    we then create an instance of `CourseJSPBean` and set its properties with values
    from the form submission. Then, we call the `addCourse` method of the bean.
  prefs: []
  type: TYPE_NORMAL
- en: Executing addCourse.jsp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still haven''t added any code to put the `Course` object in the JMS queue.
    However, if you want to test the JSP and bean, add the project to the GlassFish
    server configured in Eclipse. To do this, right-click on the configured server
    in the Servers view of Eclipse and select the Add and Remove... option. Select
    the web project that we created and click on Finish. Make sure that the server
    is started and the status is [Started, Synchronized]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00203.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Status of GlassFish after adding web project'
  prefs: []
  type: TYPE_NORMAL
- en: If the status is Republish, then right-click on the server and select the Publish
    option. If the status is Restart, right-click on the server and select the Restart
    option. You may not have to do this immediately after adding the project, but
    later when we make changes to the code, you may have to republish or restart the
    server, or both. So, keep an eye on the server status before you execute the code
    in Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: To execute `addCourse.jsp`, right-click on the file in either Project Explorer
    or the editor, and select the Run As | Run on Server option. This will open the
    built-in Eclipse browser and open JSP in it. You should see the form for adding
    the course details. If you click the Submit button, you should see the message
    that we added in JSP when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now add a class to send the course details to the JMS queue.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JMS queue sender class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the `CourseQueueSender` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we look up the JMS connection factory and create the connection.
    We then create a JMS session and lookup queue with the JNDI name that we used
    for creating the queue in a previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we did not specify any configuration properties when constructing
    `InitialContext`. This is because the code is executed in the same instance of
    the GlassFish Server that hosts the JMS provider. If you are connecting to a JMS
    provider hosted in a different GlassFish Server, then you will have to specify
    the configuration properties, particularly for the remote host, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `CourseQueueSender.sendAddcourseMessage` method creates instances of `QueueSender` and
    `ObjectMessage`. Because the producer and the consumer of the message in this
    example are in Java, we use `ObjectMessage`. However, if you are to send a message
    to a messaging system where the message is going to be consumed by a non-Java
    consumer, then you could create JSON or XML from the Java object and send `TextMessage`.
    We have already seen how to serialize Java objects to JSON and XML using JAXB
    and JSON-B in [Chapter 9](part0176.html#57R300-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55),
    *Creating Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify the `addCourse` method in `CourseJSPBean` to use the `CourseQueueSender`
    class to send JMS messages. Note that we could create an instance of `CourseQueueSender`
    in the bean class, `CouseJSPBean`, but the bean is created every time the page
    is requested. So, `CourseQueueSender` will be created frequently and the lookup
    for the JMS connection factory and the queue will also execute frequently, which
    is not necessary. Therefore, we will create an instance of `CourseQueueSender`
    and save it in the HTTP session. Then, we will modify the `addCourse` method to
    take `HttpServletRequest` as a parameter. We will also get the `HttpSession` object
    from the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we don't find the `CourseQueueSender` object in the session, then we will
    create one and save it in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to modify the call to the `addCourse` method from `addcourse.jsp`.
    Currently, we do not pass any argument to the method. However, with the preceding
    changes to the `addCourse` method, we need to pass the `HttpServletRequest` object
    to it. JSP has a built-in property called `pageContext` that provides access to
    the `HttpServletRequest` object. So, modify the code in `addCourse.jsp` where
    `courseService.addCourse` is called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can test our code at this point, but although messages are sent to the queue,
    we haven't implemented any consumer to receive them from the queue. So, let's
    implement a JMS queue consumer for our `Course` queue.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JMS queue receiver class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the `CourseQueueReceiver` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code to look up the connection factory and the queue is similar to that
    in `CourseQueueSender`. Note that the constructor takes a `name` argument. We
    don't really need to use the JMS API, but we will use it as an identifier for
    instances of the `CourseQueueReceiver` class. We register a message listener in
    the constructor, and in the `onMessage` method of the listener class we get the `CourseDTO`
    object from the message and print the message to the console. This message will
    appear in the GlassFish console in Eclipse when we execute the code. To keep the
    example simple, we have not implemented the code to save the `Course` information
    to the database, but you can do so using the JDBC or JDO APIs we learned about
    in [Chapter 4](part0073.html#25JP20-d43a3a5ee6dd4ebc9d7c7e1cc8d7df55), *Creating
    JEE Database Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: We need to instantiate the `CourseQueueReceiver` class at application startup,
    so that it will start listening for the messages. One way to implement this is
    in a servlet that loads on startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `JMSReceiverInitServlet` class in the `packt.jee.eclipse.jms.servlet`
    package. We will mark this servlet to load at startup using annotations and instantiate
    `CourseQueueReceiver` in the `init` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Publish the project again in the server and execute `addCourse.jsp` (see the *Executing
    addCourse.jsp* section of this chapter). Switch to the Console view in Eclipse.
    You should see the message that we printed in the `onMessage` method in `CourseQueueReceiver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00204.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Example of a console message from the JMS receiver class'
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple queue listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queues are meant for point-to-point communication, but this does not mean that
    there can''t be more than one listener for a queue. However, only one listener
    gets the message. Furthermore, it is not guaranteed that the same listener will
    get the message every time. If you want to test this, add one more instance of
    `CourseQueueReceiver` in `JMSReceiverInitServlet`. Let''s add the second instance
    with a different name, say `Receiver2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Republish the project, execute `addCourse.jsp`, and add a few courses. Check
    the Console messages. You may see that some of the messages were received by `Receiver1`
    and the others by `Receiver2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00205.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Console output showing multiple JMS receivers listening to a JMS
    queue'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing JMS topic publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to inform a bunch of applications when a new course is
    added. Such use cases can be best implemented by a **JMS topic**. A topic can
    have many subscribers. When a message is added to the topic, all subscribers are
    sent the same message. This is unlike a queue, where only one queue listener gets
    a message.
  prefs: []
  type: TYPE_NORMAL
- en: Steps to publish messages to a topic and subscribe for messages are very similar
    to those for a queue, except for the different classes, and in some cases, different
    method names.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement a topic publisher, which we will use when the message for adding
    a course is successfully handled in the `onMessage` method of the listener class
    implemented in `CourseQueueReceiver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `CourseTopicPublisher` in the `packt.jee.eclipse.jms` package with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is quite simple and self-explanatory. Let''s now modify the queue
    receiver class that we implemented, `CourseQueueReceiver`, to publish a message
    to the topic from the `onMessage` method, after the message from the queue is
    handled successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Implementing JMS topic subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now implement a topic subscriber class to receive messages published
    to the topic we created earlier. Create a `CourseTopicSubscriber` class in the `packt.jee.eclipse.jms`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Again, the JMS APIs to subscribe to a topic are similar to those in `CourseQueueReceiver`,
    but with different class names and method names. We also identify subscribers
    with names so that we know which instance of the class receives the message.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created the topic subscriber by calling `TopicSession.createSubscriber`.
    In this case, the subscriber will receive messages from the topic as long as the
    subscriber is active. If the subscriber becomes inactive and then active again,
    it loses messages published by the topic during that period. If you want to make
    sure that the subscriber receives all the messages, you need to create a durable
    subscription using `TopicSession.createDurableSubscriber`. Along with the topic
    name, this method takes the subscriber name as the second argument. Refer to [https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-](https://javaee.github.io/javaee-spec/javadocs/javax/jms/TopicSession.html#createDurableSubscriber-javax.jms.Topic-java.lang.String-) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create two instances of the `CourseTopicSubscriber` class (so there
    will be two topic subscribers) in `JMSReceiverInitServlet`. These two instances
    will start listening for messages on application startup (the servlet is loaded
    on startup):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have two queue listeners and two topic listeners ready when the application
    starts. Republish the project, execute `addCourse.jsp`, and add a course. Check
    the messages in the Console view of Eclipse. You will see that the message published
    in the topic is received by all subscribers, but the same message published in
    the queue is received by only one receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Console output showing multiple JMS receivers listening to JMS
    queue and topic'
  prefs: []
  type: TYPE_NORMAL
- en: Creating JMS application using JSF and CDI beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to create a JMS application using JSF and **Component
    Dependency Injection** (**CDI**) beans. With CDI beans, we can reduce the code
    that we wrote using JMS APIs, because we can use annotations to inject objects
    such as the JMS connection factory, queue, and topic. Once we obtain references
    to these objects, the steps to send or receive data are the same as those discussed
    in the previous section. Therefore, our examples in this section do not list the
    entire code. For the complete source code, download the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare our project for using JSF, we need to create `web.xml` and add the
    JSF servlet definition and mapping in it. Right-click on the project and select the Java
    EE Tools | Generate Deployment Descriptor Stub option. This creates `web.xml`
    in the `WebContent/WEB-INF` folder. Add the following servlet definition and mapping
    (within the `web-app` tag) in `web.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For CDI beans to work, we need to create a `beans.xml` file in the `META-INF`
    folder. You will find the `META-INF` folder under the `WebContent` folder in the
    project in Eclipse. Let''s create the `bean.xml` file in `META-INF` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will now create two CDI beans for the JSF page. The first one is `CourseManagedMsgSenderBean`.
    The second one is `CourseJSFBean`, which will be referenced from the JSF page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `CourseManagedMsgSenderBean` class in the `packt.jee.eclipse.jms.jsf_bean`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the JMS connection factory and queue objects are injected using the `@Resource`
    annotation. We have used the `@PostConstruct` annotation to create a JMS a connection
    and a session and the `@PreDestroy` annotation for the clean-up operation. The `addCourse`
    method is similar to the code that we already implemented in the `CourseQueueSender`
    class in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the `CourseJSFBean` class in the `packt.jee.eclipse.jms.jsf_bean`
    package with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: An instance of `CourseManagedMsgSenderBean` is injected into `CourseJSFBean` using the `@Inject`
    annotation. The `addCourse` method simply calls the same named method in `CourseManagedMsgSenderBean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create `addCourse.xhtml` in the `WebContents` folder with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Form fields are bound to fields in `CourseJSFBean`. When the Submit button is
    clicked, the `addCourse` method of the same bean is called, which puts a message
    in the JMS queue.
  prefs: []
  type: TYPE_NORMAL
- en: Republish the project and execute `addCourse.xhtml` by right-clicking it and
    selecting Run As | Run on Server. Add a course and see the message printed in
    the GlassFish Console view of Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming JMS messages using MDBs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Message-driven beans** (**MDBs**) make consuming JMS messages a lot easier.
    With just a couple of annotations and implementing the `onMessage` method, you
    can make any Java object a consumer of JMS messages. In this section, we will
    implement an MDB to consume messages from the `Course` queue. To implement MDBs,
    we need to create an EJB project. Select File | New | EJB Project from the main
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00207.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Create a EJB project to implement MDBs'
  prefs: []
  type: TYPE_NORMAL
- en: Enter Project name as `CourseManagementEJB`. Click Next. Accept the default
    values on the subsequent pages and click Finish on the last page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the project and select the New | Message-Driven Bean option.
    This opens the MDB creation wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00208.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: MDB creation wizard – class file information'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `packt.jee.eclipse.jms.mdb` as Java package and `CourseMDB` as Class name.
    Keep Destination type as Queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Destination name is the physical destination name that we specified when creating
    the queue and is not the JNDI name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00209.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: JMS queue physical destination name in the GlassFish admin console'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `CourseManagementQueue` as Destination type. Click Next. Accept the default
    values on the second page and click Finish. The wizard generates the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The class is annotated with `@MessageDriven` with `activationConfig` and the
    JMS destination parameters specified in the wizard. It also creates the `onMessage`
    method. In this method, we just print the message that the MDB received for adding
    a course. To process `ObjectMessage` in this class, we will have to refactor the `CourseDTO`
    class to a shared `.jar` between EJB and the web project. This is left to the
    readers as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The JEE container creates a pool of MDB objects for a single MDB class. An incoming
    message can be handled by any one of the instances of MDB in the pool. This can
    help in building a scalable message processing application.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test the MDB, add the project to the GlassFish Server configured
    in Eclipse. To do this, right-click on the configured server in the Servers view
    of Eclipse and select the Add and Remove... option. Select the CourseManagementEJB
    project that we created and click Finish. Make sure that the server is started
    and the status is [Started, Synchronized]. You also need to add the CourseManagementJMSWeb
    project to the server, because we have JSF and JSP pages to add a course in that
    project. Run `addCourse.xhtml` or `addCourse.jsp` from the CourseManagementJMSWeb
    project, add a course, and check the GlassFish console in Eclipse for messages
    printed from message receivers and the MDB we created in this section. However,
    note that either the MDB or one of the queue listeners we developed in CourseManagementJMSWeb
    will be receiving the message, and not all of the receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A messaging system can be a powerful tool for integrating disparate applications.
    It provides an asynchronous model of programming. The client does not wait for
    the response from the server and the server does not necessarily process requests
    at the same time that the client sends them. A messaging system can also be useful
    for building scalable applications and batch processing. JMS provides uniform
    APIs to access different messaging systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to send and receive messages from queues and
    to publish and subscribe messages from topics. There are many different ways to
    use JMS APIs. We started with the basic JMS APIs and then learned how annotations
    can help reduce some of the code. We also learned how to use MDBs to consume messages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see some of the techniques and tools used for profiling
    CPU and memory usages in Java applications.
  prefs: []
  type: TYPE_NORMAL
