- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Different Parts of the Java Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you know the phenomenon of having to restart an application to boost the
    performance of that application? If so, you may have experienced the outcome of
    poor **memory management**: the memory getting full and the application slowing
    down. This is not always why applications slow down – other causes such as processing
    data from a server or a bottleneck in the network, among other things, play a
    role – but memory management problems are a usual suspect of degrading application
    performance.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably heard of memory in the field of computer science before. That
    makes sense because computers have memory and they use this memory to store and
    access data while running programs (which in their turn are data too!).
  prefs: []
  type: TYPE_NORMAL
- en: So, when does an application use memory? Well, for example, let’s say you’d
    like to run an application that is going to process a huge video file. If you
    do this with your activity monitoring application (for example, Activity Monitor
    on macOS or Task Manager on Windows) open, you’ll see that the used memory increases
    once you open the application and load the video. Memory is a finite resource
    on your computer and once your computer runs out of it, it becomes slow.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to improve the performance of an application. A deeper understanding
    of how exactly this memory works is one of the ways that could help you improve
    the performance of your applications. Memory that is used efficiently by using
    good practices in coding is going to boost the performance of your application.
    So, coding well and being mindful of how the memory works should always be the
    first way to achieve high performance when it comes to memory management. There
    is another way in which Java memory management can be influenced and that is by
    configuring the **Java Virtual Machine** (**JVM**), which takes care of the **Java
    memory**. This is something that we’ll cover in [*Chapter 6*](B18762_06.xhtml#_idTextAnchor086)
    when we’re ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: The efficient handling of Java memory is of crucial importance for the performance
    of a Java application. In Java, this is especially the case because it comes with
    expensive processes such as garbage collection, which again, we’ll see later after
    gaining enough basic knowledge to comprehend it.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management is also important for data integrity in a concurrent context.
    Don’t worry if this sounds very complicated at the moment. By the end of this
    book, you’ll understand what is meant by this.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to optimize the usage of our application’s Java memory, we’ll first need
    to understand what this memory looks like and gain knowledge of the basic processes
    with the memory. In this chapter, we’ll do just that. We’re going to explore the
    different parts of Java memory and how we use this in our day-to-day coding. You’ll
    get a good overview of Java memory and you’ll be ready for the deep dive that’s
    coming in the next chapters. In order to do so, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding computer memory and Java memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating variables in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing variables on the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating objects in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing objects on the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Metaspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at PacktPublishing/B18762_Java-Memory-Management.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding computer memory and Java memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First things first – running applications, Java or not, requires computer memory.
    The application’s memory is the physical memory of the computer. Having more knowledge
    about the memory of the computer is going to help in our understanding of Java
    memory. Therefore, let’s discuss the concept of memory and Java memory in a bit
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Computer memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chances are that you already know this, but just to reiterate: a computer has
    memory. This is the part of the computer that is used for storing information
    that is used for executing processes. We also call this the main memory or sometimes
    primary storage. An important point to make here is that this is different from
    computer storage, where long-term information is stored. This storage is long-term
    because the HDD storage stores the information magnetically and the SDD can be
    qualified as **Electrically Erasable Programmable Read-Only Memory** (**EEPROM**).
    They don’t need constant power to persist the data. On the other hand, one common
    type of main memory, **Random Access Memory** (**RAM**), needs constant electricity
    power to persist data.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be compared to our human brains, at least partially. We have long-term
    and short-term memory. We use our long-term memory for our, well, memories – for
    example, a cherished childhood memory of your father pushing you around playfully
    in a wheelbarrow while your mother quoted from your most beloved storybook while
    you were wearing your favorite outfit that you had as a 3-year-old (magical, let’s
    save the rest for my memoir or therapist). Then there’s short-term memory, which
    is great when you want to remember the six digits for a two-step verification
    process and even better if you can’t recall them a few minutes later.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the main memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The computer, or actually the CPU of the computer, can access the main memory
    much faster than it can access the permanent storage space. In the main memory,
    programs are currently open and the data that they’re using is being stored.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you can recall starting your computer and opening an app you use daily
    for the first time that day and realizing that it takes a few seconds to boot.
    If you close it, perhaps accidentally, and open it again right after closing it,
    it is a lot faster. The main memory works as some sort of cache or buffer, and
    this explains the phenomenon of the shorter load time the second time. The second
    time, it can open it from the main memory instead of from the storage, which proves,
    or at least supports, the point that the main memory is faster.
  prefs: []
  type: TYPE_NORMAL
- en: The great news is that you don’t need to understand the tiniest details of the
    computer memory, but a rough overview will help.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the main memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common part of the main memory is the RAM. The RAM is a huge part of
    what determines the performance of a computer. Running or active applications
    need RAM for storing and accessing data. This memory can be accessed very quickly
    by the applications and processes. If there is enough RAM available and if the
    **Operating System** (**OS**) does a great job of managing the RAM, your applications
    will reach their performance potential.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how much RAM is available by having a look at your monitoring app.
    For me, that is Activity Monitor. As you can see in the following figure, my computer
    is using quite a bit of memory at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5](img/Figure_1.1_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5
  prefs: []
  type: TYPE_NORMAL
- en: I have sorted the processes from high memory to low. At the bottom, you can
    see a summary of the available memory and the memory used. To be honest, this
    seems a little high and I should probably investigate it after writing this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why should I investigate this if I still have a lot of memory available? Well,
    if the RAM gets too full, the applications that are running can only do so very
    slowly. This is something you’re likely to have experienced already when you've
    run more or heavier applications than your computer specifications allowed.
  prefs: []
  type: TYPE_NORMAL
- en: The RAM is volatile. This means that when you turn off the power, the information
    is gone. The main memory does not only consist of RAM. The **Read-Only Memory**
    (**ROM**) is part of the main memory too, but it’s non-volatile. It contains instructions
    that the computer needs to start, so luckily this does not disappear when we turn
    the power off!
  prefs: []
  type: TYPE_NORMAL
- en: Fun fact
  prefs: []
  type: TYPE_NORMAL
- en: We refer to the main memory as RAM, which is very common terminology, but now
    you know it’s technically incorrect! A fun fact indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Java memory and the JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder if we are still going to cover Java memory – and yes, we are!
    The Java memory is somewhat similar to, but also different from, the computer’s
    memory model. However, before we talk about Java memory, I’ll need to explain
    what the JVM is. I really appreciate your patience, I must say.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JVM executes Java applications. Does that mean that the JVM understands
    Java? No, not at all! It understands bytecode – the `.class` files. This means
    the compiled Java programs. The code of some other languages, such as **Kotlin**,
    is compiled to JVM bytecode as well and can therefore be interpreted by the JVM.
    This is why they’re sometimes referred to as JVM languages, such as Java, Kotlin,
    and Scala, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps can be seen in *Figure 1**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Write once, run anywhere](img/Figure_1.2_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Write once, run anywhere
  prefs: []
  type: TYPE_NORMAL
- en: The source code (in the figure, we assume this is Java source code) is being
    compiled by the Java compiler. The result is `.class` files containing bytecode.
    This bytecode can be interpreted by the JVM. Every platform, whether macOS, Windows,
    or Linux, has its own version of the JVM to execute the bytecode. This means that
    the application doesn’t need to be modified to run on different environments because
    the platform-specific JVM takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM is actually why Java once was famous and beloved for its *write once,
    run anywhere* principle. The reason Java is not so famous for this anymore is
    that it’s sort of normal for languages to work this way nowadays. Any platform
    with a JVM installed on it could run Java since the JVM takes care of translating
    it to the machine it’s running on.
  prefs: []
  type: TYPE_NORMAL
- en: I typically compare this to a travel plug adapter. Plugs don’t fit globally
    because different regions use different sockets. You can use your own adapter
    wherever you are when you have the right travel adapter plug with you. In this
    case, the travel adapter would be the JVM. The “*wherever you are*” would be the
    platform you’re trying to run Java on and your adapter would be your Java program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the basics of how the JVM deals with memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management and the JVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java memory stores the data that is required to run Java applications. All
    the instances of classes that live in a Java application are stored in the Java
    memory. This is also true for primitive values. What about constants? Also stored
    in the Java memory! And what about the method codes, native methods, field data,
    method data, and the order in which methods are being executed? You can probably
    guess that they are all stored in Java memory!
  prefs: []
  type: TYPE_NORMAL
- en: One of the tasks of the JVM is managing the Java memory. Without this memory
    management, no memory could be allocated and objects couldn’t be stored. Even
    if that part was in place, it would never be cleaned up. So, cleaning up the memory,
    which is also called the *deallocation of objects*, is of great importance for
    running Java code. Without it, the code can’t run, or if it’s only allocated,
    it will get full and the program will run out of memory. How exactly this works
    is something will learn in [*Chapter 4*](B18762_04.xhtml#_idTextAnchor057) when
    we discuss the deallocation process – called *garbage collection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long story short: memory management is important. It is one of the very important
    tasks of the JVM. Actually, nowadays, we sort of take automatic memory management
    for granted, but in its early days, this was very new and special. Let’s have
    a look at what could happen if the JVM was not managing the memory for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory management before Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`int*` means that `x` holds the value of the pointer to the base address of
    the memory block.'
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc`, which stands for memory allocation, is a function that is used to
    allocate a block of memory with a specified size. In this case, that specified
    size is four times the size of `int`. The function returns the base address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we would then like to assign a value to the memory allocation, we need to
    do this by using `*x` – otherwise, we will be overriding the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we no longer need `*x` to hold the memory location, we need to manually
    free the memory. If we don’t do this, the memory is going to be unavailable and
    used up unnecessarily. Here’s how we could free the memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `free` function to make the memory available again so that it can
    be reallocated later when we request another block of memory. Are we done then?
    No, we’re not. We are still holding the pointer to that memory location. Since
    the memory location is freed up right now, it could be overwritten with something
    else and we wouldn't know what was stored at that point. Therefore, we set our
    pointer to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what would `x` be pointing at after freeing up the memory? Well, the very
    same address – but what is in there? That’s uncertain. Depending on how the freeing
    works, it could either be empty or the old value if it’s not overwritten yet,
    but when it’s overwritten, it would be whatever it was overwritten with. In other
    words: a big surprise! Of course, I usually love surprises, but typically not
    so much when it comes to the value of the variables in my code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common problems with doing memory management manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NULL` after freeing up the memory address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory leaks**: This is what happens if you don’t free up memory that is
    no longer needed. It doesn’t become available again and it remains blocked unnecessarily.
    Eventually, you can run out of memory by holding all the values you don’t need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boilerplate code**: You have a lot of code in the code base that deals with
    allocation and deallocation, but not so much with your business logic. All this
    code needs to be maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NULL`, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other common pitfalls, but I believe that this is more than enough
    to appreciate the JVM and its garbage collector and automatic allocation. Let’s
    see what is implemented in the JVM to be able to do all this.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the JVM’s components for memory management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to execute applications, the JVM has roughly three components in
    place. One is used to load all the classes, the **class loader**. This is actually
    a complex process in itself; the classes are loaded and the bytecode is verified.
    The loading of the classes and the execution of the bytecode requires memory.
    This memory is needed for storing the class data, memory allocation, and the instructions
    that are being executed. This is what the **runtime data areas** component is
    for. This is the part that this book is all about: the Java memory. When the classes
    are loaded, the files need to be executed. The component that executes the bytecode
    after it’s loaded in the main memory using the first two components is commonly
    referred to as the **execution engine**. The execution engine interacts with the
    **Java Native Interface** (**JNI**) to use the native libraries that are required
    for executing the bytecode. These processes and the steps between them are depicted
    in *Figure 1**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Overview of the JVM components for application execution](img/Figure_1.3_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Overview of the JVM components for application execution
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what elements the memory roughly consists of, let’s explore
    the most important component for memory management in more detail: the runtime
    data area.'
  prefs: []
  type: TYPE_NORMAL
- en: Runtime data area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the runtime data areas of the JVM:'
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method area/Metaspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The runtime constant pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program counter register
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The native method stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The different parts of the Java memory are depicted in *Figure 1**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Overview of the different runtime areas](img/Figure_1.4_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Overview of the different runtime areas
  prefs: []
  type: TYPE_NORMAL
- en: The memory consists of different parts as shown in the picture. All these parts
    are needed for the Java application to run. Let us take a detailed look at each
    of these memory parts.
  prefs: []
  type: TYPE_NORMAL
- en: The heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the JVM starts, it reserves a piece of the RAM for the Java application
    to use for dynamic memory allocation. This memory is called the heap. This is
    the area where the runtime data is stored. Class instances can be found on the
    heap. The JVM takes care of assigning space to the heap and cleaning it up with
    a process called garbage collection. Assigning space is also called allocation
    and freeing up this space again is also called deallocation. The deallocation
    of objects on the heap is handled by the garbage collection process of the JVM.
    The garbage collection works with different areas of the heap. These different
    areas and garbage collection are very interesting topics and we’ll discuss them
    in much more detail in [*Chapter 3*](B18762_03.xhtml#_idTextAnchor049) and [*Chapter
    4*](B18762_04.xhtml#_idTextAnchor057).
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The stack, or more precisely, the JVM stack, is where the primitives and pointers
    to the heap are stored. For every method that is called, a frame gets created
    on a stack and this frame also holds the values for this method, such as partial
    results and return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is not just one stack. Every thread in the application has its own thread.
    This is displayed in *Figure 1**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Stack area containing stacks for every thread](img/Figure_1.5_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Stack area containing stacks for every thread
  prefs: []
  type: TYPE_NORMAL
- en: A thread is a path of execution. When an application has multiple threads, this
    means that multiple things are happening at the same time. This happening at the
    same time in an application is a very important concept called **concurrency**.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the stack area of the memory actually contains a lot of stacks
    – one for every thread. The threads can only access their own stacks and the stacks
    cannot have links between them.
  prefs: []
  type: TYPE_NORMAL
- en: So, the stack stores the values necessary for method execution and every thread
    has its own stack. The next part of the runtime data area that we’re going to
    look at is the method area.
  prefs: []
  type: TYPE_NORMAL
- en: The method area (Metaspace)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The method area is where the runtime representation of classes is stored. The
    method area contains the runtime code, static variables, constants pools, and
    constructor code. To summarize: this is where the class’s metadata is stored.
    All threads share this method area. The JVM only specifies the method area, but
    the implementation we have been dealing with since **Java 8** is called the Metaspace.
    The old name for this area was the **PermGen** (as in, **permanent generation**)
    space. There are actually also some differences between PermGen and the Metaspace,
    but these juicy details are for later. Don’t we all love a good cliffhanger?'
  prefs: []
  type: TYPE_NORMAL
- en: The PC register
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Program Counter** (**PC**) register knows what code is being executed
    by holding the address of the instruction that is being executed in its thread.
    In *Figure 1**.6*, you can see a depiction of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – A PC register containing a register for every thread](img/Figure_1.6_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – A PC register containing a register for every thread
  prefs: []
  type: TYPE_NORMAL
- en: Every thread has its own PC register, sometimes also referred to as the call
    stack. It knows the sequence of statements that needs to be executed and which
    one it is executing currently. This is why we need a separate one for every thread
    – with just one PC register, we couldn’t execute multiple threads at the same
    time!
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the stack area, as you can see when you compare *Figure 1**.5*
    and *Figure 1**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: The native method stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s also a native method stack, also known as a **C stack**. It is there
    for the native code that is executed. Native code is part of the implementation
    that is not written in Java, but for example, in C. These are the stacks that
    store the values for the native code, just as the JVM stack does for the Java
    code. Again, every thread has its own. How these are implemented depends on the
    specific implementation of the JVM. Some JVMs don’t support native code; clearly,
    they don’t need native stacks either. This can be found in the documentation of
    the JVM that you are using.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have seen the different parts of the Java runtime data area in
    a bit more detail. Chances are that a lot of new information has been thrown at
    you at this point, and this can be tough! Before we continue, let me explain why
    we even want to know this.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering what I’m still waiting for and be itching
    to get started – and you’re right! We’ll be discussing the basics of memory management,
    stack and heap memory, and the Metaspace in more detail in this chapter, but first,
    we need to have a look at creating variables in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating variables in Java means that we have to declare a variable. If we
    also want to use it, we have to initialize it. As you most likely know, declaration
    is the process of assigning a type and a name. Initializing is about giving the
    variable an actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare the variable and initialize it on the same line. We declare
    it with the type and name. The types here are `int` and `char` and the variable
    names are `number` and `letter`. This can also be separated over multiple lines
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The JVM doesn’t check the types anymore – this is done by the compiler prior
    to running the application. There is actually a difference between the storage
    of primitive types and reference types. This is what we’re going to look at now.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives and reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JVM deals with two types of variables: primitives and reference types.
    There are eight primitive types in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primitive types store just the value, and they are limited to eight types.
    There are also reference types. Reference types are instances of classes. You
    can create your own classes. Therefore, there’s no real limit to how many reference
    types there are.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create variables, there can be two types of values stored in them:
    primitive values and reference values. The primitive values have the type of one
    of the primitives. The reference value is holding a pointer to an object location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'References come in four flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Class references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class reference types hold the (dynamically) created class objects. The array
    reference type has a component type. This is the type of the array. If the component
    type is not of the array type, it is called the element type. The array reference
    always has a single dimension, but the component type can be another array, creating
    multi-dimensional arrays. It doesn’t matter how many dimensions the array has;
    the last component type is not of the array type and is therefore the element
    type. This element type can be one of three types: primitive, class, or interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '`null` is the special case where the reference is not pointing to anything.
    The value of the reference is then `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: How are these variables stored? Primitive and reference variables are stored
    on the stack. The actual object is stored on the heap. Let’s first have a look
    at storing variables on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Storing variables on the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables used in a method are stored on the stack. The stack memory is the
    memory that is used for executing methods. In *Figure 1**.7*, we have shown a
    stack area for three threads, each containing several frames.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Overview of the frames in the stack area for three threads](img/Figure_1.7_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.7 – Overview of the frames in the stack area for three threads
  prefs: []
  type: TYPE_NORMAL
- en: Inside a method, primitives and references exist. Every thread in the application
    has its own stack. The stack consists of frames. Every method that gets invoked
    comes with a new frame on the stack. When the method execution is finished, the
    frame is removed.
  prefs: []
  type: TYPE_NORMAL
- en: If the stack memory is too small to store what is needed for the frame, `StackOverFlowError`
    is thrown. When there is not enough space for a new stack for a new thread, `OutOfMemoryError`
    is thrown. The method that currently is being executed by a thread is called the
    current method and its data is held in the current frame.
  prefs: []
  type: TYPE_NORMAL
- en: Current frame and current method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason that a stack is named as such is that it can only access the top
    frame of the stack. You can compare this to a stack of plates where you can only
    (safely) take plates from the top. The top frame is called the current frame as
    it belongs to the current method – the method that is being executed at that time.
  prefs: []
  type: TYPE_NORMAL
- en: If a method that is being executed calls another method, a frame gets placed
    on top of the frame. This new frame becomes the current frame since the newly
    invoked method is the current method that is being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1**.7*, there are three current frames, because there are three
    threads. The current frames are the ones on top. So, let’s see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Frame for method y** is for **thread 1**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Frame for method c** is for **thread 2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Frame for method k** is for **thread 3**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the method is executed, it gets removed. The previous frame then becomes
    the current frame again since the method that has called the other method is the
    one that gets the control back for the moment and is the method that is being
    executed at that time (the current method).
  prefs: []
  type: TYPE_NORMAL
- en: Elements of the frame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A frame contains a number of elements. These elements are needed to store all
    the necessary data for a method to be executed. An overview of all the elements
    can be seen in *Figure 1**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Schematic overview of a stack frame](img/Figure_1.8_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.8 – Schematic overview of a stack frame
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a frame has a local variable array, an operand stack, and frame
    data. Let us explore the separate elements of the frame in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The array of local variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The local variables of the frame are stored in an array. This array length is
    set during compile time. The array has single and double spots. Single spots are
    for types of `int`, `short`, `char`, `float`, `byte`, `boolean`, and `reference`.
    The double spots are for `long` and `double` (they are 64 bits in size).
  prefs: []
  type: TYPE_NORMAL
- en: 'The local variables can be accessed by their index. There are two types of
    methods: `static` methods (class methods) and `instance` methods. For these `instance`
    methods, the first element of the local variable array is always the reference
    to the object that they exist on, also known as `this`. Parameters that are given
    to the method start from index `1` on the local variable array.'
  prefs: []
  type: TYPE_NORMAL
- en: For `static` methods, no instance needs to be provided to the frame, so they
    start with the parameters that were used to invoke them at index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The operand stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This concept can be a bit rough, so bear with me. Every stack frame has an operand
    stack – a stack (operand stack) on the element (frame) of the stack – and this
    operand stack is used to write operands so that they can be, well, operated upon.
    This is where all the values fly around.
  prefs: []
  type: TYPE_NORMAL
- en: It begs for an example, so let’s have a look at one. When the frame is newly
    created, there is nothing on the operand stack, but let’s assume that the method
    for which the frame was created is going to do a basic mathematical operation,
    such as adding *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: '`x` and `y` are local variables and their values are in the aforementioned
    array of local variables. In order to do the operation, their values need to be
    pushed to the operand stack – so, the value of `x` is going to be pushed first
    and the value of `y` is going to be pushed second.'
  prefs: []
  type: TYPE_NORMAL
- en: The operand stack is a stack, so when it needs to access the variables, it can
    only grab them from the top of the stack. It pops `y` first and then pops `x`.
    After this, the operand stack is empty again. The operation that is being performed
    knows the order of the popped variables. When the operation is done, the result
    is pushed to the operand stack and it can be popped from there.
  prefs: []
  type: TYPE_NORMAL
- en: The operand stack is also used for other important operations, such as preparing
    parameters that need to be sent to a method as input and receiving the results
    that the methods return.
  prefs: []
  type: TYPE_NORMAL
- en: Frame data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The frame data consists of diverse data needed to execute the method. Some examples
    are a reference to the constant pool, how to normally return a method, and abruptly
    completed methods (or exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: The first of these, a reference to the constant pool, requires special attention.
    A class file has all the symbolic references that need to be resolved in the runtime
    constant pool. This pool contains all the constants needed for running the class
    and it is generated by the compiler. It contains the names of identifiers in the
    class and the JVM uses this file during runtime to link the class to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: Every frame has a reference to the constant pool of the current method at runtime.
    Since this is a runtime constant pool with symbolic references, linking needs
    to happen dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at what the constant pool looks like for our silly `Example`
    class. Here is the code for our `Example` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the following command (after we compiled it with `javac Example.java`),
    we can see the constant pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the constant pool has 16 entries. These are the ones created
    by us, but also some created by Java. They are needed to execute the program,
    so the name of the program, method, and so on are created in the constant pool
    to run the program.
  prefs: []
  type: TYPE_NORMAL
- en: Values on the stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The values of the primitive’s local variables are stored directly in the stack
    – to be more precise, on the array of the frame of the method that the local variables
    are in. Objects are not stored on the stack. Instead, the object reference is
    stored on the stack. The object reference is the address at which to find the
    object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Primitives and wrapper classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful not to confuse the primitive types with their object wrapper classes.
    They are easily recognized by the type being in uppercase. The wrapper class objects
    don’t live on the stack, simply because they are objects. Whenever a method has
    been executed, the values of the associated primitives are cleaned up from the
    stack and they are gone forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some wrapper classes are more easily recognized than others. Let’s take a look
    at a code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the wrappers start with a capital and are longer. For many types,
    however, the word is exactly the same and the only difference is that it starts
    with a capital. Personally, I’m most often fooled by `Boolean` and `boolean` (I
    blame C# for this since the equivalent of the Java `boolean` primitive in C# is
    `bool`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see the difference between the other primitives and their reference
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Please note that they have the exact same name. We need to look at the first
    letter to distinguish between the wrapper class and the primitive type. Wrapper
    classes are objects and these are created differently. Let’s find out how.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects in Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are a bundle of values. In Java, they can be created by instantiating
    classes using the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very basic `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to instantiate it, we’ll use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: What this does is create a new `Person` object and store it on the heap. Storing
    on the heap deserves a bit more of an explanation. This is what we’re going to
    zoom in on now!
  prefs: []
  type: TYPE_NORMAL
- en: Storing objects on the heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storing objects on the heap is very different from storing values on the stack.
    As we’ve just seen, references to places on the heap are stored on the stack.
    These references are memory addresses and these memory addresses translate to
    a certain place on the heap where the object is being stored. Without this object
    reference, we would have no way to access an object on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Object references have a certain type. There are very many built-in types in
    Java that we can use, such as `ArrayList`, `String`, all the wrapper classes,
    and more, but we can also create our own objects and these objects will be stored
    on the heap too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap memory holds all the objects that exist in the application. Objects
    on the heap can be accessed from everywhere in the application using the address
    of the object, the object reference. The objects contain the same things as the
    blocks on the stack: the primitive values directly and the addresses for other
    objects on the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1**.9*, you can see an overview of the stack and the heap and what
    this would look like (in a simplified view) for the following Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 1.9 – Overview of the connection between the stack and the heap](img/Figure_1.9_B18762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.9 – Overview of the connection between the stack and the heap
  prefs: []
  type: TYPE_NORMAL
- en: It’s very much simplified – for example, the `String` objects in the `Person`
    object would be separate objects themselves. We’ll focus on the heap in [*Chapter
    3*](B18762_03.xhtml#_idTextAnchor049) to get a more accurate understanding of
    the heap area.
  prefs: []
  type: TYPE_NORMAL
- en: So, what happens when we run out of heap memory? If the application needs more
    heap space than is available, `OutOfMemoryError` is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, we have seen the stack and the heap. There is just one memory area
    that we need to discuss here and that is the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Metaspace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Metaspace is the memory space that holds the class `metadata` that is necessary
    for runtime. It is the method area in the JVM specification and in most popular
    Java implementations after Java SE 7, this area is called the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: If you know about PermGen, or you come across it, just know that this is the
    old memory area where all class `metadata` was stored. It had some limitations
    and has been replaced by the Metaspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to this class `metadata`. What even is that? Class `metadata` is the
    runtime representation of the Java classes that are necessary to run the program.
    It actually contains a lot of things, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Klass* structure (we’ll see more in [*Chapter 5*](B18762_05.xhtml#_idTextAnchor077)
    when we take a deep dive into the Metaspace!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytecode of methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constant pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s it! These are the basics of Java memory management. There is a lot more
    to say about the specific parts. We are going to start with a closer look at primitives
    and objects on the heap in the next chapter, but first, let’s recap what we’ve
    done.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through an overview of Java memory. We started
    with computer memory and learned that the computer has main memory and secondary
    storage. The main memory is most important for us since this is what is used to
    run programs, including Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main memory consists of RAM and ROM. Java applications use RAM to run.
    Java applications are executed by the JVM. This JVM executes Java applications
    and in order to do so, it has three components: a class loader, runtime data areas,
    and an execution engine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We focused on the different components of the runtime data area: the heap,
    stack, method area, PC register, and native method stack.'
  prefs: []
  type: TYPE_NORMAL
- en: The stack is the memory area that is used to store variables and values of methods
    in frames. The heap is used for storing objects. The stack holds references to
    objects on the heap. The heap is accessible from everywhere within the application
    and whoever has an object’s address on the heap can access the object. The stack
    is only accessible for the thread that has created this stack.
  prefs: []
  type: TYPE_NORMAL
- en: The Metaspace is the memory area where the class metadata that is needed during
    runtime is stored.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to visualize and have a closer look at how
    heap and stack memory are combined.
  prefs: []
  type: TYPE_NORMAL
