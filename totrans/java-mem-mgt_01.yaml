- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Different Parts of the Java Memory
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java内存的不同部分
- en: 'Do you know the phenomenon of having to restart an application to boost the
    performance of that application? If so, you may have experienced the outcome of
    poor **memory management**: the memory getting full and the application slowing
    down. This is not always why applications slow down – other causes such as processing
    data from a server or a bottleneck in the network, among other things, play a
    role – but memory management problems are a usual suspect of degrading application
    performance.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道需要重启应用程序以提升该应用程序性能的现象吗？如果是的话，你可能已经体验到了糟糕的**内存管理**的结果：内存满载，应用程序变慢。但这并不总是应用程序变慢的原因——其他原因，如从服务器处理数据或网络瓶颈等，也起着作用——但内存管理问题是导致应用程序性能下降的常见嫌疑。
- en: You’ve probably heard of memory in the field of computer science before. That
    makes sense because computers have memory and they use this memory to store and
    access data while running programs (which in their turn are data too!).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前在计算机科学领域听说过内存。这是有道理的，因为计算机有内存，它们在运行程序时使用这种内存来存储和访问数据（而这些程序本身也是数据！）。
- en: So, when does an application use memory? Well, for example, let’s say you’d
    like to run an application that is going to process a huge video file. If you
    do this with your activity monitoring application (for example, Activity Monitor
    on macOS or Task Manager on Windows) open, you’ll see that the used memory increases
    once you open the application and load the video. Memory is a finite resource
    on your computer and once your computer runs out of it, it becomes slow.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应用程序何时会使用内存呢？例如，假设你想运行一个将要处理大型视频文件的应用程序。如果你在打开活动监视应用程序（例如，macOS上的活动监视器或Windows上的任务管理器）时这样做，你会发现一旦打开应用程序并加载视频，使用的内存就会增加。内存是计算机上的有限资源，一旦你的计算机内存耗尽，它就会变慢。
- en: There are many ways to improve the performance of an application. A deeper understanding
    of how exactly this memory works is one of the ways that could help you improve
    the performance of your applications. Memory that is used efficiently by using
    good practices in coding is going to boost the performance of your application.
    So, coding well and being mindful of how the memory works should always be the
    first way to achieve high performance when it comes to memory management. There
    is another way in which Java memory management can be influenced and that is by
    configuring the **Java Virtual Machine** (**JVM**), which takes care of the **Java
    memory**. This is something that we’ll cover in [*Chapter 6*](B18762_06.xhtml#_idTextAnchor086)
    when we’re ready for it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 提高应用程序性能的方法有很多。深入了解这种内存究竟是如何工作的，是帮助你提高应用程序性能的途径之一。通过在编码中采用良好的实践来高效使用内存，将提升你应用程序的性能。因此，编写良好的代码并关注内存的工作方式，在内存管理方面实现高性能时，始终应该是首要的方法。还有另一种方式可以影响Java内存管理，那就是通过配置**Java虚拟机**（**JVM**），它负责管理**Java内存**。当准备好时，我们将在[*第6章*](B18762_06.xhtml#_idTextAnchor086)中介绍这一点。
- en: The efficient handling of Java memory is of crucial importance for the performance
    of a Java application. In Java, this is especially the case because it comes with
    expensive processes such as garbage collection, which again, we’ll see later after
    gaining enough basic knowledge to comprehend it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 高效管理Java内存对于Java应用程序的性能至关重要。在Java中，这尤其重要，因为它包含昂贵的进程，如垃圾回收，我们将在获得足够的基本知识来理解它之后稍后看到。
- en: Memory management is also important for data integrity in a concurrent context.
    Don’t worry if this sounds very complicated at the moment. By the end of this
    book, you’ll understand what is meant by this.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发环境中，内存管理对于数据完整性也很重要。不用担心，现在这听起来可能非常复杂。到这本书的结尾，你会明白这里的含义。
- en: 'So, to optimize the usage of our application’s Java memory, we’ll first need
    to understand what this memory looks like and gain knowledge of the basic processes
    with the memory. In this chapter, we’ll do just that. We’re going to explore the
    different parts of Java memory and how we use this in our day-to-day coding. You’ll
    get a good overview of Java memory and you’ll be ready for the deep dive that’s
    coming in the next chapters. In order to do so, we’ll cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了优化我们应用程序的Java内存使用，我们首先需要了解这种内存的外观，并掌握与内存相关的基本过程。在本章中，我们将这样做。我们将探讨Java内存的不同部分以及我们如何在日常编码中使用它们。你将获得Java内存的良好概述，并为下一章即将到来的深入探讨做好准备。为此，我们将涵盖以下主题：
- en: Understanding computer memory and Java memory
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解计算机内存和Java内存
- en: Creating variables in Java
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中创建变量
- en: Storing variables on the stack
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈上存储变量
- en: Creating objects in Java
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中创建对象
- en: Storing objects on the heap
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆上存储对象
- en: Exploring the Metaspace
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索元空间
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at PacktPublishing/B18762_Java-Memory-Management.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址是PacktPublishing/B18762_Java-Memory-Management。
- en: Understanding computer memory and Java memory
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解计算机内存和Java内存
- en: First things first – running applications, Java or not, requires computer memory.
    The application’s memory is the physical memory of the computer. Having more knowledge
    about the memory of the computer is going to help in our understanding of Java
    memory. Therefore, let’s discuss the concept of memory and Java memory in a bit
    more detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先——运行应用程序，无论是Java还是其他，都需要计算机内存。应用程序的内存是计算机的物理内存。对计算机内存有更多的了解将有助于我们理解Java内存。因此，让我们更详细地讨论内存和Java内存的概念。
- en: Computer memory
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机内存
- en: 'Chances are that you already know this, but just to reiterate: a computer has
    memory. This is the part of the computer that is used for storing information
    that is used for executing processes. We also call this the main memory or sometimes
    primary storage. An important point to make here is that this is different from
    computer storage, where long-term information is stored. This storage is long-term
    because the HDD storage stores the information magnetically and the SDD can be
    qualified as **Electrically Erasable Programmable Read-Only Memory** (**EEPROM**).
    They don’t need constant power to persist the data. On the other hand, one common
    type of main memory, **Random Access Memory** (**RAM**), needs constant electricity
    power to persist data.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你已经知道这一点，但为了重申：计算机有内存。这是计算机用于存储执行过程所需信息的部分。我们也将这称为主内存或有时称为主要存储。在这里要强调的一个重要观点是，这与计算机存储不同，在计算机存储中存储的是长期信息。这种存储是长期的，因为硬盘存储以磁性方式存储信息，而固态硬盘（SDD）可以被认为是**电可擦可编程只读存储器**（**EEPROM**）。它们不需要持续供电来保持数据。另一方面，一种常见的主内存类型，**随机存取存储器**（**RAM**），需要持续供电来保持数据。
- en: This can be compared to our human brains, at least partially. We have long-term
    and short-term memory. We use our long-term memory for our, well, memories – for
    example, a cherished childhood memory of your father pushing you around playfully
    in a wheelbarrow while your mother quoted from your most beloved storybook while
    you were wearing your favorite outfit that you had as a 3-year-old (magical, let’s
    save the rest for my memoir or therapist). Then there’s short-term memory, which
    is great when you want to remember the six digits for a two-step verification
    process and even better if you can’t recall them a few minutes later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与我们的人类大脑相比较，至少部分如此。我们拥有长期和短期记忆。我们用长期记忆来存储我们的记忆——例如，一个珍贵的童年记忆，你的父亲推着你在一个手推车里嬉戏，而你的母亲在你穿着你三岁时最喜欢的衣服时引用了你最喜爱的故事书（神奇，其余的留给我自己的回忆录或治疗师吧）。然后是短期记忆，当你想要记住用于两步验证过程的六个数字时，它就非常棒了，如果你几分钟内无法回忆起来，那就更好了。
- en: Accessing the main memory
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问主内存
- en: The computer, or actually the CPU of the computer, can access the main memory
    much faster than it can access the permanent storage space. In the main memory,
    programs are currently open and the data that they’re using is being stored.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机或更确切地说，计算机的CPU可以比访问永久存储空间更快地访问主内存。在主内存中，当前打开的程序和它们正在使用的数据被存储。
- en: Maybe you can recall starting your computer and opening an app you use daily
    for the first time that day and realizing that it takes a few seconds to boot.
    If you close it, perhaps accidentally, and open it again right after closing it,
    it is a lot faster. The main memory works as some sort of cache or buffer, and
    this explains the phenomenon of the shorter load time the second time. The second
    time, it can open it from the main memory instead of from the storage, which proves,
    or at least supports, the point that the main memory is faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得你第一次启动计算机并打开你当天首次使用的应用程序，意识到它需要几秒钟才能启动。如果你关闭它，也许是不小心，然后立即再次打开它，它就快得多。主内存就像某种缓存或缓冲区，这解释了第二次加载时间更短的现象。第二次，它可以从主内存而不是从存储中打开，这证明了，至少支持了这样一个观点，即主内存更快。
- en: The great news is that you don’t need to understand the tiniest details of the
    computer memory, but a rough overview will help.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你不需要了解计算机内存的每一个最细微的细节，但一个大致的概述会有所帮助。
- en: Overview of the main memory
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主存储器概述
- en: The most common part of the main memory is the RAM. The RAM is a huge part of
    what determines the performance of a computer. Running or active applications
    need RAM for storing and accessing data. This memory can be accessed very quickly
    by the applications and processes. If there is enough RAM available and if the
    **Operating System** (**OS**) does a great job of managing the RAM, your applications
    will reach their performance potential.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主存储器中最常见的一部分是 RAM。RAM 是决定计算机性能的一个重要因素。正在运行或活跃的应用程序需要 RAM 来存储和访问数据。这种内存可以被应用程序和进程非常快速地访问。如果可用足够的
    RAM，并且操作系统（**OS**）在管理 RAM 方面做得很好，那么你的应用程序将实现其性能潜力。
- en: 'You can see how much RAM is available by having a look at your monitoring app.
    For me, that is Activity Monitor. As you can see in the following figure, my computer
    is using quite a bit of memory at the moment:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看你的监控应用程序来查看可用的 RAM 数量。对我来说，那就是活动监视器。如图所示，我的计算机目前正在使用相当多的内存：
- en: '![Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5](img/Figure_1.1_B18762.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – macOS 12.5 上活动监视器的截图](img/Figure_1.1_B18762.jpg)'
- en: Figure 1.1 – Screenshot of Activity Monitor on macOS 12.5
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – macOS 12.5 上活动监视器的截图
- en: I have sorted the processes from high memory to low. At the bottom, you can
    see a summary of the available memory and the memory used. To be honest, this
    seems a little high and I should probably investigate it after writing this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经按照从高内存到低内存的顺序对进程进行了排序。在底部，你可以看到可用内存和已用内存的摘要。说实话，这看起来有点高，我可能应该在写完这一章后调查一下。
- en: Why should I investigate this if I still have a lot of memory available? Well,
    if the RAM gets too full, the applications that are running can only do so very
    slowly. This is something you’re likely to have experienced already when you've
    run more or heavier applications than your computer specifications allowed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我还要调查这个，如果我还剩下很多内存可用呢？嗯，如果 RAM 太满，正在运行的应用程序只能非常缓慢地执行。这可能是你已经体验过的事情，当你运行了比你的计算机规格允许的更多或更重的应用程序时。
- en: The RAM is volatile. This means that when you turn off the power, the information
    is gone. The main memory does not only consist of RAM. The **Read-Only Memory**
    (**ROM**) is part of the main memory too, but it’s non-volatile. It contains instructions
    that the computer needs to start, so luckily this does not disappear when we turn
    the power off!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RAM 是易失性的。这意味着当你关闭电源时，信息就会消失。主存储器不仅包括 RAM。**只读存储器**（**ROM**）也是主存储器的一部分，但它不是易失性的。它包含计算机启动所需的指令，所以幸运的是，当我们关闭电源时，这些指令不会消失！
- en: Fun fact
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实
- en: We refer to the main memory as RAM, which is very common terminology, but now
    you know it’s technically incorrect! A fun fact indeed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把主存储器称为 RAM，这是一个非常常见的术语，但现在你知道它在技术上是不正确的！这确实是一个有趣的事实。
- en: Java memory and the JVM
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java 内存和 JVM
- en: You may wonder if we are still going to cover Java memory – and yes, we are!
    The Java memory is somewhat similar to, but also different from, the computer’s
    memory model. However, before we talk about Java memory, I’ll need to explain
    what the JVM is. I really appreciate your patience, I must say.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道我们是否还会涵盖 Java 内存 – 是的，我们会！Java 内存与计算机的内存模型有些相似，但也不同。然而，在我们谈论 Java 内存之前，我需要解释
    JVM 是什么。我必须说，我真的很感激你的耐心。
- en: The JVM
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JVM
- en: The JVM executes Java applications. Does that mean that the JVM understands
    Java? No, not at all! It understands bytecode – the `.class` files. This means
    the compiled Java programs. The code of some other languages, such as **Kotlin**,
    is compiled to JVM bytecode as well and can therefore be interpreted by the JVM.
    This is why they’re sometimes referred to as JVM languages, such as Java, Kotlin,
    and Scala, among others.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 执行 Java 应用程序。这意味着 JVM 理解 Java 吗？不，完全不是！它理解字节码 – `.class` 文件。这意味着编译后的 Java
    程序。一些其他语言的代码，例如 **Kotlin**，也被编译成 JVM 字节码，因此也可以被 JVM 解释。这就是为什么它们有时被称为 JVM 语言，例如
    Java、Kotlin 和 Scala 等。
- en: 'The steps can be seen in *Figure 1**.2*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤可以在 *图 1.2* 中看到：
- en: '![Figure 1.2 – Write once, run anywhere](img/Figure_1.2_B18762.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 编译一次，到处运行](img/Figure_1.2_B18762.jpg)'
- en: Figure 1.2 – Write once, run anywhere
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 编译一次，到处运行
- en: The source code (in the figure, we assume this is Java source code) is being
    compiled by the Java compiler. The result is `.class` files containing bytecode.
    This bytecode can be interpreted by the JVM. Every platform, whether macOS, Windows,
    or Linux, has its own version of the JVM to execute the bytecode. This means that
    the application doesn’t need to be modified to run on different environments because
    the platform-specific JVM takes care of that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码（在图中，我们假设这是Java源代码）由Java编译器编译。结果是包含字节码的`.class`文件。这种字节码可以被JVM解释。每个平台，无论是macOS、Windows还是Linux，都有自己的JVM版本来执行字节码。这意味着应用程序不需要修改就可以在不同的环境中运行，因为特定平台的JVM会处理这一点。
- en: The JVM is actually why Java once was famous and beloved for its *write once,
    run anywhere* principle. The reason Java is not so famous for this anymore is
    that it’s sort of normal for languages to work this way nowadays. Any platform
    with a JVM installed on it could run Java since the JVM takes care of translating
    it to the machine it’s running on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JVM实际上是Java曾经因其*一次编写，到处运行*原则而闻名和受到喜爱的原因。Java不再因此闻名的原因是，如今对于语言来说，以这种方式工作似乎是正常的。任何安装了JVM的平台都可以运行Java，因为JVM负责将其转换为运行平台上的机器代码。
- en: I typically compare this to a travel plug adapter. Plugs don’t fit globally
    because different regions use different sockets. You can use your own adapter
    wherever you are when you have the right travel adapter plug with you. In this
    case, the travel adapter would be the JVM. The “*wherever you are*” would be the
    platform you’re trying to run Java on and your adapter would be your Java program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常将此比作旅行插头适配器。插头无法全球通用，因为不同地区使用不同的插座。当你拥有正确的旅行适配器插头时，无论你在哪里，都可以使用自己的适配器。在这种情况下，旅行适配器就是JVM。“无论你在哪里”就是你试图在上面运行Java的平台，而你的适配器就是你的Java程序。
- en: Let’s see the basics of how the JVM deals with memory management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看JVM处理内存管理的基本方法。
- en: Memory management and the JVM
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存管理和JVM
- en: The Java memory stores the data that is required to run Java applications. All
    the instances of classes that live in a Java application are stored in the Java
    memory. This is also true for primitive values. What about constants? Also stored
    in the Java memory! And what about the method codes, native methods, field data,
    method data, and the order in which methods are being executed? You can probably
    guess that they are all stored in Java memory!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Java内存存储了运行Java应用程序所需的数据。在Java应用程序中存在的所有类的实例都存储在Java内存中。这也适用于原始值。那么常量呢？它们也存储在Java内存中！至于方法代码、本地方法、字段数据、方法数据以及方法的执行顺序呢？你可能猜得到，它们都存储在Java内存中！
- en: One of the tasks of the JVM is managing the Java memory. Without this memory
    management, no memory could be allocated and objects couldn’t be stored. Even
    if that part was in place, it would never be cleaned up. So, cleaning up the memory,
    which is also called the *deallocation of objects*, is of great importance for
    running Java code. Without it, the code can’t run, or if it’s only allocated,
    it will get full and the program will run out of memory. How exactly this works
    is something will learn in [*Chapter 4*](B18762_04.xhtml#_idTextAnchor057) when
    we discuss the deallocation process – called *garbage collection*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的一项任务是管理Java内存。没有这种内存管理，就无法分配内存，也无法存储对象。即使这部分已经到位，它也永远不会被清理。因此，清理内存，也称为对象的*释放分配*，对于运行Java代码非常重要。没有它，代码无法运行，或者如果只是分配了，它将填满并导致程序内存不足。具体是如何工作的，我们将在讨论释放过程——称为*垃圾回收*时学习，这将在[*第4章*](B18762_04.xhtml#_idTextAnchor057)中介绍。
- en: 'Long story short: memory management is important. It is one of the very important
    tasks of the JVM. Actually, nowadays, we sort of take automatic memory management
    for granted, but in its early days, this was very new and special. Let’s have
    a look at what could happen if the JVM was not managing the memory for us.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：内存管理很重要。它是JVM非常重要的任务之一。实际上，如今，我们似乎理所当然地认为自动内存管理是理所当然的，但在它的早期，这非常新颖且特别。让我们看看如果JVM没有为我们管理内存会发生什么。
- en: Memory management before Java
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java之前的内存管理
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`int*` means that `x` holds the value of the pointer to the base address of
    the memory block.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`int*`表示`x`持有指向内存块基址的指针的值。'
- en: '`malloc`, which stands for memory allocation, is a function that is used to
    allocate a block of memory with a specified size. In this case, that specified
    size is four times the size of `int`. The function returns the base address.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`，代表内存分配，是一个用于分配指定大小的内存块的函数。在这种情况下，指定的大小是`int`大小的四倍。该函数返回基本地址。'
- en: 'If we would then like to assign a value to the memory allocation, we need to
    do this by using `*x` – otherwise, we will be overriding the location:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要分配一个值给内存分配，我们需要通过使用`*x`来这样做——否则，我们将覆盖位置：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we no longer need `*x` to hold the memory location, we need to manually
    free the memory. If we don’t do this, the memory is going to be unavailable and
    used up unnecessarily. Here’s how we could free the memory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再需要`*x`来持有内存位置时，我们需要手动释放内存。如果我们不这样做，内存将变得不可用，并且不必要地被消耗。以下是我们如何释放内存的方法：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We use the `free` function to make the memory available again so that it can
    be reallocated later when we request another block of memory. Are we done then?
    No, we’re not. We are still holding the pointer to that memory location. Since
    the memory location is freed up right now, it could be overwritten with something
    else and we wouldn't know what was stored at that point. Therefore, we set our
    pointer to `NULL`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`free`函数使内存再次可用，以便在请求另一块内存时可以重新分配。那么我们就完成了吗？不，我们还没有。我们仍然持有该内存位置的指针。由于内存位置现在已被释放，它可能被其他内容覆盖，而我们不知道在那个点存储了什么。因此，我们将我们的指针设置为`NULL`。
- en: 'So, what would `x` be pointing at after freeing up the memory? Well, the very
    same address – but what is in there? That’s uncertain. Depending on how the freeing
    works, it could either be empty or the old value if it’s not overwritten yet,
    but when it’s overwritten, it would be whatever it was overwritten with. In other
    words: a big surprise! Of course, I usually love surprises, but typically not
    so much when it comes to the value of the variables in my code.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在释放内存后，`x`将指向什么？嗯，正是同一个地址——但里面是什么？这是不确定的。根据释放的方式，它可能是空的，或者如果尚未被覆盖，则是旧值，但一旦被覆盖，它将变成被覆盖的内容。换句话说：一个巨大的惊喜！当然，我通常喜欢惊喜，但通常不是在代码中变量的值方面。
- en: 'Here are some common problems with doing memory management manually:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动进行内存管理时，这里有一些常见的问题：
- en: '`NULL` after freeing up the memory address.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存地址后的`NULL`。
- en: '**Memory leaks**: This is what happens if you don’t free up memory that is
    no longer needed. It doesn’t become available again and it remains blocked unnecessarily.
    Eventually, you can run out of memory by holding all the values you don’t need.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存泄漏**：这是当你没有释放不再需要的内存时发生的情况。它不会再次变得可用，并且不必要地保持阻塞。最终，你可能因为保留所有不需要的值而耗尽内存。'
- en: '**Boilerplate code**: You have a lot of code in the code base that deals with
    allocation and deallocation, but not so much with your business logic. All this
    code needs to be maintained.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样板代码**：在代码库中，你有很多处理分配和释放的代码，但与你的业务逻辑关系不大。所有这些代码都需要维护。'
- en: '`NULL`, for example.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`NULL`。
- en: There are other common pitfalls, but I believe that this is more than enough
    to appreciate the JVM and its garbage collector and automatic allocation. Let’s
    see what is implemented in the JVM to be able to do all this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他常见的陷阱，但我相信这已经足够让我们欣赏JVM及其垃圾收集器和自动分配了。让我们看看JVM是如何实现所有这些功能的。
- en: Understanding the JVM’s components for memory management
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JVM的内存管理组件
- en: 'To be able to execute applications, the JVM has roughly three components in
    place. One is used to load all the classes, the **class loader**. This is actually
    a complex process in itself; the classes are loaded and the bytecode is verified.
    The loading of the classes and the execution of the bytecode requires memory.
    This memory is needed for storing the class data, memory allocation, and the instructions
    that are being executed. This is what the **runtime data areas** component is
    for. This is the part that this book is all about: the Java memory. When the classes
    are loaded, the files need to be executed. The component that executes the bytecode
    after it’s loaded in the main memory using the first two components is commonly
    referred to as the **execution engine**. The execution engine interacts with the
    **Java Native Interface** (**JNI**) to use the native libraries that are required
    for executing the bytecode. These processes and the steps between them are depicted
    in *Figure 1**.3*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够执行应用程序，JVM大致有三个组件。一个是用来加载所有类的**类加载器**。这实际上是一个复杂的过程；类被加载，字节码被验证。类的加载和字节码的执行需要内存。这部分内存用于存储类数据、内存分配以及正在执行的指令。这就是**运行时数据区**组件的作用。这是本书的主要内容：Java内存。当类被加载时，文件需要被执行。在主内存中使用前两个组件加载字节码后执行的字节码通常被称为**执行引擎**。执行引擎与**Java本地接口**（**JNI**）交互，以使用执行字节码所需的本地库。这些过程以及它们之间的步骤在*图1.3*中展示：
- en: '![Figure 1.3 – Overview of the JVM components for application execution](img/Figure_1.3_B18762.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 应用程序执行时JVM组件的概述](img/Figure_1.3_B18762.jpg)'
- en: Figure 1.3 – Overview of the JVM components for application execution
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 应用程序执行时JVM组件的概述
- en: 'Now that we know what elements the memory roughly consists of, let’s explore
    the most important component for memory management in more detail: the runtime
    data area.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了内存大致由哪些元素组成，让我们更详细地探讨内存管理最重要的组成部分：运行时数据区。
- en: Runtime data area
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时数据区
- en: 'Here are the runtime data areas of the JVM:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JVM的运行时数据区：
- en: The stack
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈
- en: The heap
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: The method area/Metaspace
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法区/元空间
- en: The runtime constant pool
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时常量池
- en: The program counter register
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序计数器寄存器
- en: The native method stack
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地方法栈
- en: 'The different parts of the Java memory are depicted in *Figure 1**.4*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Java内存的不同部分在*图1.4*中展示：
- en: '![Figure 1.4 – Overview of the different runtime areas](img/Figure_1.4_B18762.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 不同运行时区域的概述](img/Figure_1.4_B18762.jpg)'
- en: Figure 1.4 – Overview of the different runtime areas
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 不同运行时区域的概述
- en: The memory consists of different parts as shown in the picture. All these parts
    are needed for the Java application to run. Let us take a detailed look at each
    of these memory parts.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存由图中所示的不同部分组成。所有这些部分都是Java应用程序运行所需的。让我们详细地查看这些内存部分的每一个。
- en: The heap
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆
- en: When the JVM starts, it reserves a piece of the RAM for the Java application
    to use for dynamic memory allocation. This memory is called the heap. This is
    the area where the runtime data is stored. Class instances can be found on the
    heap. The JVM takes care of assigning space to the heap and cleaning it up with
    a process called garbage collection. Assigning space is also called allocation
    and freeing up this space again is also called deallocation. The deallocation
    of objects on the heap is handled by the garbage collection process of the JVM.
    The garbage collection works with different areas of the heap. These different
    areas and garbage collection are very interesting topics and we’ll discuss them
    in much more detail in [*Chapter 3*](B18762_03.xhtml#_idTextAnchor049) and [*Chapter
    4*](B18762_04.xhtml#_idTextAnchor057).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM启动时，它会为Java应用程序在RAM中预留一块用于动态内存分配的空间。这块内存被称为堆。这是存储运行时数据的地方。类实例可以在堆上找到。JVM负责为堆分配空间，并通过垃圾回收过程清理它。分配空间也称为分配，再次释放这块空间也称为释放。堆上对象的释放由JVM的垃圾回收过程处理。垃圾回收与堆的不同区域协同工作。这些不同的区域和垃圾回收是非常有趣的话题，我们将在[*第3章*](B18762_03.xhtml#_idTextAnchor049)和[*第4章*](B18762_04.xhtml#_idTextAnchor057)中更详细地讨论。
- en: The stack
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 栈
- en: The stack, or more precisely, the JVM stack, is where the primitives and pointers
    to the heap are stored. For every method that is called, a frame gets created
    on a stack and this frame also holds the values for this method, such as partial
    results and return values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 栈，或者更准确地说，JVM 栈，是存储原语和堆指针的地方。对于每个被调用的方法，栈上都会创建一个帧，这个帧也持有这个方法的价值，例如部分结果和返回值。
- en: 'There is not just one stack. Every thread in the application has its own thread.
    This is displayed in *Figure 1**.5*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅有一个栈。应用程序中的每个线程都有自己的线程。这可以在 *图 1*.5 中看到：
- en: '![Figure 1.5 – Stack area containing stacks for every thread](img/Figure_1.5_B18762.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 包含每个线程栈的栈区域](img/Figure_1.5_B18762.jpg)'
- en: Figure 1.5 – Stack area containing stacks for every thread
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 包含每个线程栈的栈区域
- en: A thread is a path of execution. When an application has multiple threads, this
    means that multiple things are happening at the same time. This happening at the
    same time in an application is a very important concept called **concurrency**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是执行路径。当一个应用程序有多个线程时，这意味着同时发生了多件事情。在应用程序中同时发生的事情是一个非常重要的概念，称为 **并发**。
- en: This means that the stack area of the memory actually contains a lot of stacks
    – one for every thread. The threads can only access their own stacks and the stacks
    cannot have links between them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着内存的栈区域实际上包含了很多栈——每个线程一个。线程只能访问自己的栈，栈之间不能有链接。
- en: So, the stack stores the values necessary for method execution and every thread
    has its own stack. The next part of the runtime data area that we’re going to
    look at is the method area.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，栈存储了方法执行所需的所有值，每个线程都有自己的栈。我们将要查看的下一个运行时数据区域是方法区。
- en: The method area (Metaspace)
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法区（Metaspace）
- en: 'The method area is where the runtime representation of classes is stored. The
    method area contains the runtime code, static variables, constants pools, and
    constructor code. To summarize: this is where the class’s metadata is stored.
    All threads share this method area. The JVM only specifies the method area, but
    the implementation we have been dealing with since **Java 8** is called the Metaspace.
    The old name for this area was the **PermGen** (as in, **permanent generation**)
    space. There are actually also some differences between PermGen and the Metaspace,
    but these juicy details are for later. Don’t we all love a good cliffhanger?'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 方法区是存储类运行时表示的地方。方法区包含运行时代码、静态变量、常量池和构造函数代码。总结一下：这是存储类元数据的地方。所有线程共享这个方法区。JVM
    只指定了方法区，但我们自 Java 8 以来所处理的是称为 Metaspace 的实现。这个区域的老名字是 **PermGen**（即，**永久生成**空间）。实际上，PermGen
    和 Metaspace 之间也有一些差异，但这些有趣的细节留待以后讨论。难道我们不喜欢一个好的悬念吗？
- en: The PC register
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PC 寄存器
- en: 'The **Program Counter** (**PC**) register knows what code is being executed
    by holding the address of the instruction that is being executed in its thread.
    In *Figure 1**.6*, you can see a depiction of this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）寄存器通过持有正在执行的指令的地址来知道正在执行什么代码。在 *图 1*.6 中，你可以看到这个的描述：'
- en: '![Figure 1.6 – A PC register containing a register for every thread](img/Figure_1.6_B18762.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 包含每个线程寄存器的 PC 寄存器](img/Figure_1.6_B18762.jpg)'
- en: Figure 1.6 – A PC register containing a register for every thread
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 包含每个线程寄存器的 PC 寄存器
- en: Every thread has its own PC register, sometimes also referred to as the call
    stack. It knows the sequence of statements that needs to be executed and which
    one it is executing currently. This is why we need a separate one for every thread
    – with just one PC register, we couldn’t execute multiple threads at the same
    time!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的 PC 寄存器，有时也称为调用栈。它知道需要执行的语句序列以及当前正在执行的语句。这就是为什么我们需要为每个线程单独一个的原因——只有一个
    PC 寄存器，我们无法同时执行多个线程！
- en: This is similar to the stack area, as you can see when you compare *Figure 1**.5*
    and *Figure 1**.6*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这与栈区域类似，正如你在比较 *图 1*.5 和 *图 1*.6 时可以看到的那样。
- en: The native method stack
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地方法栈
- en: There’s also a native method stack, also known as a **C stack**. It is there
    for the native code that is executed. Native code is part of the implementation
    that is not written in Java, but for example, in C. These are the stacks that
    store the values for the native code, just as the JVM stack does for the Java
    code. Again, every thread has its own. How these are implemented depends on the
    specific implementation of the JVM. Some JVMs don’t support native code; clearly,
    they don’t need native stacks either. This can be found in the documentation of
    the JVM that you are using.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个本地方法堆栈，也称为**C堆栈**。它用于执行本地代码。本地代码是未用Java编写的实现的一部分，例如C。这些堆栈存储本地代码的值，就像JVM堆栈为Java代码做的那样。同样，每个线程都有自己的。这些是如何实现的取决于JVM的具体实现。一些JVM不支持本地代码；显然，它们也不需要本地堆栈。这可以在你使用的JVM的文档中找到。
- en: With this, we have seen the different parts of the Java runtime data area in
    a bit more detail. Chances are that a lot of new information has been thrown at
    you at this point, and this can be tough! Before we continue, let me explain why
    we even want to know this.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经更详细地了解了Java运行时数据区的不同部分。很可能在这一点上，大量的新信息被抛给了你，这可能会很困难！在我们继续之前，让我解释一下我们为什么要了解这些。
- en: At this point, you might be wondering what I’m still waiting for and be itching
    to get started – and you’re right! We’ll be discussing the basics of memory management,
    stack and heap memory, and the Metaspace in more detail in this chapter, but first,
    we need to have a look at creating variables in Java.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道我还在等待什么，迫不及待地想要开始——你是对的！在本章中，我们将更详细地讨论内存管理的基础、堆栈和堆内存以及元空间，但首先，我们需要看看如何在Java中创建变量。
- en: Creating variables in Java
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中创建变量
- en: 'Creating variables in Java means that we have to declare a variable. If we
    also want to use it, we have to initialize it. As you most likely know, declaration
    is the process of assigning a type and a name. Initializing is about giving the
    variable an actual value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中创建变量意味着我们必须声明一个变量。如果我们还想使用它，我们必须初始化它。正如你很可能知道的，声明是将类型和名称分配给变量的过程。初始化是给变量赋予实际值：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we declare the variable and initialize it on the same line. We declare
    it with the type and name. The types here are `int` and `char` and the variable
    names are `number` and `letter`. This can also be separated over multiple lines
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明变量并在同一行上初始化它。我们使用类型和名称来声明它。这里的类型是`int`和`char`，变量名是`number`和`letter`。这也可以像以下这样分多行进行：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The JVM doesn’t check the types anymore – this is done by the compiler prior
    to running the application. There is actually a difference between the storage
    of primitive types and reference types. This is what we’re going to look at now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JVM不再检查类型了——这是在运行应用程序之前由编译器完成的。实际上，原始类型和引用类型的存储之间是有区别的。这正是我们现在要探讨的。
- en: Primitives and reference types
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型和引用类型
- en: 'The JVM deals with two types of variables: primitives and reference types.
    There are eight primitive types in Java:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JVM处理两种类型的变量：原始类型和引用类型。Java中有八种原始类型：
- en: '`int`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`'
- en: '`byte`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`'
- en: '`short`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`'
- en: '`long`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`'
- en: '`float`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`'
- en: '`double`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`'
- en: '`boolean`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`'
- en: '`char`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`'
- en: The primitive types store just the value, and they are limited to eight types.
    There are also reference types. Reference types are instances of classes. You
    can create your own classes. Therefore, there’s no real limit to how many reference
    types there are.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型仅存储值，并且限于八种类型。还有引用类型。引用类型是类的实例。你可以创建自己的类。因此，引用类型的数量实际上是没有限制的。
- en: 'When you create variables, there can be two types of values stored in them:
    primitive values and reference values. The primitive values have the type of one
    of the primitives. The reference value is holding a pointer to an object location.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建变量时，它们可以存储两种类型的值：原始值和引用值。原始值具有原始类型之一。引用值持有对象位置的指针。
- en: 'References come in four flavors:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献有四种类型：
- en: Class references
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类引用
- en: Array references
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组引用
- en: Interface references
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口引用
- en: '`null`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: 'Class reference types hold the (dynamically) created class objects. The array
    reference type has a component type. This is the type of the array. If the component
    type is not of the array type, it is called the element type. The array reference
    always has a single dimension, but the component type can be another array, creating
    multi-dimensional arrays. It doesn’t matter how many dimensions the array has;
    the last component type is not of the array type and is therefore the element
    type. This element type can be one of three types: primitive, class, or interface.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 类引用类型持有（动态）创建的类对象。数组引用类型有一个组件类型。这是数组的类型。如果组件类型不是数组类型，则称为元素类型。数组引用始终具有单个维度，但组件类型可以是另一个数组，从而创建多维数组。数组的维度有多少并不重要；最后一个组件类型不是数组类型，因此是元素类型。这种元素类型可以是以下三种类型之一：原始类型、类或接口。
- en: '`null` is the special case where the reference is not pointing to anything.
    The value of the reference is then `null`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`是引用没有指向任何内容的特殊情况。此时，引用的值是`null`。'
- en: How are these variables stored? Primitive and reference variables are stored
    on the stack. The actual object is stored on the heap. Let’s first have a look
    at storing variables on the stack.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量是如何存储的？原始类型和引用变量存储在堆栈上。实际对象存储在堆上。让我们首先看看如何在堆栈上存储变量。
- en: Storing variables on the stack
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在堆栈上存储变量
- en: Variables used in a method are stored on the stack. The stack memory is the
    memory that is used for executing methods. In *Figure 1**.7*, we have shown a
    stack area for three threads, each containing several frames.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中使用的变量存储在堆栈上。堆栈内存是用于执行方法的内存。在**图1.7**中，我们展示了三个线程的堆栈区域，每个区域包含多个帧。
- en: '![Figure 1.7 – Overview of the frames in the stack area for three threads](img/Figure_1.7_B18762.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 三线程堆栈区域的帧概述](img/Figure_1.7_B18762.jpg)'
- en: Figure 1.7 – Overview of the frames in the stack area for three threads
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 三线程堆栈区域的帧概述
- en: Inside a method, primitives and references exist. Every thread in the application
    has its own stack. The stack consists of frames. Every method that gets invoked
    comes with a new frame on the stack. When the method execution is finished, the
    frame is removed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，存在原始类型和引用。应用程序中的每个线程都有自己的堆栈。堆栈由帧组成。每个被调用的方法都会在堆栈上带来一个新的帧。当方法执行完成后，帧会被移除。
- en: If the stack memory is too small to store what is needed for the frame, `StackOverFlowError`
    is thrown. When there is not enough space for a new stack for a new thread, `OutOfMemoryError`
    is thrown. The method that currently is being executed by a thread is called the
    current method and its data is held in the current frame.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果堆栈内存太小，无法存储帧所需的内容，则会抛出`StackOverFlowError`。当为新线程分配新的堆栈空间不足时，会抛出`OutOfMemoryError`。当前线程正在执行的方法称为当前方法，其数据存储在当前帧中。
- en: Current frame and current method
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前帧和当前方法
- en: The reason that a stack is named as such is that it can only access the top
    frame of the stack. You can compare this to a stack of plates where you can only
    (safely) take plates from the top. The top frame is called the current frame as
    it belongs to the current method – the method that is being executed at that time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈之所以被称为堆栈，是因为它只能访问堆栈的顶部帧。你可以将其比作盘子堆，你只能（安全地）从顶部取盘子。顶部帧称为当前帧，因为它属于当前方法——当时正在执行的方法。
- en: If a method that is being executed calls another method, a frame gets placed
    on top of the frame. This new frame becomes the current frame since the newly
    invoked method is the current method that is being executed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在执行的方法调用另一个方法，则会在帧的顶部放置一个新的帧。这个新帧成为当前帧，因为新调用的方法是当前正在执行的方法。
- en: 'In *Figure 1**.7*, there are three current frames, because there are three
    threads. The current frames are the ones on top. So, let’s see the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图1.7**中，有三个当前帧，因为有三个线程。当前帧位于顶部。所以，让我们看看以下内容：
- en: The **Frame for method y** is for **thread 1**
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法y的帧**是为**线程1**准备的'
- en: The **Frame for method c** is for **thread 2**
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法c的帧**是为**线程2**准备的'
- en: The **Frame for method k** is for **thread 3**
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法k的帧**是为**线程3**准备的'
- en: When the method is executed, it gets removed. The previous frame then becomes
    the current frame again since the method that has called the other method is the
    one that gets the control back for the moment and is the method that is being
    executed at that time (the current method).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法被执行时，它被移除。然后，之前的框架再次成为当前框架，因为调用其他方法的方法是暂时获得控制权的方法，也是当时正在执行的方法（当前方法）。
- en: Elements of the frame
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架元素
- en: 'A frame contains a number of elements. These elements are needed to store all
    the necessary data for a method to be executed. An overview of all the elements
    can be seen in *Figure 1**.8*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个框架包含许多元素。这些元素用于存储方法执行所需的所有必要数据。所有元素的概述可以在 *图 1**.8* 中看到：
- en: '![Figure 1.8 – Schematic overview of a stack frame](img/Figure_1.8_B18762.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 栈帧的示意图](img/Figure_1.8_B18762.jpg)'
- en: Figure 1.8 – Schematic overview of a stack frame
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 栈帧的示意图
- en: As you can see, a frame has a local variable array, an operand stack, and frame
    data. Let us explore the separate elements of the frame in more detail.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，一个框架包含局部变量数组、操作数栈和框架数据。让我们更详细地探讨框架的各个单独元素。
- en: The array of local variables
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量数组
- en: The local variables of the frame are stored in an array. This array length is
    set during compile time. The array has single and double spots. Single spots are
    for types of `int`, `short`, `char`, `float`, `byte`, `boolean`, and `reference`.
    The double spots are for `long` and `double` (they are 64 bits in size).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的局部变量存储在一个数组中。这个数组的长度在编译时设置。该数组有单倍和双倍位置。单倍位置用于 `int`、`short`、`char`、`float`、`byte`、`boolean`
    和 `reference` 类型。双倍位置用于 `long` 和 `double`（它们的大小为 64 位）。
- en: 'The local variables can be accessed by their index. There are two types of
    methods: `static` methods (class methods) and `instance` methods. For these `instance`
    methods, the first element of the local variable array is always the reference
    to the object that they exist on, also known as `this`. Parameters that are given
    to the method start from index `1` on the local variable array.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过索引访问局部变量。有两种类型的方法：`static` 方法（类方法）和 `instance` 方法。对于这些 `instance` 方法，局部变量数组的第一元素始终是它们存在的对象的引用，也称为
    `this`。传递给方法的参数从局部变量数组的索引 `1` 开始。
- en: For `static` methods, no instance needs to be provided to the frame, so they
    start with the parameters that were used to invoke them at index `0`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `static` 方法，不需要向框架提供实例，因此它们从索引 `0` 处开始使用调用它们的参数。
- en: The operand stack
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作数栈
- en: This concept can be a bit rough, so bear with me. Every stack frame has an operand
    stack – a stack (operand stack) on the element (frame) of the stack – and this
    operand stack is used to write operands so that they can be, well, operated upon.
    This is where all the values fly around.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可能有点粗糙，请耐心听我说。每个栈帧都有一个操作数栈——一个位于栈元素（框架）上的栈（操作数栈）——这个操作数栈用于写入操作数，以便它们可以被操作。这就是所有值飞来飞去的地方。
- en: It begs for an example, so let’s have a look at one. When the frame is newly
    created, there is nothing on the operand stack, but let’s assume that the method
    for which the frame was created is going to do a basic mathematical operation,
    such as adding *x* and *y*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要举一个例子，所以让我们看看一个例子。当框架被新创建时，操作数栈上没有任何东西，但让我们假设创建框架的方法将要执行一个基本的数学运算，比如添加 *x*
    和 *y*。
- en: '`x` and `y` are local variables and their values are in the aforementioned
    array of local variables. In order to do the operation, their values need to be
    pushed to the operand stack – so, the value of `x` is going to be pushed first
    and the value of `y` is going to be pushed second.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 是局部变量，它们的值在前面提到的局部变量数组中。为了进行操作，它们的值需要推送到操作数栈——所以，`x` 的值将被首先推送，`y`
    的值将被其次推送。'
- en: The operand stack is a stack, so when it needs to access the variables, it can
    only grab them from the top of the stack. It pops `y` first and then pops `x`.
    After this, the operand stack is empty again. The operation that is being performed
    knows the order of the popped variables. When the operation is done, the result
    is pushed to the operand stack and it can be popped from there.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数栈是一个栈，所以当它需要访问变量时，它只能从栈顶获取它们。它首先弹出 `y`，然后弹出 `x`。之后，操作数栈再次为空。正在执行的操作知道弹出变量的顺序。操作完成后，结果被推送到操作数栈，并可以从那里弹出。
- en: The operand stack is also used for other important operations, such as preparing
    parameters that need to be sent to a method as input and receiving the results
    that the methods return.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数栈也用于其他重要操作，例如准备需要作为输入发送到方法中的参数，以及接收方法返回的结果。
- en: Frame data
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帧数据
- en: The frame data consists of diverse data needed to execute the method. Some examples
    are a reference to the constant pool, how to normally return a method, and abruptly
    completed methods (or exceptions).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 帧数据由执行方法所需的各种数据组成。一些例子包括对常量池的引用、如何正常返回方法以及突然完成的方法（或异常）。
- en: The first of these, a reference to the constant pool, requires special attention.
    A class file has all the symbolic references that need to be resolved in the runtime
    constant pool. This pool contains all the constants needed for running the class
    and it is generated by the compiler. It contains the names of identifiers in the
    class and the JVM uses this file during runtime to link the class to other classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个，对常量池的引用，需要特别注意。类文件包含所有需要在运行时常量池中解析的符号引用。这个池包含运行类所需的所有常量，并且由编译器生成。它包含类中标识符的名称，JVM在运行时使用这个文件将类链接到其他类。
- en: Every frame has a reference to the constant pool of the current method at runtime.
    Since this is a runtime constant pool with symbolic references, linking needs
    to happen dynamically.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帧在运行时都有一个对当前方法常量池的引用。由于这是一个具有符号引用的运行时常量池，链接需要动态发生。
- en: 'Let’s have a look at what the constant pool looks like for our silly `Example`
    class. Here is the code for our `Example` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的愚蠢的`Example`类的常量池是什么样的。以下是我们的`Example`类的代码：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By running the following command (after we compiled it with `javac Example.java`),
    we can see the constant pool:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令（在我们用`javac Example.java`编译之后），我们可以看到常量池：
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, you can see the output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到输出结果：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, the constant pool has 16 entries. These are the ones created
    by us, but also some created by Java. They are needed to execute the program,
    so the name of the program, method, and so on are created in the constant pool
    to run the program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，常量池有16个条目。这些是我们创建的，但也有一些是Java创建的。它们是执行程序所需的，因此程序名称、方法等都在常量池中创建以运行程序。
- en: Values on the stack
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈上的值
- en: The values of the primitive’s local variables are stored directly in the stack
    – to be more precise, on the array of the frame of the method that the local variables
    are in. Objects are not stored on the stack. Instead, the object reference is
    stored on the stack. The object reference is the address at which to find the
    object on the heap.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的局部变量值直接存储在栈上——更准确地说，在局部变量所在的方法帧的数组上。对象不存储在栈上。相反，对象引用存储在栈上。对象引用是在堆上找到对象的地址。
- en: Primitives and wrapper classes
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始类型和包装类
- en: Be careful not to confuse the primitive types with their object wrapper classes.
    They are easily recognized by the type being in uppercase. The wrapper class objects
    don’t live on the stack, simply because they are objects. Whenever a method has
    been executed, the values of the associated primitives are cleaned up from the
    stack and they are gone forever.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意不要混淆原始类型及其对象包装类。它们很容易通过类型是否为大写字母来识别。包装类对象不生活在栈上，仅仅因为它们是对象。每当一个方法被执行，相关的原始值的栈就会被清理，它们将永远消失。
- en: 'Some wrapper classes are more easily recognized than others. Let’s take a look
    at a code snippet:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包装类比其他包装类更容易识别。让我们看看一个代码片段：
- en: '[PRE78]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As you can see, the wrappers start with a capital and are longer. For many types,
    however, the word is exactly the same and the only difference is that it starts
    with a capital. Personally, I’m most often fooled by `Boolean` and `boolean` (I
    blame C# for this since the equivalent of the Java `boolean` primitive in C# is
    `bool`).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，包装器以大写字母开头且更长。然而，对于许多类型，单词本身完全相同，唯一的区别是它以大写字母开头。我个人最常被`Boolean`和`boolean`（我为此责怪C#，因为C#中Java
    `boolean`原语等价的是`bool`）所迷惑。
- en: 'Here, you can see the difference between the other primitives and their reference
    types:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到其他原始类型及其引用类型之间的区别：
- en: '[PRE82]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Please note that they have the exact same name. We need to look at the first
    letter to distinguish between the wrapper class and the primitive type. Wrapper
    classes are objects and these are created differently. Let’s find out how.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它们的名称完全相同。我们需要查看第一个字母来区分包装类和原始类型。包装类是对象，它们的创建方式不同。让我们找出如何创建它们。
- en: Creating objects in Java
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中创建对象
- en: Objects are a bundle of values. In Java, they can be created by instantiating
    classes using the `new` keyword.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一组值的集合。在Java中，它们可以通过使用`new`关键字实例化类来创建。
- en: 'Here is a very basic `Person` class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常基础的`Person`类：
- en: '[PRE94]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If we want to instantiate it, we’ll use the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要实例化它，我们将使用以下方式：
- en: '[PRE110]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: What this does is create a new `Person` object and store it on the heap. Storing
    on the heap deserves a bit more of an explanation. This is what we’re going to
    zoom in on now!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的`Person`对象并将其存储在堆上。在堆上存储需要更多的解释。这正是我们现在要深入探讨的！
- en: Storing objects on the heap
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在堆上存储对象
- en: Storing objects on the heap is very different from storing values on the stack.
    As we’ve just seen, references to places on the heap are stored on the stack.
    These references are memory addresses and these memory addresses translate to
    a certain place on the heap where the object is being stored. Without this object
    reference, we would have no way to access an object on the heap.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆上存储对象与在栈上存储值非常不同。正如我们刚才看到的，堆上位置的引用存储在栈上。这些引用是内存地址，这些内存地址转换到堆上的某个位置，对象就是存储在那里。没有这个对象引用，我们就无法访问堆上的对象。
- en: Object references have a certain type. There are very many built-in types in
    Java that we can use, such as `ArrayList`, `String`, all the wrapper classes,
    and more, but we can also create our own objects and these objects will be stored
    on the heap too.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对象引用具有特定的类型。Java中有非常多的内置类型我们可以使用，例如`ArrayList`、`String`、所有包装类等，但我们也可以创建自己的对象，这些对象也会存储在堆上。
- en: 'The heap memory holds all the objects that exist in the application. Objects
    on the heap can be accessed from everywhere in the application using the address
    of the object, the object reference. The objects contain the same things as the
    blocks on the stack: the primitive values directly and the addresses for other
    objects on the heap.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存持有应用程序中存在的所有对象。堆上的对象可以通过对象的地址、对象引用从应用程序的任何地方访问。对象包含与栈上的块相同的内容：原始值直接存储，以及堆上其他对象的地址。
- en: 'In *Figure 1**.9*, you can see an overview of the stack and the heap and what
    this would look like (in a simplified view) for the following Java code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图1.9**中，你可以看到栈和堆的概述以及这对于以下Java代码的简化视图：
- en: '[PRE111]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '![Figure 1.9 – Overview of the connection between the stack and the heap](img/Figure_1.9_B18762.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 栈和堆之间连接的概述](img/Figure_1.9_B18762.jpg)'
- en: Figure 1.9 – Overview of the connection between the stack and the heap
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 栈和堆之间连接的概述
- en: It’s very much simplified – for example, the `String` objects in the `Person`
    object would be separate objects themselves. We’ll focus on the heap in [*Chapter
    3*](B18762_03.xhtml#_idTextAnchor049) to get a more accurate understanding of
    the heap area.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它非常简化——例如，`Person`对象中的`String`对象本身也是独立的对象。我们将在[*第3章*](B18762_03.xhtml#_idTextAnchor049)中关注堆，以获得对堆区域的更准确理解。
- en: So, what happens when we run out of heap memory? If the application needs more
    heap space than is available, `OutOfMemoryError` is thrown.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们耗尽堆内存时会发生什么？如果应用程序需要的堆空间超过了可用空间，就会抛出`OutOfMemoryError`异常。
- en: Alright, we have seen the stack and the heap. There is just one memory area
    that we need to discuss here and that is the Metaspace.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经看到了栈和堆。这里还有一个我们需要讨论的内存区域，那就是Metaspace。
- en: Exploring the Metaspace
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Metaspace
- en: The Metaspace is the memory space that holds the class `metadata` that is necessary
    for runtime. It is the method area in the JVM specification and in most popular
    Java implementations after Java SE 7, this area is called the Metaspace.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Metaspace是存储运行时必要的类`元数据`的内存空间。它是JVM规范中的方法区，在Java SE 7之后的多数流行Java实现中，这个区域被称为Metaspace。
- en: If you know about PermGen, or you come across it, just know that this is the
    old memory area where all class `metadata` was stored. It had some limitations
    and has been replaced by the Metaspace.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解PermGen，或者遇到它，只需知道这是一个旧的内存区域，其中存储了所有类的`元数据`。它有一些限制，并且已经被Metaspace所取代。
- en: 'So, back to this class `metadata`. What even is that? Class `metadata` is the
    runtime representation of the Java classes that are necessary to run the program.
    It actually contains a lot of things, such as the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，回到这个类`metadata`。那究竟是什么呢？类`metadata`是运行时表示Java程序运行所需的Java类的表示。它实际上包含很多东西，例如以下内容：
- en: The *Klass* structure (we’ll see more in [*Chapter 5*](B18762_05.xhtml#_idTextAnchor077)
    when we take a deep dive into the Metaspace!)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Klass*结构（我们将在[*第五章*](B18762_05.xhtml#_idTextAnchor077)中深入了解元空间时了解更多！）'
- en: Bytecode of methods
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的字节码
- en: The constant pool
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量池
- en: Annotations and more
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解和更多内容
- en: That’s it! These are the basics of Java memory management. There is a lot more
    to say about the specific parts. We are going to start with a closer look at primitives
    and objects on the heap in the next chapter, but first, let’s recap what we’ve
    done.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！这是Java内存管理的基础知识。还有很多关于具体部分的内容要讲。我们将在下一章更详细地探讨堆上的原始类型和对象，但首先，让我们回顾一下我们已经做了什么。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have gone through an overview of Java memory. We started
    with computer memory and learned that the computer has main memory and secondary
    storage. The main memory is most important for us since this is what is used to
    run programs, including Java programs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了Java内存。我们从计算机内存和辅助存储开始学习，了解到计算机有主内存和辅助存储。对于我们来说，主内存是最重要的，因为这是运行程序（包括Java程序）所使用的。
- en: 'The main memory consists of RAM and ROM. Java applications use RAM to run.
    Java applications are executed by the JVM. This JVM executes Java applications
    and in order to do so, it has three components: a class loader, runtime data areas,
    and an execution engine.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 主内存由RAM和ROM组成。Java应用程序使用RAM来运行。Java应用程序由JVM执行。这个JVM执行Java应用程序，为了执行这些应用程序，它有三个组件：类加载器、运行时数据区域和执行引擎。
- en: 'We focused on the different components of the runtime data area: the heap,
    stack, method area, PC register, and native method stack.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注了运行时数据区的不同组件：堆、栈、方法区、PC寄存器和本地方法栈。
- en: The stack is the memory area that is used to store variables and values of methods
    in frames. The heap is used for storing objects. The stack holds references to
    objects on the heap. The heap is accessible from everywhere within the application
    and whoever has an object’s address on the heap can access the object. The stack
    is only accessible for the thread that has created this stack.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是用于在帧中存储变量和方法值的内存区域。堆用于存储对象。栈持有对堆上对象的引用。堆在应用程序的任何地方都可以访问，任何拥有堆上对象地址的人都可以访问该对象。栈只能由创建此栈的线程访问。
- en: The Metaspace is the memory area where the class metadata that is needed during
    runtime is stored.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 元空间是存储运行时所需的类元数据的内存区域。
- en: In the next chapter, we’re going to visualize and have a closer look at how
    heap and stack memory are combined.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将可视化并更详细地了解堆和栈内存是如何结合在一起的。
