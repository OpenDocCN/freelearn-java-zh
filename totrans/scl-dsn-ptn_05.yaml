- en: Aspect-Oriented Programming and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often in programming, we see pieces of source code that are repeated in different
    methods. In some cases, we could refactor our code and move them to separate modules.
    Sometimes, however, this is not possible. Some notable examples include logging
    and verification. Aspect-oriented programming is helpful in such cases, and we
    will get an understanding of it by the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Components are reusable pieces of code that provide a number of services and
    have some requirements. They are extremely useful for avoiding code duplication,
    and of course, for promoting code reuse. Here, we will see how to build components
    and how Scala makes the writing and use of components easier than other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'While getting familiar with aspect-oriented programming and components, we
    will go through the following top-level topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aspect-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aspect-oriented programming** (**AOP**) addresses a common functionality,
    that spans across an application, but cannot be otherwise abstracted in a single
    module using traditional object-oriented techniques. This repeated functionality
    is often referred to as *cross-cutting concerns*. A common example is logging—normally,
    loggers are created within classes and then their methods are called inside the
    methods of the classes. This helps with the debugging and tracing of events in
    an application, but it is not really related to the actual functionality in any
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: AOP recommends that cross-cutting concerns are abstracted and encapsulated in
    their own modules. In the next few subsections, we will look into how AOP improves
    code and also makes cross-cutting concerns easily extendible.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding application efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important part of every program is efficiency. In many cases, we can time
    our methods and find bottlenecks in our applications. Let's look at an example
    program that we will try and time afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a look at parsing. In many real-life applications, we have to
    read data in specific formats and parse it to the objects in our code. For this
    example, we will have a small database of people represented in a JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent this JSON in Scala, we have to define our model. It will be simple
    and contain only one class—`Person`. Here is the code for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we will be reading JSON inputs, we will have to parse them. There are
    many parsers out there, and everyone might have their own preferences. In the
    current example, we have used json4s ([https://github.com/json4s/json4s](https://github.com/json4s/json4s)).
    We have the following extra dependency in our `build.sbt/pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the `build.sbt` equivalent of the `pom.xml` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have written a class with two methods that parses an input file of the given
    preceding format and returns a list of `Person` objects. These two methods do
    exactly the same thing, but one of them is more efficient than the other one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DataReader` trait acts as an interface, and using the implementation is
    quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It will produce output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c0e55e4-a5e0-406b-bfb0-cf40354c48cf.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding example is clear. However, what if we want to optimize our code
    and see what causes it to be slow? The previous code does not give us this possibility,
    so we will have to take some extra steps in order to time and see how our application
    performs. In the following subsections, we will show how this is done without
    and with AOP.
  prefs: []
  type: TYPE_NORMAL
- en: Timing our application without AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a basic way to do our timing. We could either surround the `println`
    statements in our application, or add the timing as a part of the methods in the
    `DataReaderImpl` class. Generally, adding the timing as part of the methods seems
    like a better choice as in some cases, these methods could be called at different
    places and their performance would depend on the passed parameters and other factors.
    Considering what we said, this is how our `DataReaderImpl` class could be refactored
    in order to support timing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code becomes quite unreadable and the timing interferes
    with the actual functionality. In any case, if we run our program, the output
    will show us where the problem is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de830a48-ec2f-4a67-9142-88b67d451c83.png)'
  prefs: []
  type: TYPE_IMG
- en: We will see how to improve our code using aspect-oriented programming in the
    next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we used `System.err.println` to log the timing. This
    is just for example purposes. In practice, using loggers, for example **slf4j**
    ([https://www.slf4j.org/](https://www.slf4j.org/)), is the recommended option,
    as you can have different logging levels and switch logs using configuration files.
    Using loggers here would have added extra dependencies and it would have pulled
    your attention away from the important material.
  prefs: []
  type: TYPE_NORMAL
- en: Timing our application with AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw, adding our timing code to our methods introduces code duplication
    and makes our code hard to follow, even for a small example. Now, imagine that
    we also have to do logging and other activities. Aspect-oriented programming helps
    in separating these concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can revert the `DataReaderImpl` class to its original state, where it does
    not do any logging. Then, we create another trait called `LoggingDataReader`,
    which extends from `DataReader` and has the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Something interesting here is the `abstract override` modifier. It notifies
    the compiler that we will be doing stackable modifications. If we do not use this
    modifier, our compilation will fail with the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use our new trait using a mixin composition, which we already covered
    earlier in this book, in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we run this program, we will see that, as before, our output will contain
    the timings.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using aspect-oriented programming is clear—the implementation
    is not contaminated by other code, which is irrelevant to it. Moreover, we can
    add extra modifications using the same approach—more logging, retry logic, rollbacks,
    and so on. Everything happens by just creating new traits that extend `DataReader`
    and mixing them in, as shown previously. Of course, we can have multiple modifications
    applied at the same time that will execute in order, and the order of their execution
    will follow the rules of linearization, which we are already familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: Components in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are parts of an application that are meant to be combined with other
    parts of the application. They should be reusable in order to achieve less code
    duplication. Components typically have interfaces, which describe the services
    they provide and a number of services or other components they depend on.
  prefs: []
  type: TYPE_NORMAL
- en: In large applications, we usually see multiple components that are integrated
    to work together. Describing the services that a component provides is usually
    straightforward, and it is done with the help of interfaces. Integrating other
    components, however, could sometimes require a developer to do extra work. This
    is usually done by passing the interface of the requirement as a parameter. However,
    imagine a large application in which we might have a lot of requirements; wiring
    things up could take time and effort. Moreover, every time a new requirement comes
    up, we would have to do quite a lot of refactoring. An alternative to parameters
    is multiple inheritance; however, the language needs to support it in some way.
  prefs: []
  type: TYPE_NORMAL
- en: A popular way to wire components up in languages such as Java is through dependency
    injection. There are libraries that exist in Java that can be used in order to
    inject components into each other during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scala's expressive power to build components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already said a few times in this book that Scala is a much more expressive
    language than the simply object-oriented ones. We already looked into concepts
    such as abstract types, self types, unification, and mixin compositions. They
    allow us to create generic code, require specific classes, and are able to treat
    objects, classes, variables, and functions in the same way and achieve multiple
    inheritance. Using different combinations of these would allow us to write the
    modular code we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection is quite popular to wire components up. However, in languages
    such as Java, this would mean that we require someone to use the same library
    as we do. Having a high number of parameters in the classes throughout our applications
    is also not acceptable. This makes it easier to make mistakes and turns refactoring
    and code extension into a nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will look into how Scala self types can be used in
    order to create and compose components.
  prefs: []
  type: TYPE_NORMAL
- en: Self types for components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, let's imagine that we are trying to build a robot that cooks
    food. Our robot will be able to look up recipes and cook the dishes we ask for,
    as well as tell us the time. We will be able to add extra functionality to our
    robot by simply creating new components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our code to be modular, so it makes sense to split the functionality.
    The following diagram shows what our robot will look like and the relationships
    between the different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b129cc6-5d6e-462a-8e1f-8f5cb39d4507.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, let''s define the interfaces for the different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need our `Food` class to be defined, and for this example, it will be as
    simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we can start creating our components. First is the `TimeComponent`
    and the implementation of `Time` in a nested class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the `RecipeComponent` in a similar way. The following
    is the component code and the implementation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement the `CookingComponent`. It actually requires
    a `RecipeComponent`. Here is how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have all the components separately implemented, and we can combine
    them in order to create our robot. We will create a component registry that the
    robot will use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now create a `Robot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An example program that uses our robot will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An example output of this program is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/401b7fb3-45a7-49ed-be72-a9ab8da0889e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we saw the way Scala implements dependency injection
    that is easy to wire up without using extra libraries. This is really useful as
    it doesn't make our constructors large and we don't have to extend many classes
    as well. Moreover, the components we have are nicely separated, testable, and
    clearly define their requirements. We also saw how we can add requirements recursively
    using components that require other ones.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is actually a representation of the **cake design pattern**.
    One of the nice features here is that the presence of dependencies is evaluated
    at compile time rather than at runtime, as popular Java libraries do.
  prefs: []
  type: TYPE_NORMAL
- en: The cake design pattern has its drawbacks as well, but we will be focusing on
    all the features—good and bad ones—later in this book. This is where we will show
    how the components can be tested as well.
  prefs: []
  type: TYPE_NORMAL
- en: The cake design pattern example in this chapter is really simple. In real-life
    applications, we might have components that depend on other components, which
    have their own dependencies and so on. In such cases, things can get complicated.
    We will aim to showcase this better and in much more detail later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked into aspect-oriented programming in Scala. We now
    know how to separate code that normally wouldn't be possible to move into modules.
    This will lead to avoiding code duplication and make our programs nice with different,
    specialized modules.
  prefs: []
  type: TYPE_NORMAL
- en: We also showed how to create reusable components using techniques we covered
    in the previous chapters of this book. Components provide interfaces and have
    specific requirements, which could be easily satisfied using the richness of Scala.
    They are really relevant to design patterns because they have the same purpose—to
    make the code better, avoid repetition, and be able to easily test it.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters of this book, we will start looking at some concrete
    design patterns with their useful features and use cases. We will start with *creational
    design patterns* as they are defined by the *GoF*, but of course, from the Scala
    point of view.
  prefs: []
  type: TYPE_NORMAL
