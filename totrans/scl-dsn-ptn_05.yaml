- en: Aspect-Oriented Programming and Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面编程与组件
- en: Often in programming, we see pieces of source code that are repeated in different
    methods. In some cases, we could refactor our code and move them to separate modules.
    Sometimes, however, this is not possible. Some notable examples include logging
    and verification. Aspect-oriented programming is helpful in such cases, and we
    will get an understanding of it by the end of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，我们经常看到在不同方法中重复的源代码片段。在某些情况下，我们可以重构我们的代码并将它们移动到单独的模块中。然而，有时这是不可能的。一些值得注意的例子包括日志记录和验证。面向方面编程在这种情况下很有帮助，我们将在本章结束时对其有一个了解。
- en: Components are reusable pieces of code that provide a number of services and
    have some requirements. They are extremely useful for avoiding code duplication,
    and of course, for promoting code reuse. Here, we will see how to build components
    and how Scala makes the writing and use of components easier than other languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是可重用的代码片段，提供一系列服务并有一些要求。它们对于避免代码重复以及当然促进代码重用非常有用。在这里，我们将了解如何构建组件以及Scala如何使组件的编写和使用比其他语言更简单。
- en: 'While getting familiar with aspect-oriented programming and components, we
    will go through the following top-level topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉面向方面编程和组件的过程中，我们将探讨以下顶级主题：
- en: Aspect-oriented programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: Components in Scala
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中的组件
- en: Aspect-oriented programming
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向方面编程
- en: '**Aspect-oriented programming** (**AOP**) addresses a common functionality,
    that spans across an application, but cannot be otherwise abstracted in a single
    module using traditional object-oriented techniques. This repeated functionality
    is often referred to as *cross-cutting concerns*. A common example is logging—normally,
    loggers are created within classes and then their methods are called inside the
    methods of the classes. This helps with the debugging and tracing of events in
    an application, but it is not really related to the actual functionality in any
    way.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向方面编程**（**AOP**）解决了一个常见功能，该功能跨越整个应用程序，但无法使用传统的面向对象技术在一个模块中抽象。这种重复的功能通常被称为*横切关注点*。一个常见的例子是日志记录——通常，日志记录器是在类内部创建的，然后在其方法内部调用这些方法。这有助于调试和跟踪应用程序中的事件，但与实际功能并没有真正的关联。'
- en: AOP recommends that cross-cutting concerns are abstracted and encapsulated in
    their own modules. In the next few subsections, we will look into how AOP improves
    code and also makes cross-cutting concerns easily extendible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面编程建议将横切关注点抽象并封装在其自己的模块中。在接下来的几个小节中，我们将探讨AOP如何改进代码，以及如何使横切关注点易于扩展。
- en: Understanding application efficiency
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序效率
- en: An important part of every program is efficiency. In many cases, we can time
    our methods and find bottlenecks in our applications. Let's look at an example
    program that we will try and time afterwards.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序的一个重要部分是效率。在许多情况下，我们可以计时我们的方法，并找到应用程序中的瓶颈。让我们看看一个示例程序，我们将在之后尝试计时。
- en: 'We will have a look at parsing. In many real-life applications, we have to
    read data in specific formats and parse it to the objects in our code. For this
    example, we will have a small database of people represented in a JSON format:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看解析。在许多实际应用中，我们必须以特定格式读取数据并将其解析为代码中的对象。对于这个例子，我们将有一个以JSON格式表示的小型人员数据库：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To represent this JSON in Scala, we have to define our model. It will be simple
    and contain only one class—`Person`. Here is the code for it:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Scala中表示这个JSON，我们必须定义我们的模型。它将是简单的，只包含一个类——`Person`。以下是它的代码：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since we will be reading JSON inputs, we will have to parse them. There are
    many parsers out there, and everyone might have their own preferences. In the
    current example, we have used json4s ([https://github.com/json4s/json4s](https://github.com/json4s/json4s)).
    We have the following extra dependency in our `build.sbt/pom.xml` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将读取JSON输入，我们不得不解析它们。市面上有很多解析器，每个人可能都有自己的偏好。在当前示例中，我们使用了json4s ([https://github.com/json4s/json4s](https://github.com/json4s/json4s))。在我们的`build.sbt/pom.xml`文件中，我们有以下额外的依赖项：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following shows the `build.sbt` equivalent of the `pom.xml` version:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了`pom.xml`版本的`build.sbt`等效：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have written a class with two methods that parses an input file of the given
    preceding format and returns a list of `Person` objects. These two methods do
    exactly the same thing, but one of them is more efficient than the other one:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了一个包含两个方法的类，这些方法解析给定格式的输入文件并返回一个`Person`对象列表。这两个方法做的是完全相同的事情，但其中一个比另一个更高效：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `DataReader` trait acts as an interface, and using the implementation is
    quite straightforward:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataReader`特质充当一个接口，使用其实现相当直接：'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It will produce output as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它将产生如下截图所示的输出：
- en: '![](img/0c0e55e4-a5e0-406b-bfb0-cf40354c48cf.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c0e55e4-a5e0-406b-bfb0-cf40354c48cf.png)'
- en: The preceding example is clear. However, what if we want to optimize our code
    and see what causes it to be slow? The previous code does not give us this possibility,
    so we will have to take some extra steps in order to time and see how our application
    performs. In the following subsections, we will show how this is done without
    and with AOP.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子很清晰。然而，如果我们想优化我们的代码并查看导致其变慢的原因呢？之前的代码没有给我们这个可能性，所以我们将不得不采取一些额外的步骤来计时并查看我们的应用程序的性能。在以下小节中，我们将展示如何在不使用和在使用AOP的情况下完成这项工作。
- en: Timing our application without AOP
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不使用AOP计时我们的应用程序
- en: 'There is a basic way to do our timing. We could either surround the `println`
    statements in our application, or add the timing as a part of the methods in the
    `DataReaderImpl` class. Generally, adding the timing as part of the methods seems
    like a better choice as in some cases, these methods could be called at different
    places and their performance would depend on the passed parameters and other factors.
    Considering what we said, this is how our `DataReaderImpl` class could be refactored
    in order to support timing:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种基本的方法来做我们的计时。我们可以在应用程序中的`println`语句周围添加，或者将计时作为`DataReaderImpl`类中的方法的一部分。一般来说，将计时作为方法的一部分似乎是一个更好的选择，因为在某些情况下，这些方法可能在不同的地方被调用，并且它们的性能将取决于传递的参数和其他因素。考虑到我们所说的，这是我们的`DataReaderImpl`类可以被重构以支持计时的方法：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the code becomes quite unreadable and the timing interferes
    with the actual functionality. In any case, if we run our program, the output
    will show us where the problem is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码变得难以阅读，计时干扰了实际的功能。无论如何，如果我们运行我们的程序，输出将显示问题所在：
- en: '![](img/de830a48-ec2f-4a67-9142-88b67d451c83.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de830a48-ec2f-4a67-9142-88b67d451c83.png)'
- en: We will see how to improve our code using aspect-oriented programming in the
    next subsection.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中看到如何使用面向方面的编程来改进我们的代码。
- en: In the previous example, we used `System.err.println` to log the timing. This
    is just for example purposes. In practice, using loggers, for example **slf4j**
    ([https://www.slf4j.org/](https://www.slf4j.org/)), is the recommended option,
    as you can have different logging levels and switch logs using configuration files.
    Using loggers here would have added extra dependencies and it would have pulled
    your attention away from the important material.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`System.err.println`来记录计时。这只是为了示例目的。在实践中，使用日志记录器，例如**slf4j** ([https://www.slf4j.org/](https://www.slf4j.org/))，是推荐的选择，因为你可以有不同的日志级别，并通过配置文件切换日志。在这里使用日志记录器会添加额外的依赖项，并且会分散你的注意力，使其远离重要的材料。
- en: Timing our application with AOP
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AOP计时我们的应用程序
- en: As we saw, adding our timing code to our methods introduces code duplication
    and makes our code hard to follow, even for a small example. Now, imagine that
    we also have to do logging and other activities. Aspect-oriented programming helps
    in separating these concerns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，将我们的计时代码添加到我们的方法中引入了代码重复，并使得我们的代码难以理解，即使是对于一个小例子。现在，想象一下我们还需要进行日志记录和其他活动。面向方面的编程有助于分离这些关注点。
- en: 'We can revert the `DataReaderImpl` class to its original state, where it does
    not do any logging. Then, we create another trait called `LoggingDataReader`,
    which extends from `DataReader` and has the following contents:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`DataReaderImpl`类恢复到其原始状态，其中它不会进行任何日志记录。然后，我们创建另一个名为`LoggingDataReader`的特质，它从`DataReader`扩展而来，并包含以下内容：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Something interesting here is the `abstract override` modifier. It notifies
    the compiler that we will be doing stackable modifications. If we do not use this
    modifier, our compilation will fail with the following errors:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是`abstract override`修饰符。它通知编译器我们将进行可堆叠的修改。如果我们不使用这个修饰符，我们的编译将失败，并出现以下错误：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s use our new trait using a mixin composition, which we already covered
    earlier in this book, in the following program:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们新的特质，通过混合组合，这是我们在这本书的早期部分已经介绍过的，在以下程序中：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we run this program, we will see that, as before, our output will contain
    the timings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们会看到，就像之前一样，我们的输出将包含时间信息。
- en: The advantage of using aspect-oriented programming is clear—the implementation
    is not contaminated by other code, which is irrelevant to it. Moreover, we can
    add extra modifications using the same approach—more logging, retry logic, rollbacks,
    and so on. Everything happens by just creating new traits that extend `DataReader`
    and mixing them in, as shown previously. Of course, we can have multiple modifications
    applied at the same time that will execute in order, and the order of their execution
    will follow the rules of linearization, which we are already familiar with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向方面编程的优势是显而易见的——实现不会被其他与之无关的代码所污染。此外，我们可以使用相同的方法添加额外的修改——更多的日志记录、重试逻辑、回滚等。所有这些操作只需创建新的特质，扩展
    `DataReader` 并将它们混合在一起，就像之前所展示的那样。当然，我们可以同时应用多个修改，它们将按顺序执行，其执行顺序将遵循我们已熟悉的线性化规则。
- en: Components in Scala
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中的组件
- en: Components are parts of an application that are meant to be combined with other
    parts of the application. They should be reusable in order to achieve less code
    duplication. Components typically have interfaces, which describe the services
    they provide and a number of services or other components they depend on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是应用程序的组成部分，旨在与其他应用程序的组成部分结合使用。它们应该是可重用的，以便减少代码重复。组件通常具有接口，这些接口描述了它们提供的服务以及它们依赖的服务或其他组件的数量。
- en: In large applications, we usually see multiple components that are integrated
    to work together. Describing the services that a component provides is usually
    straightforward, and it is done with the help of interfaces. Integrating other
    components, however, could sometimes require a developer to do extra work. This
    is usually done by passing the interface of the requirement as a parameter. However,
    imagine a large application in which we might have a lot of requirements; wiring
    things up could take time and effort. Moreover, every time a new requirement comes
    up, we would have to do quite a lot of refactoring. An alternative to parameters
    is multiple inheritance; however, the language needs to support it in some way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型应用程序中，我们通常看到多个组件被集成在一起协同工作。描述一个组件提供的服务通常是直接的，并且是通过接口来完成的。然而，集成其他组件有时可能需要开发者做额外的工作。这通常是通过将所需接口作为参数传递来完成的。然而，想象一下，在一个大型应用程序中，我们可能有很多需求；连接这些组件可能需要时间和精力。此外，每次出现新的需求时，我们都必须进行相当多的重构。参数的另一种选择是多重继承；然而，语言需要以某种方式支持它。
- en: A popular way to wire components up in languages such as Java is through dependency
    injection. There are libraries that exist in Java that can be used in order to
    inject components into each other during runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Java 这样的语言中，将组件连接起来的流行方式是通过依赖注入。在 Java 中存在一些库，可以在运行时将组件注入到彼此中。
- en: Using Scala's expressive power to build components
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Scala 的表达力构建组件
- en: We have already said a few times in this book that Scala is a much more expressive
    language than the simply object-oriented ones. We already looked into concepts
    such as abstract types, self types, unification, and mixin compositions. They
    allow us to create generic code, require specific classes, and are able to treat
    objects, classes, variables, and functions in the same way and achieve multiple
    inheritance. Using different combinations of these would allow us to write the
    modular code we are looking for.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们已经多次提到 Scala 是一种比简单的面向对象语言更具表达力的语言。我们已经探讨了诸如抽象类型、自类型、统一和混合组合等概念。它们使我们能够创建泛型代码，要求特定的类，并且能够以相同的方式处理对象、类、变量和函数，从而实现多重继承。使用这些组合的不同组合将使我们能够编写我们寻找的模块化代码。
- en: Implementing components
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现组件
- en: Dependency injection is quite popular to wire components up. However, in languages
    such as Java, this would mean that we require someone to use the same library
    as we do. Having a high number of parameters in the classes throughout our applications
    is also not acceptable. This makes it easier to make mistakes and turns refactoring
    and code extension into a nightmare.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入在连接组件方面非常流行。然而，在像 Java 这样的语言中，这意味着我们需要有人使用与我们相同的库。在我们的应用程序中的类中拥有大量的参数也不可接受。这使得犯错误更容易，并将重构和代码扩展变成了一场噩梦。
- en: In the next subsection, we will look into how Scala self types can be used in
    order to create and compose components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个子节中，我们将探讨如何使用 Scala 的自类型来创建和组合组件。
- en: Self types for components
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件的自类型
- en: As an example, let's imagine that we are trying to build a robot that cooks
    food. Our robot will be able to look up recipes and cook the dishes we ask for,
    as well as tell us the time. We will be able to add extra functionality to our
    robot by simply creating new components.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们正在尝试构建一个烹饪食物的机器人。我们的机器人将能够查找食谱并烹饪我们要求的菜肴，还能告诉我们时间。我们可以通过简单地创建新的组件来为我们的机器人添加额外的功能。
- en: 'We want our code to be modular, so it makes sense to split the functionality.
    The following diagram shows what our robot will look like and the relationships
    between the different components:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的代码是模块化的，因此分割功能是有意义的。以下图表显示了我们的机器人将是什么样子以及不同组件之间的关系：
- en: '![](img/8b129cc6-5d6e-462a-8e1f-8f5cb39d4507.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b129cc6-5d6e-462a-8e1f-8f5cb39d4507.png)'
- en: 'First of all, let''s define the interfaces for the different components:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义不同组件的接口：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need our `Food` class to be defined, and for this example, it will be as
    simple as this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义`Food`类，在这个例子中，它将非常简单：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once this is done, we can start creating our components. First is the `TimeComponent`
    and the implementation of `Time` in a nested class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以开始创建我们的组件。首先是`TimeComponent`和嵌套类中`Time`的实现：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can implement the `RecipeComponent` in a similar way. The following
    is the component code and the implementation code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以类似的方式实现`RecipeComponent`。以下是对应的组件代码和实现代码：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we need to implement the `CookingComponent`. It actually requires
    a `RecipeComponent`. Here is how this is done:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现`CookingComponent`。实际上，它需要一个`RecipeComponent`。以下是实现方式：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we have all the components separately implemented, and we can combine
    them in order to create our robot. We will create a component registry that the
    robot will use, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经分别实现了所有组件，并且可以将它们组合起来创建我们的机器人。我们将创建一个机器人将使用的组件注册表，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now create a `Robot`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`Robot`：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An example program that uses our robot will look like the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的机器人的示例程序将如下所示：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An example output of this program is shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的示例输出如下截图所示：
- en: '![](img/401b7fb3-45a7-49ed-be72-a9ab8da0889e.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/401b7fb3-45a7-49ed-be72-a9ab8da0889e.png)'
- en: In the preceding example, we saw the way Scala implements dependency injection
    that is easy to wire up without using extra libraries. This is really useful as
    it doesn't make our constructors large and we don't have to extend many classes
    as well. Moreover, the components we have are nicely separated, testable, and
    clearly define their requirements. We also saw how we can add requirements recursively
    using components that require other ones.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了 Scala 实现依赖注入的方式，这种方式易于连接，无需使用额外的库。这非常有用，因为它不会使我们的构造函数变得庞大，我们也不必扩展许多类。此外，我们拥有的组件被很好地分离，可测试，并且清楚地定义了它们的要求。我们还看到了如何使用需要其他组件的组件递归地添加要求。
- en: The preceding example is actually a representation of the **cake design pattern**.
    One of the nice features here is that the presence of dependencies is evaluated
    at compile time rather than at runtime, as popular Java libraries do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例实际上是**蛋糕设计模式**的表示。这里的一个优点是，依赖关系的存在是在编译时而不是在运行时评估的，这与流行的 Java 库不同。
- en: The cake design pattern has its drawbacks as well, but we will be focusing on
    all the features—good and bad ones—later in this book. This is where we will show
    how the components can be tested as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕设计模式也有其缺点，但我们将在这个书中关注所有特性——无论是好是坏。这就是我们将展示如何测试组件的地方。
- en: The cake design pattern example in this chapter is really simple. In real-life
    applications, we might have components that depend on other components, which
    have their own dependencies and so on. In such cases, things can get complicated.
    We will aim to showcase this better and in much more detail later in this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中蛋糕设计模式的示例非常简单。在实际应用中，我们可能会有依赖于其他组件的组件，这些组件又有自己的依赖关系，如此等等。在这种情况下，事情可能会变得复杂。我们将在本书的后面部分以更好的方式、更详细地展示这一点。
- en: Summary
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked into aspect-oriented programming in Scala. We now
    know how to separate code that normally wouldn't be possible to move into modules.
    This will lead to avoiding code duplication and make our programs nice with different,
    specialized modules.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Scala中的面向方面编程。我们现在知道如何将通常不可能移动到模块中的代码分离出来。这将有助于避免代码重复，并使我们的程序通过不同的、专业的模块变得更加出色。
- en: We also showed how to create reusable components using techniques we covered
    in the previous chapters of this book. Components provide interfaces and have
    specific requirements, which could be easily satisfied using the richness of Scala.
    They are really relevant to design patterns because they have the same purpose—to
    make the code better, avoid repetition, and be able to easily test it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了如何使用本书前几章中介绍的技术来创建可重用组件。组件提供接口并具有特定要求，这些要求可以利用Scala的丰富性轻松满足。它们与设计模式非常相关，因为它们有相同的目的——使代码更优，避免重复，并且能够轻松测试。
- en: In the following chapters of this book, we will start looking at some concrete
    design patterns with their useful features and use cases. We will start with *creational
    design patterns* as they are defined by the *GoF*, but of course, from the Scala
    point of view.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后续章节中，我们将开始探讨一些具有有用特性和用例的具体设计模式。我们将从*创建型设计模式*开始，因为这些模式是由*GoF*定义的，但当然，从Scala的角度来看。
