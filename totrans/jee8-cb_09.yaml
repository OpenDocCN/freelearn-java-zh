- en: Using Multithreading on Enterprise Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building asynchronous tasks with returning results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions with asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the status of asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building managed threads with returning results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling asynchronous tasks with returning results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using injected proxies for asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Threading** is a common issue in most software projects, no matter which
    language or other technology is involved. When talking about enterprise applications,
    things become even more important, and sometimes harder.'
  prefs: []
  type: TYPE_NORMAL
- en: A single mistake in some thread can affect the whole system, or even the whole
    infrastructure. Think about some resources that are never released, memory consumption
    that never stops increasing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The Java EE environment has some great features for dealing with these and plenty
    of other challenges, and this chapter will show you some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Building asynchronous tasks with returning results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the first challenges you will face if you have never worked with asynchronous
    tasks is: how on Earth do you return results from an asynchronous task if you
    don''t know when the execution will end?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, this recipe show you how. `AsyncResponse` for the win!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create `UserService` to emulate a *remote* slow endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create an asynchronous client that will reach that endpoint and get
    the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create a service (endpoint) that will use the client to write
    the result in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this example, just deploy it in GlassFish 5 and open this URL in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-async-result/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, our remote endpoint is creating `User` and converting it to a response
    entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: So, with no effort at all, your `User` is now a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the key method in `AsyncResultClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `rx()` method is a part of the Reactive Client API introduced in Java EE
    8\. We'll discuss reactive in more detail in the next chapter. It basically returns
    `CompletionStageInvoker`, which will allow you to get `CompletionStage<Response>`
    (the returning value for this method).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this is an asynchronous/non-blocking code that gets results
    from the remote endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we use the `@Stateless` annotation with this client so that we can
    inject it into our main endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our asynchronous method for writing a response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that it's a `void` method. It doesn't return anything because it will return
    the result to a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Suspended` annotation combined with `AsyncResponse` will make the response
    resume once the processing is done, and this happens because we are using the
    beautiful, one-line, Java 8-style code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going into the details, let''s just clarify our local `readResponse` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It just reads the `User` entity embedded in `Response` and transforms it to
    a `String` object (a JSON string).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that this one-line code could be written is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But the first way is more concise, less verbose, and more fun!
  prefs: []
  type: TYPE_NORMAL
- en: The key is the `resume` method from the `AsyncReponse` object. It will write
    the response to the callback and return it to whoever asked it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-result).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using transactions with asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using asynchronous tasks could be already a challenge: what if you need to
    add some spice and add a transaction to it?'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a transaction means something like *code blocking*. Isn't it awkward
    to combine two opposing concepts? Well, it's not! They can work together nicely,
    as this recipe will show you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is a slow bean that will return `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a task to be executed that will return `User` using some transaction
    stuff:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, here is the service endpoint that will use the task to write the
    result to a response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-async-transaction/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The magic happens in the `AsyncTask` class, where we will first take a look
    at the `performLookups` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It will give you the instances of both `UserTransaction` and `UserBean` from
    the application server. Then you can relax and rely on the things already instantiated
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our task implements a `Callabe<V>` object that it needs to implement the
    `call()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see `Callable` as a `Runnable` interface that returns a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our transaction code lives here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And if anything goes wrong, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will look at `AsyncService`. First, we have some declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are asking the container to give us an instance from `ManagedExecutorService`,
    which It is responsible for executing the task in the enterprise context.
  prefs: []
  type: TYPE_NORMAL
- en: Then we call an `init()` method, and the bean is constructed (`@PostConstruct`).
    This instantiates the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have our task execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the executor returns `Future<User>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This means this task will be executed asynchronously. Then we check its execution
    status until it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And once it''s done, we write it down to the asynchronous response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The full source code of this recipe is at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-async-transaction).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the status of asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond executing asynchronous tasks, which opens up a lot of possibilities,
    sometimes it is useful and necessary to get the status of those tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could use it as a check the time elapsed on each task stage.
    You should also think about logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you an easy way to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a slow bean for returning `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a managed task so we can monitor it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create a service endpoint to execute our task and return its
    results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-task-status/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been through the last recipe, you will already be familiar with
    the `Callable` task, so I won''t give you more details about it here. But now,
    we are implementing our task using both the `Callable` and `ManagedTaskListener`
    interfaces. The second one gives us all the methods for checking the task''s status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The best part is that you don't need to call any of them—`ManagedExecutorService`
    (explained next) will do it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have `AsyncService`. The first declaration is for our executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the service itself, we are getting four users from our asynchronous task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s done, it''s written to the asynchronous response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you look at your server log output, there are messages from the `ManagedTaskListener`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-task-status).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building managed threads with returning results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to improve the way you look at the threads you are using;
    maybe to improve your logging features, maybe to manage their priorities. It would
    be nice if you could also get the results back from them. This recipe will show
    you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we create a slow bean to return `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create an endpoint to get the result from the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-managed-thread/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The only way you should use threads in an enterprise context, and if you really
    want to use it, is when the application server creates the thread. So here, we
    are kindly asking the container to do it using `factory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using some functional-style code, we create our thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, moving to the managed stuff, we can set the name and priority of the just-created
    thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And don''t forget to ask the container to start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-managed-thread).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling asynchronous tasks with returning results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using tasks means also being able to define when they should be executed. This
    recipe is all about this topic, and also about getting the returning results whenever
    they return.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we create a slow bean to return `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a simple `Callable` task to communicate with the bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create our service to schedule and write the task''s result
    in the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-scheduled-task/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the magic relies on the `AsyncService` class, so we will focus on that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we ask the server an instance of an executor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'But it is not just any executor—it''s an executor that''s specific to scheduling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So, we are scheduling our task to be executed in five seconds. Note that we
    are also not using a regular `Future`, but `ScheduledFuture`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest is a usual task execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is how we write the results to the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-scheduled-task).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using injected proxies for asynchronous tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using tasks, you could also create your own executor. If you have very
    specific needs, it could be really handy.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to create a proxy executor that can be injected
    and used in the whole context of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first add our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a slow bean to return `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create a simple `Callable` task to communicate with the slow bean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we call our proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create the endpoint that will use the proxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To try this code, just deploy it to GlassFish 5 and open this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/ch09-proxy-task/asyncService`'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The magic really happens here in the `ExecutorProxy` task. First note that
    we are defining it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We are making sure to have one and only one instance of it in the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now note that even though we are creating our own executor, we are still relying
    on the application server context for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This guarantees that you don't violate any context rules and ruin your application
    for good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we create a pool for executing threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we create the method for sending tasks to the executing queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our proxy is ready to be injected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also ready to be called and to return results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See the full source code of this recipe at [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter09/ch09-proxy-task).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
