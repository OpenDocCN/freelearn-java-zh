["```java\nimport greenfoot.*;\n\npublic class ZombieInvasionWorld extends World {\n  private static final int DELAY = 200;\n  int bombDelayCounter = 0; // Controls the rate of bombs\n\n  public ZombieInvasionWorld() {  \n   super(600, 400, 1); \n   prepare();\n  }\n\n  public void act() {\n   if( bombDelayCounter > 0 ) bombDelayCounter--;\n   if( Greenfoot.mouseClicked(null) && (bombDelayCounter == 0) ) {\n     MouseInfo mi = Greenfoot.getMouseInfo();\n     Boom pow = new Boom();\n     addObject(pow, mi.getX(), mi.getY());\n     bombDelayCounter = DELAY;\n   }\n  }\n\n  private void prepare() {\n   int i,j;\n   for( i=0; i<5; i++) {\n     Wall w = new Wall();\n     addObject(w, 270, w.getImage().getHeight() * i);\n   }\n   for( i=0; i<2; i++) {\n     for( j=0; j<8; j++) {\n      House h = new House();\n      addObject(h, 400 + i*60, (12 +h.getImage().getHeight()) * j);\n     }\n   }\n   for( i=0; i<2; i++) {\n     for( j=0; j<8; j++) {\n      Zombie1 z = new Zombie1();\n      addObject(z, 80 + i*60, 15 + (2 +z.getImage().getHeight()) * j);\n     }\n   }\n   for( i=0; i<2; i++) {\n     for( j=0; j<7; j++) {\n      Zombie2 z = new Zombie2();\n      addObject(z, 50 + i*60, 30 + (3 +z.getImage().getHeight()) * j);\n     }\n   }\n  }\n}\n```", "```java\nimport greenfoot.*;\n\npublic class House extends Actor {\n}\n```", "```java\nimport greenfoot.*; \nimport java.util.List;\n\npublic class Wall extends Actor {\n  int wallStrength = 2000;\n  int wallStage = 0;\n\n  public void act() {\n   crumble();\n  } \n\n  private void crumble() {\n   // We will implement this in the next section…\n  }\n\n}\n```", "```java\nimport greenfoot.*; \nimport java.util.*;\n\npublic class Zombie extends Actor {\n  int counter, stationaryX, amplitude;\n\n  protected void addedToWorld(World w) {\n   stationaryX = getX();\n   amplitude = Greenfoot.getRandomNumber(6) + 2;\n  }\n\n  public void act() {\n   shake();\n   if( canMarch() ) {\n     stationaryX = stationaryX + 2;\n   }\n  } \n\n  public void shake() {\n   counter++;\n   setLocation((int)(stationaryX + amplitude*Math.sin(counter/2)), getY());\n  }\n\n  private boolean canMarch() {\n   // We will implement this in the next section… \n   return false; // Temporary return value \n  }\n}\n```", "```java\nreturn false;\n```", "```java\npublic class Zombie1 extends Zombie {\n}\npublic class Zombie2 extends Zombie {\n}\n```", "```java\nimport greenfoot.*;\nimport java.awt.Color;\nimport java.util.List;\n\npublic class Boom extends Actor {\n  private static final int BOOMLIFE = 50;\n  private static final int BOOMRADIUS = 50;\n  int boomCounter = BOOMLIFE;\n\n  public Boom() {\n    GreenfootImage me = new GreenfootImage\n    (BOOMRADIUS*2,BOOMRADIUS*2);\n    me.setColor(Color.RED);\n    me.setTransparency(125);\n    me.fillOval(0 , 0, BOOMRADIUS * 2, BOOMRADIUS*2);\n    setImage(me);\n  }\n\n  public void act() {\n    if( boomCounter == BOOMLIFE)\n    destroyEverything(BOOMRADIUS);\n    if( boomCounter-- == 0 ) {\n      World w = getWorld();\n      w.removeObject(this);\n    }\n  }\n\n  private void destroyEverything(int x) {\n    // We will implement this in the next section…\n  }\n}\n```", "```java\npublic World(int worldWidth, int worldHeight, int cellSize)\n\nConstruct a new world. The size of the world (in number of cells) and the size of each cell (in pixels) must be specified.\n\nParameters:\nworldWidth - The width of the world (in cells).\nworldHeight - The height of the world (in cells).\ncellSize - Size of a cell in pixels.\n```", "```java\nprivate void checkForCollisions() {\n  Actor enemy = getOneIntersectingObject(Enemy.class);\n  if( enemy != null ) { // If not empty, we hit an Enemy\n    AvoiderWorld world = (AvoiderWorld) getWorld();\n    world.removeObject(this);\n  }\n}\n```", "```java\nprivate void checkForCollisions() {\n  if( isTouching(Enemy.class) ) { \n    removeTouching(Enemy.class);\n  }\n}\n```", "```java\nprivate void crumble() {\n  List<Zombie> army = getIntersectingObjects(Zombie.class);\n  wallStrength = wallStrength - army.size();\n  if( wallStrength < 0 ) {\n    wallStage++;\n    if( wallStage > 4 ) {\n      World w = getWorld();\n      w.removeObject(this);\n    }\n    else {\n      changeImage();\n      wallStrength = 2000;\n    }\n  }\n}\n\nprivate void changeImage() {\n  setImage(\"brick\"+wallStage+\".png\");\n}\n```", "```java\nprivate boolean canMarch() {\n  List<Actor> things = getIntersectingObjects(Actor.class);\n  for( int i = 0; i < things.size(); i++ ) {\n    if( things.get(i).getX() > getX() + 20 ) {\n      return false;\n    }\n  }\n  return true;\n}\n```", "```java\nList<Actor> things = getIntersectingObjects(Actor.class);\n```", "```java\nprivate void destroyEverything(int x) {\n  List<Actor> objs = getObjectsInRange(x, Actor.class);\n  World w = getWorld();\n  w.removeObjects(objs);\n}\n```", "```java\npublic void removeObjects(java.util.Collection objects)\nRemove a list of objects from the world.\n\nParameters:\nobjects - A list of Actors to remove.\n```", "```java\nprivate boolean canMarch() {\n  int i=0;\n  while(i<=step) {\n    int front = getImage().getWidth()/2;\n    Actor a = getOneObjectAtOffset(i+front, 0, Actor.class);\n    if( a != null ) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n```", "```java\nprivate int step = 4;\n```", "```java\nprivate boolean canMarch() {\n  int front = getImage().getWidth()/2;\n  int i = 1;\n  while(i<=step) {\n    List<Actor> a = getObjectsAtOffset(front+i,0,Actor.class);\n    if( a.size() > 0 ) {\n      for(int j=0;j<a.size()&&a.get(j) instanceof Zombie;j++){\n        int toss = Greenfoot.getRandomNumber(100)<50 ? 1 : -1;\n        Zombie z = (Zombie) a.get(j);\n        z.setLocation(z.getX(),z.getY()+toss);\n      }\n      return false;\n    }\n    i++;\n  }\n  return true;\n}\n```", "```java\nimport greenfoot.*;\nimport java.awt.Color;\nimport java.util.*;\n\npublic class ZombieHitBox extends Actor {\n  GreenfootImage body;\n  int offsetX;\n  int offsetY;\n  Actor host;\n\n  public ZombieHitBox(Actor a, int w, int h, int dx, int dy, boolean visible) {\n    host = a;\n    offsetX = dx;\n    offsetY = dy;\n    body = new GreenfootImage(w, h);\n    if( visible ) {\n      body.setColor(Color.red);\n      // Transparency values range from 0 (invisible)\n      // to 255 (opaque)\n      body.setTransparency(100);\n      body.fill();\n    }\n    setImage(body);\n  }\n\n  public void act() {\n    if( host.getWorld() != null ) {\n      setLocation(host.getX()+offsetX, host.getY()+offsetY);\n    } else {\n      getWorld().removeObject(this);\n    }\n  }\n\n  public List getHitBoxIntersections() {\n    return getIntersectingObjects(Actor.class);\n  }\n}\n```", "```java\nprivate ZombieHitBox zbh;\n```", "```java\nprotected void addedToWorld(World w) {\n  stationaryX = getX();\n  amplitude = Greenfoot.getRandomNumber(6) + 2;\n  zbh = new ZombieHitBox(this, 10, 25, 10, 5, true);\n  getWorld().addObject(zbh, getX(), getY());\n}\n```", "```java\nprivate boolean canMarch() {\n  if( zbh.getWorld() != null ) {\n    List<Actor> things = zbh.getHitBoxIntersections();\n    if( things.size() > 1 ) {\n      int infront = 0;\n      for(int i=0; i < things.size(); i++ ) {\n        Actor a = things.get(i);\n        if( a == this || a instanceof ZombieHitBox)\n        continue;\n        if( a instanceof Zombie) {\n          int toss =\n          Greenfoot.getRandomNumber(100)<50 ? 1:-1;\n          infront += (a.getX() > getX()) ? 1 : 0;\n          if( a.getX() >= getX() )\n          a.setLocation(a.getX(),a.getY()+toss);\n        } else {\n          return false;\n        }\n      }\n      if( infront > 0 ) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n    return true;\n  } else {\n    getWorld().removeObject(this);\n  }\n  return false;\n}\n```"]