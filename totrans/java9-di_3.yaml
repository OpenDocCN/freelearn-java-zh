- en: Dependency Injection with Spring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring 进行依赖注入
- en: So far, we have learned why modularity is so important in writing cleaner and
    maintainable code. In [Chapter 1](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16), *Why
    Dependency Injection?*, we learned about the **Dependency Inversion Principle**
    (**DIP**), **IoC** (a design methodology to implement DIP), and various design
    patterns to implement IoC. **Dependency Injection** (**DI**) is one of the design
    patterns to achieve IoC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了为什么模块化在编写更干净、可维护的代码中如此重要。在[第 1 章](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16)，“为什么需要依赖注入？”，我们学习了**依赖倒置原则**（**DIP**）、**IoC**（一种实现
    DIP 的设计方法）以及各种设计模式来实现 IoC。**依赖注入**（**DI**）是实现 IoC 的设计模式之一。
- en: In the [Chapter 2](part0037.html#1394Q0-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection in Java 9*, we learned how modular framework and DI are facilitated
    in Java 9\. In this chapter, we will continue our journey to learn DI in Spring—one
    of the most popular and widely used frameworks to implement enterprise applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](part0037.html#1394Q0-255b24dd0eb24162a557b7d0d84b0b16)，“Java 9 中的依赖注入”，我们学习了模块化框架和
    DI 在 Java 9 中的实现方式。在本章中，我们将继续我们的旅程，学习在 Spring 中实现 DI——这是最受欢迎和最广泛使用的框架之一，用于实现企业应用程序。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: A brief introduction to Spring framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对 Spring 框架的简要介绍
- en: Bean management in Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 中的 Bean 管理
- en: How to achieve DI with Spring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Spring 实现 DI
- en: 'Auto wiring: he feature of resolving dependency automatically'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装配：自动解决依赖的功能
- en: Annotation-based DI implementation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的 DI 实现
- en: DI implementation with Java-based configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Java 配置的 DI 实现
- en: A brief introduction to Spring framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 Spring 框架的简要介绍
- en: Spring is a lightweight and open source enterprise framework created way back
    in 2003\. Modularity is the heart of Spring framework. Because of this, Spring
    can be used from the presentation layer to the persistence layer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是一个轻量级和开源的企业框架，它早在 2003 年就创建了。模块化是 Spring 框架的核心。正因为如此，Spring 可以从表示层到持久化层使用。
- en: The good thing is, Spring doesn't force you to use Spring in all layers. For
    example, if you use Spring in the persistence layer, you are free to use any other
    framework in presentation of the controller layer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于，Spring 不会强迫您在所有层都使用 Spring。例如，如果您在持久化层使用 Spring，您可以在控制器层的表示层自由使用任何其他框架。
- en: Another good part of Spring is its **Plain Old Java Object** (**POJO**) model-based
    framework. Unlike other frameworks, Spring doesn't force your class to extend
    or implement any base class or interface of Spring API; however, Spring does provide
    a set of classes to use other frameworks, such as ORM frameworks, logging framework,
    Quartz timers, and other third-party libraries, which will help you to integrate
    those frameworks with Spring.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 的另一个优点是其基于**普通老式 Java 对象**（**POJO**）模型的框架。与其他框架不同，Spring 不会强迫您的类扩展或实现
    Spring API 的任何基类或接口；然而，Spring 提供了一套类，用于使用其他框架，例如 ORM 框架、日志框架、Quartz 定时器以及其他第三方库，这些库将帮助您将这些框架与
    Spring 集成。
- en: 'More on this: Spring allows you to change the similar framework without changing
    the code. For example, you can choose different persistence frameworks just by
    changing the configuration. This is also applicable to third-party API integration
    with Spring.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更多内容：Spring 允许您在不更改代码的情况下更改类似的框架。例如，您可以通过更改配置来选择不同的持久化框架。这也适用于与 Spring 集成的第三方
    API。
- en: Spring is a POJO-based framework; a servlet container is suffice to run your
    application and a fully-fledged application server is not required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是一个基于 POJO 的框架；一个 servlet 容器就足以运行您的应用程序，不需要完整的应用服务器。
- en: Spring framework architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 框架架构
- en: 'Spring is a modular framework. This brings great flexibility to choosing the
    modules that you need instead of bringing all of them together in your code. Spring
    comprises around 20 modules that are logically grouped into the following layers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是一个模块化框架。这为您选择所需的模块提供了极大的灵活性，而不是将所有模块都集成到您的代码中。Spring 包含大约 20 个模块，它们逻辑上分为以下几层：
- en: Core container layer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心容器层
- en: Data access/integration layer
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问/集成层
- en: Web layer
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 层
- en: Test layer
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试层
- en: Miscellaneous layer
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项层
- en: Core container layer
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心容器层
- en: 'Being a main part of the framework, the core container covers the following
    modules:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为框架的主要部分，核心容器涵盖了以下模块：
- en: '**Spring core**:As its name suggests, it provides core functionalities of the
    framework, including an IoC container and DI mechanism. An IoC container isolates
    the configuration and dependencies management from the application code.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring核心**：正如其名所示，它提供了框架的核心功能，包括IoC容器和DI机制。IoC容器将配置和依赖关系管理从应用程序代码中隔离出来。'
- en: '**Spring beans**:This module provides the bean factory to create and manage
    the life cycle of beans (objects). It is a factory pattern implementation.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring beans**：此模块提供bean工厂以创建和管理bean（对象）的生命周期。它是一个工厂模式的实现。'
- en: '**Spring context**: This module is built on top of core and bean modules. Its
    entry point is to load the configuration and access the objects. On top of bean
    modules, the context module provides some additional features such as event propagation,
    creating context on the fly, internationalization, and so on.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring上下文**：此模块建立在核心和bean模块之上。其入口点是加载配置和访问对象。在bean模块之上，上下文模块提供了一些额外的功能，如事件传播、动态创建上下文、国际化等。'
- en: '**Spring Expression Language** (**SpEL**): This is an expression language to
    access and manipulate objects on the fly in JSP.It''s an extension of **Expression
    Language** (**EL**) of JSP 2.1 specification. Using SpEL makes the JSP code cleaner,
    more readable, and maintainable. Major benefits of using SpEL are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring表达式语言**（**SpEL**）：这是一个用于在JSP中动态访问和操作对象的表达式语言。它是JSP 2.1规范中**表达式语言**（**EL**）的扩展。使用SpEL可以使JSP代码更简洁、更易读、更易于维护。使用SpEL的主要好处包括：'
- en: The setting of and getting properties' values of objects with ease
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松设置和获取对象的属性值
- en: It can directly invoke controller methods to get the data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以直接调用控制器方法以获取数据
- en: It's used to retrieve objects directly from Spring's application context (IoC
    container)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于直接从Spring的应用程序上下文（IoC容器）检索对象
- en: It supports various list operations such as projection, selection, iteration,
    and aggregation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持各种列表操作，如投影、选择、迭代和聚合
- en: It provides logical and arithmetic operations
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供逻辑和算术运算
- en: Data access/integration layer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问/集成层
- en: 'Spring data access and the integration layer is used for data manipulation
    and other integration. It covers the following modules:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Spring数据访问和集成层用于数据操作和其他集成。它包括以下模块：
- en: '**Transaction**:This module helps maintain transactions in a programmatic and
    declarative manner. This module supports ORM and JDBC modules.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**：此模块帮助以编程和声明性方式维护事务。此模块支持ORM和JDBC模块。'
- en: '**Object XML mapping** (**OXM**):This module provides abstraction of Object/XML
    processing, which can be used by various OXM implementation such as JAXB, XMLBeans,
    and so on, to integrate with Spring.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象XML映射**（**OXM**）：此模块提供对象/XML处理的抽象，可用于各种OXM实现，如JAXB、XMLBeans等，以与Spring集成。'
- en: '**Object Relationship Mapping** (**ORM**):Spring doesn''t provide its own ORM
    framework; instead it facilitates integration with ORM frameworks such as Hibernate,
    JPA, JDO, and so on, with this module.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象关系映射**（**ORM**）：Spring不提供自己的ORM框架；相反，它通过此模块促进与Hibernate、JPA、JDO等ORM框架的集成。'
- en: '**Java Database Connectivity** (**JDBC**):This module provides all low-level
    boilerplate code to deal with JDBC. You can use it to interact with databases
    with standard JDBC API.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java数据库连接**（**JDBC**）：此模块提供处理JDBC的所有底层样板代码。您可以使用它使用标准JDBC API与数据库交互。'
- en: '**Java Messaging Service** (**JMS**):This module supports integration of messaging
    systems in Spring.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java消息服务**（**JMS**）：此模块支持Spring中消息系统的集成。'
- en: Spring web layer
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring网络层
- en: '**Spring web layer** is used to create web-based applications. It is comprised
    of the following modules:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring 网络层**用于创建基于Web的应用程序。它由以下模块组成：'
- en: '**Web**:This module provides basic web-related features such as multipart file
    upload (with the help of Spring custom tags in JSP). It is also responsible for
    initialization of IoC containers in web context.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web**：此模块提供基本的Web相关功能，如多部分文件上传（借助JSP中的Spring自定义标签）。它还负责在Web上下文中初始化IoC容器。'
- en: '**Servlet: **This module provides implementation of Spring MVC (Model View
    Controller) for web-based applications. It provides clear separation of views
    (presentation layer) from models (business logic), and controls the flow between
    them with controllers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Servlet**：此模块为基于Web的应用程序提供Spring MVC（模型-视图-控制器）的实现。它提供了视图（表示层）与模型（业务逻辑）的清晰分离，并通过控制器控制它们之间的流程。'
- en: '**Portlet: **This module provides MVC implementation for a portlet, and it
    is mainly used in portal environments.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：此模块为端口提供MVC实现，主要用于门户环境。'
- en: Spring test
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring测试
- en: This provides support for unit and integration testing with various unit-testing
    frameworks, such as JUnit and TestNg. We will see how to perform unit testing
    with Spring in upcoming sections in this chapter, so keep reading.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了对JUnit和TestNg等单元测试框架的支持，以进行单元和集成测试。我们将在本章后续部分看到如何使用Spring进行单元测试，所以请继续阅读。
- en: Miscellaneous
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: 'Some additional modules are also part of the Spring framework:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的模块也是Spring框架的一部分：
- en: '**Aspect and AOP: **These modules provide a facility to apply common logic
    (called *concerns* in AOP terminology) across multiple application layers dynamically'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方面和AOP**：这些模块提供了一种动态地在多个应用层应用通用逻辑（在AOP术语中称为*关注点*）的功能'
- en: '**Instrumentation:** This module provides a class instrumentation facility
    and class loader implementation'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表**：此模块提供类仪表化和类加载器实现功能'
- en: '**Messaging: **This module provides support for **Streaming Text-Oriented Messaging
    Protocol** (**STOMP**) for communicating with various STOMP-based clients'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**：此模块为与基于STOMP的客户端通信提供对**流文本导向消息协议**（**STOMP**）的支持'
- en: Bean management in Spring container
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring容器中的Bean管理
- en: When any software application is being executed, a set of objects are created
    and interact with each other to achieve specific business goals. Being a POJO-based
    programming model, the Spring framework treats all the objects of classes in your
    application as POJO or beans (in a Spring-friendly way).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何软件应用正在执行时，会创建一组对象，它们相互交互以实现特定的业务目标。作为一个基于POJO的编程模型，Spring框架将你的应用程序中类的所有对象视为POJO或豆（以Spring友好的方式）。
- en: These objects or beans should be independent in a manner that they can be re-used
    or changed without causing the ripple effect of changing others. Being loosely
    coupled this way, it also provides the benefit of doing testing without much worry
    of any dependency.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象或豆类应该以独立的方式存在，以便可以在不引起其他对象变化涟漪效应的情况下重用或更改。以这种方式松散耦合，它还提供了无需过多担心任何依赖项即可进行测试的好处。
- en: Spring provides an IoC container, which is used to automate the process of supplying
    external dependency to your class. You need to give instruction (in the form of
    configuration) about your client and dependencies. Spring will manage and resolve
    all your dependencies at runtime. Moreover, Spring provides a facility to keep
    availability of your dependencies at various application scopes, such as request,
    session, application, and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了一个IoC容器，用于自动化向你的类提供外部依赖的过程。你需要提供关于你的客户端和依赖项的指令（以配置的形式）。Spring将在运行时管理和解决所有依赖项。此外，Spring提供了一个功能，可以在各种应用范围内保持依赖项的可用性，例如请求、会话、应用等。
- en: It's essential to understand how Spring manages the life cycle (the process
    of creating, managing, and destroying) of objects before getting an idea about
    injecting dependency. In Spring, all these responsibilities are performed by the
    Spring IoC container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解依赖注入之前，理解Spring如何管理对象的生命周期（创建、管理和销毁的过程）是至关重要的。在Spring中，所有这些责任都由Spring IoC容器执行。
- en: Spring IoC container
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring IoC容器
- en: In Spring, the `org.springframework.beans.factory.BeanFactory` interface defines
    the basic IoC container, while the `org.springframework.context.ApplicationContext` interface
    represents an advanced IoC container. `ApplicationContext` is a super set of `BeanFactory`.
    It provides some additional enterprise-level functionalities on top of basic IoC
    features by `BeanFactory`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring中，`org.springframework.beans.factory.BeanFactory`接口定义了基本的IoC容器，而`org.springframework.context.ApplicationContext`接口则代表一个高级IoC容器。`ApplicationContext`是`BeanFactory`的超集。它通过在`BeanFactory`的基本IoC功能之上提供一些额外的企业级功能来实现这一点。
- en: To cater for different types of applications, Spring provides various implementations
    of `ApplicationContext` out of the box. For standalone applications, you can use
    the `FileSystemXmlApplicationContext` or `ClassPathXmlApplicationContext` class. They
    are both implementations of `ApplicationConext`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应不同类型的应用程序，Spring提供了`ApplicationContext`的多种实现。对于独立应用程序，你可以使用`FileSystemXmlApplicationContext`或`ClassPathXmlApplicationContext`类。它们都是`ApplicationConext`的实现。
- en: While working with Spring, you need to pass one XML file as an entry point for
    these containers. This file is called the **Spring Application Context file**.
    When the Spring container starts, it loads this XML file and starts configuring
    your beans (either with XML-based bean definition in this file, or annotation-based
    definition in your POJO Java class).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Spring 的时候，您需要传递一个 XML 文件作为这些容器的入口点。此文件称为 **Spring 应用程序上下文文件**。当 Spring
    容器启动时，它会加载此 XML 文件并开始配置您的 bean（要么是文件中的基于 XML 的 bean 定义，要么是 POJO Java 类中的基于注解的定义）。
- en: '`FileSystemXmlApplicationContext`: This container loads the Spring XML file
    and processes it. You need to give the full path of the XML file.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileSystemXmlApplicationContext`：此容器加载 Spring XML 文件并处理它。您需要提供 XML 文件的完整路径。'
- en: '`ClassPathXmlApplicationContext`: This container works similarly to `FileSystemXmlApplicationContext`;
    however, it assumes that the Spring XML file is available in `CLASSPATH`. You
    do not need to pass a root-level path for it.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassPathXmlApplicationContext`：此容器的工作方式类似于 `FileSystemXmlApplicationContext`；然而，它假定
    Spring XML 文件位于 `CLASSPATH` 中。您不需要为它传递根级路径。'
- en: '`WebXmlApplicationContext`: This container is generally used within web applications.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebXmlApplicationContext`：此容器通常用于 Web 应用程序中。'
- en: 'Spring''s IoC container is responsible for instantiating, configuring, maintaining,
    and accumulating the beans (objects in your application). You need to provide
    configuration metadata about the objects you want to assemble with the IoC container.
    The following diagram depicts a high-level flow of how the IoC container gets
    this work done:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 的 IoC 容器负责实例化、配置、维护和收集 bean（您应用程序中的对象）。您需要向 IoC 容器提供有关您想要组装的对象的配置元数据。以下图示展示了
    IoC 容器如何完成这项工作的一个高级流程：
- en: '![](img/00027.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00027.jpeg)'
- en: We provide **Pojo Classes** (or bean definitions) and **Configuration metadata**
    (set of instructions) as an input. The Spring IoC container will create and manage
    the objects (or beans) in a way that they produce a ready-to-use system. In short,
    an IoC container performs all low-level tasks (of managing beans and dependencies)
    so that you can write business logic in your POJO class.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供 **Pojo 类**（或 bean 定义）和 **配置元数据**（一组指令）作为输入。Spring IoC 容器将创建和管理对象（或 bean），以便它们产生一个可用的系统。简而言之，IoC
    容器执行所有低级任务（管理 bean 和依赖项），这样您就可以在您的 POJO 类中编写业务逻辑。
- en: Configuration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'You need to give instructions to Spring''s container about how you want to
    configure your beans based on your application needs. These instructions should
    be in the form of configuration metadata, and they should tell the following things
    to the IoC container:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要向 Spring 容器提供有关如何根据您的应用程序需求配置 bean 的说明。这些说明应以配置元数据的形式提供，并且它们应向 IoC 容器说明以下内容：
- en: '**Instantiation**: How to create the objects from bean definitions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例化**：如何从 bean 定义中创建对象。'
- en: '**Lifespan**: Till what time these objects are available.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：这些对象可用到何时。'
- en: '**Dependencies**: Do they need someone else?'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖项**：它们是否需要其他人？'
- en: 'Spring provides a great amount of flexibility, even in defining the configuration
    metadata. You can supply it to the IoC container in the following three ways:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 提供了大量的灵活性，甚至在定义配置元数据方面也是如此。您可以通过以下三种方式将其提供给 IoC 容器：
- en: '**XML format:** One or more entries with configuration metadata about beans
    in Spring''s Application Context (XML) file.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML 格式**：Spring 应用程序上下文（XML）文件中关于 bean 的配置元数据的一个或多个条目。'
- en: '**Java annotation:** Put the configuration metadata in the form of an annotation
    in a Java class.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 注解**：将配置元数据以注解的形式放入 Java 类中。'
- en: '**pure Java code: **From version 3.0, Spring started support of defining configuration
    with Java code. You can define beans outside of your application classes by using
    Java rather than XML files.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯 Java 代码**：从 3.0 版本开始，Spring 开始支持使用 Java 代码定义配置。您可以使用 Java 而不是 XML 文件在应用程序类之外定义
    bean。'
- en: 'When the Spring application starts, it will load the application context (XML)
    file first. This file looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Spring 应用程序启动时，它将首先加载应用程序上下文（XML）文件。此文件如下所示：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This file must be present for both XML-based and annotation-based configuration
    metadata. In the case of XML-based configuration, you need to define your bean
    with the `<bean>` element under top-level `<beans>` elements in this file. One
    or multiple `<bean>` entries can be defined. The configuration metadata will go
    along with the `<bean>` element.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件必须存在于基于XML和基于注解的配置元数据中。在基于XML的配置中，您需要在此文件顶级`<beans>`元素下使用`<bean>`元素定义您的bean。可以定义一个或多个`<bean>`条目。配置元数据将与`<bean>`元素一起使用。
- en: In the preceding bean definition, the `id` attribute defines the identity of
    that bean. The container will use it to point out the specific bean, so it must
    be unique. While the `class` attribute defines the type of bean, you need to give
    its fully qualified class name here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的bean定义中，`id`属性定义了该bean的标识。容器将使用它来指出特定的bean，因此它必须是唯一的。而`class`属性定义了bean的类型，您需要在这里给出其完全限定的类名。
- en: Each bean is associated with an actual object through the `class` attribute.
    You can define beans for any type of class, such as your custom service layer
    classes, DAO layer classes, presentation classes, and so on. Spring's container
    will use the `class` attribute to instantiate the objects, and it applies the
    configuration metadata associated with the corresponding `<bean>` element.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个bean都与一个实际对象通过`class`属性相关联。您可以定义任何类型的类的bean，例如您的自定义服务层类、DAO层类、表示层类等。Spring的容器将使用`class`属性来实例化对象，并应用与相应`<bean>`元素关联的配置元数据。
- en: In case of annotation-based configuration, your metadata will be defined to
    actual Java classes and in this (XML) file; you need to just specify the base
    package name with the `<context:component-scan base-package="org.example"/>` element.
    We will see more on this in an upcoming section, *Annotation-based DI*, in this
    chapter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于注解的配置中，您的元数据将被定义为实际的Java类，并在该（XML）文件中；您只需使用`<context:component-scan base-package="org.example"/>`元素指定基本包名。我们将在本章的下一个部分，*基于注解的依赖注入*中看到更多关于这个内容。
- en: Containers in action
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器在行动
- en: 'To understand the flow of Spring-based applications with ease, we will take
    an example of standalone application containers: `ClassPathXmlApplicationContext`,
    or `FileSystemXmlApplicationContext`. The whole process of dealing with Spring
    comprises the following three steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了轻松理解基于Spring的应用程序的流程，我们将以独立的应用程序容器为例：`ClassPathXmlApplicationContext`，或者`FileSystemXmlApplicationContext`。处理Spring的整体过程包括以下三个步骤：
- en: Defining POJOs
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义POJOs
- en: Creating application context (XML) files with configuration metadata
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有配置元数据的应用程序上下文（XML）文件
- en: Initializing the container
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化容器
- en: '**Defining POJOs: **As we have seen in previous sections of this chapter, Spring
    considers each object in your application as a POJO. So, first you need to define
    POJOs. We will use simple examples to understand the concepts as per the following
    snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义POJOs：**正如我们在本章前面的部分所看到的，Spring将您的应用程序中的每个对象视为POJO。因此，首先您需要定义POJOs。我们将使用简单的示例来理解以下片段中的概念：'
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Providing application context (XML) files**: Create one XML file and name
    it `application-context.xml`. For the sake of simplicity, we use XML-based configuration
    metadata. We will see another two ways (annotation-based and Java code-based)
    of setting configuration metadata in upcoming sections.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**提供应用程序上下文（XML）文件**：创建一个XML文件，并将其命名为`application-context.xml`。为了简化，我们使用基于XML的配置元数据。我们将在接下来的部分中看到另外两种设置配置元数据的方式（基于注解和基于Java代码）。'
- en: 'Define `<bean>` for each of your module classes along with their configuration
    metadata in the application context file (`application-context.xml`), as per the
    following snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序上下文文件（`application-context.xml`）中为每个模块类定义`<bean>`，并包括它们的配置元数据，如下面的片段所示：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have defined `<bean>` for our POJO `-Car` with `id="myCar"`. The Spring container
    uses this ID to get the object of the `Car` bean.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的POJO `Car`定义了`<bean>`，ID为`myCar`。Spring容器使用此ID来获取`Car` bean的对象。
- en: '**Initializing container: **In case of a web-based application, the container
    (`WebXmlApplicationContext`) will be initialized by a web listener when an application
    is loaded into the servlet container. In case of a standalone application, you
    need to initialize the containers (`ClassPathXmlApplicationContext` or `FileSystemXmlApplicationContext`)
    with Java code, as per the following snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化容器**：在基于Web的应用程序中，当应用程序被加载到servlet容器中时，容器（`WebXmlApplicationContext`）将由web监听器初始化。在独立应用程序的情况下，你需要使用以下代码片段初始化容器（`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`）：'
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are other overloaded constructors of `ClassPathXmlApplicationContext`
    and `FileSystemXmlApplicationContext` containers, such as a no-argument constructor
    and string array argument constructor, which is used to load more than one application
    context (XML) file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassPathXmlApplicationContext`和`FileSystemXmlApplicationContext`容器还有其他重载的构造函数，例如无参数构造函数和字符串数组参数构造函数，后者用于加载多个应用程序上下文（XML）文件。'
- en: 'Soon after the Spring container is loaded into memory, it processes the application
    context (XML) file and creates the objects for corresponding `<bean>` definition.
    You can get the instance of your bean with the help of a container, as per the
    following snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Spring容器加载到内存后不久，它就会处理应用程序上下文（XML）文件，并为相应的`<bean>`定义创建对象。你可以通过容器使用以下代码片段获取你的bean实例：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you call the `getBean` method, the container internally calls its constructor
    to create the object, which is equivalent to calling the `new()` operator. This
    is how Spring's IoC container creates, maintains, and assembles the objects corresponding
    to each `<bean>` definition in Spring's application context(XML) file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`getBean`方法时，容器内部会调用其构造函数来创建对象，这相当于调用`new()`操作符。这就是Spring的IoC容器如何在Spring的应用上下文（XML）文件中为每个`<bean>`定义创建、维护和组装对象的方式。
- en: By default, Spring creates the object of each `<bean>` element with a Singleton
    fashion. It means a container creates and holds just one object of each `<bean>`
    unless you explicitly tell it not to. When you ask a container for the object
    of `<bean>` with the `getBean()` method, it gives the reference of the same object
    every time after creating it the first time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring以单例模式创建每个`<bean>`元素的对象。这意味着除非你明确告诉它不要这样做，否则容器只为每个`<bean>`创建并保留一个对象。当你使用`getBean()`方法请求`<bean>`对象时，它每次都会提供第一次创建后的同一对象的引用。
- en: When a container creates the object corresponding to the `<bean>` definition,
    you do not need to implement any specific interface, or extend any class or code
    in a specific way. Simply specifying the `class` attribute of `<bean>` is suffice.
    Spring is capable enough to create an object of any type.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器创建与`<bean>`定义对应的对象时，你不需要实现任何特定的接口，也不需要以特定的方式扩展任何类或代码。只需指定`<bean>`的`class`属性就足够了。Spring能够创建任何类型的对象。
- en: Dependency Injection (DI) in Spring
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的依赖注入（DI）
- en: After getting an idea of how Spring manages bean life cycle, next we will learn
    how Spring provides and maintains the dependencies in your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解Spring如何管理bean生命周期之后，接下来我们将学习Spring如何提供和维护你的应用程序中的依赖。
- en: '**DI** is a process of providing the dependent objects to other objects that
    need it. In Spring, the container supplies the dependencies. The flow of creating
    and managing the dependencies is inverted from client to container. That is the
    reason we call it an **IoC container**.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**DI（依赖注入**）是一个将依赖对象提供给需要它的其他对象的过程。在Spring中，容器提供依赖。创建和管理依赖的流程从客户端反转到容器。这就是我们称之为**IoC容器**的原因。'
- en: A Spring IoC container uses the Dependency Injection (DI) mechanism to provide
    the dependency at runtime. In [Chapter 1](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16), 
    *Why Dependency Injection?,* we saw various DI types such as constructor, setter
    method, and interface-based. Let's see how we can implement the constructor and
    setter-based DI through Spring's IoC container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Spring IoC容器使用依赖注入（DI）机制在运行时提供依赖。在[第1章](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16)，“为什么需要依赖注入？”中，我们看到了各种DI类型，如构造函数、setter方法和基于接口的。让我们看看如何通过Spring的IoC容器实现基于构造函数和setter的DI。
- en: Constructor-based DI
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于构造函数的DI
- en: Constructor-based dependency is generally used where you want to pass mandatory
    dependencies before the object is instantiated. It's provided by a container through
    a constructor with different arguments, and each represents dependency.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基于构造函数的依赖注入通常用于在对象实例化之前传递必需的依赖项。它通过具有不同参数的构造函数由容器提供，每个参数代表一个依赖项。
- en: When a container starts, it checks wheather any constructor-based DI is defined
    for `<bean>`. It will create the dependency objects first, and then pass them
    to the current object's constructor. We will understand this by taking the classic
    example of using logging. It is good practice to put the log statement at various
    places in code to trace the flow of execution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，它会检查 `<bean>` 是否定义了基于构造函数的依赖注入。它将首先创建依赖对象，然后将它们传递给当前对象的构造函数。我们将通过使用日志的经典示例来理解这一点。在代码的各个地方放置日志语句以跟踪执行流程是一种良好的实践。
- en: 'Let''s say you have an `EmployeeService` class where you need to put a log
    in each of its methods. To achieve separation of concern, you put the log functionality
    in a separated class called `Logger`. To make sure the `EmployeeService` and `Logger`
    are independent and loosely coupled, you need to inject the `Logger` object into
    the `EmployeeService` object. Let''s see how to achieve this by constructor-based
    injection:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为 `EmployeeService` 的类，你需要在它的每个方法中添加日志。为了实现关注点的分离，你将日志功能放入一个名为 `Logger`
    的独立类中。为了确保 `EmployeeService` 和 `Logger` 之间是独立且松散耦合的，你需要将 `Logger` 对象注入到 `EmployeeService`
    对象中。让我们看看如何通过构造函数注入来实现这一点：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As per the preceding code, when these objects are configured with Spring, the `EmployeeService`
    object expects the Spring container to inject the object of `Logger` through the
    constructor. To achieve this, you need to set the configuration metadata as per
    the following snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的代码，当这些对象通过 Spring 配置时，`EmployeeService` 对象期望 Spring 容器通过构造函数注入 `Logger`
    对象。为了实现这一点，你需要按照以下代码片段设置配置元数据：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding configuration, the `Logger` bean is injected into the `employee`
    bean through the `constructor-arg` element. It has a `ref` attribute, which is
    used to point to other beans with a matching `id` value.  This configuration instructs
    Spring to pass the object of `Logger` into the constructor of the `EmployeeService`
    bean.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，`Logger` bean 通过 `constructor-arg` 元素注入到 `employee` bean 中。它有一个 `ref`
    属性，用于指向具有匹配 `id` 值的其他 bean。此配置指示 Spring 将 `Logger` 对象传递给 `EmployeeService` bean
    的构造函数。
- en: You can put the `<bean>` definition in any order here. Spring will create the
    objects of `<bean>` based on need, and not as per the order they are defined here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按任何顺序在这里放置 `<bean>` 定义。Spring 将根据需要创建 `<bean>` 对象，而不是根据它们在这里定义的顺序。
- en: For more than one constructor argument, you can pass additional `<constructor-arg>`
    elements. The order is not important as far as the object type (class attribute
    of referred bean) is not ambiguous.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多个构造函数参数，你可以传递额外的 `<constructor-arg>` 元素。只要引用的对象类型（bean 的类属性）不模糊，顺序并不重要。
- en: 'Spring also supports DI with primitive constructor arguments. Spring provides
    the facility to pass the primitive values in a constructor from an application
    context (XML) file. Let''s say you want to create an object of the `Camera` class
    with a default value, as per the following snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 还支持使用原始构造函数参数进行依赖注入。Spring 提供了从应用程序上下文（XML）文件传递原始值到构造函数的功能。假设你想要创建一个具有默认值的
    `Camera` 类对象，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Camera` class has three properties: `resolution`, `mode`, and `smileShot`.
    Its constructor takes three primitive arguments to create a camera object with
    default values. You need to give configuration metadata in the following way,
    so that Spring can create instances of the `Camera` object with default primitive
    values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera` 类有三个属性：`resolution`、`mode` 和 `smileShot`。它的构造函数接受三个原始参数来创建具有默认值的相机对象。你需要以下方式提供配置元数据，以便
    Spring 可以创建具有默认原始值的 `Camera` 对象实例：'
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We pass three `<constructor-arg>` elements under `<bean>`, corresponding to
    each constructor argument. Since these are primitive, Spring has no idea about
    its type while passing the value. So, we need to explicitly pass the `type` attribute,
    which defines the type of primitive constructor argument.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `<bean>` 下传递三个 `<constructor-arg>` 元素，对应于每个构造函数参数。由于这些是原始类型，Spring 在传递值时并不知道其类型。因此，我们需要显式传递
    `type` 属性，它定义了原始构造函数参数的类型。
- en: In case of primitive also, there is no fixed order to pass the value of the
    constructor argument, as long as the type is not ambiguous. In previous cases,
    all three types are different, so Spring intelligently picks up the right constructor
    argument, no matter which order you pass them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于原始类型，只要类型不是模糊的，就没有固定的顺序来传递构造函数参数的值。在前面的例子中，所有三种类型都是不同的，所以Spring智能地选择正确的构造函数参数，无论你以什么顺序传递它们。
- en: 'Now we are adding one more attribute to the `Camera` class called `flash`,
    as per the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在`Camera`类中添加一个名为`flash`的额外属性，如下所示：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, the constructor arguments `smileShot` and `flash` are of the
    same type (Boolean), and you pass the constructor argument value from XML configuration
    as per the following snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构造函数参数`smileShot`和`flash`具有相同的类型（布尔型），你按照以下片段从XML配置中传递构造函数参数值：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding scenario, Spring will pick up the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的场景中，Spring将选择以下内容：
- en: int value for resolution
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于分辨率的整数值
- en: String value for mode
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串值用于模式
- en: First Boolean value (true) in sequence for first Boolean argument—`smileShot`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中第一个布尔值（true）用于第一个布尔参数——`smileShot`
- en: Second Boolean value (false) in sequence for second Boolean argument—flash
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列中第二个布尔值（false）用于第二个布尔参数——`flash`
- en: In short, for similar types in constructor arguments, Spring will pick the first
    value that comes in the sequence. So sequence does matter in this case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，对于构造函数参数中的相似类型，Spring将选择序列中第一个出现的值。所以在这种情况下，顺序很重要。
- en: 'This may lead to logical errors, as you are passing wrong values to the right
    argument. To avoid such accidental mistakes, Spring provides the facility to define
    a zero-based index in the `<constructor-arg>` element, as per the following snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致逻辑错误，因为你将错误的值传递给了正确的参数。为了避免这种意外的错误，Spring提供了在`<constructor-arg>`元素中定义零基索引的功能，如下所示：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is more readable and less error prone. Now Spring will pick up the last
    value (with `index=2`) for `smileShot`, and the second value (with `index=3`)
    for `flash` arguments. Index attributes resolves the ambiguity of two constructor
    arguments having the same type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这更易于阅读且错误率更低。现在Spring将选择`smileShot`的最后一个值（`index=2`）和`flash`参数的第二个值（`index=3`）。索引属性解决了两个具有相同类型的构造函数参数的歧义。
- en: If the `type` you defined in `<constructor-arg>` is not compatible with the
    actual type of constructor argument in that index, then Spring will raise an error.
    So just make sure about this while using index attribute.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`<constructor-arg>`中定义的`type`与该索引处构造函数参数的实际类型不兼容，那么Spring将引发错误。所以使用索引属性时，请确保这一点。
- en: Setter-based DI
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入
- en: '**Setter-based DI** is generally used for optional dependencies. In case of
    setter-based DI, the container first creates an instance of your bean, either
    by calling a no-argument constructor or static `factory` method. It then passes
    the said dependencies through each setter method. Dependencies injected through
    the setter method can be re-injected or changed at a later stage of application.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于setter的依赖注入**通常用于可选依赖。在基于setter的依赖注入的情况下，容器首先通过调用无参数构造函数或静态`factory`方法创建你的bean实例。然后通过每个setter方法传递这些依赖。通过setter方法注入的依赖可以在应用程序的后期阶段重新注入或更改。'
- en: 'We will understand setter-based DI with the following code base:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下代码库来理解基于setter的依赖注入：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The  `DocumentBase` class depends on `DocFinder`, and we are passing it through
    the `setter` method. You need to define the configuration metadata for Spring,
    as per the following snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`DocumentBase`类依赖于`DocFinder`，我们通过setter方法传递它。你需要根据以下片段定义Spring的配置元数据：'
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Setter-based DI can be defined through the `<property>` element under `<bean>`.
    The `name` attribute denotes the name of the `setter` name. In our case, the `name`
    attribute of the `property` element is `docFinder`, so Spring will call the `setDocFinder` method
    to inject the dependency. The pattern to find the `setter` method is to prepend
    `set` and make the first character capital.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 基于setter的依赖注入可以通过在`<bean>`标签下的`<property>`元素中定义。`name`属性表示`setter`方法的名称。在我们的例子中，`property`元素的`name`属性是`docFinder`，因此Spring会调用`setDocFinder`方法来注入依赖。查找`setter`方法的模式是在`set`前缀前加上并使第一个字符大写。
- en: The `name` attribute of the `<property>` element is case-sensitive. So, if you
    set the name to `docfinder`, Spring will try to call the `setDocfinder` method
    and will show an error.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`<property>`元素的`name`属性是区分大小写的。所以，如果你将名称设置为`docfinder`，Spring将尝试调用`setDocfinder`方法并显示错误。'
- en: 'Just like constructor DI, Setter DI also supports supplying the value for primitives,
    as per the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像构造函数DI一样，Setter DI也支持根据以下代码片段提供原始类型的值：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the `setter` method takes only one argument, there is no scope of argument
    ambiguity. Whatever value you are passing here, Spring will convert it to an actual
    primitive type of the `setter` method parameter. If it's not compatible, it will
    show an error.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setter`方法只接受一个参数，因此不存在参数歧义的范围。无论你在这里传递什么值，Spring都会将其转换为`setter`方法参数的实际原始类型。如果不兼容，它将显示错误。
- en: Spring DI with the factory method
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂方法的Spring DI
- en: So far, we have seen that the Spring container takes care of creating the instances
    of `bean`. In some scenarios, you need to take control of creating an instance
    of `bean` with custom code. Spring supports this feature with the help of the
    `factory` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到Spring容器负责创建`bean`的实例。在某些场景中，你需要使用自定义代码来控制创建`bean`的实例。Spring通过`factory`方法支持此功能。
- en: You can write your custom logic to create the instance in the `factory` method,
    and just instruct Spring to use it. When Spring encounters such instructions,
    it will call the `factory` method to create the instance. So, the `factory` method
    is kind of a callback function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`factory`方法中编写自定义逻辑来创建实例，并仅指示Spring使用它。当Spring遇到此类指令时，它将调用`factory`方法来创建实例。因此，`factory`方法类似于回调函数。
- en: 'There are two flavors of the `factory` method: static, and instance (non-static).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`factory`方法有两种类型：静态的和实例（非静态）。'
- en: Static factory method
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态工厂方法
- en: 'When you want to encapsulate the logic of creating the instance in a static
    way to custom methods, you can use a static `factory` method. In this case, Spring
    will use the `Class` attribute of `<bean>` to call the `factory` method and generate
    instances. Let''s understand this by looking at the following example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要以静态方式将创建实例的逻辑封装到自定义方法中时，你可以使用静态`factory`方法。在这种情况下，Spring将使用`<bean>`的`Class`属性来调用`factory`方法并生成实例。让我们通过以下示例来理解这一点：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous configuration, Spring will always use the `getSearchableFactory`
    method to create the instance of bean irrespective of any scope.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置中，Spring将始终使用`getSearchableFactory`方法来创建bean的实例，而不考虑任何作用域。
- en: Instance (non-static) factory method
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例（非静态）工厂方法
- en: 'You can use an instance `factory` method to shift the control of creating the
    instance from a container to your custom object. The only difference between an
    instance `factory` method and a static `factory` method is that the former can
    only be invoked with an instance of bean. Let''s understand this by taking the
    following example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用实例`factory`方法将创建实例的控制权从容器转移到你的自定义对象。实例`factory`方法和静态`factory`方法之间的唯一区别是，前者只能使用bean的实例来调用。让我们通过以下示例来理解这一点：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Employee` is a generic class that has a `type` instance variable. `Developer`
    and `Manager` extend `Employee`, and they pass the `type` in the constructor.
    `EmployeeService` is a class that has a `factory` method: `getEmployee`. This
    method takes a String argument, and generates either `Developer` or `Manager`
    objects.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`是一个具有`type`实例变量的泛型类。`Developer`和`Manager`扩展了`Employee`，并在构造函数中传递`type`。`EmployeeService`是一个具有`factory`方法的类：`getEmployee`。此方法接受一个String参数，并生成`Developer`或`Manager`对象。'
- en: 'These objects can be configured in Spring as per the following snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象可以根据以下代码片段进行配置：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `employeeService` is defined with normal bean definition. The `developerBean`
    is defined with `factory-method` and `factory-bean` attributes. The `factory-bean`
    attribute represents the reference of bean in which the `factory` method is defined.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`employeeService`使用正常的bean定义。`developerBean`使用`factory-method`和`factory-bean`属性定义。`factory-bean`属性表示定义`factory`方法的bean的引用。'
- en: In previous cases, `developerBean` is created by calling the `factory` method `getEmployee`
    on bean `employeeService`. The argument passed through `<constructor-arg>` to
    `developerBean` actually goes to the `factory` method. You will also notice that
    we haven't defined a `class` attribute for `developerBean`, because when `factory-bean`
    is defined for bean, Spring will consider the class as a returned type from the
    `factory` method (defined in factory bean), rather than considering the bean's
    class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的案例中，`developerBean`是通过在`employeeService`的`bean`上调用`factory`方法`getEmployee`来创建的。通过`<constructor-arg>`传递给`developerBean`的参数实际上传递给了`factory`方法。你也会注意到，我们没有为`developerBean`定义一个`class`属性，因为当为`bean`定义`factory-bean`时，Spring会将类视为`factory`方法（在`factory`bean中定义）返回的类型，而不是将类视为`bean`的类。
- en: This way, `developerBean` is a kind of virtual bean that is generated by the
    `factory` method of another class. Lastly, we have created `salaryService`, and
    passed the `developerBean` as a setter injection. When you execute this code,
    it shows the type as a `developer`. This is how we can use the instance `factory`
    method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`developerBean`是一种由另一个类的`factory`方法生成的虚拟`bean`。最后，我们创建了`salaryService`，并将`developerBean`作为setter注入。当你执行此代码时，它显示的类型为`developer`。这就是我们如何使用实例`factory`方法。
- en: The type of class returned by the`factory` method need not be the same as the
    class in which the `factory` method is defined. If you have used a different class,
    you need to cast with the class that is being returned from the `factory` method,
    while calling the `getBean()` method of `ApplicationContext`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`factory`方法返回的类的类型不必与定义`factory`方法的类相同。如果你使用了不同的类，你需要在调用`ApplicationContext`的`getBean()`方法时使用从`factory`方法返回的类进行类型转换。'
- en: By default, Spring uses `singleton` scope for each of the beans. It means Spring
    will create just one object of each bean. For other scopes such as `prototype`,
    Spring creates a new instance every time you make a call to the `getBean` method.
    But if you specify which `factory` method, Spring will call the `factory` method
    to get the object all the time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Spring为每个`bean`使用`singleton`作用域。这意味着Spring将为每个`bean`创建一个对象。对于`prototype`等其他作用域，每次你调用`getBean`方法时，Spring都会创建一个新的实例。但是，如果你指定了哪个`factory`方法，Spring将始终调用`factory`方法来获取对象。
- en: In our case, we are using the `factory` method to make sure Spring creates just
    one object of our bean, irrespective of the bean's scope. This is just one example.
    This way you can use the `factory` method with any custom logic while creating
    the instance. It basically encapsulates the object instantiation process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们使用`factory`方法来确保Spring无论`bean`的作用域如何，都只为我们的`bean`创建一个对象。这只是其中一个例子。这样，你可以在创建实例时使用任何自定义逻辑的`factory`方法。它基本上封装了对象实例化过程。
- en: Auto-wiring in Spring
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring中的自动装配
- en: So far, we have learned how to define configuration metadata along with `<bean>`
    to set the dependencies. How good would it be if everything was settled down without
    giving any instruction in the form of configuration? That is a cool idea, and
    the good news is that Spring supports it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何定义与`<bean>`一起的配置元数据来设置依赖关系。如果一切都在不提供任何配置形式说明的情况下解决，那会怎么样？这是一个很酷的想法，好消息是Spring支持它。
- en: This feature is called autowire (in Spring terminology), which automates the
    process of binding relations between beans. This greatly reduces the effort of
    providing configuration metadata at either properties or constructor arguments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能被称为自动装配（在Spring术语中），它自动化了绑定`bean`之间关系的过程。这大大减少了在属性或构造函数参数中提供配置元数据的工作量。
- en: 'The autowire feature can be enabled in XML-based configuration metadata by
    defining the `autowire` attribute of the `<bean>` element. It can be specified
    with the following three modes: name, type, and constructor. By default, autowire
    is set off for all beans.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在基于XML的配置元数据中定义`<bean>`元素的`autowire`属性来启用自动装配功能。它可以指定以下三种模式：名称、类型和构造函数。默认情况下，所有`bean`的自动装配都是关闭的。
- en: Auto-wiring by name
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按名称自动装配
- en: 'As its name suggests, in this mode, Spring does the wiring of beans by name.
    Spring looks for beans with the same name (ID) as the property that needs to be
    autowired. In other words, dependencies are auto-bound with the bean that has
    the same name (value of ID attribute) as the property name. Let''s understand
    this by looking at the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在这种模式下，Spring通过名称进行`bean`的装配。Spring会寻找与需要自动装配的属性具有相同名称（ID）的`bean`。换句话说，依赖关系会与具有相同名称（ID属性值）的`bean`自动绑定。让我们通过以下示例来理解这一点：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, `AccountService` depends on `UserService`. `AccountService`
    has a setter method through which Spring will inject the dependency of `UserService`.
    The preceding scenario can be configured in Spring as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`AccountService` 依赖于 `UserService`。`AccountService` 有一个setter方法，Spring将通过这个方法注入
    `UserService` 的依赖。前面的场景可以在Spring中配置如下：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In typical setter-based DI configuration, we would have used the `<property>`
    element for the `accountService` bean, and defined the `ref` attribute to refer
    to the `userService` bean. But in previous cases, we haven't used the property
    element, and `userService` is still injected into `accountService` by Spring.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的基于setter的DI配置中，我们会在 `accountService` bean上使用 `<property>` 元素，并将 `ref` 属性定义为引用
    `userService` bean。但在前面的例子中，我们没有使用属性元素，并且 `userService` 仍然通过Spring注入到 `accountService`
    中。
- en: This magic is done by the attribute `autowire="byName"`. How does this work?
    Well, when Spring reads this attribute in `<bean>`, it will try to search the
    bean with the same `name(id)` as the property (setter method) name. If found,
    it will inject that bean to the current bean's setter method on which the `autowire`
    attribute is defined.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种魔法是通过 `autowire="byName"` 属性实现的。它是如何工作的呢？当Spring读取 `<bean>` 中的这个属性时，它会尝试寻找与属性（setter方法）名称相同的
    `name(id)` 的bean。如果找到了，它将把这个bean注入到当前bean的setter方法中，该setter方法定义了 `autowire` 属性。
- en: In our case, `autowire="byName"` is set on the `accountService` bean, which
    has setter method `setUserService` to set the instance of `userService`. Spring
    will try to find any bean with the ID `userService` and, if found, it will inject
    the instance of the `userService` bean through this setter method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`autowire="byName"` 设置在 `accountService` bean 上，该bean有一个 `setUserService`
    的setter方法来设置 `userService` 的实例。Spring会尝试找到任何ID为 `userService` 的bean，如果找到了，它将通过这个setter方法注入
    `userService` bean的实例。
- en: In this case, the autowire happens with the name of the setter method instead
    of the property name. For example, if you set the setter method name as `setUserService1`,
    Spring will try to find the bean with `id=userService1`, irrespective of the actual
    property name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，自动装配是通过setter方法名称而不是属性名称来发生的。例如，如果你将setter方法名称设置为 `setUserService1`，Spring将尝试找到ID为
    `userService1` 的bean，而不考虑实际的属性名称。
- en: Auto-wiring by type
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按类型自动装配
- en: In this mode, Spring does binding of beans based on type. Here, the type means
    the `class` attribute of `<bean>`. Spring looks for the bean with the same type
    as the property that needs to be autowired. In other words, dependencies are auto
    bound with the bean having the same type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，Spring根据类型绑定bean。在这里，类型指的是 `<bean>` 的 `class` 属性。Spring会寻找与需要自动装配的属性类型相同的bean。换句话说，依赖项会自动绑定到具有相同类型的bean上。
- en: 'If more than one bean of the same type exists, Spring shows exception. If Spring
    doesn''t find the bean with a matching type, nothing happens; simply, the property
    will not be set. Let''s understand this by looking at the following example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在多个相同类型的bean，Spring会抛出异常。如果Spring找不到匹配类型的bean，则不会发生任何事情；简单地，该属性将不会被设置。让我们通过以下示例来理解这一点：
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, `HRService` depends on `EmailService`. `HRService` has
    a setter method through which Spring will inject the dependency of `EmailService`.
    Previous scenarios can be configured in Spring as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`HRService` 依赖于 `EmailService`。`HRService` 有一个setter方法，Spring将通过这个方法注入
    `EmailService` 的依赖。前面的场景可以在Spring中配置如下：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When Spring reads the `autowire="byType"` attribute in the `hrService` bean,
    it will try to search the bean with the same type as the property of `hrService`.
    Spring expects just one such bean. If found, it will inject that bean.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring读取 `hrService` bean中的 `autowire="byType"` 属性时，它将尝试寻找与 `hrService` 属性类型相同的bean。Spring期望只有一个这样的bean。如果找到了，它将注入这个bean。
- en: Since this is autowire by type, Spring relies on the type of property to inject
    the dependency, and not on the name of the setter method. Spring only expects
    that the method should take the reference of dependency as a parameter to set
    it with the property of the bean.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是按类型自动装配，Spring依赖于属性的类型来注入依赖项，而不是setter方法的名称。Spring只期望该方法应该将依赖项的引用作为参数传递，以便将其设置到bean的属性中。
- en: Auto-wiring by constructor
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按构造函数自动装配
- en: 'This mode is identical to autowire by type. The only difference is, in this
    case, the autowire happens to constructor arguments rather than properties of
    the bean. When Spring encounters autowire with constructor mode, it will try to
    search and bind the bean''s constructor argument with exactly one bean of the
    same type. Let''s understand this by looking at the following example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与按类型自动装配相同。唯一的区别是，在这种情况下，自动装配发生在构造函数参数而不是bean的属性上。当Spring遇到构造函数模式的自动装配时，它将尝试搜索并绑定bean的构造函数参数与类型完全相同的单个bean。让我们通过以下示例来理解这一点：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, `ExamService`  depends on `StudentService`. `ExamService`
    has a constructor through which Spring will inject the dependency of `StudentService`.
    The previous scenario can be configured in Spring as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ExamService`依赖于`StudentService`。`ExamService`有一个构造函数，Spring将通过它注入`StudentService`的依赖项。在Spring中，可以按照以下方式配置之前的场景：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When Spring scans the attribute `autowire="constructor"` for the bean `examService`,
    it will search and inject any bean with the same type as `examService`'s constructor.
    In our case, we are using one constructor argument of the `StudentService` class,
    so Spring will inject the instance of the `studentService` bean, which we defined
    in the previous XML file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring扫描`examService` bean的`autowire="constructor"`属性时，它将搜索并注入与`examService`构造函数类型相同的任何bean。在我们的例子中，我们使用`StudentService`类的一个构造函数参数，因此Spring将注入我们在之前XML文件中定义的`studentService`
    bean的实例。
- en: Similar to autowire by type mode, if there is more than one bean with a matching
    type to the constructor argument type, Spring will throw an error. Along with
    `autowire = constructor` mode, you can still pass any additional arguments through
    the `<constructor-arg>` element shown in the previous configuration. If we hadn't
    used autowire here, we would have passed the `studentService` with the `<constructor-arg>`
    element.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与按类型自动装配类似，如果存在多个与构造函数参数类型匹配的bean，Spring将抛出错误。在`autowire = constructor`模式下，您仍然可以通过之前配置中显示的`<constructor-arg>`元素传递任何额外的参数。如果我们没有在这里使用自动装配，我们将通过`<constructor-arg>`元素传递`studentService`。
- en: 'In spite of the preceding advantages, the autowire feature should be used with
    a little caution. Following are the points you need to take into consideration
    while using it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有上述优点，自动装配功能在使用时仍需谨慎。以下是在使用时需要考虑的几点：
- en: Autowire can't be applied to primitive types.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动装配不能应用于原始类型。
- en: In case there are multiple beans of the same type, it will cause errors while
    using autowire by type and constructor, though there are options to avoid this.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在多个相同类型的bean，使用按类型和构造函数自动装配时将导致错误，尽管有避免这种情况的选项。
- en: Since autowiring happens silently by Spring, sometimes it's difficult to find
    the logical issue when there are plenty of beans defined in the Spring application
    context files.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于自动装配是由Spring静默执行的，当Spring应用程序上下文文件中定义了大量的bean时，有时很难找到逻辑问题。
- en: People still prefer explicit mapping rather than autowiring, because explicit
    mapping is somewhat more accurate, clear, and more readable as well.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们仍然更喜欢显式映射而不是自动装配，因为显式映射在某种程度上更准确、更清晰，也更易于阅读。
- en: Annotation-based DI
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于注解的依赖注入
- en: From the beginning, the most common way of defining configuration in Spring
    has been XML-based. But when the complexity grew and navigation of beans became
    exhausted in the jungle of angle brackets, there was a demand for a second option
    to define configuration. As a result, Spring started support for annotation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，定义Spring配置最常见的方式就是基于XML的。但随着复杂性的增加，在尖括号丛林中导航bean变得力不从心，因此需要第二种定义配置的方法。因此，Spring开始支持注解。
- en: Annotation-based configuration is an alternate of XML-based configuration, and
    it relies on bytecode metadata. Spring started support for annotation with version
    2.5\. With annotation, the configuration moves from an XML to component class.
    Annotation can be declared on classes, methods, or at field level.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注解的配置是XML配置的替代方案，它依赖于字节码元数据。Spring从2.5版本开始支持注解。使用注解后，配置从XML移动到组件类。注解可以声明在类、方法或字段级别。
- en: Let's understand the process of defining configuration through annotation. We
    will first understand this process through XML configuration, and then will gradually
    move to annotation-based configuration in the following sections.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过注解来理解定义配置的过程。我们首先通过XML配置来理解这个过程，然后在接下来的章节中将逐步转向基于注解的配置。
- en: DI through XML configuration
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过XML配置进行依赖注入
- en: 'It''s always good to start with the most common option. So first, we will take
    an example of pure XML-based configuration, as per the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 总是以最常见的选择开始总是好的。所以首先，我们将举一个纯XML配置的例子，如下面的片段所示：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The object of the `Professor` bean will be created followed by setting the
    `name` property through the setter injection. Since the `name` property is primitive,
    we directly gave the value. Once the object of the `professor` bean is ready,
    it''s injected into the object of the `subject` bean through the setter injection.
    To recall, in XML-based configuration, the setter injection can be performed by
    the `ref` attribute of the `<property>` element. Once you run this code, you will
    get output similar to the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Professor` bean的对象将被创建，然后通过setter注入设置`name`属性。由于`name`属性是原始类型，我们直接给出了值。一旦`professor`
    bean的对象准备好，它将通过setter注入注入到`subject` bean的对象中。回想一下，在基于XML的配置中，setter注入可以通过`<property>`元素的`ref`属性来执行。一旦你运行这段代码，你将得到类似于以下输出的结果：'
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is typical XML-based metadata, and we want to convert it into annotation-based
    configuration. The first annotation we will use in the previous example is `@Autowired`.
    It works similarly to its XML counterpart, `autowire`. It can be configured at
    field, constructor, and method level.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种典型的基于XML的元数据，我们希望将其转换为基于注解的配置。在之前的示例中，我们将首先使用`@Autowired`注解。它与其XML对应物`autowire`的工作方式类似，可以在字段、构造函数和方法级别进行配置。
- en: Defining annotation
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义注解
- en: 'Let''s define `@Autowired` for the previous example. Our goal is to remove
    the XML configuration `<property name="professor" ref="professor" />` for the `subject`
    bean with the `@Autowired` annotation. Let''s modify a `setter` method of the
    `Subject` class and Spring application (XML) context file, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来为之前的示例定义`@Autowired`。我们的目标是移除带有`@Autowired`注解的`subject` bean的XML配置`<property
    name="professor" ref="professor" />`。让我们修改`Subject`类和Spring应用程序（XML）上下文文件中的一个`setter`方法，如下所示：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We are expected to auto-inject the object of `Professor` into `subject`, since
    we used the `@Autowired` annotation. When you run this code, you will get output
    similar to the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望自动将`Professor`对象注入到`subject`中，因为我们使用了`@Autowired`注解。当你运行这段代码时，你将得到类似于以下输出的结果：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Quick observation: only objects of `Professor` and `Subject` beans are created,
    and no setter is called. In spite of using the `@Autowired` annotation, dependency
    is not injected automatically. This has happened because, without being processed,
    annotations do nothing at all. It''s like electronic equipment without being plugged
    in. You can''t do anything with it.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 快速观察：只有`Professor`和`Subject` bean的对象被创建，没有调用任何setter方法。尽管使用了`@Autowired`注解，但依赖注入并没有自动进行。这是因为，如果没有经过处理，注解什么也不做。就像没有插上电源的电子设备一样。你无法对它做任何事情。
- en: By declaring configurations with annotations in the Java class, how does Spring
    know about it? This should be your first question when we talk about annotation-based
    DI. The answer is, we need to let Spring know about the annotation we defined,
    so that Spring can use it to get this work done.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Java类中声明注解配置，Spring是如何知道这些配置的？当我们谈论基于注解的依赖注入时，这应该是你的第一个问题。答案是，我们需要让Spring知道我们定义的注解，这样Spring才能使用它来完成这项工作。
- en: Activating annotation-based configuration
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活基于注解的配置
- en: Annotation-based configuration is not turned on by default. You need to enable
    it by defining the `<context:annotation-config/>` element in application context
    (XML) files. When Spring reads this element, it activates the actions for all
    annotations defined in beans in the same application context where this element
    is defined. In other words, Spring will activate the annotation on all the beans
    defined in the current application context where the `<context:annotation-config
    />` element is defined.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 基于注解的配置默认是关闭的。你需要通过在应用程序上下文（XML）文件中定义`<context:annotation-config/>`元素来启用它。当Spring读取此元素时，它将激活在定义此元素的应用程序上下文中定义的所有注解的动作。换句话说，Spring将在定义了`<context:annotation-config
    />`元素的应用程序上下文中激活所有定义在当前应用程序上下文中的bean上的注解。
- en: 'Let''s update the configuration and rerun the previous code. You will get output
    similar to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新配置并重新运行之前的代码。你将得到类似于以下输出的结果：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To enable `<context:annotation-config />` in Spring XML configuration files,
    you need to include a few schema definitions specific to context, such as `xmlns:context`,
    and add `context-specific xsd` into `schemaLocation`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Spring XML配置文件中启用`<context:annotation-config />`，您需要包含一些特定于上下文的模式定义，例如`xmlns:context`，并将`context-specific
    xsd`添加到`schemaLocation`中。
- en: Now everything works as expected. Objects of the `professor` bean are injected
    into objects of the `subject` bean properly. This is what we want to achieve with
    annotation. But wait a minute. We just removed one element (`<property>`) and
    added the new one—`<context:annotation-config />`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切按预期工作。`professor` Bean的对象被正确地注入到`subject` Bean的对象中。这正是我们希望通过注解实现的目标。但是等等。我们刚刚移除了一个元素（`<property>`）并添加了新的元素——`<context:annotation-config
    />`。
- en: Ideally, annotation-based configuration should replace XML-based configuration
    completely. In previous cases, we are still defining the `<bean>` definition in
    XML-based configuration. If you remove it, Spring will not create any bean, and
    will not perform any action for annotation you defined for those beans. This is
    because `<context:annotation-config />` only works for the `<bean>`s that are
    defined in Spring's application context (XML) file. So, if there is no `<bean>`
    defined, there is no meaning of annotation, even though you defined it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，基于注解的配置应该完全取代基于XML的配置。在先前的案例中，我们仍在基于XML的配置中定义`<bean>`定义。如果您将其删除，Spring将不会创建任何Bean，也不会对您为这些Bean定义的注解执行任何操作。这是因为`<context:annotation-config
    />`仅适用于在Spring的应用程序上下文（XML）文件中定义的`<bean>`。因此，如果没有`<bean>`定义，即使您定义了注解，注解也没有意义。
- en: Defining a Java class as <bean> with annotation
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Java类定义为带有注解的<bean>
- en: 'The solution to this <indexentry content="annotation-based DI:Java class, defining
    as with annotation">problem is to define `<context:component-scan>` in an application
    context (XML) file. When Spring reads this element, it will start scanning the
    beans from the Java package defined by its attribute, `base-package`. You can
    instruct Spring to treat the Java class as `<bean>` by declaring class-level annotation
    `@Component`. In short, defining annotation-based configuration is a two-step
    process, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是定义应用程序上下文（XML）文件中的`<context:component-scan>`。当Spring读取此元素时，它将开始从由其属性`base-package`定义的Java包中扫描Bean。您可以通过声明类级别的注解`@Component`来指示Spring将Java类视为`<bean>`。简而言之，定义基于注解的配置是一个两步过程，如下所示：
- en: '**Scanning the package**: This can be done by reading the `base-package` attribute
    of `<context:component-scan>`. Spring will start scanning for the classes in that
    Java package.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫描包**：这可以通过读取`<context:component-scan>`的`base-package`属性来完成。Spring将开始扫描该Java包中的类。'
- en: '**Defining beans**: Out of Java classes in the said Java package, Spring will
    consider as `<bean>` only those which have class-level annotation—`@Component`
    is defined. Let''s change our example to incorporate this configuration:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**定义Bean**：在指定的Java包中的Java类中，Spring只会将具有类级别注解的类视为`<bean>`——即定义了`@Component`注解的类。让我们修改我们的示例以包含此配置：'
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Spring will consider `Professor` and `Subject` classes as a `<bean>` through
    `@Component` annotation, so there is no need to define them in an application
    context (XML) file. You can inject the value for primitive properties with the `@Value`
    annotation. In the preceding example, we have set the value of the `name` property
    of the `Professor` bean with the `@Value` annotation directly at property level. 
    Alternatively, you can inject the primitive values to `property` at a setter method
    level, as per the following snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Spring将通过`@Component`注解将`Professor`和`Subject`类视为`<bean>`，因此不需要在应用程序上下文（XML）文件中定义它们。您可以使用`@Value`注解为原始属性注入值。在前面的示例中，我们直接在属性级别使用`@Value`注解设置了`Professor`
    Bean的`name`属性的值。或者，您可以根据以下片段在setter方法级别将原始值注入到`property`中：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You need to set the `@Autowired` annotation on the setter method and inject
    the value of that property with the `@Value` annotation. When you run this code,
    you will get the desired output, similar to what we got with pure XML-based configuration.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在setter方法上设置`@Autowired`注解，并使用`@Value`注解注入该属性的值。当您运行此代码时，您将得到期望的输出，类似于我们使用纯XML配置所得到的结果。
- en: The element `<context:component-scan>` does all the things that `<context:annotation-config
    />` can. If you keep both of them in application context (XML) files, there is
    no harm; but then `<context:component-scan>` is just suffice, and you can omit
    `<context:annotation-config />`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 `<context:component-scan>` 执行 `<context:annotation-config />` 可以执行的所有操作。如果您在应用程序上下文（XML）文件中同时保留这两个元素，则没有害处；但是在这种情况下，`<context:component-scan>`
    就足够了，您可以省略 `<context:annotation-config />`。
- en: You can pass multiple packages to `<context:component-scan>` as comma separated
    string to its `base-package` attribute. What's more, you can define various filters
    (include and exclude) on `<context:component-scan>` to scan specific subpackages
    and eliminate others.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将多个包传递给 `<context:component-scan>`，作为逗号分隔的字符串到其 `base-package` 属性。更重要的是，您可以在
    `<context:component-scan>` 上定义各种过滤器（包括和排除），以扫描特定的子包并消除其他包。
- en: Configuration can be done through annotation or with XML, or by mixing both
    of them. The DI configured with XML is executed after annotation-based DI. So
    it's possible that XML-based configuration overrides the annotation-based configuration
    for a bean's property (setter) wiring.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可以通过注释或 XML 进行，或者混合使用两者。通过 XML 配置的 DI 在基于注释的 DI 之后执行。因此，基于 XML 的配置可能会覆盖基于注释的配置，以进行
    Bean 属性（setter）连接。
- en: 'So far, we have learned about `@Autowired`, `@Component`, and `@Value` annotations.
    We will see a few more annotations that are used frequently in DI as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了 `@Autowired`、`@Component` 和 `@Value` 注释。我们将看到一些在 DI 中经常使用的其他注释，如下所示：
- en: '**Annotation—**`@Required`: The  `@Required` annotation can be applied to a
    bean''s setter method. It indicates that Spring must populate the value of a property
    from the setter method either through autowire or explicit setting of a property
    value. In other words, the bean property must be populated at configuration time.
    If this is not fulfilled, the container throws an exception.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释—**`@Required`：`@Required` 注释可以应用于一个 Bean 的 setter 方法。它表示 Spring 必须通过自动装配或显式设置属性值来从
    setter 方法中填充属性的值。换句话说，Bean 属性必须在配置时填充。如果未满足此条件，容器将抛出异常。'
- en: As an alternative, you can use the `@Autowired` annotation with the attribute
    required—`@Autowired` (`required=false`). When you set it to `false`, Spring will
    ignore this property for autowire if the suitable bean is not available.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，您可以使用具有属性 required 的 `@Autowired` 注释—`@Autowired (required=false)`。当您将其设置为
    `false` 时，如果找不到合适的 Bean，Spring 将忽略此属性进行自动装配。
- en: '**Annotation—**`@Qualifier`: By default, the `@Autowired` annotation works
    with the type of bean''s class. When there is more than one bean with the same
    type (class) configured, Spring will show an error when you try to autowire it
    with a property. In this case, you need to use the `@Qualifier` annotation. It
    will help to wire the specific bean out of available beans of the same type. You
    need to specify `@Qualifier` along with `@Autowired` to remove the confusion by
    declaring an exact bean. Let''s understand this by looking at the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释—**`@Qualifier`：默认情况下，`@Autowired` 注释与 Bean 类的类型一起工作。当配置了多个具有相同类型（类）的 Bean
    时，如果您尝试使用属性自动装配它，Spring 将显示错误。在这种情况下，您需要使用 `@Qualifier` 注释。它将帮助从相同类型的可用 Bean 中连接特定的
    Bean。您需要与 `@Autowired` 一起指定 `@Qualifier` 以通过声明一个确切的 Bean 来消除混淆。让我们通过以下示例来理解这一点：'
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the previous code, the `@Qualifier` annotation is added along with `@Autowired`,
    with the value `professor1` in the `Subject` class. This indicates to Spring to
    autowire the `professor` bean with `id = professor1`. In the Spring configuration
    file, we have defined two beans of the `Professor` type with different ID values.
    In absence of the `@Qualifier` annotation, Spring throws an error. The previous
    code produces output like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Qualifier` 注释与 `@Autowired` 一起添加，`Subject` 类中的值为 `professor1`。这表示
    Spring 将自动装配 `id = professor1` 的 `professor` Bean。在 Spring 配置文件中，我们已定义了两个具有不同
    ID 值的 `Professor` 类型的 Bean。如果没有 `@Qualifier` 注释，Spring 将抛出错误。前面的代码产生如下输出：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now Spring will inject the object of a <indexentry content="annotation-based
    DI:Java class, defining as with annotation">bean with similar ID as the value
    of the `@Qualifier` annotation. In previous cases, the object of bean with `id
    = professor1` is injected into `Subject`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Spring 将注入具有与 `@Qualifier` 注释值相似的 ID 的 Bean 对象。在前面的情况下，`id = professor1`
    的 Bean 对象被注入到 `Subject` 中。
- en: You might be surprised that we have used XML-based configuration here. It's
    quite possible to define this with annotation in a Java class, but it's advisable
    to use XML configuration in case you need to define multiple beans of the same
    type with different ID.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶我们在这里使用了基于XML的配置。完全有可能在Java类中使用注解来定义这个配置，但如果你需要定义具有不同ID的相同类型的多个bean，建议使用XML配置。
- en: Annotation with the factory method
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有工厂方法的注解
- en: 'We have seen how the `factory` method is created and configured to generate
    beans with XML-based configuration. Spring supports annotation for the `factory`
    method also. Let''s take the same example, and understand how to write annotation
    for the `factory` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建和配置`factory`方法以使用基于XML的配置来生成bean。Spring也支持对`factory`方法的注解。让我们以相同的示例为例，了解如何编写`factory`方法的注解：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Employee` is a base class having `type` as property. `Developer` and `Manager`
    extend `Employee`, and set the `type` property in a respective constructor. `EmployeeService`
    and `SalaryService` are defined as component classes with the `@Component` annotation.
    Spring will treat both of them as `<bean>`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`是一个基类，具有`type`属性。`Developer`和`Manager`扩展了`Employee`类，并在相应的构造函数中设置了`type`属性。`EmployeeService`和`SalaryService`被定义为带有`@Component`注解的组件类。Spring会将它们都视为`<bean>`。'
- en: '`EmployeeService` works as a factory bean, which has a `getEmployee` method.
    This method has an `@Bean` annotation. The `@Bean` annotation indicates a `factory`
    method. In this method, we are injecting a primitive value: `developer` to `type`
    parameter, with the `@Value` annotation. This method generates the object of either
    `Developer` or `Manager` based on the `type` parameter.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeService`作为一个工厂bean工作，它有一个`getEmployee`方法。这个方法有一个`@Bean`注解。`@Bean`注解表示一个`factory`方法。在这个方法中，我们使用`@Value`注解将原始值`developer`注入到`type`参数中。这个方法根据`type`参数生成`Developer`或`Manager`对象。'
- en: 'In the preceding code, we are supplying a `developerBean` value to the `@Bean`
    annotation. This instructs Spring to create a `<bean>` with `id =developerBean`,
    and a class as `Employee`—a return type from the `getEmployee` (factory) method.
    In short, the `factory` method in the previous code is equivalent to the following
    XML configuration:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们向`@Bean`注解提供了`developerBean`值。这指示Spring创建一个`<bean>`，其`id = developerBean`，类为`Employee`——这是`getEmployee`（工厂）方法的返回类型。简而言之，前面代码中的`factory`方法等同于以下XML配置：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have another component class: ` SalaryService `. It has a `setEmployee` method,
    taking the object of `Employee` as a parameter. We have given a qualifier as `developerBean` to
    the parameter of this method. Since this method is declared as autowired, Spring
    will inject the object of type `Employee` with `id=developerBean`, which is generated
    by the `factory` method in `EmployeeService`.  So, conclusively, the whole preceding
    Java code  is equivalent to the following XML configuration:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个组件类：`SalaryService`。它有一个`setEmployee`方法，该方法接受`Employee`对象作为参数。我们给这个方法的参数指定了一个限定符`developerBean`。由于这个方法被声明为自动装配的，Spring将注入类型为`Employee`且`id=developerBean`的对象，该对象由`EmployeeService`中的`factory`方法生成。因此，综上所述，前面的所有Java代码等同于以下XML配置：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: DI with Java configuration
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java配置进行DI
- en: So far, we have seen how to define the configuration with XML and annotation.
    Spring also supports defining configuration completely in Java classes, and there
    is no more XML required. You need to provide Java classes that take the ownership
    of creating the beans. In short, it's a source of bean definition.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用XML和注解来定义配置。Spring还支持完全在Java类中定义配置，不再需要XML。您需要提供负责创建bean的Java类。简而言之，这是一个bean定义的来源。
- en: 'A class annotated by `@Configuration` would be considered as Java config for
    a Spring IoC container. This class should declare methods that actually configure
    and instantiate the objects of beans that would be managed by containers. All
    such methods should be annotated with `@Bean`. Spring will consider all such `@Bean`
    annotated methods as a source of bean. Such methods are kinds of `factory` methods.
    Let''s understand this by looking at the following simple example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 被注解为`@Configuration`的类将被视为Spring IoC容器的Java配置。这个类应该声明实际配置和实例化由容器管理的bean对象的方法。所有这些方法都应该使用`@Bean`注解。Spring会将所有这样的`@Bean`注解方法视为bean的来源。这些方法类似于`factory`方法。让我们通过以下简单示例来理解这一点：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code, `JavaBaseSpringConfig` is a configuration class. The `name` attribute
    in the `@Bean` annotation is equivalent to the `id` attribute of the `<bean>`
    element. This configuration is equivalent to the following XML configuration:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`JavaBaseSpringConfig` 是一个配置类。`@Bean` 注解中的 `name` 属性等同于 `<bean>` 元素的 `id`
    属性。此配置等同于以下 XML 配置：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once you define all your beans in a configuration class, it can be loaded with
    application context by a container. Spring provides a separate application context
    called `AnnotationConfigApplicationContext` to load configuration classes and
    manage bean objects. It can be used as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在配置类中定义了所有的 Bean，它就可以通过容器加载应用程序上下文。Spring 提供了一个名为 `AnnotationConfigApplicationContext`
    的独立应用程序上下文来加载配置类和管理 Bean 对象。它可以如下使用：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You need to pass a configuration class in the constructor of `AnnotationConfigApplicationContext`,
    and the rest of the process of getting beans is identical to other application
    contexts. Also, there is no change in the way beans are wired with Java config.
    For example, in the previous code, objects of type `Professor` can be injected
    into objects of `Subject`, as per the following snippet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在 `AnnotationConfigApplicationContext` 的构造函数中传递一个配置类，获取 Bean 的其余过程与其他应用程序上下文相同。此外，使用
    Java 配置连接 Bean 的方式没有变化。例如，在之前的代码中，`Professor` 类型的对象可以按照以下片段注入到 `Subject` 类型的对象中：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can notice in the preceding code that we haven't put a `@Component` annotation
    for the `Professor` and `Subject` class. This is because the logic of instance
    creation is within the methods of the configuration class, so there is no need
    to ask Spring to scan the Java package explicitly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到在之前的代码中，我们没有为 `Professor` 和 `Subject` 类添加 `@Component` 注解。这是因为实例创建的逻辑在配置类的函数中，所以没有必要要求
    Spring 显式扫描 Java 包。
- en: 'Spring still provides support scanning of  specific Java package to create
    the bean, instead of creating it yourself with a new operator. For this, you need
    to apply the following changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 仍然支持扫描特定 Java 包以创建 Bean，而不是使用新操作符自己创建。为此，你需要应用以下更改：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In conclusion, the following diagram shows how a Spring IoC container manages
    the process of object creation and dependency management:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，以下图表显示了 Spring IoC 容器如何管理对象创建和依赖管理的过程：
- en: '![](img/00028.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00028.jpeg)'
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how you can implement DI with Spring—one of the
    most popular frameworks for developing enterprise applications today. We have
    seen how the Spring container plays a vital role for managing bean life cycle.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Spring 实现依赖注入——目前开发企业应用程序最受欢迎的框架之一。我们看到了 Spring 容器在管理 Bean 生命周期中扮演的重要角色。
- en: We also learned how to define configurations that are XML and annotation-based.
    We also looked at different types of DI in depth, such as setter-based injection
    and constructor-based injection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何定义基于 XML 和注解的配置。我们还深入探讨了不同类型的依赖注入（DI），例如基于 setter 的注入和基于构造函数的注入。
- en: If you want to write your custom logic while creating instances of beans, you
    can now use the `factory` method in Spring. We also learned how to bind beans
    automatically with various modes, such as autowire by name, type, and constructor.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在创建 Bean 实例时编写自定义逻辑，你现在可以使用 Spring 中的 `factory` 方法。我们还学习了如何以各种模式自动绑定 Bean，例如按名称、类型和构造函数自动装配。
- en: With the help of Java config, you can build Spring applications with zero XML.
    We saw various techniques for using Java config in the last section.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 配置的帮助下，你可以用零 XML 构建 Spring 应用程序。我们在上一节中看到了使用 Java 配置的各种技术。
- en: We will continue our journey and learn how to achieve DI in Google Guice, another
    popular framework that provides containers to achieve loosely coupled systems.
    We will explore them in the next chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续我们的旅程，学习如何在 Google Guice 中实现依赖注入，这是另一个流行的框架，它提供容器以实现松散耦合的系统。我们将在下一章中探讨它们。
