- en: Dependency Injection with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned why modularity is so important in writing cleaner and
    maintainable code. In [Chapter 1](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16), *Why
    Dependency Injection?*, we learned about the **Dependency Inversion Principle**
    (**DIP**), **IoC** (a design methodology to implement DIP), and various design
    patterns to implement IoC. **Dependency Injection** (**DI**) is one of the design
    patterns to achieve IoC.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Chapter 2](part0037.html#1394Q0-255b24dd0eb24162a557b7d0d84b0b16), *Dependency
    Injection in Java 9*, we learned how modular framework and DI are facilitated
    in Java 9\. In this chapter, we will continue our journey to learn DI in Spring—one
    of the most popular and widely used frameworks to implement enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to Spring framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean management in Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to achieve DI with Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Auto wiring: he feature of resolving dependency automatically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation-based DI implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DI implementation with Java-based configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to Spring framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring is a lightweight and open source enterprise framework created way back
    in 2003\. Modularity is the heart of Spring framework. Because of this, Spring
    can be used from the presentation layer to the persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is, Spring doesn't force you to use Spring in all layers. For
    example, if you use Spring in the persistence layer, you are free to use any other
    framework in presentation of the controller layer.
  prefs: []
  type: TYPE_NORMAL
- en: Another good part of Spring is its **Plain Old Java Object** (**POJO**) model-based
    framework. Unlike other frameworks, Spring doesn't force your class to extend
    or implement any base class or interface of Spring API; however, Spring does provide
    a set of classes to use other frameworks, such as ORM frameworks, logging framework,
    Quartz timers, and other third-party libraries, which will help you to integrate
    those frameworks with Spring.
  prefs: []
  type: TYPE_NORMAL
- en: 'More on this: Spring allows you to change the similar framework without changing
    the code. For example, you can choose different persistence frameworks just by
    changing the configuration. This is also applicable to third-party API integration
    with Spring.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring is a POJO-based framework; a servlet container is suffice to run your
    application and a fully-fledged application server is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Spring framework architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring is a modular framework. This brings great flexibility to choosing the
    modules that you need instead of bringing all of them together in your code. Spring
    comprises around 20 modules that are logically grouped into the following layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Core container layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access/integration layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core container layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being a main part of the framework, the core container covers the following
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring core**:As its name suggests, it provides core functionalities of the
    framework, including an IoC container and DI mechanism. An IoC container isolates
    the configuration and dependencies management from the application code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring beans**:This module provides the bean factory to create and manage
    the life cycle of beans (objects). It is a factory pattern implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring context**: This module is built on top of core and bean modules. Its
    entry point is to load the configuration and access the objects. On top of bean
    modules, the context module provides some additional features such as event propagation,
    creating context on the fly, internationalization, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Expression Language** (**SpEL**): This is an expression language to
    access and manipulate objects on the fly in JSP.It''s an extension of **Expression
    Language** (**EL**) of JSP 2.1 specification. Using SpEL makes the JSP code cleaner,
    more readable, and maintainable. Major benefits of using SpEL are:'
  prefs: []
  type: TYPE_NORMAL
- en: The setting of and getting properties' values of objects with ease
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can directly invoke controller methods to get the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's used to retrieve objects directly from Spring's application context (IoC
    container)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports various list operations such as projection, selection, iteration,
    and aggregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides logical and arithmetic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access/integration layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring data access and the integration layer is used for data manipulation
    and other integration. It covers the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction**:This module helps maintain transactions in a programmatic and
    declarative manner. This module supports ORM and JDBC modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object XML mapping** (**OXM**):This module provides abstraction of Object/XML
    processing, which can be used by various OXM implementation such as JAXB, XMLBeans,
    and so on, to integrate with Spring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Relationship Mapping** (**ORM**):Spring doesn''t provide its own ORM
    framework; instead it facilitates integration with ORM frameworks such as Hibernate,
    JPA, JDO, and so on, with this module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Database Connectivity** (**JDBC**):This module provides all low-level
    boilerplate code to deal with JDBC. You can use it to interact with databases
    with standard JDBC API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java Messaging Service** (**JMS**):This module supports integration of messaging
    systems in Spring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring web layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring web layer** is used to create web-based applications. It is comprised
    of the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web**:This module provides basic web-related features such as multipart file
    upload (with the help of Spring custom tags in JSP). It is also responsible for
    initialization of IoC containers in web context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Servlet: **This module provides implementation of Spring MVC (Model View
    Controller) for web-based applications. It provides clear separation of views
    (presentation layer) from models (business logic), and controls the flow between
    them with controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portlet: **This module provides MVC implementation for a portlet, and it
    is mainly used in portal environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This provides support for unit and integration testing with various unit-testing
    frameworks, such as JUnit and TestNg. We will see how to perform unit testing
    with Spring in upcoming sections in this chapter, so keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some additional modules are also part of the Spring framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aspect and AOP: **These modules provide a facility to apply common logic
    (called *concerns* in AOP terminology) across multiple application layers dynamically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumentation:** This module provides a class instrumentation facility
    and class loader implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Messaging: **This module provides support for **Streaming Text-Oriented Messaging
    Protocol** (**STOMP**) for communicating with various STOMP-based clients'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean management in Spring container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When any software application is being executed, a set of objects are created
    and interact with each other to achieve specific business goals. Being a POJO-based
    programming model, the Spring framework treats all the objects of classes in your
    application as POJO or beans (in a Spring-friendly way).
  prefs: []
  type: TYPE_NORMAL
- en: These objects or beans should be independent in a manner that they can be re-used
    or changed without causing the ripple effect of changing others. Being loosely
    coupled this way, it also provides the benefit of doing testing without much worry
    of any dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides an IoC container, which is used to automate the process of supplying
    external dependency to your class. You need to give instruction (in the form of
    configuration) about your client and dependencies. Spring will manage and resolve
    all your dependencies at runtime. Moreover, Spring provides a facility to keep
    availability of your dependencies at various application scopes, such as request,
    session, application, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: It's essential to understand how Spring manages the life cycle (the process
    of creating, managing, and destroying) of objects before getting an idea about
    injecting dependency. In Spring, all these responsibilities are performed by the
    Spring IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Spring IoC container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Spring, the `org.springframework.beans.factory.BeanFactory` interface defines
    the basic IoC container, while the `org.springframework.context.ApplicationContext` interface
    represents an advanced IoC container. `ApplicationContext` is a super set of `BeanFactory`.
    It provides some additional enterprise-level functionalities on top of basic IoC
    features by `BeanFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: To cater for different types of applications, Spring provides various implementations
    of `ApplicationContext` out of the box. For standalone applications, you can use
    the `FileSystemXmlApplicationContext` or `ClassPathXmlApplicationContext` class. They
    are both implementations of `ApplicationConext`.
  prefs: []
  type: TYPE_NORMAL
- en: While working with Spring, you need to pass one XML file as an entry point for
    these containers. This file is called the **Spring Application Context file**.
    When the Spring container starts, it loads this XML file and starts configuring
    your beans (either with XML-based bean definition in this file, or annotation-based
    definition in your POJO Java class).
  prefs: []
  type: TYPE_NORMAL
- en: '`FileSystemXmlApplicationContext`: This container loads the Spring XML file
    and processes it. You need to give the full path of the XML file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClassPathXmlApplicationContext`: This container works similarly to `FileSystemXmlApplicationContext`;
    however, it assumes that the Spring XML file is available in `CLASSPATH`. You
    do not need to pass a root-level path for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebXmlApplicationContext`: This container is generally used within web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring''s IoC container is responsible for instantiating, configuring, maintaining,
    and accumulating the beans (objects in your application). You need to provide
    configuration metadata about the objects you want to assemble with the IoC container.
    The following diagram depicts a high-level flow of how the IoC container gets
    this work done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We provide **Pojo Classes** (or bean definitions) and **Configuration metadata**
    (set of instructions) as an input. The Spring IoC container will create and manage
    the objects (or beans) in a way that they produce a ready-to-use system. In short,
    an IoC container performs all low-level tasks (of managing beans and dependencies)
    so that you can write business logic in your POJO class.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to give instructions to Spring''s container about how you want to
    configure your beans based on your application needs. These instructions should
    be in the form of configuration metadata, and they should tell the following things
    to the IoC container:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiation**: How to create the objects from bean definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifespan**: Till what time these objects are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**: Do they need someone else?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring provides a great amount of flexibility, even in defining the configuration
    metadata. You can supply it to the IoC container in the following three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XML format:** One or more entries with configuration metadata about beans
    in Spring''s Application Context (XML) file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java annotation:** Put the configuration metadata in the form of an annotation
    in a Java class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pure Java code: **From version 3.0, Spring started support of defining configuration
    with Java code. You can define beans outside of your application classes by using
    Java rather than XML files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the Spring application starts, it will load the application context (XML)
    file first. This file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This file must be present for both XML-based and annotation-based configuration
    metadata. In the case of XML-based configuration, you need to define your bean
    with the `<bean>` element under top-level `<beans>` elements in this file. One
    or multiple `<bean>` entries can be defined. The configuration metadata will go
    along with the `<bean>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding bean definition, the `id` attribute defines the identity of
    that bean. The container will use it to point out the specific bean, so it must
    be unique. While the `class` attribute defines the type of bean, you need to give
    its fully qualified class name here.
  prefs: []
  type: TYPE_NORMAL
- en: Each bean is associated with an actual object through the `class` attribute.
    You can define beans for any type of class, such as your custom service layer
    classes, DAO layer classes, presentation classes, and so on. Spring's container
    will use the `class` attribute to instantiate the objects, and it applies the
    configuration metadata associated with the corresponding `<bean>` element.
  prefs: []
  type: TYPE_NORMAL
- en: In case of annotation-based configuration, your metadata will be defined to
    actual Java classes and in this (XML) file; you need to just specify the base
    package name with the `<context:component-scan base-package="org.example"/>` element.
    We will see more on this in an upcoming section, *Annotation-based DI*, in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Containers in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand the flow of Spring-based applications with ease, we will take
    an example of standalone application containers: `ClassPathXmlApplicationContext`,
    or `FileSystemXmlApplicationContext`. The whole process of dealing with Spring
    comprises the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining POJOs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating application context (XML) files with configuration metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Defining POJOs: **As we have seen in previous sections of this chapter, Spring
    considers each object in your application as a POJO. So, first you need to define
    POJOs. We will use simple examples to understand the concepts as per the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Providing application context (XML) files**: Create one XML file and name
    it `application-context.xml`. For the sake of simplicity, we use XML-based configuration
    metadata. We will see another two ways (annotation-based and Java code-based)
    of setting configuration metadata in upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define `<bean>` for each of your module classes along with their configuration
    metadata in the application context file (`application-context.xml`), as per the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have defined `<bean>` for our POJO `-Car` with `id="myCar"`. The Spring container
    uses this ID to get the object of the `Car` bean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing container: **In case of a web-based application, the container
    (`WebXmlApplicationContext`) will be initialized by a web listener when an application
    is loaded into the servlet container. In case of a standalone application, you
    need to initialize the containers (`ClassPathXmlApplicationContext` or `FileSystemXmlApplicationContext`)
    with Java code, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are other overloaded constructors of `ClassPathXmlApplicationContext`
    and `FileSystemXmlApplicationContext` containers, such as a no-argument constructor
    and string array argument constructor, which is used to load more than one application
    context (XML) file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Soon after the Spring container is loaded into memory, it processes the application
    context (XML) file and creates the objects for corresponding `<bean>` definition.
    You can get the instance of your bean with the help of a container, as per the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you call the `getBean` method, the container internally calls its constructor
    to create the object, which is equivalent to calling the `new()` operator. This
    is how Spring's IoC container creates, maintains, and assembles the objects corresponding
    to each `<bean>` definition in Spring's application context(XML) file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring creates the object of each `<bean>` element with a Singleton
    fashion. It means a container creates and holds just one object of each `<bean>`
    unless you explicitly tell it not to. When you ask a container for the object
    of `<bean>` with the `getBean()` method, it gives the reference of the same object
    every time after creating it the first time.
  prefs: []
  type: TYPE_NORMAL
- en: When a container creates the object corresponding to the `<bean>` definition,
    you do not need to implement any specific interface, or extend any class or code
    in a specific way. Simply specifying the `class` attribute of `<bean>` is suffice.
    Spring is capable enough to create an object of any type.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection (DI) in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After getting an idea of how Spring manages bean life cycle, next we will learn
    how Spring provides and maintains the dependencies in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '**DI** is a process of providing the dependent objects to other objects that
    need it. In Spring, the container supplies the dependencies. The flow of creating
    and managing the dependencies is inverted from client to container. That is the
    reason we call it an **IoC container**.'
  prefs: []
  type: TYPE_NORMAL
- en: A Spring IoC container uses the Dependency Injection (DI) mechanism to provide
    the dependency at runtime. In [Chapter 1](part0020.html#J2B80-255b24dd0eb24162a557b7d0d84b0b16), 
    *Why Dependency Injection?,* we saw various DI types such as constructor, setter
    method, and interface-based. Let's see how we can implement the constructor and
    setter-based DI through Spring's IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constructor-based dependency is generally used where you want to pass mandatory
    dependencies before the object is instantiated. It's provided by a container through
    a constructor with different arguments, and each represents dependency.
  prefs: []
  type: TYPE_NORMAL
- en: When a container starts, it checks wheather any constructor-based DI is defined
    for `<bean>`. It will create the dependency objects first, and then pass them
    to the current object's constructor. We will understand this by taking the classic
    example of using logging. It is good practice to put the log statement at various
    places in code to trace the flow of execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have an `EmployeeService` class where you need to put a log
    in each of its methods. To achieve separation of concern, you put the log functionality
    in a separated class called `Logger`. To make sure the `EmployeeService` and `Logger`
    are independent and loosely coupled, you need to inject the `Logger` object into
    the `EmployeeService` object. Let''s see how to achieve this by constructor-based
    injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the preceding code, when these objects are configured with Spring, the `EmployeeService`
    object expects the Spring container to inject the object of `Logger` through the
    constructor. To achieve this, you need to set the configuration metadata as per
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, the `Logger` bean is injected into the `employee`
    bean through the `constructor-arg` element. It has a `ref` attribute, which is
    used to point to other beans with a matching `id` value.  This configuration instructs
    Spring to pass the object of `Logger` into the constructor of the `EmployeeService`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: You can put the `<bean>` definition in any order here. Spring will create the
    objects of `<bean>` based on need, and not as per the order they are defined here.
  prefs: []
  type: TYPE_NORMAL
- en: For more than one constructor argument, you can pass additional `<constructor-arg>`
    elements. The order is not important as far as the object type (class attribute
    of referred bean) is not ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring also supports DI with primitive constructor arguments. Spring provides
    the facility to pass the primitive values in a constructor from an application
    context (XML) file. Let''s say you want to create an object of the `Camera` class
    with a default value, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Camera` class has three properties: `resolution`, `mode`, and `smileShot`.
    Its constructor takes three primitive arguments to create a camera object with
    default values. You need to give configuration metadata in the following way,
    so that Spring can create instances of the `Camera` object with default primitive
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We pass three `<constructor-arg>` elements under `<bean>`, corresponding to
    each constructor argument. Since these are primitive, Spring has no idea about
    its type while passing the value. So, we need to explicitly pass the `type` attribute,
    which defines the type of primitive constructor argument.
  prefs: []
  type: TYPE_NORMAL
- en: In case of primitive also, there is no fixed order to pass the value of the
    constructor argument, as long as the type is not ambiguous. In previous cases,
    all three types are different, so Spring intelligently picks up the right constructor
    argument, no matter which order you pass them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are adding one more attribute to the `Camera` class called `flash`,
    as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the constructor arguments `smileShot` and `flash` are of the
    same type (Boolean), and you pass the constructor argument value from XML configuration
    as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding scenario, Spring will pick up the following:'
  prefs: []
  type: TYPE_NORMAL
- en: int value for resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String value for mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First Boolean value (true) in sequence for first Boolean argument—`smileShot`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second Boolean value (false) in sequence for second Boolean argument—flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, for similar types in constructor arguments, Spring will pick the first
    value that comes in the sequence. So sequence does matter in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may lead to logical errors, as you are passing wrong values to the right
    argument. To avoid such accidental mistakes, Spring provides the facility to define
    a zero-based index in the `<constructor-arg>` element, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is more readable and less error prone. Now Spring will pick up the last
    value (with `index=2`) for `smileShot`, and the second value (with `index=3`)
    for `flash` arguments. Index attributes resolves the ambiguity of two constructor
    arguments having the same type.
  prefs: []
  type: TYPE_NORMAL
- en: If the `type` you defined in `<constructor-arg>` is not compatible with the
    actual type of constructor argument in that index, then Spring will raise an error.
    So just make sure about this while using index attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Setter-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Setter-based DI** is generally used for optional dependencies. In case of
    setter-based DI, the container first creates an instance of your bean, either
    by calling a no-argument constructor or static `factory` method. It then passes
    the said dependencies through each setter method. Dependencies injected through
    the setter method can be re-injected or changed at a later stage of application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will understand setter-based DI with the following code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The  `DocumentBase` class depends on `DocFinder`, and we are passing it through
    the `setter` method. You need to define the configuration metadata for Spring,
    as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Setter-based DI can be defined through the `<property>` element under `<bean>`.
    The `name` attribute denotes the name of the `setter` name. In our case, the `name`
    attribute of the `property` element is `docFinder`, so Spring will call the `setDocFinder` method
    to inject the dependency. The pattern to find the `setter` method is to prepend
    `set` and make the first character capital.
  prefs: []
  type: TYPE_NORMAL
- en: The `name` attribute of the `<property>` element is case-sensitive. So, if you
    set the name to `docfinder`, Spring will try to call the `setDocfinder` method
    and will show an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like constructor DI, Setter DI also supports supplying the value for primitives,
    as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the `setter` method takes only one argument, there is no scope of argument
    ambiguity. Whatever value you are passing here, Spring will convert it to an actual
    primitive type of the `setter` method parameter. If it's not compatible, it will
    show an error.
  prefs: []
  type: TYPE_NORMAL
- en: Spring DI with the factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen that the Spring container takes care of creating the instances
    of `bean`. In some scenarios, you need to take control of creating an instance
    of `bean` with custom code. Spring supports this feature with the help of the
    `factory` method.
  prefs: []
  type: TYPE_NORMAL
- en: You can write your custom logic to create the instance in the `factory` method,
    and just instruct Spring to use it. When Spring encounters such instructions,
    it will call the `factory` method to create the instance. So, the `factory` method
    is kind of a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two flavors of the `factory` method: static, and instance (non-static).'
  prefs: []
  type: TYPE_NORMAL
- en: Static factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you want to encapsulate the logic of creating the instance in a static
    way to custom methods, you can use a static `factory` method. In this case, Spring
    will use the `Class` attribute of `<bean>` to call the `factory` method and generate
    instances. Let''s understand this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous configuration, Spring will always use the `getSearchableFactory`
    method to create the instance of bean irrespective of any scope.
  prefs: []
  type: TYPE_NORMAL
- en: Instance (non-static) factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use an instance `factory` method to shift the control of creating the
    instance from a container to your custom object. The only difference between an
    instance `factory` method and a static `factory` method is that the former can
    only be invoked with an instance of bean. Let''s understand this by taking the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Employee` is a generic class that has a `type` instance variable. `Developer`
    and `Manager` extend `Employee`, and they pass the `type` in the constructor.
    `EmployeeService` is a class that has a `factory` method: `getEmployee`. This
    method takes a String argument, and generates either `Developer` or `Manager`
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These objects can be configured in Spring as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `employeeService` is defined with normal bean definition. The `developerBean`
    is defined with `factory-method` and `factory-bean` attributes. The `factory-bean`
    attribute represents the reference of bean in which the `factory` method is defined.
  prefs: []
  type: TYPE_NORMAL
- en: In previous cases, `developerBean` is created by calling the `factory` method `getEmployee`
    on bean `employeeService`. The argument passed through `<constructor-arg>` to
    `developerBean` actually goes to the `factory` method. You will also notice that
    we haven't defined a `class` attribute for `developerBean`, because when `factory-bean`
    is defined for bean, Spring will consider the class as a returned type from the
    `factory` method (defined in factory bean), rather than considering the bean's
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This way, `developerBean` is a kind of virtual bean that is generated by the
    `factory` method of another class. Lastly, we have created `salaryService`, and
    passed the `developerBean` as a setter injection. When you execute this code,
    it shows the type as a `developer`. This is how we can use the instance `factory`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The type of class returned by the`factory` method need not be the same as the
    class in which the `factory` method is defined. If you have used a different class,
    you need to cast with the class that is being returned from the `factory` method,
    while calling the `getBean()` method of `ApplicationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Spring uses `singleton` scope for each of the beans. It means Spring
    will create just one object of each bean. For other scopes such as `prototype`,
    Spring creates a new instance every time you make a call to the `getBean` method.
    But if you specify which `factory` method, Spring will call the `factory` method
    to get the object all the time.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are using the `factory` method to make sure Spring creates just
    one object of our bean, irrespective of the bean's scope. This is just one example.
    This way you can use the `factory` method with any custom logic while creating
    the instance. It basically encapsulates the object instantiation process.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-wiring in Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to define configuration metadata along with `<bean>`
    to set the dependencies. How good would it be if everything was settled down without
    giving any instruction in the form of configuration? That is a cool idea, and
    the good news is that Spring supports it.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is called autowire (in Spring terminology), which automates the
    process of binding relations between beans. This greatly reduces the effort of
    providing configuration metadata at either properties or constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The autowire feature can be enabled in XML-based configuration metadata by
    defining the `autowire` attribute of the `<bean>` element. It can be specified
    with the following three modes: name, type, and constructor. By default, autowire
    is set off for all beans.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto-wiring by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As its name suggests, in this mode, Spring does the wiring of beans by name.
    Spring looks for beans with the same name (ID) as the property that needs to be
    autowired. In other words, dependencies are auto-bound with the bean that has
    the same name (value of ID attribute) as the property name. Let''s understand
    this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `AccountService` depends on `UserService`. `AccountService`
    has a setter method through which Spring will inject the dependency of `UserService`.
    The preceding scenario can be configured in Spring as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In typical setter-based DI configuration, we would have used the `<property>`
    element for the `accountService` bean, and defined the `ref` attribute to refer
    to the `userService` bean. But in previous cases, we haven't used the property
    element, and `userService` is still injected into `accountService` by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: This magic is done by the attribute `autowire="byName"`. How does this work?
    Well, when Spring reads this attribute in `<bean>`, it will try to search the
    bean with the same `name(id)` as the property (setter method) name. If found,
    it will inject that bean to the current bean's setter method on which the `autowire`
    attribute is defined.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, `autowire="byName"` is set on the `accountService` bean, which
    has setter method `setUserService` to set the instance of `userService`. Spring
    will try to find any bean with the ID `userService` and, if found, it will inject
    the instance of the `userService` bean through this setter method.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the autowire happens with the name of the setter method instead
    of the property name. For example, if you set the setter method name as `setUserService1`,
    Spring will try to find the bean with `id=userService1`, irrespective of the actual
    property name.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-wiring by type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this mode, Spring does binding of beans based on type. Here, the type means
    the `class` attribute of `<bean>`. Spring looks for the bean with the same type
    as the property that needs to be autowired. In other words, dependencies are auto
    bound with the bean having the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If more than one bean of the same type exists, Spring shows exception. If Spring
    doesn''t find the bean with a matching type, nothing happens; simply, the property
    will not be set. Let''s understand this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `HRService` depends on `EmailService`. `HRService` has
    a setter method through which Spring will inject the dependency of `EmailService`.
    Previous scenarios can be configured in Spring as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When Spring reads the `autowire="byType"` attribute in the `hrService` bean,
    it will try to search the bean with the same type as the property of `hrService`.
    Spring expects just one such bean. If found, it will inject that bean.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is autowire by type, Spring relies on the type of property to inject
    the dependency, and not on the name of the setter method. Spring only expects
    that the method should take the reference of dependency as a parameter to set
    it with the property of the bean.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-wiring by constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This mode is identical to autowire by type. The only difference is, in this
    case, the autowire happens to constructor arguments rather than properties of
    the bean. When Spring encounters autowire with constructor mode, it will try to
    search and bind the bean''s constructor argument with exactly one bean of the
    same type. Let''s understand this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `ExamService`  depends on `StudentService`. `ExamService`
    has a constructor through which Spring will inject the dependency of `StudentService`.
    The previous scenario can be configured in Spring as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When Spring scans the attribute `autowire="constructor"` for the bean `examService`,
    it will search and inject any bean with the same type as `examService`'s constructor.
    In our case, we are using one constructor argument of the `StudentService` class,
    so Spring will inject the instance of the `studentService` bean, which we defined
    in the previous XML file.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to autowire by type mode, if there is more than one bean with a matching
    type to the constructor argument type, Spring will throw an error. Along with
    `autowire = constructor` mode, you can still pass any additional arguments through
    the `<constructor-arg>` element shown in the previous configuration. If we hadn't
    used autowire here, we would have passed the `studentService` with the `<constructor-arg>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In spite of the preceding advantages, the autowire feature should be used with
    a little caution. Following are the points you need to take into consideration
    while using it:'
  prefs: []
  type: TYPE_NORMAL
- en: Autowire can't be applied to primitive types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case there are multiple beans of the same type, it will cause errors while
    using autowire by type and constructor, though there are options to avoid this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since autowiring happens silently by Spring, sometimes it's difficult to find
    the logical issue when there are plenty of beans defined in the Spring application
    context files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: People still prefer explicit mapping rather than autowiring, because explicit
    mapping is somewhat more accurate, clear, and more readable as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotation-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the beginning, the most common way of defining configuration in Spring
    has been XML-based. But when the complexity grew and navigation of beans became
    exhausted in the jungle of angle brackets, there was a demand for a second option
    to define configuration. As a result, Spring started support for annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation-based configuration is an alternate of XML-based configuration, and
    it relies on bytecode metadata. Spring started support for annotation with version
    2.5\. With annotation, the configuration moves from an XML to component class.
    Annotation can be declared on classes, methods, or at field level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the process of defining configuration through annotation. We
    will first understand this process through XML configuration, and then will gradually
    move to annotation-based configuration in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: DI through XML configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s always good to start with the most common option. So first, we will take
    an example of pure XML-based configuration, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The object of the `Professor` bean will be created followed by setting the
    `name` property through the setter injection. Since the `name` property is primitive,
    we directly gave the value. Once the object of the `professor` bean is ready,
    it''s injected into the object of the `subject` bean through the setter injection.
    To recall, in XML-based configuration, the setter injection can be performed by
    the `ref` attribute of the `<property>` element. Once you run this code, you will
    get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is typical XML-based metadata, and we want to convert it into annotation-based
    configuration. The first annotation we will use in the previous example is `@Autowired`.
    It works similarly to its XML counterpart, `autowire`. It can be configured at
    field, constructor, and method level.
  prefs: []
  type: TYPE_NORMAL
- en: Defining annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define `@Autowired` for the previous example. Our goal is to remove
    the XML configuration `<property name="professor" ref="professor" />` for the `subject`
    bean with the `@Autowired` annotation. Let''s modify a `setter` method of the
    `Subject` class and Spring application (XML) context file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are expected to auto-inject the object of `Professor` into `subject`, since
    we used the `@Autowired` annotation. When you run this code, you will get output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Quick observation: only objects of `Professor` and `Subject` beans are created,
    and no setter is called. In spite of using the `@Autowired` annotation, dependency
    is not injected automatically. This has happened because, without being processed,
    annotations do nothing at all. It''s like electronic equipment without being plugged
    in. You can''t do anything with it.'
  prefs: []
  type: TYPE_NORMAL
- en: By declaring configurations with annotations in the Java class, how does Spring
    know about it? This should be your first question when we talk about annotation-based
    DI. The answer is, we need to let Spring know about the annotation we defined,
    so that Spring can use it to get this work done.
  prefs: []
  type: TYPE_NORMAL
- en: Activating annotation-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotation-based configuration is not turned on by default. You need to enable
    it by defining the `<context:annotation-config/>` element in application context
    (XML) files. When Spring reads this element, it activates the actions for all
    annotations defined in beans in the same application context where this element
    is defined. In other words, Spring will activate the annotation on all the beans
    defined in the current application context where the `<context:annotation-config
    />` element is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the configuration and rerun the previous code. You will get output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To enable `<context:annotation-config />` in Spring XML configuration files,
    you need to include a few schema definitions specific to context, such as `xmlns:context`,
    and add `context-specific xsd` into `schemaLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: Now everything works as expected. Objects of the `professor` bean are injected
    into objects of the `subject` bean properly. This is what we want to achieve with
    annotation. But wait a minute. We just removed one element (`<property>`) and
    added the new one—`<context:annotation-config />`.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, annotation-based configuration should replace XML-based configuration
    completely. In previous cases, we are still defining the `<bean>` definition in
    XML-based configuration. If you remove it, Spring will not create any bean, and
    will not perform any action for annotation you defined for those beans. This is
    because `<context:annotation-config />` only works for the `<bean>`s that are
    defined in Spring's application context (XML) file. So, if there is no `<bean>`
    defined, there is no meaning of annotation, even though you defined it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Java class as <bean> with annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this <indexentry content="annotation-based DI:Java class, defining
    as with annotation">problem is to define `<context:component-scan>` in an application
    context (XML) file. When Spring reads this element, it will start scanning the
    beans from the Java package defined by its attribute, `base-package`. You can
    instruct Spring to treat the Java class as `<bean>` by declaring class-level annotation
    `@Component`. In short, defining annotation-based configuration is a two-step
    process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanning the package**: This can be done by reading the `base-package` attribute
    of `<context:component-scan>`. Spring will start scanning for the classes in that
    Java package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Defining beans**: Out of Java classes in the said Java package, Spring will
    consider as `<bean>` only those which have class-level annotation—`@Component`
    is defined. Let''s change our example to incorporate this configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring will consider `Professor` and `Subject` classes as a `<bean>` through
    `@Component` annotation, so there is no need to define them in an application
    context (XML) file. You can inject the value for primitive properties with the `@Value`
    annotation. In the preceding example, we have set the value of the `name` property
    of the `Professor` bean with the `@Value` annotation directly at property level. 
    Alternatively, you can inject the primitive values to `property` at a setter method
    level, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You need to set the `@Autowired` annotation on the setter method and inject
    the value of that property with the `@Value` annotation. When you run this code,
    you will get the desired output, similar to what we got with pure XML-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The element `<context:component-scan>` does all the things that `<context:annotation-config
    />` can. If you keep both of them in application context (XML) files, there is
    no harm; but then `<context:component-scan>` is just suffice, and you can omit
    `<context:annotation-config />`.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass multiple packages to `<context:component-scan>` as comma separated
    string to its `base-package` attribute. What's more, you can define various filters
    (include and exclude) on `<context:component-scan>` to scan specific subpackages
    and eliminate others.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration can be done through annotation or with XML, or by mixing both
    of them. The DI configured with XML is executed after annotation-based DI. So
    it's possible that XML-based configuration overrides the annotation-based configuration
    for a bean's property (setter) wiring.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned about `@Autowired`, `@Component`, and `@Value` annotations.
    We will see a few more annotations that are used frequently in DI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotation—**`@Required`: The  `@Required` annotation can be applied to a
    bean''s setter method. It indicates that Spring must populate the value of a property
    from the setter method either through autowire or explicit setting of a property
    value. In other words, the bean property must be populated at configuration time.
    If this is not fulfilled, the container throws an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative, you can use the `@Autowired` annotation with the attribute
    required—`@Autowired` (`required=false`). When you set it to `false`, Spring will
    ignore this property for autowire if the suitable bean is not available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Annotation—**`@Qualifier`: By default, the `@Autowired` annotation works
    with the type of bean''s class. When there is more than one bean with the same
    type (class) configured, Spring will show an error when you try to autowire it
    with a property. In this case, you need to use the `@Qualifier` annotation. It
    will help to wire the specific bean out of available beans of the same type. You
    need to specify `@Qualifier` along with `@Autowired` to remove the confusion by
    declaring an exact bean. Let''s understand this by looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the `@Qualifier` annotation is added along with `@Autowired`,
    with the value `professor1` in the `Subject` class. This indicates to Spring to
    autowire the `professor` bean with `id = professor1`. In the Spring configuration
    file, we have defined two beans of the `Professor` type with different ID values.
    In absence of the `@Qualifier` annotation, Spring throws an error. The previous
    code produces output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now Spring will inject the object of a <indexentry content="annotation-based
    DI:Java class, defining as with annotation">bean with similar ID as the value
    of the `@Qualifier` annotation. In previous cases, the object of bean with `id
    = professor1` is injected into `Subject`.
  prefs: []
  type: TYPE_NORMAL
- en: You might be surprised that we have used XML-based configuration here. It's
    quite possible to define this with annotation in a Java class, but it's advisable
    to use XML configuration in case you need to define multiple beans of the same
    type with different ID.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation with the factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how the `factory` method is created and configured to generate
    beans with XML-based configuration. Spring supports annotation for the `factory`
    method also. Let''s take the same example, and understand how to write annotation
    for the `factory` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Employee` is a base class having `type` as property. `Developer` and `Manager`
    extend `Employee`, and set the `type` property in a respective constructor. `EmployeeService`
    and `SalaryService` are defined as component classes with the `@Component` annotation.
    Spring will treat both of them as `<bean>`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmployeeService` works as a factory bean, which has a `getEmployee` method.
    This method has an `@Bean` annotation. The `@Bean` annotation indicates a `factory`
    method. In this method, we are injecting a primitive value: `developer` to `type`
    parameter, with the `@Value` annotation. This method generates the object of either
    `Developer` or `Manager` based on the `type` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we are supplying a `developerBean` value to the `@Bean`
    annotation. This instructs Spring to create a `<bean>` with `id =developerBean`,
    and a class as `Employee`—a return type from the `getEmployee` (factory) method.
    In short, the `factory` method in the previous code is equivalent to the following
    XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have another component class: ` SalaryService `. It has a `setEmployee` method,
    taking the object of `Employee` as a parameter. We have given a qualifier as `developerBean` to
    the parameter of this method. Since this method is declared as autowired, Spring
    will inject the object of type `Employee` with `id=developerBean`, which is generated
    by the `factory` method in `EmployeeService`.  So, conclusively, the whole preceding
    Java code  is equivalent to the following XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: DI with Java configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to define the configuration with XML and annotation.
    Spring also supports defining configuration completely in Java classes, and there
    is no more XML required. You need to provide Java classes that take the ownership
    of creating the beans. In short, it's a source of bean definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class annotated by `@Configuration` would be considered as Java config for
    a Spring IoC container. This class should declare methods that actually configure
    and instantiate the objects of beans that would be managed by containers. All
    such methods should be annotated with `@Bean`. Spring will consider all such `@Bean`
    annotated methods as a source of bean. Such methods are kinds of `factory` methods.
    Let''s understand this by looking at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, `JavaBaseSpringConfig` is a configuration class. The `name` attribute
    in the `@Bean` annotation is equivalent to the `id` attribute of the `<bean>`
    element. This configuration is equivalent to the following XML configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you define all your beans in a configuration class, it can be loaded with
    application context by a container. Spring provides a separate application context
    called `AnnotationConfigApplicationContext` to load configuration classes and
    manage bean objects. It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to pass a configuration class in the constructor of `AnnotationConfigApplicationContext`,
    and the rest of the process of getting beans is identical to other application
    contexts. Also, there is no change in the way beans are wired with Java config.
    For example, in the previous code, objects of type `Professor` can be injected
    into objects of `Subject`, as per the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can notice in the preceding code that we haven't put a `@Component` annotation
    for the `Professor` and `Subject` class. This is because the logic of instance
    creation is within the methods of the configuration class, so there is no need
    to ask Spring to scan the Java package explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring still provides support scanning of  specific Java package to create
    the bean, instead of creating it yourself with a new operator. For this, you need
    to apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In conclusion, the following diagram shows how a Spring IoC container manages
    the process of object creation and dependency management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how you can implement DI with Spring—one of the
    most popular frameworks for developing enterprise applications today. We have
    seen how the Spring container plays a vital role for managing bean life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to define configurations that are XML and annotation-based.
    We also looked at different types of DI in depth, such as setter-based injection
    and constructor-based injection.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to write your custom logic while creating instances of beans, you
    can now use the `factory` method in Spring. We also learned how to bind beans
    automatically with various modes, such as autowire by name, type, and constructor.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of Java config, you can build Spring applications with zero XML.
    We saw various techniques for using Java config in the last section.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue our journey and learn how to achieve DI in Google Guice, another
    popular framework that provides containers to achieve loosely coupled systems.
    We will explore them in the next chapter.
  prefs: []
  type: TYPE_NORMAL
