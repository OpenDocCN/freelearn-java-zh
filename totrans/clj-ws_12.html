<html><head></head><body>
		<div>
			<div id="_idContainer238" class="Content">
			</div>
		</div>
		<div id="_idContainer239" class="Content">
			<h1 id="_idParaDest-266"><a id="_idTextAnchor356"/>12. Concurrency</h1>
		</div>
		<div id="_idContainer265" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter we will explore Clojure's concurrency features. On the JVM, you will learn the basics of programming with multiple processor threads: starting a new thread and using the results. To coordinate your threads, we will use Clojure's innovative reference types. One of these, the atom, can also be used in a JavaScript environment.<a id="_idTextAnchor357"/></p>
			<p class="callout">By the end of this chapter, you will be able to build simple browser games and manage their state using atoms.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor358"/>Introduction</h1>
			<p>Ever since the Clojure language was first introduced, its concurrency model has been one of its major selling points. In programming, the word "concurrency" can apply to a lot of different situations. To start with a simple definition, any time your program or your system has more than one simultaneous flow of operations, you are dealing with concurrency. In multithreaded Java programs, that would mean code running simultaneously in separate processor threads. Each processor thread follows its own internal logic, but to work properly your program needs to coordinate the communication between the different threads. Even though JavaScript runtimes are single-threaded, both the browser and Node.js environments have their own ways of dealing with simultaneous logical flows. <a id="_idTextAnchor359"/>While the roots of Clojure's concurrency are definitely in Java, some of the ideas and tools apply equally in <strong class="bold">ClojureScript</strong>.</p>
			<p>In this chapter, you will learn the basics of concurrent programming. Some of Clojure's features, such as <strong class="bold">Software Transactional Memory</strong> (<strong class="bold">STM</strong>), are mostly useful in large, complex systems. While we can't simulate all of that complexity in a single chapter, we will explore the basic concepts and tools that Clojure provides. To demonstrate the techniques and get you up to speed on concurrency, we'll use two different environments. On the JVM, you'll learn how to create threads that communicate with each other. In the browser, you'll learn how to coordinate events that occur in different parts of the web page. </p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor360"/>Concurrency in General</h1>
			<p>Modern computers use <strong class="bold">threads</strong> to distribute execution between multiple processor cores. There are many reasons for this, including the physics of microchip design and the need for user environments that remain responsive even when one program is performing an intensive computation in the background. Everyone wants to be able to check their email, listen to music, and run their Clojure REPL at the same time! Inside a program, this kind of multitasking can also represent a significant performance gain. While one thread is waiting for data from the disk drive, another for the network, two other threads can be processing data. When done correctly, this can represent a significant gain in performance and overall efficiency. The operative phrase here, though, is "when done correctly." Concurrency can be tricky.</p>
			<p>Most computer code is written in a linear manner: do this, do that, then do this. The source code for a method or a function reads from top to bottom. We think about code linearly when we are writing it. In a multithreaded system, that's not how your code will be executed. Some parts of your program will run in one thread, and other parts in other threads, simultaneously. Coordination becomes a new problem. Experience shows that multithreaded applications are harder to write and tend to be more error-prone than single-threaded applications. Most of all, they are harder for us to understand. So, while there is a potential for better performance, there is also a potential for greater complexity. Like many aspects of programming, it's all about trade-offs.</p>
			<p>Clojure's most important concurrency feature is actually one that you've been using from the beginning: immutability. Clojure's immutable data types provide a special kind of protection throughout your system. Values are locked down once and for all; if a separate thread needs to "modify" your data, it will actually use an efficient copy that won't interfere with the other threads. And because this feature is a fundamental part of the Clojure language, you get it for "free": data is immutable by default, so there is no extra procedure to prepare it for concurrency. </p>
			<p>When a new thread is created, we say that the current thread has been forked. The parent thread shares its state with the new thread but loses control of the execution flow. Let's take a look at how things can go wrong when values are mutable:</p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B14502_12_01.jpg" alt="Figure 12.1: Shared state in a language with mutable data structures can lead to problems&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: Shared state in a language with mutable data structures can lead to problems</p>
			<p>In this diagram, we can see a main thread that creates a fork. In the original thread, the variable, <strong class="source-inline">x</strong>, is an array: <strong class="source-inline">[5, 3, 7]</strong>. The fork then modifies the array. Because it is shared between the two threads, the array is also modified in the main thread. From the point of view of the main thread, the value of <strong class="source-inline">x</strong> seems to change suddenly for no reason, as if modified by some external force. This is an oversimplification, of course, since languages such as Java do allow programmers to protect themselves from problems like this. However, shared mutable state does create a risk of this kind of problem.</p>
			<p>Immutability in Clojure largely solves this part of the problem. Here's a similar diagram representing a Clojure version of the same thing:</p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B14502_12_02.jpg" alt="Figure 12.2: Clojure's immutable data structures are never modified: changes create new &#13;&#10;versions of the data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Clojure's immutable data structures are never modified: changes create new versions of the data</p>
			<h2 id="_idParaDest-269">Au<a id="_idTextAnchor361"/>tomatic Parallelization with pmap</h2>
			<p>Nearly every kind of concurrency involves some additional complexity for the programmer. There is an exception to this rule though: Clojure's <strong class="source-inline">pmap</strong> function. The name is the abbreviation of <strong class="bold">parallel map</strong>. Just like <strong class="source-inline">map</strong>, <strong class="source-inline">pmap</strong> calls a function on each item in a list. The difference is that each function call runs on a separate thread so that some of the calculations can be run simultaneously.</p>
			<p>In this diagram, we map an imaginary function, <strong class="source-inline">pfn</strong>, over a simple vector. For each item, <strong class="source-inline">pmap</strong> calls <strong class="source-inline">pfn</strong> in a new thread:</p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B14502_12_03.jpg" alt="Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously</p>
			<p>This might seem like great news. In certain cases, it might be. But if you're thinking "I'll use <strong class="source-inline">pmap</strong> all the time and my program will run faster," you'll be disappointed most of the time. The problem is that there is a lot of behind-the-scenes work that must occur for <strong class="source-inline">pmap</strong> to spawn new threads. It turns out that <strong class="source-inline">pmap</strong> is only more efficient than the single-threaded <strong class="source-inline">map</strong> function when the calculation is particularly time-consuming. We can compare the relative speed of <strong class="source-inline">map</strong> and <strong class="source-inline">pmap</strong> on a trivial <strong class="source-inline">map</strong> operation. We'll use Clojure's <strong class="source-inline">time</strong> macro to compare execution times. The <strong class="source-inline">time</strong> macro wraps an expression, evaluates it normally, and prints out the time it took to evaluate:</p>
			<p class="source-code">user&gt; (time (doall (map inc (range 10))))</p>
			<p class="source-code">"Elapsed time: 0.081947 msecs"</p>
			<p class="source-code">(1 2 3 4 5 6 7 8 9 10)</p>
			<p class="source-code">user&gt; (time (doall (pmap inc (range 10))))</p>
			<p class="source-code">"Elapsed time: 2.288832 msecs"</p>
			<p class="source-code">(1 2 3 4 5 6 7 8 9 10)</p>
			<p>Incrementing 10 integers is not a resource-intensive task. With the ordinary <strong class="source-inline">map</strong> function, it takes less than a tenth of a microsecond. Performing the same operation with <strong class="source-inline">pmap</strong> takes almost 30 times longer! What took so long? Creating threads consumes resources. Obviously, <strong class="source-inline">pmap</strong> should only be used when it's clear that the additional overhead is worth it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We need to use <strong class="source-inline">doall</strong> here; otherwise, we would just be timing the speed of the creation of an unrealized lazy sequence.</p>
			<h2 id="_idParaDest-270">Exe<a id="_idTextAnchor362"/>rcise 12.01: Testing Randomness</h2>
			<p>Back on your job at the data journalism website, one of the analysts is concerned that the random number generator used in your programs is not random enough. She wants you to test it by generating a very long sequence of random integers and then checking a few numbers to see whether they are equally represented. In doing this, you'll be able to see whether it's faster to use <strong class="source-inline">map</strong> or <strong class="source-inline">pmap</strong> thanks to Clojure's <strong class="source-inline">time</strong> function.</p>
			<p>Open a <strong class="source-inline">REPL</strong>. This is a one-off test, so there's no need to create a project:</p>
			<ol>
				<li>Generate a very long sequence of integers between <strong class="source-inline">0</strong> and <strong class="source-inline">1000</strong>:<p class="source-code">user&gt; (def random-ints (doall (take 10000000 (repeatedly </p><p class="source-code"> (partial rand-int 1000)))))</p><p class="source-code">#'user/random-ints</p><p>Note that we use <strong class="source-inline">doall</strong> to make sure that the lazy sequence returned by <strong class="source-inline">repeatedly</strong> is fully realized.</p></li>
				<li>Define a function that counts the number of occurrences of an integer in a list:<p class="source-code">user&gt; (defn int-count [i xs]</p><p class="source-code">    (count (filter #(= % i) xs)))</p><p class="source-code">#'user/int-count</p></li>
				<li>Use <strong class="source-inline">map</strong> to count the number of occurrences of some integers in <strong class="source-inline">random-ints</strong>:<p class="source-code">user&gt; (map #(int-count % random-ints) [0 1 2 45 788 500 999 ])</p><p class="source-code">(1034 1009 971 1094 968 1029 908)</p></li>
				<li>This seems to work, but it is fairly slow. To discover how slow it is, we can use Clojure's <strong class="source-inline">time</strong> function to provide a quick benchmark. Don't forget to wrap the output from <strong class="source-inline">map</strong> in <strong class="source-inline">doall</strong>. Otherwise, you're just timing the creation of an unrealized lazy sequence:<p class="source-code">(time (doall (map #(int-count % random-ints) [0 1 2 45 788 500 </p><p class="source-code"> 999])))</p><p class="source-code">"Elapsed time: 7307.28571 msecs"</p><p class="source-code">(9808 10027 9825 10090 9963 10096 9984)</p><p>Your time will be longer or shorter, of course.</p></li>
				<li>Now try using <strong class="source-inline">pmap</strong> instead:<p class="source-code">user&gt; (time (doall (pmap #(int-count % random-ints) [0 1 2 45 </p><p class="source-code"> 788 500 999])))</p><p class="source-code">"Elapsed time: 1602.424627 msecs"</p><p class="source-code">(9808 10027 9825 10090 9963 10096 9984)</p><p>That's a lot faster! This is good in case the analyst asks for an even bigger sample size.</p></li>
			</ol>
			<p>In this example, <strong class="source-inline">pmap</strong> came to the rescue and sped things up significantly. The beauty of <strong class="source-inline">pmap</strong> is that no extra coding is necessary. It's simple enough to write <strong class="source-inline">pmap</strong> instead of <strong class="source-inline">map</strong>. However, like many tools, the most important part is knowing when not to use it. This example was particularly well suited for parallelization because of the large size of the dataset. <strong class="source-inline">pmap</strong> should only be used in situations where you know that the calculation will generally be slow.</p>
			<h1 id="_idParaDest-271">Fut<a id="_idTextAnchor363"/>ures</h1>
			<p>With <strong class="source-inline">pmap</strong>, Clojure takes care of all the thread management for you, which makes things easy. A lot of times, however, you need more control over your threads than what <strong class="source-inline">pmap</strong> provides. Clojure's <strong class="bold">futures</strong> do just this. They are a mechanism for spawning and waiting for new threads.</p>
			<p>Consider a situation where two expensive calculations are needed to perform a third operation, such as adding the two results together. In a single-threaded context, we would just write this:</p>
			<p class="source-code">(+ (expensive-calc-1 5) (expensive-calc-2 19))</p>
			<p>Written this way, the call to <strong class="source-inline">expensive-calc-1</strong> needs to complete before <strong class="source-inline">expensive-calc-2</strong> can start. If the calculations could be run in parallel, we would cut the execution time nearly in half, in the best cases. Running the two threads in parallel creates some new problems, though. We need a way of coordinating the return values, especially since we don't know whether <strong class="source-inline">expensive-calc-1</strong> or <strong class="source-inline">expensive-calc-2</strong> will complete first. We need a way to wait for both before calling <strong class="source-inline">+</strong>.</p>
			<p>Futures are designed for this type of situation. The <strong class="source-inline">future</strong> macro causes the code it contains to be run in a separate thread. It immediately returns a placeholder, which is a reference to the <em class="italic">future</em> result. When the code in the new thread has completed, the placeholder can be <strong class="bold">dereferenced</strong>. </p>
			<p>In Clojure, dereferencing applies when a value is not immediately available and can only be accessed by taking an additional step. With a var or a let binding, the value is immediately available. There is no extra step to take. We just use it. With a future, as well as with reference types that we'll see later in the chapter, we don't know whether the value is available yet. Using the <strong class="source-inline">deref</strong> function with a future means that we are willing to wait for it to complete. <strong class="source-inline">deref</strong> is necessary because we need a way to indicate this special behavior. To make your code easier to read (and type), instead of writing <strong class="source-inline">(deref my-future)</strong>, you can just type <strong class="source-inline">@my-future</strong>. This is an example of a reader macro: Clojure immediately translates <strong class="source-inline">@my-future</strong> into <strong class="source-inline">(deref my-future)</strong> when it reads your code.</p>
			<p>With this in mind, we can rewrite the preceding expression. First, though, we'll define an artificially slow function using the Java <strong class="source-inline">Thread/sleep</strong> method:</p>
			<p class="source-code">user&gt; (defn expensive-calc-1 [i]</p>
			<p class="source-code">    (Thread/sleep (+ 500 (rand 1000)))</p>
			<p class="source-code">    (println "Calc 1")</p>
			<p class="source-code">    (+ i 5))</p>
			<p class="source-code">user&gt; (defn expensive-calc-2 [i]</p>
			<p class="source-code">    (Thread/sleep (+ 500 (rand 1000)))</p>
			<p class="source-code">    (println "Calc 2")</p>
			<p class="source-code">    (+ i 5))</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">Thread/sleep</strong> method is a convenient piece of Java interop that is useful for simulating long-running computations or input/output operations that take time. While it's good for experimenting, you rarely need it in production code.</p>
			<p>With these functions, the original expression evaluates them one after the other:</p>
			<p class="source-code">user&gt; (+ (expensive-calc-1 10) (expensive-calc-2 25))</p>
			<p class="source-code">Calc 1</p>
			<p class="source-code">Calc 2</p>
			<p class="source-code">45</p>
			<p>No matter how many times this function is run, <strong class="source-inline">expensive-calc-1</strong> will always return before <strong class="source-inline">expensive-calc-2</strong>. With futures, this will change:</p>
			<p class="source-code">user&gt; (let [c1 (future (expensive-calc-1 10))</p>
			<p class="source-code">      c2 (future (expensive-calc-2 20))]</p>
			<p class="source-code">    (+ (deref c1) (deref c2)))</p>
			<p class="source-code">Calc 2</p>
			<p class="source-code">Calc 1</p>
			<p class="source-code">40</p>
			<p class="source-code">user&gt; (let [c1 (future (expensive-calc-1 10))</p>
			<p class="source-code">      c2 (future (expensive-calc-2 20))]</p>
			<p class="source-code">    (+ (deref c1) (deref c2)))</p>
			<p class="source-code">Calc 1</p>
			<p class="source-code">Calc 2</p>
			<p class="source-code">40</p>
			<p>First of all, you'll probably notice that this version is slightly faster. Sometimes <strong class="source-inline">expensive-calc-1</strong> returns first, sometimes <strong class="source-inline">expensive-calc-2</strong> wins the race. It doesn't matter which one is faster: the final addition only happens when both are complete. This is the work of the <strong class="source-inline">deref</strong> function, which blocks the evaluation until the computation started by the corresponding call to <strong class="source-inline">future</strong> has returned.</p>
			<p>The <strong class="source-inline">(deref c1)</strong> or <strong class="source-inline">(deref c2)</strong> expressions can be replaced with <strong class="source-inline">@c1</strong> or <strong class="source-inline">@c2</strong>, thanks to the <strong class="source-inline">@</strong> reader macro.</p>
			<h2 id="_idParaDest-272">Exe<a id="_idTextAnchor364"/>rcise 12.02: A Crowdsourced Spellchecker</h2>
			<p>Have you ever typed a word into a search engine just to see whether you've spelled it correctly? In this exercise, we'll build a command-line tool that improves on this way of using the internet to verify spellings.</p>
			<p>The goal is to be able to write out a command followed by several possible spellings for a word. The spelling tool will then query Wikipedia and return the word that received the most hits. We will use futures so that the different search queries can be run in parallel.</p>
			<ol>
				<li value="1">Use Leiningen to create a new project using the <strong class="source-inline">app</strong> template. You can call it whatever you want. We'll use <strong class="source-inline">packt-clj.crowdspell</strong> in our examples:<p class="source-code">lein new app packt-clj.crowdspell</p></li>
				<li>Go to the new directory that Leiningen created and modify the dependencies in the <strong class="source-inline">project.clj</strong> file. We'll need three libraries: <strong class="source-inline">org.clojure/tools.cli</strong> for accepting user input, <strong class="source-inline">clj-http</strong> for making HTTP requests, and <strong class="source-inline">org.clojure/data.json</strong>.<p>The <strong class="source-inline">:dependencies</strong> map should look like this:</p><p class="source-code">:dependencies [[org.clojure/clojure "1.10.1"]</p><p class="source-code">               [org.clojure/tools.cli "0.4.2"]</p><p class="source-code">               [clj-http "3.10.0"]</p><p class="source-code">               [org.clojure/data.json "0.2.6"]]</p></li>
				<li>In the <strong class="source-inline">src/packt_clj/</strong> directory, create a <strong class="source-inline">crowdspell</strong> directory. We'll use this directory for any namespaces we need to create for the project. Create a file there called <strong class="source-inline">fetch.clj</strong> and insert the following namespace definition:<p class="source-code">(ns packt-clj.crowdspell.fetch</p><p class="source-code">  (:require [clj-http.client :as http]</p><p class="source-code">            [clojure.data.json :as json]))</p><p>All of the fetching and parsing of results will happen in this namespace. The <strong class="source-inline">clj-http</strong> library will help us to perform our web requests to the Wikipedia endpoint and <strong class="source-inline">clojure.data.json</strong> will help us to parse the JSON data that we get back.</p></li>
				<li>While you're there, create an empty function definition for <strong class="source-inline">get-best-word</strong>. This will be the key interface of the application: given a list of words, <strong class="source-inline">get-best-word</strong> will return the best one based on the data retrieved from Wikipedia. All we know at this point is that it takes a language code and a list of words as an argument:<p class="source-code">(defn get-best-word [language-code words])</p><p>Because Wikipedia uses a separate URL for each language, such as <a href="https://ja.wikipedia.org/">https://ja.wikipedia.org/</a> or https://en.wikipedia.org/, we can use the language code parameter to internationalize our app.</p></li>
				<li>The <strong class="source-inline">packt-clj/crowdspell</strong> namespace, defined in <strong class="source-inline">src/packt_clj/crowdspell.clj</strong>, will be the entry point into the application. There should already be a <strong class="source-inline">-main</strong> function there, created using the <strong class="source-inline">lein new </strong>command.<p>Modify the <strong class="source-inline">-main</strong> function so that it calls <strong class="source-inline">get-best-word</strong>. This will also require updating the namespace declaration so that you'll have access to <strong class="source-inline">clojure.tools.cli</strong> and <strong class="source-inline">packt-clj.crowdspell.fetch</strong>.</p><p>The namespace declaration should now look like this:</p><p class="source-code">(ns packt-clj.crowdspell</p><p class="source-code"> (:require</p><p class="source-code">  [clojure.tools.cli :as cli]</p><p class="source-code">  [packt-clj.crowdspell.fetch :as fetch])</p><p class="source-code"> (:gen-class))</p><p>The <strong class="source-inline">-main</strong> function should look like this:</p><p class="source-code">(defn -main</p><p class="source-code"> [&amp; args]</p><p class="source-code"> (println (fetch/get-best-word "en" args)))</p><p>For now, we'll just hardcode English as the language code. At this point, the application would theoretically compile and run at the command line but would not do anything.</p></li>
				<li>Back in <strong class="source-inline">src/packt_clj/crowdspell/fetch.clj</strong>, write a skeleton for a <strong class="source-inline">word-search</strong> function. This function will search for a single word. The <strong class="source-inline">get-best-word</strong> function will coordinate several concurrent HTTP requests using futures. Each request will be run with <strong class="source-inline">word-search</strong>:<p class="source-code">(defn word-search [word language-code]</p><p class="source-code"> (try</p><p class="source-code">  ;; TODO: the HTTP request</p><p class="source-code">  (catch Exception e</p><p class="source-code">   {:status :error})))</p><p>There's a <strong class="source-inline">language-code</strong> parameter because we want our application to be multilingual. We'll add that as a command-line parameter later.</p><p>We want to use a <strong class="source-inline">try</strong> block here since our request might fail for any number of reasons. We've already made a design decision: the function will return a map containing, among other things, a <strong class="source-inline">:status</strong> code.</p></li>
				<li>Now it's time to write the HTTP request itself. The <strong class="source-inline">clj-http.client</strong> library makes this fairly painless. We just have to make sure that we use the proper Wikipedia-specific parameters: <strong class="source-inline">srsearch</strong> is our search term, and <strong class="source-inline">srlimit</strong> tells the API that we only want one item. Only one item is necessary because the metadata in the response includes a field indicating how many total items were found. Since we are only interested in counting them, this is all we need. You can try the request in the REPL first if you like:<p class="source-code">packt-clj.crowdspell.fetch&gt; (http/get (str "https://en.wikipedia.org/w/api.php")</p><p class="source-code">                {:query-params {"action" "query"</p><p class="source-code">                        "list" "search"</p><p class="source-code">                        "srlimit" 1</p><p class="source-code">                        "srsearch" "Clojure"</p><p class="source-code">                        "format" "json"}</p><p class="source-code">                 :accept :json</p><p class="source-code">                 :cookie-policy :none})</p><p>If all goes well, a map containing HTTP response, including all the headers, should fill your REPL. You should find a key that says <strong class="source-inline">:status 200</strong>, which means that the request was successful. Any status besides <strong class="source-inline">200</strong> means that something is wrong:</p><div id="_idContainer243" class="IMG---Figure"><img src="image/B14502_12_04.jpg" alt="Figure 12.4: REPL output of a successful HTTP request&#13;&#10;"/></div><p class="figure-caption">Figure 12.4: REPL output of a successful HTTP request</p></li>
				<li>Let's add this request as a <strong class="source-inline">let</strong> binding inside the <strong class="source-inline">try</strong> block. The only change needed is to insert the two parameters: the word we're searching for and the language. Start by making a <strong class="source-inline">let</strong> binding from the result of the HTTP request to the Wikipedia endpoint. We will need the entire request later:<p class="source-code">(defn word-search [word language-code]</p><p class="source-code"> (try</p><p class="source-code">  (let [http-result (http/get (str "https://" language-code ".wikipedia.org/w/api.php")</p><p class="source-code">                {:query-params {"action" "query"</p><p class="source-code">                        "list" "search"</p><p class="source-code">                        "srlimit" 1</p><p class="source-code">                        "srsearch" word</p><p class="source-code">                        "format" "json"}</p><p class="source-code">                 :accept :json</p><p class="source-code">                 :cookie-policy :none})]</p><p class="source-code">   ;; TODO: do something with the result</p><p class="source-code">   {:status :ok :total-hits total-hits :word word})</p><p class="source-code">  (catch Exception e</p><p class="source-code">   {:status :error})))</p></li>
				<li>Now we just need to interpret the result of the HTTP request. There are really two steps: first, convert the raw JSON response into a Clojure map, then extract the data we're looking for. The Wikipedia API provides a <strong class="source-inline">totalhits</strong> field that we can use to decide which word is the most popular. We can combine these two steps into a brief code snippet:<p class="source-code">(-&gt; (json/read-str (:body http-result) :key-fn keyword)</p><p class="source-code">  (get-in [:query :searchinfo :totalhits]))</p><p>The <strong class="source-inline">json/read-str</strong> does just that: it reads the body of the response and converts it into a map. The <strong class="source-inline">:key-fn</strong> option allows us to provide a function that will be called on all the keys. In nearly all cases, the <strong class="source-inline">keyword</strong> function is used here so that we can have the convenience of Clojure keywords.</p><p>All that's left is to grab the one piece of data that we need. The result map is a large, multiple-nested map, which is not a problem for <strong class="source-inline">get-in</strong>.</p></li>
				<li>Once we have the number of hits, we wrap all the data we'll need for later in a map: the status, the number of hits, and the word itself:<p class="source-code">{:status :ok :total-hits total-hits :word word}</p><p>We know the word from the original argument supplied to the function. We also know that the status is <strong class="source-inline">:ok</strong>: if the query resulted in an error, we would be in the catch <strong class="source-inline">block</strong> instead.</p><p>The final function looks like this:</p><p class="source-code">(defn word-search [word language-code]</p><p class="source-code"> (try</p><p class="source-code">  (let [http-result (http/get (str "https://" language-code ".wikipedia.org/w/api.php")</p><p class="source-code">                {:query-params {"action" "query"</p><p class="source-code">                        "list" "search"</p><p class="source-code">                        "srlimit" 1</p><p class="source-code">                        "srsearch" word</p><p class="source-code">                        "format" "json"}</p><p class="source-code">                 :accept :json</p><p class="source-code">                 :cookie-policy :none})</p><p class="source-code">     total-hits (-&gt; (json/read-str (:body http-result) :key-fn keyword)</p><p class="source-code">             (get-in [:query :searchinfo :totalhits]))]</p><p class="source-code">   {:status :ok :total-hits total-hits :word word})</p><p class="source-code">  (catch Exception e</p><p class="source-code">   {:status :error})))</p><p>If you test <strong class="source-inline">word-search</strong> in the REPL, you should see something like this:</p><div id="_idContainer244" class="IMG---Figure"><img src="image/B14502_12_05.jpg" alt="Figure 12.5: The important data extracted from the HTTP request&#13;&#10;"/></div><p class="figure-caption">Figure 12.5: The important data extracted from the HTTP request</p></li>
				<li>Now we turn to <strong class="source-inline">get-best-word</strong>. Its job is to make parallel calls to <strong class="source-inline">word-search</strong>. Futures are exactly what we need for that. Since the words are supplied as a list, the first step will be to call <strong class="source-inline">word-search</strong> inside a future for each of the words. This is remarkably straightforward:<p class="source-code">(defn get-best-word</p><p class="source-code"> [language-code words]</p><p class="source-code"> (let [results (map (fn [a] [a (future (word-search a language-code))]) words)]</p><p class="source-code">  ;; TODO: decide which word is the best</p><p class="source-code">  ))</p><p>The HTTP requests will run simultaneously and the responses become available as they complete. This expression will return a list of futures. We will need to dereference them before we can use them. Except for that difference, we can look at <strong class="source-inline">results</strong> as though it were a list of ordinary values. Clojure's <strong class="source-inline">future</strong> and <strong class="source-inline">deref</strong> function manage the asynchronicity for us.</p></li>
				<li>The final step here will be to select the word with the most hits. We'll use <strong class="source-inline">reduce</strong> with a pattern we introduced in <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>:<p class="source-code">(reduce (fn [best-so-far [word result-future]]</p><p class="source-code">     (let [{:keys [status total-hits] :as result} @result-future]</p><p class="source-code">      (if (= status :ok)</p><p class="source-code">       (if (&gt; total-hits (:total-hits best-so-far))</p><p class="source-code">        result</p><p class="source-code">        best-so-far)</p><p class="source-code">       best-so-far)))</p><p class="source-code">    {:total-hits 0}</p><p class="source-code">    results)</p><p>Obviously, dereferencing <strong class="source-inline">@result-future</strong> here is the first very important step. But once the value is dereferenced, all the data is available, and we can forget all about its asynchronous past.</p><p>The rest of the call to <strong class="source-inline">reduce</strong> follows the familiar pattern: we check whether the current item has a better score than <strong class="source-inline">best-so-far</strong>, and if so, it replaces <strong class="source-inline">best-so-far</strong>.</p><p>To make a very polished app, we would want to warn the user in case there were errors, but, for now, it will suffice to simply ignore the failed requests.</p></li>
				<li>Once we've found the best word, all that's left is to extract the <strong class="source-inline">:word</strong> key from the best word. For that, we'll use a threading macro, <strong class="source-inline">-&gt;</strong>, and <strong class="source-inline">:word</strong>. Altogether, that leaves us with this function:<p class="source-code">(defn get-best-word</p><p class="source-code"> [language-code words]</p><p class="source-code"> (let [results (map (fn [a] [a (future (word-search a language-code))]) words)]</p><p class="source-code">  (-&gt;</p><p class="source-code">   (reduce (fn [best-so-far [word result-future]]</p><p class="source-code">        (let [{:keys [status total-hits] :as result} @result-future]</p><p class="source-code">         (if (= status :ok)</p><p class="source-code">          (if (&gt; total-hits (:total-hits best-so-far))</p><p class="source-code">           result</p><p class="source-code">           best-so-far)</p><p class="source-code">          best-so-far)))</p><p class="source-code">       {:total-hits 0}</p><p class="source-code">       results)</p><p class="source-code">   :word)))</p></li>
				<li>Test <strong class="source-inline">get-best-word</strong> in the REPL with some really bad spellings of "Clojure" alongside the correct one:<p class="source-code">packt-clj.crowdspell.fetch&gt; (get-best-word "en" ["Fortran" "Pascal"])</p><p class="source-code">"Pascal"</p><p class="source-code">packt-clj.crowdspell.fetch&gt; (get-best-word "en" ["Clojur" "Clojure" "Clojrre"])</p><p class="source-code">"Clojure"</p><p>It seems to work!</p></li>
				<li>To make this into a useful application, we still need to package this behavior into a command-line utility. The <strong class="source-inline">-main</strong> function back in <strong class="source-inline">src/packt_clj/crowdspell.clj </strong>is almost ready, except that the language code parameter is still just hardcoded as <strong class="source-inline">en</strong>.<p>The <strong class="source-inline">clojure.tools.cli</strong> library will make it easy to add the language code as an optional parameter at the command line. The goal is to be able to compile our code to an uberjar and then type this:</p><p class="source-code">java -jar packt-clj.crowdspell-0.1.0-SNAPSHOT-standalone.jar --language en Clojur Clojure Clojrre</p></li>
				<li>The <strong class="source-inline">clojure.tools.cli/parse-opts</strong> function takes the <strong class="source-inline">args</strong> value from <strong class="source-inline">-main</strong> and a list of argument prefix descriptors. The best way to understand this is with an example, like our language code option:<p class="source-code">(cli/parse-opts</p><p class="source-code">         args</p><p class="source-code">         [["-l" "--language LANG" "Two-letter language code for search"</p><p class="source-code">          :default "en"]])</p><p>The nested vector is the configuration argument to <strong class="source-inline">parse-opts</strong>. <strong class="source-inline">"-l"</strong> and <strong class="source-inline">"--language LANG"</strong> define the short and long form of the command-line option. Remember that the long form of the option will be used, in keyword form, as the name of the argument in the nested <strong class="source-inline">:options</strong> map that <strong class="source-inline">parse-opts</strong> returns.</p><p>The next string is a documentation string that will be displayed if there is an error, for example, an unknown option prefix.</p><p>After these first three items, there can be additional keyword-tagged parameters. There are a lot of possibilities here that we won't explore. <strong class="source-inline">:default</strong> is enough for our purposes here. If the user doesn't supply a <strong class="source-inline">--language</strong> option (or the shorter <strong class="source-inline">-l</strong> option), they will get results from the English-language Wikipedia output.</p></li>
				<li>To test the configuration of the command-line options, there's no need to actually use the command line. <strong class="source-inline">parse-opts</strong> can be run in the <strong class="source-inline">REPL</strong> with a list of strings masquerading as command-line arguments:<p class="source-code">packt-clj.crowdspell&gt; (cli/parse-opts ["--language" "fr" "Cloj" "Clojure"] [["-l" "--language LANG" "Language code for search"]])</p><p class="source-code">{:options {:language "fr"},</p><p class="source-code"> :arguments ["Cloj" "Clojure"],</p><p class="source-code"> :summary " -l, --language LANG Language code for search",</p><p class="source-code"> :errors nil}</p></li>
				<li>This is useful because it shows us the structure of the map that is returned. To finalize the <strong class="source-inline">-main</strong> function, we just need to know how to extract the language option and the arguments from the map:<p class="source-code">(defn -main</p><p class="source-code"> [&amp; args]</p><p class="source-code"> (let [parsed (cli/parse-opts</p><p class="source-code">         args</p><p class="source-code">         [["-l" "--language LANG" "Two-letter language code for search"</p><p class="source-code">          :default "en"]])]</p><p class="source-code">  (fetch/get-best-word (get-in parsed [:options :language])</p><p class="source-code">             (:arguments parsed))))</p><p class="source-code">             (System/exit))))</p><p>The call to <strong class="source-inline">System/exit</strong> guarantees that our program will exit immediately. Because we used <strong class="source-inline">future</strong>, the program otherwise would not exit until the threads created by <strong class="source-inline">future</strong> had terminated entirely.</p><p>And that should be all the code we need.</p></li>
				<li>Before compiling, we can test our code in the <strong class="source-inline">REPL</strong> by simulating the command-line arguments in a list:<p class="source-code">packt-clj.crowdspell&gt; (-main "-l" "en" "Klojure" "Cloojure" "Clojure")</p><p class="source-code">"Clojure"</p></li>
				<li>To compile, simply run <strong class="source-inline">lein uberjar</strong> in the root directory of the project. Now we can finally test the entire application:<p class="source-code">$ java -jar target/uberjar/packt-clj.crowdspell-0.1.0-SNAPSHOT-standalone.jar --language en Clojur Clojure Clojrre</p><p class="source-code">Clojure</p></li>
			</ol>
			<p>All right, it works. But it's slow. Yes, the Java runtime takes a few seconds to get started and it's a problem for something that should be a fast, easy-to-use app. It's best to consider this version as a proof of concept. A ClojureScript version based on Node.js would have a much shorter startup time. Or this could be built as a web service. You'll learn about building an application server in <em class="italic">Chapter 14</em>, <em class="italic">HTTP with Ring</em>. For now, the fastest and easiest approach would be to use <strong class="source-inline">fetch.clj</strong> directly in the REPL, although this requirement might limit the number of potential customers.</p>
			<p>In this exercise, we learned how to write a simple multithreaded application using Clojure futures. Futures are particularly well suited for situations where discreet tasks can be handed off to separate threads. Even more importantly, <strong class="source-inline">future</strong>, with <strong class="source-inline">deref</strong>, provides a way to coordinate the data as it returns from the separate threads.</p>
			<h1 id="_idParaDest-273">Coord<a id="_idTextAnchor365"/>ination</h1>
			<p>Futures work well for cases like the <strong class="source-inline">crowdspell</strong> example. Work is assigned to a thread; the thread performs its task independently and returns a result to the initial thread. The coordination is in the gathering of the results: evaluation is blocked until all the futures have completed. Thanks to immutability, there is a guarantee that simultaneous threads won't interfere with each other because nothing is shared.</p>
			<p>This simple model is effective precisely because it is simple. Sometimes, however, more coordination is necessary, especially when communication between threads is required.</p>
			<p>With a future, we fork, perform a computation, and return the data:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B14502_12_06.jpg" alt="Figure 12.6: With a future, coordination occurs when the future is dereferenced&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6: With a future, coordination occurs when the future is dereferenced</p>
			<p>Message sending is one way to communicate among threads. Now, we imagine three threads that send messages to one another:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B14502_12_07.jpg" alt="Figure 12.7: Complex interactions between multiple threads&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7: Complex interactions between multiple threads</p>
			<p>To implement a communication model like this in Clojure, you could also use the <strong class="source-inline">core.async</strong> library, which is a sophisticated tool for creating channels between threads. The <strong class="source-inline">core.async</strong> library is widely used but would require its own chapter to cover it correctly:</p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/B14502_12_08.jpg" alt="Figure 12.8: Threads referring to and modifying shared data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: Threads referring to and modifying shared data</p>
			<p>The fundamental challenge of concurrent programming stems from the fact that the timeline of a program is no longer linear. Threads in communication with each other do not know when they will receive new data or when the data they've sent will be processed on the receiving end. Unless the communication is carefully managed, accidents happen. If two threads try to update the same data simultaneously without coordination, the results become unpredictable. One update overwrites another. While a value is being updated, the original value is modified, and the update is suddenly obsolete. If more threads are involved, the interactions (and the possibilities for errors) are multiplied. In the <strong class="source-inline">crowdspell</strong> exercise, the futures coordinated the return value from the different threads. Instead of clobbering each other's data, the results were assembled into a coherent list that the rest of the program could use.</p>
			<p>Clojure has several <strong class="source-inline">reference types</strong>: vars, atoms, agents, and refs. Before talking about each one separately, it might be good to think about what a <em class="italic">reference type</em> actually is. First of all, a reference type is not a data structure. In fact, you can use any of Clojure's data structures with any of these reference types. Instead, a reference type sits between your code and your data and provides a particular way of referring to your data. </p>
			<p>It might help to visualize this relationship. The reference type as an interface allows your code to apply changes to the data and retrieve the current state of the data. Remember, the values that the reference type points to are still the familiar Clojure data types: integers, strings, vectors, maps, and so on:</p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/B14502_12_09.jpg" alt="Figure 12.9: Reference type: a way of referring to and interacting with a piece of data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9: Reference type: a way of referring to and interacting with a piece of data</p>
			<p>Most of the time, when coding in Clojure, we don't think about the difference between the name of a thing and thing itself. Consider this simple <strong class="source-inline">let</strong> binding:</p>
			<p class="source-code">(let [some-numbers [3 12 -1 55]]</p>
			<p class="source-code"> ;; TODO: do something</p>
			<p class="source-code"> )</p>
			<p>What is <strong class="source-inline">some-numbers</strong>? Usually, we just say, or think, "it's a vector." Of course, it's really a symbol that points at a vector. The fact that it's in a <strong class="source-inline">let</strong> binding means that <strong class="source-inline">some-numbers</strong> will only point at <strong class="source-inline">[3 12 -1 55]</strong> inside that particular <strong class="source-inline">let</strong> expression. In other words, <strong class="source-inline">let</strong> defines a particular kind of pointing.</p>
			<p>Now consider this <strong class="source-inline">let</strong> binding:</p>
			<p class="source-code">(let [some-atomic-numbers (atom [3 12 -1 55])]</p>
			<p class="source-code"> ;; TODO: do something with an atom</p>
			<p class="source-code"> )</p>
			<p>This time, <strong class="source-inline">some-atomic-numbers</strong> is still just a symbol. It points at an atom (we'll explain what that means in a second), and the atom points at the vector:</p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/B14502_12_10.jpg" alt="Figure 12.10: The binding points at the atom, and the atom points at the value&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.10: The binding points at the atom, and the atom points at the value</p>
			<p>Immutability means that values don't change. An integer remains an integer, and a vector remains equal to itself. Immutability does not mean that a symbol always points at the same value, though. Clojure's reference types are a way to manage certain kinds of change while continuing to use immutable data.</p>
			<p>One of the reference types is already very familiar to you by now: the var, which, among other roles, is how Clojure identifies functions. Up until now, we've treated the var as an immutable identity, and, for the most part, this is accurate. Generally, if you see <strong class="source-inline">(def x 5)</strong> in a program, that means that the value of <strong class="source-inline">x</strong> will not change.</p>
			<p>However, at the REPL, you will quickly find that you can indeed redefine a var simply by calling <strong class="source-inline">def</strong> again:</p>
			<p class="source-code">user&gt; (def x 5)</p>
			<p class="source-code">#'user/x</p>
			<p class="source-code">user&gt; x</p>
			<p class="source-code">5</p>
			<p class="source-code">user&gt; (def x 6)</p>
			<p class="source-code">#'user/x</p>
			<p class="source-code">user&gt; x</p>
			<p class="source-code">6</p>
			<p>While this is fine when experimenting with the REPL, clobbering a var like this in a program would be extremely unusual. That said, the var reference type does provide the <strong class="source-inline">alter-var-root</strong> function, which is a more graceful way to update a var. It takes a function and updates the value:</p>
			<p class="source-code">user&gt; (def the-var 55)</p>
			<p class="source-code">#'user/the-var</p>
			<p class="source-code">user&gt; (alter-var-root #'the-var #(+ % 15))</p>
			<p class="source-code">70</p>
			<p>If you ever actually need to use this function, it will probably be to change some feature of your work environment. The point here is not to encourage you to start modifying vars, but rather to show how even vars have semantics for changing their values. <strong class="source-inline">Vars</strong> happen to be a reference type that strongly discourages change but does not prohibit it completely.</p>
			<p>The other reference types—atoms, agents, and refs—are designed to give you much finer control over how to manage change and they do this by controlling what they point at. In the preceding diagram, we showed a <strong class="source-inline">let</strong> binding, <strong class="source-inline">some-atomic-numbers</strong>, pointing at an atom containing a vector. Now we can complete the picture by showing how the atom might evolve as different functions are called on it:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B14502_12_11.jpg" alt="Figure 12.11: The atom points at different values over time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.11: The atom points at different values over time</p>
			<p>In this picture, the data (the vectors) is still immutable. The atom allows us to define some kind of identity that might have different values at different times. As we'll see, this turns out to be particularly useful in multithreaded programs, where one or more threads need to have access to stable identities in another thread.</p>
			<p>So, what are atoms, refs, and agents? Let's take a quick look at each of these reference types.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor366"/>Atoms</h2>
			<p>Atoms<a id="_idTextAnchor367"/> are the simplest and most commonly used reference type. They are also the only reference type that is currently available in ClojureScript, mostly due to the fact that the JavaScript runtime is single-threaded.</p>
			<p>The life-cycle of an atom starts with an initial definition of the data with the <strong class="source-inline">atom</strong> function:</p>
			<p class="source-code">user&gt; (def integer-atom (atom 5))</p>
			<p class="source-code">#'user/integer-atom</p>
			<p>Just with like <strong class="source-inline">future</strong>, the underlying data can be accessed with <strong class="source-inline">deref</strong> (or the <strong class="source-inline">@</strong> reader macro):</p>
			<p class="source-code">user&gt; (deref integer-atom)</p>
			<p class="source-code">5</p>
			<p>Changing the data is done with <strong class="source-inline">swap!</strong>, which updates the atom by applying the function you supply to the current value that the atom points to:</p>
			<p class="source-code">user&gt; (swap! integer-atom inc)</p>
			<p class="source-code">6</p>
			<p class="source-code">user&gt; (deref integer-atom)</p>
			<p class="source-code">6</p>
			<p>The <strong class="source-inline">swap!</strong> function doesn't assign a value to the atom. Instead, it applies a function. This way, if the value of the atom has changed since the last time we dereferenced it, the function will simply be applied to the new value, whatever it is.</p>
			<p>Let's see this in action. Here is the code we are going to execute in the REPL, once again using <strong class="source-inline">Thread/sleep</strong> to simulate some long-running task:</p>
			<p class="source-code">user&gt; (do</p>
			<p class="source-code">    (future (do (Thread/sleep 500) (swap! integer-atom + 500)))</p>
			<p class="source-code">    (future (swap! integer-atom * 1000))</p>
			<p class="source-code">    (deref integer-atom))</p>
			<p class="source-code">6000</p>
			<p>What's going on here? The first future waits half a second before calling <strong class="source-inline">swap!</strong>. The second future executes right away, multiplying the current value of the atom, <strong class="source-inline">6</strong>, by <strong class="source-inline">1000</strong>. Now try dereferencing <strong class="source-inline">integer-atom</strong> again:</p>
			<p class="source-code">user&gt; @integer-atom</p>
			<p class="source-code">6500</p>
			<p>If we change the timing by modifying the durations of the <strong class="source-inline">Thread/sleep</strong> calls, the results change too:</p>
			<p class="source-code">user&gt; (do</p>
			<p class="source-code">    (def integer-atom (atom 6))</p>
			<p class="source-code">    (future (swap! integer-atom + 500))</p>
			<p class="source-code">    (future (do (Thread/sleep 500) (swap! integer-atom * 1000)))</p>
			<p class="source-code">    (deref integer-atom))</p>
			<p class="source-code">506</p>
			<p class="source-code">user&gt; @integer-atom</p>
			<p class="source-code">506000</p>
			<p>When calling <strong class="source-inline">swap!</strong>, you can't be sure ahead of time what the value of the atom will be. But you know that your function will be called on whatever the value happens to be at that point in time.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is also a more rarely used <strong class="source-inline">compare-and-set!</strong> function that provides finer grained control. It takes an additional value, usually the current value of the atom, and will only modify the atom if it still matches that. In other words, if another thread has already done something to your atom, <strong class="source-inline">compare-and-set!</strong> will leave it alone.</p>
			<h2 id="_idParaDest-275">Concept: Re<a id="_idTextAnchor368"/>tries</h2>
			<p>Changes to an atom are not instantaneous. Remember, we're sending a function to the atom. Depending on the work being done, some functions may take more time to complete. In a busy environment, it might mean that several threads try to make changes to an atom at the same time.</p>
			<p>The following diagram shows a naïve implementation of an atom being modified by two threads, <strong class="source-inline">Thread A</strong> and <strong class="source-inline">Thread B</strong>. Even though they are just multiplying the value of the atom by 3 or by 4, let's imagine that this operation takes a few milliseconds:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B14502_12_12.jpg" alt="Figure 12.12: Overlapping updates to a naive implementation of a Clojure atom&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: Overlapping updates to a naive implementation of a Clojure atom</p>
			<p>The initial value of the atom is 5. Then <strong class="source-inline">Thread A</strong> intervenes to multiply by 3. As it is starting to perform its operation, <strong class="source-inline">Thread B</strong> starts as well. The input to the function of <strong class="source-inline">Thread B</strong>'s is still <strong class="source-inline">5</strong>. The function of <strong class="source-inline">Thread A</strong> completes, and the value of the atom is set to <strong class="source-inline">15</strong>. Then Thread B's function completes its calculation without having seen the new value of the atom. This result is based on a "stale" version of the initial value, but it overwrites the result of the first calculation. In the end, it's as if Thread A's update had never happened.</p>
			<p>Clojure does not want this to happen to you! Here's what would take place with a real Clojure atom:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/B14502_12_13.jpg" alt="Figure 12.13: A real Clojure atom retries when a conflict occurs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: A real Clojure atom retries when a conflict occurs</p>
			<p>This time, when the atom tries to apply the update from <strong class="source-inline">Thread B</strong>, it detects that the underlying value has changed and reapplies the function with the new value.</p>
			<p>We can observe this in the REPL, using one slow-acting (long-sleeping) function and a quick function in two separate threads:</p>
			<p class="source-code">user&gt; (do</p>
			<p class="source-code">    (def integer-atom (atom 5))</p>
			<p class="source-code">    (future (swap! integer-atom (fn [a] (Thread/sleep 2000)(* a 100))))</p>
			<p class="source-code">    (future (swap! integer-atom (fn [a] (Thread/sleep 500) (+ a 200))))</p>
			<p class="source-code">    @integer-atom)</p>
			<p class="source-code">5</p>
			<p class="source-code">user&gt; @integer-atom</p>
			<p class="source-code">205</p>
			<p class="source-code">user&gt; @integer-atom</p>
			<p class="source-code">20500</p>
			<p>In this scenario, we can consider that both calls to <strong class="source-inline">swap!</strong> execute at approximately the same time, when the value of <strong class="source-inline">integer-atom</strong> is still 5. By dereferencing <strong class="source-inline">integer-atom</strong> at the end of the <strong class="source-inline">do</strong> block, we can see that the atom hasn't been updated yet. Yet, a couple of seconds later, the results indicate that both functions were applied, and in the correct order.</p>
			<h2 id="_idParaDest-276">Refs and Soft<a id="_idTextAnchor369"/>ware Transactional Memory</h2>
			<p>Refs are Clojure's most sophisticated reference type. They are why the Clojure language, when it was first introduced, became known for its advanced concurrency management and, more specifically, for STM. STM is an abstraction that guarantees that changes can be made to multiple <em class="italic">refs</em> in a safe, coordinated manner.</p>
			<p>Behind STM, there is a fundamental concept: the transaction. If you have worked with database transactions, you are already familiar with the basic idea. A database transaction might consist of several related operations. If, during the transaction, any individual operation fails, the entire transaction is "rolled back" to the initial state, as if nothing had happened. Transactions are a way of avoiding invalid states where only part of an action is performed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <em class="italic">Chapter 13</em>, <em class="italic">Database Interaction and the Application Layer</em>, we will take a closer look at database transactions.</p>
			<p>The classic example for explaining database transactions also applies here: imagine a bank transaction where money moves from one account to another. To do this, at least two actions need to occur: an amount of money is removed from one account and added to another. If for some reason one of those operations fails, we don't want the other to succeed. If the second account was deleted after the funds are debited from the first account, those funds should return to the original account; otherwise, they would vanish into thin air. In a database transaction, if the second step is not completed, the first step is canceled as well. This way, the system returns automatically to a known, correct state.</p>
			<p>Clojure's software transactional memory is conceptually similar to database transactions but works with data inside your program. A transaction in Clojure is managed by the <strong class="source-inline">dosync</strong> macro, which creates a space in which actions on refs will be coordinated. Imagine that the preceding banking scenario was implemented using Clojure reference types instead of a database. If you are drawing from one bank account ref and depositing to another, then both operations will succeed or the entire <strong class="source-inline">dosync</strong> block will be retried. Like database transactions, the purpose of refs is to make sure that your system remains in a coherent state. This is one of the first key differences between refs and atoms: unlike atoms, refs can provide coordination. When two atoms are updated, there is no such guarantee.</p>
			<p>Refs actually offer even more fine-grained control over how they are modified. There are several functions that can update a ref, each with different semantics. The two most common are <strong class="source-inline">alter</strong> and <strong class="source-inline">commute</strong>. <strong class="source-inline">alter</strong> is the most restrictive: if the underlying value has changed outside the <strong class="source-inline">dosync</strong> block, then the entire transaction will be retried. The <strong class="source-inline">commute</strong> function can be used when this kind of guarantee is not necessary. When adding or subtracting from a total, for example, the order of operations does not affect the result, so these operations can accept changes to the underlying value without a retry. And when accessing the data, the <strong class="source-inline">ensure</strong> function can be used instead of <strong class="source-inline">deref</strong>. In this case, if a ref that is being read from has changed, a retry will be triggered.</p>
			<h2 id="_idParaDest-277">Exercise 12.0<a id="_idTextAnchor370"/>3: Stock Trading</h2>
			<p>In this exercise, we will observe refs in the REPL to get a better sense of their behavior.</p>
			<p>Your current project is a prototype for a stock trading application. You need to write a function that will simulate a client buying some numbers of stocks at a given price. For the purchase to succeed, four things must happen:</p>
			<ul>
				<li>The client account is debited for the amount of the transaction.</li>
				<li>The broker account is credited for the same amount.</li>
				<li>The broker stock account (for that particular stock) is debited, that is, there are now <em class="italic">n </em>fewer stocks in that account.</li>
				<li>The client stock account (for that particular stock) is credited: there are now <em class="italic">n</em> more stocks.</li>
			</ul>
			<p>However, if the price of the stock changes while this is happening, the entire purchase must be invalidated and retried.</p>
			<p>Also, since this is a simulation, we will use <strong class="source-inline">Thread/sleep</strong> to slow the functions down:</p>
			<ol>
				<li value="1">In the REPL, set up some refs for the five different values we'll need. The first three will have integer values, representing account balances in whatever currency is being used:<p class="source-code">user&gt; (def client-account (ref 2100))</p><p class="source-code">#'user/client-account</p><p class="source-code">user&gt; (def broker-account (ref 10000))</p><p class="source-code">#'user/broker-account</p><p class="source-code">user&gt; (def acme-corp-share-price (ref 22))</p><p class="source-code">#'user/acme-corp-share-price</p></li>
				<li>Because the client and the broker would probably own stocks for various firms, we'll use maps for that:<p class="source-code">user&gt; (def broker-stocks (ref {:acme-corp 50}))</p><p class="source-code">#'user/broker-stocks</p><p class="source-code">user&gt; (def client-stocks (ref {:acme-corp 0}))</p><p class="source-code">#'user/client-stocks</p><p>The client starts off with zero <strong class="source-inline">Acme Corp</strong> stocks and a currency balance of <strong class="source-inline">2100</strong> in her account. The broker has <strong class="source-inline">50</strong> stocks and a balance of <strong class="source-inline">10000</strong>.</p></li>
				<li>Write a function that describes a complete transaction:<p class="source-code">user&gt; (defn buy-acme-corp-shares [n]</p><p class="source-code">    (dosync</p><p class="source-code">     (let [purchase-price (* n @acme-corp-share-price)]</p><p class="source-code">      (alter client-account #(- % purchase-price))</p><p class="source-code">      (alter broker-account #(+ % purchase-price))</p><p class="source-code">      (alter client-stocks update :acme-corp #(+ % n))</p><p class="source-code">      (alter broker-stocks update :acme-corp #(- % n)))))</p></li>
				<li>All our code here is wrapped in a <strong class="source-inline">dosync</strong> macro. Beyond that, the code is quite simple. Even in a <strong class="source-inline">dosync</strong> environment, it is necessary to dereference other refs when accessing their value, which is why we write <strong class="source-inline">@acme-corp-share-price</strong>. The syntax for updating the <strong class="source-inline">client-stocks</strong> and <strong class="source-inline">broker-stocks</strong> maps might look a little bit strange. The second argument to <strong class="source-inline">alter</strong> is always a function, and in this case it's the <strong class="source-inline">update</strong> function we've already used for updating maps. The remaining arguments to <strong class="source-inline">alter</strong> will be simply passed on to <strong class="source-inline">update</strong>, after the initial argument, which will be the map contained in the ref. All told, the final call to <strong class="source-inline">update</strong> will be as follows:<p class="source-code">(update {:acme-corp 0} :acme-corp #(+ % n))</p></li>
				<li>Because <strong class="source-inline">update</strong> behaves in the same way as <strong class="source-inline">alter</strong> and passes any additional arguments on to the provided function, our calls to <strong class="source-inline">alter</strong> could be rewritten like this:<p class="source-code">(alter client-stocks update :acme-corp + n)</p><p class="source-code">(alter broker-stocks update :acme-corp - n)</p></li>
				<li>And likewise, the previous lines could use the same syntax:<p class="source-code">(alter client-account - purchase-price)</p><p class="source-code">(alter broker-account + purchase-price)</p><p>These forms are more concise and might be easier to read for experienced Clojure programmers. The forms using anonymous functions have the advantage of explicitly reminding us that we are providing functions as well as clearly laying out the order of the arguments.</p></li>
				<li>Let's try our new function:<p class="source-code">user&gt; (buy-acme-corp-shares 1)</p><p class="source-code">{:acme-corp 49}</p><p>The <strong class="source-inline">dosync</strong> block returns the last value, which, in this case, is the in-transaction value of <strong class="source-inline">broker-account</strong>. That might be useful sometimes, but the data we're really interested in is in the refs:</p><p class="source-code">user&gt; @client-account</p><p class="source-code">2078</p><p class="source-code">user&gt; @broker-account</p><p class="source-code">10022</p><p class="source-code">user&gt; @broker-stocks</p><p class="source-code">{:acme-corp 49}</p><p class="source-code">user&gt; @client-stocks</p><p class="source-code">{:acme-corp 1}</p><p>Here, we see that the balances of the two accounts have been correctly updated and that one stock has moved from <strong class="source-inline">broker-stocks</strong> to <strong class="source-inline">client-stocks</strong>.</p><p>This means that our best-case scenario works: none of the refs are changed outside of the current thread and the transactions are instantaneous. In these conditions, atoms would work just as well. Now it's time to simulate a more demanding environment for the purchase!</p></li>
				<li>Modify <strong class="source-inline">buy-acme-corp-shares</strong> to make the transaction slower and print some information:<p class="source-code">user&gt; (defn buy-acme-corp-shares [n]</p><p class="source-code">    (dosync</p><p class="source-code">     (let [purchase-price (* n @acme-corp-share-price)]</p><p class="source-code">      (println "Let's buy" n "stock(s) at" purchase-price "per stock")</p><p class="source-code">      (Thread/sleep 1000)</p><p class="source-code">      (alter client-account #(- % purchase-price))</p><p class="source-code">      (alter broker-account #(+ % purchase-price))</p><p class="source-code">      (alter client-stocks update :acme-corp #(+ % n))</p><p class="source-code">      (alter broker-stocks update :acme-corp #(- % n)))))</p><p class="source-code">#'user/buy-acme-corp-shares</p><p>With <strong class="source-inline">Thread/sleep</strong>, the transaction will now last one second.</p></li>
				<li>Reset all the accounts to their initial values. To make this easier, let's write a quick reset function using the <strong class="source-inline">ref-set</strong> function:<p class="source-code">user&gt; (defn reset-accounts []</p><p class="source-code">    (dosync</p><p class="source-code">     (ref-set acme-corp-share-price 22)</p><p class="source-code">     (ref-set client-account 2100)</p><p class="source-code">     (ref-set broker-account 10000)</p><p class="source-code">     (ref-set client-stocks {:acme-corp 0})</p><p class="source-code">     (ref-set broker-stocks {:acme-corp 50})))</p><p class="source-code">#'user/reset-accounts</p><p class="source-code">user&gt; (reset-accounts)</p><p class="source-code">{:acme-corp 50}</p><p class="source-code">user&gt; @acme-corp-share-price</p><p class="source-code">22</p><p>All the accounts and the stock price should now be back at their initial values. This will make it easier to observe the behavior of the function.</p></li>
				<li>Use two separate threads to change the client's account during the transaction. To do this, we'll use <strong class="source-inline">future</strong> and set a shorter wait time to the thread by changing <strong class="source-inline">client-account</strong>:<p class="source-code">user&gt; (do</p><p class="source-code">    (reset-accounts)</p><p class="source-code">    (future (buy-acme-corp-shares 1))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 300)</p><p class="source-code">         (alter client-account + 500))))</p><p class="source-code">Let's buy 1 stocks at 22 per stock</p><p class="source-code">#&lt;Future@611d7261: :pending&gt;Let's buy 1 stocks at 22 per stock</p><p>Notice that the <strong class="source-inline">println</strong> message appears twice. What happened? Let's look at the values:</p><p class="source-code">user&gt; @client-account</p><p class="source-code">2578</p><p>Both transactions were correctly recorded: +500 and -22. Here's what happened: first, <strong class="source-inline">buy-acme-corp-shares</strong> tried to complete the transaction but when it was time to write the new account balance to <strong class="source-inline">client-account</strong>, the underlying value had changed due to the deposit from the other thread. Without this, <strong class="source-inline">buy-acme-corp-shares</strong> would have overwritten the account balance, ignoring the recent deposit. The client would not have been pleased.</p></li>
				<li>Simulate a busy broker account. The broker account is probably much busier than the client's account. Let's add more transactions:<p class="source-code">user&gt; (do</p><p class="source-code">    (reset-accounts)</p><p class="source-code">    (future (buy-acme-corp-shares 1))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 300)</p><p class="source-code">         (alter client-account + 500)))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 350)</p><p class="source-code">         (alter broker-account - 200)))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 600)</p><p class="source-code">         (alter broker-account + 1200))))</p><p class="source-code">Let's buy 1 stock(s) at 22 per stock</p><p class="source-code">#&lt;Future@2ffabed2: :pending&gt;Let's buy 1 stock(s) at 22 per stock</p><p class="source-code">Let's buy 1 stock(s) at 22 per stock</p><p>Dereference the atoms to see their final values:</p><p class="source-code">user&gt; @broker-account</p><p class="source-code">11022</p><p class="source-code">user&gt; @client-account</p><p class="source-code">2578</p><p>More changes to the refs cause more restarts, which we can see because the <strong class="source-inline">Let's buy 1 stock(s) at 22 per stock</strong> message is printed three times. Each modification of an account causes the entire transaction to be retried. This is what atoms cannot do: with refs inside a <strong class="source-inline">dosync</strong> block, a change to any of the refs causes the entire block to restart.</p></li>
			</ol>
			<p>This exercise shows the basics of using refs to simplify the sharing of data across threads. Obviously, real-life uses would generally be much more complex, but even at this scale we can see some of the difficulties posed by concurrency and how Clojure provides tools for dealing with it.</p>
			<p>There are a few things that we can observe. Like with atoms, the retry strategy used by refs prevents near-simultaneous operations from interfering with one another. But refs go further by making sure that even if one ref causes a retry, all the updates in the transaction will be retried. This guarantees data coherence. It also means that we give up some control of when changes to refs will be made. As programmers, we are used to thinking in a very linear fashion: "do this, then do that." Multithreaded applications break this way of thinking. Clojure's reference types, and refs in particular, can help us write better code, especially if we learn to think less in terms of the strict order of operations and more in terms of the correctness and coherence of the operations.</p>
			<h2 id="_idParaDest-278">More Cohesion<a id="_idTextAnchor371"/> with refs</h2>
			<p>In the previous example, STM helped us to make sure that the updates were coherent: the buyer had less money in her account, but more stocks; the seller had more money, but fewer stocks. If any one of those four changes had failed, the system would have returned to the previous valid state. Either way, everyone ends up with the correct balances on their accounts. There is, however, one possibility we didn't consider. What if the price of the stock changes during the transaction? Let's take a look:</p>
			<p class="source-code">user&gt; (do</p>
			<p class="source-code">    (reset-accounts)</p>
			<p class="source-code">    (future (buy-acme-corp-shares 1))</p>
			<p class="source-code">    (future (dosync</p>
			<p class="source-code">         (Thread/sleep 300)</p>
			<p class="source-code">         (alter acme-corp-share-price + 10))))</p>
			<p class="source-code">Let's buy 1 stocks at 22 per stock</p>
			<p class="source-code">#&lt;Future@11e639bf: :pending&gt;</p>
			<p class="source-code">user&gt; @client-account</p>
			<p class="source-code">2078</p>
			<p>The balance on the client's account indicates that the purchase price was 22. The sequence of events suggests that the client got a good deal. While <strong class="source-inline">buy-acme-corp-shares</strong> was waiting for 1,000 milliseconds, in the second future, the stock price was changed to 32. When the purchase was finally complete, the price was no longer 22 but 32. Why didn't the refs protect us from this?</p>
			<p>The problem here is that the <strong class="source-inline">buy-acme-corp-shares</strong> function consults the value of the <strong class="source-inline">acme-corp-share-price</strong> atom but does not do anything with it. As a result, <strong class="source-inline">dosync</strong> does not track the changes made to that ref. In the next exercise, we'll explore two different solutions: the <strong class="source-inline">ensure</strong> function and a clever way to use <strong class="source-inline">alter</strong>.</p>
			<h2 id="_idParaDest-279">Exercise 12.0<a id="_idTextAnchor372"/>4: Keeping up with the Stock Price</h2>
			<p>The initial prototype for the stock purchase function seems to be working but the team has realized that it does not react correctly to variations in the stock price that occur while the transaction is completing. You've been asked to suggest some solutions.</p>
			<ol>
				<li value="1">In your REPL, use the same environment as in the previous exercise. If necessary, recreate the same five refs and make sure that the <strong class="source-inline">reset-accounts</strong> function is defined.</li>
				<li>In <strong class="source-inline">buy-acme-corp-shares</strong>, use <strong class="source-inline">ensure</strong> to dereference <strong class="source-inline">acme-corps-stock-price</strong>:<p class="source-code">user&gt; (defn buy-acme-corp-shares [n]</p><p class="source-code">    (dosync</p><p class="source-code">     (let [price (ensure acme-corp-share-price)]</p><p class="source-code">      (println "Let's buy" n "stock(s) at" price "per stock")</p><p class="source-code">      (Thread/sleep 1000)</p><p class="source-code">      (alter client-account #(- % price))</p><p class="source-code">      (alter broker-account #(+ % price))</p><p class="source-code">      (alter client-stocks update :acme-corp #(+ % n))</p><p class="source-code">      (alter broker-stocks update :acme-corp #(- % n)))))</p><p class="source-code">#'user/buy-acme-corp-shares</p></li>
				<li>Run the same transaction as before. We'll add an extra <strong class="source-inline">println</strong> statement to see when the share price updates occur:<p class="source-code">user&gt; (do</p><p class="source-code">    (reset-accounts)</p><p class="source-code">    (future (buy-acme-corp-shares 1))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 300)</p><p class="source-code">         (println "Raising share price to " (+ @acme-corp-share-price 10))</p><p class="source-code">         (alter acme-corp-share-price + 10))))</p><p class="source-code">Let's buy 1 stock(s) at 22 per stock</p><p class="source-code">#&lt;Future@5410594c: :pending&gt;Raising share price to 32</p><p class="source-code">Raising share price to 32</p><p class="source-code">Raising share price to 32</p><p class="source-code">user&gt; @client-account</p><p class="source-code">2078</p><p>There are two noteworthy things in this output: <strong class="source-inline">Raising share price…</strong> was printed 3 times and the client account balance is still only down by 22. What happened?</p><p>As soon as <strong class="source-inline">ensure</strong> was called in <strong class="source-inline">buy-acme-corp-shares</strong>, the value of <strong class="source-inline">acme-corp-share-price</strong> was frozen until the <strong class="source-inline">dosync</strong> block had completed. The second <strong class="source-inline">dosync </strong>macro then kept retrying until the first had completed. When <strong class="source-inline">buy-acme-corp-shares </strong>had terminated, <strong class="source-inline">acme-corp-share-price</strong> could finally be raised.</p><p>At the very instant that <strong class="source-inline">buy-acme-corp-shares</strong> purchased the shares, the price was still 22. Data coherence was thus maintained. There is, however, a problem. In the real world, a single buyer cannot force the rest of the stock market to wait for a purchase to go through. This solution is correct in a way, but in this scenario it would not work.</p></li>
				<li>Use <strong class="source-inline">alter</strong> to trigger a retry. This time, we'll go back to <strong class="source-inline">deref</strong> for accessing the current share price. We'll also call <strong class="source-inline">alter</strong> on <strong class="source-inline">acme-corp-share-price</strong> to trigger a retry if that ref has changed. You might think "we can't change the share price!" You're right, of course, but our call to <strong class="source-inline">alter</strong> won't actually do anything, since we will only provide the <strong class="source-inline">identity</strong> function as an argument. We call <strong class="source-inline">alter</strong>, but just as a way to say "stay the way you are":<p class="source-code">user&gt; (defn buy-acme-corp-shares [n]</p><p class="source-code">    (dosync</p><p class="source-code">     (let [price @acme-corp-share-price]</p><p class="source-code">      (println "Let's buy" n "stock(s) at" price "per stock")</p><p class="source-code">      (Thread/sleep 1000)</p><p class="source-code">      (alter acme-corp-share-price identity)</p><p class="source-code">      (alter client-account #(- % price))</p><p class="source-code">      (alter broker-account #(+ % price))</p><p class="source-code">      (alter client-stocks update :acme-corp #(+ % n))</p><p class="source-code">      (alter broker-stocks update :acme-corp #(- % n)))))</p><p class="source-code">#'user/buy-acme-corp-shares</p><p>Let's see what happens:</p><p class="source-code">user&gt; (do</p><p class="source-code">    (reset-accounts)</p><p class="source-code">    (future (buy-acme-corp-shares 1))</p><p class="source-code">    (future (dosync</p><p class="source-code">         (Thread/sleep 300)</p><p class="source-code">         (println "Raising share price to " (+ @acme-corp-share-price 10))</p><p class="source-code">         (alter acme-corp-share-price + 10))))</p><p class="source-code">Let's buy 1 stock(s) at 22 per stock</p><p class="source-code">#&lt;Future@2b64a327: :pending&gt;Raising share price to 32</p><p class="source-code">Let's buy 1 stock(s) at 32 per stock</p><p>This time, <strong class="source-inline">Let's buy 1 stock(s)…</strong> is printed twice, with two different prices. <strong class="source-inline">Raising share price…</strong> is printed only once. The share price is changed during the first call to <strong class="source-inline">buy-acme-corp-shares</strong>. Because of the change, a retry is triggered, now with the correct share price. The purchase finally completes, with the correct price:</p><p class="source-code">user&gt; @client-account</p><p class="source-code">2068</p></li>
			</ol>
			<p>This exercise demonstrates the power and the subtlety of Clojure's STM. Depending on the problem you need to solve and on the environment you're working in, you will need retries to happen in slightly different circumstances. In this example, it was obvious that we could not ask the stock market to wait even 1 second for our transaction to complete. Refs give you the ability to precisely define the retry behavior that you need. (In addition to <strong class="source-inline">alter</strong> and <strong class="source-inline">ref-set</strong>, there is <strong class="source-inline">commute</strong>, which provides yet another set of semantics for updating refs when less control is needed.) And of course, this degree of control also requires careful thought about the relationships between refs.</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor373"/>Agents</h2>
			<p>The pr<a id="_idTextAnchor374"/>imary difference between agents and the other reference types is that, while updates to atoms and refs are <strong class="source-inline">synchronous</strong>, updates to agents are <strong class="source-inline">asynchronous</strong>. Changes made to an agent are sent to a queue, a waiting list of changes, and the functions are run in a separate thread. Unlike refs and atoms, the calling thread is not blocked while waiting for the action to complete. So, while agents provide far less control over updates than refs, they do not slow down operations with retries. In atoms and refs, retries are necessary to solve the problem of simultaneous mutations; in agents, the same problem is solved by giving up on simultaneity and simply executing incoming functions in the order they are received.</p>
			<p>We can observe the asynchronous nature of an agent by making changes that take a few seconds to complete, thanks to <strong class="source-inline">Thread/sleep</strong> again:</p>
			<p class="source-code">user&gt; (def integer-agent (agent 5))</p>
			<p class="source-code">#'user/integer-agent</p>
			<p class="source-code">user&gt; (send integer-agent (fn [a] (Thread/sleep 5000) (inc a)))</p>
			<p class="source-code">#&lt;Agent@3c221047: 5&gt;</p>
			<p class="source-code">user&gt; (send integer-agent (fn [a] (Thread/sleep 5000) (inc a)))</p>
			<p class="source-code">#&lt;Agent@3c221047: 5&gt;</p>
			<p class="source-code">user&gt; @integer-agent</p>
			<p class="source-code">5</p>
			<p class="source-code">user&gt; @integer-agent</p>
			<p class="source-code">6</p>
			<p class="source-code">user&gt; @integer-agent</p>
			<p class="source-code">7</p>
			<p>First, we define the agent, setting its value to <strong class="source-inline">5</strong>. Then we <strong class="source-inline">send</strong> two identical modifications to increment the agent's value after 5 seconds. If we quickly type <strong class="source-inline">@integer-agent</strong> (or <strong class="source-inline">(deref</strong></p>
			<p><strong class="source-inline">integer-agent)</strong>, but that takes more time), we see that the value is still <strong class="source-inline">5</strong>. If we wait a little bit longer and type <strong class="source-inline">@integer-agent</strong> again, we see that the value has moved to <strong class="source-inline">6</strong>. And a few seconds later, it increments again to <strong class="source-inline">7</strong>.</p>
			<p>If we replace the agent in the preceding example with an atom (and use <strong class="source-inline">swap!</strong> instead of <strong class="source-inline">send</strong>), the final result is the same but we are forced to wait for the operation to complete before we regain control of the REPL:</p>
			<p class="source-code">user&gt; (def integer-atom (atom 5))</p>
			<p class="source-code">#'user/integer-atom</p>
			<p class="source-code">user&gt; (swap! integer-atom (fn [a] (Thread/sleep 5000) (inc a)))</p>
			<p class="source-code">6</p>
			<p class="source-code">user&gt; (swap! integer-atom (fn [a] (Thread/sleep 5000) (inc a)))</p>
			<p class="source-code">7</p>
			<p>If you try this in your REPL, you will see that the REPL prompt is blocked for 5 seconds after each call to <strong class="source-inline">swap!</strong>.</p>
			<p>Because they do not block, there are some situations where agents are preferable to atoms or refs. For example, suppose your main application divides a processor-intensive task into several parts that can be passed to separate threads. While these threads are working, you want to present a progress bar to the user. When a thread accomplishes one unit of work, it increments a counter in an agent. The advantage of an asynchronous agent is that this would not slow the worker thread down: control returns immediately to the thread, which can start working again right away, and the agent can handle the update on its own:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/B14502_12_14.jpg" alt="Figure 12.14: The worker threads send progress updates to the agent&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: The worker threads send progress updates to the agent</p>
			<p>Like refs and unlink atoms, agents also benefit from STM. Inside a <strong class="source-inline">dosync</strong> block, changes made to several agents benefit from the same retry semantics as refs. Because updates to agents are asynchronous, on the output side they do not provide as much control as refs, but they are less prone to deadlock from endless retries in very busy systems.</p>
			<h2 id="_idParaDest-281">Atoms in Cloju<a id="_idTextAnchor375"/>reScript</h2>
			<p>Vars and atoms are the only reference types available in ClojureScript. Even though JavaScript runtimes are not multithreaded, code execution is often non-linear. In the browser, a single-page application needs to be able to handle events that can come from every link or input, or from actions such as scrolling and hovering. Application state needs to be shared by the code triggered by these events, and atoms turn out to be a very good choice. (This is fortunate, since they are the only choice.)</p>
			<p>The rest of this chapter will focus on atoms in the browser. The odds are that your first real-life experience of concurrency in Clojure won't be a complex multithreaded JVM application. There's a good chance that you'll take your first Clojure concurrency steps in a browser-based ClojureScript program. Many of the best-known ClojureScript frameworks for building browser applications, such as Reagent, Re-frame, and Om, use atoms to manage state.</p>
			<h2 id="_idParaDest-282">Exercise 12.05<a id="_idTextAnchor376"/>: Rock, Scissors, Paper</h2>
			<p>In this exercise, we're going to implement the famous Rock, Scissors, Paper game in ClojureScript. The real game is played between two people who count to three and then simultaneously make a hand gesture, either a "rock," "scissors," or "paper." Each of the three choices can defeat one of the other two and be defeated by the other. Thus, "rock crushes scissors," "scissors cut paper," and "paper wraps rock". If both players choose the same object, it's a draw and they play again.</p>
			<ol>
				<li value="1">At the command-line prompt, create a new <strong class="source-inline">figwheel</strong> project using the following <strong class="source-inline">Leiningen</strong> command:<p class="source-code">lein new figwheel packt-clj.rock-scissors-paper -- --rum</p></li>
				<li>Move to the <strong class="source-inline">packt-clj.rock-scissors-paper/</strong> directory and type the following:<p class="source-code">lein figwheel</p><p>After a few seconds, your browser should open to the default Figwheel page:</p><div id="_idContainer254" class="IMG---Figure"><img src="image/B14502_12_15.jpg" alt="Figure 12.15: A fresh ClojureScript project waiting for your code&#13;&#10;"/></div><p class="figure-caption">Figure 12.15: A fresh ClojureScript project waiting for your code</p><p>Open <strong class="source-inline">packt-clj.rock-scissors-paper/src/packt_clj/rock_scissors_paper/core.cljs</strong> and get ready to write some code.</p></li>
				<li>Let's start by designing the underlying data. This is a very simple game, so it won't take much. We need to keep track of the computer's choice (rock, scissors, or paper) and the user's choice. We also need to have a game state, which will be one of three states: <strong class="source-inline">:setup</strong> (the game hasn't started yet), <strong class="source-inline">:waiting</strong> (waiting for the user to play), and <strong class="source-inline">:complete</strong> (we'll show who won and offer to play again).<p>Replace the supplied <strong class="source-inline">app-state</strong> definition with the following:</p><p class="source-code">(defonce app-state (atom {:computer-choice nil</p><p class="source-code">             :game-state :setup</p><p class="source-code">             :user-choice nil}))</p><p>We also want to make this our own app, so let's update some of the function names. Rename the <strong class="source-inline">hello-world</strong> component as <strong class="source-inline">rock-scissors-paper</strong>, for example.</p></li>
				<li>All of the game logic will go in a <strong class="source-inline">rock-paper-scissors</strong> component. For now, we'll just have it display some text:<p class="source-code">(rum/defc rock-paper-scissors []</p><p class="source-code"> [:div</p><p class="source-code">  [:h1 "Rock, Paper, Scissors"]])</p><p>While we're there, we can change the end of the file slightly to use the pattern that we used in <em class="italic">Chapter 9</em>, <em class="italic">Host Platform interoperability with Java and JavaScript</em>:</p><p class="source-code">(defn on-js-reload []</p><p class="source-code"> (rum/mount (rock-paper-scissors)</p><p class="source-code">       (. js/document (getElementById "app"))))</p><p class="source-code">(on-js-reload)</p></li>
				<li>Now we'll define the game logic itself. We'll try to have this part of the program not be dependent on ClojureScript. The first function will determine the computer's choice of rock, paper, or scissors:<p class="source-code">(defn computer-choice []</p><p class="source-code"> (nth [:rock :scissors :paper] (rand-int 3)))</p></li>
				<li>The only slightly complex problem is translating the "rock crushes scissors" rules into code. Of course, we could just write a long <strong class="source-inline">cond</strong> structure, but since this is Clojure, so we'll use a data structure instead:<p class="source-code">(def resolutions</p><p class="source-code">  {:rock {:paper :computer-wins</p><p class="source-code">          :scissors :player-wins}</p><p class="source-code">   :scissors {:rock :computer-wins</p><p class="source-code">              :paper :player-wins}</p><p class="source-code">   :paper {:scissors :computer-wins</p><p class="source-code">           :rock :player-wins}})</p><p>In the <strong class="source-inline">resolutions</strong> map, the top-level keys correspond to the human player's choice. Each item contains two possible outcomes, based on the two non-tie choices the computer might make.</p></li>
				<li>That means that if the player chooses <strong class="source-inline">:rock</strong> and the computer chooses <strong class="source-inline">:scissors</strong>, we can get the result like this:<p class="source-code">packt-clj.rock-scissors-paper.core&gt; (get-in resolutions [:rock :scissors])</p><p class="source-code">:player-wins</p></li>
				<li>This is how we'll write our <strong class="source-inline">resolve-game</strong> function. Checking for ties is easy with a simple equality check:<p class="source-code">(defn resolve-game [player computer]</p><p class="source-code"> (if (= player computer)</p><p class="source-code">  :tie</p><p class="source-code">  (get-in resolutions [player computer])))</p></li>
				<li>We also want to tell the user why they won or lost by providing a message such as "Rock crushes scissors." These messages don't need to mention who won, so we only need associate pairs of objects with a message. <strong class="source-inline">:rock</strong> and <strong class="source-inline">:paper</strong> in any order should result in <strong class="source-inline">Paper wraps rock</strong>. Since order isn't important, <strong class="source-inline">sets</strong> might be a good choice. We can use the sets as map keys, like this:<p class="source-code">(def object-sets-&gt;messages</p><p class="source-code"> {#{:rock :scissors} "Rock crushes scissors."</p><p class="source-code">  #{:scissors :paper} "Scissors cut paper."</p><p class="source-code">  #{:paper :rock} "Paper wraps rock."})</p><p>Most of the time we use keywords as map keys, to the point that we forget sometimes that more complex data structures can also be used. This way, it doesn't matter if we write the following:</p><p class="source-code">(get object-sets-&gt;messages #{:rock :scissors})</p><p>We can also write the following:</p><p class="source-code">(get object-sets-&gt;messages #{:scissors :rock})</p></li>
				<li>Let's wrap this logic into a function:<p class="source-code">(defn result-messages [a b]</p><p class="source-code"> (get object-sets-&gt;messages (hash-set a b)))</p><p>Here, <strong class="source-inline">hash-set</strong> builds the set to be used to look for the appropriate message. The <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> parameters can be, interchangeably, the player's choice or the computer's choice.</p></li>
				<li>At this point, a game can be resolved with two function calls: one to know who won, the other to know why. Here, the player chooses <strong class="source-inline">:scissors</strong> and defeats the computer, who unwisely chose <strong class="source-inline">:paper</strong>:<p class="source-code">packt-clj.rock-scissors-paper.core&gt; (resolve-game :scissors :paper)</p><p class="source-code">:player-wins</p><p class="source-code">packt-clj.rock-scissors-paper.core&gt; (result-messages :scissors :paper)</p><p class="source-code">"Scissors cut paper."</p></li>
				<li>The next step is to convert our gameplay into views. Let's break the game view out into its own component, which we'll call <strong class="source-inline">game-view</strong>. There are only three game states, so we can get away with a <strong class="source-inline">case</strong> expression. We'll start with just placeholders:<p class="source-code">(rum/defc game-view &lt; rum/reactive []</p><p class="source-code"> (case (:game-state (rum/react app-state))</p><p class="source-code">  :setup</p><p class="source-code">  [:div "Ready to play?"</p><p class="source-code">   [:div [:a {:href "#start"} "Start"]]]</p><p class="source-code">  :waiting</p><p class="source-code">  [:div "Choose one"</p><p class="source-code">   [:div [:a {:href "#rock"} "Rock"]]</p><p class="source-code">   [:div [:a {:href "#paper"} "Paper"]]</p><p class="source-code">   [:div [:a {:href "#scissors"} "Scissors"]]]</p><p class="source-code">  :complete</p><p class="source-code">  [:div [:a {:href "#restart"} "Play again?"]]))</p><p>To see the output from this component, we can plug it into the <strong class="source-inline">(rock-scissors-paper)</strong> function we defined earlier:</p><p class="source-code">(rum/defc rock-paper-scissors []</p><p class="source-code"> [:div</p><p class="source-code">  [:h1 "Rock, Paper, Scissors"]</p><p class="source-code">  (game-view)])</p><p>At this point, the <strong class="source-inline">game-view</strong> component just shows some different markups depending on the game state, which is stuck at <strong class="source-inline">:setup</strong> because there is no code to make anything happen yet. Still, it's a good idea to make sure that everything is working as expected. The key here is how <strong class="source-inline">app-state</strong> is dereferenced using <strong class="source-inline">rum/react</strong>. The <strong class="source-inline">rum</strong> library adds a lot of built-in behavior that goes beyond just dereferencing. For now, though, we can think of <strong class="source-inline">rum/react</strong> as a fancy, framework-specific version of <strong class="source-inline">deref</strong>:</p><div id="_idContainer255" class="IMG---Figure"><img src="image/B14502_12_16.jpg" alt="Figure 12.16: We have a start screen but no gameplay yet&#13;&#10;"/></div><p class="figure-caption">Figure 12.16: We have a start screen but no gameplay yet</p></li>
				<li>To move on to the next game state, something needs to happen when the player clicks on <strong class="source-inline">Start</strong>. We need a function that will start the game.<p>To start a new game, we need to do two things to <strong class="source-inline">app-state</strong>: set <strong class="source-inline">:game-state</strong> to <strong class="source-inline">:waiting</strong> and set <strong class="source-inline">:computer-choice</strong> to the output from our <strong class="source-inline">computer-choice</strong> function. It's also probably good practice to clean up the <strong class="source-inline">:player-choice</strong> field as well, since it is no longer valid. Our <strong class="source-inline">start-game</strong> function can look like this:</p><p class="source-code">(defn start-game []</p><p class="source-code"> (swap! app-state</p><p class="source-code">     (fn [state]</p><p class="source-code">      (assoc state</p><p class="source-code">         :computer-choice (computer-choice)</p><p class="source-code">         :game-state :waiting</p><p class="source-code">         :player-choice nil))))</p><p>Notice that we're using <strong class="source-inline">swap!</strong>. Since <strong class="source-inline">app-state</strong> is a real atom, this is how we have to interact with it, by providing a function. If we wanted to be more concise, our call to <strong class="source-inline">swap!</strong> could be rewritten like this:</p><p class="source-code">(swap! app-state</p><p class="source-code">    assoc</p><p class="source-code">    :computer-choice (computer-choice)</p><p class="source-code">    :game-state :waiting</p><p class="source-code">    :player-choice nil)</p></li>
				<li>Inside the <strong class="source-inline">game-view</strong> component, we can now add <strong class="source-inline">start-game</strong> as a click handler in both the <strong class="source-inline">:setup</strong> and <strong class="source-inline">:complete</strong> phases:<p class="source-code">(rum/defc game-view &lt; rum/reactive []</p><p class="source-code"> (case (:game-state (rum/react app-state))</p><p class="source-code">  :setup</p><p class="source-code">  [:div "Ready to play?"</p><p class="source-code">   [:div [:a {:href "#start"</p><p class="source-code">        :onClick start-game} "Start"]]]</p><p class="source-code">  :waiting</p><p class="source-code">  [:div "Choose one"</p><p class="source-code">   [:div [:a {:href "#rock"} "Rock"]]</p><p class="source-code">   [:div [:a {:href "#paper"} "Paper"]]</p><p class="source-code">   [:div [:a {:href "#scissors"} "Scissors"]]]</p><p class="source-code">  :complete</p><p class="source-code">  [:div [:a {:href "#restart"</p><p class="source-code">        :onClick start-game} "Play again?"]]))</p><p>Let's check this new behavior. If you click on <strong class="source-inline">Start</strong>, you should now see this:</p><div id="_idContainer256" class="IMG---Figure"><img src="image/B14502_12_17.jpg" alt="Figure 12.17: Starting the Rock, Paper, Scissors application&#13;&#10;"/></div><p class="figure-caption">Figure 12.17: Starting the Rock, Paper, Scissors application</p></li>
				<li>Now we need handlers for each of the choices. Since each handler will do essentially the same thing, just with a different value, let's write a function that returns a function using that value. We'll call it <strong class="source-inline">player-choice</strong>:<p class="source-code">(defn player-choice [choice]</p><p class="source-code"> (fn []</p><p class="source-code">  (swap! app-state</p><p class="source-code">      (fn [state]</p><p class="source-code">       (assoc state</p><p class="source-code">          :player-choice choice</p><p class="source-code">          :game-state :complete)))))</p><p>The changes made to <strong class="source-inline">app-state</strong> here move the <strong class="source-inline">:game-state</strong> to the next phase and add in the <strong class="source-inline">choice</strong> parameter as a means of closure for the anonymous function.</p></li>
				<li>Instead of writing three separate handlers, we can just call these functions in the view. Now our <strong class="source-inline">game-view</strong> component looks like this:<p class="source-code">(rum/defc game-view &lt; rum/reactive []</p><p class="source-code"> (case (:game-state (rum/react app-state))</p><p class="source-code">  :setup</p><p class="source-code">  [:div "Ready to play?"</p><p class="source-code">   [:div [:a {:href "#start"</p><p class="source-code">        :onClick start-game} "Start"]]]</p><p class="source-code">  :waiting</p><p class="source-code">  [:div "Choose one"</p><p class="source-code">   [:div [:a {:href "#rock"</p><p class="source-code">        :onClick (player-choice :rock)} "Rock"]]</p><p class="source-code">   [:div [:a {:href "#paper"</p><p class="source-code">        :onClick (player-choice :paper)} "Paper"]]</p><p class="source-code">   [:div [:a {:href "#scissors"</p><p class="source-code">        :onClick (player-choice :scissors)} "Scissors"]]]</p><p class="source-code">  :complete</p><p class="source-code">  [:div [:a {:href "#restart"</p><p class="source-code">              :onClick start-game} "Play again?"]]))</p><p>Notice that with the <strong class="source-inline">start-game</strong> handler, we supply the function itself, without parentheses. That's because <strong class="source-inline">start-game</strong> itself is the handler. With <strong class="source-inline">player-choice</strong>, we call the function when defining the view; it isn't the handler, instead it returns an anonymous handler, which is what will actually be called when the user clicks the link.</p></li>
				<li>Now, when clicking on <strong class="source-inline">Rock</strong>, <strong class="source-inline">Scissors</strong>, or <strong class="source-inline">Paper</strong>, you should see the final screen:<div id="_idContainer257" class="IMG---Figure"><img src="image/B14502_12_18.jpg" alt="Figure 12.18: Final screen of Rock, Paper, Scissors&#13;&#10;"/></div><p class="figure-caption">Figure 12.18: Final screen of Rock, Paper, Scissors</p></li>
				<li>The last step is to display the results. Since this is more complex than the other views, it's worth breaking it out into a new component, which we'll call <strong class="source-inline">result-view</strong>. Let's look at the code and then we'll go through the logic:<p class="source-code">(rum/defc result-view &lt; rum/reactive []</p><p class="source-code"> (let [player (:player-choice (rum/react app-state))</p><p class="source-code">    computer (:computer-choice (rum/react app-state))</p><p class="source-code">    result (resolve-game player computer)]</p><p class="source-code">  [:div</p><p class="source-code">    [:div "You played " [:strong (name player)]]</p><p class="source-code">    [:div "The computer played " [:strong (name computer)]]</p><p class="source-code">    (if (= result :tie)</p><p class="source-code">     [:div "It was a tie!"]</p><p class="source-code">     [:div</p><p class="source-code">      [:div (result-messages player computer)]</p><p class="source-code">      [:div (if (= result :player-wins) "You won!" "Oops. The computer won.")]])</p><p class="source-code">    [:div [:a {:href "#start"</p><p class="source-code">        :onClick start-game} "Play again?"]]]))</p><p>We start off with some <strong class="source-inline">let</strong> bindings for the player choice, the computer choice, and the result, which is derived from the two choices.</p><p>Everything after that takes place in a single <strong class="source-inline">:div</strong> element. This is necessary because in React, and thus in all the React-based ClojureScript frameworks, a component can only return a single HTML element. Without this wrapping <strong class="source-inline">:div</strong> element, we would get an error.</p><p>After displaying both of the choices, using <strong class="source-inline">name</strong> to convert the keywords to strings, we get to the actual results. In case of a tie, there is not much to display, so we test for that first. The <strong class="source-inline">result-messages</strong> function provides a nice summary of what happened and then we can finally tell the player whether they won or lost, depending on the value of <strong class="source-inline">result</strong>. At the end, we've placed the "<strong class="source-inline">Play again?</strong>" link that was previously in the <strong class="source-inline">game-view</strong> component.</p></li>
				<li>Now we just need to insert the <strong class="source-inline">result-view</strong> component into the <strong class="source-inline">game-view</strong> component:<p class="source-code">(rum/defc game-view &lt; rum/reactive []</p><p class="source-code"> (case (:game-state (rum/react app-state))</p><p class="source-code">  :setup</p><p class="source-code">  [:div "Ready to play?"</p><p class="source-code">   [:div [:a {:href "#start"</p><p class="source-code">        :onClick start-game} "Start"]]]</p><p class="source-code">  :waiting</p><p class="source-code">  [:div "Choose one"</p><p class="source-code">   [:div [:a {:href "#rock"</p><p class="source-code">        :onClick (player-choice :rock)} "Rock"]]</p><p class="source-code">   [:div [:a {:href "#paper"</p><p class="source-code">        :onClick (player-choice :paper)} "Paper"]]</p><p class="source-code">   [:div [:a {:href "#scissors"</p><p class="source-code">        :onClick (player-choice :scissors)} "Scissors"]]]</p><p class="source-code">  :complete</p><p class="source-code">  (result-view)))</p><p class="callout-heading">Note</p><p class="callout">The complete code for this exercise is available on the book's GitHub repository: <a href="https://packt.live/2uoDolF">https://packt.live/2uoDolF</a>.</p><p>Now you should be able to play the game:</p></li>
			</ol>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B14502_12_19.jpg" alt="Figure 12.19: Prompt to play again&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.19: Prompt to play again</p>
			<p>You won! By building this simple game, you've learned a basic template for stateful ClojureScript applications, using one of Clojure's reference types. Even though the JavaScript runtime is single-threaded, atoms are useful here because they allow event handlers to interact with shared program state in a safer way than simply overwriting data.</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor377"/>Watchers</h2>
			<p>In the pre<a id="_idTextAnchor378"/>vious exercise, we mentioned that when using the <strong class="source-inline">Rum</strong> library, writing <strong class="source-inline">(rum/react app-state)</strong> basically dereferences the <strong class="source-inline">app-state</strong> atom. There is, however, a little bit more going on, obviously, since otherwise we would use <strong class="source-inline">deref</strong> instead. In ClojureScript libraries such as Rum, atoms often serve as the application's "single source of truth." Rum and the Om framework both use plain atoms; Reagent and the popular <strong class="source-inline">Re-frame</strong> library, which is based on Reagent, both use a special <strong class="source-inline">atom</strong> implementation sometimes referred to as a "ratom" (from <strong class="bold">r/atom</strong>, if <strong class="bold">r</strong> is a namespace alias for Reagent). You'll learn more about Reagent in <em class="italic">Chapter 15</em>, <em class="italic">The Front End: A ClojureScript UI</em>.</p>
			<p>Why are atoms so popular for ClojureScript libraries? First of all, atoms help manage concurrent updates. When there is a single source of truth, that means that many parts of the program may interfere with each other when they all try to update the same data source. As we've already seen, atoms, with their built-in retry logic, help avoid many of these issues.</p>
			<p>Beyond this, however, Clojure (and ClojureScript) atoms have another important feature that makes them particularly useful as the single source of truth in a browser-based application. A common pattern in modern JavaScript architectures goes something like this:</p>
			<ul>
				<li>An event occurs and is handled by the application. In the previous exercise, these were the click handlers. There are, of course, many other kinds of events that might occur: scrolling events, timeouts, successful (or failed) network requests, and so on.</li>
				<li>In response to the event, the application state is modified. In the Rock, Paper, Scissors game, the player made their choice, and this was reflected in <strong class="source-inline">app-state</strong>, via <strong class="source-inline">swap!</strong>.</li>
				<li>The rest of the application reacts to this change in the application state. Views that reference the application state are updated automatically. Advancing the <strong class="source-inline">:game-state</strong> field in <strong class="source-inline">app-state</strong> caused the different phases of the game to be displayed. Once the appropriate views were defined, the framework seemed to take care of making sure that the views were updated.</li>
			</ul>
			<p>When one part of the application updates the application states, the other parts respond. Atoms help with this because they accept "watcher" functions that are called when the atom changes. To "watch" an atom, we use the <strong class="source-inline">add-watch</strong> function:</p>
			<p class="source-code">user&gt; (def observable-atom (atom 5))</p>
			<p class="source-code">#'user/observable-atom</p>
			<p class="source-code">user&gt; (add-watch observable-atom :watcher-1</p>
			<p class="source-code">         (fn [k a old new]</p>
			<p class="source-code">          (println "The observable atom has gone from" old "to" new)))</p>
			<p class="source-code">#&lt;Atom@14b35f8d: 5&gt;</p>
			<p class="source-code">user&gt; (swap! observable-atom inc)</p>
			<p class="source-code">The observable atom has gone from 5 to 6</p>
			<p class="source-code">6</p>
			<p>We've provided an anonymous function that simply prints out a message when the atom is changed. When adding a <strong class="source-inline">watch</strong> function, a key such as <strong class="source-inline">:watcher-1</strong> is required so that, later, that particular watcher can be identified for removal by the <strong class="source-inline">remove-watch</strong> function. That key is then available as the first argument to the watcher function, <strong class="source-inline">k</strong> in this example. The <strong class="source-inline">a</strong> argument is the atom itself. Often, these two arguments will not be used; in most cases, what you really need is in the <strong class="source-inline">old</strong> and <strong class="source-inline">new</strong> arguments.</p>
			<p>In the previous exercise, we defined our components using the <strong class="source-inline">rum/reactive</strong> mixin as follows:</p>
			<p class="source-code">(rum/defc game-view &lt; rum/reactive []</p>
			<p class="source-code"> ;;</p>
			<p class="source-code"> )</p>
			<p><strong class="source-inline">rum/reactive</strong> then adds watchers as appropriate so that the component knows when to update. This way, multiple components can reference the same data in <strong class="source-inline">app-state</strong>; when the data changes, the components are watching, and they can update accordingly. This pattern happens to mesh nicely with some of the common patterns used with React.js, which is why it is seen so often in ClojureScript libraries and applications. Generally, when using these frameworks, you will not need to define your own watchers. The frameworks take care of that for you.</p>
			<p>Validators are another feature of atoms that you could actually use in your ClojureScript app. Like watchers, validators are functions that can be added to Clojure reference types. When an atom, for example, is about to be modified by a call to <strong class="source-inline">swap!</strong>, if any validators have been set on the atom, they will be called. If any of them do not return <strong class="source-inline">true</strong>, the update will fail and an exception (or an error, if this is on the JavaScript runtime) will be thrown:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/B14502_12_20.jpg" alt="Figure 12.20: Execution error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.20: Execution error</p>
			<p>When an update fails validation, an exception is thrown.</p>
			<p>Here, the validator enforces a "less than 6" rule on <strong class="source-inline">integer-atom</strong>. The call to <strong class="source-inline">swap!</strong> tries to increment the value to <strong class="source-inline">6</strong> but an exception is thrown instead. In the next exercise, we will incorporate some validation.</p>
			<h2 id="_idParaDest-284">Exercise 12.06: One,<a id="_idTextAnchor379"/> Two, Three… "Rock!"</h2>
			<p>Your in-browser Rock, Paper, Scissors game is starting to generate some interest. You've created a start-up around it and now your investors want an improved version that is more like the original. Your plan is to introduce a countdown before the user can make their choice, just like in the original version of the game, where the two players coordinate their moves before revealing their choices: "One, two, three…Rock!"</p>
			<p>To do this, we'll use JavaScript intervals to provide some timing for the countdown. In the browser, intervals are how JavaScript developers can cause a function to be called repeatedly after a certain number of milliseconds. We will use intervals to simulate a ticking clock, where each tick of the clock will be an event that the application reacts to. This will show how application state can be used to coordinate and react to events.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This exercise builds on your code from the previous exercise. Either use the same project or make a copy.</p>
			<ol>
				<li value="1">At the command-line prompt, start the ClojureScript REPL:<p class="source-code">lein figwheel</p><p>A browser window should open, inviting you to play a game of Rock, Paper, Scissors.</p></li>
				<li>Add a <strong class="source-inline">:countdown</strong> field to the <strong class="source-inline">app-state</strong> atom:<p class="source-code">(defonce app-state (atom {:computer-choice nil</p><p class="source-code">             :game-state :setup</p><p class="source-code">             :player-choice nil</p><p class="source-code">             :countdown 3}))</p></li>
				<li>Add a validator to the <strong class="source-inline">app-state</strong> to make sure that the <strong class="source-inline">:game-state</strong> field always contains a game phase keyword and that the countdown never goes beyond 3 or below 0:<p class="source-code">(set-validator! app-state #(and</p><p class="source-code">               (&gt;= 3 (:countdown %) 0)</p><p class="source-code">               (#{:setup :waiting :complete} (:game-state %))))</p><p class="callout-heading">Note</p><p class="callout">The greater-than and less-than family of functions all take more than two arguments. This is a convenient way of testing whether a value is between two other values.</p></li>
				<li>Most of the improvements we want to make are going to affect the <strong class="source-inline">:waiting</strong> phase of the game. Let's make a dedicated view, which we'll call the <strong class="source-inline">choices-view</strong> function. It will show two things: the countdown and the list of choices.<p>As a first step, set up the view with the same list of choices as before:</p><p class="source-code">(rum/defc choices-view &lt; rum/reactive []</p><p class="source-code"> [:div.choices-view</p><p class="source-code">  [:div.choices</p><p class="source-code">  [:div "Choose one"</p><p class="source-code">   [:div [:a {:href "#rock"</p><p class="source-code">        :onClick (player-choice :rock)} "Rock"]]</p><p class="source-code">   [:div [:a {:href "#paper"</p><p class="source-code">        :onClick (player-choice :paper)} "Paper"]]</p><p class="source-code">   [:div [:a {:href "#scissors"</p><p class="source-code">        :onClick (player-choice :scissors)} "Scissors"]]]]])</p><p>At the same time, add this new view to <strong class="source-inline">game-view</strong>, instead of the previous list corresponding to the <strong class="source-inline">:waiting</strong> game state:</p><p class="source-code">(rum/defc game-view &lt; rum/reactive []</p><p class="source-code"> (case (:game-state (rum/react app-state))</p><p class="source-code">  :setup</p><p class="source-code">  [:div "Ready to play?"</p><p class="source-code">   [:div [:a {:href "#start"</p><p class="source-code">        :onClick start-game} "Start"]]]</p><p class="source-code">  :waiting</p><p class="source-code">  (choices-view)</p><p class="source-code">  :complete</p><p class="source-code">  (result-view)))</p><p>At this point, the game should still work exactly as before.</p></li>
				<li>Before the countdown reaches zero, the links in the list of choices should be inactive to prevent the player from clicking too soon. Since each link needs to handle two different states, it makes sense to encapsulate that behavior in a component, like this:<p class="source-code">(rum/defc choice-link-view [kw label countdown]</p><p class="source-code"> (if (zero? countdown)</p><p class="source-code">  [:div [:a {:href (str "#" (name kw))</p><p class="source-code">        :on-click (player-choice kw)}</p><p class="source-code">      label]]</p><p class="source-code">  [:div label]))</p><p class="callout-heading">Note</p><p class="callout">Remember to place <strong class="source-inline">choice-link-view</strong> before <strong class="source-inline">choices-view</strong> in the source file.</p><p>The first two arguments simply supply the keyword and the text label necessary for building the links, as before. The <strong class="source-inline">countdown</strong> argument, however, will allow us to determine what should be displayed. If the countdown has reached zero, we display the link. If not, we simply display the label.</p></li>
				<li>We need to update <strong class="source-inline">choices-view</strong> as well:<p class="source-code">(rum/defc choices-view &lt; rum/reactive []</p><p class="source-code"> (let [ready? (= :waiting (:game-state (rum/react app-state)))</p><p class="source-code">    countdown (:countdown (rum/react app-state))]</p><p class="source-code">  [:div.choices-view</p><p class="source-code">   [:div.choices</p><p class="source-code">   [:h3 "Choose one"]</p><p class="source-code">   (choice-link-view :rock "Rock" countdown)</p><p class="source-code">   (choice-link-view :paper "Paper" countdown)</p><p class="source-code">   (choice-link-view :scissors "Scissors" countdown)]]))</p><p>When you try to play the game now, if you click on <strong class="source-inline">Start</strong>, you should see this:</p><div id="_idContainer260" class="IMG---Figure"><img src="image/B14502_12_21.jpg" alt="Figure 12.21: Options available on clicking Start&#13;&#10;"/></div><p class="figure-caption">Figure 12.21: Options available on clicking Start</p></li>
				<li>We also want to display the countdown in this view. Let's make a new component for that too so that we can add a little bit of display logic:<p class="source-code">(rum/defc countdown-view &lt; rum/reactive [countdown]</p><p class="source-code"> [:div.countdown</p><p class="source-code">  [:div.countdown-message</p><p class="source-code">  (if (&gt; countdown 0)</p><p class="source-code">   "Get ready to make your choice..."</p><p class="source-code">   "Go!")]</p><p class="source-code">  [:h1 countdown]])</p><p>And this view can be called from <strong class="source-inline">choices-view</strong> as well:</p><p class="source-code">(rum/defc choices-view &lt; rum/reactive []</p><p class="source-code"> (let [countdown (:countdown (rum/react app-state))]</p><p class="source-code">  [:div.player-choices-view</p><p class="source-code">   (countdown-view countdown)</p><p class="source-code">   [:div.choices</p><p class="source-code">   [:h3 "Choose one"]</p><p class="source-code">   (choice-link-view :rock "Rock" countdown)</p><p class="source-code">   (choice-link-view :paper "Paper" countdown)</p><p class="source-code">   (choice-link-view :scissors "Scissors" countdown)]]))</p><p>If you try to play the game at this point, you should see <strong class="source-inline">3</strong> displayed above the inactive links:</p><div id="_idContainer261" class="IMG---Figure"><img src="image/B14502_12_22.jpg" alt="Figure 12.22: The countdown is there but it's not moving yet&#13;&#10;"/></div><p class="figure-caption">Figure 12.22: The countdown is there but it's not moving yet</p></li>
				<li>For the timing of the countdown, we'll use <strong class="source-inline">setInterval</strong>, which means that we need some JavaScript interop. This function will cause the <strong class="source-inline">:countdown</strong> field to decrement every second:<p class="source-code">(defn start-countdown []</p><p class="source-code"> (js/setInterval #(swap! app-state update :countdown dec) 1000))</p></li>
				<li>The <strong class="source-inline">setInterval</strong> function returns an identifier that we'll need later for canceling the interval. Each time a new game starts, we need to start the interval and record its identifier. These things can be done by the <strong class="source-inline">start-game</strong> function, which we'll update. (For this reason, <strong class="source-inline">start-countdown</strong> will need to be placed before the <strong class="source-inline">start-game</strong> function in your source file.):<p class="source-code">(defn start-game []</p><p class="source-code"> (let [interval (start-countdown)]</p><p class="source-code">  (swap! app-state</p><p class="source-code">      (fn [state]</p><p class="source-code">       (assoc state</p><p class="source-code">          :computer-choice (computer-choice)</p><p class="source-code">          :game-state :waiting</p><p class="source-code">          :countdown 3</p><p class="source-code">          :interval interval)))))</p><p>The <strong class="source-inline">interval</strong> goes into the app-state for later use.</p></li>
				<li>We know that we don't want the countdown to go below 0. We also don't want to start a new interval in a game without canceling the previous interval. After a few games, we would end up with many intervals all trying to update the <strong class="source-inline">:countdown</strong> field.<p>Stopping the interval is easy enough with the <strong class="source-inline">clearInterval</strong> function. But how do we know when it should be called? One solution would be to add a check in the function we passed to <strong class="source-inline">setInterval</strong> in the <strong class="source-inline">start-countdown</strong> function. For this exercise, though, we'll use a watcher:</p><p class="source-code">(add-watch app-state :countdown-zero</p><p class="source-code">      (fn [_k state old new]</p><p class="source-code">       (when (and (= 1 (:countdown old)) (= 0 (:countdown new)))</p><p class="source-code">        (js/clearInterval (:interval new)))))</p><p>We won't ever remove this watcher, but we still need to give it an identifier, for which we use a descriptive keyword. The interesting part of this call to <strong class="source-inline">add-watch</strong> is the anonymous function we provide. This function will be called every time a change occurs in the <strong class="source-inline">app-state</strong> atom. Most of the time, this function will do nothing. The exception, of course, is when the countdown is about to go to zero. In that case, <strong class="source-inline">clearInterval</strong> is called with the interval identifier stored in the atom.</p><p>Now the countdown should work as planned. When it reaches zero, the message changes to <strong class="source-inline">Go!</strong> and the links become active:</p></li>
			</ol>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/B14502_12_23.jpg" alt="Figure 12.23: A successful countdown&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.23: A successful countdown</p>
			<p>This exercise showed us how watchers and validators work. Remember, in Clojure they can be used on all the different kinds of reference types.</p>
			<h2 id="_idParaDest-285">Activity 12.01: A DOM W<a id="_idTextAnchor380"/>hack-a-mole Game</h2>
			<p>After the amazing success of your Rock, Paper, Scissors browser game, you've decided to create an even more ambitious product, based on the classic Whack-a-mole game. Whack-a-mole is an early arcade game. Moles pop up at random from several holes in a table. The player holds a mallet and tries to whack the moles as soon as they appear. When hit, the mole disappears back into its hole until it pops back up again.</p>
			<p>Your version of Whack-a-mole will use DOM elements in a web browser. It might look something like this (if you know some CSS, you're free to make it look a little better):</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/B14502_12_24.jpg" alt="Figure 12.24: Before the game starts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.24: Before the game starts</p>
			<p>Once the player clicks on the <strong class="source-inline">Click to play!</strong> button, the clock starts and the moles, who are actually just HTML <strong class="source-inline">&lt;div&gt;</strong> elements, start to randomly activate:</p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/B14502_12_25.jpg" alt="Figure 12.25: Click on the moles!&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.25: Click on the moles!</p>
			<p>At this point, if the player clicks on a mole, it goes back to the waiting state and a point is added to the player's score. The game stops after a fixed number of seconds, probably 20 or so.</p>
			<p>The behavior of the moles follows these rules: Only two moles are visible at a time. The moles to be made visible are selected randomly. A mole is visible for a fixed duration (2 or 3 seconds, probably) and reverts to the hidden state after that time if the player has not clicked on it.</p>
			<p>To build this game, you should take these basic steps:</p>
			<ol>
				<li value="1">Use the same basic ClojureScript and Rum setup used in the Rock, Paper, Scissors exercises.</li>
				<li>As in the last exercise, use <strong class="source-inline">setInterval</strong> to count down the seconds after the game starts. For more fluidity, it's probably best to use an interval smaller than 1 second. 100 milliseconds is probably about right.</li>
				<li>Use multiple atoms for the various counters that you'll need: the countdown clock (the interval itself), the number of milliseconds remaining in the game, the game state (<strong class="source-inline">:waiting</strong> or <strong class="source-inline">:playing</strong>), and a vector of moles.</li>
				<li>The moles themselves should have two values: their status (<strong class="source-inline">:waiting</strong> or <strong class="source-inline">:live</strong>) and the number of remaining milliseconds remaining if they are in the <strong class="source-inline">:live</strong> state. These values could be contained in a map or a two-item vector tuple.</li>
				<li>Write event handlers for clicks on the <strong class="source-inline">Start</strong> button and on the active moles.</li>
				<li>If you know some CSS, feel free to make the game look better by adding some definitions to <strong class="source-inline">resources/public/css/style.css</strong>.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 738.</p></li>
			</ol>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor381"/>Summary</h1>
			<p>Concurrency, by its very nature, is a complex problem. While it's impossible to cover all the techniques you might need, hopefully, this chapter will provide you with the tools to get started. We covered the usage of <strong class="source-inline">pmap</strong> and <strong class="source-inline">future</strong> for using multiple threads. We also saw Clojure's reference types: var, atoms, agents, and refs. We used atoms to manage state in a browser-based ClojureScript application.</p>
			<p>For each of these topics, there is a lot more that can be said. What you learn further down the road will depend on the kinds of problems you need to solve. Concurrency is one of the areas where the problems will be more diverse than almost any other. Familiarity with Clojure's basic approach to these questions will start you in the right direction when you search for solutions.</p>
			<p>In the next chapter, we will take another big step toward real-world Clojure by learning how to interact with databases.</p>
		</div>
		<div>
			<div id="_idContainer266" class="Basic-Text-Frame">
			</div>
		</div>
	</body></html>