- en: Chapter 4. Exploring Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Views** are an essential part of an application, or, in cases where interaction
    is minimal, they are the means to show what an application is capable of. They
    have the power to increase the number of end users or discourage them completely.
    Views that enhance the user experience are always preferred over those that are
    as complicated as a maze, through which the user struggles to perform a simple
    task. They act as a deciding factor in an application''s success.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building views using Twirl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templating Internals (covers basics of how Twirl works)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into Scala templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **Twirl** template is composed of parameters and content. The following figure
    shows the components of a login page template called `login.scala.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diving into Scala templates](img/3803OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parameters must be declared first since they are used as the parameters
    of the `apply` method of the generated template object. For example, for the `main.scala.html`
    template, shown in the preceding code, the `apply` method will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The template content can be HTML as well as Scala code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at some `defaultpages` (accessible through the object
    `views.html.defaultpages`) bundled along with Play. The default view for this
    action is not implemented; `todo.scala.html` has no template parameters and has
    plain HTML for its content. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the default view for unauthorized, `unauthorized.scala.html`, is
    also a static page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check how the view for action not found in development mode, `devNotFound.scala.html`
    is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the template snippets, the style component has been excluded to focus on
    the Scala code used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is a route file defined, then it lists all the available routes in
    a preformatted block. The methods defined for the type of the template parameter
    can be called even within the template. For example, if `books: Seq[String]` is
    one of the parameters, we can call `@books.length` or `@books.map{...}`, and so
    on, within the template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, a Twirl template can be used within another template. This allows
    us to have reusable chunks of views. For example, supposing we have a main template,
    which is used by all other views, the application''s theme (which includes the
    header, footer, basic layout, and so on) can be updated by tweaking the main template.
    Consider a template `main.scala.html`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Reusing this template will be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Another example is defining *widgets* as templates. These widget templates can
    then be used in multiple views of the application. Similarly, we can also define
    code blocks within our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Building a view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's build a view, which is commonly found in today's web applications. A view
    where the user is asked to select the account they want to log in with, such as
    Google, Facebook, and so on, is given a list of providers with the condition that,
    by default, the first provider should be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that in the list of supported third-party authentications, `otherAuth`
    is passed as a template parameter. The type of `otherAuth` is `Seq[ThirdPartyAuth]`,
    where `ThirdyPartyAuth` is a case class defined to represent any third-party authentication
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this is completed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we used `for` to iterate through all the supported third-party
    authentications. In the templates, we can use two Scala functions, `for` and `if`,
    in addition to those defined within the template and the ones defined on the basis
    of the type of template parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the only important part remaining is to set the default value. We can
    achieve this by using one of the utility methods provided by Twirl the `defining`
    method. Let''s create a variable to check whether the provider is the first one
    or not. We can then have different markups for the two possibilities. If we modify
    our code to accommodate this, we will get this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Generating forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Forms are important in situations where the application requires input from
    users, for example, in the case of registration, login, search, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Play provides helpers to generate a form and wrapper classes to translate the
    form data into a Scala object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll build a user registration form using the form helper provided by
    Play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `@helper.form` is a template provided by Play, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also provide other parameters for the `form` element as a tuple of `Symbol`
    and `String`. The `Symbol` component will become the parameter and its corresponding
    `String` component will be set as its value in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting HTML will now be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is possible due to the `toHtmlArgs` helper method, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we try to register a user, the request body within the action will
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `enctype` parameter is specified, and the request is parsed as `multipartformdata`,
    the request body will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Instead of defining custom methods to take a map so that it results in a corresponding
    model, we can use the `play.api.data.Form` form data helper object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form object aids in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping form data to user-defined models (such as case classes) or tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the data entered to see if it meets the required constraints. This
    can be done for the all of the fields collectively, independently for each field,
    or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling in default values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We might need to have the form data translated into credentials; in this case,
    the class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the registration view to use the form object in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we define a form that creates a credentials object from a form with the
    `loginId` and `password` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We now define the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `register` and `newUser` methods are mapped to `GET /register` and `POST
    /register`, respectively. We pass the form in the view so that when there are
    errors in form validation, they are shown in the view along with the form fields.
    We will see this in detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how this works. When we fill the form and submit, the call goes
    to the `newUser` action. The `signupForm` is a form and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the constructor, which is defined in its companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mapping` method can accept a maximum of 18 arguments. Forms can also be
    defined using the `tuple` method, which will in turn call the `mapping` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, instead of mapping for `signupForm`, you will get this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terms `email` and `nonEmptyText`, which we used while defining the form
    using mapping as well as the tuple, are predefined constraints and are also defined
    in the `Form` object. The following section discusses them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining forms that have a single field, we can use the `single` method
    since the tuple is not defined for a single field, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The method called in our action is `signupForm.bindRequestFrom`. The `bindRequestFrom`
    method takes an implicit request and fills the form with the form data in the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have filled the form, we need to check if it has any errors or not.
    This is where the `fold` method comes in handy, as defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The variable errors and value are from the form constructor. The type of error
    is `Seq[FormError]`, whereas that of the value is `Option[T]`.
  prefs: []
  type: TYPE_NORMAL
- en: We then map the result from `fold` to `BadRequest(formWithErrors)` if the form
    has errors. If it doesn't, we can continue with the handled data submitted through
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints on data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is a common requirement to restrict the form data entered by users with
    one rule or another. For example, checking to ensure that the name field data
    does not contain digits, the age is less than 18 years, if an expired card is
    being used to complete the transaction, and so on. Play provides default constraints,
    which can be used to validate the field data. Using these constraints, we can
    define a form easily as well as restrict the field data in some ways, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The default constraints can be broadly classified into two categories: the
    ones that define a simple `Mapping[T]`, and the ones that consume `Mapping[T]`
    and result in `Mapping[KT]`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Mapping[String]` is transformed into `Mapping[List[String]]`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other constraints that do not fall into either category. They
    are `ignored` and `checked`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ignored` constraint can be used when we do need mapping from the user
    data for that field. For example, fields such as login time or logout time should
    be filled in by an application and not the user. We could use `mapping` in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `checked` constraint can be used when we need to ensure that a particular
    checkbox has been selected by the user. For example, accepting terms and conditions
    of the organization, and so on, in `signupForm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraints of the first category are listed in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint | Results in | Additional properties and their default values
    (if any) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | `Mapping[String]` | `minLength`: 0,`maxLength`: `Int.MaxValue` |'
  prefs: []
  type: TYPE_TB
- en: '| `nonEmptyText` | `Mapping[String]` | `minLength`: 0,`maxLength`: `Int.MaxValue`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `number` | `Mapping[Int]` | `min`: `Int.MinValue`,`max`: `Int.MaxValue`,`strict`:
    `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `longNumber` | `Mapping[Long]` | `min`: `Long.MinValue`,`max`: `Long.MaxValue`,
    strict: `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `bigDecimal` | `Mapping[BigDecimal]` | precision,scale |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | `Mapping[java.util.Date]` | pattern,`timeZone`: `java.util.TimeZone.getDefault`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlDate` | `Mapping[java.sql.Date]` | pattern,`timeZone`: `java.util.TimeZone.getDefault`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jodaDate` | `Mapping[org.joda.time.DateTime]` | pattern,`timeZone`: `org.joda.time.DateTimeZone.getDefault`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jodaLocalDate` | `Mapping[org.joda.time.LocalDate]` | pattern |'
  prefs: []
  type: TYPE_TB
- en: '| `email` | `Mapping[String]` |   |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `Mapping[Boolean]` |   |'
  prefs: []
  type: TYPE_TB
- en: 'This table lists the constraints included in the second category:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Constraint | Results in | Required parameters and their type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `optional` | `Mapping[Option[A]]` | `mapping`: `Mapping[A]` |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | `Mapping[A]` | `mapping`: `Mapping[A]`, value: `A` |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | `Mapping[List[A]]` | `mapping`: `Mapping[A]` |'
  prefs: []
  type: TYPE_TB
- en: '| `seq` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
  prefs: []
  type: TYPE_TB
- en: In addition to these field constraints, we can also define ad hoc and/or custom
    constraints on a field using the `verifying` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance might arise where an application lets users choose their `userName`,
    which can only consist of numbers and alphabet. To ensure that this rule is not
    broken, we can define an ad hoc constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can define a custom constraint using the `Constraint` case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this in a form definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that `nonEmpty`, `minLength`, `maxLength`, `min`, `max`, `pattern`, and
    `email` are predefined constraints. They are defined in the `play.api.data.validation`
    trait. The available constraints can be used as references when defining custom
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when one or more constraints has been broken in the form that has
    been submitted? The `bindFromRequest` method creates a form with errors, which
    we earlier referred to as `formWithErrors`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each violated constraint, an error is saved. An error is represented by
    `FormError`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `key` is the name of the field where a constraint was broken, `message`
    is its corresponding error message and `args` are the arguments, if any, used
    in the message. In the case of constraints defined in multiple fields, the key
    is an empty string and such errors are termed `globalErrors`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The errors in a form for a specific field can be accessed through the `errors`
    method, defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, to access only the first error, we can use the `error` method
    instead. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, how do we access `globalErrors` (that is, an error from a constraint defined
    in multiple fields together)?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the form''s `globalErrors` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want just the first `globalError` method, we can use the `globalError`
    method. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the form-field helpers, field-specific errors are mapped to the
    field and displayed if they''re present. However, if we are not using the form
    helpers, we will need to display the errors, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `globalErrors` method needs to be added to the view explicitly, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Form-field helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, we used the HTML code for the `form` fields, but we
    can also do this using the `form` field helpers provided by Play. We can update
    our `view,@import models.Credentials`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this works. The helper `inputText` is a view defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses the input helper internally, which is also a view and can be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `form` field helpers use an implicit `FieldConstructor`. This field
    constructor is responsible for the HTML rendered. By default, `defaultFieldConstructor`
    is forwarded. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we wish to change the layouts for our `form` fields, we can define a
    custom `FieldConstructor` and pass it to the `form` field helpers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This section attempts to explain how the form helper works; for more examples,
    refer to the Play Framework documentation at [http://www.playframework.com/documentation/2.3.x/ScalaForms](http://www.playframework.com/documentation/2.3.x/ScalaForms).
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the wide reach of the Internet, it is now possible to communicate and
    interact with people from diverse locations. An application that communicates
    with users in one specific language restricts its user base through the use of
    only that language. Internationalization and localization can be used to cater
    to user groups from various regions by removing barriers that arise due to the
    use of a particular language only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build a simple view, which allows us to ask a question. The `views/index.scala.html`
    view file will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `AppController` is a controller and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The main template `views/main.scala.html` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The routes for the application are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we start the application, with the help of a little bit of styling
    (CSS styles), our view looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Internationalization](img/3803OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Supporting views in multiple languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We might want our application to be available in both English and French. Therefore,
    having different views for different languages is a bad idea. This would mean
    that every time the support for a language is included, we would need to define
    all the views in our application in this particular language as well. Using Play's
    *i18n* support, supporting another language can be as simple as adding a file
    that contains translations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we will need to specify the languages supported by our application
    in `conf/application.conf`. Notice that this is commented code in the default
    `conf/application.conf`, which indicates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The format in which the language should be specified is its ISO 639-2 code,
    optionally followed by an ISO 3166-1 alpha-2 country code. You can include French
    as well, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In Play, the translations required for content to be rendered in a particular
    language are called messages. For each language, we need to provide a `conf/messages.lang-code`
    file. If we wish to have common content, we should define it in `conf/messages`;
    this can be quite useful for names, branding, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `messages` file for English called `conf/messages.en`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to update our view to use these messages, in the form of `@(enquiryForm:
    Form[(String, Option[String], String)])(implicit lang: Lang)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the French `messages` file, `conf/messages.fr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Change your browser settings so that you have French (fr) enabled as the primary
    language and run the application. You should be able to see the enquiry view in
    French:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Supporting views in multiple languages](img/3803OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the messages within the Scala code after importing `play.api.i18n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Understanding internationalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use `Messages` (word) in our code, it calls the `apply` method of the
    `play.api.i18n.Messages` object. The `apply` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Play has an internal plugin called the `MessagesPlugin`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin is responsible for loading all the messages and generating a `MessagesApi`
    object, which is later used to fetch the value of a message. So, when we refer
    to a message, it''s fetched from this instance of `MessagesApi`. `MessagesApi`
    and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implicit `lang` parameter is the key to get messages in the accepted language.
  prefs: []
  type: TYPE_NORMAL
- en: Scala templating in Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play supports the use of Scala code within views and also provides a couple
    of helper methods to ease the process of defining a view.
  prefs: []
  type: TYPE_NORMAL
- en: We've created different views till now. Let's see how they are actually rendered.
    Consider the view for the Task Tracker app we saw in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Play"), *Getting Started with Play*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The view has Scala code along with HTML, so how is it rendered correctly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Task Tracker view in a browser without running the Play application.
    The browser renders the page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scala templating in Play](img/3803OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now have a look at how differently it is rendered when you run the Play application!
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Play application is compiled, the route-related files (`routes_reverseRouting.scala`
    and `routes_routing.scala`, `controllers/routes.java`) and Scala views are generated.
    The routes-related files are generated through the **routes compiler**, while
    the Scala views are generated by the **template compiler**. The Scala template
    engine of Play has been extracted to facilitate its use in projects independent
    of Play. The Play Scala template engine is now available as Twirl. According to
    [https://github.com/spray/twirl](https://github.com/spray/twirl), the reason for
    choosing Twirl as the name is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a replacement for the rather unwieldy name "Play framework Scala template
    engine" we were looking for something shorter with a bit of "punch" and liked
    Twirl as a reference to the template languages "magic" character @, which is sometimes
    also called "twirl".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understanding the working of Twirl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Play''s plugin is defined with a dependency on **SbtTwirl**; we can see this
    in the plugin definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to this, there are some SBT keys defined in `defaultSettings` using
    **TwirlKeys**. TwirlKeys exposes some keys, which can be used to customize Twirl
    as per our requirement. The keys that are exposed using TwirlKeys are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`twirlVersion`: This is the Twirl version used for twirl-api dependency (`SettingKey[String]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateFormats`: This defines Twirl template formats (`SettingKey[Map[String,
    String]]`). The default formats available are `html`, `txt`, `xml`, and `js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateImports`: This includes the extra imports used for twirl templates
    (`SettingKey[Seq[String]]`). By default, its value is an empty sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useOldParser`: This uses the original Play template parser (`SettingKey[Boolean]`);
    the value is false by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sourceEncoding`: This includes the source encoding for template files and
    generated Scala files (`TaskKey[String]`). If no encoding is specified in Scala
    compiler options, it uses the UTF-8 encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compileTemplates`: This compiles twirl templates into Scala source files (`TaskKey[Seq[File]]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand this task, let''s see how `twirlSettings` are defined in the
    Twirl plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `compileTemplates` setting gets its value from `compileTemplatesTask.value`.
    The `compileTemplatesTask` in turn returns the result from the `TemplateCompiler.compile`
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`TemplateCompiler.compile` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `compile` method creates the `target/scala-scalaVersion/src_managed` directory
    within the project if it does not already exist. If it exists, then it deletes
    all the files that match the `"*.template.scala"` pattern through the `cleanUp`
    method. After this, the `collectTemplates` method gets `Seq[(File, String, TemplateType)]`
    by searching for files whose names match the `"*.scala.*"` pattern and end with
    a supported extension.
  prefs: []
  type: TYPE_NORMAL
- en: Each object from the result of `collectTemplates` is then passed as an argument
    for `TwirlCompiler.compile`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TwirlCompiler.compile` is responsible for parsing and generating Scala templates
    and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parseAndGenerateCode` method gets the parser and parses the file. The
    resulting parsed `Template` (internal object) is passed on to the `generateFinalCode`
    method. The `generateFinalCode` method is responsible for generating the code.
    Internally, it uses the `generateCode` method, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The result from `parseAndGenerateCode` is written into its corresponding file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check out where we are going to use the file we generated!
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the view defined in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Play"), *Getting Started with Play*; the generated Scala template is similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: So, when we refer to this view in a controller as `views.html.index(Task.all,
    taskForm)`, we are calling the `apply` method of the generated template object
    index.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few issues we can come across while using a Play view:'
  prefs: []
  type: TYPE_NORMAL
- en: The form is not submitted when you click on **Submit** and no errors are displayed
    using `globalErrors`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may be a situation where a particular required field is missing or there
    is a typo in the name of the field. It will not be shown in `globalErrors` but
    if you attempt to display the error for an individual field, `error.required`
    will show up for the missing field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do we need to use Twirl templates for the application's views?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No, Play does not force developers to use Twirl templates for the views. They
    are free to design the views in whichever way they find easy or comfortable. For
    example, this can be done by using Handlebars, Google Closure templates, and so
    on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Does this affect the performance of the application in any way?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No, unless there are no performance flaws in your view definitions, plugging
    it in a Play application will not affect the performance. There are projects that
    use the Play server for their native Android and iOS apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Are there any other templating libraries supported by Play?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No, but there some Play plugins which aid in using other templating mechanisms
    or libraries that are available. Since they are developed by individuals or other
    organizations, check the licensing before using them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although application language configurations have been updated and messages
    added in various languages, the views are only rendered in English. There are
    no errors thrown at runtime and yet it doesn't work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Play to determine the language used from a request, it is required that
    the request should be an implicit one. Ensure that all the defined actions within
    the application make use of implicit requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another possibility can be that the Accept-Language header could be missing.
    This will be added by updating the browser settings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Will a compilation error occur when a message that doesn't have a mapping in
    the language resources is accessed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No, a compilation error occurs if an undefined message is being accessed. You
    can implement this mechanism if required or use something from the open source
    plugins if they're available and meet your requirements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw how to create views using Twirl and the various helper
    methods provided by Play. We have built different kinds of views: reusable templates
    or widgets and forms. We also saw how to support multiple languages in our Play
    application using the built-in i18n API.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to handle data transactions available
    in Play, and also gain insights into how to effectively design your models.
  prefs: []
  type: TYPE_NORMAL
