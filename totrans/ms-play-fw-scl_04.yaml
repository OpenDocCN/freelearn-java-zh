- en: Chapter 4. Exploring Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 探索视图
- en: '**Views** are an essential part of an application, or, in cases where interaction
    is minimal, they are the means to show what an application is capable of. They
    have the power to increase the number of end users or discourage them completely.
    Views that enhance the user experience are always preferred over those that are
    as complicated as a maze, through which the user struggles to perform a simple
    task. They act as a deciding factor in an application''s success.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是应用程序的一个基本组成部分，或者在交互最小的情况下，它们是展示应用程序功能的方式。它们有增加或完全阻止最终用户数量的能力。增强用户体验的视图总是比那些像迷宫一样复杂、用户难以完成简单任务的视图更受欢迎。它们是应用程序成功与否的决定性因素。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building views using Twirl
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twirl构建视图
- en: Generating Form
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成表单
- en: Internationalization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化
- en: Templating Internals (covers basics of how Twirl works)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板内部（涵盖Twirl的工作基本原理）
- en: Diving into Scala templates
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入Scala模板
- en: 'A **Twirl** template is composed of parameters and content. The following figure
    shows the components of a login page template called `login.scala.html`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Twirl**模板由参数和内容组成。以下图显示了名为`login.scala.html`的登录页面模板的组件：'
- en: '![Diving into Scala templates](img/3803OS_04_02.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![深入Scala模板](img/3803OS_04_02.jpg)'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The parameters must be declared first since they are used as the parameters
    of the `apply` method of the generated template object. For example, for the `main.scala.html`
    template, shown in the preceding code, the `apply` method will be:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参数必须首先声明，因为它们被用作生成模板对象的`apply`方法的参数。例如，对于前面代码中显示的`main.scala.html`模板，`apply`方法将是：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The template content can be HTML as well as Scala code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模板内容可以是HTML，也可以是Scala代码。
- en: 'For example, let''s look at some `defaultpages` (accessible through the object
    `views.html.defaultpages`) bundled along with Play. The default view for this
    action is not implemented; `todo.scala.html` has no template parameters and has
    plain HTML for its content. It is defined as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看一些与Play捆绑在一起的`defaultpages`（通过`views.html.defaultpages`对象访问）中的`defaultpages`。对于此操作，默认视图未实现；`todo.scala.html`没有模板参数，其内容是纯HTML。它定义如下：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similarly, the default view for unauthorized, `unauthorized.scala.html`, is
    also a static page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，未授权的默认视图`unauthorized.scala.html`也是一个静态页面。
- en: 'Now, let''s check how the view for action not found in development mode, `devNotFound.scala.html`
    is defined:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查开发模式下找不到操作视图`devNotFound.scala.html`的定义：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the template snippets, the style component has been excluded to focus on
    the Scala code used.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板片段中，已排除样式组件，以专注于使用的Scala代码。
- en: 'If there is a route file defined, then it lists all the available routes in
    a preformatted block. The methods defined for the type of the template parameter
    can be called even within the template. For example, if `books: Seq[String]` is
    one of the parameters, we can call `@books.length` or `@books.map{...}`, and so
    on, within the template.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '如果定义了路由文件，则它将以预格式化的块列出所有可用路由。可以调用为模板参数类型定义的方法，即使在模板内部也可以。例如，如果`books: Seq[String]`是参数之一，我们可以在模板内部调用`@books.length`或`@books.map{...}`等。'
- en: 'Additionally, a Twirl template can be used within another template. This allows
    us to have reusable chunks of views. For example, supposing we have a main template,
    which is used by all other views, the application''s theme (which includes the
    header, footer, basic layout, and so on) can be updated by tweaking the main template.
    Consider a template `main.scala.html`, defined as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Twirl模板可以用于另一个模板中。这允许我们有可重用的视图块。例如，假设我们有一个主模板，它被所有其他视图使用，应用程序的主题（包括页眉、页脚、基本布局等）可以通过调整主模板来更新。考虑以下定义的模板`main.scala.html`：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Reusing this template will be as simple as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用此模板将像以下这样简单：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another example is defining *widgets* as templates. These widget templates can
    then be used in multiple views of the application. Similarly, we can also define
    code blocks within our templates.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是将*小部件*定义为模板。这些小部件模板可以在应用程序的多个视图中使用。同样，我们也可以在我们的模板中定义代码块。
- en: Building a view
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建视图
- en: Let's build a view, which is commonly found in today's web applications. A view
    where the user is asked to select the account they want to log in with, such as
    Google, Facebook, and so on, is given a list of providers with the condition that,
    by default, the first provider should be selected.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个视图，这在今天的Web应用中很常见。一个用户被要求选择他们想要登录的账户的视图，例如Google、Facebook等，提供了一个提供者列表，默认情况下，第一个提供者应该被选中。
- en: Consider that in the list of supported third-party authentications, `otherAuth`
    is passed as a template parameter. The type of `otherAuth` is `Seq[ThirdPartyAuth]`,
    where `ThirdyPartyAuth` is a case class defined to represent any third-party authentication
    API.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在支持的第三方认证列表中，`otherAuth`作为模板参数传递。`otherAuth`的类型是`Seq[ThirdPartyAuth]`，其中`ThirdyPartyAuth`是一个案例类，用于表示任何第三方认证API。
- en: 'So, this is completed as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是以下完成的：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this snippet, we used `for` to iterate through all the supported third-party
    authentications. In the templates, we can use two Scala functions, `for` and `if`,
    in addition to those defined within the template and the ones defined on the basis
    of the type of template parameters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们使用了`for`循环遍历所有受支持的第三方认证。在模板中，我们可以使用两个Scala函数，`for`和`if`，以及模板内部定义的和基于模板参数类型定义的函数。
- en: 'Now, the only important part remaining is to set the default value. We can
    achieve this by using one of the utility methods provided by Twirl the `defining`
    method. Let''s create a variable to check whether the provider is the first one
    or not. We can then have different markups for the two possibilities. If we modify
    our code to accommodate this, we will get this code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的唯一重要部分是设置默认值。我们可以通过使用Twirl提供的`defining`方法之一来实现这一点。让我们创建一个变量来检查提供者是否是第一个。然后我们可以为两种可能性提供不同的标记。如果我们修改我们的代码以适应这一点，我们将得到以下代码：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Generating forms
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成表单
- en: Forms are important in situations where the application requires input from
    users, for example, in the case of registration, login, search, and so on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要从用户那里获取输入的情况下，表单很重要，例如在注册、登录、搜索等情况。
- en: Play provides helpers to generate a form and wrapper classes to translate the
    form data into a Scala object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Play提供了生成表单的辅助工具和将表单数据转换为Scala对象的包装类。
- en: 'Now, we''ll build a user registration form using the form helper provided by
    Play:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Play提供的表单助手构建一个用户注册表单：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, `@helper.form` is a template provided by Play, which is defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@helper.form`是Play提供的一个模板，定义如下：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also provide other parameters for the `form` element as a tuple of `Symbol`
    and `String`. The `Symbol` component will become the parameter and its corresponding
    `String` component will be set as its value in the following way:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`form`元素提供其他参数，作为`Symbol`和`String`的元组。`Symbol`组件将成为参数，其对应的`String`组件将以以下方式设置为它的值：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The resulting HTML will now be as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML现在如下所示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is possible due to the `toHtmlArgs` helper method, defined as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为定义了以下`toHtmlArgs`辅助方法：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when we try to register a user, the request body within the action will
    be:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们尝试注册用户时，动作内的请求体将是：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the `enctype` parameter is specified, and the request is parsed as `multipartformdata`,
    the request body will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`enctype`参数，并且请求被解析为`multipartformdata`，则请求体将如下所示：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of defining custom methods to take a map so that it results in a corresponding
    model, we can use the `play.api.data.Form` form data helper object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要定义自定义方法来接受一个映射，以便它产生相应的模型，我们可以使用`play.api.data.Form`表单数据助手对象。
- en: 'The form object aids in the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表单对象有助于以下：
- en: Mapping form data to user-defined models (such as case classes) or tuples
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表单数据映射到用户定义的模型（如案例类）或元组
- en: Validating the data entered to see if it meets the required constraints. This
    can be done for the all of the fields collectively, independently for each field,
    or both.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入的数据是否满足所需的约束。这可以针对所有字段集体进行，也可以针对每个字段独立进行，或者两者都进行。
- en: Filling in default values.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填写默认值。
- en: 'We might need to have the form data translated into credentials; in this case,
    the class is defined as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要将表单数据转换为凭据；在这种情况下，类定义如下：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can update the registration view to use the form object in the following
    way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将注册视图更新为使用表单对象，如下所示：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we define a form that creates a credentials object from a form with the
    `loginId` and `password` field:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个表单，它从具有 `loginId` 和 `password` 字段的表单创建一个凭据对象：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We now define the following actions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义以下操作：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `register` and `newUser` methods are mapped to `GET /register` and `POST
    /register`, respectively. We pass the form in the view so that when there are
    errors in form validation, they are shown in the view along with the form fields.
    We will see this in detail in the following section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 和 `newUser` 方法分别映射到 `GET /register` 和 `POST /register`。我们将表单传递到视图中，以便在表单验证出错时，它们会与表单字段一起在视图中显示。我们将在下一节中详细看到这一点。'
- en: 'Let us now see how this works. When we fill the form and submit, the call goes
    to the `newUser` action. The `signupForm` is a form and is defined as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。当我们填写表单并提交时，调用将转到 `newUser` 动作。`signupForm` 是一个表单，定义如下：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We used the constructor, which is defined in its companion object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了在其伴随对象中定义的构造函数：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `mapping` method can accept a maximum of 18 arguments. Forms can also be
    defined using the `tuple` method, which will in turn call the `mapping` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapping` 方法可以接受最多 18 个参数。也可以使用 `tuple` 方法来定义表单，这会依次调用 `mapping` 方法：'
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using this, instead of mapping for `signupForm`, you will get this code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方法，而不是为 `signupForm` 映射，你将得到以下代码：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terms `email` and `nonEmptyText`, which we used while defining the form
    using mapping as well as the tuple, are predefined constraints and are also defined
    in the `Form` object. The following section discusses them in detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用映射和元组定义表单时，我们使用的 `email` 和 `nonEmptyText` 术语是预定义约束，并且也在 `Form` 对象中定义。下一节将详细讨论它们。
- en: 'When defining forms that have a single field, we can use the `single` method
    since the tuple is not defined for a single field, as shown here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义只有一个字段的表单时，我们可以使用 `single` 方法，因为元组没有为单个字段定义，如下所示：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method called in our action is `signupForm.bindRequestFrom`. The `bindRequestFrom`
    method takes an implicit request and fills the form with the form data in the
    request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的操作中调用的方法是 `signupForm.bindRequestFrom`。`bindRequestFrom` 方法接受一个隐式请求，并用请求中的表单数据填充表单。
- en: 'Once we have filled the form, we need to check if it has any errors or not.
    This is where the `fold` method comes in handy, as defined here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们填写了表单，我们需要检查它是否有任何错误。这就是 `fold` 方法派上用场的地方，如下定义：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The variable errors and value are from the form constructor. The type of error
    is `Seq[FormError]`, whereas that of the value is `Option[T]`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `errors` 和 `value` 来自表单构造函数。错误类型是 `Seq[FormError]`，而值的类型是 `Option[T]`。
- en: We then map the result from `fold` to `BadRequest(formWithErrors)` if the form
    has errors. If it doesn't, we can continue with the handled data submitted through
    the form.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果表单有错误，我们将 `fold` 的结果映射到 `BadRequest(formWithErrors)`；如果没有错误，我们可以继续处理通过表单提交的数据。
- en: Adding constraints on data
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数据上添加约束
- en: 'It is a common requirement to restrict the form data entered by users with
    one rule or another. For example, checking to ensure that the name field data
    does not contain digits, the age is less than 18 years, if an expired card is
    being used to complete the transaction, and so on. Play provides default constraints,
    which can be used to validate the field data. Using these constraints, we can
    define a form easily as well as restrict the field data in some ways, as shown
    here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 限制用户输入的表单数据，通常需要遵循一个或多个规则。例如，检查姓名字段数据是否不包含数字，年龄是否小于 18 岁，如果使用过期卡完成交易等情况。Play
    提供了默认约束，可用于验证字段数据。使用这些约束，我们可以轻松定义表单，并在某些方面限制字段数据，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The default constraints can be broadly classified into two categories: the
    ones that define a simple `Mapping[T]`, and the ones that consume `Mapping[T]`
    and result in `Mapping[KT]`, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认约束可以大致分为两类：定义简单 `Mapping[T]` 的那些，以及消耗 `Mapping[T]` 并产生 `Mapping[KT]` 的那些，如下所示：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, `Mapping[String]` is transformed into `Mapping[List[String]]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`Mapping[String]` 转换为 `Mapping[List[String]]`。
- en: There are two other constraints that do not fall into either category. They
    are `ignored` and `checked`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种不属于上述任一类的约束。它们是 `ignored` 和 `checked`。
- en: 'The `ignored` constraint can be used when we do need mapping from the user
    data for that field. For example, fields such as login time or logout time should
    be filled in by an application and not the user. We could use `mapping` in this
    way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将该字段的用户数据进行映射时，可以使用`ignored`约束。例如，登录时间或登出时间等字段应由应用程序填写，而不是用户。我们可以这样使用`mapping`：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `checked` constraint can be used when we need to ensure that a particular
    checkbox has been selected by the user. For example, accepting terms and conditions
    of the organization, and so on, in `signupForm`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要确保用户已选中特定的复选框时，可以使用`checked`约束。例如，在`signupForm`中接受组织的条款和条件等，我们可以这样定义：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The constraints of the first category are listed in this table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类约束列在此表中：
- en: '| Constraint | Results in | Additional properties and their default values
    (if any) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 约束 | 结果 | 额外属性及其默认值（如有） |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `text` | `Mapping[String]` | `minLength`: 0,`maxLength`: `Int.MaxValue` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `text` | `Mapping[String]` | `minLength`: 0, `maxLength`: `Int.MaxValue`
    |'
- en: '| `nonEmptyText` | `Mapping[String]` | `minLength`: 0,`maxLength`: `Int.MaxValue`
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `nonEmptyText` | `Mapping[String]` | `minLength`: 0, `maxLength`: `Int.MaxValue`
    |'
- en: '| `number` | `Mapping[Int]` | `min`: `Int.MinValue`,`max`: `Int.MaxValue`,`strict`:
    `false` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `number` | `Mapping[Int]` | `min`: `Int.MinValue`, `max`: `Int.MaxValue`,
    `strict`: `false` |'
- en: '| `longNumber` | `Mapping[Long]` | `min`: `Long.MinValue`,`max`: `Long.MaxValue`,
    strict: `false` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `longNumber` | `Mapping[Long]` | `min`: `Long.MinValue`, `max`: `Long.MaxValue`,
    strict: `false` |'
- en: '| `bigDecimal` | `Mapping[BigDecimal]` | precision,scale |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `bigDecimal` | `Mapping[BigDecimal]` | precision, scale |'
- en: '| `date` | `Mapping[java.util.Date]` | pattern,`timeZone`: `java.util.TimeZone.getDefault`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `date` | `Mapping[java.util.Date]` | pattern, `timeZone`: `java.util.TimeZone.getDefault`
    |'
- en: '| `sqlDate` | `Mapping[java.sql.Date]` | pattern,`timeZone`: `java.util.TimeZone.getDefault`
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `sqlDate` | `Mapping[java.sql.Date]` | pattern, `timeZone`: `java.util.TimeZone.getDefault`
    |'
- en: '| `jodaDate` | `Mapping[org.joda.time.DateTime]` | pattern,`timeZone`: `org.joda.time.DateTimeZone.getDefault`
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `jodaDate` | `Mapping[org.joda.time.DateTime]` | pattern, `timeZone`: `org.joda.time.DateTimeZone.getDefault`
    |'
- en: '| `jodaLocalDate` | `Mapping[org.joda.time.LocalDate]` | pattern |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `jodaLocalDate` | `Mapping[org.joda.time.LocalDate]` | pattern |'
- en: '| `email` | `Mapping[String]` |   |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `email` | `Mapping[String]` | |'
- en: '| `boolean` | `Mapping[Boolean]` |   |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `Mapping[Boolean]` | |'
- en: 'This table lists the constraints included in the second category:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此表列出了第二类中包含的约束：
- en: '| Constraint | Results in | Required parameters and their type |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 约束 | 结果 | 必需的参数及其类型 |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `optional` | `Mapping[Option[A]]` | `mapping`: `Mapping[A]` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `optional` | `Mapping[Option[A]]` | `mapping`: `Mapping[A]` |'
- en: '| `default` | `Mapping[A]` | `mapping`: `Mapping[A]`, value: `A` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `default` | `Mapping[A]` | `mapping`: `Mapping[A]`, value: `A` |'
- en: '| `list` | `Mapping[List[A]]` | `mapping`: `Mapping[A]` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `Mapping[List[A]]` | `mapping`: `Mapping[A]` |'
- en: '| `seq` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `seq` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
- en: '| `set` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `set` | `Mapping[Seq[A]]` | `mapping`: `Mapping[A]` |'
- en: In addition to these field constraints, we can also define ad hoc and/or custom
    constraints on a field using the `verifying` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些字段约束外，我们还可以使用`verifying`方法在字段上定义临时的和/或自定义约束。
- en: 'An instance might arise where an application lets users choose their `userName`,
    which can only consist of numbers and alphabet. To ensure that this rule is not
    broken, we can define an ad hoc constraint:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现应用程序允许用户选择他们的`userName`的情况，该用户名只能由数字和字母组成。为了确保此规则不被违反，我们可以定义一个临时的约束：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Or, we can define a custom constraint using the `Constraint` case class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`Constraint`案例类定义一个自定义约束：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use this in a form definition:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在表单定义中使用此功能：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that `nonEmpty`, `minLength`, `maxLength`, `min`, `max`, `pattern`, and
    `email` are predefined constraints. They are defined in the `play.api.data.validation`
    trait. The available constraints can be used as references when defining custom
    constraints.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nonEmpty`, `minLength`, `maxLength`, `min`, `max`, `pattern`, 和 `email`
    是预定义的约束。它们定义在`play.api.data.validation`特质中。在定义自定义约束时，可以使用可用的约束作为参考。
- en: Handling errors
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: What happens when one or more constraints has been broken in the form that has
    been submitted? The `bindFromRequest` method creates a form with errors, which
    we earlier referred to as `formWithErrors`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单提交中一个或多个约束被违反时，会发生什么？`bindFromRequest`方法创建一个包含错误的表单，我们之前称之为`formWithErrors`。
- en: 'For each violated constraint, an error is saved. An error is represented by
    `FormError`, defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个违反的约束，都会保存一个错误。错误由`FormError`表示，其定义如下：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `key` is the name of the field where a constraint was broken, `message`
    is its corresponding error message and `args` are the arguments, if any, used
    in the message. In the case of constraints defined in multiple fields, the key
    is an empty string and such errors are termed `globalErrors`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`是违反约束的字段名称，`message`是对应的错误信息，`args`是消息中使用的任何参数。在多个字段中定义约束的情况下，`key`是一个空字符串，此类错误被称为`globalErrors`。'
- en: 'The errors in a form for a specific field can be accessed through the `errors`
    method, defined as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过定义的`errors`方法访问特定字段的表单错误：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, to access only the first error, we can use the `error` method
    instead. It is defined as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了只访问第一个错误，我们可以使用`error`方法。它定义如下：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, how do we access `globalErrors` (that is, an error from a constraint defined
    in multiple fields together)?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何访问`globalErrors`（即由多个字段一起定义的约束错误）？
- en: 'We can use the form''s `globalErrors` method, which is defined as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用表单的`globalErrors`方法，它定义如下：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we want just the first `globalError` method, we can use the `globalError`
    method. It is defined as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想获取第一个`globalError`方法，我们可以使用`globalError`方法。它定义如下：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we use the form-field helpers, field-specific errors are mapped to the
    field and displayed if they''re present. However, if we are not using the form
    helpers, we will need to display the errors, as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用表单字段助手时，字段特定的错误会被映射到字段，并在存在时显示。然而，如果我们不使用表单助手，我们需要显示错误，如下所示：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `globalErrors` method needs to be added to the view explicitly, as shown
    here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 需要显式地将`globalErrors`方法添加到视图中，如下所示：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Form-field helpers
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单字段助手
- en: 'In the previous example, we used the HTML code for the `form` fields, but we
    can also do this using the `form` field helpers provided by Play. We can update
    our `view,@import models.Credentials`, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了`form`字段的HTML代码，但也可以使用Play提供的`form`字段助手来完成这项工作。我们可以更新我们的`view,@import
    models.Credentials`，如下所示：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s see how this works. The helper `inputText` is a view defined as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。助手`inputText`是一个如下定义的视图：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It uses the input helper internally, which is also a view and can be defined
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用内部输入助手，这同样也是一个视图，可以定义如下：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Both the `form` field helpers use an implicit `FieldConstructor`. This field
    constructor is responsible for the HTML rendered. By default, `defaultFieldConstructor`
    is forwarded. It is defined as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`form`字段助手都使用隐式的`FieldConstructor`。这个字段构造器负责渲染HTML。默认情况下，`defaultFieldConstructor`被转发。它定义如下：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, if we wish to change the layouts for our `form` fields, we can define a
    custom `FieldConstructor` and pass it to the `form` field helpers, as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想更改`form`字段的布局，我们可以定义一个自定义的`FieldConstructor`并将其传递给`form`字段助手，如下所示：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This section attempts to explain how the form helper works; for more examples,
    refer to the Play Framework documentation at [http://www.playframework.com/documentation/2.3.x/ScalaForms](http://www.playframework.com/documentation/2.3.x/ScalaForms).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节试图解释表单助手是如何工作的；更多示例，请参阅Play框架文档[http://www.playframework.com/documentation/2.3.x/ScalaForms](http://www.playframework.com/documentation/2.3.x/ScalaForms)。
- en: Internationalization
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: Due to the wide reach of the Internet, it is now possible to communicate and
    interact with people from diverse locations. An application that communicates
    with users in one specific language restricts its user base through the use of
    only that language. Internationalization and localization can be used to cater
    to user groups from various regions by removing barriers that arise due to the
    use of a particular language only.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于互联网的广泛覆盖，现在可以与来自不同地区的人们进行沟通和互动。一个只使用一种特定语言与用户沟通的应用程序，通过仅使用该语言来限制其用户基础。国际化本地化可以通过消除由于仅使用特定语言而产生的障碍，来满足来自各个地区的用户群体。
- en: 'Now, let''s build a simple view, which allows us to ask a question. The `views/index.scala.html`
    view file will be similar to the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个简单的视图，它允许我们提出一个问题。`views/index.scala.html`视图文件将类似于以下内容：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, `AppController` is a controller and is defined as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`AppController`是一个控制器，定义如下：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The main template `views/main.scala.html` is defined as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 主模板`views/main.scala.html`定义如下：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The routes for the application are defined as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的路线如下定义：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now when we start the application, with the help of a little bit of styling
    (CSS styles), our view looks similar to this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们启动应用程序时，借助一点样式（CSS样式），我们的视图看起来类似于以下这样：
- en: '![Internationalization](img/3803OS_04_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![国际化](img/3803OS_04_03.jpg)'
- en: Supporting views in multiple languages
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多语言视图
- en: We might want our application to be available in both English and French. Therefore,
    having different views for different languages is a bad idea. This would mean
    that every time the support for a language is included, we would need to define
    all the views in our application in this particular language as well. Using Play's
    *i18n* support, supporting another language can be as simple as adding a file
    that contains translations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望我们的应用程序同时提供英语和法语。因此，为不同的语言提供不同的视图是一个坏主意。这意味着每次添加对一种语言的支持时，我们都需要在我们的应用程序中以这种特定语言定义所有视图。使用Play的*i18n*支持，支持另一种语言可以简单到只需添加一个包含翻译的文件。
- en: 'Firstly, we will need to specify the languages supported by our application
    in `conf/application.conf`. Notice that this is commented code in the default
    `conf/application.conf`, which indicates the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在`conf/application.conf`中指定应用程序支持的语言。请注意，这是默认`conf/application.conf`中的注释代码，表示以下内容：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The format in which the language should be specified is its ISO 639-2 code,
    optionally followed by an ISO 3166-1 alpha-2 country code. You can include French
    as well, as shown here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应指定语言的方式是其ISO 639-2代码，可选地后跟ISO 3166-1 alpha-2国家代码。您还可以包括法语，如下所示：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In Play, the translations required for content to be rendered in a particular
    language are called messages. For each language, we need to provide a `conf/messages.lang-code`
    file. If we wish to have common content, we should define it in `conf/messages`;
    this can be quite useful for names, branding, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在Play中，用于在特定语言中渲染内容的翻译被称为消息。对于每种语言，我们需要提供一个`conf/messages.lang-code`文件。如果我们希望有通用内容，我们应该在`conf/messages`中定义它；这对于名称、品牌等非常有用。
- en: 'Let''s create a `messages` file for English called `conf/messages.en`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`conf/messages.en`的英语`messages`文件：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we need to update our view to use these messages, in the form of `@(enquiryForm:
    Form[(String, Option[String], String)])(implicit lang: Lang)`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们需要更新我们的视图以使用这些消息，形式为`@(enquiryForm: Form[(String, Option[String], String)])(implicit
    lang: Lang)`：'
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s add the French `messages` file, `conf/messages.fr`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加法语`messages`文件，`conf/messages.fr`：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change your browser settings so that you have French (fr) enabled as the primary
    language and run the application. You should be able to see the enquiry view in
    French:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 修改您的浏览器设置，以便将法语（fr）设置为首选语言并运行应用程序。您应该能够看到法语查询视图：
- en: '![Supporting views in multiple languages](img/3803OS_04_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![支持多语言视图](img/3803OS_04_04.jpg)'
- en: 'We can also use the messages within the Scala code after importing `play.api.i18n`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在导入`play.api.i18n`之后在Scala代码中使用这些消息：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Understanding internationalization
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解国际化
- en: 'When we use `Messages` (word) in our code, it calls the `apply` method of the
    `play.api.i18n.Messages` object. The `apply` method is defined as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中使用`Messages`（单词）时，它调用`play.api.i18n.Messages`对象的`apply`方法。`apply`方法定义如下：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Play has an internal plugin called the `MessagesPlugin`, defined as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Play有一个内部插件，称为`MessagesPlugin`，定义如下：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This plugin is responsible for loading all the messages and generating a `MessagesApi`
    object, which is later used to fetch the value of a message. So, when we refer
    to a message, it''s fetched from this instance of `MessagesApi`. `MessagesApi`
    and is defined as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件负责加载所有消息并生成一个`MessagesApi`对象，该对象随后用于获取消息的值。因此，当我们提到一个消息时，它就是从这个`MessagesApi`实例中获取的。`MessagesApi`的定义如下：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The implicit `lang` parameter is the key to get messages in the accepted language.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式的`lang`参数是获取接受语言消息的关键。
- en: Scala templating in Play
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Play中的Scala模板
- en: Play supports the use of Scala code within views and also provides a couple
    of helper methods to ease the process of defining a view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Play支持在视图中使用Scala代码，并提供了一些辅助方法来简化定义视图的过程。
- en: We've created different views till now. Let's see how they are actually rendered.
    Consider the view for the Task Tracker app we saw in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Play"), *Getting Started with Play*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了不同的视图。让我们看看它们是如何实际渲染的。考虑我们在[第1章](ch01.html "第1章。Play入门")中看到的任务跟踪器应用程序的视图，*Play入门*。
- en: '[PRE57]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The view has Scala code along with HTML, so how is it rendered correctly?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 视图包含Scala代码和HTML，那么它是如何正确渲染的呢？
- en: 'Open the Task Tracker view in a browser without running the Play application.
    The browser renders the page as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开任务跟踪器视图，而不运行Play应用程序。浏览器将页面渲染如下：
- en: '![Scala templating in Play](img/3803OS_04_01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![Play中的Scala模板](img/3803OS_04_01.jpg)'
- en: Now have a look at how differently it is rendered when you run the Play application!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看当你运行Play应用程序时，它如何以不同的方式渲染！
- en: 'When a Play application is compiled, the route-related files (`routes_reverseRouting.scala`
    and `routes_routing.scala`, `controllers/routes.java`) and Scala views are generated.
    The routes-related files are generated through the **routes compiler**, while
    the Scala views are generated by the **template compiler**. The Scala template
    engine of Play has been extracted to facilitate its use in projects independent
    of Play. The Play Scala template engine is now available as Twirl. According to
    [https://github.com/spray/twirl](https://github.com/spray/twirl), the reason for
    choosing Twirl as the name is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当Play应用程序编译时，会生成与路由相关的文件（`routes_reverseRouting.scala`和`routes_routing.scala`，`controllers/routes.java`）和Scala视图。路由相关的文件是通过**路由编译器**生成的，而Scala视图是通过**模板编译器**生成的。Play的Scala模板引擎已被提取出来，以方便在独立于Play的项目中使用。Play的Scala模板引擎现在作为Twirl提供。根据[https://github.com/spray/twirl](https://github.com/spray/twirl)，选择Twirl作为名称的原因是：
- en: '*As a replacement for the rather unwieldy name "Play framework Scala template
    engine" we were looking for something shorter with a bit of "punch" and liked
    Twirl as a reference to the template languages "magic" character @, which is sometimes
    also called "twirl".*'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*作为“Play框架Scala模板引擎”这个相对繁琐的名称的替代，我们寻找一个更短且带有“冲击力”的名称，并喜欢将Twirl作为对模板语言“魔法”字符@的参考，该字符有时也被称为“twirl”。*'
- en: Understanding the working of Twirl
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Twirl的工作原理
- en: 'Play''s plugin is defined with a dependency on **SbtTwirl**; we can see this
    in the plugin definition:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Play的插件通过依赖**SbtTwirl**来定义；我们可以在插件定义中看到这一点：
- en: '[PRE58]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In addition to this, there are some SBT keys defined in `defaultSettings` using
    **TwirlKeys**. TwirlKeys exposes some keys, which can be used to customize Twirl
    as per our requirement. The keys that are exposed using TwirlKeys are:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些使用**TwirlKeys**在`defaultSettings`中定义的SBT键。TwirlKeys公开了一些键，可以用来根据我们的要求自定义Twirl。使用TwirlKeys公开的键包括：
- en: '`twirlVersion`: This is the Twirl version used for twirl-api dependency (`SettingKey[String]`).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`twirlVersion`: 这是用于twirl-api依赖的Twirl版本（`SettingKey[String]`）。'
- en: '`templateFormats`: This defines Twirl template formats (`SettingKey[Map[String,
    String]]`). The default formats available are `html`, `txt`, `xml`, and `js`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateFormats`: 这定义了Twirl模板格式（`SettingKey[Map[String, String]]`）。默认可用的格式有`html`、`txt`、`xml`和`js`。'
- en: '`templateImports`: This includes the extra imports used for twirl templates
    (`SettingKey[Seq[String]]`). By default, its value is an empty sequence.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateImports`: 这包括用于Twirl模板的额外导入（`SettingKey[Seq[String]]`）。默认值是一个空序列。'
- en: '`useOldParser`: This uses the original Play template parser (`SettingKey[Boolean]`);
    the value is false by default.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useOldParser`: 这使用原始的Play模板解析器（`SettingKey[Boolean]`）；默认值为false。'
- en: '`sourceEncoding`: This includes the source encoding for template files and
    generated Scala files (`TaskKey[String]`). If no encoding is specified in Scala
    compiler options, it uses the UTF-8 encoding.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sourceEncoding`: 这包括模板文件和生成的Scala文件的源编码（`TaskKey[String]`）。如果Scala编译器选项中没有指定编码，则使用UTF-8编码。'
- en: '`compileTemplates`: This compiles twirl templates into Scala source files (`TaskKey[Seq[File]]`).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compileTemplates`: 这将Twirl模板编译成Scala源文件（`TaskKey[Seq[File]]`）。'
- en: 'To understand this task, let''s see how `twirlSettings` are defined in the
    Twirl plugin:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个任务，让我们看看Twirl插件中如何定义`twirlSettings`：
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `compileTemplates` setting gets its value from `compileTemplatesTask.value`.
    The `compileTemplatesTask` in turn returns the result from the `TemplateCompiler.compile`
    method, as shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`compileTemplates`设置从`compileTemplatesTask.value`获取其值。`compileTemplatesTask`反过来返回`TemplateCompiler.compile`方法的结果，如下所示：'
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`TemplateCompiler.compile` is defined as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`TemplateCompiler.compile`的定义如下：'
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `compile` method creates the `target/scala-scalaVersion/src_managed` directory
    within the project if it does not already exist. If it exists, then it deletes
    all the files that match the `"*.template.scala"` pattern through the `cleanUp`
    method. After this, the `collectTemplates` method gets `Seq[(File, String, TemplateType)]`
    by searching for files whose names match the `"*.scala.*"` pattern and end with
    a supported extension.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果项目内不存在，`compile` 方法将在项目中创建 `target/scala-scalaVersion/src_managed` 目录。如果已存在，则通过
    `cleanUp` 方法删除所有匹配 `"*.template.scala"` 模式的文件。之后，`collectTemplates` 方法通过搜索名称匹配
    `"*.scala.*"` 模式且以受支持扩展名结尾的文件来获取 `Seq[(File, String, TemplateType)]`。
- en: Each object from the result of `collectTemplates` is then passed as an argument
    for `TwirlCompiler.compile`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`collectTemplates` 的结果中的每个对象都作为 `TwirlCompiler.compile` 的参数传递。
- en: '`TwirlCompiler.compile` is responsible for parsing and generating Scala templates
    and is defined as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwirlCompiler.compile` 负责解析和生成 Scala 模板，其定义如下：'
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `parseAndGenerateCode` method gets the parser and parses the file. The
    resulting parsed `Template` (internal object) is passed on to the `generateFinalCode`
    method. The `generateFinalCode` method is responsible for generating the code.
    Internally, it uses the `generateCode` method, which is defined as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseAndGenerateCode` 方法获取解析器并解析文件。生成的解析 `Template`（内部对象）随后传递给 `generateFinalCode`
    方法。`generateFinalCode` 方法负责生成代码。内部，它使用 `generateCode` 方法，其定义如下：'
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The result from `parseAndGenerateCode` is written into its corresponding file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseAndGenerateCode` 的结果写入其对应的文件。'
- en: Let's check out where we are going to use the file we generated!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们将要使用我们生成的文件的地方！
- en: 'Consider the view defined in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Play"), *Getting Started with Play*; the generated Scala template is similar
    to the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到定义在[第 1 章](ch01.html "第 1 章。Play 入门")中的视图，*Play 入门*；生成的 Scala 模板类似于以下内容：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So, when we refer to this view in a controller as `views.html.index(Task.all,
    taskForm)`, we are calling the `apply` method of the generated template object
    index.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们以 `views.html.index(Task.all, taskForm)` 的方式在控制器中引用此视图时，我们正在调用生成的模板对象
    index 的 `apply` 方法。
- en: Troubleshooting
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除
- en: 'Here are a few issues we can come across while using a Play view:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Play 视图时，我们可能会遇到以下一些问题：
- en: The form is not submitted when you click on **Submit** and no errors are displayed
    using `globalErrors`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你点击 **提交** 时，表单没有提交，并且没有使用 `globalErrors` 显示错误。
- en: There may be a situation where a particular required field is missing or there
    is a typo in the name of the field. It will not be shown in `globalErrors` but
    if you attempt to display the error for an individual field, `error.required`
    will show up for the missing field.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能存在一种情况，某个特定字段缺失或字段名称有误。它不会在 `globalErrors` 中显示，但如果尝试显示单个字段的错误，`error.required`
    将会显示缺失的字段。
- en: Do we need to use Twirl templates for the application's views?
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否需要为应用程序的视图使用 Twirl 模板？
- en: No, Play does not force developers to use Twirl templates for the views. They
    are free to design the views in whichever way they find easy or comfortable. For
    example, this can be done by using Handlebars, Google Closure templates, and so
    on.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不，Play 不会强迫开发者为视图使用 Twirl 模板。他们可以自由地以他们认为简单或舒适的方式设计视图。例如，这可以通过使用 Handlebars、Google
    Closure 模板等方式完成。
- en: Does this affect the performance of the application in any way?
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是否以任何方式影响了应用程序的性能？
- en: No, unless there are no performance flaws in your view definitions, plugging
    it in a Play application will not affect the performance. There are projects that
    use the Play server for their native Android and iOS apps.
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不，除非你的视图定义没有性能缺陷，否则将其插入 Play 应用程序不会影响性能。有一些项目使用 Play 服务器作为它们的原生 Android 和 iOS
    应用程序。
- en: Are there any other templating libraries supported by Play?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Play 是否支持其他模板库？
- en: No, but there some Play plugins which aid in using other templating mechanisms
    or libraries that are available. Since they are developed by individuals or other
    organizations, check the licensing before using them.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不，但有一些 Play 插件可以帮助使用其他可用的模板机制或库。由于它们是由个人或其他组织开发的，所以在使用之前请检查它们的许可协议。
- en: Although application language configurations have been updated and messages
    added in various languages, the views are only rendered in English. There are
    no errors thrown at runtime and yet it doesn't work as expected.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管应用程序的语言配置已经更新，并添加了各种语言的消息，但视图只以英语渲染。在运行时没有抛出错误，但仍然没有达到预期的效果。
- en: For Play to determine the language used from a request, it is required that
    the request should be an implicit one. Ensure that all the defined actions within
    the application make use of implicit requests.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了让Play从请求中确定使用的语言，要求请求必须是隐式的。确保应用程序中定义的所有操作都使用隐式请求。
- en: Another possibility can be that the Accept-Language header could be missing.
    This will be added by updating the browser settings.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种可能性是Accept-Language头可能缺失。这可以通过更新浏览器设置来添加。
- en: Will a compilation error occur when a message that doesn't have a mapping in
    the language resources is accessed?
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问一个在语言资源中没有映射的消息时，会发生编译错误吗？
- en: No, a compilation error occurs if an undefined message is being accessed. You
    can implement this mechanism if required or use something from the open source
    plugins if they're available and meet your requirements.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不，如果访问了一个未定义的消息，将会发生编译错误。如果需要，您可以实现这个机制，或者如果可用并且满足您的要求，可以使用开源插件中的某些功能。
- en: Summary
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw how to create views using Twirl and the various helper
    methods provided by Play. We have built different kinds of views: reusable templates
    or widgets and forms. We also saw how to support multiple languages in our Play
    application using the built-in i18n API.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Twirl和Play提供的各种辅助方法来创建视图。我们构建了不同类型的视图：可重用的模板或小部件和表单。我们还看到了如何使用内置的i18n
    API在我们的Play应用程序中支持多种语言。
- en: In the next chapter, we will cover how to handle data transactions available
    in Play, and also gain insights into how to effectively design your models.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何在Play中处理数据事务，并深入了解如何有效地设计您的模型。
