- en: Chapter 3. Building JSF Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。构建JSF表单
- en: '|   | *"It''s the whole thing. The way something actually works on so many
    different levels. Ultimately, of course, design defines so much of our experiences."*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"这是全部。某物实际上在许多不同层面上是如何工作的。最终，当然，设计定义了我们经历的大部分内容。" |   |'
- en: '|   | --*Sir Jony Ive, Senior Vice President of Design, Apple USA* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*苹果美国设计高级副总裁乔尼·艾夫* |'
- en: JavaServer Faces is an example of a component-oriented web application framework,
    as opposed to Java EE 8 MVC (See [Chapter 9](part0087.xhtml#aid-2IV0U1 "Chapter 9. Java
    EE MVC Framework"), *Java EE MVC Framework*), WebWork, or Apache Struts, which
    are known as request-oriented web application frameworks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaServer Faces是一个面向组件的Web应用程序框架的例子，与Java EE 8 MVC（见[第9章](part0087.xhtml#aid-2IV0U1
    "第9章。Java EE MVC框架")，*Java EE MVC框架*）、WebWork或Apache Struts相对，后者被称为请求导向的Web应用程序框架。
- en: A request-oriented framework is one where the information flow is from the web
    request to the response. Such frameworks provide you with an ability and structure
    above the `javax.servlet.http.HttpServletRequest` and `javax.servlet.http.HttpServletResponse`
    objects, but there are no special user interface components. With additional help,
    the application user must program the mapping of the parameters and attributes
    to the data entity models. The developer, therefore, has to write parsing logic.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请求导向的框架是指信息流从网络请求到响应。这样的框架为你提供了在`javax.servlet.http.HttpServletRequest`和`javax.servlet.http.HttpServletResponse`对象之上的能力和结构，但没有特殊用户界面组件。因此，应用程序用户必须编写将参数和属性映射到数据实体模型的程序。因此，开发者必须编写解析逻辑。
- en: It is important to understand that component-oriented frameworks, such as JSF,
    have their detractors. The quick inspection of the code resembles the components
    found in a standalone client such as Java Swing or even JavaFX, but the very same
    `HttpServletRequest` and `HttpServletResponse` lurk behind the scenes. Hence,
    a competent JSF developer has to be aware of the Servlet API and underlying servlet
    scopes. This was a valid criticism in 2004, and in the digital marketing age,
    a digital developer has to know not only Servlet, but also we can presume that
    they would be open to learning other technologies such as JavaScript. Based on
    the knowledge obtained from [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer
    Faces Lifecycle"), *JavaServer Faces Lifecycle*, we will learn about building
    the JSF forms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要，即面向组件的框架，如JSF，也有其批评者。代码的快速检查类似于在Java Swing或JavaFX等独立客户端中找到的组件，但同样的`HttpServletRequest`和`HttpServletResponse`隐藏在幕后。因此，一个合格的JSF开发者必须了解Servlet
    API和底层的servlet作用域。这在2004年是一个有效的批评，在数字营销时代，数字开发者不仅要了解Servlet，我们还可以假设他们愿意学习其他技术，如JavaScript。基于从[第2章](part0025.xhtml#aid-NQU22
    "第2章。JavaServer Faces生命周期")中获得的知识，我们将学习如何构建JSF表单。
- en: Create, Retrieve, Update, and Delete
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、检索、更新和删除
- en: 'In this chapter, we will solve an everyday problem with JSF. The Java EE framework
    and enterprise application are about solving data entry issues. Unlike social
    networking software that is built with a different architecture and non-functional
    requirements such as scalability, performance, statelessness, and eventual consistency,
    Java EE applications are designed for stateful work flows, as shown in the following
    screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用JSF解决一个日常问题。Java EE框架和企业应用程序主要是为了解决数据录入问题。与使用不同架构和非功能性需求（如可伸缩性、性能、无状态和最终一致性）构建的社交网络软件不同，Java
    EE应用程序是为有状态的工作流程设计的，如下面的截图所示：
- en: '![Create, Retrieve, Update, and Delete](img/image00379.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![创建、检索、更新和删除](img/image00379.jpeg)'
- en: Screenshot of the page view to create contact details
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 页面视图截图以创建联系详情
- en: The preceding screenshot is the JSF application, `jsf-crud`, which shows the
    create contact details form.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是JSF应用程序`jsf-crud`，显示了创建联系详情表单。
- en: As a reminder, you can find the entire code for this application with the book's
    source code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，你可以通过本书的源代码找到这个应用程序的完整代码。
- en: Typically, an enterprise application captures the information from a web user,
    stores it in a data store, and allows this information to be retrieved and edited.
    There is usually an option to delete the user's information. In software engineering,
    we call this idiom Create, Retrieve, Update, and Delete (CRUD).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，企业应用程序从网络用户那里捕获信息，将其存储在数据存储中，并允许检索和编辑这些信息。通常有一个选项可以删除用户信息。在软件工程中，我们称这种习语为创建、检索、更新和删除（CRUD）。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What constitutes the actual deletion of the user and customer data is a matter
    that ultimately affects the business owners who are under the pressure to conform
    to the local and international laws that define privacy and data protection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构成实际删除用户和客户数据的是影响业务所有者的一个最终问题，他们面临着遵守定义隐私和数据保护的本地和国际法律的压力。
- en: A basic create entity JSF form
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的创建实体 JSF 表单
- en: Let's create a basic form that captures the user's name, e-mail address, and
    date of birth. We will write this code using HTML5 and take advantage of Bootstrap
    for the modern day CSS and JavaScript. Refer to [http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的表单，用于捕获用户的姓名、电子邮件地址和出生日期。我们将使用 HTML5 编写此代码，并利用 Bootstrap 的现代 CSS 和
    JavaScript。请参阅 [http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/)。
- en: 'The following is the JSF Facelet view, `createContact.xhtml`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 JSF Facelet 视图，`createContact.xhtml`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should already recognize the `<h:head>` and `<h:body>` JSF custom tags.
    As the type is a Facelet view, (`*.xhtml`), the document must actually be well-formed
    like an XML document. You should have noticed that certain HTML5 element tags
    such as `<meta>` are closed and completed; the XHTML document must be well-formed
    in JSF.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经认识 `<h:head>` 和 `<h:body>` JSF 自定义标签了。由于类型是 Facelet 视图（`*.xhtml`），文档实际上必须像
    XML 文档一样具有良好的格式。你应该已经注意到某些 HTML5 元素标签，如 `<meta>`，已经被关闭并完成；XHTML 文档在 JSF 中必须具有良好的格式。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Always close the XHTML elements**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终关闭 XHTML 元素**'
- en: The typical e-commerce application has web pages with standard HTML with the
    `<meta>`, `<link>`, and `<br>` tags. In the XHTML and Facelet views, these tags,
    which web designers normally leave open and hanging, must be closed. **Extensible
    Mark-up Language** (**XML**) is less forgiving and XHTML, which is derived from
    XML, must be well-formed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的电子商务应用程序具有带有标准 HTML 的网页，包括 `<meta>`、`<link>` 和 `<br>` 标签。在 XHTML 和 Facelet
    视图中，这些标签，通常是网页设计师留下开放和悬空的，必须关闭。**可扩展标记语言**（**XML**）不太宽容，而由 XML 衍生的 XHTML 必须具有良好的格式。
- en: The new `<h:form>` tag is a JSF custom tag that corresponds to the HTML form
    element. A JSF form element shares many of the attributes of the HTML partner.
    You can see that the `id` attribute is just the same. However, instead of the
    `class` attribute, we have the `styleClass` attribute in JSF, because in Java,
    the `java.lang.Object.getClass()` method is reserved and therefore, cannot be
    overridden.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `<h:form>` 标签是 JSF 自定义标签，对应于 HTML 表单元素。JSF 表单元素与 HTML 对应元素共享许多属性。你可以看到 `id`
    属性是一样的。然而，在 JSF 中，我们使用 `styleClass` 属性而不是 `class` 属性，因为在 Java 中，`java.lang.Object.getClass()`
    方法是保留的，因此不能被重写。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**What is the JSF request context path expression?**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSF 请求上下文路径表达式是什么？**'
- en: 'The curious markup around the links to the style sheets, JavaScript, and other
    resources is the expression language: `#{request.contextPath}`. The expression
    reference ensures that the web application path is added to the URL of the JSF
    resources. Bootstrap CSS itself relies on the font glyph icons in a particular
    folder. The JSF images, JavaScript module files, and CSS files should be placed
    in the resources folder of the web root.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕样式表、JavaScript 和其他资源的链接周围的标记是表达式语言：`#{request.contextPath}`。表达式引用确保将 Web 应用程序路径添加到
    JSF 资源的 URL 中。Bootstrap CSS 本身依赖于特定文件夹中的字体图标。JSF 图像、JavaScript 模块文件和 CSS 文件应放置在
    Web 根目录的资源文件夹中。
- en: The `p:role` attribute is an example of the JSF `passthrough` attribute, which
    informs the JSF render kit to send through the key and value to the rendered output.
    The `passthrough` attributes are key additions in JSF 2.2, which is a part of
    Java EE 7\. They allow JSF to play well with the recent HTML5 frameworks such
    as Bootstrap and Foundation ([http://foundation.zurb.com/](http://foundation.zurb.com/)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`p:role` 属性是 JSF `passthrough` 属性的一个例子，它通知 JSF 渲染器将键和值发送到渲染输出。`passthrough`
    属性是 JSF 2.2 的一个重要新增功能，它是 Java EE 7 的一部分。它们允许 JSF 与最近的 HTML5 框架（如 Bootstrap 和 Foundation）良好地协同工作（[http://foundation.zurb.com/](http://foundation.zurb.com/)）。'
- en: 'Here is an extract of the rendered HTML source output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是渲染的 HTML 源代码的摘录：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: JSF was implemented before Bootstrap was created in Twitter. How could the JSF
    designer retrofit the framework in order to be compatible with the recent HTML5,
    CSS3, and JavaScript innovations? This is where the `passthrough` attribute helps.
    By declaring the XML namespace in XHTML with the URI [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough).
    We can enable the feature for the page view. As you can see, the attribute name
    and value, `role="form"`, is simply passed through to the output. The `passthrough`
    attributes allow JSF to easily handle the HTML5 features such as placeholders
    in the text input fields, which we will exploit from now onwards.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JSF是在Twitter创建Bootstrap之前实现的。JSF设计者如何将框架改造以兼容最近的HTML5、CSS3和JavaScript创新？这就是`passthrough`属性发挥作用的地方。通过在XHTML中声明XML命名空间URI
    [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough)，我们可以为页面视图启用该功能。正如你所见，属性名称和值`role="form"`简单地传递到输出中。`passthrough`属性允许JSF轻松处理HTML5功能，如文本输入字段中的占位符，我们将从现在开始利用这些功能。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are brand new to web development, you might be scared of markup that
    appears to be overcomplicated. There are lots and lots of DIV HTML elements, which
    are often created by page designers and Interface Developers. This is the historical
    effect and just the way that HTML and the web has evolved over time. The practices
    of 2002 have no bearing on 2016\. I recommend that you read the [Appendix C](part0104.xhtml#aid-335QG1
    "Appendix C. Agile Performance – Working inside Digital Teams"), *Agile Performance
    – Working inside Digital Teams*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Web开发，你可能会对看起来过于复杂的标记感到害怕。有很多很多由页面设计师和界面开发者创建的DIV HTML元素。这是历史效应，也是HTML和Web随时间演变的方式。2002年的做法与2016年无关。我建议你阅读[附录C](part0104.xhtml#aid-335QG1
    "附录C. 敏捷性能 – 在数字团队中工作")，*敏捷性能 – 在数字团队中工作*。
- en: 'Let''s take a deeper look at `<h:form>` and fill in the missing details. Here
    is the extracted code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看`<h:form>`并填补缺失的细节。以下是提取的代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This form is built using the Bootstrap CSS style, but we will ignore the extraneous
    details and concentrate purely on the JSF custom tags.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单使用Bootstrap CSS样式构建，但我们将忽略无关的细节，纯粹关注JSF自定义标签。
- en: The `<h:selectOneMenu>` tag is a JSF custom tag that corresponds to the HTML
    form select element. The `<f:selectItem>` tag corresponds to the HTML form select
    option element. The `<h:inputText>` tag corresponds to the HTML form input element.
    The `<h:selectBooleanCheckbox>` tag is a special custom tag to represent the HTML
    select with only one checkbox element. Finally, `<h:commandButton>` represents
    the HTML form submit element.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:selectOneMenu>`标签是JSF自定义标签，对应于HTML表单选择元素。《f:selectItem>`标签对应于HTML表单选择选项元素。《h:inputText>`标签对应于HTML表单输入元素。《h:selectBooleanCheckbox>`标签是一个特殊自定义标签，用于表示只有一个复选框元素的HTML选择。《h:commandButton>`代表HTML表单提交元素。'
- en: The JSF HTML output label
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSF HTML输出标签
- en: 'The `<h:outputLabel>` tag renders the HTML form label element in the following
    way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:outputLabel>`标签以以下方式渲染HTML表单标签元素：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The developers should prefer this tag in conjunction with the other associated
    JSF form input tags because the special `for` attribute targets the correct sugared
    identifier for the element.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应该优先选择此标签与其他相关JSF表单输入标签一起使用，因为特殊的`for`属性针对的是元素的正确糖化标识符。
- en: 'Here is the rendered output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染的输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could have written the tag using the value attribute, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用value属性来编写标签，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also possible to take advantage of internationalization at this point;
    so just for illustration, we could rewrite the page content as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，也可以利用国际化；所以为了说明，我们可以将页面内容重写如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For more information about internationalization and resource bundles in JSF,
    please see the [Appendix A](part0093.xhtml#aid-2OM4A1 "Appendix A. JSF with HTML5,
    Resources, and Faces Flows"), *JSF with HTML5, Resources, and Faces Flows*. Let's
    move on to the input fields.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JSF中国际化和资源包的更多信息，请参阅[附录A](part0093.xhtml#aid-2OM4A1 "附录A. JSF与HTML5、资源和Faces流")，*JSF与HTML5、资源和Faces流*。让我们继续到输入字段。
- en: The JSF HTML input text
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSF HTML输入文本
- en: 'The `<h:inputText>` tag allows data to be entered in the form like text, as
    shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:inputText>`标签允许以文本等形式在表单中输入数据，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The value attribute represents a JSF expression language, and the clue is that
    the evaluation string starts with a hash character. The Expression Language value
    references a scoped backing bean `ContactDetailController.java` with the name
    of `contactDetailController`. In JSF 2.2, there are now convenience attributes
    to support the HTML5 support so that the standard `id`, `class`, and `placeholder`
    attributes work as expected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值属性代表一个JSF表达式语言，线索是评估字符串以哈希字符开头。表达式语言值引用具有 `contactDetailController` 名称的具有作用域的后端Bean
    `ContactDetailController.java`。在JSF 2.2中，现在有便利属性来支持HTML5支持，以便标准的 `id`、`class`
    和 `placeholder` 属性按预期工作。
- en: 'The rendered output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染输出如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the sugared `createContactDetails:firstName` identifier matches the
    output of the `<h:outputLabel>` tag.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，简化的 `createContactDetails:firstName` 标识符与 `<h:outputLabel>` 标签的输出相匹配。
- en: The JSF HTML select one menu
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSF HTML 选择单菜单
- en: The `<h:selectOneMenu>` tag generates a single select drop-down list. In fact,
    it is a part of a family of selection type custom tags. See *JSF HTML select Boolean
    checkbox* in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:selectOneMenu>` 标签生成一个单选下拉列表。实际上，它是选择类型自定义标签家族的一部分。参见下一节中的 *JSF HTML 选择布尔复选框*。'
- en: 'In the code, we have the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们有以下代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<h:selectOneMenu>` tag corresponds to an HTML Form select tag The `value`
    attribute is again a JSF expression language string.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:selectOneMenu>` 标签对应于HTML表单选择标签。`value` 属性再次是一个JSF表达式语言字符串。'
- en: In JSF, we can use another new custom tag, `<f:selectItem>`, which adds a child
    javax.faces.component.UISelectItem to the nearest parent UI component. The `<f:selectItem>`
    tag accepts an `itemLabel` and `itemValue` attribute. If you set the `itemValue`
    and do not specify the `itemLabel`, then the value becomes the label. So, for
    the first item, the option is set to `--` but the value submitted to the form
    is a blank string because we want to hint to the user that there is a value that
    ought be chosen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF中，我们可以使用另一个新的自定义标签 `<f:selectItem>`，它将一个 javax.faces.component.UISelectItem
    子组件添加到最近的父UI组件。`<f:selectItem>` 标签接受 `itemLabel` 和 `itemValue` 属性。如果你设置了 `itemValue`
    而没有指定 `itemLabel`，则值成为标签。因此，对于第一个选项，选项设置为 `--`，但提交给表单的值是一个空字符串，因为我们想提示用户应该选择一个值。
- en: 'The rendered HTML output is instructive, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的HTML输出如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The JSF HTML select Boolean checkbox
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSF HTML 选择布尔复选框
- en: The `<h:selectBooleanCheckbox>` custom tag is a special case of selection where
    there is only one item that the user can choose. Typically, in a web application,
    you will find such an element in the final terms and conditions form or usually
    in the marketing e-mail section in an e-commerce application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:selectBooleanCheckbox>` 自定义标签是选择中的一个特殊情况，用户只能选择一个项目。通常，在Web应用程序中，你会在最终条款和条件表单或通常在电子商务应用程序的市场营销电子邮件部分找到这样的元素。'
- en: 'In the targeted managed bean, the only value must be a Boolean type, as shown
    in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标管理Bean中，唯一的值必须是布尔类型，如下所示：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The rendered output for this custom tag looks as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此自定义标签的渲染输出如下所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The JSF HTML command button
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSF HTML 命令按钮
- en: 'The `<h:commandButton>` custom tags correspond to the HTML form submit element.
    They accept an action attribute in JSF that refers to a method in a backing bean.
    The syntax is again in the JSF expression language:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:commandButton>` 自定义标签对应于HTML表单提交元素。它们接受JSF中的action属性，该属性指向后端Bean中的方法。语法再次使用JSF表达式语言：'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the user presses this **Submit** button, the JSF framework will find the
    named managed bean corresponding to `contactDetailController` and then invoke
    the no-arguments method: `createContact()`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下此 **提交** 按钮时，JSF框架将找到对应于 `contactDetailController` 的命名管理Bean，然后调用无参数方法：`createContact()`。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the expression language, it is important to note that the parentheses are
    not required because the interpreter or Facelet automatically introspects whether
    the meaning is an action (`MethodExpression`) or a value definition (`ValueExpression`).
    Be aware that most of the examples in the real world do not add the parentheses
    as a short hand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式语言中，重要的是要注意不需要括号，因为解释器或Facelet会自动检查其含义是动作（`MethodExpression`）还是值定义（`ValueExpression`）。请注意，现实世界中的大多数示例都不添加括号作为快捷方式。
- en: 'The `value` attribute denotes the text for the form **Submit** button. We can
    write the tag in an alternative way and achieve the same result, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 属性表示表单 **提交** 按钮的文本。我们可以以另一种方式编写标签并达到相同的结果，如下所示：'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The value is taken from the body content of the custom tag. The rendered output
    of the tag looks as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值是从自定义标签的正文内容中获取的。标签的渲染输出如下所示：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code illustrates the output from the JSF renderer in the Mojarra
    implementation ([https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)),
    which is the reference implementation. You can clearly see that the renderer writes
    an HTML submit and hidden element in the output. The hidden element captures information
    about the view state that is posted back to the JSF framework (postback), which
    allows it to restore the view.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 Mojarra 实现（[https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)）中
    JSF 渲染器的输出，Mojarra 是参考实现。你可以清楚地看到渲染器在输出中写入了一个 HTML 提交和隐藏元素。隐藏元素捕获有关视图状态的信息，这些信息被发送回
    JSF 框架（postback），从而允许它恢复视图。
- en: 'Finally, here is a screenshot of the contact details form:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是联系方式表单的截图：
- en: '![The JSF HTML command button](img/image00380.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![JSF HTML 命令按钮](img/image00380.jpeg)'
- en: The contact details input JSF form with additional DOB fields
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 带有额外出生日期字段（DOB）的联系方式输入 JSF 表单
- en: There are many more JSF custom tags to consider, and you will find a full table
    list of all the tags later in the chapter. Now, let's examine the backing bean
    that is also known as the controller.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多 JSF 自定义标签需要考虑，你将在本章后面找到所有标签的完整表格列表。现在，让我们检查后端 Bean，它也被称为控制器。
- en: The backing bean controller
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端 Bean 控制器
- en: For our simple POJO form, we need a backing bean or, in modern day JSF developer
    parlance, a managed bean controller.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的简单 POJO 表单，我们需要一个后端 Bean，或者用现代 JSF 开发者的术语来说，就是一个管理 Bean 控制器。
- en: 'The following is the entire code for `ContactDetailController`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对 `ContactDetailController` 的完整代码：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For this managed bean, let's introduce you to a couple of new annotations. The
    first annotation is called `@javax.inject.Named` and it declares this POJO to
    be a CDI-managed bean, which also simultaneously declares a JSF controller. Here,
    we will explicitly declare the value of the name of the managed bean as `contactDetailController`.
    This is actually the default name of the managed bean, so we could have left it
    out.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个管理 Bean，让我们介绍几个新的注解。第一个注解是 `@javax.inject.Named`，它声明这个 POJO 是一个 CDI 管理的
    Bean，同时也声明了一个 JSF 控制器。在这里，我们将显式声明管理 Bean 的名称值为 `contactDetailController`。这实际上是管理
    Bean 的默认名称，因此我们可以省略它。
- en: 'We can also write an alternative name, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以写一个替代名称，如下所示：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, JSF would give us a bean with the name `wizard`. The name of the managed
    bean helps in the expression language syntax.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JSF 会给我们一个名为 `wizard` 的 Bean。管理 Bean 的名称有助于表达式语言语法。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we are talking about JSF, we can interchange the term backing bean with
    managed bean freely. Many professional Java web developers understand that both
    the terms mean the same thing!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 JSF 时，我们可以自由地互换使用“后端 Bean”和“管理 Bean”这两个术语。许多专业的 Java 网络开发者都明白这两个术语意味着同一件事！
- en: The `@javax.faces.view.ViewScoped` annotation denotes that the controller has
    scoped the lifecycle of the view. The scoped view is designed for a situation
    where the application data is preserved just for one page until the user navigates
    to another page. As soon as the user navigates to another page, JSF destroys the
    bean. JSF removes the reference to the view-scoped bean from its internal data
    structure and the object is left for the garbage collector.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`@javax.faces.view.ViewScoped` 注解表示控制器已经将视图的生命周期进行了范围限定。范围限定的视图是为了满足一种情况，即应用程序数据仅保留在一个页面中，直到用户导航到另一个页面。一旦用户导航到另一个页面，JSF
    就会销毁该 Bean。JSF 会从其内部数据结构中移除对视图范围 Bean 的引用，该对象随后留给垃圾回收器处理。'
- en: 'The `@ViewScoped` annotation is new in Java EE 7 and JSF 2.2 and fixes a bug
    between the Faces and CDI specifications. This is because CDI and JSF were developed
    independently. By looking at the Javadoc, you will find an older annotation: `@javax.faces.bean.ViewScoped`,
    which comes from JSF 2.0 and was not part of the CDI specification.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewScoped` 注解是 Java EE 7 和 JSF 2.2 中新引入的，它修复了 Faces 和 CDI 规范之间的一个错误。这是因为
    CDI 和 JSF 是独立开发的。通过查看 Javadoc，你会找到一个旧的注解：`@javax.faces.bean.ViewScoped`，它来自 JSF
    2.0，并且不是 CDI 规范的一部分。'
- en: For now, if you choose to write the `@ViewScoped` annotated controllers, you
    probably should use `@ManagedBean`. We will explain `@ViewScoped` beans later
    in this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你选择编写带有 `@ViewScoped` 注解的控制器，你可能应该使用 `@ManagedBean`。我们将在本章后面解释 `@ViewScoped`
    Bean。
- en: '`ContactDetailController` also has a dependency on an **Enterprise Java Bean**
    (**EJB**) service endpoint: `ContactDetailService` and most importantly, has a
    bean property: `ContactDetail`. Note the `getter` and `setter` methods and we
    will also ensure that the property is instantiated during the construction time.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactDetailController`还依赖于一个**企业JavaBean**（**EJB**）服务端点：`ContactDetailService`，并且最重要的是，有一个名为`ContactDetail`的bean属性。注意`getter`和`setter`方法，我们还将确保在构造时实例化该属性。'
- en: 'We will now turn our attention to the methods, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将注意力转向方法，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `createContact()` method uses EJB to create a new contact detail. It returns
    a string, which is the next Facelet view: `index.xhtml`. This method is referenced
    by `<h:commandButton>`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`createContact()`方法使用EJB创建一个新的联系详情。它返回一个字符串，这是下一个Facelet视图：`index.xhtml`。此方法由`<h:commandButton>`引用。'
- en: The `retrieveAllContacts()` method invokes the data service to fetch the list
    collection of the entities. This method will be referenced by another page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieveAllContacts()`方法调用数据服务以获取实体的列表集合。此方法将被另一页引用。'
- en: Data service
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据服务
- en: 'The controller relies on an entity bean: `ContactDetail`. Here is the code
    for this bean, which has been simplified:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器依赖于一个实体bean：`ContactDetail`。以下是此bean的代码，它已经被简化：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It uses the **Java Persistence API** (**JPA**) annotation to map the Java properties
    to a relational database.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用**Java持久化API**（**JPA**）注解将Java属性映射到关系数据库。
- en: There are a set of annotations that declare against the entity itself. The `@Entity`
    annotation marks this POJO as a persistence capable object. The `@Table` annotation
    overrides the default database table name for the entity—instead of `CONTACT_DETAIL`,
    it becomes `CONTACT`. The `@NameQueries` and `@NameQuery` annotations define the
    name queries in the **Java Persistence Query Language** (**JPQL**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组注解是针对实体本身声明的。`@Entity`注解将此POJO标记为持久化能力对象。`@Table`注解覆盖了实体的默认数据库表名——而不是`CONTACT_DETAIL`，它变成了`CONTACT`。`@NameQueries`和`@NameQuery`注解定义了**Java持久化查询语言**（**JPQL**）中的名称查询。
- en: The remaining annotations declare the metadata that is associated with the database
    table columns. The `@Id` annotation specifies the property that will be the primary
    key, which is the `id` field. The `@GenerationValue` annotation declares that
    the primary key is automatically generated. The JPA provider generates a unique
    value if there is a `0` or null value. The other annotation on this property—`@Column`—renames
    the default database table column name from `ID` to `CONTACT_ID` and sets certain
    constraints.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的注解声明与数据库表列关联的元数据。`@Id`注解指定将成为主键的属性，即`id`字段。`@GenerationValue`注解声明主键是自动生成的。如果存在`0`或null值，JPA提供商会生成一个唯一值。此属性上的其他注解`@Column`将默认数据库表列名从`ID`重命名为`CONTACT_ID`并设置某些约束。
- en: Finally, JPA must specify the date time type for a field with the `@Temporal`
    annotation. The annotation value can be `Temporal.DATE`, `Temporal.TIME`, or `Temporal.TIMESTAMP`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JPA必须使用`@Temporal`注解指定字段的日期时间类型。注解值可以是`Temporal.DATE`、`Temporal.TIME`或`Temporal.TIMESTAMP`。
- en: You will learn about the JPA in my book, Java EE 7 Developer Handbook, where
    there are several concise and devoted chapters on the subject. However, this book
    concerns the web application development.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我的书中了解JPA，即《Java EE 7开发者手册》，其中有几个关于该主题的简洁和专门的章节。然而，这本书关注的是Web应用程序开发。
- en: 'It should be apparent now that the entity bean can be directly used in a JSF
    form. Do you remember the JSF expression language for the form properties? Look
    at the following first name field:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很明显，实体bean可以直接在JSF表单中使用。你还记得表单属性的JSF表达式语言吗？看看以下的名字字段：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As the JSF framework knows about `contactDetailController` by name, which has
    a class type of `ContactDetailController`, it can move through the object graph
    and determine the property. The controller has a property called `contactDetail`
    of the `ContactDetail` type, which has a `firstName` property of the String type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSF框架通过名称知道`contactDetailController`，其类类型为`ContactDetailController`，它可以遍历对象图并确定属性。控制器有一个名为`contactDetail`的属性，其类型为`ContactDetail`，它有一个字符串类型的`firstName`属性。
- en: 'The key requirement for a controller is that the entity should be instantiated
    by the time the form is submitted and when the data is retrieved from the form
    for the `remembered` values. Let''s have a look at the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的关键要求是在表单提交时以及从表单检索`remembered`值时，实体应该被实例化。让我们看看以下代码：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a number of possibilities that the developer can make use of for a
    large object hierarchy. Lazy loading and lazy creation of the data structure can
    help in these situations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以针对大型对象层次结构使用多种可能性。延迟加载和延迟创建数据结构可以帮助在这些情况下。
- en: 'Let''s look now at the enterprise service bean, `ContactDataService`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看企业服务豆`ContactDataService`：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This class is an example of a stateful session EJB, which is essentially a poolable
    remote service endpoint in an application server with a conversational state.
    A stateful session bean is associated with a calling client.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是一个有状态会话EJB的例子，它本质上是一个具有会话状态的应用服务器中的可池化远程服务端点。有状态会话豆与调用客户端相关联。
- en: '`ContactDetailService` has a dependency on a JPA provider, as we can see with
    the injection of the entity manager through the `@PersistenceContext` annotation.
    Note that we are using the extended variety of the persistence context because
    the conversation can live for more than one request-response cycle.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactDetailService`依赖于一个JPA提供者，正如我们通过`@PersistenceContext`注解注入实体管理器所看到的那样。请注意，我们使用持久化上下文的扩展版本，因为会话可以持续多个请求-响应周期。'
- en: In a non-extended persistence conversation, EntityManager will live only as
    long as there is a JTA transaction. Once the transaction is finished in the Java
    EE model, all of the persistence objects are detached from `EntityManager` and
    they become unmanaged.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在非扩展持久化会话中，EntityManager将仅存在于JTA事务期间。一旦Java EE模型中的事务完成，所有持久化对象都会从`EntityManager`中分离，并变为未管理状态。
- en: An extended persistence conversation is one where EntityManager can outlive
    the scope of a **Java Transaction API** (**JTA**) transaction. In fact, it can
    survive over several transactions. The persistence objects do not become detached
    from EntityManager in this case; the data is only saved to the database when it
    is flushed explicitly or through the special demarcation of states that the application
    server provides around the stateful session beans. For this reason, the extended
    persistence contexts can be used only in the stateful session beans.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展持久化会话是指EntityManager可以超出**Java事务API（JTA**）事务的作用域。实际上，它可以在多个事务中存活。在这种情况下，持久化对象不会从EntityManager中分离；数据仅在显式刷新或通过应用服务器为有状态会话豆提供的特殊状态标记时保存到数据库中。因此，扩展持久化上下文只能用于有状态会话豆。
- en: For more information about the permission and stateful session beans, see my
    sister book, *Java EE 7 Developer Handbook*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关权限和有状态会话豆的更多信息，请参阅我的姐妹书籍《Java EE 7开发者手册》。
- en: 'For now, we should only concern ourselves with the methods in `ContactDataService`.
    The `add()` method inserts a new record in the database. The `update()` method
    amends an existing record and `delete()` removes the record. The `findAll()` method
    retrieves all of the `ContactDetail` records from the underlying database. It
    uses the named JPQL query: `Contact.findAll`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需关注`ContactDataService`中的方法。`add()`方法在数据库中插入一条新记录。`update()`方法修改现有记录，`delete()`方法删除记录。`findAll()`方法从底层数据库检索所有`ContactDetail`记录。它使用命名的JPQL查询：`Contact.findAll`。
- en: You might be wondering where in the user interface is the JSF field that sets
    up the `Date of Birth (DOB)` property, as seen in the `ContactDetail` entity bean.
    We will add these fields later on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道用户界面中的JSF字段在哪里设置`Date of Birth (DOB)`属性，就像在`ContactDetail`实体豆中看到的那样。我们稍后会添加这些字段。
- en: JSF custom tags
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF自定义标签
- en: As you have seen, JSF comes with a wealth of custom tag libraries. In order
    to get the best out of the framework, a digital developer should learn about them
    and their abilities. The tags can be divided into namespaces as we have previously
    seen.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，JSF自带丰富的自定义标签库。为了充分利用框架，数字开发者应该了解它们及其功能。标签可以按照我们之前看到的命名空间进行划分。
- en: The HTML render kit custom tags
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML渲染工具自定义标签
- en: 'The first set of tags in JSF 2.2 relate to the rendering of the HTML elements.
    They are in the name space: [http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html).
    The default implementation of the render kit in the JSF framework contains component
    tags for `javax.faces.component.UIComponent`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2中的第一组标签与HTML元素的渲染相关。它们位于命名空间：[http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html)。JSF框架中渲染工具的默认实现包含`javax.faces.component.UIComponent`的组件标签。
- en: 'Here is a table of the HTML render kit tags:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是HTML渲染工具标签的表格：
- en: '| JSF custom tag | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| JSF自定义标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<h:column>` | This renders an instance of `javax.faces.component.UIColumn`
    that represents a single column of data in a parent UIData component. This custom
    tag is used in `<h:dataTable>`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '`<h:column>` | 这将渲染一个`javax.faces.component.UIColumn`实例，代表父UIData组件中的单个数据列。此自定义标签用于`<h:dataTable>`中。'
- en: '| `<h:commandButton>` | This renders an HTML input element with the submit
    or rest type. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '`<h:commandButton>` | 这将渲染一个具有提交或重置类型的HTML输入元素。'
- en: '| `<h:commandLink>` | This renders an HTML anchor element that performs like
    a submit button, and therefore, the tag must be added in an `<h:form>` tag. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '`<h:commandLink>` | 这将渲染一个类似于提交按钮的HTML锚元素，因此，该标签必须添加在`<h:form>`标签中。'
- en: '| `<h:dataTable>` | This renders an HTML table with rows and columns including
    the table headers and table column cells. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '`<h:dataTable>` | 这将渲染一个具有行和列的HTML表格，包括表头和表列单元格。'
- en: '| `<h:form>` | This renders an HTML form element. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`<h:form>` | 这将渲染一个HTML表单元素。'
- en: '| `<h:graphicImage>` | This renders an HTML image element. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '`<h:graphicImage>` | 这将渲染一个HTML图像元素。'
- en: '| `<h:inputFile>` | This renders an HTML form input element with a file type
    and allows an application to upload a file from the client''s operating system.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '`<h:inputFile>` | 这将渲染一个具有文件类型的HTML表单输入元素，并允许应用程序从客户端操作系统上传文件。'
- en: '| `<h:inputHidden>` | This renders an HTML form input element with a hidden
    type. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '`<h:inputHidden>` | 这将渲染一个具有隐藏类型的HTML表单输入元素。'
- en: '| `<h:inputSecret>` | This renders an HTML form input element with a password
    type. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '`<h:inputSecret>` | 这将渲染一个具有密码类型的HTML表单输入元素。'
- en: '| `<h:inputText>` | This renders an HTML form input element with a text type.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '`<h:inputText>` | 这将渲染一个具有文本类型的HTML表单输入元素。'
- en: '| `<h:inputTextarea>` | This renders an HTML form text area element. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '`<h:inputTextarea>` | 这将渲染一个HTML表单文本区域元素。'
- en: '| `<h:link>` | This renders an HTML anchor element that performs an HTTP GET
    request to the application. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '`<h:link>` | 这将渲染一个HTML锚元素，执行对应用的HTTP GET请求。'
- en: '| `<h:outputFormat>` | This tag renders the parameterized text with formatted
    parameters. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '`<h:outputFormat>` | 此标签以格式化参数渲染参数化文本。'
- en: '| `<h:outputLabel>` | This renders an HTML label element. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '`<h:outputLabel>` | 这将渲染一个HTML标签元素。'
- en: '| `<h:outputLink>` | This renders an HTML anchor element that is typically
    used for non-JSF application links. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '`<h:outputLink>` | 这将渲染一个HTML锚元素，通常用于非JSF应用的链接。'
- en: '| `<h:outputText>` | This tag renders the output to the view. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '`<h:outputText>` | 此标签将输出渲染到视图中。'
- en: '| `<h:message>` | This renders a single message to a page for a specific component.
    The tag allows internationalization through a resource bundle. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`<h:message>` | 这将为特定组件向页面渲染一条消息。该标签通过资源包允许国际化。'
- en: '| `<h:messages>` | This renders a series of messages to a page from the Faces
    Context. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`<h:messages>` | 这将从Faces上下文向页面渲染一系列消息。'
- en: '| `<h:panelGrid>` | This custom tag renders components into a grid. The default
    JSF implementation uses the HTML table element. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`<h:panelGrid>` | 此自定义标签将组件渲染到网格中。默认的JSF实现使用HTML表格元素。'
- en: '| `<h:panelGroup>` | This custom tag organizes the nested JSF tags into defined
    groups where the layout produces and generates a single entity. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`<h:panelGroup>` | 此自定义标签将嵌套的JSF标签组织到定义的组中，其中布局生成并生成单个实体。'
- en: '| `<h:selectBooleanCheckbox>` | This renders an HTML input element with a checkbox
    type and is designed for Boolean properties. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectBooleanCheckbox>` | 这将渲染一个具有复选框类型的HTML输入元素，并设计用于布尔属性。'
- en: '| `<h:selectManyCheckbox>` | This renders a list of the HTML input elements
    with the type as checkbox. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectManyCheckbox>` | 这将渲染具有复选框类型的HTML输入元素列表。'
- en: '| `<h:selectManyListbox>` | This renders a list of the HTML select option elements.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectManyListbox>` | 这将渲染HTML选择选项元素的列表。'
- en: '| `<h:selectManyMenu>` | This renders a list of the HTML select option elements.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectManyMenu>` | 这将渲染HTML选择选项元素的列表。'
- en: '| `<h:selectOneListbox>` | This renders a list of the HTML select option elements.
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectOneListbox>` | 这将渲染HTML选择选项元素的列表。'
- en: '| `<h:selectOneMenu>` | This renders a list of the HTML select option elements.
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectOneMenu>` | 这将渲染HTML选择选项元素的列表。'
- en: '| `<h:selectOneRadio>` | This renders a list of the HTML input elements with
    the type as radio. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '`<h:selectOneRadio>` | 这将渲染一个具有单选类型的HTML输入元素列表。'
- en: The JSF HTML tags are divided into different kinds, such as commands, inputs,
    outputs, and types in order to handle the selection of items. There are also additional
    tags to handle special cases such as `<h:graphicImage>` to render the `<img>`
    tags and `<h:dataTable>` to render the `<table>` information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: JSF HTML标签被分为不同的类型，例如命令、输入、输出和类型，以便处理项目的选择。还有额外的标签来处理特殊案例，例如`<h:graphicImage>`用于渲染`<img>`标签和`<h:dataTable>`用于渲染`<table>`信息。
- en: The core JSF custom tags
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心JSF自定义标签
- en: The core JSF custom tags add the features that are independent to the HTML render
    kit tags. The namespace for these tags is [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core).
    The JSF framework is extendable. If you want an alternative render kit, then all
    you have to do is add it. The core JSF custom tags will still work.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 核心JSF自定义标签添加了独立于HTML渲染标签的功能。这些标签的命名空间是[http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core)。JSF框架是可扩展的。如果您想使用替代渲染套件，那么您只需添加它。核心JSF自定义标签仍然会工作。
- en: 'Here is a table of the JSF Core tags:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JSF核心标签的表格：
- en: '| JSF custom tag | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| JSF自定义标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<f:actionListener>` | This registers an `ActionListener` instance. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `<f:actionListener>` | 这注册一个`ActionListener`实例。|'
- en: '| `<f:attribute>` | This adds an attribute to `UIComponent` with the closest
    parent `UIComponent` action. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `<f:attribute>` | 这向`UIComponent`添加一个属性，并使用最近的父`UIComponent`执行操作。|'
- en: '| `<f:convertDateTime>` | This registers `DateTimeConverter` to `UIComponent`.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `<f:convertDateTime>` | 这将`DateTimeConverter`注册到`UIComponent`。|'
- en: '| `<f:convertNumber>` | This registers `NumberConverter` to `UIComponent`.
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `<f:convertNumber>` | 这将`NumberConverter`注册到`UIComponent`。|'
- en: '| `<f:converter>` | This renders an HTML anchor element that performs like
    a submit button, and therefore, the tag must be added in `<h:form>`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `<f:converter>` | 这渲染一个类似于提交按钮的HTML锚点元素，因此，该标签必须添加到`<h:form>`中。|'
- en: '| `<f:facet>` | This adds a facet to a component. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `<f:facet>` | 这向组件添加一个面。|'
- en: '| `<f:loadBundle>` | This loads a resource bundle that is localized for Locale
    of the current view and stores the properties as `java.util.Map`. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `<f:loadBundle>` | 这加载一个为当前视图的Locale本地化的资源包，并将属性存储为`java.util.Map`。|'
- en: '| `<f:metadata>` | This declares the metadata facet for this view. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `<f:metadata>` | 这声明此视图的元数据面。|'
- en: '| `<f:param>` | This adds a parameter to `UIComponent`. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `<f:param>` | 这向`UIComponent`添加一个参数。|'
- en: '| `<f:phaseListener>` | This registers a `PhaseListener` instance to the page.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `<f:phaseListener>` | 这将`PhaseListener`实例注册到页面中。|'
- en: '| `<f:selectItem>` | This specifies an item for a select one or select many
    component. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `<f:selectItem>` | 这指定了一个单选或多选组件的项目。|'
- en: '| `<f:selectItems>` | This specifies items for a select one or select many
    component. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `<f:selectItems>` | 这指定单选或多选组件的项目。|'
- en: '| `<f:setProperty-ActionListener>` | This registers `ActionListener` to the
    component for a particular property. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `<f:setProperty-ActionListener>` | 这将`ActionListener`注册到组件的特定属性。|'
- en: '| `<f:subview>` | This creates another JSF naming context (See `<f:view>`).
    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `<f:subview>` | 这创建另一个JSF命名上下文（参见`<f:view>`）。|'
- en: '| `<f:validateDoubleRange>` | This registers `DoubleRangeValidator` to the
    component. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateDoubleRange>` | 这将`DoubleRangeValidator`注册到组件中。|'
- en: '| `<f:validateLength>` | This registers `LengthValidator` to the component.
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLength>` | 这将`LengthValidator`注册到组件中。|'
- en: '| `<f:validateLongRange>` | This registers `LongRangeValidator` to the component.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateLongRange>` | 这将`LongRangeValidator`注册到组件中。|'
- en: '| `<f:validateRegex>` | This registers a regular expression validator to the
    component. If the entire pattern matches, then it is valid. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRegex>` | 这将正则表达式验证器注册到组件中。如果整个模式匹配，则它是有效的。|'
- en: '| `<f:validateRequired>` | This ensures that a value in a component is present
    when a form is submitted. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validateRequired>` | 这确保在表单提交时组件中的值存在。|'
- en: '| `<f:validator>` | This registers a named Validator instance to the component.
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `<f:validator>` | 这将命名的Validator实例注册到组件中。|'
- en: '| `<f:valueChangeListener>` | This registers `ValueChangeListener` to the component.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `<f:valueChangeListener>` | 这将`ValueChangeListener`注册到组件中。|'
- en: '| `<f:verbatim>` | This adds a markup to a JSF page and allows the body content
    to pass directly to the rendered output. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `<f:verbatim>` | 这向JSF页面添加标记，并允许主体内容直接传递到渲染输出。|'
- en: '| `<f:view>` | This sets parameters on the JSF current naming context for the
    page. Use this tag to override the locale, encoding, or content type. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `<f:view>` | 这为页面的JSF当前命名上下文设置参数。使用此标签可以覆盖区域设置、编码或内容类型。|'
- en: '| `<f:viewParam>` | This adds a view parameter to the metadata of a facet so
    that the page has access to query the parameters in a GET request. This tag can
    be used only in `<f:metadata>`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `<f:viewParam>` | 这将一个视图参数添加到分面的元数据中，以便页面可以访问在GET请求中查询参数。此标签只能在`<f:metadata>`中使用。
    |'
- en: The purpose of many core JSF tags is to enhance and configure an `UIComponent`
    instance. You have already seen this example used with the `<f:selectItem>` tag
    in `<h:selectOneMenu>` in the previous code example, `createContact.xhtml`. (See
    the section *Basic JSF form*).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 许多核心JSF标签的目的是增强和配置一个`UIComponent`实例。您已经在之前的代码示例`createContact.xhtml`中的`<h:selectOneMenu>`的`<f:selectItem>`标签中看到了这个示例的使用。（见*基本JSF表单*部分）。
- en: For most circumstances, the developer can add attributes, listeners, converters,
    facets, parameters, and selections to the components using the core JSF tag.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，开发者可以使用核心JSF标签向组件添加属性、监听器、转换器、分面、参数和选择。
- en: The template composition custom tags
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板组合自定义标签
- en: The library of the template JSF custom tags provides you with the ability to
    compose pages with content from the other pages. Templating allows the content
    to reused and shared across an entire JSF application. Best of all, the templates
    can be adapted by specifying the parameters so that there is adaptability and
    flexibility in the mix. The namespace for these tags is [http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets),
    which underlines the technology of the Facelet view behind the scenes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 模板JSF自定义标签库为您提供了使用其他页面内容组合页面的能力。模板允许内容在整个JSF应用程序中重用和共享。最好的是，可以通过指定参数来适应模板，从而在混合中具有适应性和灵活性。这些标签的命名空间是[http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets)，这强调了Facelet视图背后的技术。
- en: 'Here is a list of the template tags in JSF 2.2:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是JSF 2.2中的模板标签列表：
- en: '| JSF custom tag | Description |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| JSF自定义标签 | 描述 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<ui:component>` | This defines a template component and specifies the filename
    for the component. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:component>` | 这定义了一个模板组件并指定了组件的文件名。 |'
- en: '| `<ui:composition>` | This defines a page composition, which encapsulates
    the JSF content that optionally uses a template. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:composition>` | 这定义了一个页面组合，它封装了可选使用模板的JSF内容。 |'
- en: '| `<ui:debug>` | This creates and adds a special component to the current page
    that allows the debugging output to be shown. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:debug>` | 这将在当前页面创建并添加一个特殊组件，允许显示调试输出。 |'
- en: '| `<ui:define>` | This defines the JSF content that is inserted into a page
    by a composition template. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:define>` | 这定义了由组合模板插入到页面中的JSF内容。 |'
- en: '| `<ui:decorate>` | This defines the content that decorates specific regions
    of a JSF page. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:decorate>` | 这定义了装饰JSF页面特定区域的内联内容。 |'
- en: '| `<ui:fragment>` | This defines a template fragment in a way that is similar
    to the `<ui:composition>` tag, except that this tag preserves the content outside
    the body instead of discarding it. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:fragment>` | 以类似于`<ui:composition>`标签的方式定义模板片段，不同之处在于此标签保留正文外的内容，而不是丢弃它。
    |'
- en: '| `<ui:include>` | This includes inserting another JSF page into the current
    page. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:include>` | 这将另一个JSF页面插入到当前页面中。 |'
- en: '| `<ui:insert>` | This inserts a named content definition into the current
    page. This tag is used in conjunction with `<ui:define>`. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:insert>` | 这将一个命名的内联定义插入到当前页面中。此标签与`<ui:define>`一起使用。 |'
- en: '| `<ui:param>` | This passes parameters to an included file that is specified
    with `<ui:include>` or a template reference such as `<ui:composition>` or `<ui:include>`.
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:param>` | 这将参数传递给由`<ui:include>`或模板引用（如`<ui:composition>`或`<ui:include>`）指定的包含文件。
    |'
- en: '| `<ui:repeat>` | This iterates over a list collection from the bean property
    or method. This tag is an alternative way to loop through a collection similar
    to `<h:dataTable>` or `<c:forEach>`. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:repeat>` | 这遍历来自bean属性或方法的列表集合。此标签是循环遍历集合的替代方法，类似于`<h:dataTable>`或`<c:forEach>`。
    |'
- en: '| `<ui:remove>` | This removes specific marked content from a page. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `<ui:remove>` | 这从页面中删除特定的标记内容。 |'
- en: We have seen the operation of `<ui:composition>`, `<ui:define>`, and `<ui:insert>`
    in [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer Faces Lifecycle"),
    *JavaServer Faces Lifecycle*. We will definitely be using the template JSF tags
    for the remainder of the book concerning JSF.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](part0025.xhtml#aid-NQU22 "第2章. JavaServer Faces生命周期")中看到了`<ui:composition>`、`<ui:define>`和`<ui:insert>`的操作，*JavaServer
    Faces生命周期*。我们肯定会使用模板JSF标签来处理本书中关于JSF的剩余部分。
- en: Common attributes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见属性
- en: 'The JSF standard tags share many common attributes. The following table is
    a reference and some of these attributes are available for most of the HTML render
    kit tags:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JSF标准标签共享许多共同属性。以下表格是一个参考，其中一些属性适用于大多数HTML渲染标签：
- en: '| Attribute Name | Description |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `id` | This specifies the HTML element identifier. JSF developers should
    use this attribute every time. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 这指定了HTML元素标识符。JSF开发者应该每次都使用此属性。 |'
- en: '| `binding` | This binds a tag to a component instance in a managed bean. The
    JSF framework binds a component''s reference in the component tree to a scoped
    variable. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `binding` | 这将一个标签绑定到一个管理Bean中的组件实例。JSF框架将组件树中的组件引用绑定到一个作用域变量。 |'
- en: '| `Immedate` | This specifies to a Boolean value, if set `true`, it causes
    the JSF framework to skip the processing of validations, conversions, and events
    after the Apply Request Value stage in the JSF lifecycle. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `Immediate` | 这指定了一个布尔值，如果设置为`true`，则导致JSF框架在JSF生命周期中的“应用请求值”阶段之后跳过验证、转换和事件的处理。
    |'
- en: '| `rendered` | This specifies to a Boolean value, which usually defaults to
    true, whether the component should be rendered. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `rendered` | 这指定了一个布尔值，通常默认为true，表示组件是否应该被渲染。 |'
- en: '| `required` | This specifies to a Boolean value whether this input element
    is required for input validation. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `required` | 这指定了该输入元素是否为输入验证所必需的布尔值。 |'
- en: '| `styleClass` | This specifies the HTML class attribute for a rendered tag.
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `styleClass` | 这指定了渲染标签的HTML类属性。 |'
- en: '| `stylestyle` | This specifies the HTML style attribute for the rendered tag.
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `stylestyle` | 这指定了渲染标签的HTML样式属性。 |'
- en: '| `valuevalue` | This specifies a String value or expression language reference.
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `valuevalue` | 这指定了一个字符串值或表达式语言引用。 |'
- en: Now that we have seen the JSF tags, we will move back to our CRUD example.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了JSF标签，我们将回到我们的CRUD示例。
- en: Displaying a list collection of objects
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示对象列表集合
- en: For CRUD examples, we are often faced with the practical problem of displaying
    the data in the application in a meaningful context that the user can understand.
    One of the easiest ways is to just print out a list of items for the fairly simple
    data. Another way is to display a tabular view of the data. There are other solutions
    worthy of consideration if your data is a tree structure or a graph.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CRUD示例，我们经常面临在应用程序中以用户可理解的有意义的方式显示数据的实际问题。最容易的方法之一就是简单地打印出项目的列表，对于相对简单的数据。另一种方法是显示数据的表格视图。如果你的数据是树结构或图，还有其他值得考虑的解决方案。
- en: For our case, we will choose the second path and display the list of contact
    details in a table. In JSF, we can use the `<h:dataTable>` HTML component. This
    custom tag iterates over each object in the list and displays the specified values.
    The `<h:dataTable>` component is a very powerful and flexible tag because the
    Java web engineer can configure it in order to render the custom styles in a variety
    of layouts.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的情况，我们将选择第二条路径，并在表格中显示联系详情列表。在JSF中，我们可以使用`<h:dataTable>`HTML组件。这个自定义标签遍历列表中的每个对象并显示指定的值。《h:dataTable》组件是一个非常强大且灵活的标签，因为Java网络工程师可以配置它以在多种布局中渲染自定义样式。
- en: 'Let''s take a look at another JSF Facelet view, `index.html`, in the `jsf-crud`
    project. As a reminder, we are using Bootstrap CSS to style. Now, here is the
    extracted code, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`jsf-crud`项目中的另一个JSF Facelet视图，`index.html`。作为提醒，我们正在使用Bootstrap CSS进行样式设计。现在，以下是提取的代码，如下所示：
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing that you will notice is that the `<h:dataTable>` tag accepts
    a value attribute, which is the JSF expression language reference to the controller's
    `retrieveAllContacts()` method. `ContactDetailController` delegates this request
    to `ContactDetailService`, the stateful session EJB that we saw earlier.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到`<h:dataTable>`标签接受一个值属性，这是JSF表达式语言对控制器`retrieveAllContacts()`方法的引用。`ContactDetailController`将此请求委派给我们在前面看到的`ContactDetailService`，即有状态的会话EJB。
- en: 'The `var` attribute specifies the name of the JSF scope variable, which is
    the element that is created each time a component iterates through the list collection.
    The type of the element in the view is the entity bean: `ContactDetail`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`属性指定了JSF作用域变量的名称，这是每次组件遍历列表集合时创建的元素。视图中的元素类型是实体bean：`ContactDetail`。'
- en: The `styleClass` attributes add specific CSS styles from the Bootstrap framework,
    and of course, every component can have an `id` attribute.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`styleClass`属性添加了来自Bootstrap框架的特定CSS样式，当然，每个组件都可以有一个`id`属性。'
- en: The `<h:dataTable>` component requires the nested delineated `<h:column>` tags
    that describe the column data for the table.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:dataTable>`组件需要嵌套的描述表格列数据的`<h:column>`标签。'
- en: 'If you want header rows for the table, then you must place and add a core JSF
    tag called `<f:facet>` in the `<h:column>` tag. This tag name must be given a
    special name attribute with the `header` value. If you were to ask me: why must
    I write tags using different XML namespaces? Then my answer would be that this
    was the way the JSF designers foresaw that the core tags could be reusable to
    the other rendering kits. Hence, the tag name is `<f:facet>` and not something
    like `<h:headerColumn>`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为表格添加标题行，那么您必须在`<h:column>`标签中放置并添加一个核心JSF标签`<f:facet>`。此标签名必须有一个特殊的名称属性，其值为`header`。如果您问我：为什么我必须使用不同的XML命名空间来编写标签？那么我的回答将是，这是JSF设计者预见核心标签可以重复用于其他渲染套件的方式。因此，标签名是`<f:facet>`而不是类似`<h:headerColumn>`的东西。
- en: In order to show the user the information for each row, we use the `<h:outputText>`
    element. This tag accepts another expression language statement, namely, the reference
    to the property in the entity bean such as `#{contact.firstName}`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户显示每行的信息，我们使用`<h:outputText>`元素。此标签接受另一个表达式语言语句，即实体Bean中属性的引用，例如`#{contact.firstName}`。
- en: 'Here is a screenshot of the `index.html` list view:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`index.html`列表视图的截图：
- en: '![Displaying a list collection of objects](img/image00381.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![显示对象列表集合](img/image00381.jpeg)'
- en: A screenshot of the list view for the CRUD application
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD应用程序的列表视图截图
- en: Enhanced date time entry
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强的日期时间输入
- en: If you notice, we neglected to add the JSF controls so that a user can add his
    or her date of birth to the contact details form. Let us presume that we have
    a directive from the UX person in our agile team and that the input has to be
    in two drop-down lists. The business wants two drop-down elements for the days
    of the month and months of the year respectfully. They also want a text entry
    for the year.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，我们忽略了添加JSF控件，以便用户可以将他的或她的出生日期添加到联系详细信息表单中。让我们假设我们敏捷团队中的UX人员有一个指令，并且输入必须以两个下拉列表的形式出现。业务希望有两个下拉元素，分别用于月份的天数和年份的月份。他们还希望有一个文本输入用于年份。
- en: We have already covered some of the HTML selection custom tags so far in our
    JSF journey, such as `<h:selectOneMenu>` and `<h:selectBooleanCheckbox>`. Now,
    we will learn how to generate data for these tags programmatically from our managed
    bean. If we can help it—and we surely can—we truly don't want to repeat writing
    `<f:selectItem>` 31 times in a JSF view.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JSF之旅中，我们已经介绍了一些HTML选择自定义标签，例如`<h:selectOneMenu>`和`<h:selectBooleanCheckbox>`。现在，我们将学习如何从我们的管理Bean中程序化地生成这些标签的数据。如果我们能帮助的话——我们当然可以——我们真的不想在JSF视图中重复编写`<f:selectItem>`
    31次。
- en: 'We will need to add extra logic to `ContactDetailController`. These are the
    enhancements for the JSF managed bean, which provide the methods accessible to
    the page view through the expression language, which is mentioned as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`ContactDetailController`中添加额外的逻辑。这些增强是为了JSF管理Bean，它提供了通过表达式语言可访问的方法，如下所述：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will add three new bean properties: `dobDay`, `dobMonth`, and `dobYear`
    to the controller. Note that `dobYear` is a string, whereas the other two are
    integers because the year field is a text field. When an integer is used, the
    default value shown in the front end is `0`, which detracts and confuses the user.
    We want the user to see an empty text field. There are getters and setters for
    these new properties.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制器中添加三个新的Bean属性：`dobDay`、`dobMonth`和`dobYear`。请注意，`dobYear`是一个字符串，而其他两个是整数，因为年份字段是一个文本字段。当使用整数时，前端显示的默认值是`0`，这会减损并混淆用户。我们希望用户看到一个空白的文本字段。这些新属性有getter和setter。
- en: We enhance the `createContact()` method to take into account the date of birth
    from the three separate fields and convert them to a DOB value using a `java.util.Calendar`
    instance. Before the entity bean is saved to the database, we will set a property
    on the entity with the computed value of a `java.util.Date` type.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们增强了`createContact()`方法，以便考虑来自三个单独字段的出生日期，并使用`java.util.Calendar`实例将它们转换为DOB值。在将实体Bean保存到数据库之前，我们将设置一个具有`java.util.Date`类型计算值的属性。
- en: There are two bean property methods, `getDaysOfTheMonth()` and `getMonthsOfTheYear()`,
    which will return the static collections that are built in the static initializer
    of the class. The `daysOfTheMonth` field is a list collection of integers from
    1 to 31, and the `monthsOfTheYear` field is a map collection of the entries and
    strings associated with integers, which represent the months of the year.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个属性方法，`getDaysOfTheMonth()` 和 `getMonthsOfTheYear()`，它们将返回由类静态初始化器构建的静态集合。`daysOfTheMonth`
    字段是一个从 1 到 31 的整数列表集合，而 `monthsOfTheYear` 字段是一个与整数关联的条目和字符串的映射集合，代表一年的月份。
- en: We use JDK's `DateFormatSymbols` class to retrieve the long names of the months
    that are set to the application's default locale.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 JDK 的 `DateFormatSymbols` 类来检索设置为应用程序默认区域设置的月份的长名称。
- en: With these backend changes, we can adapt the JSF view in order to add the ability
    to set the applicant's date of birth.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些后端更改，我们可以调整 JSF 视图，以便添加设置申请人的出生日期的能力。
- en: 'Here are the updated changes in the JSF view, `createContactDetails.xhtml`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 JSF 视图 `createContactDetails.xhtml` 的更新更改：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Well, hopefully I did not scare you off and have you running up the hill! We
    are using Bootstrap CSS v3.11 here, so this is the reason you see a lot of the
    `<div>` elements in HTML with the specifically named CSS selectors such as `control-label`,
    `col-sm-6` and `row`. Bootstrap is popular framework for HTML5, CSS and JavaScript
    that helps designers and developers build responsive web sites.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，希望我没有吓到你，让你跑上坡路！我们在这里使用 Bootstrap CSS v3.11，这就是为什么你在 HTML 中看到很多带有特定命名的 CSS
    选择器的 `<div>` 元素，如 `control-label`、`col-sm-6` 和 `row`。Bootstrap 是一个流行的 HTML5、CSS
    和 JavaScript 框架，它帮助设计师和开发者构建响应式网站。
- en: As a component framework, JSF provides the basis to encapsulate the `<div>`
    layer, CSS, and JavaScript. There are a few approaches that can help. First, the
    teams can develop their custom components; second, they can leverage a third-party
    component system that has the features and customization that is required, and
    finally, the team can act as a library writer and therefore, create their own
    bespoke HTML render kit. The custom components are a lot easier to program, which
    we will talk about in [Chapter 5](part0050.xhtml#aid-1FLS41 "Chapter 5. Conversations
    and Journeys"), *Conversations and Journeys*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为组件框架，JSF 提供了封装 `<div>` 层、CSS 和 JavaScript 的基础。有一些方法可以帮助实现这一点。首先，团队可以开发自己的自定义组件；其次，他们可以利用具有所需功能和定制的第三方组件系统；最后，团队可以作为库编写者，因此创建他们自己的定制
    HTML 渲染工具包。自定义组件编程起来要容易得多，我们将在第 5 章 [Conversations and Journeys](part0050.xhtml#aid-1FLS41
    "第 5 章。对话和旅程") 中讨论，*对话和旅程*。
- en: If your team is interested in the component libraries, then you may want to
    look at vendor solutions such as Rich Faces ([http://richfaces.jboss.org/](http://richfaces.jboss.org/))
    and particularly, Prime Faces ([http://primefaces.org/](http://primefaces.org/)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的团队对组件库感兴趣，那么您可能想查看供应商解决方案，例如 Rich Faces ([http://richfaces.jboss.org/](http://richfaces.jboss.org/))
    和特别是 Prime Faces ([http://primefaces.org/](http://primefaces.org/))。
- en: Let's concentrate on the `<h:selectOneMenu>` tags. This HTML custom tag from
    the JSF namespaces specifies a drop-down selection list where the user can choose
    only one item. The `value` attribute references a property in the controller bean.
    So, the expression language for the first field is `#{contactDetailController.dobDay}`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中讨论 `<h:selectOneMenu>` 标签。这个来自 JSF 命名空间的 HTML 自定义标签指定了一个下拉选择列表，用户只能选择一个项目。`value`
    属性引用控制器 bean 中的一个属性。因此，第一个字段的表达式语言是 `#{contactDetailController.dobDay}`。
- en: In the parent tag, you see the `<f:selectItem>` and `<f:selectItems>` custom
    tags. The `<f:selectItem>` tag defines one menu item. It accepts an `itemLabel`
    and `itemValue` attribute. We can use it to define a default empty option.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在父标签中，您可以看到 `<f:selectItem>` 和 `<f:selectItems>` 自定义标签。`<f:selectItem>` 标签定义了一个菜单项。它接受
    `itemLabel` 和 `itemValue` 属性。我们可以用它来定义一个默认的空选项。
- en: The `<f:selectItems>` tag defines many menu items and accepts another value
    attribute, which is the expression language `#{contactDetailController.daysOfTheMonth}`.
    This expression refers to the controller getter method, `getDaysOfTheMonth()`,
    which returns `List<Integer>`. We will use `var`, `itemLabel`, and `itemValue`
    to configure how this collection renders each menu option, as follows.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:selectItems>` 标签定义了许多菜单项，并接受另一个值属性，即表达式语言 `#{contactDetailController.daysOfTheMonth}`。这个表达式引用控制器获取方法
    `getDaysOfTheMonth()`，它返回 `List<Integer>`。我们将使用 `var`、`itemLabel` 和 `itemValue`
    来配置如何渲染每个菜单选项，如下所示。'
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Just as with the `<h:dataTable>` tag, we can define a JSF scope variable using
    the `var` attribute and iterate effectively through the collection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `<h:dataTable>` 标签一样，我们可以使用 `var` 属性定义 JSF 范围变量，并有效地遍历集合。
- en: The markup for the months of the year dropdown is slightly different in `<f:selectMenu>`.
    As `getMonthsOfTheYear()` already returns a `Map<String,Integer>` collection,
    there is no need to provide the configuration of the labels and values. The custom
    tag already knows that it has to render the map collections.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<f:selectMenu>` 中，年份下拉菜单的标记略有不同。由于 `getMonthsOfTheYear()` 已经返回了一个 `Map<String,Integer>`
    集合，因此不需要提供标签和值的配置。自定义标签已经知道它必须渲染地图集合。
- en: The last field for the DOB year is `<h:inputText>`, and by now, you already
    know how these tags work. There are a couple of surprises that you may have noticed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: DOB 年份的最后字段是 `<h:inputText>`，到现在为止，你已经知道这些标签是如何工作的。你可能已经注意到了一些惊喜。
- en: 'The `<f:validateRequired>` tag is a validation custom tag, which specifies
    that the bean properties must be defined by the time the form is submitted. The
    `<h:message>` tag specifies an area in the HTML where we want a specific validation
    error to appear, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:validateRequired>` 标签是一个验证自定义标签，它指定了在表单提交时必须定义 bean 属性。`<h:message>` 标签指定了一个区域，在
    HTML 中我们希望特定的验证错误显示如下：'
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `<h:message>` tag accepts a compulsory for attribute that refers to the
    JSF HTML form property. We can set the CSS style with the `styleClass` attribute,
    which is a form error from Bootstrap. In the next chapter, we will look at the
    validation properly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:message>` 标签接受一个必填的 `for` 属性，该属性引用 JSF HTML 表单属性。我们可以使用 `styleClass` 属性设置
    CSS 样式，这是一个来自 Bootstrap 的表单错误。在下一章中，我们将详细探讨验证。'
- en: 'Here is a screenshot of the new form:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是新的表单的截图：
- en: '![Enhanced date time entry](img/image00382.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![增强的日期时间输入](img/image00382.jpeg)'
- en: A screenshot of the create page view for the contact data application
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 联系数据应用程序创建页面视图的截图
- en: Editing data
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑数据
- en: Now, let's add one more JSF `index.xhtml` to allow the users to edit and delete
    the contact details. Before we can edit a contact detail, we must add some JSF
    links to the list view so that the user can navigate to the edit and remove pages.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再添加一个 JSF `index.xhtml`，以便用户可以编辑和删除联系详情。在我们能够编辑联系详情之前，我们必须向列表视图添加一些 JSF
    链接，以便用户可以导航到编辑和删除页面。
- en: 'Let''s modify the `<h:dataTable>` section in the `index.xhtml` view and add
    an additional column. The code looks as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `index.xhtml` 视图中的 `<h:dataTable>` 部分，并添加一个额外的列。代码如下：
- en: '[PRE28]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have two `<h:link>` tags that generate two HTML anchor element links to
    two new pages: `editContactDetail.xhtml` and `removeContactDetail.xhtml`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个 `<h:link>` 标签，它们生成两个 HTML 锚点元素链接到两个新页面：`editContactDetail.xhtml` 和 `removeContactDetail.xhtml`。
- en: The `<h:link>` custom tag has an outcome attribute to generate the URL using
    the JSF navigation rules. The `value` attribute specifies the text on the link
    or you may specify the body text. The tag is clever enough that if the link does
    not exist, then it will generate a `<span>` element instead. This is a useful
    feature for prototyping.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:link>` 自定义标签有一个 `outcome` 属性，用于使用 JSF 导航规则生成 URL。`value` 属性指定链接上的文本或你可以指定正文文本。这个标签足够聪明，如果链接不存在，它将生成一个
    `<span>` 元素。这是一个有用的功能，用于原型设计。'
- en: 'Here is some of the rendered output for `<h:link>`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `<h:link>` 的渲染输出的一部分：
- en: '[PRE29]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `glyphicon`, `glyphicon-edit`, and `glyph-trash` class are markups from
    Bootstrap to show the icon buttons.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`glyphicon`、`glyphicon-edit` 和 `glyph-trash` 类是 Bootstrap 的标记，用于显示图标按钮。'
- en: With the links in place, we must now allow the editing of the contract details
    on the server side. We will adapt `ContactDetailController` with new properties
    and methods. The first property that we will introduce is `id` so that we can
    track the primary key of the contact ID in the database. We will also require
    a getter and setter for the JSF framework.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好链接之后，我们现在必须在服务器端允许编辑合同详情。我们将通过添加新的属性和方法来适配 `ContactDetailController`。我们将引入的第一个属性是
    `id`，这样我们就可以跟踪数据库中联系 ID 的主键。我们还将需要为 JSF 框架提供 getter 和 setter。
- en: 'On second thoughts, it would be nice to allow the user to cancel the task.
    So, we will introduce a `cancel()` method in the controller. We will also add
    a couple of methods: `findByContactId()` and `editContact()`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 重新考虑一下，允许用户取消任务会更好。因此，我们将在控制器中引入一个 `cancel()` 方法。我们还将添加几个方法：`findByContactId()`
    和 `editContact()`。
- en: 'This is the following code of `ContactDetailController` as it now stands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `ContactDetailController` 的以下代码，现在如下所示：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `cancel()` method simply returns the next view: `index.xhtml`. It does
    nothing, which is not an error in the code, but is in fact the purpose: to go
    back to the start.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel()` 方法简单地返回下一个视图：`index.xhtml`。它什么都不做，这并不是代码中的错误，而实际上是目的：返回到开始。'
- en: The `findContactById()` method uses the `id` property to look up the contact
    details using the `ContactDataService` EJB. This method makes use of the `Calendar`
    instance in order to pull apart the `dob` property from the `ContactDetail` entity
    in the constituent `dobDay`, `dobMonth`, and `dobYear` properties.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`findContactById()` 方法使用 `id` 属性通过 `ContactDataService` EJB 查找联系详细信息。此方法使用
    `Calendar` 实例从 `ContactDetail` 实体中提取 `dob` 属性，并将其分解为 `dobDay`、`dobMonth` 和 `dobYear`
    属性。'
- en: The `javax.faces.context.FacesContext` type is an aggregate object that stores
    the current request and response information. `FacesContext` can be retrieved
    using the factory method only. In the example, we will add an error message to
    the Faces response, which can be displayed in the view. The `javax.faces.application.FacesMessage`
    type is a representation of the error validation or it can be defined as a message
    resource from a external resource bundle. See [Appendix A](part0093.xhtml#aid-2OM4A1
    "Appendix A. JSF with HTML5, Resources, and Faces Flows"), *JSF with HTML5, Resources,
    and Faces Flows*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`javax.faces.context.FacesContext` 类型是一个聚合对象，用于存储当前请求和响应信息。`FacesContext` 只能通过工厂方法获取。在示例中，我们将向
    Faces 响应添加错误消息，该消息可以在视图中显示。`javax.faces.application.FacesMessage` 类型是错误验证的表示，或者可以定义为来自外部资源包的消息资源。参见
    [附录 A](part0093.xhtml#aid-2OM4A1 "附录 A. JSF with HTML5, Resources, and Faces Flows")，*JSF
    with HTML5, Resources, and Faces Flows*。'
- en: 'The `editContact()` method is almost the same as `createContect()` because
    it reconstructs the `dob` property in the entity. The difference is that the `id`
    property in the entity is set from the controller property: `id`. Setting the
    correct primary key is extremely important because the user does not want to see
    duplicate entries. The `editContect()` method now invokes the database using `update()`
    instead of `create()`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`editContact()` 方法几乎与 `createContect()` 相同，因为它在实体中重建了 `dob` 属性。不同之处在于实体中的 `id`
    属性是从控制器属性 `id` 中设置的：设置正确的主键至关重要，因为用户不希望看到重复条目。现在 `editContect()` 方法使用 `update()`
    而不是 `create()` 调用数据库。'
- en: 'We will now adapt the `ContactDetail` entity with a new named query. The following
    is the modification:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用新的命名查询来适配 `ContactDetail` 实体。以下是修改内容：
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The named `ContactDetail.findById` query uses a JPQL statement with a key parameter,
    which is denoted in the string as `:id`. We will now add an extra method to the
    EJB.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的 `ContactDetail.findById` 查询使用带有键参数的 JPQL 语句，该参数在字符串中表示为 `:id`。我们现在将向 EJB
    添加一个额外的方法。
- en: 'Here is the additional `ContactDetailService` method with the following code:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是附加的 `ContactDetailService` 方法，以下是其代码：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `findById()` method makes use of the named query and invokes the JPA query
    in order to retrieve a list collection of the `ContactDetail` elements. There
    should only be one element in the collection by definition as we are querying
    by a primary key.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`findById()` 方法使用命名查询并调用 JPA 查询以检索 `ContactDetail` 元素的列表集合。根据定义，集合中应该只有一个元素，因为我们是通过主键进行查询的。'
- en: With these change in the backend, all we need are a few changes in the page
    view, which is almost the same as `createContactDetail.xhtml`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端进行这些更改后，我们只需要在页面视图中进行一些更改，这几乎与 `createContactDetail.xhtml` 相同。
- en: 'Here is an extract of the Facelet view, `editContactDetail.xhtml`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是 Facelet 视图的摘录，`editContactDetail.xhtml`:'
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are JSF custom tags used here. The `<f:metadata>` tag is a container tag
    that declares a metadata facet for the current page.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了 JSF 自定义标签。`<f:metadata>` 标签是一个容器标签，用于声明当前页面的元数据面。
- en: The `<f:viewParam>` tag attaches a GET request parameter for the page as metadata
    for the current view. We will use it to attach the query parameter to the controller
    property. The name attribute specifies the query parameter name. The `value` attribute
    specifies the JSF expression language reference. Giving a URL request such as
    `/jsf-crud-1.0-SNAPSHOT/editContactDetail.xhtml?id=4` will cause the framework
    to populate the `id` property in `ContactDetailController` with the value of `4`.
    This call happens in the Restore View phase of the JSF lifecycle.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:viewParam>` 标签将页面作为当前视图的元数据附加一个 GET 请求参数。我们将使用它将查询参数附加到控制器属性。`name` 属性指定查询参数名称。`value`
    属性指定 JSF 表达式语言引用。提供一个 URL 请求，如 `/jsf-crud-1.0-SNAPSHOT/editContactDetail.xhtml?id=4`，将导致框架在
    `ContactDetailController` 中的 `id` 属性中填充 `4` 的值。这个调用发生在 JSF 生命周期的 Restore View
    阶段。'
- en: Tip
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As the `<f:metadata>` tag declares the metadata for a single page view, it must
    be placed near the root element view of the page. The `<f:metadata>` tag must
    be placed in `<ui:define>` if it is used in a JSF template composition. In the
    example, the tag is just after `<h:body>`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `<f:metadata>` 标签声明了单个页面视图的元数据，它必须放置在页面根元素视图附近。如果 `<f:metadata>` 标签用于 JSF
    模板组合，则必须放置在 `<ui:define>` 中。在示例中，该标签位于 `<h:body>` 之后。
- en: The `<f:event>` custom tag associates a JSF Faces event with a component. The
    official documentation describing this tag says that it installs a `ComponentSystemEventListener`
    instance on a target component in a page. Here, we can simply say that the tag
    associates a prerendering event with the `findByContactId()` method in the controller.
    In other words, `<f:event>` prepopulates the form with the data from the underlying
    database.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`<f:event>` 自定义标签将 JSF Faces 事件与组件关联。官方文档描述此标签时说，它在页面上的目标组件上安装了一个 `ComponentSystemEventListener`
    实例。在这里，我们可以简单地说，该标签将预渲染事件与控制器中的 `findByContactId()` 方法关联。换句话说，`<f:event>` 预填充表单以包含底层数据库中的数据。'
- en: In the `<h:form>` content, we will use the `<h:hidden>` custom tag so as to
    store the current ID of the contact details. The value attribute is an expression
    reference. In this way, the identifier is propagated back to the controller when
    the user submits the form.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<h:form>` 内容中，我们将使用 `<h:hidden>` 自定义标签来存储联系详情的当前 ID。值属性是一个表达式引用。这样，当用户提交表单时，标识符就会传播回控制器。
- en: Finally, there are two `<h:submit>` buttons and they reference the `editContact()`
    and `cancel()` methods in the controller respectively. The intermediate attribute
    in the second `<h:submit>` button specifies that the JSF life cycle should skip
    the Process Validation state. JSF then does not apply the validation when the
    form is submitted. Instead, the life cycle moves from Apply Request Values directly
    to the Render Response state.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个 `<h:submit>` 按钮，它们分别引用控制器中的 `editContact()` 和 `cancel()` 方法。第二个 `<h:submit>`
    按钮中的中间属性指定 JSF 生命周期应跳过 Process Validation 状态。因此，当表单提交时，JSF 不应用验证。相反，生命周期从 Apply
    Request Values 直接移动到 Render Response 状态。
- en: Tip
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Adding HTML entity characters to XHTML**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**在 XHTML 中添加 HTML 实体字符**'
- en: 'Facelets only support five predefined XML entity characters: `&lt`, `&gt`,
    `&amp`, `&quot`, and `&apos`. The only way to add an HTML element is through the
    hexadecimal or octal notation. The `&#160` entity represents the Unicode character
    `&nbsp` for break space.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Facelets 只支持五个预定义的 XML 实体字符：`&lt`、`&gt`、`&amp`、`&quot` 和 `&apos`。添加 HTML 元素的唯一方法是通过十六进制或八进制表示法。`&#160`
    实体表示 Unicode 字符 `&nbsp`（空格）。
- en: 'Here is a screenshot of the `editContactDetail.xhtml` view:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `editContactDetail.xhtml` 视图的截图：
- en: '![Editing data](img/image00383.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![编辑数据](img/image00383.jpeg)'
- en: A screenshot of the edit page view for the contact details application
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 联系详情应用程序编辑页面视图的截图
- en: Removing data
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: Our user is able to create the contact details and she can now update the entries.
    To complete our customer's journey, we should allow her to remove the entries
    as a good Net citizen. Why there are so many companies out there that want to
    block the access to delete the user's data by putting in hazards or extra hassles
    to make such a simple task so difficult is beyond me! However, we can do this
    for our contact detail application and it is now straightforward as we have the
    building blocks in place.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户能够创建联系详情，现在她可以更新条目。为了完成我们客户的旅程，我们应该允许她作为良好的网络公民删除条目。为什么现在有那么多公司想要通过设置危险或额外的麻烦来阻止用户删除数据的访问，使得这样一个简单的任务变得如此困难，这让我感到困惑！然而，我们可以为我们联系详情应用程序做这件事，现在它变得非常直接，因为我们已经有了构建块。
- en: 'We will add a `removeDetail()` method to `ContactDetailController`. Here is
    the extra method:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `ContactDetailController` 中添加一个 `removeDetail()` 方法。以下是额外的方法：
- en: '[PRE34]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This method searches for `contactDetail` by a fresh `id`. The `id` field is
    the controller's property, which is set in a hidden form field. By invoking the
    data services `findById()` method at the form submission, we will ensure that
    we retrieve the latest information from the persistence context. Maybe the user
    went off to lunch and came back and then submitted the form. With the entity found,
    we can then call the data service to remove it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过新的 `id` 搜索 `contactDetail`。`id` 字段是控制器的属性，它在隐藏的表单字段中设置。通过在表单提交时调用数据服务的
    `findById()` 方法，我们将确保从持久化上下文中检索最新信息。也许用户去吃午饭然后回来提交了表单。找到实体后，我们可以调用数据服务来删除它。
- en: 'Here is an extract of the `removeContactDetail.xhtml` view:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `removeContactDetail.xhtml` 视图的摘录：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you look at this carefully, then you will see the `<table>` element that
    displays the properties of the `ContactDetail` entity; but wait a minute, where
    have the `<h:outputText>` elements gone? Well, in JSF 2, you no longer have to
    write `<h:outputText>`, just output the authoring content for the JSF managed
    bean and you can immediately write the expression directly in place.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到显示 `ContactDetail` 实体属性的 `<table>` 元素；但是等等，那些 `<h:outputText>` 元素去哪了？嗯，在
    JSF 2 中，你不再需要写 `<h:outputText>`，只需为 JSF 管理的 Bean 输出内容，你就可以立即直接写入表达式。
- en: 'Hence, one simply writes as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，人们只需这样写：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead of:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Which of the preceding authoring contents would you prefer to program with?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢使用以下哪种 preceding authoring contents 进行编程？
- en: However, the DOB is a field where we will use the `<h:outputText>` element.
    The `<f:convertDateTime>` tag formats a `java.util.Date` type to a readable format.
    The pattern attribute specifies the date format pattern. This tags relies on the
    `java.text.SimpleDateFormat` class.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，日期出生（DOB）是我们将使用 `<h:outputText>` 元素的领域。`<f:convertDateTime>` 标签将 `java.util.Date`
    类型格式化为可读格式。模式属性指定日期格式模式。此标签依赖于 `java.text.SimpleDateFormat` 类。
- en: The `<h:form>` tag is still required in order to allow the user to submit the
    form. It encloses the two `<h:commandButton>` tags. When the form is submitted,
    JSF invokes the `removeContact()` method in the controller.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h:form>` 标签仍然需要，以便允许用户提交表单。它包围了两个 `<h:commandButton>` 标签。当表单提交时，JSF 将在控制器中调用
    `removeContact()` 方法。'
- en: Finally, the page also requires the `<f:metadata>` stanza that was mentioned
    earlier in the *Editing data* section of this chapter in order to fetch the contact
    details before the page is rendered.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，页面还需要之前在章节的 *编辑数据* 部分提到的 `<f:metadata>` 标签，以便在页面渲染之前获取联系详情。
- en: We have come to the end of our customer's journey with this basic digital-by-default
    JSF example. We can create, retrieve, update, and delete a contact detail from
    a database using a web form. It is really so straightforward. We have also taken
    advantage of the HTML5 framework like Bootstrap, and therefore, we can quickly
    adapt our application to a responsive web design.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个基本的默认为数字的 JSF 示例，我们已经完成了客户的旅程。我们可以使用网页表单创建、检索、更新和删除数据库中的联系详情。这真的很简单。我们还利用了
    HTML5 框架，如 Bootstrap，因此我们可以快速将我们的应用程序适应响应式网页设计。
- en: 'Here is the screenshot for the `deleteContent.xhtml` view:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `deleteContent.xhtml` 视图的截图：
- en: '![Removing data](img/image00384.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![删除数据](img/image00384.jpeg)'
- en: The delete page view for the contact details application
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 联系详情应用的删除页面视图
- en: Before we close this chapter, we will have a short interlude on the JSF and
    CDI scopes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关闭这一章之前，我们将简要介绍 JSF 和 CDI 范围。
- en: JSF and CDI scopes
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 和 CDI 范围
- en: There has been some confusion before Java EE 7 about which annotations are correct
    to declare the managed beans. The issues are that the JavaServer Faces specification
    predates the later standard from the CDI and the fact that the scoping overlaps.
    The history of scopes comes from the original design and definition of the servlet
    container and providing convenience to the application developer. A scope is simply
    a map collection of name/value pairs. It helps to think of them as `java.util.Map`
    type hash map collections. The scopes differ in their life span.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 7 之前，关于哪些注解是声明管理 Bean 的正确注解存在一些混淆。问题是 JavaServer Faces 规范早于 CDI 的后续标准，以及范围重叠的事实。范围的历史来自原始设计和对
    servlet 容器的定义，以及为应用程序开发者提供便利。范围简单地说是一个名称/值对的映射集合。有助于将它们视为 `java.util.Map` 类型的哈希映射集合。范围在它们的生存周期上有所不同。
- en: For CDI, the package name is `javax.enterprise.context`, and for JSF managed
    beans, the package is `javax.faces.bean`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CDI，包名是 `javax.enterprise.context`，对于 JSF 管理豆子，包名是 `javax.faces.bean`。
- en: Bean scopes
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 豆子作用域
- en: An `@RequestScoped` annotation denotes a controller with a lifecycle that has
    the duration for the Faces request and response. The request-scope is short-lived.
    It begins when the web client submits an HTTP request and is then processed by
    the servlet container. The scope ends when the response is sent back to the client.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`@RequestScoped` 注解表示一个控制器，其生命周期与 Faces 请求和响应的持续时间相同。请求作用域是短暂的。它从网络客户端提交 HTTP
    请求开始，然后由 Servlet 容器处理。作用域在将响应发送回客户端时结束。'
- en: The `@SessionScoped` annotation denotes a lifecycle of many requests and responses.
    The session scope is designed to get around the stateless protocol of HTTP. The
    servlet containers enhance the HTTP protocol with the ability to store and retrieve
    the objects that live longer than one request and response cycle. For this reason,
    the session scope long-lived. A session scope can expire after a time-out or may
    become invalid if the service is restarted.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`@SessionScoped` 注解表示许多请求和响应的生命周期。会话作用域是为了绕过 HTTP 的无状态协议而设计的。Servlet 容器通过能够存储和检索比一个请求和响应周期更长时间的对象来增强
    HTTP 协议。因此，会话作用域是长期存在的。会话作用域可以在超时后过期，或者如果服务重启，可能会变得无效。'
- en: The `@ApplicationScoped` annotation denotes a life cycle that exists for as
    long as the web application is running and available. The application scope, more
    importantly, is shared across all the requests, sessions, and conversation and
    custom scopes. This scope begins as soon as the web application starts up. It
    ends when the web application is shut down.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApplicationScoped` 注解表示一个生命周期，只要 web 应用程序运行并可用，它就存在。更重要的，应用程序作用域是跨所有请求、会话、会话和自定义作用域共享的。这个作用域从
    web 应用程序启动时开始。它结束于 web 应用程序关闭时。'
- en: The request, session, and application scopes are classic versions of the scope
    model. JSF and CDI also have additional scopes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请求、会话和应用程序作用域是作用域模型的经典版本。JSF 和 CDI 还具有额外的作用域。
- en: The `@javax.enterprise.context.ConversationScoped` annotation denotes a lifecycle
    that has a duration greater than one or more request and response cycles and yet
    is shorter than the session scope. CDI defines a scope called a conversation scope.
    It is a scope between the request and session scopes but also has a contextual
    association to the beans that it encapsulates. We will discuss the conversation
    scope in a later chapter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`@javax.enterprise.context.ConversationScoped` 注解表示一个生命周期，其持续时间大于一个或多个请求和响应周期，但短于会话作用域。CDI
    定义了一个称为会话作用域的范围。它是请求和会话作用域之间的范围，同时也与它所封装的豆子具有上下文关联。我们将在后面的章节中讨论会话作用域。'
- en: JSF 2.0 has defined a scope called `@javax.faces.bean.ViewScoped` that is similar
    to the conversation scope because it also has a longer life span than the request
    scope. The view scope begins when the client submits an HTTP request. It stays
    around until the user navigates to another page. This makes the `@ViewScoped`
    bean a broader and more reasonable choice for the managed bean controller than
    the `@RequestScoped` variety. A `@ViewScoped` annotation is appropriate to manage
    a one-user story, as we have seen with the CRUD example.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 定义了一个名为 `@javax.faces.bean.ViewScoped` 的作用域，它与会话作用域相似，因为它也有比请求作用域更长的生命周期。视图作用域从客户端提交
    HTTP 请求时开始。它持续存在，直到用户导航到另一个页面。这使得 `@ViewScoped` 豆子比 `@RequestScoped` 类型更适合作为管理豆子控制器。`@ViewScoped`
    注解适合管理一个用户故事，正如我们在 CRUD 示例中所看到的。
- en: Tip
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `@ViewScoped` annotation is not available for the CDI beans. If you are
    using a version of JSF before 2.2 and Java EE 7, then this annotation will not
    work with the `@javax.inject.Named` annotated beans. You have to use `@javax.faces.bean.ManagedBean`
    instead.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ViewScoped` 注解对于 CDI 豆子不可用。如果你使用的是 JSF 2.2 之前的版本和 Java EE 7，那么这个注解将无法与 `@javax.inject.Named`
    注解的豆子一起使用。你必须使用 `@javax.faces.bean.ManagedBean` 代替。'
- en: In JSF 2.2, there is the `@javax.faces.flow.FlowScoped` annotation, which is
    a CDI sanctioned extension. The flow scope is also similar to the conversation
    scope with a life span that is greater than the request-scope but shorter than
    the session scope; however, it is designed for workflow management operations.
    The flow scope allows the developer to create a set of pages with a well-defined
    entry and an exit point. One can think of this scope as being appropriate to the
    Wizard data-entry applications.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.2中，有一个`@javax.faces.flow.FlowScoped`注解，这是一个CDI授权的扩展。流程作用域也与会话作用域类似，其生命周期大于请求作用域但小于会话作用域；然而，它是为工作流管理操作设计的。流程作用域允许开发者创建一组具有明确入口和出口点的页面。可以将这个作用域视为适合向导数据输入应用程序。
- en: Finally, let's learn about the two remaining scopes. There is the POJO annotation,
    `@javax.faces.beanCustomScoped`, which allows the managed bean to evaluate the
    values at the runtime. For a custom scope, the JSF implementation will defer to
    the implementation, and so, any EL expression may be customized depending on the
    code-based values. The `@javax.faces.bean.NoneScoped` annotation is a special
    scope that implies that a managed bean has no scope at all. JSF will instantiate
    these types of none scope managed beans every time they are referenced. You might
    wonder why JSF should sanction such types of beans? A none scope bean might be
    useful in a security context or in situations where you do not want a bean to
    maintain a state.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们了解剩下的两个作用域。有一个POJO注解，`@javax.faces.beanCustomScoped`，它允许管理Bean在运行时评估值。对于自定义作用域，JSF实现将委托给实现，因此，任何EL表达式都可以根据基于代码的值进行自定义。`@javax.faces.bean.NoneScoped`注解是一个特殊的作用域，意味着管理Bean没有任何作用域。每次引用这些类型的无作用域管理Bean时，JSF都会实例化它们。你可能想知道为什么JSF应该允许这种类型的Bean？在安全上下文或你不想让Bean保持状态的情况下，无作用域Bean可能很有用。
- en: Tip
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Where are the other HTML tags?**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他HTML标签在哪里？**'
- en: There are many examples of an older version of JSF on the Internet. You might
    wonder why we have not seen tags such as `h:panel` and `h:panelGrid`. These tags
    are used to lay out the content, especially in JSF 1.*x*. The default HTML implementation
    of these tags generates the content with the HTML table elements. The modern digital
    engineer knows that building sites with the ubiquitous table elements are not
    recommended. For this reason, I chose not to build my examples with these tags.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多关于JSF旧版本的例子。你可能想知道为什么我们没有看到像`h:panel`和`h:panelGrid`这样的标签。这些标签用于布局内容，特别是在JSF
    1.*x*版本中。这些标签的默认HTML实现使用HTML表格元素生成内容。现代数字工程师知道使用无处不在的表格元素来构建网站是不推荐的。因此，我选择不使用这些标签来构建我的示例。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter about JSF forms, we explored the HTML and core JSF custom tags
    to build the answer to one of the most sought-after questions on the Internet:
    how on earth do I—as a digital developer—write a CRUD application? It is surprising
    that this simple idea is considered difficult to program.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于JSF表单的讨论中，我们探讨了HTML和核心JSF自定义标签，以构建互联网上最被寻求的答案之一：作为一个数字开发者，我究竟如何编写一个CRUD应用程序？这个简单想法被认为编程起来很困难。
- en: We built a digital JSF form that initially created a contact detail. We saw
    the Facelet view, the managed bean controller, the stateful session EJB, and the
    entity. We are modern because we took advantage of the recent HTML5 advances such
    as the Bootstrap CSS framework. We displayed a list collection of objects with
    a `<h:dataTable>` tag, which is a powerful and flexible component. We then added
    the ability to edit and remove the contact details from the application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个数字JSF表单，最初创建了一个联系详情。我们看到了Facelet视图、管理Bean控制器、有状态的会话EJB和实体。我们之所以现代，是因为我们利用了最近的HTML5进步，如Bootstrap
    CSS框架。我们使用`<h:dataTable>`标签显示对象列表集合，这是一个强大且灵活的组件。然后我们添加了编辑和从应用程序中删除联系详情的能力。
- en: In the next chapter, we will look at form validation extensively and throw in
    a mix of an AJAX communication in JSF. We have already—sort of—looked in the territory
    of validation with `<f:validateRequired>`, `<h:messages>`, and `<h:message>`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨表单验证，并在JSF中混合使用AJAX通信。我们已经——某种程度上——在验证领域进行了探索，使用了`<f:validateRequired>`、`<h:messages>`和`<h:message>`。
- en: Exercises
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'These are the questions for Chapter 3:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是第三章的问题：
- en: What are the differences between the HTML5 render kit and core custom tags in
    JSF?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML5渲染套件和JSF核心自定义标签之间有什么区别？
- en: What are the common attributes that are shared among the JSF custom tags?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JSF自定义标签之间有哪些常见的属性是共享的？
- en: 'The web applications for a business tend to be of two types: data submission
    and case working. Data submissions simply capture the data and have some limited
    validation. The other mode provides you with full control to enter new records,
    amend them, and often delete data. What do you think are the reasons for these
    two types?'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 商业网络应用通常有两种类型：数据提交和案例处理。数据提交只是捕获数据并有一些有限的验证。另一种模式提供你完全控制以输入新记录、修改它们以及通常删除数据。你认为这两种类型的原因是什么？
- en: The idiom **Create Read Update Delete** (**CRUD**) is de rigueur for a business
    facing an e-commerce application. Where have you encountered these applications?
    Are these applications exclusive to the web? Given a second chance, what can be
    done to improve the state of art of these applications? How can better digital
    transformations help these businesses and more importantly, their customers?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于面向电子商务应用的商业来说，**创建、读取、更新、删除**（**CRUD**）是必不可少的。你在哪里遇到过这些应用？这些应用是否仅限于网络？如果给你第二次机会，你将如何改进这些应用的现状？更好的数字化转型如何帮助这些企业和更重要的是，他们的客户？
- en: Write a simple JSF application that basically uses an HTML form element, `<h:form>`,
    with a command button, `<h:commandButton>`. Your task is to write a registration
    application for a local Hobby Book Club of avid readers of fiction. Your participants
    have to register online before they can attend. Start with the backing bean (managed
    controller). Think of the properties that you need to record. (Your `Registration.java`
    POJO will need contact details such as names, age, and e-mail.) At this stage,
    you do not have to persist any information to a database but it would be helpful
    if you create a book data record (`Book.java`), which contains the properties
    `title` (String), `author` (String), `genre` (String), `publisher` (String), and
    `publication year` (Integer). Write a design specification using the MVC design
    pattern.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个简单的JSF应用，基本使用HTML表单元素`<h:form>`和一个命令按钮`<h:commandButton>`。你的任务是编写一个为热衷于小说的本地爱好读书俱乐部的注册应用。你的参与者必须在线注册后才能参加。从后端bean（管理控制器）开始。考虑你需要记录的属性。（你的`Registration.java`
    POJO将需要联系详情，如姓名、年龄和电子邮件。）在这个阶段，你不需要将任何信息持久化到数据库中，但如果你创建一个图书数据记录（`Book.java`），其中包含属性`title`（字符串）、`author`（字符串）、`genre`（字符串）、`publisher`（字符串）和`publication
    year`（整数）将会很有帮助。使用MVC设计模式编写一个设计规范。
- en: In the first iteration with an imaginary stakeholder, you are required to only
    write a simple JSF form. Create a backing bean that captures the book title and
    author. You will need to `<h:outputLabel>` and `<h:inputText>`. In the book's
    source site, you will find an empty project directory with empty JSF placeholder
    pages and Bootstrap CSS and JavaScript libraries such as jQuery already set up.
    You can copy and rename this folder to get started quicker.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与一个假想的利益相关者的第一次迭代中，你只需要编写一个简单的JSF表单。创建一个后端bean来捕获书名和作者。你需要`<h:outputLabel>`和`<h:inputText>`。在书的源网站上，你会找到一个空的项目目录，其中包含空的JSF占位符页面和Bootstrap
    CSS和JavaScript库，如jQuery已经设置好。你可以复制并重命名这个文件夹以更快地开始。
- en: In order to use Bootstrap CSS in JSF, we can apply almost all of the JSF HTML
    components to the `styleClass` attribute. What are the other common attributes?
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在JSF中使用Bootstrap CSS，我们可以将几乎所有的JSF HTML组件应用到`styleClass`属性上。其他常见的属性有哪些？
- en: 'Take the Hobby Book Club application and add some other components such as
    a drop-down list: `<h:selectManyMenu>`. You will need to add properties to the
    backing bean. (This could be the genre of the book such as crime, science fiction,
    thriller, or romantic). You will need a POJO to serve as a data record for the
    registrants (perhaps a class name of `Registrant.java` will serve us well).'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将爱好读书俱乐部应用添加一些其他组件，例如下拉列表`<h:selectManyMenu>`。你需要在后端bean中添加属性。（这可能包括书籍的类型，如犯罪、科幻、惊悚或浪漫。）你需要一个POJO作为注册者的数据记录（可能`Registrant.java`类名将很好地为我们服务）。
- en: What happens if you find a rare book that defies a genre? How would you model
    this property bean and which JSF HTML custom tags would you use?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你发现一本难以归类于某一类别的罕见图书，会发生什么？你将如何建模这个属性bean，以及你会使用哪些JSF HTML自定义标签？
- en: Adapt your hobby application in order to use the other elements of the JSF HTML
    custom tags such as `<h:selectBooleanCheckbox>`. You might add a Boolean value
    to a property to capture the state when somebody in the group has reviewed the
    book.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的爱好应用程序，以便使用JSF HTML自定义标签的其他元素，例如`<h:selectBooleanCheckbox>`。你可能会给一个属性添加一个布尔值，以捕获当小组中的某个人已经审阅了书籍时的状态。
- en: What is the difference between `<h:selectOneMenu>` and `<h:selectManyCheckbox>`?
    Explain what the customer will see when confronted with `<h:selectOneListbox>`
    and `<h:selectManyListbox>`?
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<h:selectOneMenu>`和`<h:selectManyCheckbox>`之间有什么区别？解释一下当客户面对`<h:selectOneListbox>`和`<h:selectManyListbox>`时会看到什么？'
- en: In a modern digital web design, why should we avoid composing a web user interface
    with the `<h:panelGroup>` elements?
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现代数字网页设计中，为什么我们应该避免使用`<h:panelGroup>`元素来构建网页用户界面？
- en: To finish the hobby book application, we might allow a registered user to add
    a comment to their application form. They want to say what their particular specialty
    is, and it could be anything from futuristic cyberpunk Doctor Who to historical
    marine warfare around ancient Greece and Rome. What is the difference between
    `<h:inputText>` and `<h:inputTextArea>`? Can you optimize this control with the
    modern CSS frameworks?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成爱好书籍应用程序，我们可能允许注册用户向他们的申请表添加评论。他们想要表达他们的特定专长是什么，这可能是从未来的赛博朋克《博士谁》到古希腊和罗马的历史海军战争。`<h:inputText>`和`<h:inputTextArea>`之间有什么区别？你能用现代CSS框架优化这个控件吗？
- en: What happens when two customers want to edit the same contact detail record
    in the web database? How do think the application should behave? What features
    would you add? How do you think the customer will feel about your ideas?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个客户想要在网页数据库中编辑相同的联系详情记录时会发生什么？你认为应用程序应该如何表现？你会添加哪些功能？你认为客户会对你的想法有何感受？
