- en: Chapter 3. Building JSF Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"It''s the whole thing. The way something actually works on so many
    different levels. Ultimately, of course, design defines so much of our experiences."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Sir Jony Ive, Senior Vice President of Design, Apple USA* |'
  prefs: []
  type: TYPE_TB
- en: JavaServer Faces is an example of a component-oriented web application framework,
    as opposed to Java EE 8 MVC (See [Chapter 9](part0087.xhtml#aid-2IV0U1 "Chapter 9. Java
    EE MVC Framework"), *Java EE MVC Framework*), WebWork, or Apache Struts, which
    are known as request-oriented web application frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: A request-oriented framework is one where the information flow is from the web
    request to the response. Such frameworks provide you with an ability and structure
    above the `javax.servlet.http.HttpServletRequest` and `javax.servlet.http.HttpServletResponse`
    objects, but there are no special user interface components. With additional help,
    the application user must program the mapping of the parameters and attributes
    to the data entity models. The developer, therefore, has to write parsing logic.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that component-oriented frameworks, such as JSF,
    have their detractors. The quick inspection of the code resembles the components
    found in a standalone client such as Java Swing or even JavaFX, but the very same
    `HttpServletRequest` and `HttpServletResponse` lurk behind the scenes. Hence,
    a competent JSF developer has to be aware of the Servlet API and underlying servlet
    scopes. This was a valid criticism in 2004, and in the digital marketing age,
    a digital developer has to know not only Servlet, but also we can presume that
    they would be open to learning other technologies such as JavaScript. Based on
    the knowledge obtained from [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer
    Faces Lifecycle"), *JavaServer Faces Lifecycle*, we will learn about building
    the JSF forms.
  prefs: []
  type: TYPE_NORMAL
- en: Create, Retrieve, Update, and Delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will solve an everyday problem with JSF. The Java EE framework
    and enterprise application are about solving data entry issues. Unlike social
    networking software that is built with a different architecture and non-functional
    requirements such as scalability, performance, statelessness, and eventual consistency,
    Java EE applications are designed for stateful work flows, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Create, Retrieve, Update, and Delete](img/image00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the page view to create contact details
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot is the JSF application, `jsf-crud`, which shows the
    create contact details form.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, you can find the entire code for this application with the book's
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, an enterprise application captures the information from a web user,
    stores it in a data store, and allows this information to be retrieved and edited.
    There is usually an option to delete the user's information. In software engineering,
    we call this idiom Create, Retrieve, Update, and Delete (CRUD).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What constitutes the actual deletion of the user and customer data is a matter
    that ultimately affects the business owners who are under the pressure to conform
    to the local and international laws that define privacy and data protection.
  prefs: []
  type: TYPE_NORMAL
- en: A basic create entity JSF form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a basic form that captures the user's name, e-mail address, and
    date of birth. We will write this code using HTML5 and take advantage of Bootstrap
    for the modern day CSS and JavaScript. Refer to [http://getbootstrap.com/getting-started/](http://getbootstrap.com/getting-started/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the JSF Facelet view, `createContact.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You should already recognize the `<h:head>` and `<h:body>` JSF custom tags.
    As the type is a Facelet view, (`*.xhtml`), the document must actually be well-formed
    like an XML document. You should have noticed that certain HTML5 element tags
    such as `<meta>` are closed and completed; the XHTML document must be well-formed
    in JSF.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Always close the XHTML elements**'
  prefs: []
  type: TYPE_NORMAL
- en: The typical e-commerce application has web pages with standard HTML with the
    `<meta>`, `<link>`, and `<br>` tags. In the XHTML and Facelet views, these tags,
    which web designers normally leave open and hanging, must be closed. **Extensible
    Mark-up Language** (**XML**) is less forgiving and XHTML, which is derived from
    XML, must be well-formed.
  prefs: []
  type: TYPE_NORMAL
- en: The new `<h:form>` tag is a JSF custom tag that corresponds to the HTML form
    element. A JSF form element shares many of the attributes of the HTML partner.
    You can see that the `id` attribute is just the same. However, instead of the
    `class` attribute, we have the `styleClass` attribute in JSF, because in Java,
    the `java.lang.Object.getClass()` method is reserved and therefore, cannot be
    overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What is the JSF request context path expression?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The curious markup around the links to the style sheets, JavaScript, and other
    resources is the expression language: `#{request.contextPath}`. The expression
    reference ensures that the web application path is added to the URL of the JSF
    resources. Bootstrap CSS itself relies on the font glyph icons in a particular
    folder. The JSF images, JavaScript module files, and CSS files should be placed
    in the resources folder of the web root.'
  prefs: []
  type: TYPE_NORMAL
- en: The `p:role` attribute is an example of the JSF `passthrough` attribute, which
    informs the JSF render kit to send through the key and value to the rendered output.
    The `passthrough` attributes are key additions in JSF 2.2, which is a part of
    Java EE 7\. They allow JSF to play well with the recent HTML5 frameworks such
    as Bootstrap and Foundation ([http://foundation.zurb.com/](http://foundation.zurb.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an extract of the rendered HTML source output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: JSF was implemented before Bootstrap was created in Twitter. How could the JSF
    designer retrofit the framework in order to be compatible with the recent HTML5,
    CSS3, and JavaScript innovations? This is where the `passthrough` attribute helps.
    By declaring the XML namespace in XHTML with the URI [http://xmlns.jcp.org/jsf/passthrough](http://xmlns.jcp.org/jsf/passthrough).
    We can enable the feature for the page view. As you can see, the attribute name
    and value, `role="form"`, is simply passed through to the output. The `passthrough`
    attributes allow JSF to easily handle the HTML5 features such as placeholders
    in the text input fields, which we will exploit from now onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are brand new to web development, you might be scared of markup that
    appears to be overcomplicated. There are lots and lots of DIV HTML elements, which
    are often created by page designers and Interface Developers. This is the historical
    effect and just the way that HTML and the web has evolved over time. The practices
    of 2002 have no bearing on 2016\. I recommend that you read the [Appendix C](part0104.xhtml#aid-335QG1
    "Appendix C. Agile Performance – Working inside Digital Teams"), *Agile Performance
    – Working inside Digital Teams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a deeper look at `<h:form>` and fill in the missing details. Here
    is the extracted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This form is built using the Bootstrap CSS style, but we will ignore the extraneous
    details and concentrate purely on the JSF custom tags.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:selectOneMenu>` tag is a JSF custom tag that corresponds to the HTML
    form select element. The `<f:selectItem>` tag corresponds to the HTML form select
    option element. The `<h:inputText>` tag corresponds to the HTML form input element.
    The `<h:selectBooleanCheckbox>` tag is a special custom tag to represent the HTML
    select with only one checkbox element. Finally, `<h:commandButton>` represents
    the HTML form submit element.
  prefs: []
  type: TYPE_NORMAL
- en: The JSF HTML output label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<h:outputLabel>` tag renders the HTML form label element in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The developers should prefer this tag in conjunction with the other associated
    JSF form input tags because the special `for` attribute targets the correct sugared
    identifier for the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rendered output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have written the tag using the value attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to take advantage of internationalization at this point;
    so just for illustration, we could rewrite the page content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For more information about internationalization and resource bundles in JSF,
    please see the [Appendix A](part0093.xhtml#aid-2OM4A1 "Appendix A. JSF with HTML5,
    Resources, and Faces Flows"), *JSF with HTML5, Resources, and Faces Flows*. Let's
    move on to the input fields.
  prefs: []
  type: TYPE_NORMAL
- en: The JSF HTML input text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<h:inputText>` tag allows data to be entered in the form like text, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The value attribute represents a JSF expression language, and the clue is that
    the evaluation string starts with a hash character. The Expression Language value
    references a scoped backing bean `ContactDetailController.java` with the name
    of `contactDetailController`. In JSF 2.2, there are now convenience attributes
    to support the HTML5 support so that the standard `id`, `class`, and `placeholder`
    attributes work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rendered output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the sugared `createContactDetails:firstName` identifier matches the
    output of the `<h:outputLabel>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: The JSF HTML select one menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<h:selectOneMenu>` tag generates a single select drop-down list. In fact,
    it is a part of a family of selection type custom tags. See *JSF HTML select Boolean
    checkbox* in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<h:selectOneMenu>` tag corresponds to an HTML Form select tag The `value`
    attribute is again a JSF expression language string.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF, we can use another new custom tag, `<f:selectItem>`, which adds a child
    javax.faces.component.UISelectItem to the nearest parent UI component. The `<f:selectItem>`
    tag accepts an `itemLabel` and `itemValue` attribute. If you set the `itemValue`
    and do not specify the `itemLabel`, then the value becomes the label. So, for
    the first item, the option is set to `--` but the value submitted to the form
    is a blank string because we want to hint to the user that there is a value that
    ought be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rendered HTML output is instructive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The JSF HTML select Boolean checkbox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<h:selectBooleanCheckbox>` custom tag is a special case of selection where
    there is only one item that the user can choose. Typically, in a web application,
    you will find such an element in the final terms and conditions form or usually
    in the marketing e-mail section in an e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the targeted managed bean, the only value must be a Boolean type, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered output for this custom tag looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The JSF HTML command button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `<h:commandButton>` custom tags correspond to the HTML form submit element.
    They accept an action attribute in JSF that refers to a method in a backing bean.
    The syntax is again in the JSF expression language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user presses this **Submit** button, the JSF framework will find the
    named managed bean corresponding to `contactDetailController` and then invoke
    the no-arguments method: `createContact()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the expression language, it is important to note that the parentheses are
    not required because the interpreter or Facelet automatically introspects whether
    the meaning is an action (`MethodExpression`) or a value definition (`ValueExpression`).
    Be aware that most of the examples in the real world do not add the parentheses
    as a short hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `value` attribute denotes the text for the form **Submit** button. We can
    write the tag in an alternative way and achieve the same result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is taken from the body content of the custom tag. The rendered output
    of the tag looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code illustrates the output from the JSF renderer in the Mojarra
    implementation ([https://javaserverfaces.java.net/](https://javaserverfaces.java.net/)),
    which is the reference implementation. You can clearly see that the renderer writes
    an HTML submit and hidden element in the output. The hidden element captures information
    about the view state that is posted back to the JSF framework (postback), which
    allows it to restore the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here is a screenshot of the contact details form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The JSF HTML command button](img/image00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The contact details input JSF form with additional DOB fields
  prefs: []
  type: TYPE_NORMAL
- en: There are many more JSF custom tags to consider, and you will find a full table
    list of all the tags later in the chapter. Now, let's examine the backing bean
    that is also known as the controller.
  prefs: []
  type: TYPE_NORMAL
- en: The backing bean controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our simple POJO form, we need a backing bean or, in modern day JSF developer
    parlance, a managed bean controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the entire code for `ContactDetailController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For this managed bean, let's introduce you to a couple of new annotations. The
    first annotation is called `@javax.inject.Named` and it declares this POJO to
    be a CDI-managed bean, which also simultaneously declares a JSF controller. Here,
    we will explicitly declare the value of the name of the managed bean as `contactDetailController`.
    This is actually the default name of the managed bean, so we could have left it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write an alternative name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Then, JSF would give us a bean with the name `wizard`. The name of the managed
    bean helps in the expression language syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are talking about JSF, we can interchange the term backing bean with
    managed bean freely. Many professional Java web developers understand that both
    the terms mean the same thing!
  prefs: []
  type: TYPE_NORMAL
- en: The `@javax.faces.view.ViewScoped` annotation denotes that the controller has
    scoped the lifecycle of the view. The scoped view is designed for a situation
    where the application data is preserved just for one page until the user navigates
    to another page. As soon as the user navigates to another page, JSF destroys the
    bean. JSF removes the reference to the view-scoped bean from its internal data
    structure and the object is left for the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ViewScoped` annotation is new in Java EE 7 and JSF 2.2 and fixes a bug
    between the Faces and CDI specifications. This is because CDI and JSF were developed
    independently. By looking at the Javadoc, you will find an older annotation: `@javax.faces.bean.ViewScoped`,
    which comes from JSF 2.0 and was not part of the CDI specification.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, if you choose to write the `@ViewScoped` annotated controllers, you
    probably should use `@ManagedBean`. We will explain `@ViewScoped` beans later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`ContactDetailController` also has a dependency on an **Enterprise Java Bean**
    (**EJB**) service endpoint: `ContactDetailService` and most importantly, has a
    bean property: `ContactDetail`. Note the `getter` and `setter` methods and we
    will also ensure that the property is instantiated during the construction time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now turn our attention to the methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createContact()` method uses EJB to create a new contact detail. It returns
    a string, which is the next Facelet view: `index.xhtml`. This method is referenced
    by `<h:commandButton>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `retrieveAllContacts()` method invokes the data service to fetch the list
    collection of the entities. This method will be referenced by another page.
  prefs: []
  type: TYPE_NORMAL
- en: Data service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The controller relies on an entity bean: `ContactDetail`. Here is the code
    for this bean, which has been simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It uses the **Java Persistence API** (**JPA**) annotation to map the Java properties
    to a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: There are a set of annotations that declare against the entity itself. The `@Entity`
    annotation marks this POJO as a persistence capable object. The `@Table` annotation
    overrides the default database table name for the entity—instead of `CONTACT_DETAIL`,
    it becomes `CONTACT`. The `@NameQueries` and `@NameQuery` annotations define the
    name queries in the **Java Persistence Query Language** (**JPQL**).
  prefs: []
  type: TYPE_NORMAL
- en: The remaining annotations declare the metadata that is associated with the database
    table columns. The `@Id` annotation specifies the property that will be the primary
    key, which is the `id` field. The `@GenerationValue` annotation declares that
    the primary key is automatically generated. The JPA provider generates a unique
    value if there is a `0` or null value. The other annotation on this property—`@Column`—renames
    the default database table column name from `ID` to `CONTACT_ID` and sets certain
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, JPA must specify the date time type for a field with the `@Temporal`
    annotation. The annotation value can be `Temporal.DATE`, `Temporal.TIME`, or `Temporal.TIMESTAMP`.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about the JPA in my book, Java EE 7 Developer Handbook, where
    there are several concise and devoted chapters on the subject. However, this book
    concerns the web application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be apparent now that the entity bean can be directly used in a JSF
    form. Do you remember the JSF expression language for the form properties? Look
    at the following first name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As the JSF framework knows about `contactDetailController` by name, which has
    a class type of `ContactDetailController`, it can move through the object graph
    and determine the property. The controller has a property called `contactDetail`
    of the `ContactDetail` type, which has a `firstName` property of the String type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key requirement for a controller is that the entity should be instantiated
    by the time the form is submitted and when the data is retrieved from the form
    for the `remembered` values. Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of possibilities that the developer can make use of for a
    large object hierarchy. Lazy loading and lazy creation of the data structure can
    help in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look now at the enterprise service bean, `ContactDataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This class is an example of a stateful session EJB, which is essentially a poolable
    remote service endpoint in an application server with a conversational state.
    A stateful session bean is associated with a calling client.
  prefs: []
  type: TYPE_NORMAL
- en: '`ContactDetailService` has a dependency on a JPA provider, as we can see with
    the injection of the entity manager through the `@PersistenceContext` annotation.
    Note that we are using the extended variety of the persistence context because
    the conversation can live for more than one request-response cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: In a non-extended persistence conversation, EntityManager will live only as
    long as there is a JTA transaction. Once the transaction is finished in the Java
    EE model, all of the persistence objects are detached from `EntityManager` and
    they become unmanaged.
  prefs: []
  type: TYPE_NORMAL
- en: An extended persistence conversation is one where EntityManager can outlive
    the scope of a **Java Transaction API** (**JTA**) transaction. In fact, it can
    survive over several transactions. The persistence objects do not become detached
    from EntityManager in this case; the data is only saved to the database when it
    is flushed explicitly or through the special demarcation of states that the application
    server provides around the stateful session beans. For this reason, the extended
    persistence contexts can be used only in the stateful session beans.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the permission and stateful session beans, see my
    sister book, *Java EE 7 Developer Handbook*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we should only concern ourselves with the methods in `ContactDataService`.
    The `add()` method inserts a new record in the database. The `update()` method
    amends an existing record and `delete()` removes the record. The `findAll()` method
    retrieves all of the `ContactDetail` records from the underlying database. It
    uses the named JPQL query: `Contact.findAll`.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering where in the user interface is the JSF field that sets
    up the `Date of Birth (DOB)` property, as seen in the `ContactDetail` entity bean.
    We will add these fields later on.
  prefs: []
  type: TYPE_NORMAL
- en: JSF custom tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have seen, JSF comes with a wealth of custom tag libraries. In order
    to get the best out of the framework, a digital developer should learn about them
    and their abilities. The tags can be divided into namespaces as we have previously
    seen.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML render kit custom tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first set of tags in JSF 2.2 relate to the rendering of the HTML elements.
    They are in the name space: [http://xmlns.jcp.org/jsf/html](http://xmlns.jcp.org/jsf/html).
    The default implementation of the render kit in the JSF framework contains component
    tags for `javax.faces.component.UIComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table of the HTML render kit tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JSF custom tag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:column>` | This renders an instance of `javax.faces.component.UIColumn`
    that represents a single column of data in a parent UIData component. This custom
    tag is used in `<h:dataTable>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:commandButton>` | This renders an HTML input element with the submit
    or rest type. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:commandLink>` | This renders an HTML anchor element that performs like
    a submit button, and therefore, the tag must be added in an `<h:form>` tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:dataTable>` | This renders an HTML table with rows and columns including
    the table headers and table column cells. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:form>` | This renders an HTML form element. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:graphicImage>` | This renders an HTML image element. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:inputFile>` | This renders an HTML form input element with a file type
    and allows an application to upload a file from the client''s operating system.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:inputHidden>` | This renders an HTML form input element with a hidden
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:inputSecret>` | This renders an HTML form input element with a password
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:inputText>` | This renders an HTML form input element with a text type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:inputTextarea>` | This renders an HTML form text area element. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:link>` | This renders an HTML anchor element that performs an HTTP GET
    request to the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:outputFormat>` | This tag renders the parameterized text with formatted
    parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:outputLabel>` | This renders an HTML label element. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:outputLink>` | This renders an HTML anchor element that is typically
    used for non-JSF application links. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:outputText>` | This tag renders the output to the view. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:message>` | This renders a single message to a page for a specific component.
    The tag allows internationalization through a resource bundle. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:messages>` | This renders a series of messages to a page from the Faces
    Context. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:panelGrid>` | This custom tag renders components into a grid. The default
    JSF implementation uses the HTML table element. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:panelGroup>` | This custom tag organizes the nested JSF tags into defined
    groups where the layout produces and generates a single entity. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectBooleanCheckbox>` | This renders an HTML input element with a checkbox
    type and is designed for Boolean properties. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectManyCheckbox>` | This renders a list of the HTML input elements
    with the type as checkbox. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectManyListbox>` | This renders a list of the HTML select option elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectManyMenu>` | This renders a list of the HTML select option elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectOneListbox>` | This renders a list of the HTML select option elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectOneMenu>` | This renders a list of the HTML select option elements.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<h:selectOneRadio>` | This renders a list of the HTML input elements with
    the type as radio. |'
  prefs: []
  type: TYPE_TB
- en: The JSF HTML tags are divided into different kinds, such as commands, inputs,
    outputs, and types in order to handle the selection of items. There are also additional
    tags to handle special cases such as `<h:graphicImage>` to render the `<img>`
    tags and `<h:dataTable>` to render the `<table>` information.
  prefs: []
  type: TYPE_NORMAL
- en: The core JSF custom tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core JSF custom tags add the features that are independent to the HTML render
    kit tags. The namespace for these tags is [http://xmlns.jcp.org/jsf/core](http://xmlns.jcp.org/jsf/core).
    The JSF framework is extendable. If you want an alternative render kit, then all
    you have to do is add it. The core JSF custom tags will still work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table of the JSF Core tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JSF custom tag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:actionListener>` | This registers an `ActionListener` instance. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:attribute>` | This adds an attribute to `UIComponent` with the closest
    parent `UIComponent` action. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:convertDateTime>` | This registers `DateTimeConverter` to `UIComponent`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:convertNumber>` | This registers `NumberConverter` to `UIComponent`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:converter>` | This renders an HTML anchor element that performs like
    a submit button, and therefore, the tag must be added in `<h:form>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:facet>` | This adds a facet to a component. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:loadBundle>` | This loads a resource bundle that is localized for Locale
    of the current view and stores the properties as `java.util.Map`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:metadata>` | This declares the metadata facet for this view. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:param>` | This adds a parameter to `UIComponent`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:phaseListener>` | This registers a `PhaseListener` instance to the page.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:selectItem>` | This specifies an item for a select one or select many
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:selectItems>` | This specifies items for a select one or select many
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:setProperty-ActionListener>` | This registers `ActionListener` to the
    component for a particular property. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:subview>` | This creates another JSF naming context (See `<f:view>`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateDoubleRange>` | This registers `DoubleRangeValidator` to the
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLength>` | This registers `LengthValidator` to the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateLongRange>` | This registers `LongRangeValidator` to the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRegex>` | This registers a regular expression validator to the
    component. If the entire pattern matches, then it is valid. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validateRequired>` | This ensures that a value in a component is present
    when a form is submitted. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:validator>` | This registers a named Validator instance to the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:valueChangeListener>` | This registers `ValueChangeListener` to the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:verbatim>` | This adds a markup to a JSF page and allows the body content
    to pass directly to the rendered output. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:view>` | This sets parameters on the JSF current naming context for the
    page. Use this tag to override the locale, encoding, or content type. |'
  prefs: []
  type: TYPE_TB
- en: '| `<f:viewParam>` | This adds a view parameter to the metadata of a facet so
    that the page has access to query the parameters in a GET request. This tag can
    be used only in `<f:metadata>`. |'
  prefs: []
  type: TYPE_TB
- en: The purpose of many core JSF tags is to enhance and configure an `UIComponent`
    instance. You have already seen this example used with the `<f:selectItem>` tag
    in `<h:selectOneMenu>` in the previous code example, `createContact.xhtml`. (See
    the section *Basic JSF form*).
  prefs: []
  type: TYPE_NORMAL
- en: For most circumstances, the developer can add attributes, listeners, converters,
    facets, parameters, and selections to the components using the core JSF tag.
  prefs: []
  type: TYPE_NORMAL
- en: The template composition custom tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library of the template JSF custom tags provides you with the ability to
    compose pages with content from the other pages. Templating allows the content
    to reused and shared across an entire JSF application. Best of all, the templates
    can be adapted by specifying the parameters so that there is adaptability and
    flexibility in the mix. The namespace for these tags is [http://xmlns.jcp.org/jsf/facelets](http://xmlns.jcp.org/jsf/facelets),
    which underlines the technology of the Facelet view behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the template tags in JSF 2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '| JSF custom tag | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:component>` | This defines a template component and specifies the filename
    for the component. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:composition>` | This defines a page composition, which encapsulates
    the JSF content that optionally uses a template. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:debug>` | This creates and adds a special component to the current page
    that allows the debugging output to be shown. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:define>` | This defines the JSF content that is inserted into a page
    by a composition template. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:decorate>` | This defines the content that decorates specific regions
    of a JSF page. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:fragment>` | This defines a template fragment in a way that is similar
    to the `<ui:composition>` tag, except that this tag preserves the content outside
    the body instead of discarding it. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:include>` | This includes inserting another JSF page into the current
    page. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:insert>` | This inserts a named content definition into the current
    page. This tag is used in conjunction with `<ui:define>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:param>` | This passes parameters to an included file that is specified
    with `<ui:include>` or a template reference such as `<ui:composition>` or `<ui:include>`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:repeat>` | This iterates over a list collection from the bean property
    or method. This tag is an alternative way to loop through a collection similar
    to `<h:dataTable>` or `<c:forEach>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `<ui:remove>` | This removes specific marked content from a page. |'
  prefs: []
  type: TYPE_TB
- en: We have seen the operation of `<ui:composition>`, `<ui:define>`, and `<ui:insert>`
    in [Chapter 2](part0025.xhtml#aid-NQU22 "Chapter 2. JavaServer Faces Lifecycle"),
    *JavaServer Faces Lifecycle*. We will definitely be using the template JSF tags
    for the remainder of the book concerning JSF.
  prefs: []
  type: TYPE_NORMAL
- en: Common attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The JSF standard tags share many common attributes. The following table is
    a reference and some of these attributes are available for most of the HTML render
    kit tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | This specifies the HTML element identifier. JSF developers should
    use this attribute every time. |'
  prefs: []
  type: TYPE_TB
- en: '| `binding` | This binds a tag to a component instance in a managed bean. The
    JSF framework binds a component''s reference in the component tree to a scoped
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `Immedate` | This specifies to a Boolean value, if set `true`, it causes
    the JSF framework to skip the processing of validations, conversions, and events
    after the Apply Request Value stage in the JSF lifecycle. |'
  prefs: []
  type: TYPE_TB
- en: '| `rendered` | This specifies to a Boolean value, which usually defaults to
    true, whether the component should be rendered. |'
  prefs: []
  type: TYPE_TB
- en: '| `required` | This specifies to a Boolean value whether this input element
    is required for input validation. |'
  prefs: []
  type: TYPE_TB
- en: '| `styleClass` | This specifies the HTML class attribute for a rendered tag.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `stylestyle` | This specifies the HTML style attribute for the rendered tag.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `valuevalue` | This specifies a String value or expression language reference.
    |'
  prefs: []
  type: TYPE_TB
- en: Now that we have seen the JSF tags, we will move back to our CRUD example.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list collection of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For CRUD examples, we are often faced with the practical problem of displaying
    the data in the application in a meaningful context that the user can understand.
    One of the easiest ways is to just print out a list of items for the fairly simple
    data. Another way is to display a tabular view of the data. There are other solutions
    worthy of consideration if your data is a tree structure or a graph.
  prefs: []
  type: TYPE_NORMAL
- en: For our case, we will choose the second path and display the list of contact
    details in a table. In JSF, we can use the `<h:dataTable>` HTML component. This
    custom tag iterates over each object in the list and displays the specified values.
    The `<h:dataTable>` component is a very powerful and flexible tag because the
    Java web engineer can configure it in order to render the custom styles in a variety
    of layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another JSF Facelet view, `index.html`, in the `jsf-crud`
    project. As a reminder, we are using Bootstrap CSS to style. Now, here is the
    extracted code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that you will notice is that the `<h:dataTable>` tag accepts
    a value attribute, which is the JSF expression language reference to the controller's
    `retrieveAllContacts()` method. `ContactDetailController` delegates this request
    to `ContactDetailService`, the stateful session EJB that we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `var` attribute specifies the name of the JSF scope variable, which is
    the element that is created each time a component iterates through the list collection.
    The type of the element in the view is the entity bean: `ContactDetail`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `styleClass` attributes add specific CSS styles from the Bootstrap framework,
    and of course, every component can have an `id` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:dataTable>` component requires the nested delineated `<h:column>` tags
    that describe the column data for the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want header rows for the table, then you must place and add a core JSF
    tag called `<f:facet>` in the `<h:column>` tag. This tag name must be given a
    special name attribute with the `header` value. If you were to ask me: why must
    I write tags using different XML namespaces? Then my answer would be that this
    was the way the JSF designers foresaw that the core tags could be reusable to
    the other rendering kits. Hence, the tag name is `<f:facet>` and not something
    like `<h:headerColumn>`.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to show the user the information for each row, we use the `<h:outputText>`
    element. This tag accepts another expression language statement, namely, the reference
    to the property in the entity bean such as `#{contact.firstName}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the `index.html` list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying a list collection of objects](img/image00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the list view for the CRUD application
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced date time entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you notice, we neglected to add the JSF controls so that a user can add his
    or her date of birth to the contact details form. Let us presume that we have
    a directive from the UX person in our agile team and that the input has to be
    in two drop-down lists. The business wants two drop-down elements for the days
    of the month and months of the year respectfully. They also want a text entry
    for the year.
  prefs: []
  type: TYPE_NORMAL
- en: We have already covered some of the HTML selection custom tags so far in our
    JSF journey, such as `<h:selectOneMenu>` and `<h:selectBooleanCheckbox>`. Now,
    we will learn how to generate data for these tags programmatically from our managed
    bean. If we can help it—and we surely can—we truly don't want to repeat writing
    `<f:selectItem>` 31 times in a JSF view.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to add extra logic to `ContactDetailController`. These are the
    enhancements for the JSF managed bean, which provide the methods accessible to
    the page view through the expression language, which is mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add three new bean properties: `dobDay`, `dobMonth`, and `dobYear`
    to the controller. Note that `dobYear` is a string, whereas the other two are
    integers because the year field is a text field. When an integer is used, the
    default value shown in the front end is `0`, which detracts and confuses the user.
    We want the user to see an empty text field. There are getters and setters for
    these new properties.'
  prefs: []
  type: TYPE_NORMAL
- en: We enhance the `createContact()` method to take into account the date of birth
    from the three separate fields and convert them to a DOB value using a `java.util.Calendar`
    instance. Before the entity bean is saved to the database, we will set a property
    on the entity with the computed value of a `java.util.Date` type.
  prefs: []
  type: TYPE_NORMAL
- en: There are two bean property methods, `getDaysOfTheMonth()` and `getMonthsOfTheYear()`,
    which will return the static collections that are built in the static initializer
    of the class. The `daysOfTheMonth` field is a list collection of integers from
    1 to 31, and the `monthsOfTheYear` field is a map collection of the entries and
    strings associated with integers, which represent the months of the year.
  prefs: []
  type: TYPE_NORMAL
- en: We use JDK's `DateFormatSymbols` class to retrieve the long names of the months
    that are set to the application's default locale.
  prefs: []
  type: TYPE_NORMAL
- en: With these backend changes, we can adapt the JSF view in order to add the ability
    to set the applicant's date of birth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the updated changes in the JSF view, `createContactDetails.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Well, hopefully I did not scare you off and have you running up the hill! We
    are using Bootstrap CSS v3.11 here, so this is the reason you see a lot of the
    `<div>` elements in HTML with the specifically named CSS selectors such as `control-label`,
    `col-sm-6` and `row`. Bootstrap is popular framework for HTML5, CSS and JavaScript
    that helps designers and developers build responsive web sites.
  prefs: []
  type: TYPE_NORMAL
- en: As a component framework, JSF provides the basis to encapsulate the `<div>`
    layer, CSS, and JavaScript. There are a few approaches that can help. First, the
    teams can develop their custom components; second, they can leverage a third-party
    component system that has the features and customization that is required, and
    finally, the team can act as a library writer and therefore, create their own
    bespoke HTML render kit. The custom components are a lot easier to program, which
    we will talk about in [Chapter 5](part0050.xhtml#aid-1FLS41 "Chapter 5. Conversations
    and Journeys"), *Conversations and Journeys*.
  prefs: []
  type: TYPE_NORMAL
- en: If your team is interested in the component libraries, then you may want to
    look at vendor solutions such as Rich Faces ([http://richfaces.jboss.org/](http://richfaces.jboss.org/))
    and particularly, Prime Faces ([http://primefaces.org/](http://primefaces.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Let's concentrate on the `<h:selectOneMenu>` tags. This HTML custom tag from
    the JSF namespaces specifies a drop-down selection list where the user can choose
    only one item. The `value` attribute references a property in the controller bean.
    So, the expression language for the first field is `#{contactDetailController.dobDay}`.
  prefs: []
  type: TYPE_NORMAL
- en: In the parent tag, you see the `<f:selectItem>` and `<f:selectItems>` custom
    tags. The `<f:selectItem>` tag defines one menu item. It accepts an `itemLabel`
    and `itemValue` attribute. We can use it to define a default empty option.
  prefs: []
  type: TYPE_NORMAL
- en: The `<f:selectItems>` tag defines many menu items and accepts another value
    attribute, which is the expression language `#{contactDetailController.daysOfTheMonth}`.
    This expression refers to the controller getter method, `getDaysOfTheMonth()`,
    which returns `List<Integer>`. We will use `var`, `itemLabel`, and `itemValue`
    to configure how this collection renders each menu option, as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the `<h:dataTable>` tag, we can define a JSF scope variable using
    the `var` attribute and iterate effectively through the collection.
  prefs: []
  type: TYPE_NORMAL
- en: The markup for the months of the year dropdown is slightly different in `<f:selectMenu>`.
    As `getMonthsOfTheYear()` already returns a `Map<String,Integer>` collection,
    there is no need to provide the configuration of the labels and values. The custom
    tag already knows that it has to render the map collections.
  prefs: []
  type: TYPE_NORMAL
- en: The last field for the DOB year is `<h:inputText>`, and by now, you already
    know how these tags work. There are a couple of surprises that you may have noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<f:validateRequired>` tag is a validation custom tag, which specifies
    that the bean properties must be defined by the time the form is submitted. The
    `<h:message>` tag specifies an area in the HTML where we want a specific validation
    error to appear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `<h:message>` tag accepts a compulsory for attribute that refers to the
    JSF HTML form property. We can set the CSS style with the `styleClass` attribute,
    which is a form error from Bootstrap. In the next chapter, we will look at the
    validation properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the new form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhanced date time entry](img/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the create page view for the contact data application
  prefs: []
  type: TYPE_NORMAL
- en: Editing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's add one more JSF `index.xhtml` to allow the users to edit and delete
    the contact details. Before we can edit a contact detail, we must add some JSF
    links to the list view so that the user can navigate to the edit and remove pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the `<h:dataTable>` section in the `index.xhtml` view and add
    an additional column. The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two `<h:link>` tags that generate two HTML anchor element links to
    two new pages: `editContactDetail.xhtml` and `removeContactDetail.xhtml`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:link>` custom tag has an outcome attribute to generate the URL using
    the JSF navigation rules. The `value` attribute specifies the text on the link
    or you may specify the body text. The tag is clever enough that if the link does
    not exist, then it will generate a `<span>` element instead. This is a useful
    feature for prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some of the rendered output for `<h:link>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `glyphicon`, `glyphicon-edit`, and `glyph-trash` class are markups from
    Bootstrap to show the icon buttons.
  prefs: []
  type: TYPE_NORMAL
- en: With the links in place, we must now allow the editing of the contract details
    on the server side. We will adapt `ContactDetailController` with new properties
    and methods. The first property that we will introduce is `id` so that we can
    track the primary key of the contact ID in the database. We will also require
    a getter and setter for the JSF framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'On second thoughts, it would be nice to allow the user to cancel the task.
    So, we will introduce a `cancel()` method in the controller. We will also add
    a couple of methods: `findByContactId()` and `editContact()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the following code of `ContactDetailController` as it now stands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cancel()` method simply returns the next view: `index.xhtml`. It does
    nothing, which is not an error in the code, but is in fact the purpose: to go
    back to the start.'
  prefs: []
  type: TYPE_NORMAL
- en: The `findContactById()` method uses the `id` property to look up the contact
    details using the `ContactDataService` EJB. This method makes use of the `Calendar`
    instance in order to pull apart the `dob` property from the `ContactDetail` entity
    in the constituent `dobDay`, `dobMonth`, and `dobYear` properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `javax.faces.context.FacesContext` type is an aggregate object that stores
    the current request and response information. `FacesContext` can be retrieved
    using the factory method only. In the example, we will add an error message to
    the Faces response, which can be displayed in the view. The `javax.faces.application.FacesMessage`
    type is a representation of the error validation or it can be defined as a message
    resource from a external resource bundle. See [Appendix A](part0093.xhtml#aid-2OM4A1
    "Appendix A. JSF with HTML5, Resources, and Faces Flows"), *JSF with HTML5, Resources,
    and Faces Flows*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `editContact()` method is almost the same as `createContect()` because
    it reconstructs the `dob` property in the entity. The difference is that the `id`
    property in the entity is set from the controller property: `id`. Setting the
    correct primary key is extremely important because the user does not want to see
    duplicate entries. The `editContect()` method now invokes the database using `update()`
    instead of `create()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now adapt the `ContactDetail` entity with a new named query. The following
    is the modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The named `ContactDetail.findById` query uses a JPQL statement with a key parameter,
    which is denoted in the string as `:id`. We will now add an extra method to the
    EJB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the additional `ContactDetailService` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `findById()` method makes use of the named query and invokes the JPA query
    in order to retrieve a list collection of the `ContactDetail` elements. There
    should only be one element in the collection by definition as we are querying
    by a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: With these change in the backend, all we need are a few changes in the page
    view, which is almost the same as `createContactDetail.xhtml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an extract of the Facelet view, `editContactDetail.xhtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are JSF custom tags used here. The `<f:metadata>` tag is a container tag
    that declares a metadata facet for the current page.
  prefs: []
  type: TYPE_NORMAL
- en: The `<f:viewParam>` tag attaches a GET request parameter for the page as metadata
    for the current view. We will use it to attach the query parameter to the controller
    property. The name attribute specifies the query parameter name. The `value` attribute
    specifies the JSF expression language reference. Giving a URL request such as
    `/jsf-crud-1.0-SNAPSHOT/editContactDetail.xhtml?id=4` will cause the framework
    to populate the `id` property in `ContactDetailController` with the value of `4`.
    This call happens in the Restore View phase of the JSF lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the `<f:metadata>` tag declares the metadata for a single page view, it must
    be placed near the root element view of the page. The `<f:metadata>` tag must
    be placed in `<ui:define>` if it is used in a JSF template composition. In the
    example, the tag is just after `<h:body>`.
  prefs: []
  type: TYPE_NORMAL
- en: The `<f:event>` custom tag associates a JSF Faces event with a component. The
    official documentation describing this tag says that it installs a `ComponentSystemEventListener`
    instance on a target component in a page. Here, we can simply say that the tag
    associates a prerendering event with the `findByContactId()` method in the controller.
    In other words, `<f:event>` prepopulates the form with the data from the underlying
    database.
  prefs: []
  type: TYPE_NORMAL
- en: In the `<h:form>` content, we will use the `<h:hidden>` custom tag so as to
    store the current ID of the contact details. The value attribute is an expression
    reference. In this way, the identifier is propagated back to the controller when
    the user submits the form.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there are two `<h:submit>` buttons and they reference the `editContact()`
    and `cancel()` methods in the controller respectively. The intermediate attribute
    in the second `<h:submit>` button specifies that the JSF life cycle should skip
    the Process Validation state. JSF then does not apply the validation when the
    form is submitted. Instead, the life cycle moves from Apply Request Values directly
    to the Render Response state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Adding HTML entity characters to XHTML**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Facelets only support five predefined XML entity characters: `&lt`, `&gt`,
    `&amp`, `&quot`, and `&apos`. The only way to add an HTML element is through the
    hexadecimal or octal notation. The `&#160` entity represents the Unicode character
    `&nbsp` for break space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the `editContactDetail.xhtml` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing data](img/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A screenshot of the edit page view for the contact details application
  prefs: []
  type: TYPE_NORMAL
- en: Removing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our user is able to create the contact details and she can now update the entries.
    To complete our customer's journey, we should allow her to remove the entries
    as a good Net citizen. Why there are so many companies out there that want to
    block the access to delete the user's data by putting in hazards or extra hassles
    to make such a simple task so difficult is beyond me! However, we can do this
    for our contact detail application and it is now straightforward as we have the
    building blocks in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a `removeDetail()` method to `ContactDetailController`. Here is
    the extra method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This method searches for `contactDetail` by a fresh `id`. The `id` field is
    the controller's property, which is set in a hidden form field. By invoking the
    data services `findById()` method at the form submission, we will ensure that
    we retrieve the latest information from the persistence context. Maybe the user
    went off to lunch and came back and then submitted the form. With the entity found,
    we can then call the data service to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an extract of the `removeContactDetail.xhtml` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you look at this carefully, then you will see the `<table>` element that
    displays the properties of the `ContactDetail` entity; but wait a minute, where
    have the `<h:outputText>` elements gone? Well, in JSF 2, you no longer have to
    write `<h:outputText>`, just output the authoring content for the JSF managed
    bean and you can immediately write the expression directly in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, one simply writes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Which of the preceding authoring contents would you prefer to program with?
  prefs: []
  type: TYPE_NORMAL
- en: However, the DOB is a field where we will use the `<h:outputText>` element.
    The `<f:convertDateTime>` tag formats a `java.util.Date` type to a readable format.
    The pattern attribute specifies the date format pattern. This tags relies on the
    `java.text.SimpleDateFormat` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `<h:form>` tag is still required in order to allow the user to submit the
    form. It encloses the two `<h:commandButton>` tags. When the form is submitted,
    JSF invokes the `removeContact()` method in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the page also requires the `<f:metadata>` stanza that was mentioned
    earlier in the *Editing data* section of this chapter in order to fetch the contact
    details before the page is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: We have come to the end of our customer's journey with this basic digital-by-default
    JSF example. We can create, retrieve, update, and delete a contact detail from
    a database using a web form. It is really so straightforward. We have also taken
    advantage of the HTML5 framework like Bootstrap, and therefore, we can quickly
    adapt our application to a responsive web design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the screenshot for the `deleteContent.xhtml` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing data](img/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The delete page view for the contact details application
  prefs: []
  type: TYPE_NORMAL
- en: Before we close this chapter, we will have a short interlude on the JSF and
    CDI scopes.
  prefs: []
  type: TYPE_NORMAL
- en: JSF and CDI scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There has been some confusion before Java EE 7 about which annotations are correct
    to declare the managed beans. The issues are that the JavaServer Faces specification
    predates the later standard from the CDI and the fact that the scoping overlaps.
    The history of scopes comes from the original design and definition of the servlet
    container and providing convenience to the application developer. A scope is simply
    a map collection of name/value pairs. It helps to think of them as `java.util.Map`
    type hash map collections. The scopes differ in their life span.
  prefs: []
  type: TYPE_NORMAL
- en: For CDI, the package name is `javax.enterprise.context`, and for JSF managed
    beans, the package is `javax.faces.bean`.
  prefs: []
  type: TYPE_NORMAL
- en: Bean scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An `@RequestScoped` annotation denotes a controller with a lifecycle that has
    the duration for the Faces request and response. The request-scope is short-lived.
    It begins when the web client submits an HTTP request and is then processed by
    the servlet container. The scope ends when the response is sent back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The `@SessionScoped` annotation denotes a lifecycle of many requests and responses.
    The session scope is designed to get around the stateless protocol of HTTP. The
    servlet containers enhance the HTTP protocol with the ability to store and retrieve
    the objects that live longer than one request and response cycle. For this reason,
    the session scope long-lived. A session scope can expire after a time-out or may
    become invalid if the service is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: The `@ApplicationScoped` annotation denotes a life cycle that exists for as
    long as the web application is running and available. The application scope, more
    importantly, is shared across all the requests, sessions, and conversation and
    custom scopes. This scope begins as soon as the web application starts up. It
    ends when the web application is shut down.
  prefs: []
  type: TYPE_NORMAL
- en: The request, session, and application scopes are classic versions of the scope
    model. JSF and CDI also have additional scopes.
  prefs: []
  type: TYPE_NORMAL
- en: The `@javax.enterprise.context.ConversationScoped` annotation denotes a lifecycle
    that has a duration greater than one or more request and response cycles and yet
    is shorter than the session scope. CDI defines a scope called a conversation scope.
    It is a scope between the request and session scopes but also has a contextual
    association to the beans that it encapsulates. We will discuss the conversation
    scope in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.0 has defined a scope called `@javax.faces.bean.ViewScoped` that is similar
    to the conversation scope because it also has a longer life span than the request
    scope. The view scope begins when the client submits an HTTP request. It stays
    around until the user navigates to another page. This makes the `@ViewScoped`
    bean a broader and more reasonable choice for the managed bean controller than
    the `@RequestScoped` variety. A `@ViewScoped` annotation is appropriate to manage
    a one-user story, as we have seen with the CRUD example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ViewScoped` annotation is not available for the CDI beans. If you are
    using a version of JSF before 2.2 and Java EE 7, then this annotation will not
    work with the `@javax.inject.Named` annotated beans. You have to use `@javax.faces.bean.ManagedBean`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: In JSF 2.2, there is the `@javax.faces.flow.FlowScoped` annotation, which is
    a CDI sanctioned extension. The flow scope is also similar to the conversation
    scope with a life span that is greater than the request-scope but shorter than
    the session scope; however, it is designed for workflow management operations.
    The flow scope allows the developer to create a set of pages with a well-defined
    entry and an exit point. One can think of this scope as being appropriate to the
    Wizard data-entry applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's learn about the two remaining scopes. There is the POJO annotation,
    `@javax.faces.beanCustomScoped`, which allows the managed bean to evaluate the
    values at the runtime. For a custom scope, the JSF implementation will defer to
    the implementation, and so, any EL expression may be customized depending on the
    code-based values. The `@javax.faces.bean.NoneScoped` annotation is a special
    scope that implies that a managed bean has no scope at all. JSF will instantiate
    these types of none scope managed beans every time they are referenced. You might
    wonder why JSF should sanction such types of beans? A none scope bean might be
    useful in a security context or in situations where you do not want a bean to
    maintain a state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where are the other HTML tags?**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many examples of an older version of JSF on the Internet. You might
    wonder why we have not seen tags such as `h:panel` and `h:panelGrid`. These tags
    are used to lay out the content, especially in JSF 1.*x*. The default HTML implementation
    of these tags generates the content with the HTML table elements. The modern digital
    engineer knows that building sites with the ubiquitous table elements are not
    recommended. For this reason, I chose not to build my examples with these tags.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter about JSF forms, we explored the HTML and core JSF custom tags
    to build the answer to one of the most sought-after questions on the Internet:
    how on earth do I—as a digital developer—write a CRUD application? It is surprising
    that this simple idea is considered difficult to program.'
  prefs: []
  type: TYPE_NORMAL
- en: We built a digital JSF form that initially created a contact detail. We saw
    the Facelet view, the managed bean controller, the stateful session EJB, and the
    entity. We are modern because we took advantage of the recent HTML5 advances such
    as the Bootstrap CSS framework. We displayed a list collection of objects with
    a `<h:dataTable>` tag, which is a powerful and flexible component. We then added
    the ability to edit and remove the contact details from the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at form validation extensively and throw in
    a mix of an AJAX communication in JSF. We have already—sort of—looked in the territory
    of validation with `<f:validateRequired>`, `<h:messages>`, and `<h:message>`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the questions for Chapter 3:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the differences between the HTML5 render kit and core custom tags in
    JSF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common attributes that are shared among the JSF custom tags?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The web applications for a business tend to be of two types: data submission
    and case working. Data submissions simply capture the data and have some limited
    validation. The other mode provides you with full control to enter new records,
    amend them, and often delete data. What do you think are the reasons for these
    two types?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The idiom **Create Read Update Delete** (**CRUD**) is de rigueur for a business
    facing an e-commerce application. Where have you encountered these applications?
    Are these applications exclusive to the web? Given a second chance, what can be
    done to improve the state of art of these applications? How can better digital
    transformations help these businesses and more importantly, their customers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a simple JSF application that basically uses an HTML form element, `<h:form>`,
    with a command button, `<h:commandButton>`. Your task is to write a registration
    application for a local Hobby Book Club of avid readers of fiction. Your participants
    have to register online before they can attend. Start with the backing bean (managed
    controller). Think of the properties that you need to record. (Your `Registration.java`
    POJO will need contact details such as names, age, and e-mail.) At this stage,
    you do not have to persist any information to a database but it would be helpful
    if you create a book data record (`Book.java`), which contains the properties
    `title` (String), `author` (String), `genre` (String), `publisher` (String), and
    `publication year` (Integer). Write a design specification using the MVC design
    pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first iteration with an imaginary stakeholder, you are required to only
    write a simple JSF form. Create a backing bean that captures the book title and
    author. You will need to `<h:outputLabel>` and `<h:inputText>`. In the book's
    source site, you will find an empty project directory with empty JSF placeholder
    pages and Bootstrap CSS and JavaScript libraries such as jQuery already set up.
    You can copy and rename this folder to get started quicker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to use Bootstrap CSS in JSF, we can apply almost all of the JSF HTML
    components to the `styleClass` attribute. What are the other common attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take the Hobby Book Club application and add some other components such as
    a drop-down list: `<h:selectManyMenu>`. You will need to add properties to the
    backing bean. (This could be the genre of the book such as crime, science fiction,
    thriller, or romantic). You will need a POJO to serve as a data record for the
    registrants (perhaps a class name of `Registrant.java` will serve us well).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you find a rare book that defies a genre? How would you model
    this property bean and which JSF HTML custom tags would you use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adapt your hobby application in order to use the other elements of the JSF HTML
    custom tags such as `<h:selectBooleanCheckbox>`. You might add a Boolean value
    to a property to capture the state when somebody in the group has reviewed the
    book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `<h:selectOneMenu>` and `<h:selectManyCheckbox>`?
    Explain what the customer will see when confronted with `<h:selectOneListbox>`
    and `<h:selectManyListbox>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a modern digital web design, why should we avoid composing a web user interface
    with the `<h:panelGroup>` elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish the hobby book application, we might allow a registered user to add
    a comment to their application form. They want to say what their particular specialty
    is, and it could be anything from futuristic cyberpunk Doctor Who to historical
    marine warfare around ancient Greece and Rome. What is the difference between
    `<h:inputText>` and `<h:inputTextArea>`? Can you optimize this control with the
    modern CSS frameworks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when two customers want to edit the same contact detail record
    in the web database? How do think the application should behave? What features
    would you add? How do you think the customer will feel about your ideas?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
