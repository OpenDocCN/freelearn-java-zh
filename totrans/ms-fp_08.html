<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Basic Type Classes and Their Usage</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we discussed the idea of the type class and how type classes are a methodology for decoupling data from behavior. We have also seen how type classes can be treated as toolboxes that abstract away certain behavior. In essence, to a functional programmer, they are what a workshop is to a carpenter.</p>
<p>In the previous chapters, we also saw how type classes are motivated based on the practical needs that arise during functional programming. In this chapter, we will see how an entire library of classes for functional programming arise from practical needs. We'll take a look at one such library, and we will see how typical libraries are structured and how they can be used in practice.</p>
<p>The following are the topics that we will be covering in this chapter:</p>
<ul>
<li class="h1">A motivation for organizing type classes into systems and libraries</li>
<li class="h1">The <kbd>Cats</kbd> library for purely functional programming and its structure</li>
<li>Type classes <kbd>Cats</kbd> defines</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A motivation for organizing type classes into systems and libraries</h1>
                </header>
            
            <article>
                
<p>The basic principle of engineering is abstracting away what repeats. In the previous chapters, we saw how functional programming deals with effect types extensively and encapsulates side effects into them. This is because working with them directly can be tedious. It is pretty hard to analyze these data structures in an ad hoc using only the services provided to you by your programming language of choice. Hence, patterns of working with effect types get abstracted away into type classes.</p>
<p class="mce-root"/>
<p>So far, we have only seen a small amount of type classes. However, the most important thing to realize is the principle behind their creation, that is, realizing how the type classes get created and what the motivation is for their existence. The motivation for creating new type classes is precisely dealing with the complexity that side effects impose on the programmer.</p>
<p>We have also learned that the type class pattern consists of at least two parts. The first part is a declaration of the methods that are supported by the type class, and the second part is the implementation of the type class for the effect types you are going to work with. Certain effect types are embedded into the language's core. For example, in Scala, types such as <kbd>Future</kbd>, <kbd>Option</kbd>, and <kbd>Either</kbd> are present in the language core library by default. This means that you are going to be dealing with them frequently, and this, in turn, means that you will need the implementation of the type classes whenever you deal with these effect types. Basically, this means that you are going to redefine our implantation of type classes for these types every time you need them in different projects.</p>
<p>Whenever some functionality repeats from project to project, it makes sense to encapsulate it into a separate library. So, the preceding discussion shows that here, we have the situation where you have functionality that repeats from project to project. The first one is the type classes themselves that we use in multiple projects. For example, Monad deals with sequential composition, and sequential composition is frequent in both the functional and non-functional worlds.</p>
<p>Another item that repeats from project to project is the implementation of the type classes for frequently repeating effect types.</p>
<p>The preceding argument can be extended a little bit to the effect types themselves. Previously, we mentioned that the core libraries of functional languages usually include support for frequently encountered effect types. However, it is possible to imagine a situation where you're going to want to define the effect types yourself. For example, you may be dealing with some new effects that you want to encapsulate, or maybe you are going to define something that is specific to your own use case, and your own project.</p>
<p>With that, you'll notice that certain side effects that are not members of the core library start repeating from project to project. In this case, it would be wise to encapsulate them into a separate library, too. Of course, if you are frequently dealing with the same effect types that are not present in the language core, it is also a good idea to define the type class implementations for them in the library as well.</p>
<p class="mce-root"/>
<p>This is because whenever you need these effect types, you will also need the type classes to work with them. So, if you are going to encapsulate the effect types into a separate library, you will also need to encapsulate the type class implementations in that library as well.</p>
<p>To summarize the preceding argument, we need to encapsulate three things:</p>
<ul>
<li>The type class definitions</li>
<li>The type class implementations</li>
<li>The frequently encountered effect types that are not present in the language core and the type class implementations for them</li>
</ul>
<p>Such libraries for purely functional programming have been implemented for various programming languages. Now, let's take a look at what such a library may look like and how you can use it in practice. We will use a library called <kbd>Cats</kbd>, which comes from Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Cats library for purely functional programming</h1>
                </header>
            
            <article>
                
<p>In this section, we will introduce the library that we will be using for purely functional programming in Scala. It encapsulates frequently encountered type classes, implementations of them for frequently encountered effect types, and some effect types as well.</p>
<p>In this section, we will dive deeper into the structure of the library, and we will see how you can use it in practice. We will be following an example of a <kbd>Monad</kbd> type class that we discussed in the previous chapters. We will see how this type class is defined in this library and how it is implemented for its data types.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The structure of the library</h1>
                </header>
            
            <article>
                
<p><span>The library consists of the top-level package and its subpackages. The top-level package is called </span><kbd>cats</kbd><span> and is a location where basic type classes are defined:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/57e96392-216e-4c9e-8d27-bde045a1f7c9.png"/></div>
<p>Apart from that, there are several subpackages present in the top-level package. The most important ones are <kbd>instances</kbd>, <kbd>data</kbd>, and <kbd>syntax</kbd>.</p>
<p>The <kbd>instances</kbd> package contains the implementations of the type classes for basic data types that are present in the language core and the ones defined by the <kbd>Cats</kbd> library. Finally, data types that are frequently encountered and absent from the language core are defined under the <kbd>data</kbd> package.</p>
<p>We will now take a look at each of these structural pieces in detail. We will start from the top level package, that is, <kbd>cats</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core</h1>
                </header>
            
            <article>
                
<p>The core package, <kbd>cats</kbd>, of the library exposes the following API:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/89caab0d-1699-4481-89fd-58c3aa51e29a.png"/></div>
<p class="mce-root">The core package contains a list of all the type classes that are defined by the library. The type classes pattern in the <kbd>Cats</kbd> implementation usually consists of a trait and its companion object.</p>
<p class="mce-root">Let's use an example of <kbd>Monad</kbd> to take a look at what a typical type class looks like in the context of the library:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3c0d41ca-1195-4e93-9f52-67a917eca5ca.png"/></div>
<p>Let us now take a closer look at how the type classes in the type class hierarchy of <kbd>Cats</kbd> are structured.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type class hierarchy</h1>
                </header>
            
            <article>
                
<p>The first thing to notice here is that the type classes are defined in the format that we saw in the previous chapter. Another thing to notice is the hierarchy of type classes in the <kbd>Cats</kbd> library. So, for example, the <kbd>Monad</kbd> class extends the <kbd>FlatMap</kbd> and <kbd>Applicative</kbd> type classes, and if you take a look at the linear super types of the type class, you will see that the ancestors are far more numerous. Also, if you have a look at the subclasses, you will notice that a number of type classes also extend the <kbd>Monad</kbd> type class.</p>
<p>The reason for this hierarchy is that the <kbd>Cats</kbd> library is quite fine-grained. We previously discussed that type classes can be treated as containers for methods that you're going to use. Type classes such as <kbd>Monad</kbd> may define several methods at once. Therefore, it may be reasonable to have a separate type class for each of the method. Let us now discuss the abstract methods that <kbd>Monad</kbd> defines.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Abstract methods</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the <em>value member</em> section of the Scaladoc documentation of the <kbd>Monad</kbd> implementation by <kbd>Cats</kbd>. The abstract members section is the most important section of any type cause definition. A type class is a declaration of certain tools, and its concrete instances must support these tools. They are declared, but not implemented in the type class trait. So, the abstract methods defined by a type class constitute a definition of this type class.</p>
<p>Concretely, in the case of Monad, we have three abstract methods, as follows:</p>
<ul>
<li>There is a <kbd>flatMap</kbd> method, which we are already familiar with.</li>
<li>The pure method is able to lift any value into an effect type of <kbd>F</kbd>.</li>
<li>There is a <kbd>tailRecM</kbd> and type class. It is a tail recursive Monadic loop. The intuition for this method is as follows. Monad's <kbd>flatMap</kbd> defines a sequential composition of effectful computations. Where there is a sequence, a loop may also be desirable. A loop is a sequence of instructions that repeat over and over. Therefore, a loop is built on top of the sequential composition. If you define the sequential composition, you can use it to also define the loop. The role of <kbd>tailRecM</kbd> is to provide such a loop for the functional programming under effect types. You can think of it as a <kbd>while</kbd> loop of pure functional programming. We will discuss this method in more detail later on in the chapter.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concrete methods</h1>
                </header>
            
            <article>
                
<p>Besides abstract methods, the <kbd>Monad</kbd> type class provides a bunch of predefined concrete value members. These are implemented by default in the type class, so when you define the type class instance, you do not need to provide the implementation of these value members. Their definitions are based on the abstract value members that we saw previously. This means that every method that you encounter under concrete value members can be defined in terms of the abstract value members we saw previously.</p>
<p>It is very common for concrete value members to contain methods that are abstract value members in a superclass of the type class in question. Take, for example, the <kbd>map</kbd> method, which we are already familiar with. Technically, it comes as an abstract member of the <kbd>Functor</kbd> type class. However, it is possible to define a type class in terms of only <kbd>flatMap</kbd> and pure functions. These two functions are abstract members of the <kbd>Monad</kbd> class, and hence we can override the inherited <kbd>map</kbd> function with a concrete implementation of it, as follows:</p>
<pre>def map[A, B](fa: F[A])(f: A =&gt; B): F[B] = fm.flatMap(fa)(x =&gt; pure(f(x)))</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In the preceding code snippet, you can see how exactly that function can be implemented when you have <kbd>flatMap</kbd> and <kbd>pure</kbd> functions. A word of caution, that this kind of implementation based on the <kbd>flatMap</kbd> and <kbd>pure</kbd> functions is not always desirable. There are situations where you will want to have a custom implementation of the functions that can be implemented in terms of the abstract methods. In some scenarios, reusing the functionality that you already have is not always the best solution.</p>
<p>The intuition for this logic is as follows. We have already discussed that sequential composition in pure functional programming is facilitated by Monad. Later in this chapter, we will see a type class that has been designed for parallel composition. The operator to compose two computationals in parallel can be implemented in two ways. One way is what you would expect from real parallelism. It performs computations independently. For example, if one computation fails, the other computation will still continue and will still produce a value. However, it is possible to implement the parallel composition operator with the help of sequential composition. You may have an implementation of such a composition that just composes two computations sequentially, although you will have it named as a parallel composition operator. So, if you have a sequential composition operator such as <kbd>flatMap</kbd>, a naive parallel composition operator will be defined as a sequential composition of the computations using this sequential composition operator.</p>
<p>The reason we are having this discussion is that Monad inherits from the Applicative type class. The Applicative type class was designed for parallel computation. It contains a method called <kbd>ap</kbd> that is designed to compose computations in parallel. However, when we discussed the <kbd>Monad</kbd> type class in the past, we did not see this method among the abstract members. This is because it is a concrete member of the <kbd>Monad</kbd> type class, which means that it was implemented using the methods defined by Monad—the <kbd>flatMap</kbd> and the <kbd>pure</kbd> functions. In practice, it means that if you want to perform a parallel composition, you may be able to, depending on either the Monad or Applicative type class. However, if you depend on Monad, you may not get true parallelism, since its parallelism operator may be implemented in terms of sequential composition. So, it is very important to understand the mechanics of type classes and not to treat them as something magical because you might be in for an unexpected error.</p>
<p>Type classes have a solid mathematical foundation in the form of Category Theory. We will not be discussing the theory in this pragmatic guide to functional programming. However, in the next section, we will touch upon the mathematical nature of type classes and discuss which mathematical laws they must obey.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Laws</h1>
                </header>
            
            <article>
                
<p>Type classes are defined in terms of the methods they support. When defining a type class, you do not have an idea of how exactly the methods will be implemented for every given data type. However, you do have a rough idea of what these methods will do. For example, we have a rough idea that <kbd>flatMap</kbd> is responsible for sequential composition, and pure corresponds to lifting a value into an effect type without doing anything else.</p>
<p>This kind of information regarding how the methods should behave can be encapsulated in terms of the mathematical laws that the type class must obey. In fact, the majority of type classes can be viewed from a mathematical perspective, and so there are certain laws that they must obey.</p>
<p>Let's take a look at the laws that Monads must obey. There are three of them, as follows:</p>
<ol>
<li><strong>Left identity</strong>: <kbd>pure(a).flatMap(f) == f(a)</kbd>. This means that if you have a raw value, <kbd>a</kbd>, and a function, <kbd>f</kbd>, which takes that value as an input and computes an effect type out of it, the effect of applying this function directly on <kbd>a</kbd> should be the same as if you first used the <kbd>pure</kbd> function on <kbd>a</kbd> and flatMapped the result with <kbd>f</kbd>.</li>
<li><strong>Right identity</strong>: <kbd>m.flatMap(pure) == m</kbd>. This means that a pure function must lift a value into the effect type without performing any other action. The effect of this function is nil. This also means that if you are using the <kbd>flatMap</kbd> function on pure, pure must behave as an identity, meaning the effect type you flatMapped will be equal to the result of flatMapping.</li>
<li><strong>Associativity</strong>: <kbd>m.flatMap(f).flatMap(g) == m.flatMap(a =&gt; f(a).flatMap(g))</kbd>. Basically, this law states that the precedence of the <kbd>flatMap</kbd> application do not matter. Think of the associativity in the context of the <kbd>+</kbd> operator—<kbd>(a + b) + c == a + (b + c)</kbd>.</li>
</ol>
<p>For the majority of type classes out there, you should expect some mathematical laws to be defined. The meaning of them is that they provide certain guarantees that you can rely on when programming your software. For every concrete implementation of the <kbd>Monad</kbd> type class, the preceding mathematical laws must hold true. For any other type class, all of its implementations must obey its own laws.</p>
<p>Since there is a requirement for every type class implementation to obey certain laws, it is reasonable to expect that all of your implementations must be tested with respect to these laws. Since the laws are not dependent on a particular implementation of a type class and should hold true for every implementation of the type class, it is also reasonable to have the tests defined in the same library that defines the type classes.</p>
<p class="mce-root"/>
<p>We do this so that we do not need to redefine these tests every time. Indeed, these tests are defined in a separate module of the <kbd>Cats</kbd> library—<kbd>cats-laws</kbd>. The module defines the laws for every cats type class and provides an integration with the majority of popular test frameworks so that once you define your own implementation of a type class, you do not need to define the tests to check this implementation against the mathematical laws.</p>
<p>For example, this is how tests for Monad are defined:</p>
<pre>implicit override def F: Monad[F]<br/>def monadLeftIdentity[A, B](a: A, f: A =&gt; F[B]): IsEq[F[B]] =<br/> F.pure(a).flatMap(f) &lt;-&gt; f(a)<br/>def monadRightIdentity[A](fa: F[A]): IsEq[F[A]] =<br/> fa.flatMap(F.pure) &lt;-&gt; fa<br/>/**<br/> * Make sure that map and flatMap are consistent.<br/> */<br/> def mapFlatMapCoherence[A, B](fa: F[A], f: A =&gt; B): IsEq[F[B]] =<br/>  fa.flatMap(a =&gt; F.pure(f(a))) &lt;-&gt; fa.map(f)<br/> lazy val tailRecMStackSafety: IsEq[F[Int]] = {<br/>   val n = 50000<br/>   val res = F.tailRecM(0)(i =&gt; F.pure(if (i &lt; n) Either.left(i + 1)<br/>    else Either.right(i)))<br/>   res &lt;-&gt; F.pure(n)<br/> }</pre>
<p>Next, let us discuss how to use methods defined by <kbd>Monad</kbd> conveniently from the Scala code with <kbd>Cats</kbd>. Let us have a look at what infrastructure <kbd>Cats</kbd> provides to expose methods on effect types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Syntax</h1>
                </header>
            
            <article>
                
<p>We should mention here that the requirement to use the implicit mechanism with a <em><span>Rich Wrapper</span></em> pattern is a requirement that's specific to Scala. Scala is a language that mixes object-oriented and purely functional styles. This is why certain functional programming features such as type classes are not a part of the language and are implemented in a more generic way instead. This means that in Scala, method injection and the type class pattern are not first-class citizens. They are not defined at the language level. Instead, they leverage a more general mechanism that is defined on the class level—the implicit mechanism. Hence, in order to seamlessly use type classes in a Scala project, you need to use this mechanism so that they take effect manually.</p>
<p class="mce-root"/>
<p>A note should be taken that this may not be true for other functional languages. For example, Haskell has language-level support for the type class style of programming. This is why you don't need to bother with method injection. This is because the language itself does all of the necessary work for you.</p>
<p>However, languages such as Scala that do not have first-class citizen support for style may require you to use such a mechanism. The exact approaches to type class programming may vary from language to language. In this section, we will take a look at how this works for Scala.</p>
<p>We previously discussed that method injection in Scala happens with the help of the implicit mechanism and the <em><span>Rich Wrapper</span></em> pattern. Since this kind of mechanism to inject methods is defined for every type class, it makes sense to define the required Rich Wrappers in the <kbd>Cats</kbd> library together with all of the type classes. This is indeed done in the <kbd>Cats</kbd> library, in the <kbd>syntax</kbd> package, like following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4a746d62-f06f-4c52-90e1-b2f9fd93c7fb.png"/></div>
<p class="mce-root"/>
<p>The package contains a set of classes and traits. What you need to notice are the naming conventions they follow. You will see that lots of the traits and classes end in <kbd>Ops</kbd> and <kbd>Syntax</kbd>, for example, <kbd>MonadOps</kbd> or <kbd>MonadSyntax</kbd>.</p>
<p>Besides classes and traits, you will also notice a set of singleton objects are present in this package. The names of these objects mimic the names of the type classes they are defined for.</p>
<p>Let's take a look at how this mechanism works for the <kbd>Monad</kbd> type class:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73859f8e-f26d-4159-a9de-a7e3e4a1a574.png"/></div>
<p class="mce-root"/>
<p>First, let's take a look at the <kbd>MonadOps</kbd> class. This is a Rich Wrapper that is supposed to be used for <kbd>Monad</kbd> method injection. It injects the methods provided by the <kbd>Monad</kbd> type class into an effect type, <kbd>f</kbd>. One thing to notice about the methods it injects is that all of them have an implicit <kbd>Monad</kbd> argument. They delegate their implementation to this type class.</p>
<p>However, the <kbd>MonadOps</kbd> class is not an implicit class—it is an ordinary class. We learned previously that for the <em>Rich Wrapper</em> pattern, we need an implicit conversion from an effect type to the Rich Wrapper. So, where is this conversion defined, and how is it brought into scope? To find out, let's take a look at the <kbd>MonadSyntax</kbd> trait:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/074e0741-687d-457e-a8e2-14cc3aefbf88.png"/></div>
<p>As you can see, the <kbd>MonadSyntax</kbd> contains implicit methods. These are supposed to convert any object, <kbd>F[A]</kbd>, into <kbd>MonadOps[F[A]]</kbd>. However, how do you bring the methods into scope?</p>
<p class="mce-root"/>
<p>For this, let's take a look at the Monad singleton:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1332acf1-bb04-4a99-b52a-3a0bcec796c2.png"/></div>
<p>As you can see in the preceding screenshot, the singleton extends the <kbd>MonadSyntax</kbd> trait. So basically, this is a concrete implementation of the <kbd>MonadSyntax</kbd> trait. You can import all of the contents of this object, and you will have the Rich Wrapper for <kbd>MonadOps</kbd>.</p>
<p>Why is it implemented as a combination of a singleton and a trait? Would it not be more convenient to implement the <span>Rich Wrapper</span> as one singleton object that contains all of the required methods?</p>
<p>This can be understood if you take a look at the sheer amount of singleton objects present in the <kbd>syntax</kbd> package. If you are using a lot of type classes in a single Scala file, all of the imports for each type class can be tedious to write and track. Hence, you might want to just bring in scope the syntax for all available type classes at once, even though you will never use the majority of them.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Precisely for this reason, there is an <kbd>all</kbd> singleton object, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/51ef1905-4d96-45f3-a975-db8a94c2971a.png"/></p>
<p>If you take a look at this object and its supertypes, you'll see that its ancestors constitute a massive list. They include all of the syntax traits defined in the package. This means that this singleton object contains all of the implicit conversion from effect types to Rich Wrappers that inject methods defined in the type classes into the effect types in question. You can import all of the contents of this object into your project and have all of these implicit conversions in scope. This is exactly why we define implicit conversions inside the trait and not inside singleton objects. If you define these implicit conversions as part of singleton objects, you will not be able to combine these singleton objects into one object, because you cannot inherit from a singleton object. However, you can inherit from multiple traits in Scala. Therefore, the reason for having traits is modularity and composability.</p>
<p>To summarize, the <kbd>Cats</kbd> library contains two major components:</p>
<ul>
<li>It contains the <span>Rich Wrapper</span> classes that wrap effect types and inject methods defined by the type classes into these effect types</li>
<li>It contains implicit conversions from these effect types to the <span>Rich Wrapper</span> classes</li>
</ul>
<p>Later in this chapter, we will see examples of how to use these capabilities in practice.</p>
<p class="mce-root">Next, let's take a look at the structure and the purpose of the <kbd>instances</kbd> package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instances</h1>
                </header>
            
            <article>
                
<p>The <kbd>instances</kbd> package exposes the following API:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/af1ffeec-e2b4-40b3-91b0-7abca12e0880.png" style="width:34.67em;height:28.50em;"/></div>
<p>As you can see from the preceding screenshot, the <kbd>instances</kbd> package contains quite a lot of entities. As in the case of the <kbd>syntax</kbd> package, the main thing to notice here is the naming convention of these entities. First, we have a set of traits and classes. They are named as follows—the first part of the name is the name of the type for which the instances are defined, and then there's the <kbd>Instances</kbd> suffix.</p>
<p>There are also singleton objects, which are named after the types for which the instances are defined.</p>
<p>Let's take a look at what one of the instances traits looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8398a71f-5910-43e2-9d41-37fd43946f58.png"/></div>
<p>In the preceding screenshot, you can see the structure of the <kbd>FutureInstances</kbd> trait. All of the methods are defined as <kbd>implicit</kbd> methods, which means they will be brought into the implicit scope whenever the members of this trait are imported. Another important thing to notice is the result types of the methods. These result types are all some kind of type class. It is the meaning of these methods to provide the implicit implementations of various type classes for a given effect type. Also notice that the trait contains a lot of methods for various type classes, but all of them are parametrized by the <kbd>Future</kbd> type. All of the type classes are implemented for this effect type.</p>
<p class="mce-root"/>
<p>Similarly to the case of the <kbd>syntax</kbd> package, the traits are then used to create singleton objects. For example, let's take a look at the <kbd>future</kbd> singleton:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4bb931b8-754c-4440-a36a-c97d9c48bf18.png"/></div>
<p class="mce-root"/>
<p>The <kbd>future</kbd> singleton object extends the <kbd>FutureInstances</kbd> trait, and the same pattern repeats for all of the other singleton objects present in the <kbd>instances</kbd> package. The reason for having the singletons extending the traits is similar to the situation with the <kbd>syntax</kbd> package:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bc1a769f-6656-47ae-a76d-d46b9d0b40ee.png"/></div>
<p>The package also defines an <kbd>all</kbd> singleton object, which extends all of the other traits present in the package. The value of this strategy is that in order to bring the standard implementations of type classes in scope, all you need to do is import the contents of the <kbd>all</kbd> object. You do not need to import the implementation separately for every type.</p>
<p>Finally, let's take a look at the last essential part of the <kbd>Cats</kbd> library, that is, the <kbd>data</kbd> package.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data</h1>
                </header>
            
            <article>
                
<p>Let us now discuss the <kbd>data</kbd> package, which is another package you will use a lot in daily functional programming with <kbd>Cats</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6ba84616-5235-4e68-87b5-0701bae792c6.png" style="width:30.08em;height:34.25em;"/></div>
<p>Previously, we discussed that the main utility of having a library such as <kbd>cat</kbd> is to abstract away the common type classes for functional programming. We have also seen that not only do the type classes get abstracted, but also all of the various kinds of supporting stuff to use them in practice efficiently. This supporting stuff includes the mechanism for syntax injection and the default implementations for commonly encountered effect types.</p>
<p>A final piece of the supporting infrastructure that cats provides is a set of common effect types. These are encapsulated under the <kbd>data</kbd> package. Under this package, you will encounter various data types that you can use to express your side effects in a purely functional way.</p>
<p>For example, there are data types such as <kbd>Reader</kbd>, <kbd>Writer</kbd>, and others. The effect types are often not related one to another, and you can really use each of them independently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Infrastructure synergy</h1>
                </header>
            
            <article>
                
<p>In this section, we have seen how cats defines its type classes and how it can be used in functional programming. The main points to understand about the <kbd>Cats</kbd> library are regarding the supporting infrastructure that it provides to you as a functional programmer, and how exactly to use it in practice.</p>
<p>The supporting infrastructure in questions provides a set of the type classes, their implementations for the commonly encountered data types, and a mechanism to inject their methods into your effect types. Also, cats provides a set of commonly encountered effect types.</p>
<p>The library is very modular, and you can use various parts of it independently from the rest of the library. So, it is a good strategy for beginner programmers so that they can simply start with one or two basic type classes and use the library to bring them in scope. As you gradually progress as a functional programmer, you will start to pick up and familiarize yourself with more and more type classes and chunks of this library.</p>
<p>In this section, we have familiarized ourselves with the general structure of the <kbd>Cats</kbd> library. In the rest of this chapter, we will familiarize ourselves with certain commonly encountered type classes. We will see how to use them in practice. We will also have a look at some of the mechanics for how the type classes are implemented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type classes</h1>
                </header>
            
            <article>
                
<p>So far, we have performed a bird's-eye overview of the <kbd>Cats</kbd> library and its structure. In this section, we'll have a look at some individual type classes from the <kbd>Cats</kbd> library that are frequently used in real-world projects. For every such type class, will take a look at the motivation as to why it exists. We will discuss their methods and behavior in detail. We will also take a look at examples of the usage of the type class. Finally, we will take a look at the implementation of the type class for various effect types, and take a look at how the class is implemented for popular types so that you have an idea of what an implementation of the type class might look like.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monad</h1>
                </header>
            
            <article>
                
<p>Let us have a look at how you can use type classes from the <kbd>Cats</kbd> library on an example of <kbd>Monad</kbd>, the type class we are already familiar with.</p>
<p>In the previous sections, in order to use a <kbd>Monad</kbd> type class, we defined it as ad hoc. However, the <kbd>Cats</kbd> library provides all of the abstractions we need so that we don't need to define this type class and its syntax ourselves.</p>
<p>So, how do you use the <kbd>Monad</kbd> type class in the context of the logging example from <a href="a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml" target="_blank">Chapter 7</a>, <em>The Idea of the Type Classes</em>? As you may recall, in that chapter, we took a look at an example of logging capabilities and discussed that it is a good example of the sequential composition that can be handled by Monad. So, let's take a look at how this can be done with <kbd>cats</kbd>:</p>
<pre>import cats.Monad, cats.syntax.monad._</pre>
<p>First of all, we no longer need to define the trait of Monad ourselves as well as its companion object where we normally defined the syntax for it. All we need to do is perform some imports from cats. In the preceding code, you can see that first of all we perform an import of the <kbd>Monad</kbd> type from the <kbd>cats</kbd> package, and then we import the syntax for the Monad. We have already discussed how this mechanism works in the previous section of this chapter.</p>
<p>After that, we can define the method  from <a href="a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml" target="_blank">Chapter 7</a>, <em>The Idea of the Type Classes</em>, <span>for adding two integers and writing to the login process</span>, as follows:</p>
<pre>def add[F[_]](a: Double, b: Double)(implicit M: Monad[F], L: Logging[F]): F[Double] =<br/> for {<br/>   _ &lt;- L.log(s"Adding $a to $b")<br/>   res = a + b<br/>   _ &lt;- L.log(s"The result of the operation is $res")<br/> } yield res<br/> println(add[SimpleWriter](1, 2)) // SimpleWriter(List(Adding 1.0 to<br/> 2.0, The result of the operation is 3.0),3.0)</pre>
<p>Note that the definition looks exactly the same as the one from <a href="a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml" target="_blank">Chapter 7</a>, <em>The Idea of the Type Classes</em>. However, the semantics is a bit different. The Monad type comes from the <kbd>cats</kbd> package and is not defined as ad hoc.</p>
<p class="mce-root"/>
<p>Also, in order to use the type class with the <kbd>SimpleWriter</kbd> effect type that we defined in <a href="a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml" target="_blank">Chapter 7</a><span>, </span><em>The Idea of the Type Classes</em>, we still need to add an implementation of the Monad for this data type. We can do so as follows:</p>
<pre>implicit val monad: Monad[SimpleWriter] = new Monad[SimpleWriter] {<br/>  override def map[A, B](fa: SimpleWriter[A])(f: A =&gt; B):<br/>   SimpleWriter[B] = fa.copy(value = f(fa.value))<br/>  override def flatMap[A, B](fa: SimpleWriter[A])(f: A =&gt;  <br/>   SimpleWriter[B]): SimpleWriter[B] = {<br/>     val res = f(fa.value)<br/>     SimpleWriter(fa.log ++ res.log, res.value)<br/>  }<br/>  override def pure[A](a: A): SimpleWriter[A] = SimpleWriter(Nil, a)<br/> <br/>  override def tailRecM[A, B](a: A)(f: A =&gt;<br/>   SimpleWriter[Either[A,B]]): SimpleWriter[B] = ???<br/>}</pre>
<p><span>Actually, </span><kbd>cats</kbd><span> already provides a type similar to our </span><kbd>SimpleWriter</kbd><span> effect type that is intended precisely for logging. Let us now discuss how to get rid of <kbd>SimpleWriter</kbd> in favor of the capabilities <kbd>cats</kbd> provides.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writer effect type</h1>
                </header>
            
            <article>
                
<p>The Writer effect type provides us with a bit more of a generic type class than the <kbd>SimpleWriter</kbd> implementation. However, if we use it, we do not need to define the <kbd>SimplerWriter</kbd> type, as well as an implementation of the type classes for it. Since cats provides the implementation of its type classes for its data types, we don't need to worry about doing this ourselves.</p>
<p>As you may recall, our <kbd>SimpleWriter</kbd> object is essentially a pair. The first element of the pair is a list of strings which represents all of the logging messages that were logged by a computation. The other object of a pair is a value that was computed by the computation.</p>
<p>The cats implementation of the <kbd>Writer</kbd> object is essentially very similar to our simpler Writer implementation, except the first element of a pair is not a list of strings but an arbitrary type. This has a certain utility, because now you have the ability to use it for logging data structures other than lists of strings.</p>
<p class="mce-root"/>
<p>The <kbd>SimpleWriter</kbd> that we are using can be expressed in terms of the cats Writer if we explicitly specify the type in which the log messages are stored:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/556bd98d-0ac0-445e-b5ec-8628c4b34067.png"/></div>
<p>In the preceding screenshot, you can see the documentation of the Writer singleton object from the <kbd>data</kbd> package. This object can be used to write log messages into a Writer effect type. The two most important methods over here are <kbd>tell</kbd> and <kbd>value</kbd>. The <kbd>tell</kbd> method writes a message into the log and the <kbd>value</kbd> method lifts an arbitrary value into the Writer data structure with an empty log message. The Writer data type has a <kbd>Monad</kbd> instance that defines how to sequentially compose two Writers. During the sequential composition, the logs of two effect types are combined into one.</p>
<p>Also, if you look through the <kbd>data</kbd> package of <kbd>cats</kbd>, you will discover that there is no trait or class called Writer. The real name of the Writer data type is <kbd>WriterT</kbd>. One thing to remember about <kbd>cats</kbd> is that it aims to provide highly generic and abstract tools that can be used in a wide range of different scenarios. So, in this particular situation, the technique of Monad Transformers is used, hence why is has the strange name of <kbd>WriterT</kbd>. For the time being, you don't need to worry about the Monad Transformers, and you can use the Writer type, which is defined in <kbd>cats</kbd> in terms of <kbd>WriterT</kbd>. The Writer singleton provides a convenient set of methods to deal with it.</p>
<p class="mce-root"/>
<p>Since the Writer data type is a standard data type of <kbd>cats</kbd>, we can replace our custom <kbd>SimpleWriter</kbd> with the Writer that comes from <kbd>cats</kbd>, and we can also remove the Logging type class from our application altogether. The reason we do this is to standardize on the <kbd>Cats</kbd> library. This standardization makes the code more compact, eliminates redundancy, and increases reliability. We do this because we are using standard tools instead of reinventing them ad hoc.</p>
<p><span>In the code snippet, you can see an implementation of an addition method from </span><a href="a23f2254-09d2-4335-8b5f-a3f9256eec14.xhtml" target="_blank">Chapter 7</a><span>, </span><em>The Idea of the Type Classes,</em><span> using the capabilities from </span><kbd>cats</kbd><span> that we </span>discussed<span> previously.</span></p>
<pre>def add(a: Double, b: Double): Writer[List[String], Double] =<br/>  for {<br/>    _ &lt;- Writer.tell(List(s"Adding $a to $b"))<br/>    res = a + b<br/>    _ &lt;- Writer.tell(List(s"The result of the operation is $res"))<br/>  } yield res<br/>  println(add(1, 2)) // WriterT((List(Adding 1.0 to 2.0,<br/>   The result of the operation is 3.0),3.0))</pre>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The tailRecM method</h1>
                </header>
            
            <article>
                
<p>Previously in this section, we touched on the <kbd>tailRecM</kbd> method briefly. It is pretty useful in certain situations, because it allows you to define loops in the context of an effect type. In this subsection, let's take a more detailed look at its signature and at how this method works:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77354c52-e187-496e-944b-788b880e01d4.png"/></div>
<p>Let's take a look at the arguments of this method. First of all, let's take a look at the second argument of this method, the <kbd>f</kbd> function. The function takes a raw value of type <kbd>A</kbd>, and the result of this function is an effect type, which is <kbd>F[Either[A, B]]</kbd>.</p>
<p class="mce-root"/>
<p>Let's think about what we can do with this computation to make a loop out of it. Suppose that we start from some value, <kbd>A</kbd>. Suppose that we run the computation <kbd>f</kbd> on this value. Then, our result is of the type <kbd>F[Either[A, B]]</kbd>. There are two possibilities of what exactly this type will be—either <kbd>F[Left[A]]</kbd> or <kbd>F[Right[B]]</kbd>. If it is <kbd>F[Left[A]]</kbd>, then we are able to use <kbd>flatMap</kbd> on <kbd>F[Left[A]]</kbd>; after that, we can extract <kbd>A</kbd> from <kbd>Left</kbd>, and then we can run the computation <kbd>f</kbd> again on that <kbd>A</kbd>. If it is the <kbd>F[Right[B]]</kbd>, there is nothing left to do but return the result of the computation, that is, <kbd>F[B]</kbd>.</p>
<p>So, the function passed to <kbd>tailRecM</kbd> will run on argument <kbd>A</kbd> while it produces the results of type <kbd>F[Left[A]]</kbd>. Once it produces <kbd>F[Right[B]]</kbd>, this result is counted as the final result and is returned from the loop.</p>
<p>Basically, if we have the ability to perform a <kbd>flatMap</kbd> on the effect type <kbd>F</kbd>, we are also able to define a loop based on <kbd>flatMap</kbd>. However, why is it an abstract method? If all it takes to make a loop is the ability to perform <kbd>flatMap</kbd>, then why can we not define it as a concrete method implemented in terms of <kbd>flatMap</kbd>?</p>
<p>Well, we might want to try and do that. Consider the implementation of the Monad for our <kbd>SimpleWriter</kbd> example, as follows:</p>
<pre>override def tailRecM[A, B](a: A)(f: A =&gt; SimpleWriter[Either[A,B]]):<br/>  SimpleWriter[B] = f(a).flatMap {<br/>   case Left (a1) =&gt; tailRecM(a1)(f)<br/>   case Right(res) =&gt; pure(res)<br/>}</pre>
<p>In the preceding example, we have a <kbd>tailRecM</kbd> in terms of <kbd>flatMap</kbd>. What happens if we try an infinite loop?</p>
<pre>Monad[SimpleWriter].tailRecM[Int, Unit](0) { a =&gt; Monad[SimpleWriter].pure(Left(a))}</pre>
<p>The preceding code results in a <kbd>StackOverflowError</kbd>:</p>
<pre>[error] java.lang.StackOverflowError<br/>...<br/>[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)<br/>[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)<br/>[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)<br/>[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)<br/>[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)<br/>[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)<br/>[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)<br/>[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)<br/>[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)<br/>[error] at jvm.TailRecM$$anon$1.tailRecM(TailRecM.scala:18)<br/>[error] at jvm.TailRecM$$anon$1.$anonfun$tailRecM$1(TailRecM.scala:19)<br/>[error] at jvm.SimpleWriter.flatMap(AdditionMonadic.scala:19)<br/>...</pre>
<p>This error occurs most frequently in the scenario of a recursive call where we run out of stack frames of memory that are allocated for us by the JVM.</p>
<p>Every time you perform a method call, a specific memory fragment is allocated by the JVM for all of the variables and parameters of that method call. This memory fragment is called a stack frame. So, if you are calling a method recursively, you will have the number of stack frames growing proportionally to the depths of your recursion. The memory you can use for the stack frames is set on the JVM level and is usually up to 1 MB, and it is fairly easy to run into its limit with a deep enough recursion.</p>
<p>However, there are situations when you do not need to create additional stack frames in cases of recursion. Here, we are talking about tail recursion. Basically, you are able to drop the previous stack frame of recursion if it is no longer needed. This situation arises if there is nothing else to do in the method owning the stack frame, and the result of this method is fully dependent on the result of the subsequent calls of the recursion.</p>
<p>Consider, for example, the following example of a factorial computation:</p>
<pre>def factorial(n: Int): Int =<br/>  if (n &lt;= 0) 1<br/>  else n * factorial(n - 1)<br/>println(factorial(5)) // 120</pre>
<p>In the preceding code, the <kbd>factorial</kbd> function is defined recursively. So, in order to compute a factorial of a number <kbd>n</kbd>, you first need to compute a factorial of <kbd>n-1</kbd>, and then multiply it by <kbd>n</kbd>. When we call the factorial method recursively, we can ask a question as to whether we need to do anything else in this method after the recursive call is done, or if its results are dependent only on the method that we are calling recursively. More precisely, we are talking about whether we need to do anything else after the factorial call inside the <kbd>factorial</kbd> function. The answer is that we need to perform one more step to complete the computation. This step is the multiplication of the result of the factorial call by the number <kbd>n</kbd>. So, until this step is completed, we are not able to drop the frame of the current call. However, consider the <kbd>factorial</kbd> method, which is defined as follows:</p>
<pre>def factorialTailrec(n: Int, accumulator: Int = 1): Int =<br/>  if (n &lt;= 0) accumulator<br/>  else factorialTailrec(n - 1, n * accumulator)<br/>println(factorialTailrec(5)) // 120</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>In the preceding example, when we are calling the <kbd>factorial</kbd> method, we can ask ourselves the following question—do we have anything else to do in the method in order to complete its computation after the call to the <kbd>factorial</kbd> method? Or is the result of this method fully dependent on the result of the <kbd>factorial</kbd> method we are calling in this place? The answer is that we do not need to do anything else here.</p>
<p>The Scala compiler can recognize such situations and perform optimization in places where recursion can reuse the stack frames of the previous reclusive calls. This situation is called <strong>tail recursion.</strong> In general, such calls are much more efficient than ordinary recursion because you cannot get a Stack Overflow with them, and in general their speed is comparable to the speed of an ordinary <kbd>while</kbd> loop.</p>
<p>In fact, you can explicitly make a requirement on a method so that it's tail recursive in Scala, like so:</p>
<pre>@annotation.tailrec<br/>def factorialTailrec(n: Int, accumulator: Int = 1): Int =<br/> if (n &lt;= 0) accumulator<br/> else factorialTailrec(n - 1, n * accumulator)</pre>
<p>In the preceding example, the first method will not compile because it is not tail recursive while annotated with <kbd>@tailrec</kbd>. The Scala compiler will perform a check for all the methods annotated with <kbd>@tailrec</kbd> so see whether they're tail recursive.</p>
<p>Let's revisit our case of <kbd>tailRecM</kbd>. From the name, you can now guess that this method is supposed to be tail recursive. Now, let's recall our naive implementation of this method for <kbd>SimpleWriter</kbd>. Its execution resulted in a stack overflow exception. This is because, here, the recursion is split into several methods. So if you take a look at the stack trace output, you can see that the output is periodic. There are two methods repeating in this output—<kbd>flatMap</kbd> and <kbd>tailRecM</kbd>. The Scala compiler is not able to prove that the method is tail recursive in such a periodic recursion situation. In principle, you can think of a way to optimize recursion even in this, but Scala compiler cannot do that.</p>
<p>Also, let's see what happens if you try to declare the <kbd>tailRecM</kbd><span> </span><span>method </span><span>with the</span> <kbd>@tailrec</kbd> <span>annotation:</span></p>
<pre>@annotation.tailrec<br/>override def tailRecM[A, B](a: A)(f: A =&gt; SimpleWriter[Either[A,B]]): SimpleWriter[B] =<br/> f(a).flatMap {<br/>  case Left (a1) =&gt; tailRecM(a1)(f)<br/>  case Right(res) =&gt; pure(res)<br/> }</pre>
<p class="mce-root"/>
<p>You will see that the code stops compiling because the method is not recognized as tail recursive:</p>
<pre>[error] /Users/anatolii/Projects/1mastering-funprog/Chapter8/jvm/src/main/scala/jvm/TailRecM.scala:19:12: could not optimize @tailrec annotated method tailRecM: it contains a recursive call not in tail position<br/>[error] f(a).flatMap {<br/>[error] ^</pre>
<p>The point of having this method as an abstract method is precisely because you must implement it, not in terms of <kbd>flatMap</kbd> (which would inevitably lead to periodic recursion), but in terms of a single tail recursive method. For example, in the context of <kbd>SimpleWriter</kbd>, we can come up with such an implementation such as the following:</p>
<pre>@annotation.tailrec<br/> override def tailRecM[A, B](a: A)(f: A =&gt; SimpleWriter[Either[A,B]]):<br/> SimpleWriter[B] = {<br/>   val next = f(a)<br/>   next.value match {<br/>     case Left (a1) =&gt; tailRecM(a1)(f)<br/>     case Right(res) =&gt; pure(res)<br/>   }<br/> }</pre>
<p>In the preceding code snippet, as you can see, we have an implementation of <kbd>tailRecM</kbd> in a tail recursive manner. Notice that we are still using techniques similar to the ones that we are using in the <kbd>flatMap</kbd> function. However, these techniques are wrapped in a single method which is tail recursive.</p>
<p>One remark should be made, and that is that not every Monad implementation has an implementation of <kbd>tailRecM</kbd>. Frequently, you will find scenarios where <kbd>tailRecM</kbd> just throws a <kbd>NotImplementedError</kbd>:</p>
<pre>override def tailRecM[A, B](a: A)(f: A =&gt; SimpleWriter[Either[A,B]]): SimpleWriter[B] = ???</pre>
<p>The <kbd>???</kbd> syntax is used in Scala to conveniently throw such an error.</p>
<p>So far, we have discussed a <kbd>flatMap</kbd> in the context of composition of side effecting computations. Now, let's take a look at an example of the composition of a side effecting computation with a non-side effecting computation. Let's take a look at Functor.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functor</h1>
                </header>
            
            <article>
                
<p>Another frequently encountered type class in functional programming is Functor. Functor is all about the map function in its essence. As you may recall from the previous chapters, the <kbd>map</kbd> function is very similar to <kbd>flatMap</kbd> function; however, it takes a non-side effecting computation as its argument. It is used to transform a value within the context of a effect type when this transformation is not side effecting itself.</p>
<p>You might want to use a Functor if you want to do something with the result of a side effecting computation without extracting it from its effect type.</p>
<p>As you may recall, we used an intuition of sequential composition in the case of the <kbd>flatMap</kbd> of a Monad. This intuition may not be the best one for Functor. In the case of <kbd>map</kbd>, we can use another intuition of function, changing a value under the effect type. The operation that is abstracted away in this case is one of extracting the value from an effect type. The <kbd>map</kbd> method asks you only about what you want to do with the result of a side-effecting computation, without demanding from you and information about how exactly to extract this result from the effect type.</p>
<p>As in the case of the <kbd>Monad</kbd> type class, we have already discussed the <kbd>map</kbd> method in detail in the previous sections, so we will not be stopping on this type class for long. All we will do is take a look at how you might want to use it with the <kbd>Cats</kbd> library.</p>
<p class="mce-root"/>
<p>Let's take a look at the classes defined by the <kbd>Cats</kbd> library for Functor:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/def275eb-529e-48ac-a367-c3b7ad143bc1.png"/></div>
<p>In the preceding screenshot, you can see the documentation and the definition of the Functor type class. Now, let's take a look at what its implementation may look like for our <kbd>SimpleWriter</kbd> type. First of all, let's recall the definition of the <kbd>SimpleWriter</kbd> data type:</p>
<pre>case class SimpleWriter[A](log: List[String], value: A)</pre>
<p>Now we need to provide an implementation of the Functor type class from the <kbd>Cats</kbd> library. We will do some imports from the <kbd>Cats</kbd> library:</p>
<pre class="mce-root">import cats._, cats.implicits._</pre>
<p class="mce-root">In the preceding code, we are performing an import of the Functor type from the <kbd>cats</kbd> package (by importing <kbd>cats._</kbd>). After that, we must import the syntax for this type class (by importing <kbd>cats.implicits._</kbd> imports all the syntax and instances for all the type classes). So, whenever we have an implementation of the type class in scope, we will also have the syntax for it injected.</p>
<p>So, let's provide the implementation of the Functor type class for <kbd>SimpleWriter</kbd>:</p>
<pre>implicit val simpleWriterFunctor: Functor[SimpleWriter] =<br/> new Functor[SimpleWriter] {<br/>   override def map[A, B](fa: SimpleWriter[A])(f: A =&gt; B):<br/>    SimpleWriter[B] = fa.copy(value = f(fa.value))<br/> }</pre>
<p>In the preceding code, you can see a simple implementation of the Functor type class for <kbd>SimpleWriter</kbd>. As you can see, all we need to do is implement the <kbd>map</kbd> method of this type class.</p>
<p>After that, once we have created some very simple instances of the effect type, we are able to call the <kbd>map</kbd> method on it:</p>
<pre>val x = SimpleWriter(Nil, 3)<br/>println(x.map(_ * 2)) // SimpleWriter(List(),6)</pre>
<p>So, the <kbd>map</kbd> method gets injected into our effect type.</p>
<p>One question you might be asking is, what is the point is this? If Functor and Monad both define the <kbd>map</kbd> method, why have Functor at all? Why not have the Monad implementation for every type class where we need the <kbd>map</kbd> method and not bother with the Functor class at all? The answer is that not every effect type has the <kbd>flatMap</kbd> method implementation for it. So, an effect type might have an implementation of <kbd>map</kbd>, but it may be impossible to define a <kbd>flatMap</kbd> on it. Hence, the <kbd>Cats</kbd> library provides a fine-grained structure of its type class hierarchy so that you can use it according to your own needs.</p>
<p>So far, we have discussed type classes for sequential composition. Now, let's take a look at the case of parallel composition and how the Applicative type class handles it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applicative</h1>
                </header>
            
            <article>
                
<p>Knowing how to compose computations in sequence is a basic skill that enables procedural programming to take place. This is something that we rely upon by default when we use imperative programming languages. When we write two statements in sequence, we implicitly mean that these two statements are supposed to be executed one after another.</p>
<p>However, sequential programming is not capable of describing all the programming situations, especially if you're working in the context of an application that is supposed to run in parallel. There may be lots of situations where you may want computations composed in parallel. This is exactly where the Applicative type class comes into play.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Motivation</h1>
                </header>
            
            <article>
                
<p>Consider that we have two independent computations. Suppose we have two computations that evaluate mathematical expressions, and then we need to combine their results. Also, suppose that their computation is performed under the <kbd>Either</kbd> effect type. So, the main idea is that either of the two computations can fail, and if one of them fails, it is the result of interpretation being left with an error, and if it succeeds, the result is  <kbd>Right</kbd> of some result:</p>
<pre>type Fx[A] = Either[List[String], A]<br/>def combineComputations[F[_]: Monad](f1: F[Double], f2: F[Double]): F[Double] =<br/> for {<br/>   r1 &lt;- f1<br/>   r2 &lt;- f2<br/> } yield r1 + r2<br/>val result = combineComputations[Fx](Monad[Fx].pure(1.0), <br/> Monad[Fx].pure(2.0))<br/> println(result) // Right(3.0)</pre>
<p>In the preceding code, you can see how you can combine two such computations sequentially using the <kbd>Monad</kbd> type class. Here, we are using for comprehensions to compute the result of the first computation, and then the second computation.</p>
<p>Let's take a look at a scenario where one of these computations goes wrong:</p>
<pre>val resultFirstFailed = combineComputations[Fx](<br/> Left(List("Division by zero")), Monad[Fx].pure(2.0))<br/> println(resultFirstFailed) // Left(List(Division by zero))<br/>val resultSecondFailed = combineComputations[Fx](<br/> Monad[Fx].pure(1.0), Left(List("Null pointer encountered")))<br/> println(resultSecondFailed) // Left(List(Null pointer encountered))</pre>
<p>You can see two situations and two outputs. The first one is where the first computation goes wrong and the second one is where the second computation goes from. So basically, the result of the combined computation will be <kbd>Left</kbd> if either both of the two computations fail.</p>
<p>What happens if both of these computations fail?</p>
<pre>val resultBothFailed = combineComputations(<br/> Left(List("Division by zero")), Left(List("Null pointer encountered")))<br/> println(resultBothFailed) // Left(List(Division by zero))</pre>
<p>You can see an output of the situation where both of these computations fail. An error the first computation only gets an output. This is because they are composed sequentially, and the sequence is terminated on the first error. The behavior of the Monad for <kbd>Either</kbd> is to terminate sequential composition if <kbd>Left</kbd> is encountered.</p>
<p>This kind of scenario may not always be desirable,<span> e</span>specially in large applications that consist of a large amount of various modules that can fail. In such an application, for debugging purposes, you would like to collect as much information about the errors that have occurred as possible. If you're only collecting one error at a time, and you have dozens of independent computations that fail, you will have to debug them one at a time because you will not have access to the entire set of errors that have occurred. This is because only the first error encountered will be reported, even though the computations are independent on one another.</p>
<p>The reason why this scenarios happens is because of the very nature of the way we have composed our computations. They are composed sequentially. The nature of sequential composition is to run computations one after another, even if they are not dependent on one another's results. Since these computations run one after another, it is only natural to interrupt an entire sequence if an error has occurred in one of the links of the chain.</p>
<p>This solution to the preceding scenario would be to compose independent computations in parallel instead of in sequence. So, they should all be run independently one from another, and their results should be combined in some manner after they finish.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Applicative type class</h1>
                </header>
            
            <article>
                
<p>We would like to define a new primitive for the preceding scenario. We can call this method <kbd>zip</kbd>:</p>
<pre>type Fx[A] = Either[List[String], A]<br/>def zip[A, B](f1: Fx[A], f2: Fx[B]): Fx[(A, B)] = (f1, f2) match {<br/>  case (Right(r1), Right(r2)) =&gt; Right((r1, r2))<br/>  case (Left(e1), Left(e2)) =&gt; Left(e1 ++ e2)<br/>  case (Left(e), _) =&gt; Left(e)<br/>  case (_, Left(e)) =&gt; Left(e)<br/>}</pre>
<p>The method will take two computations as its arguments, and it will output a combined result of two of its supplied inputs as a tuple under their common effect type.</p>
<p>Also notice that we are dealing with specific cases of <kbd>Left</kbd> being a list of strings. This is to combine multiple error strings for multiple failed computations into one error report.</p>
<p>The way it works is that if both compilations are successful, their results are combined into a pair. Otherwise, if either of these computations fails, their errors are collected in a combined list.</p>
<p>Given the new method, <kbd>zip</kbd>, we can express the preceding example as follows:</p>
<pre>def combineComputations(f1: Fx[Double], f2: Fx[Double]): Fx[Double] =<br/> zip(f1, f2).map { case (r1, r2) =&gt; r1 + r2 }<br/><br/>val result = combineComputations(Monad[Fx].pure(1.0),<br/>  Monad[Fx].pure(2.0))<br/>  println(result) // Right(3.0)<br/><br/>val resultFirstFailed = combineComputations(<br/>  Left(List("Division by zero")), Monad[Fx].pure(2.0))<br/>  println(resultFirstFailed) // Left(List(Division by zero))<br/><br/>val resultSecondFailed = combineComputations(<br/>  Monad[Fx].pure(1.0), Left(List("Null pointer encountered")))<br/>  println(resultSecondFailed) // Left(List(Null pointer encountered))<br/><br/>val resultBothFailed = combineComputations(<br/>  Left(List("Division by zero")), Left(List("Null pointer encountered")))<br/>  println(resultBothFailed) // Left(List(Division by zero, Null pointer <br/>  encountered))</pre>
<p>Notice that here we're making the use of <kbd>zip</kbd> to create combined versions of two independent computations, and addressing the fact that we are using the <kbd>map</kbd> method to do something with the result of this computation.</p>
<p>Actually, we can express the <kbd>zip</kbd> function in terms of a more generic <kbd>ap</kbd> (short for <kbd>apply</kbd>) function. It is as follows:</p>
<pre>def ap[A, B](ff: Fx[A =&gt; B])(fa: Fx[A]): Fx[B] = (ff, fa) match {<br/>  case (Right(f), Right(a)) =&gt; Right(f(a))<br/>  case (Left(e1), Left(e2)) =&gt; Left(e1 ++ e2)<br/>  case (Left(e), _) =&gt; Left(e)<br/>  case (_, Left(e)) =&gt; Left(e)<br/>}</pre>
<p>Here is how we can express the <kbd>zip</kbd> function in terms of the <kbd>ap</kbd> function:</p>
<pre>def zip[A, B](f1: Fx[A], f2: Fx[B]): Fx[(A, B)] =<br/> ap[B, (A, B)](ap[A, B =&gt; (A, B)](Right { (a: A) =&gt; (b: B) =&gt; (a, b) })(f1))(f2)</pre>
<p>The actual meaning of the <kbd>ap</kbd> function is a more generic way to express the combination of two independent computations running together. The trick is that the first computation results in some function, <kbd>F[A =&gt; B]</kbd>, and the second computation is raw computation, <kbd>F[A]</kbd>. The point about this function and why it is different from the <kbd>zip</kbd> function in a qualitative way is as follows. Intervention is composition plus execution. It composes some value lifted into effect type <kbd>F</kbd>, together with a computation, <kbd>A =&gt; B</kbd>, that works on this value, which is also lifted into the context <kbd>F</kbd>. Since at composition time we already deal with effect types, we already have the independent computations finished. Compare that to the case of <kbd>flatMap</kbd>, where one of the arguments is a function, <kbd>A =&gt; F[B]</kbd>, that outputs an effect type. So, in the case of <kbd>flatMap</kbd>, one of the competitions is a function that is going to be executed. It is the responsibility of <kbd>flatMap</kbd> to execute it and obtain the result <kbd>F[B]</kbd>. This cannot be said about <kbd>ap</kbd>, which already has access to the results that the effect types computed—<kbd>F[A =&gt; B]</kbd> and <kbd>F[A]</kbd>. Hence, there is independence of computations. Since one of the values of the computed effect types is a function, <kbd>A =&gt; B</kbd>, it is not only a composition in terms of zipping into a pair, but also an execution that's similar to mapping.</p>
<p>Actually, the <kbd>ap</kbd> function comes from the <kbd>Apply</kbd> type class, which is an ancestor of Applicative:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f5db63dd-576a-4fe0-b27c-adac657fbae9.png"/></div>
<p>However, you will encounter Applicative versions of the type class that extend the <kbd>Apply</kbd> type class more frequently. The only difference between these type classes is that Applicative also has the <kbd>pure</kbd> function, which is used to lift a raw value, <kbd>a</kbd>, into the same effect type, <kbd>F</kbd>.</p>
<p>Applicative also has a bunch of useful concrete methods defined in terms of <kbd>ap</kbd>. There is also some nice syntactic sugar support that <kbd>cats</kbd> provides for you so that you can use Applicative in your projects in an intuitive way. For example, you can perform a <kbd>map</kbd> on two values at once, as follows:</p>
<pre>def combineComputations(f1: Fx[Double], f2: Fx[Double]): Fx[Double] =<br/> (f1, f2).mapN { case (r1, r2) =&gt; r1 + r2 }</pre>
<p>We can use the syntactic sugar that <kbd>cats</kbd> injects in tuples in order to easily work with such kind of cases of parallel computation. So, you can just unite two effect types under a tuple and map them with the Applicative type class in scope.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation of the type class</h1>
                </header>
            
            <article>
                
<p>Let's take a look at how the type class can be implemented for a data type. For example, let's look at <kbd>Either</kbd>:</p>
<pre>implicit val applicative: Applicative[Fx] = new Applicative[Fx] {<br/>  override def ap[A, B](ff: Fx[A =&gt; B])(fa: Fx[A]): Fx[B] = (ff, fa)<br/>  match {<br/>    case (Right(f), Right(a)) =&gt; Right(f(a))<br/>    case (Left(e1), Left(e2)) =&gt; Left(e1 ++ e2)<br/>    case (Left(e), _) =&gt; Left(e)<br/>    case (_, Left(e)) =&gt; Left(e)<br/>  }<br/>  override def pure[A](a: A): Fx[A] = Right(a)<br/>}</pre>
<p>You can see how the type class can be implemented for <kbd>Either</kbd> with <kbd>Left</kbd> being <kbd>List[String]</kbd>. So, as you can see, if two computations are successful, that is, they are <kbd>Right</kbd>, we simply combine them. However, if at least one of them is <kbd>Left</kbd>, we combine the <kbd>Left</kbd> side of both computations into a single <kbd>Left[List[String]]</kbd>. This is done specifically in mind for the cases where several independent computations may produce errors that you might want to combine under a single data structure.</p>
<p>You have probably noticed that we are using a pretty specific case of <kbd>Either</kbd>—the one where <kbd>Left</kbd> is always a <kbd>List[String]</kbd>. We have done this because we need a way to combine the <kbd>Left</kbd> sides of two computations into one, and we are not able to combine generic types. The preceding example can be generalized further to the arbitrary version of the type of <kbd>Left</kbd>, <kbd>Either[L, A]</kbd>. This can be done with the help of the <kbd>Monoid</kbd> type class, which we will learn about next. So, let's take a look at this type class and see where it can be useful.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monoid</h1>
                </header>
            
            <article>
                
<p>Monoid is another popular type class that you will frequently encounter in practice. Basically, it defines how to combine two data types.</p>
<p>As an example of Monoid, let's take a look at the implementation of an Applicative type class for the <kbd>Either</kbd> data type. In the previous section, we were forced to use a specific version of <kbd>Either</kbd>, the one with <kbd>Left</kbd> set to a list of strings. This was done precisely because we know how to combine two lists of strings, but we do not know how to combine any two generic types.</p>
<p class="mce-root"/>
<p>If we define the signature of this preceding Applicative as follows, then we will not be able to provide a decent implementation of this function because we will not be able to combine two generic types:</p>
<pre>implicit def applicative[L]: Applicative[Either[L, ?]]</pre>
<p>If you tried to write an implementation of this function, it would look something like the following:</p>
<pre>override def ap[A, B](ff: Either[L, A =&gt; B])(fa: Either[L, A]): <br/>Either[L, B] = (ff, fa) match {<br/>  case (Right(f), Right(a)) =&gt; Right(f(a))<br/>  case (Left(e1), Left(e2)) =&gt; Left(e1 |+| e2)<br/>  case (Left(e), _) =&gt; Left(e)<br/>  case (_, Left(e)) =&gt; Left(e)<br/>}</pre>
<p>We are using a special operator, <kbd>|+|</kbd>, in order to describe the operation of combining two data types we know nothing about. However, since we know nothing about the data types we are trying to combine, the code will not compile. We cannot simply combine two arbitrary data types because the compiler does not know how to do that.</p>
<p>This situation can be changed if we make the Applicative type class implicitly depend on another type class that does know how to implicitly combine these two data types. Meet Monoid:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b8f98c4-c89d-4aa5-a17b-682bf0a1179b.png"/></div>
<p>The Monoid type class extends <kbd>Semigroup</kbd>. <kbd>Semigroup</kbd> is a mathematical structure of from. It is a type class that is defined as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7a1fd818-e5ee-4247-8abd-0f0260f0c9ff.png"/></div>
<p>Basically, <kbd>Semigroup</kbd> is defined in the context of abstract algebra and Set Theory. Given a set, a <kbd>Semigroup</kbd> is a structure on this set that defines an operator that can combine two arbitrary elements of a set to produce another element of the same set. So, for any two elements of a set, you are able to combine them using this operator to produce another element that also belongs to this set. In the language of programming, <kbd>Semigroup</kbd> is a type class that can be defined, as shown in the preceding screenshot.</p>
<p>In the preceding screenshot, you can see that <kbd>Semigroup</kbd> defines a single method called <kbd>combined</kbd>. It takes two arguments of type <kbd>A</kbd> and returns another value of type <kbd>A</kbd>.</p>
<p>An intuitive way to understand <kbd>Semigroup</kbd> is to have a look at the addition operation on integers:</p>
<pre>implicit val semigroupInt: Semigroup[Int] = new Semigroup[Int] {<br/>  override def combine(a: Int, b: Int) = a + b<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>In addition operation on integers, <kbd>+</kbd> is an operator that can be used to combine any two arbitrary integers to obtain another integer. Hence, the operation of addition forms a <kbd>Semigroup</kbd> on the set of all possible integers. The <kbd>Semigroup</kbd> type class in <kbd>cats</kbd> generalizes this idea to any arbitrary type, <kbd>A</kbd>.</p>
<p>Looking back at our Monoid example, we can see that it extends a <kbd>Semigroup</kbd> and adds another method to it, which is called <kbd>empty</kbd>. Monoid must obey certain laws. One of these laws is that the <kbd>empty</kbd> element must be an identity with respect to the <kbd>combined</kbd> operation. This means that the following equalities must hold true:</p>
<pre>combine(a, empty) == combine(empty, a) == a</pre>
<p>So basically, if you try to combine an empty identity element with any other element of set <kbd>A</kbd>, you will get that same element as a result.</p>
<p>An intuitive way to understand this point is to have a look at the operation of the addition of integers:</p>
<pre>implicit def monoidInt: Monoid[Int] = new Monoid[Int] {<br/>  override def combine(a: Int, b: Int) = a + b<br/>  override def empty = 0<br/>}</pre>
<p>You can see an implementation of the Monoid for integers. If we take the operation to be an <span>addition</span>, then <kbd>0</kbd> is an empty element. Indeed, if you add <kbd>0</kbd> to any other integer, you will get this integer as a result. <kbd>0</kbd> is an identity element with respect to the addition operation.</p>
<p>This remark, <em>with respect to the addition operation</em>, is really important to notice. For example, <kbd>0</kbd> is not an identity element with respect to multiplication. In fact, if you multiply <kbd>0</kbd> by any other element, you will get <kbd>0</kbd> and not that other element. Speaking of multiplication, we can define a Monoid for integers with the operation of multiplication and the identity element being one, as follows:</p>
<pre>implicit def monoidIntMult: Monoid[Int] = new Monoid[Int] {<br/>  override def combine(a: Int, b: Int) = a * b<br/>  override def empty = 1<br/>}</pre>
<p>Actually, <kbd>cats</kbd> defines some nice syntactic sugar for Monoids. Given the preceding definition of that Monoid for integers for the multiplication operation, we can use it as follows:</p>
<pre>println(2 |+| 3) // 6</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>You can see how you can use an infix operator, <kbd>|+|</kbd>, in Scala to combine two elements. The preceding code is equivalent to the following:</p>
<pre>println(2 combine 3) // 6</pre>
<p>This is a common practice in <kbd>cats</kbd> in order to define such kinds of symbolic operators for frequently encountered operators. Let us have a look at how <kbd>Applicative</kbd> can be implemented for <kbd>Either</kbd> with <kbd>Monoid</kbd> as its dependency.</p>
<div class="packt_infobox">Another library for functional programming, ScalaZ, is more aggressive than <kbd>cats</kbd> with respect to operator usage, and hence it can be more difficult to understand for a beginner. <kbd>cats</kbd> is more friendly in this respect. The reason symbolic operators are less friendly is because their meaning is not immediately obvious from the name. For example, the preceding operator, <kbd>|+|</kbd>, can be pretty ambiguous for somebody who is looking at it for the first time. However, the <kbd>combine</kbd> method gives you a very solid idea of what it does.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementation for Either</h1>
                </header>
            
            <article>
                
<p>Now that we have familiarized ourselves with Monoid and had a look at how it is used in the context of simple types such as integer, let's take a look at our previous example, the example of <kbd>Either</kbd> with a generic type of <kbd>Left</kbd>—<kbd>Either[L, A]</kbd>. How can we define the Applicative instance for a generic <kbd>Left</kbd> type? Previously, we saw that the body of the <kbd>ap</kbd> function for a generic <kbd>Left</kbd> type is not very different from the body of this function for the list. The only problem was that we didn't know how to combine two arbitrary types.</p>
<p>This combination sounds like exactly the task for Monoid. So, if we bring the implicit dependency on Monoid into scope, we can define the <kbd>ap</kbd> and Applicative type class for the <kbd>Either</kbd> type as follows:</p>
<pre>implicit def applicative[L: Monoid]: Applicative[Either[L, ?]] =<br/> new Applicative[Either[L, ?]] {<br/>   override def ap[A, B](ff: Either[L, A =&gt; B])(fa: Either[L, A]):<br/>   Either[L, B] = (ff, fa) match {<br/>      case (Right(f), Right(a)) =&gt; Right(f(a))<br/>      case (Left(e1), Left(e2)) =&gt; Left(e1 |+| e2)<br/>      case (Left(e), _) =&gt; Left(e)<br/>      case (_, Left(e)) =&gt; Left(e)<br/>   }<br/>   override def pure[A](a: A): Either[L, A] = Right(a)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>You can see an implicit implementation of the Applicative type class that is also dependent on an implicit implementation of the <kbd>Monoid</kbd> type class for the <kbd>Left</kbd> type of <kbd>Either</kbd>. So, what happens is that the Applicative type class will be implicitly resolved, but only if it's possible to implicitly resolve the Monoid for the <kbd>Left</kbd> type's value. If there is no implicit implementation of Monoid for <kbd>Left</kbd> in scope, we will not be able to generate Applicative. This makes sense, because the body of Applicative depends on the functionality provided by Monoid in order to define its own functionality.</p>
<p>The only thing to notice about the body of the <kbd>ap</kbd> function is that it now uses the <kbd>|+|</kbd> operator in order to combine the left elements if both computations result in an error.</p>
<p>One peculiarity to notice about Monoid is that it is said it is defined not for an effective, but for an ordinary type. So, if you look at the signature of Monoid again, it is of the kind <kbd>Monoid[A]</kbd>, not the kind of <kbd>Monoid[F[A]]</kbd>. So far, we have only encountered the type classes that work on effect types, that is, the types of the kind <kbd>F[A]</kbd>.</p>
<p>What is the reason for the existence of type classes that work on raw types and not effect types? To answer this question, let's remember what the motivation for the existence of ordinary type classes that we are familiar with so far was. The main motivation for their existence was that certain operations with effect types were not convenient to accomplish. We had the need to abstract certain operations with effect types. We needed an abstraction to define tools that work on the effect types.</p>
<p>Effect types are usually data structures, and it is pretty hard to work with them ad hoc. You are not usually able to work with them using the capabilities built into your language conveniently. Hence, we encountered difficulties working with these data types on every corner if we did not have a toolset defined for them. Hence, the need for type classes manifests itself mostly for effect types.</p>
<p>Ordinary types like <kbd>A</kbd> are usually not as hard to work with as data structures. Hence, the need for tools and for abstractions over these data types is less obvious than for the effect types. However, as we saw previously, there are situations where type classes can be useful for raw types as well. The reason we had to define a separate type class Monoid for a raw type is in the fact that we needed to generalize the feature that the type must be composable.</p>
<p>Also notice that we can hardly do that using any other technique than type classes. An ordinary approach of object-oriented programming to the problem of making sure a datatype exposes certain functionality is interfaces. Interfaces must be declared at definition time of the class implementing them. So, for example, there is no single interface to specify that lists, integers, and strings are composable with another with the same method.</p>
<p class="mce-root"/>
<p>The only way to specify such an exposure of certain functionality is to define an interface as ad hoc. But ordinary object-oriented programming does not provide you with the capability to inject interfaces into already implemented classes. This cannot be said about type classes. With type classes, whenever you want to capture that a type exposes a certain functionality, you can define a type class as ad hoc. You can also define in which way exactly a class exhibits this functionality by defining and implementing this type class for this particular class. Notice exactly when it is done. This operation can be done in any part of the program. So, whenever you need to make it explicit that a type exhibits certain functionality and has this functionality in common with other types, you are able to do so by defining a type class that captures this functionality.</p>
<p>This kind of extensibility provides you with a greater level of flexibility that is hard to achieve with ordinary object-oriented programming techniques such as, for example, those in Java. In fact, it can be argued that it is sufficient for the programmer to drop the object-oriented style of interfaces altogether and resort to only using the type classes. In the style of programming Haskell is based on, there is a strict separation of data and behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MonoidK</h1>
                </header>
            
            <article>
                
<p>Previously, we saw the version of Monoid that works on all types. A version of Monoid also exists that operates on effect types, that is, on the types of the kind of <kbd>F[A]</kbd>. This type class is called <kbd>MonoidK</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9518c592-e97f-40ca-89fe-c850a3020a58.png"/></div>
<p class="mce-root"/>
<p>So, as you can see, the method is defined for an effect type, and instead of the <kbd>combined</kbd> method that works on two types, <kbd>A</kbd>, <kbd>MonoidK</kbd> defines a method called <kbd>combineK</kbd>, which works on values of type <kbd>F[A]</kbd>. Also notice that this method is parametrized by the type <kbd>A</kbd> on the method level and not on the level of the type class itself, which means that you can have the single type class defined for some effect type, <kbd>F[_]</kbd>, and you can use it for arbitrary <kbd>A</kbd> in the context of <kbd>F[A]</kbd>.</p>
<p>This example can be useful when combining lists. While it is not really an effect type, because a <kbd>List</kbd> is a data structure that does not encapsulate any side effects, it is still a type of the form <kbd>F[A]</kbd>. We can imagine an implementation of <kbd>combinedK</kbd> for it as follows:</p>
<pre>implicit val listMonoid: MonoidK[List] = new MonoidK[List] {<br/>  override def combineK[A](a1: List[A], a2: List[A]): List[A] =<br/>   a1 ++ a2<br/>  override def empty[A] = Nil<br/>}</pre>
<p>So, in the preceding code, we are able to implement the method in a manner that is independent of type <kbd>A</kbd> because the behavior of the combination of two lists is independent of the type of the elements that are contained in them. This combination is just a concatenation of the elements of one list with the elements of another list to form one combined list.</p>
<p>Also notice the <kbd>algebra</kbd><span> </span><span>method </span><span>here. This method can be used to obtain a</span> <kbd>Monoid</kbd> <span>instance from the </span><kbd>MonoidK</kbd> <span>instance. This can be useful in cases where you need a</span> <kbd>Monoid</kbd> <span>instance, but you only have</span> <kbd>MonoidK</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Traverse</h1>
                </header>
            
            <article>
                
<p>Previously, we learned about the Applicative type class. We argued that the main utility of the Applicative type class is that it allows us to combine two independent computations in parallel. No longer are we bound by the <kbd>flatMap</kbd> function that performs sequential composition, so that if one computation fails then no other computation is ever performed. In the Applicative scenario, all of the computations are performed, despite the fact that some of them can fail.</p>
<p class="mce-root"/>
<p>However, Applicative is only able to combine two independent computations. There are also methods to combine up to 22 computations into tuples. However, what if we need to combine an arbitrary amount of computations? The usual generalization for multiplicity is collections. Tuples are just special cases of collections. So, if there is a type class for combining independent computations into tuples, there must be a type class for combining independent computations into collections.</p>
<p>To illustrate this scenario, consider our example we we're working with in Applicative case. What if we have an arbitrary list of mathematical expressions computed under the parallel operator, and we have a function that is supposed to combine them by summing them up? What might such a function look like?</p>
<pre>type Fx[A] = Either[List[String], A]<br/>def combineComputations(f1: List[Fx[Double]]): Fx[Double] =<br/> (f1, f2).mapN { case (r1, r2) =&gt; r1 + r2 }</pre>
<p>So, the preceding function takes a list of the results of the computations, and its job is to produce a combined result of all of the computations. This result will be of the type <kbd>Either[List[String], List[Double]]</kbd> type, which means that we also need to aggregate all of the errors that happened in all of the computationals we are trying to combine. How would we go about it in the case of Applicative?</p>
<p>What we need to do is take the first element of the list, combine it with the second element of the list using the <kbd>ap</kbd> function, add the results together to obtain an <kbd>Either</kbd> as a result, and combine this result with the third element, and so on.</p>
<p>In fact, there is a type class to perform just that. Meet the <kbd>Traverse</kbd> type class:</p>
<p class="mce-root"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca9ec1bf-e863-4365-a00a-36b5c5eb9a10.png"/></div>
<p>The main point of interest of the <kbd>Traverse</kbd> type class is the <kbd>traverse</kbd> method. Let's take a look at its signature:</p>
<pre>abstract def traverse[G[_], A, B](fa: F[A])(f: (A) ⇒ G[B])(implicit arg0: Applicative[G]): G[F[B]]</pre>
<p>The signature of this method is very abstract. So, let's give all the types involved a little bit more context. In the preceding signature, consider that type <kbd>F</kbd> is a collection type. Consider that type <kbd>G</kbd> is an effect type.</p>
<p>This means that traverse takes a collection as its first argument—<span>a </span>collection of some arbitrary raw elements, <kbd>A</kbd>. The second argument is similar to what we saw in <kbd>flatMap</kbd>. It is a side effecting computation that works on the elements of the collection we saw as the first argument. So, the idea is that you have a collection of some elements, <kbd>A</kbd>, and a computation that you can run on these elements, <kbd>A</kbd>. However, this computation is side effecting. The side effects from this computation are wrapped into the effect type <kbd>G</kbd>.</p>
<p class="mce-root"/>
<p>What would happen if you ran such a computation on every element of the collection? What would happen if you map collection <kbd>F</kbd> with the help of this operation?</p>
<p>The result type that you would expect to get is this: <kbd>F[G[B]]</kbd>. So, you will get a collection of effect types that are the results of the computation that you've run on every element of the original collection.</p>
<p>Returning to our example of <kbd>Either</kbd> that we need to combine together, we would get the following result:</p>
<pre>List[Either[List[String], A]]</pre>
<p>However, we are not looking for this. We are looking to obtain a list of all the results of our computation under the effect type <kbd>Either</kbd>. In the case of Applicative, the <kbd>ap</kbd> method was taking the results of side effecting computations and combining them under their common effect type. So, in the case of <kbd>ap</kbd> and <kbd>zip</kbd> based on it, we had the following results:</p>
<pre>Either[List[String], (A, A)]</pre>
<p>Here, in our generalized case, the role of tuple is replaced by <kbd>List</kbd>. Therefore, we are aiming for the following:</p>
<pre>Either[List[String], List[A]]</pre>
<p>Now, let's return to our <kbd>traverse</kbd> function. Let's take a look at its result type. The result of this function is <kbd>G[F[B]]</kbd>. <kbd>G</kbd> is an effect type. <kbd>F</kbd> is a collection type. So, all of the results of the computations are combined into a single collection under an effect type, <kbd>G</kbd>. This is precisely what we were aiming at in the case of <kbd>Either</kbd>.</p>
<p>So, this makes <kbd>Traverse</kbd> a more generic case of Applicative that can be used for situations where you do not know how many computations you are going to combine ahead of time.</p>
<p>A word of caution here. We have also discussed that the type <kbd>F</kbd> is a collection type and that the type <kbd>G</kbd> is an effect type. You should remember that this constraint is not encoded into a type class itself. We have imposed this constraint in order to be able to develop an intuition for the type class. So, potentially, you might come up with some more advanced uses of the <kbd>Traverse</kbd> type class that go beyond this collection. However, in your projects, you will be using it in the context of collections the most frequently.</p>
<p>Let's take a look at what our example might look like with the help of <kbd>Traverse</kbd>:</p>
<pre>def combineComputationsFold(f1: List[Fx[Double]]): Fx[Double] =<br/> f1.traverse(identity).map { lst =&gt;<br/> lst.foldLeft(0D) { (runningSum, next) =&gt; runningSum + next } }<br/><br/>val samples: List[Fx[Double]] =<br/>  (1 to 5).toList.map { x =&gt; Right(x.toDouble) }<br/><br/>val samplesErr: List[Fx[Double]] =<br/>  (1 to 5).toList.map {<br/>    case x if x % 2 == 0 =&gt; Left(List(s"$x is not a multiple of 2"))<br/>    case x =&gt; Right(x.toDouble)<br/>  }<br/><br/>println(combineComputationsFold(samples)) // Right(15.0)<br/>println(combineComputationsFold(samplesErr)) // Left(List(2 is not a <br/> multiple of 2, 4 is not a multiple of 2))</pre>
<p>We can further enhance this example if we use the <kbd>combineAll</kbd> method from the <kbd>Traverse</kbd> type class:</p>
<pre>def combineComputations(f1: List[Fx[Double]]): Fx[Double] =<br/> f1.traverse(identity).map(_.combineAll)<br/><br/>println(combineComputations(samples)) // Right(15.0)<br/>println(combineComputations(samplesErr)) // Left(List(2 is not a  <br/> multiple of 2, 4 is not a multiple of 2))</pre>
<p>The examples are introduced in the context of the following type classes that are defined:</p>
<pre>type Fx[A] = Either[List[String], A]<br/>implicit val applicative: Applicative[Fx] = new Applicative[Fx] {<br/>  override def ap[A, B](ff: Fx[A =&gt; B])(fa: Fx[A]): Fx[B] = (ff, fa)  <br/>  match {<br/>    case (Right(f), Right(a)) =&gt; Right(f(a))<br/>    case (Left(e1), Left(e2)) =&gt; Left(e1 ++ e2)<br/>    case (Left(e), _) =&gt; Left(e)<br/>    case (_, Left(e)) =&gt; Left(e)<br/>  }<br/>  override def pure[A](a: A): Fx[A] = Right(a)<br/>}<br/>implicit val monoidDouble: Monoid[Double] = new Monoid[Double] {<br/>  def combine(x1: Double, x2: Double): Double = x1 + x2<br/>  def empty: Double = 0<br/>}</pre>
<p><kbd>combinedAll</kbd> works on some collection, <kbd>F[A]</kbd>, and produces the result <kbd>A</kbd> out of this collection, given <kbd>Monoid[A]</kbd> in scope. The Monoid defines how to combine two elements, <kbd>A</kbd>, into one element, <kbd>A</kbd>. <kbd>F[A]</kbd> is a collection of elements, <kbd>A</kbd>. So, given a collection of elements, <kbd>A</kbd>, <kbd>combineAll</kbd> is capable of combining all of the elements and computing a single result, <kbd>A</kbd>, with the help of the Monoid in scope that defines a binary composition operation.</p>
<p class="mce-root"/>
<p>One thing to notice here is that the type classes of <kbd>cats</kbd> form an ecosystem and frequently depend one on another. In order to obtain an instance of a certain type class for a certain type, you might discover that it is implicitly dependent on an instance of another type class. For other type classes, you can discover that some of its methods are dependent on some other type class implicitly, just like in the case of <kbd>combineAll</kbd> depending on Monoid.</p>
<p>This connection can be used to the advantage of a learner of purely functional programming. This kind of ecosystem means that you can start very small. You can start by using one or two type classes that you understand. Since the <kbd>Cats</kbd> library forms an ecosystem of dependent type classes, you will encounter situations where your familiar type classes will depend on type classes that you still do not know. Therefore, you will need to learn about the other type classes.</p>
<p>Other things that we need to notice about the type classes that we have learned about so far is that they are pretty generic and language independent. What it encodes is the relationships and the transformations between types. This can be encoded in any language of your choosing. For example, in Haskell, the language is built around the idea of type classes. So, if you look at Haskell, you will find that it also contain the type classes that we have covered in this chapter. As a matter of fact, there is an entire mathematical theory that deals with these concepts and defines the type classes that we have covered, called the <strong>category theory</strong>. That means that we could have discussed type classes from a mathematical perspective without touching programming at all. Therefore, the concepts of the type classes are language independent and have a solid mathematical foundation. We have extensively covered a library that is specific to Scala, but the concepts that we have covered are language independent. In one form or another, they are implemented in all of the languages that support purely functional styles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we had an in-depth look at the system of type classes used in purely functional programming. We take a look at the library, that is, a standard library for purely functional programming. We had our first look at the structure of the library and we found out that it is composed of separate models for the type classes, the syntax, and the effect types.</p>
<p class="mce-root"/>
<p>Then, we had an in-depth look at some type classes that are defined by the library. We saw the motivation for their existence, as well as their implementation and usage details. One thing to remember about all of the type classes is that they are not Scala specific. In fact, there is an entire mathematical theory that deals with them in a manner that is independent from any programming language at all. This is called category theory. So, if you know the concepts from one programming language, we are able to use them in any programming language that supports the functional style.</p>
<p class="mce-root">Cats provides us with effective functional programming tools. However, we need higher-level libraries to write industrial-grade software such as web application backends. In the next chapter, we will see more advanced functional libraries that build on the basic ones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is the motivation to organize type classes into libraries?</li>
<li>What methods does Traverse define?</li>
<li>Which real-world scenario would we use <span>Traverse</span> in?</li>
<li>What methods does Monad define?</li>
<li>Which real-world scenario would we use<span> </span><span>Monad</span><span> </span>in?</li>
<li>What is the structure of the Cats library?</li>
</ol>


            </article>

            
        </section>
    </body></html>