<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Domain Specific Languages"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Domain Specific Languages</h1></div></div></div><p>In the 
<a class="indexterm" id="id396"/>previous chapter, we covered the core concepts of functional programming such as pure functions, immutability, and higher-order functions. We introduced some of the design patterns that are prevalent in large functional programs. Finally, we covered two popular functional programming libraries called Cats and Doobie and used them to write some interesting programs.
</p><p>In this chapter, we will cover how Scala makes it possible to write powerful DSLs by providing a few interesting language features. We'll have a brief look at what DSLs are in general terms. We'll also cover a DSL that you'll very likely be using if you're going to work with Scala professionally. Finally, you will implement your own DSL.</p><p>This chapter demonstrates how Scala makes it possible to write powerful Domain Specific Languages (DSLs) by providing a few interesting language features.</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the use of Domain Specific Languages (DSLs)</li><li class="listitem" style="list-style-type: disc">Use the DSL <code class="literal">ScalaTest</code>, a popular testing library for Scala</li><li class="listitem" style="list-style-type: disc">Design your own DSLs in Scala</li><li class="listitem" style="list-style-type: disc">Recognize the additional libraries and tools that will be useful beyond this book</li></ul></div><div class="section" title="DSLs and Types of DSLs"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec35"/>DSLs and Types of DSLs</h1></div></div></div><p>A domain specific language
<a class="indexterm" id="id397"/> is, as the name suggests, a language that's specialized for a specific domain. Contrast that with a language like Scala, which is a general-purpose language in the sense that it's applicable across a broad range of domains.
</p><p>By restricting the domain, you'd hope to make a language that's less comprehensive but 
<a class="indexterm" id="id398"/>better suited to solving a specific set of problems within a domain. A well-constructed DSL will make it easy to solve problems within a domain and make it hard for the user to make mistakes. DSLs come in many different shapes and sizes, but you can roughly separate them into two groups: external DSLs and internal DSLs.
</p><div class="section" title="External DSLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec108"/>External DSLs</h2></div></div></div><p>External DSLs 
<a class="indexterm" id="id399"/>are written "outside" of the host language (the language that's used to implement the DSL is called the host language). That means you'll have to parse the text, evaluate it, and so on, just as if you were creating a general-purpose 
<a class="indexterm" id="id400"/>programming language. We won't be creating an external DSL, so we won't cover the topic much further.
</p><p>One example of an external DSL is 
<code class="literal">DOT</code>, which is used to describe graphs. Here's an 
<a class="indexterm" id="id401"/>example of a simple 
<code class="literal">DOT</code> program, which 
<a class="indexterm" id="id402"/>produces the graph you see here:
</p><div class="mediaobject"><img alt="External DSLs" src="graphics/8_01.jpg"/></div><p>Here is the code that can be written to implement the graph above:</p><div class="informalexample"><pre class="programlisting">graph graphname {
   a -- b -- c;
   b -- d;
}</pre></div><p>So, 
<code class="literal">DOT</code> is specialized for the domain of describing graphs.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>For more information on 
<code class="literal">DOT</code>, please refer to 
<a class="ulink" href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">https://en.wikipedia.org/wiki/DOT_(graph_description_language)</a>.
</p></div></div></div><div class="section" title="Internal DSLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Internal DSLs</h2></div></div></div><p>Internal 
<a class="indexterm" id="id403"/>DSLs are embedded in the 
<a class="indexterm" id="id404"/>host language and can be separated into two groups:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shallow:</strong></span> Operations <a class="indexterm" id="id405"/>directly use the host language's operations (for example, <code class="literal">+</code> uses Scala's <code class="literal">+</code>). </li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Deep:</strong></span> You build up <a class="indexterm" id="id406"/>your abstract syntax tree (AST) and evaluate it just as you would with an external DSL.</li></ul></div><p>We'll be 
<a class="indexterm" id="id407"/>writing an internal shallow DSL in this chapter, which is also, in my experience, the most 
<a class="indexterm" id="id408"/>common type of DSL you'll encounter when you're using various Scala libraries.
</p><p>
<code class="literal">ScalaTest</code> is a 
<a class="indexterm" id="id409"/>very popular testing library for Scala. It has a set of different DSLs for writing your test specifications. We'll look at 
<code class="literal">ScalaTest</code> in depth in the next section.
</p><p>You now have a very basic understanding of what DSLs are and how they can be grouped into internal/external and shallow/deep. In the next section, we'll look at 
<code class="literal">ScalaTest</code> and how that library uses DSLs to make it easy to write test specifications.
</p></div></div></div>
<div class="section" title="ScalaTest &#x2013; A Popular DSL"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec36"/>ScalaTest – A Popular DSL</h1></div></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>
<code class="literal">ScalaTest</code> was introduced in 
<a class="link" href="ch01.html" title="Chapter 1. Setting up the Development Environment">Chapter 1</a>, 
<span class="emphasis"><em>Setting up the Development Environment</em></span>, but as we'll use it extensively in this lecture, we'll do a little recap here and make sure that everyone has a working 
<code class="literal">ScalaTest</code> environment.
</p></div></div><p>In this section, we'll 
<a class="indexterm" id="id410"/>have a look at a popular library for testing your Scala programs, 
<code class="literal">ScalaTest</code>, and see how the library uses DSLs to allow its users to write readable tests in various styles. 
</p><p>The purpose of looking at 
<code class="literal">ScalaTest</code> is twofold. First off, 
<code class="literal">ScalaTest</code> is a widely used testing library for Scala projects, so you're likely to end up using it when you're using Scala professionally. Secondly, it's a good example of how to use DSLs to make your code more readable.
</p><p>By the end of this section, you should be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify how to use <code class="literal">ScalaTest</code> in your own projects</li><li class="listitem" style="list-style-type: disc">Identify the various styles that <code class="literal">ScalaTest</code> offers and be able to pick the one that's relevant to your project</li><li class="listitem" style="list-style-type: disc">Write <code class="literal">ScalaTest</code> tests using the <code class="literal">F</code><code class="literal">latSpec</code> style</li></ul></div><div class="section" title="Adding ScalaTest to Your Project"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Adding ScalaTest to Your Project</h2></div></div></div><p>
<code class="literal">ScalaTest</code> is a 
<a class="indexterm" id="id411"/>Scala library like any other, so you simply add it as a library dependency to your project. As we're using SBT in this book, we'll use that as an example here. Create a new SBT project with the following 
<code class="literal">build.sbt</code> file:
</p><div class="informalexample"><pre class="programlisting">name := "Lession2-ScalaTest"
scalaVersion := "2.12.4"
libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.4" % "test"</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>For more information, refer to the installation section (<a class="ulink" href="http://www.scalatest.org/install">http://www.scalatest.org/install</a>) from the documentation if you want to see how to use it outside of SBT.
</p></div></div><p>Create a simple test and place it in your 
<code class="literal">src/test/scala/com/example/ExampleSpec.scala </code>project:
</p><div class="informalexample"><pre class="programlisting">package com.example

import collection.mutable.Stack
import org.scalatest._

class ExampleSpec extends FlatSpec with Matchers {
  "A Stack" should "pop values in last-in-first-out order" in {
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
    stack.pop() should be (2)
    stack.pop() should be (1)
  }
}</pre></div><p>To verify 
<a class="indexterm" id="id412"/>that your setup is correct, start an SBT session in the root of your project and run the following command:
</p><div class="informalexample"><pre class="programlisting">test:compile                     # to compile your tests
test                             # to run your test-suite
testOnly com.example.ExampleSpec # To run just that test</pre></div><p>You should see output similar to the following:</p><div class="informalexample"><pre class="programlisting">testOnly com.example.ExampleSpec
[info] ExampleSpec:
[info] A Stack
[info] - should pop values in last-in-first-out order
[info] Run completed in 282 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 6 s, completed Dec 4, 2017 9:50:04 PM</pre></div><p>As we'll be 
<a class="indexterm" id="id413"/>writing a few tests using 
<code class="literal">ScalaTest</code> in the following section, it's important that you have a correctly configured SBT project that you can use for the exercises. Follow these steps:
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new SBT project using the previous <code class="literal">build.sbt</code> definition.</li><li class="listitem">Create a new test file at <code class="literal">src/test/scala/com/example/ExampleSpec.scala</code> with the previous contents.</li><li class="listitem">Run the tests using the <code class="literal">sbt test</code> command and make sure that it has detected the tests and that they pass.</li></ol></div><p>You've seen how to add 
<code class="literal">ScalaTest</code> to your Scala project and how to run the tests using SBT. You should now have a correctly configured Scala project that you can use for the remainder of the exercises in this chapter. In the next section, we'll 
<a class="indexterm" id="id414"/>have a look at the various styles of tests you can write using 
<code class="literal">ScalaTest</code>.
</p></div><div class="section" title="Overview of ScalaTest Styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Overview of ScalaTest Styles</h2></div></div></div><p>ScalaTest offers a 
<a class="indexterm" id="id415"/>selection of different styles that you can use when you're writing your tests. What style to use depends on your
<a class="indexterm" id="id416"/> team's experience and preference. 
</p><p>In this section, we'll have a look at some of the different styles so you can get a feeling for what style you prefer:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FunSuite</strong></span> is a simple <a class="indexterm" id="id417"/>style that will be<a class="indexterm" id="id418"/> familiar to most people:<div class="informalexample"><pre class="programlisting">describe("A Set") {

  describe("(when empty)") {
    it("should have size 0") {

      assert(Set.empty.size == 0)

    }

  }

}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FlatSpec</strong></span> is <a class="indexterm" id="id419"/>very similar to <code class="literal">FunSuite</code> but<a class="indexterm" id="id420"/> it focuses more on Behavior-Driven Design (BDD) by forcing you to name your tests in a manner that reads more like a specification:<div class="informalexample"><pre class="programlisting">"An empty Set" should "have size 0" in {

    assert(Set.empty.size == 0)

}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FunSpec</strong></span> is a <a class="indexterm" id="id421"/>good general-purpose style<a class="indexterm" id="id422"/> for writing specification-style tests:<div class="informalexample"><pre class="programlisting">describe("A Set") {

  describe("(when empty)") {

    it("should have size 0") {

      assert(Set.empty.size == 0)

    }

  }

}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FreeSpec</strong></span> focuses<a class="indexterm" id="id423"/> on specification-style<a class="indexterm" id="id424"/> testing but doesn't enforce any structure upon your tests:<div class="informalexample"><pre class="programlisting">"A Set" - {

  "(when empty)" - {

    "should have size 0" in {

      assert(Set.empty.size == 0)

    }

  }

}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PropSpec</strong></span> is for<a class="indexterm" id="id425"/> if you want<a class="indexterm" id="id426"/> to write tests exclusively in terms of property checks:<div class="informalexample"><pre class="programlisting">property("An empty Set should have size 0") {

    assert(Set.empty.size == 0)

}</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FeatureSpec</strong></span> is primarily <a class="indexterm" id="id427"/>intended <a class="indexterm" id="id428"/>for acceptance testing:<div class="informalexample"><pre class="programlisting">class TVSetSpec extends FeatureSpec with GivenWhenThen {

  info("As a TV set owner")

  info("I want to be able to turn the TV on and off")



  feature("TV power button") {
    scenario("User presses power button when TV is off") {

      Given("a TV set that is switched off")

      val tv = new TVSet
      assert(!tv.isOn)

      When("the power button is pressed")

      tv.pressPowerButton()

      Then("the TV should switch on")

      assert(tv.isOn)

    }

  }

}</pre></div></li></ul></div><p>Example: 
<code class="literal">FunSuite</code>
</p><p>Let's have
<a class="indexterm" id="id429"/> a look at the test case we created in the previous section:
</p><div class="informalexample"><pre class="programlisting">package com.example

import collection.mutable.Stack
import org.scalatest._

class ExampleSpec extends FlatSpec with Matchers {
 "A Stack" should "pop values in last-in-first-out order" in {
   val stack = new Stack[Int]
   stack.push(1)
   stack.push(2)
   stack.pop() should be (2)
   stack.pop() should be (1)
}
}</pre></div><p>There are two internal DSLs in action here. The first one is used to write your test specifications in the readable form of 
<code class="literal">"X" should "Y" in { &lt;code&gt; }</code>. This style is made available by extending 
<code class="literal">FlatSpec</code>. The other DSL is used to write your assertions in the form of 
<code class="literal">&lt;expression&gt; should be &lt;expression&gt;</code>, which is made available by extending 
<code class="literal">Matchers</code>.
</p><p>The DSLs are 
<a class="indexterm" id="id430"/>implemented as a combination of classes and extension methods, but we'll look into that in greater detail when we implement our own little DSL in the next section.
</p></div><div class="section" title="Activity: Implementing ScalaTest Styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Activity: Implementing ScalaTest Styles</h2></div></div></div><p>The best way to
<a class="indexterm" id="id431"/> get a feeling for the different styles is to use them. Select three of the styles from the previous list and convert the following test to those styles.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Continue using the Scala project you created in the previous activity.</li><li class="listitem">Create a file for each style you've selected. If you picked <code class="literal">FunSpec</code>, then create a <code class="literal">FunSpecExample.scala</code> file.</li><li class="listitem">For each style, convert the following test into a test that uses that style:<div class="informalexample"><pre class="programlisting">import collection.mutable.Stack
import org.scalatest._

class ExampleSpec extends FlatSpec with Matchers {
 "A Stack" should "pop values in last-in-first-out order" in {
   val stack = new Stack[Int]
   stack.push(1)
   stack.push(2)
   stack.pop() should be (2)
   stack.pop() should be (1)
 }
}</pre></div></li></ol></div><p>You've seen the different styles that 
<code class="literal">ScalaTest</code> offers and have a rough feeling for the difference between them.
</p><p>
<code class="literal">ScalaTest</code> is 
<a class="indexterm" id="id432"/>a testing library that uses DSLs to make it possible to write very readable tests. We have seen how you can add it to your own Scala projects, we got an overview of the different styles that it supports, and we have written a few tests using different styles. In the next section, we'll look at the Scala features that Scala provides which make it possible to write DSLs in Scala.
</p></div></div>
<div class="section" title="Language Features for Writing DSLs"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec37"/>Language Features for Writing DSLs</h1></div></div></div><p>In this 
<a class="indexterm" id="id433"/>section, 
<a class="indexterm" id="id434"/>we'll look at the Scala features that make it easy to write small DSLs:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Flexible syntax for method invocation</li><li class="listitem" style="list-style-type: disc">By-name parameters</li><li class="listitem" style="list-style-type: disc">Extension methods and <code class="literal">Value</code> classes</li></ul></div><p>We'll use all of these features in the next section when we create our own DSL in Scala.</p><div class="section" title="Flexible Syntax for Method Invocation"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec113"/>Flexible Syntax for Method Invocation</h2></div></div></div><p>Scala has a
<a class="indexterm" id="id435"/> flexible syntax for method invocations that makes it possible to, in some 
<a class="indexterm" id="id436"/>cases, omit the dot (
<code class="literal">.</code>) and parentheses (
<code class="literal">()</code>) when invoking methods.
</p><p>The rules are as
<a class="indexterm" id="id437"/> follows:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For methods that are of arity-<code class="literal">0</code>, meaning they don't take any parameters, the parentheses can be omitted and you can use the postfix notation.</li><li class="listitem" style="list-style-type: disc">For methods with an arity of <code class="literal">1</code> or more, meaning they take one or more parameters, it's possible to write the method using infix notation.</li></ul></div><p>Here's an example of using infix notation when invoking 
<code class="literal">filter</code>:
</p><div class="informalexample"><pre class="programlisting">List.range(0, 10).filter(_ &gt; 5)
List.range(0, 10) filter (_ &gt; 5)</pre></div><p>And here's an example of omitting the parentheses when invoking 
<code class="literal">toUpperCase:</code>
</p><div class="informalexample"><pre class="programlisting">"Professional Scala".toUpperCase()
"Professional Scala".toUpperCase</pre></div><p>This allows you to write code that reads more like prose, which is a nice option to have when you're creating your DSL.</p></div><div class="section" title="By-Name Parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec114"/>By-Name Parameters</h2></div></div></div><p>By-name parameters 
<a class="indexterm" id="id438"/>make it possible
<a class="indexterm" id="id439"/> to specify that a parameter that's passed to a function shouldn't be evaluated until it's actually used:
</p><div class="informalexample"><pre class="programlisting">def whileLoop(condition: =&gt; Boolean)(body: =&gt; Unit): Unit =
 if (condition) {
   body
   whileLoop(condition)(body)
 }

var i = 2

whileLoop (i &gt; 0) {
 println(i)
 i -= 1
}  // prints 2 1</pre></div><p>Note that both the 
<code class="literal">condition</code> and 
<code class="literal">body</code> parameter types have a 
<code class="literal">=&gt;</code> prepended. That's how you specify that a parameter is a by-name parameter.
</p><p>We'll use by-name parameters to enable the user to write the 
<code class="literal">… in { … code … }</code> blocks for the tests cases when we're writing our own DSL later in this chapter.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>It's important to note that by-name parameters are evaluated every time they're referenced.</p></div></div></div><div class="section" title="Extension Methods and Value Classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec115"/>Extension Methods and Value Classes</h2></div></div></div><p>Extension methods 
<a class="indexterm" id="id440"/>are a
<a class="indexterm" id="id441"/> technique for adding new methods to already existing Scala classes. 
<code class="literal">Value</code> Classes is a Scala feature that, among other things, makes it possible to 
<a class="indexterm" id="id442"/>create extension methods without incurring any allocation overhead.
</p><p>Here's an example 
<a class="indexterm" id="id443"/>of a 
<code class="literal">Value</code> class that adds an extension method to 
<code class="literal">String:</code>
</p><div class="informalexample"><pre class="programlisting">implicit class StringExtensions(val self: String) extends AnyVal {
 def repeat(count: Int): String =
  List.range(0, count).map(_ =&gt; self).fold("")(_ + _)
}</pre></div><p>With this definition, there will be an implicit conversion from 
<code class="literal">String</code> to 
<code class="literal">StringExtension</code>, which allows you to invoke 
<code class="literal">repeat</code> on a string as if it had always been there (note the use of the postfix notation):
</p><div class="informalexample"><pre class="programlisting">"Professional Scala" repeat 5</pre></div><p>We'll use extension methods and Value classes to add the 
<code class="literal">should</code> method to 
<code class="literal">String</code> when we're writing our own DSL later in this chapter.
</p><p>We've seen how Scala's features make it possible to write nice internal DSLs in Scala. We'll now see how to write a custom DSL.</p></div></div>
<div class="section" title="Writing a Small DSL"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Writing a Small DSL</h1></div></div></div><p>In this section, we'll 
<a class="indexterm" id="id444"/>reimplement some 
<code class="literal">FlatSpec</code>
<code class="literal">ScalaTest</code> DSLs in order to see how to implement DSLs in Scala.
</p><p>First, we'll have a look at a simple way to model test cases in Scala using case classes. Then, we'll have a look at how to create a little DSL for creating those test cases.</p><div class="section" title="Modeling Test Cases"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec116"/>Modeling Test Cases</h2></div></div></div><p>Before we
<a class="indexterm" id="id445"/> can create a DSL, we need to have something to create a DSL for. In our case, we want to create a DSL for specifying tests, so let's have a look at how we could model tests using case classes in Scala:
</p><div class="informalexample"><pre class="programlisting">sealed trait TestResult
case class TestFailure(message: String) extends TestResult
case object TestSuccess extends TestResult</pre></div><p>We'll create an algebraic data type that represents the result of running a test case. The result can either be a failure that contains a message regarding the failure, or a 
<code class="literal">TestSuccess</code> that simply indicates that the test passed:
</p><div class="informalexample"><pre class="programlisting">case class TestCase(description: TestDescription, run: () =&gt; TestResult)
case class TestDescription(name: String, specification: String)</pre></div><p>Then, we define two simple case classes. 
<code class="literal">TestDescription</code> contains the description of a test case, whereas 
<code class="literal">TestCase</code> has such a description and a 
<code class="literal">run</code> function that can be used to invoke the test case.
</p><p>With this simple model, we 
<a class="indexterm" id="id446"/>can describe a test case like the following:
</p><div class="informalexample"><pre class="programlisting">TestCase(
    TestDescription("A stack", "pop values in last-in-first-out order"),
   TestResult.wrap({
        val stack = new Stack[Int]
        stack.push(1)
        stack.push(2)
        assert(stack.pop() == 2, "should be (2)")
        assert(stack.pop() == 1, "should be (1)")
    })
)</pre></div><p>Here, 
<code class="literal">TestResult.wrap</code> is a method with the signature 
<code class="literal">def wrap(body: =&gt; Unit): () =&gt; TestResult</code>.
</p><p>Now, this looks 
<a class="indexterm" id="id447"/>nothing like the nice test cases we wrote in the previous section using the 
<code class="literal">FlatSpec</code> DSL, so let's have a look at how we can create a DSL that creates a 
<code class="literal">TestCase</code> like the previous one.
</p></div><div class="section" title="DSL for TestCase"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec117"/>DSL for TestCase</h2></div></div></div><p>We'll 
<a class="indexterm" id="id448"/>start by looking at
<a class="indexterm" id="id449"/> the part of the DSL that makes it possible to write the test specification, that is, the part of the DSL shown here:
</p><div class="informalexample"><pre class="programlisting">"A Stack (with one item)" should "be non-empty" in { … code … }</pre></div><p>From the last section, it should be clear that this is using an extension method 
<code class="literal">should</code> on 
<code class="literal">String</code> that's invoked using infix notation. So, we'll add an extension method to 
<code class="literal">String</code> to create 
<code class="literal">TestDescription</code> using the little DSL from before:
</p><div class="informalexample"><pre class="programlisting">implicit class StringExtension(val name: String) extends AnyVal {
 def should(specification: String): TestDescription =
   TestDescription(name, specification)
}</pre></div><p>With this 
<a class="indexterm" id="id450"/>implicit value
<a class="indexterm" id="id451"/> class in scope, we can create a 
<code class="literal">TestDescription</code> using the following syntax:
</p><div class="informalexample"><pre class="programlisting">"A Stack (with one item)" should "be non-empty"
// Returns TestDescription("A Stack (with one item)","be non-empty")</pre></div><p>This reduces our 
<code class="literal">TestCase</code> creation to the following.
</p><div class="informalexample"><pre class="programlisting">TestCase(
    "A Stack (with one item)" should "be non-empty"
    TestResult.wrap({
        val stack = new Stack[Int]
        stack.push(1)
        stack.push(2)
        assert(stack.pop() == 2, "should be (2)")
        assert(stack.pop() == 1, "should be (1)")
    })
)</pre></div><p>This is slightly better, but far from ideal. Let's continue. Now, let's focus on the remaining part of the DSL, the part that makes it possible to write the actual test case. It's the part of the DSL shown here:</p><div class="informalexample"><pre class="programlisting">"A Stack (with one item)" should "be non-empty" in { … code … }</pre></div><p>Again, in the previous section, we saw that we could write such expressions in Scala using infix notation 
<a class="indexterm" id="id452"/>and by-name parameters. Now, to allow the creation of 
<code class="literal">TestCase</code> instances using the DSL, we'll have to add a method to 
<code class="literal">TestDescription</code> as follows:
</p><div class="informalexample"><pre class="programlisting">def in(body: =&gt; Unit): TestCase = TestCase(this, TestResult.wrap(body))</pre></div><p>With this 
<a class="indexterm" id="id453"/>method, we can now write our test case using the following syntax:
</p><div class="informalexample"><pre class="programlisting">"A Stack (with one item)" should "be non-empty" in {
    val stack = new Stack[Int]
    stack.push(1)
    stack.push(2)
    assert(stack.pop() == 2, "should be (2)")
    assert(stack.pop() == 1, "should be (1)")
}</pre></div><p>And, with that, we're done with creating our little DSL for writing test case specifications.</p><p>We're not trying to create a full-featured testing library here, but it would be fun to be able to run the tests, so let's have a look at how to implement a test runner.</p><p>As we've modeled our test cases using Scala classes, it's quite simple to create a test runner that runs the tests and prints a nice little report.</p><p>You've seen how to use some of Scala's features to very easily write a DSL to create test cases. By using the flexible syntax for method invocation, by-name parameters, and extension methods (through Value classes), you've managed to create an internal DSL that makes it possible to convert this expression:</p><div class="informalexample"><pre class="programlisting">TestCase(
    TestDescription("A stack", "pop values in last-in-first-out order"),
    TestResult.wrap({
        val stack = new Stack[Int]
        stack.push(1)
        stack.push(2)
        assert(stack.pop() == 2, "should be (2)")
        assert(stack.pop() == 1, "should be (1)")
    })
)</pre></div><p>Into the
<a class="indexterm" id="id454"/> following:
</p><div class="informalexample"><pre class="programlisting">"A Stack" should "pop values in last-in-first-out order" in {
    val stack = new Stack[Int]
   stack.push(1)
    stack.push(2)
    assert(stack.pop() == 2, "should be (2)")
    assert(stack.pop() == 1, "should be (1)")
}</pre></div></div><div class="section" title="Activity: Creating a DSL to Specify Assertions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec118"/>Activity: Creating a DSL to Specify Assertions</h2></div></div></div><p>Our DSL makes
<a class="indexterm" id="id455"/> it possible to write 
<code class="literal">TestCase</code> instances easily. However, the assertions in our test cases don't look very nice. Create a DSL to specify assertions. It should support the following syntax:
</p><div class="informalexample"><pre class="programlisting">expected(2) from stack.pop()</pre></div><p>
<span class="strong"><strong>Hint</strong></span>:
</p><p>Start by modeling assertions 
<a class="indexterm" id="id456"/>using case classes:
</p><div class="informalexample"><pre class="programlisting">case class Assertion[A](expected: Expected[A], value: () =&gt; A)
case class Expected[A](expected: A)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>You can see the final result in the code for this chapter in 
<code class="literal">dsl/src/main/scala/com/example/Assertion.scala</code> and the usage in 
<code class="literal">dsl/src/main/scala/com/example/Assertion.scala/Main.scala.</code>
</p></div></div><p>The full code should look like this:</p><div class="informalexample"><pre class="programlisting">
<code class="literal">package com.example</code>
<code class="literal">case class Assertion[A](expected: Expected[A], value: () =&gt; A) {</code>
<code class="literal">  def run(): Unit = {</code>
<code class="literal">    val result = value()</code>
<code class="literal">    assert(expected.expected == result, s"Failed asserting that ${expected.expected} == $result")</code>
<code class="literal">  }</code>
<code class="literal">}</code>
<code class="literal">case class Expected[A](expected: A) {</code>
<code class="literal">  def from(expression: =&gt; A): Assertion[A] = Assertion(</code>
<code class="literal">    this,</code>
<code class="literal">    () =&gt; expression</code>
<code class="literal">  )</code>
<code class="literal">}</code>
<code class="literal">object Assertion {</code>
<code class="literal">  def expected[A](x: A): Expected[A] = Expected(x)</code>
<code class="literal">}</code>
</pre></div></div></div>
<div class="section" title="Beyond This Book"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec39"/>Beyond This Book</h1></div></div></div><p>This section will help you get a better overview of the Scala ecosystem and help guide your self-study after the book has ended, so you can continue to improve your Scala skills.</p><div class="section" title="Various Scala Libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec119"/>Various Scala Libraries</h2></div></div></div><p>The purpose of this topic is to briefly introduce a couple of different Scala libraries for solving problems in different domains so that you can study the ones that are interesting to you after the book.</p><div class="section" title="Akka"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec19"/>Akka</h3></div></div></div><p>The first library
<a class="indexterm" id="id457"/> we'll look at is one of the most popular 
<a class="indexterm" id="id458"/>libraries in the Scala ecosystem. It has been around for a long time—the first public release of the library was in 2010—and it's used in production by a large number of big organizations.
</p><p>Its main abstractions are 
<code class="literal">Actor</code> and 
<code class="literal">Streams</code>:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Actors</code> are a way to model concurrency without resorting to locks. You might have heard about them before if you've read about the programming language <code class="literal">Erlang</code>. An Actor is an entity that can receive and react to messages, spawn new <code class="literal">actors</code>, and send messages to other <code class="literal">actors</code>. Thus, you model your programs as a set of <code class="literal">actors</code> that communicate to each other by sending messages.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>You can find more
<a class="indexterm" id="id459"/> information about 
<code class="literal">Actors</code> here: 
<a class="ulink" href="https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala">https://doc.akka.io/docs/akka/current/guide/actors-intro.html?language=scala</a>
</p></div></div></li><li class="listitem" style="list-style-type: disc">If you have to deal with streaming data, you can use Akka <code class="literal">Streams</code> to model your programs as transformations over data flowing from sources into sinks.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>You can read more about 
<a class="indexterm" id="id460"/>
<code class="literal">Streams</code> here: 
<a class="ulink" href="https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala">https://doc.akka.io/docs/akka/current/stream/stream-introduction.html?language=scala</a>.
</p></div></div></li><li class="listitem" style="list-style-type: disc">If you want to build a distributed system in Scala, it is highly recommended to use Akka.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>You can read more 
<a class="indexterm" id="id461"/>about Akka on its website: 
<a class="ulink" href="https://akka.io/">https://akka.io/</a>.
</p></div></div></li></ul></div></div><div class="section" title="Apache Spark"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec20"/>Apache Spark</h3></div></div></div><p>Apache Spark is 
<a class="indexterm" id="id462"/>a library for processing large Scala
<a class="indexterm" id="id463"/> datasets. Apache Spark was initially developed at UC Berkeley in 2009, and in 2013 it was donated to the Apache Software Foundation and is now a Top-Level Apache Project with more than 1,000 contributors.
</p><p>You can write Spark programs in Java, Scala, Python, and R. You can write your own custom data analytics programs using the Spark API, or you can use one of the high-level APIs: Spark SQL for SQL and structured data processing, MLlib for machine learning, GraphX for graph processing, and Spark Streaming.</p><p>If you're interested in big data processing, take a look at Spark.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>You can read more about Spark 
<a class="indexterm" id="id464"/>on its website: 
<a class="ulink" href="https://spark.apache.org/">https://spark.apache.org/</a>.
</p></div></div></div><div class="section" title="Shapeless"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec21"/>Shapeless</h3></div></div></div><p>Shapeless is a
<a class="indexterm" id="id465"/> type class and dependent type-based generic programming library for Scala. It was initially written in 2011 by Miles Sabin and is 
<a class="indexterm" id="id466"/>now used by many companies to write type-safe code. It is also used internally by many libraries.
</p><p>One of the major features of Shapeless is that it enables automatic derivation of type classes.</p><p>Using Shapeless, you 
<a class="indexterm" id="id467"/>can get the compiler to type-check things that you might not have thought possible. Some examples are:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Heterogeneous lists, that is, lists where each element can be of different types and where the Scala compiler keeps track of the types</li><li class="listitem" style="list-style-type: disc">Have the compiler check that collections are of a given length</li></ul></div><p>In this section, we've 
<a class="indexterm" id="id468"/>seen three different Scala libraries that can be used to solve problems in the following domains:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Distributed programming</li><li class="listitem" style="list-style-type: disc">Big data processing</li><li class="listitem" style="list-style-type: disc">Generic programming</li></ul></div></div></div><div class="section" title="Uncovered Language Features"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec120"/>Uncovered Language Features</h2></div></div></div><p>The purpose 
<a class="indexterm" id="id469"/>of this topic is to briefly introduce you to some of the language features that we haven't covered, and show you where to go if you want to learn more about these topics. These features are:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Macros</li><li class="listitem" style="list-style-type: disc">Reflection</li></ul></div><div class="section" title="Macros"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec22"/>Macros</h3></div></div></div><p>Macros 
<a class="indexterm" id="id470"/>are a 
<a class="indexterm" id="id471"/>programming language feature that makes it possible to write functions that take the AST of their arguments as input and produce a new AST, effectively allowing you to write programs that generate other programs. 
</p><p>Macros come in many shapes and sizes. In this section, we'll have a look at how to use macros in Scala. Experimental support for Scala macros was shipped with Scala 2.10, and, since then, they have been improved with every release.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>You can 
<a class="indexterm" id="id472"/>find the official documentation for macros on the Scala documentation website here: 
<a class="ulink" href="https://docs.scala-lang.org/overviews/macros/overview.html.">https://docs.scala-lang.org/overviews/macros/overview.html.</a>
</p></div></div></div><div class="section" title="Def Macros"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec23"/>Def Macros</h3></div></div></div><p>Def macros are 
<a class="indexterm" id="id473"/>macros that are defined as Scala functions 
<a class="indexterm" id="id474"/>which reference a macro implementation. Let's have a look at a very simple macro that takes a 
<code class="literal">String</code> and returns an uppercase version of that string:
</p><div class="informalexample"><pre class="programlisting">object Macros {

 def uppercaseImpl(c: Context)(strExpr: c.Expr[String]): c.Expr[String] = {
   import c.universe._
   val Literal(Constant(str: String)) = strExpr.tree
   c.Expr[String](q"${str.toUpperCase}")
 }

 def uppercase(strExpr: String): String = macro uppercaseImpl
}</pre></div><p>The 
<code class="literal">uppercase</code> method is how the macro is exposed to the users of the macro. The actual macro implementation is 
<code class="literal">uppercaseImpl</code>, which has two parameter lists. The
<a class="indexterm" id="id475"/> first parameter contains a single argument, the 
<code class="literal">Context</code>, which contains information collected by the compiler at the call site of the macro. The second parameter contains the Scala abstract syntax trees of the expression
<a class="indexterm" id="id476"/> of type 
<code class="literal">String</code> that the macro was invoked with. Let's see how to invoke this macro:
</p><div class="informalexample"><pre class="programlisting">val x = Macros.uppercase("testing")
println(x)</pre></div><p>This looks very much like a normal Scala method invocation; however, the uppercasing of the argument happens at compile time.</p><p>Note that the macro as implemented here only works with 
<code class="literal">String</code> literals; if you invoke it with anything else, you'll crash the compiler.
</p></div><div class="section" title="Implicit Macros"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec24"/>Implicit Macros</h3></div></div></div><p>Implicit macros
<a class="indexterm" id="id477"/> make it possible to reference a macro in the
<a class="indexterm" id="id478"/> implementation of an implicit method. One use case of this is to write macros that can generate an instance of a given type class, given any type 
<code class="literal">T</code>:
</p><div class="informalexample"><pre class="programlisting">trait Showable[T] { def show(x: T): String }</pre></div><p>Then, instead of writing individual type class instances for all of your types, like the following:</p><div class="informalexample"><pre class="programlisting">final case class Person(name: String)

object Person {
 implicit val showable: Showable[Person] = new Showable[Person]{
   def show(x: Person) = s"Person(name=${x.name})"
 }
}</pre></div><p>You could 
<a class="indexterm" id="id479"/>instead define an implicit macro that can generate 
<a class="indexterm" id="id480"/>an instance of the type class for any given type 
<code class="literal">T</code>, as follows:
</p><div class="informalexample"><pre class="programlisting">object Showable {
 implicit def materializeShowable[T]: Showable[T] = macro ...
}</pre></div></div><div class="section" title="Quasiquotes"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec25"/>Quasiquotes</h3></div></div></div><p>It is possible
<a class="indexterm" id="id481"/> for you to use Scala's powerful String Interpolation feature to make it to write ASTs inside of Strings, so you don't have to construct the ASTs by hand. That is, you can write the following: 
</p><div class="informalexample"><pre class="programlisting">q"List(10)"</pre></div><p>Instead of writing the following:</p><div class="informalexample"><pre class="programlisting">List(Literal(Constant(10)))))</pre></div></div><div class="section" title="Reflection"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec26"/>Reflection</h3></div></div></div><p>You have very likely used reflection in other programming languages, such as Java or 
<a class="indexterm" id="id482"/>Python. Reflection makes it possible for a program to inspect and sometimes modify itself. You can think of macros as compile-time reflection
<a class="indexterm" id="id483"/> and of the reflections we'll look at now as runtime reflection.
</p><p>With runtime reflection, you can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inspect the types of objects</li><li class="listitem" style="list-style-type: disc">Instantiate new objects</li><li class="listitem" style="list-style-type: disc">Access or invoke members of an object</li></ul></div><p>Let's have a look at an example of how to inspect types at runtime:</p><div class="informalexample"><pre class="programlisting">import scala.reflect.runtime.{universe =&gt; ru}

def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]

getTypeTag(List(1,2,3)).tpe.decls
 .filter(_.name.toString.length &lt; 5)
 .foreach(d =&gt; println(s"${d.name} : ${d.typeSignature}"))</pre></div><p>This example uses 
<code class="literal">scala.reflect.runtime.universe</code> to implement a method that, for a given object of type 
<code class="literal">T,</code> will get the 
<code class="literal">TypeTag</code> for that type. Given the 
<code class="literal">TypeTag,</code> we can access 
<code class="literal">Type</code> through 
<code class="literal">tpe</code> and then get the list of the members of the type through 
<code class="literal">decls</code>. The example then filters out any member whose name is shorter than five
<code class="literal"/>characters and prints their 
<code class="literal">name</code> and 
<code class="literal">type</code>.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>Reflection can in some cases incur a non-negligible runtime overhead. If you're using it in performance-sensitive places, make sure to benchmark the results.</p></div></div><p>In this subsection, we've briefly covered two interesting Scala language features and
<a class="indexterm" id="id484"/> provided multiple links for further study of these features so that you can improve your Scala skills after this book.
</p></div></div><div class="section" title="Resources to Keep You Updated"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec121"/>Resources to Keep You Updated</h2></div></div></div><p>In this subsection, we'll have a look at how you can keep up to date with the development of the Scala programming language, as well as its ecosystem.</p><div class="section" title="Scala Improvement Process"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec27"/>Scala Improvement Process</h3></div></div></div><p>The 
<a class="indexterm" id="id485"/>Scala Improvement Process (SIP) and
<a class="indexterm" id="id486"/> Scala Platform Process (SPP) are how changes are made to the Scala Programming Language and The Scala Standard Library, respectively. If you want to make a change to either, you can make a proposal for the change, which will then be reviewed and potentially accepted.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>You can
<a class="indexterm" id="id487"/> find a list of all the current SIPs here: 
<a class="ulink" href="https://docs.scala-lang.org/sips/all.html">https://docs.scala-lang.org/sips/all.html</a>.
</p></div></div></div><div class="section" title="Scala Times"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec28"/>Scala Times</h3></div></div></div><p>The Scala Times
<a class="indexterm" id="id488"/> is a weekly newsletter that features
<a class="indexterm" id="id489"/> interesting blog posts about Scala and gives a short recap of the various Scala libraries that have been released in the previous week.
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>You can read more about it and subscribe
<a class="indexterm" id="id490"/> to the newsletter here: 
<a class="ulink" href="http://scalatimes.com/">http://scalatimes.com/</a>
</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we covered how Scala makes it possible to write powerful Domain Specific Languages (DSLs) by providing a few interesting language features. We had a brief look at what DSLs are in general terms. We have also covered a DSL that you'll very likely be using if you're going to work with Scala professionally. Finally, we have implemented our own DSL.</p><p>We now come to the end of this book. In this book, we covered all the professional concepts of the Scala language, from setting up the development environment to writing your own custom DSLs. We covered the object-oriented and functional programming aspects of the Scala language. We also covered some useful libraries that are used in Scala, such as 
<code class="literal">Cats</code> and 
<code class="literal">Doobie</code>. Finally, we covered the additional resources and tools that will help you to stay up to date in the industry.
</p></div></body></html>