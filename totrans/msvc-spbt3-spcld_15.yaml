- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Introduction to Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 简介
- en: In this chapter, we will start to learn about Kubernetes, the most popular and
    widely used container orchestrator at the time of writing this book. Since the
    subjects on container orchestrators in general and Kubernetes itself are too big
    to be covered in one chapter, I will focus on introducing the areas that I have
    found to be the most important in my use of Kubernetes over the last few years.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习 Kubernetes，这是在撰写本书时最受欢迎和最广泛使用的容器编排器。由于容器编排器的一般主题和 Kubernetes 本身的内容太多，无法在一章中涵盖，因此我将专注于介绍我在过去几年使用
    Kubernetes 时认为最重要的领域。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing Kubernetes concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 概念介绍
- en: Introducing Kubernetes API objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes API 对象介绍
- en: Introducing Kubernetes runtime components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 运行时组件介绍
- en: Creating a local Kubernetes cluster
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本地 Kubernetes 集群
- en: Trying out a sample Deployment and getting used to the `kubectl` Kubernetes
    CLI tool
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一个示例部署并熟悉 `kubectl` Kubernetes 命令行界面工具
- en: Managing a local Kubernetes cluster
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理本地 Kubernetes 集群
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何安装本书中使用的工具以及如何访问本书源代码的说明，请参阅：
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 21 章*，*macOS 安装说明*'
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 22 章*，*使用 WSL 2 和 Ubuntu 在 Microsoft Windows 上的安装说明*'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter15`.
    The source code for the sample Deployment on Kubernetes that will be performed
    in this chapter can be found in the folder `$BOOK_HOME/Chapter15/kubernetes/first-attempts`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例均来自 `$BOOK_HOME/Chapter15` 目录下的源代码。本章将要执行的示例部署在 Kubernetes 上的源代码可以在
    `$BOOK_HOME/Chapter15/kubernetes/first-attempts` 文件夹中找到。
- en: Introducing Kubernetes concepts
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 概念介绍
- en: At a high level, as a container orchestrator, Kubernetes makes a cluster of
    (physical or virtual) servers that runs containers appear to be one big logical
    server running containers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，作为容器编排器，Kubernetes 使得一组（物理或虚拟）运行容器的服务器看起来像是一个运行容器的单个大逻辑服务器。
- en: As an operator, we declare a **desired state** to the Kubernetes cluster by
    creating objects using the Kubernetes API. Kubernetes continuously compares the
    desired state with the current state. If it detects differences, it takes action
    to ensure that the current state is the same as the desired state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作员，我们通过使用 Kubernetes API 创建对象来向 Kubernetes 集群声明一个**期望状态**。Kubernetes 会持续比较期望状态和当前状态。如果检测到差异，它会采取措施确保当前状态与期望状态相同。
- en: One of the main purposes of a Kubernetes cluster is to deploy and run containers,
    but also to support zero-downtime rolling upgrades using techniques such as green/blue
    and canary Deployments. Kubernetes can schedule containers, that is, **Pods**
    that contain one or more co-located containers, to the available nodes in the
    cluster. To be able to monitor the health of running containers, Kubernetes assumes
    that containers implement a **liveness probe**. If a liveness probe reports an
    unhealthy container, Kubernetes will restart the container. Containers can be
    scaled in the cluster manually or automatically using a horizontal autoscaler.
    To optimize the use of the available hardware resources in a cluster, for example,
    memory and CPU, containers can be configured with **quotas** that specify the
    amount of resources a container needs. On the other hand, limits regarding how
    much a container is allowed to consume can be specified on the Pod or for a group
    of Pods at the **namespace** level. Namespaces will be introduced as we proceed
    through this chapter. This is of extra importance if several teams share a common
    Kubernetes cluster.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群的主要目的之一是部署和运行容器，但同时也支持使用绿色/蓝色和金丝雀部署等技术进行零停机滚动升级。Kubernetes 可以调度容器，即包含一个或多个相邻容器的**Pod**，到集群中的可用节点。为了能够监控运行容器的健康状态，Kubernetes
    假设容器实现了**存活探针**。如果存活探针报告容器不健康，Kubernetes 将重启该容器。可以在集群中手动或自动使用水平自动扩展来扩展容器。为了优化集群中可用硬件资源（例如内存和
    CPU）的使用，可以将具有指定容器所需资源数量的**配额**配置到容器中。另一方面，可以在**命名空间**级别为容器或一组 Pod 指定允许消耗的最大量。随着本章的进行，我们将介绍命名空间。如果多个团队共享一个共同的
    Kubernetes 集群，这一点尤为重要。
- en: Another main purpose of Kubernetes is to provide Service discovery of the running
    Pods and their containers. Kubernetes **Service** objects can be defined for Service
    discovery and will also load-balance incoming requests over the available Pods.
    Service objects can be exposed to the outside of a Kubernetes cluster. However,
    as we will see, an **Ingress** object is, in many cases, better suited to handling
    externally incoming traffic to a group of Services. To help Kubernetes find out
    whether a container is ready to accept incoming requests, a container can implement
    a **readiness probe**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的另一个主要目的是提供正在运行的 Pod 和它们的容器的服务发现。可以为服务发现定义 Kubernetes **服务**对象，并且它还会在可用的
    Pod 上进行请求的负载均衡。服务对象可以被暴露在 Kubernetes 集群外部。然而，正如我们将看到的，**入口**对象在很多情况下更适合处理指向一组服务的外部传入流量。为了帮助
    Kubernetes 确定容器是否准备好接受传入请求，容器可以实现 **就绪探测**。
- en: Internally, a Kubernetes cluster provides one big flat IP network where each
    Pod gets its own IP address and can reach all the other Pods, independent of which
    node they run on. To support multiple network vendors, Kubernetes allows the use
    of network plugins that comply with the **Container Network Interface** (**CNI**)
    specification ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    Pods are not isolated by default; they accept all incoming requests. CNI plugins
    that support the use of network policy definitions can be used to lock down access
    to Pods, for example, only allowing traffic from Pods in the same namespace.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Kubernetes 集群提供一个大型的扁平 IP 网络，其中每个 Pod 都有自己的 IP 地址，并且可以到达所有其他 Pod，无论它们运行在哪个节点上。为了支持多个网络供应商，Kubernetes
    允许使用符合 **容器网络接口**（**CNI**）规范（[https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)）的网络插件。默认情况下，Pod
    不会被隔离；它们接受所有传入的请求。支持使用网络策略定义的 CNI 插件可以用来锁定对 Pod 的访问，例如，仅允许来自同一命名空间内 Pod 的流量。
- en: To allow multiple teams to work on the same Kubernetes cluster in a safe way,
    **Role-Based Access Control** (**RBAC**, [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/))
    can be applied. For example, administrators can be authorized to access resources
    at the cluster level, while the access of team members can be locked down to resources
    that are created in a namespace owned by the teams.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许多个团队以安全的方式在同一个 Kubernetes 集群上工作，可以应用 **基于角色的访问控制**（**RBAC**，[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)）。例如，管理员可以授权访问集群级别的资源，而团队成员的访问可以限制到由团队拥有的命名空间中创建的资源。
- en: In total, these concepts provide a platform for running containers that is scalable,
    secure, highly available, and resilient.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些概念提供了一个可扩展、安全、高可用性和弹性的容器运行平台。
- en: Let’s look a bit further into the API objects that are available in Kubernetes
    and, after that, the runtime components that make up a Kubernetes cluster.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步了解 Kubernetes 中可用的 API 对象，以及构成 Kubernetes 集群的运行时组件。
- en: Introducing Kubernetes API objects
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes API 对象
- en: 'Kubernetes defines an API that is used to manage different types of *objects*
    or *resources*, as they are also known. Some of the most commonly used types,
    or *kinds*, as referred to in the API, are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 定义了一个 API，用于管理不同类型的 *对象* 或 *资源*，正如它们所知。API 中提到的最常用的类型，或称为 *种类*，如下所示：
- en: '**Node**: A node represents a server, virtual or physical, in the cluster.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：节点代表集群中的一个服务器，无论是虚拟的还是物理的。'
- en: '**Pod**: A Pod represents the smallest possible deployable component in Kubernetes,
    consisting of one or more co-located containers. The containers share the same
    IP address and port range. This means that containers in the same Pod instance
    can talk to each other over localhost, but need to be aware of potential port
    collisions. Typically, a Pod consists of one container, but there are use cases
    for extending the functionality of the main container by running the second container
    in a Pod. In *Chapter 18*, *Using a Service Mesh to Improve Observability and
    Management*, a second container will be used in the Pods, running a sidecar that
    makes the main container join the Service mesh.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**：Pod是Kubernetes中最小的可部署组件，由一个或多个并置的容器组成。这些容器共享相同的IP地址和端口范围。这意味着同一Pod实例中的容器可以通过localhost相互通信，但需要注意潜在的端口冲突。通常，Pod由一个容器组成，但也有一些用例，可以通过在Pod中运行第二个容器来扩展主容器的功能。在*第18章*，*使用服务网格来提高可观察性和管理*中，Pod中将使用第二个容器，运行一个边车容器，使主容器加入服务网格。'
- en: '**Deployment**: A Deployment is used to deploy and upgrade Pods. The Deployment
    objects hand over the responsibility of creating and monitoring the Pods to a
    ReplicaSet. When creating a Deployment for the first time, the work performed
    by the Deployment object is not much more than creating the ReplicaSet object.
    When performing a rolling upgrade of a Deployment, the role of the Deployment
    object is more involved.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：Deployment用于部署和升级Pod。Deployment对象将创建和监控Pod的责任交给ReplicaSet。当首次创建Deployment时，Deployment对象执行的工作并不比创建ReplicaSet对象的工作多多少。当执行Deployment的滚动升级时，Deployment对象的角色更为复杂。'
- en: '**ReplicaSet**: A ReplicaSet is used to ensure that a specified number of Pods
    is running at all times. If a Pod is deleted, it will be replaced with a new Pod
    by the ReplicaSet.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReplicaSet**：ReplicaSet用于确保始终运行指定数量的Pod。如果一个Pod被删除，ReplicaSet将用一个新的Pod来替换它。'
- en: '**Service**: A Service is a stable network endpoint that you can use to connect
    to one or multiple Pods. A Service is assigned an IP address and a DNS name in
    the internal network of the Kubernetes cluster. The IP address of the Service
    will stay the same for the lifetime of the Service. Requests that are sent to
    a Service will be forwarded to one of the available Pods using round-robin-based
    load balancing. By default, a Service is only exposed inside the cluster using
    a cluster IP address. It is also possible to expose a Service outside the cluster,
    either on a dedicated port on each node in the cluster or – even better – through
    an external load balancer that is aware of Kubernetes; that is, it can automatically
    provision a public IP address and/or DNS name for the Service. Cloud providers
    that offer Kubernetes as a Service, in general, support this type of load balancer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Service**：Service是一个稳定的网络端点，您可以使用它来连接到一个或多个Pod。Service在Kubernetes集群的内部网络中被分配一个IP地址和DNS名称。Service的IP地址在其生命周期内保持不变。发送到Service的请求将通过基于轮询的负载均衡转发到可用的Pod之一。默认情况下，Service仅通过集群IP地址在集群内部暴露。也有可能将Service暴露在集群外部，要么在集群中每个节点的专用端口上，要么——更好的是——通过一个了解Kubernetes的外部负载均衡器；也就是说，它可以自动为Service分配一个公共IP地址和/或DNS名称。通常，提供Kubernetes作为服务的云提供商支持这种类型的负载均衡器。'
- en: '**Ingress**: Ingress can manage external access to Services in a Kubernetes
    cluster, typically using HTTP or HTTPS. For example, it can route traffic to the
    underlying Services based on URL paths or HTTP headers such as the hostname. Instead
    of exposing a number of Services externally, either using node ports or through
    load balancers, it is, in general, more convenient to set up an Ingress in front
    of the Services. To handle the actual communication defined by the Ingress objects,
    an Ingress controller must be running in the cluster. We will see an example of
    an Ingress controller as we proceed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress**：Ingress可以管理Kubernetes集群中服务的对外访问，通常使用HTTP或HTTPS。例如，它可以根据URL路径或HTTP头（如主机名）将流量路由到底层的服务。通常，不是通过使用节点端口或通过负载均衡器公开多个服务，而是在服务前面设置一个Ingress更为方便。为了处理Ingress对象定义的实际通信，集群中必须运行一个Ingress控制器。随着我们的进展，我们将看到一个Ingress控制器的示例。'
- en: '**Namespace**: A namespace is used to group and, on some levels, isolate resources
    in a Kubernetes cluster. The names of resources must be unique in their namespaces,
    but not between namespaces.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Namespace**：Namespace用于在Kubernetes集群中对资源进行分组和在某种程度上进行隔离。资源名称必须在它们的命名空间中是唯一的，但不同命名空间之间不必唯一。'
- en: '**ConfigMap**: A ConfigMap is used to store configuration that’s used by containers.
    ConfigMaps can be mapped into a running container as environment variables or
    files.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigMap**：ConfigMap用于存储容器使用的配置。ConfigMaps可以映射到正在运行的容器中作为环境变量或文件。'
- en: '**Secret**: This is used to store sensitive data used by containers, such as
    credentials. Secrets can be made available to containers in the same way as ConfigMaps.
    Anyone with full read access to the API server can access the values of created
    Secrets, so they are not as safe as the name might imply.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secret**：用于存储容器使用的敏感数据，例如凭证。Secrets可以通过与ConfigMaps相同的方式提供给容器。任何对API服务器具有完全读取访问权限的人都可以访问创建的Secrets的值，因此它们并不像名字所暗示的那样安全。'
- en: '**DaemonSet**: This ensures that one Pod is running on each node in a set of
    nodes in the cluster. In *Chapter 19*, *Centralized Logging with the EFK Stack*,
    we will see an example of a log collector, Fluentd, that will run on each worker
    node as a DaemonSet.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：确保在集群中的一组节点上运行一个Pod。在*第19章*，*使用EFK堆栈进行集中式日志记录*中，我们将看到一个日志收集器Fluentd的示例，它将以DaemonSet的形式在每个工作节点上运行。'
- en: For a full list of resource objects that the Kubernetes API covers in v1.26,
    see [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Kubernetes API在v1.26中涵盖的资源对象的完整列表，请参阅[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/)。
- en: 'The following diagram summarizes the Kubernetes resources that are involved
    in handling incoming requests:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图总结了处理传入请求所涉及的Kubernetes资源：
- en: '![Diagram  Description automatically generated](img/B19825_15_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_15_01.png)'
- en: 'Figure 15.1: Overview of Kubernetes resources'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：Kubernetes资源概述
- en: 'In the preceding diagram, we can see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以看到以下内容：
- en: Two Deployments, **Deployment A** and **Deployment B**, have been deployed to
    a cluster with two nodes, **Node 1** and **Node 2**
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个部署，**部署A**和**部署B**，已部署到具有两个节点**节点1**和**节点2**的集群中
- en: '**Deployment A** contains two Pods, **Pod A1** and **Pod A2**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署A**包含两个Pod，**Pod A1**和**Pod A2**'
- en: '**Deployment B** contains one Pod, **Pod B1**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署B**包含一个Pod，**Pod B1**'
- en: '**Pod A1** is scheduled to **Node 1**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A1**被调度到**节点1**'
- en: '**Pod A2** and **Pod B1** are scheduled to **Node 2**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A2**和**Pod B1**被调度到**节点2**'
- en: Each Deployment has a corresponding Service deployed, **Service A** and **Service
    B**, and they are available on all nodes
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部署都有一个相应的服务部署，**服务A**和**服务B**，并且它们在所有节点上都是可用的
- en: An **Ingress** is defined to route incoming requests to the two Services
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个**入口**来路由传入请求到两个服务
- en: A client typically sends requests to the cluster via an **external load balancer**
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通常通过**外部负载均衡器**向集群发送请求
- en: These objects are not, by themselves, running components; instead, they are
    definitions of different types of desired states. To reflect the desired state
    in the cluster’s current state, Kubernetes comes with an architecture consisting
    of a number of runtime components, as described in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象本身不是运行组件；相反，它们是不同类型期望状态的定义。为了在集群的当前状态下反映期望状态，Kubernetes提供了一套由多个运行时组件组成的架构，如下一节所述。
- en: Introducing Kubernetes runtime components
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes运行时组件
- en: 'A Kubernetes cluster contains two types of nodes: **master nodes** and **worker
    nodes**. Master nodes manage the cluster, while the main purpose of worker nodes
    is to run the actual workload, for example, the containers we deploy in the cluster.
    Kubernetes is built up of a number of runtime components. The most important components
    are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群包含两种类型的节点：**主节点**和**工作节点**。主节点管理集群，而工作节点的主要目的是运行实际的工作负载，例如，我们在集群中部署的容器。Kubernetes由多个运行时组件组成。最重要的组件如下：
- en: 'There are components that run on master nodes, constituting the **control plane**:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些组件运行在主节点上，构成了**控制平面**：
- en: The **API server**, the entry point to the control plane. This exposes a RESTful
    API, which, for example, the Kubernetes CLI tool known as **kubectl** uses.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API服务器**，控制平面的入口点。它公开了一个RESTful API，例如，Kubernetes CLI工具**kubectl**就是使用这个API。'
- en: '**etcd**, a highly available and distributed key-value store, used as a database
    for all cluster data.'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**，一个高度可用和分布式的键值存储，用作所有集群数据的数据库。'
- en: A **controller manager**, which contains a number of controllers that continuously
    evaluate the desired state versus the current state for the objects defined in
    the etcd database. Whenever the desired or current state changes, a controller
    that’s responsible for that type of state takes action to move the current state
    to the desired state. For example, a replication controller that’s responsible
    for managing Pods will react if a new Pod is added through the API server or a
    running Pod is deleted and ensures that new Pods are started. Another example
    of a controller is the node controller. It is responsible for acting if a node
    becomes unavailable, ensuring that Pods running on a failing node are rescheduled
    on other nodes in the cluster.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **控制器管理器**，其中包含多个控制器，它们会持续评估 etcd 数据库中定义的对象的期望状态与当前状态。每当期望状态或当前状态发生变化时，负责该类型状态的控制器会采取行动，将当前状态移动到期望状态。例如，负责管理
    Pods 的复制控制器会在通过 API 服务器添加新 Pod 或正在运行的 Pod 被删除时做出反应，并确保启动新的 Pods。另一个控制器的例子是节点控制器。它负责在节点不可用时采取行动，确保在集群中的其他节点上重新调度失败节点上运行的
    Pods。
- en: A **scheduler**, which is responsible for assigning newly created Pods to a
    node with available capacity, for example, in terms of memory and CPU. **Affinity
    rules** can be used to control how Pods are assigned to nodes. For example, Pods
    that perform a lot of disk I/O operations can be assigned to a group of worker
    nodes that have fast SSD disks. Anti-affinity rules can be defined to separate
    Pods, for example, to avoid scheduling Pods from the same Deployment to the same
    worker node.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 **调度器**，负责将新创建的 Pods 分配到具有可用容量的节点上，例如，从内存和 CPU 的角度来看。可以使用 **亲和性规则** 来控制 Pods
    分配到节点的方式。例如，执行大量磁盘 I/O 操作的 Pods 可以分配到具有快速 SSD 硬盘的一组工作节点。可以定义 **反亲和性规则** 来分离 Pods，例如，避免将来自同一
    Deployment 的 Pods 分配到同一工作节点。
- en: 'Components that run on all the nodes, constituting the **data plane**:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有节点上运行的组件，构成 **数据平面**：
- en: '**kubelet**, a node agent that executes as a process directly in the nodes’
    operating system and not as a container. A kubelet ensures that the Pods that
    are scheduled to its node have their containers up and running and that they are
    healthy. It acts as a conduit between the API server and the container runtime
    on its node.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubelet**，一个节点代理，它作为节点操作系统中直接运行的过程，而不是作为容器。kubelet 确保分配给其节点的 Pods 的容器处于运行状态，并且它们是健康的。它在其节点上充当
    API 服务器和容器运行时之间的通道。'
- en: '**kube-proxy**, a network proxy that enables the Service concept in Kubernetes
    and is capable of forwarding requests to the appropriate Pods, typically in a
    round-robin fashion if more than one Pod is available for the specific Service.
    `kube-proxy` is deployed as a DaemonSet.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**，一个网络代理，它使 Kubernetes 中的 Service 概念成为可能，并且能够将请求转发到适当的 Pods，如果有多个
    Pods 可用于特定的 Service，通常以轮询的方式。`kube-proxy` 作为 DaemonSet 部署。'
- en: '**Container runtime**, which is the software that runs the containers on a
    node. Historically, Kubernetes used Docker Engine, but today any implementation
    of the Kubernetes **Container Runtime Interface** (**CRI**) can be used, for example,
    **cri-o** ([https://cri-o.io](https://cri-o.io)) and **containerd** ([https://containerd.io/](https://containerd.io/)).
    Support for Docker Engine was removed in Kubernetes v1.24.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**，这是在节点上运行容器的软件。历史上，Kubernetes 使用 Docker Engine，但今天可以使用任何 Kubernetes
    **容器运行时接口**（**CRI**）的实现，例如 **cri-o** ([https://cri-o.io](https://cri-o.io)) 和
    **containerd** ([https://containerd.io/](https://containerd.io/))。在 Kubernetes
    v1.24 中移除了对 Docker Engine 的支持。'
- en: '`containerd` is actually the container engine of Docker. It was separated from
    Docker back in 2017 and is today a graduated CNCF project.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`containerd` 实际上是 Docker 的容器引擎。它在 2017 年从 Docker 中分离出来，如今已成为一个毕业的 CNCF 项目。'
- en: '**Kubernetes DNS**, which is a DNS server that’s used in the cluster’s internal
    network. Services and Pods are assigned a DNS name, and Pods are configured to
    use this DNS server to resolve the internal DNS names. The DNS server is deployed
    as a Deployment object and a Service object.'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes DNS**，这是一个在集群内部网络中使用的 DNS 服务器。服务和 Pods 被分配一个 DNS 名称，并且 Pods 被配置为使用此
    DNS 服务器解析内部 DNS 名称。DNS 服务器作为 Deployment 对象和 Service 对象部署。'
- en: 'The following diagram summarizes the Kubernetes runtime components described
    above:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下图总结了上述描述的 Kubernetes 运行时组件：
- en: '![Diagram  Description automatically generated](img/B19825_15_02.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19825_15_02.png)'
- en: 'Figure 15.2: Overview of Kubernetes runtime components'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2：Kubernetes 运行时组件概述
- en: 'Based on the diagram, we can imagine the following sequence of events:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图示，我们可以想象以下事件序列：
- en: An operator uses **kubectl** to send in a new desired state to Kubernetes, containing
    manifests declaring a new **Deployment**, **Service**, and **Ingress** object.
    The Ingress defines a route to the Service object and the Service object is defined
    to select Pods that are configured by the Deployment object.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作员使用**kubectl**向Kubernetes发送一个新的期望状态，其中包含声明新**Deployment**、**Service**和**Ingress**对象的清单。Ingress定义了到Service对象的路由，而Service对象被定义为选择由Deployment对象配置的Pods。
- en: '**kubectl** talks to the **API server** and it stores the new desired state
    as objects in the **etcd** database.'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**kubectl**与**API服务器**通信，并将新的期望状态作为对象存储在**etcd**数据库中。'
- en: 'Various **controllers** will react to the creation of the new objects and take
    the following actions:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 各种**控制器**将对新对象的创建做出反应并采取以下行动：
- en: 'For the Deployment object:'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Deployment对象：
- en: New **ReplicaSet** and **Pod** objects will be registered in the API server.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的**ReplicaSet**和**Pod**对象将在API服务器中注册。
- en: The **scheduler** will see the new Pod(s) and schedule them to the appropriate
    worker nodes.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调度器**将看到新的Pod(s)并将它们调度到适当的工作节点。'
- en: On each worker node, the **kubelet** agent will launch containers as described
    by the Pods. The kubelet will use the **container runtime** on the worker node
    to manage the containers.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个工作节点上，**kubelet**代理将根据Pods描述启动容器。kubelet将使用工作节点上的**容器运行时**来管理容器。
- en: 'For the Service object:'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Service对象：
- en: A DNS name will be registered in the internal DNS server for the Service object
    and the **kube-proxy** will be able to route requests that use the DNS name to
    one of the available Pods.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在Service对象的内部DNS服务器中注册一个DNS名称，**kube-proxy**将能够将使用DNS名称的请求路由到可用的Pod之一。
- en: Note that Pods are reachable from any node in the cluster, so the kube-proxy
    does not need to run on the same node as the Pod to be able to forward requests
    to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Pods可以从集群中的任何节点访问，因此kube-proxy不需要在Pod所在的同一节点上运行，才能将请求转发到它。
- en: 'For the Ingress object:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Ingress对象：
- en: An **Ingress controller** will set up routes according to the Ingress object
    and be ready to accept requests from outside of the Kubernetes cluster. External
    requests that match the routes defined by the Ingress object will be forwarded
    by the Ingress controller to the Service object. These requests will be forwarded
    by the kube-proxy to a Pod as described above.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Ingress控制器**将根据Ingress对象设置路由，并准备好接受来自Kubernetes集群外部的请求。与Ingress对象定义的路由匹配的外部请求将由Ingress控制器转发到Service对象。这些请求将如上所述由kube-proxy转发到Pod。'
- en: Now that we understand the Kubernetes runtime components and what they support
    and run on, let’s move on to creating a Kubernetes cluster with Minikube.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Kubernetes运行时组件及其支持的内容和运行环境，让我们继续使用Minikube创建一个Kubernetes集群。
- en: Creating a Kubernetes cluster using Minikube
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Minikube创建Kubernetes集群
- en: Now, we are ready to create a Kubernetes cluster! We will use Minikube to create
    a local single-node cluster. Minikube can be deployed in a VM, a container, or
    on bare metal using different drivers. We will use one of the preferred drivers,
    the Docker driver, where the Minikube instance runs in a container managed by
    Docker Desktop on macOS and Windows with **Windows Subsystem for Linux, v2** (WSL
    2).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好创建一个Kubernetes集群！我们将使用Minikube创建一个本地单节点集群。Minikube可以使用不同的驱动程序部署在VM、容器或裸金属上。我们将使用首选驱动程序之一，即Docker驱动程序，其中Minikube实例在macOS和Windows上的Docker
    Desktop管理的容器中运行，并使用**Windows Subsystem for Linux, v2** (WSL 2)。
- en: For information on the available drivers in Minikube, see [https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Minikube中可用驱动程序的更多信息，请参阅[https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/)。
- en: Docker and its containers are already running in a separate WSL 2 instance;
    see the *Installing Docker Desktop for Windows* section in *Chapter 22*, *Installation
    Instructions for Microsoft Windows with WSL 2 and Ubuntu*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker及其容器已经在单独的WSL 2实例中运行；请参阅*第22章，*安装Microsoft Windows的WSL 2和Ubuntu的安装说明*中的*安装Docker
    Desktop for Windows*部分。
- en: One drawback of running Minikube as a container on Docker is that ports exposed
    by Minikube are only accessible on the host that runs Docker. To make the ports
    available to Docker clients, for example, macOS or the Linux server we will use
    on WSL 2, we can specify port mappings when creating the Minikube cluster.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Minikube 作为容器在 Docker 上运行的一个缺点是，Minikube 暴露的端口只能在运行 Docker 的主机上访问。为了使端口对 Docker
    客户端可用，例如，在 WSL 2 上我们将使用的 macOS 或 Linux 服务器，我们可以在创建 Minikube 集群时指定端口映射。
- en: Before creating the Kubernetes cluster, we need to learn a bit about Minikube
    profiles, the Kubernetes CLI tool known as `kubectl`, and its use of contexts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Kubernetes 集群之前，我们需要了解一下 Minikube 配置文件，这是 Kubernetes 的 CLI 工具 `kubectl`
    的相关知识，以及它对上下文的使用。
- en: Working with Minikube profiles
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Minikube 配置文件
- en: 'In order to run multiple Kubernetes clusters locally, Minikube comes with the
    concept of **profiles**. For example, if you want to work with multiple versions
    of Kubernetes, you can create multiple Kubernetes clusters using Minikube. Each
    cluster will be assigned a separate Minikube profile. Most of the Minikube commands
    accept a `--profile` flag (or `-p` for short), which can be used to specify which
    of the Kubernetes clusters the command will be applied to. If you plan to work
    with one specific profile for a while, a more convenient alternative exists, where
    you specify the current profile with the following command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地运行多个 Kubernetes 集群，Minikube 提供了**配置文件**的概念。例如，如果您想使用多个 Kubernetes 版本，您可以使用
    Minikube 创建多个 Kubernetes 集群。每个集群都将分配一个单独的 Minikube 配置文件。大多数 Minikube 命令都接受 `--profile`
    标志（或 `-p` 的简称），可以用来指定命令将应用于哪个 Kubernetes 集群。如果您计划在一段时间内使用一个特定的配置文件，存在一个更方便的替代方案，其中您可以使用以下命令指定当前配置文件：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will set the `my-profile` profile as the current profile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将 `my-profile` 配置文件设置为当前配置文件。
- en: 'To get the current profile, run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前配置文件，请运行以下命令：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If no profile is specified, either using the `minikube profile` command or the
    `--profile` switch, a default profile named `minikube` will be used.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定配置文件，无论是使用 `minikube profile` 命令还是 `--profile` 开关，都将使用默认配置文件 `minikube`。
- en: Information regarding existing profiles can be found with the command `minikube
    profile` `list`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `minikube profile list` 命令找到有关现有配置文件的信息。
- en: Working with the Kubernetes CLI, kubectl
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI，kubectl
- en: '`kubectl` is the Kubernetes CLI tool. Once a cluster has been set up, this
    is usually the only tool you need to manage the cluster!'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是 Kubernetes 的 CLI 工具。一旦集群已设置，这通常是您唯一需要的用于管理集群的工具！'
- en: For managing the API objects, as we described earlier in this chapter, the `kubectl`
    `apply` command is the only command you need to know about. It is a **declarative
    command**; that is, as an operator, we ask Kubernetes to apply the object definition
    we give to the command. It is then up to Kubernetes to figure out what actually
    needs to be done.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理 API 对象，正如我们在本章前面所描述的，`kubectl apply` 命令是您唯一需要了解的命令。它是一个**声明性命令**；也就是说，作为操作员，我们要求
    Kubernetes 应用我们通过命令给出的对象定义。然后由 Kubernetes 决定实际上需要做什么。
- en: Another example of a declarative command that’s hopefully familiar to many readers
    of this book is a `SQL SELECT` statement, which can join information from several
    database tables. We only declare the expected result in the SQL query, and it
    is up to the database query optimizer to figure out in what order the tables should
    be accessed and what indexes to use to retrieve the data in the most efficient
    way.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能是许多本书读者的熟悉声明性命令的例子是 `SQL SELECT` 语句，它可以连接来自多个数据库表的信息。我们在 SQL 查询中只声明预期的结果，而数据库查询优化器则需要确定以何种顺序访问表以及使用哪些索引以最有效的方式检索数据。
- en: In some cases, **imperative statements** that explicitly tell Kubernetes what
    to do are preferred. One example is the `kubectl delete` command, where we explicitly
    tell Kubernetes to delete some API objects. Creating a namespace object can also
    be conveniently done with an explicit `kubectl create namespace` command.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，**命令式语句**更受欢迎，这些语句明确告诉 Kubernetes 要做什么。一个例子是 `kubectl delete` 命令，其中我们明确告诉
    Kubernetes 删除一些 API 对象。也可以使用明确的 `kubectl create namespace` 命令方便地创建命名空间对象。
- en: Repetitive usage of the imperative statements will make them fail, for example,
    deleting the same API object twice using `kubectl delete` or creating the same
    namespace twice using `kubectl create`. A declarative command, that is, using
    `kubectl apply`, will not fail with repetitive usage – it will simply state that
    there is no change and exit without taking any action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用祈使语句会导致它们失败，例如，使用 `kubectl delete` 删除相同的 API 对象两次或使用 `kubectl create` 创建相同的命名空间两次。声明式命令，即使用
    `kubectl apply`，不会因重复使用而失败——它将简单地声明没有变化并退出而不采取任何行动。
- en: 'Some commonly used commands for retrieving information about a Kubernetes cluster
    are as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于检索 Kubernetes 集群信息的常用命令：
- en: '`kubectl get` shows information about the specified API object'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl get` 显示指定 API 对象的信息'
- en: '`kubectl describe` gives more detail about the specified API object'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe` 提供有关指定 API 对象的更多详细信息'
- en: '`kubectl logs` displays log output from containers'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl logs` 显示容器的日志输出'
- en: We will see a lot of examples of these and other `kubectl` commands in this
    and the upcoming chapters!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章节和接下来的章节中看到许多这些以及其他 `kubectl` 命令的示例！
- en: 'If in doubt about how to use the `kubectl` tool, the `kubectl help` and `kubectl`
    `<command> --help` commands are always available and provide very useful information.
    Another helpful command is `kubectl explain`, which can be used to show what fields
    are available when declaring a Kubernetes object. For example, run the following
    command if you need to look up the fields available to describe a container in
    the template of a Deployment object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对如何使用 `kubectl` 工具有疑问，`kubectl help` 和 `kubectl <command> --help` 命令始终可用，并提供非常有用的信息。另一个有用的命令是
    `kubectl explain`，它可以用来显示在声明 Kubernetes 对象时有哪些字段可用。例如，如果你需要查找描述 Deployment 对象模板中容器可用的字段，请运行以下命令：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Working with kubectl contexts
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl 上下文
- en: 'To be able to work with more than one Kubernetes cluster, using either Minikube
    locally or Kubernetes clusters set up on on-premises servers or in the cloud,
    `kubectl` comes with the concept of **contexts**. A context is a combination of
    the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够与多个 Kubernetes 集群一起工作，无论是使用本地的 Minikube 还是设置在本地服务器或云中的 Kubernetes 集群，`kubectl`
    都包含 **上下文** 的概念。上下文是以下内容的组合：
- en: A Kubernetes cluster
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群
- en: Authentication information for a user
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户认证信息
- en: A default namespace
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认命名空间
- en: By default, contexts are saved in the `~/.kube/config` file, but the file can
    be changed using the `KUBECONFIG` environment variable. In this book, we will
    use the default location, so we will unset `KUBECONFIG` using the `unset KUBECONFIG`
    command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，上下文保存在 `~/.kube/config` 文件中，但可以使用 `KUBECONFIG` 环境变量更改该文件。在这本书中，我们将使用默认位置，因此我们将使用
    `unset KUBECONFIG` 命令取消设置 `KUBECONFIG`。
- en: When a Kubernetes cluster is created in Minikube, a context is created with
    the same name as the Minikube profile and is then set as the current context.
    So, `kubectl` commands that are issued after the cluster is created in Minikube
    will be sent to that cluster.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Minikube 中创建 Kubernetes 集群时，会创建一个与 Minikube 配置文件同名上下文，并将其设置为当前上下文。因此，在 Minikube
    中创建集群后发出的 `kubectl` 命令将发送到该集群。
- en: 'To list the available contexts, run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的上下文，请运行以下命令：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is a sample response:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_15_03.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，应用程序描述自动生成](img/B19825_15_03.png)'
- en: 'Figure 15.3: List of kubectl contexts'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3：kubectl 上下文列表
- en: The wildcard, *****, in the first column marks the current context.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列中的通配符 ***** 标记了当前上下文。
- en: You will only see the `handson-spring-boot-cloud` context in the preceding response
    once the cluster has been created, the process for which we will describe shortly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在集群创建完成后，你才会在前面的响应中看到 `handson-spring-boot-cloud` 上下文，我们将在稍后描述其创建过程。
- en: 'If you want to switch the current context to another context, that is, work
    with another Kubernetes cluster, run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将当前上下文切换到另一个上下文，即与另一个 Kubernetes 集群一起工作，请运行以下命令：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the current context will be changed to `my-cluster`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，当前上下文将更改为 `my-cluster`。
- en: To update a context, for example, switching the default namespace used by `kubectl`,
    use the `kubectl config set-context` command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新上下文，例如，切换 `kubectl` 使用的默认命名空间，请使用 `kubectl config set-context` 命令。
- en: 'For example, to change the default namespace of the current context to `my-namespace`,
    use the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将当前上下文的默认命名空间更改为 `my-namespace`，请使用以下命令：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this command, `kubectl config current-context` is used to get the name of
    the current context.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，`kubectl config current-context` 用于获取当前上下文名称。
- en: Creating a Kubernetes cluster
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 集群
- en: 'To create a Kubernetes cluster using Minikube, we need to run a few commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Minikube 创建 Kubernetes 集群，我们需要运行几个命令：
- en: Unset the `KUBECONFIG` environment variable to ensure that the `kubectl` context
    is created in the default config file, `~/.kube/config`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消设置 `KUBECONFIG` 环境变量，以确保 `kubectl` 上下文在默认配置文件 `~/.kube/config` 中创建。
- en: 'Create the cluster using the `minikube start` command, where we can also specify
    what version of Kubernetes to use and the amount of hardware resources we want
    to allocate to the cluster:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `minikube start` 命令创建集群，我们也可以指定要使用的 Kubernetes 版本以及要分配给集群的硬件资源量：
- en: To be able to complete the examples in the remaining chapters of this book,
    allocate 10 GB of memory, that is, 10,240 MB, to the cluster. The samples should
    also work if only 6 GB (6,144 MB) is allocated to the Minikube cluster, albeit
    more slowly.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够完成本书剩余章节中的示例，请为集群分配 10 GB 的内存，即 10,240 MB。如果只分配 6 GB（6,144 MB）给 Minikube
    集群，尽管速度较慢，这些示例也应该能正常工作。
- en: Allocate the number of CPU cores and disk space you find suitable; 4 CPU cores
    and 30 GB of disk space are used in the following example.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配您认为合适的 CPU 核心和磁盘空间；以下示例中使用了 4 个 CPU 核心和 30 GB 的磁盘空间。
- en: Specify what version of Kubernetes will be used. In this book, we will use v1.26.1.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定将使用哪个版本的 Kubernetes。在本书中，我们将使用 v1.26.1。
- en: Specify that we will use the Docker driver as described above.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定我们将使用上面描述的 Docker 驱动程序。
- en: Specify the required port mappings. The ports `8080` and `8443` will be used
    by the Ingress controller, and the ports `30080` and `30443` will be used by Services
    of type `NodePort`.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定所需的端口映射。端口 `8080` 和 `8443` 将由 Ingress 控制器使用，而端口 `30080` 和 `30443` 将由类型为 `NodePort`
    的服务使用。
- en: See *Chapter 16**, Deploying Our Microservices to Kubernetes,* for information
    on how the Gateway server deploys a Service of type `NodePort`.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关网关服务器如何部署类型为 `NodePort` 的服务的详细信息，请参阅*第 16 章*，将我们的微服务部署到 Kubernetes。
- en: Specify the Minikube profile to be used for the coming `minikube` commands.
    We will use `handson-spring-boot-cloud` as the profile name.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定用于即将到来的 `minikube` 命令的 Minikube 配置文件。我们将使用 `handson-spring-boot-cloud` 作为配置文件名称。
- en: After the cluster has been created, we will use the add-on manager in Minikube
    to enable an Ingress controller and a metrics server that comes out of the box
    with Minikube. The Ingress controller and the metrics server will be used in the
    next chapters.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集群创建后，我们将使用 Minikube 中的插件管理器来启用 Minikube 自带的 Ingress 控制器和度量服务器。Ingress 控制器和度量服务器将在下一章中使用。
- en: 'Run the following commands to create the Kubernetes cluster:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以创建 Kubernetes 集群：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the preceding commands complete, you should be able to communicate with
    the cluster. Try the `kubectl get nodes` command. It should respond with something
    that looks similar to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令完成后，您应该能够与集群通信。尝试运行 `kubectl get nodes` 命令。它应该响应类似于以下内容：
- en: '![Graphical user interface  Description automatically generated](img/B19825_15_04.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，描述自动生成](img/B19825_15_04.png)'
- en: 'Figure 15.4: List of nodes in the Kubernetes cluster'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4：Kubernetes 集群中的节点列表
- en: 'Once created, the cluster will initialize itself in the background, starting
    up a number of system Pods in the `kube-system` and the `ingress-nginx` namespace.
    We can monitor its progress by issuing the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，集群将在后台初始化自身，启动 `kube-system` 和 `ingress-nginx` 命名空间中的多个系统 Pods。我们可以通过以下命令来监控其进度：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the startup is complete, the preceding command should report the status
    for all Pods as **Running** and the **READY** count should be **1/1**, meaning
    that a single container in each Pod is up and running:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动完成，前面的命令应该报告所有 Pods 的状态为 **运行中**，并且 **READY** 计数应为 **1/1**，这意味着每个 Pod 中的单个容器都已启动并运行：
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_15_05.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，描述自动生成](img/B19825_15_05.png)'
- en: 'Figure 15.5: List of running system Pods'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5：运行中的系统 Pods 列表
- en: Note that two Pods are reported as **Completed**, and not **Running**. They
    are Pods created by **Job** objects, used to execute a container a fixed number
    of times like a batch job. Run the command `kubectl get jobs --namespace=ingress-nginx`
    to reveal the two Job objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个Pod报告为**Completed**，而不是**Running**。它们是由**Job**对象创建的Pod，用于执行容器固定次数，就像批处理作业一样。运行命令`kubectl
    get jobs --namespace=ingress-nginx`以揭示这两个Job对象。
- en: We are now ready for some action!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好采取一些行动了！
- en: Trying out a sample Deployment
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一个示例Deployment
- en: 'Let’s see how we can do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到以下：
- en: Deploy a simple web server based on NGINX in our Kubernetes cluster
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Kubernetes集群中部署基于NGINX的简单Web服务器
- en: 'Apply some changes to the Deployment:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Deployment应用一些更改：
- en: Change the current state by deleting the Pod and verify that the `ReplicaSet`
    creates a new one
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过删除Pod来更改当前状态，并验证`ReplicaSet`创建了一个新的Pod
- en: Change the desired state by scaling the web server to three Pods and verify
    that the `ReplicaSet` fills the gap by starting up two new Pods
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将Web服务器扩展到三个Pod来更改所需状态，并验证`ReplicaSet`通过启动两个新的Pod来填补空缺
- en: Route external traffic to the web server using a Service with a node port
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有节点端口的Service将外部流量路由到Web服务器
- en: 'First, create a namespace, `first-attempts`, and update the `kubectl` context
    to use this namespace by default:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个命名空间`first-attempts`，并更新`kubectl`上下文以默认使用此命名空间：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now create a Deployment of NGINX in the namespace using the `kubernetes/first-attempts/nginx-deployment.yaml`
    file. This file looks as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`kubernetes/first-attempts/nginx-deployment.yaml`文件在命名空间中创建一个NGINX Deployment。此文件如下所示：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s explain this source code in more detail:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释这段源代码：
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a Deployment object.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个Deployment对象。'
- en: The `metadata` section is used to describe the Deployment object. For example,
    we give it the name `nginx-deploy`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述Deployment对象。例如，我们给它命名为`nginx-deploy`。'
- en: Other commonly used metadata for a Kubernetes object includes the name of the
    `namespace` it belongs to, `label`s, and `annotation`s. We will see them used
    in this chapter and the following chapters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对象常用的其他元数据包括它所属的`namespace`名称、`label`s和`annotation`s。我们将在本章和下一章中看到它们的使用。
- en: 'Next comes a `spec` section that defines our desired state for the Deployment
    object:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个定义Deployment对象的期望状态的`spec`部分：
- en: '`replicas: 1` specifies we want to have one Pod up and running.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas: 1`指定我们希望有一个Pod运行。'
- en: A `selector` section that specifies how the Deployment will find the Pods it
    manages. In this case, the Deployment will look for Pods that have the `app` label
    set to `nginx-app`.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定Deployment如何找到它管理的Pods的`selector`部分。在这种情况下，Deployment将寻找将`app`标签设置为`nginx-app`的Pods。
- en: The `template` section is used to specify how Pods will be created.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`部分用于指定Pod的创建方式。'
- en: 'The `metadata` section specifies the `label`, `app: nginx-app`, which is used
    to identify the Pods, thereby matching the selector.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分指定了用于识别Pods的`label`，即`app: nginx-app`，从而匹配选择器。'
- en: The `spec` section specifies details for the creation of the single container
    in the Pod, that is, `name`, `image`, and what `ports` it uses.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`部分指定了Pod中单个容器创建的详细信息，即`name`、`image`以及它使用的`ports`。'
- en: 'Create the Deployment with the following commands:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建Deployment：
- en: '[PRE10]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s see what we got with the `kubectl get all` command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`kubectl get all`命令我们得到了什么：
- en: '![Text  Description automatically generated](img/B19825_15_06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_15_06.png)'
- en: 'Figure 15.6: Kubernetes objects created by the sample deployment'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：由示例Deployment创建的Kubernetes对象
- en: As expected, we got a Deployment, ReplicaSet, and Pod object. After a short
    while, which mainly depends on the time it takes to download the NGINX Docker
    image, the Pod will be up and running, reported as **1/1** in the **READY** column,
    meaning that the desired state is equal to the current state!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，我们得到了一个Deployment、ReplicaSet和Pod对象。经过一段时间后，这主要取决于下载NGINX Docker镜像所需的时间，Pod将启动并运行，在**READY**列中报告为**1/1**，这意味着所需状态等于当前状态！
- en: 'Now, we will change the current state by deleting the Pod. Before deleting
    the Pod, run the command `kubectl get pod --watch` in another terminal. The use
    of the `--watch` option makes the command hang, waiting for state changes of Pods
    in the current namespace. Delete the Pod using the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过删除Pod来更改当前状态。在删除Pod之前，在另一个终端中运行命令`kubectl get pod --watch`。使用`--watch`选项使命令挂起，等待当前命名空间中Pod的状态变化。使用以下命令删除Pod：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the Pod has a random name (`nginx-deploy-59b8c5f7cd-mt6pg` in the preceding
    example), the Pod is selected based on the `app` label, which is set to `nginx-app`
    in the Pod.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pod有一个随机名称（在前面的例子中是`nginx-deploy-59b8c5f7cd-mt6pg`），Pod是根据`app`标签选择的，该标签在Pod中设置为`nginx-app`。
- en: Note how `kubectl get pod --watch` reports how the current Pod is terminated
    and at the same time a new Pod is started up.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`kubectl get pod --watch`如何报告当前Pod的终止，同时启动一个新的Pod。
- en: 'It is the ReplicaSet that detects the difference between the desired and current
    state and almost immediately starts up a new Pod to compensate for the deviation.
    The reported events should look like the following screenshot:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 是ReplicaSet检测到期望状态和当前状态之间的差异，并且几乎立即启动一个新的Pod来补偿偏差。报告的事件应类似于以下截图：
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B19825_15_07.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图，描述由低置信度自动生成](img/B19825_15_07.png)'
- en: 'Figure 15.7: kubectl get pod --watch reporting changes to the Pods'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：kubectl get pod --watch报告Pod的变化
- en: In the screenshot, we can see that the Pod with a name ending with `d69ln` was
    stopped by the `delete` command and that the ReplicaSet immediately started up
    a new Pod with a name ending with `ptbkf`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图上，我们可以看到以`d69ln`结尾的Pod被`delete`命令停止了，并且ReplicaSet立即启动了一个以`ptbkf`结尾的新Pod。
- en: Change the desired state by setting the number of desired Pods to three replicas
    in the `kubernetes/first-attempts/nginx-deployment.yaml` Deployment file. Apply
    the change in the desired state by simply repeating the `kubectl apply` command,
    as we mentioned previously.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`kubernetes/first-attempts/nginx-deployment.yaml` Deployment文件中将期望的Pod数量设置为三个副本来更改期望状态。通过简单地重复我们之前提到的`kubectl
    apply`命令来应用期望状态的变化。
- en: Again, note that the `kubectl get pod --watch` command reports new Pods being
    launched by the ReplicaSet to get the current state equivalent to the new desired
    state, that is, three Pods. After a few seconds, two new NGINX Pods will be reported
    as up and running. Stop the command with *Ctrl + C*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，`kubectl get pod --watch`命令报告ReplicaSet启动的新Pod以获取当前状态等效于新的期望状态，即三个Pod。几秒钟后，将报告两个新的NGINX
    Pod已启动并运行。使用*Ctrl + C*停止命令。
- en: 'Run the `kubectl get all` command and expect a response that looks similar
    to the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`kubectl get all`命令，并期待得到以下类似的响应：
- en: '![Text  Description automatically generated](img/B19825_15_08.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述由低置信度自动生成](img/B19825_15_08.png)'
- en: 'Figure 15.8: New Pods started up by Kubernetes to meet the desired state'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：Kubernetes启动的新Pod以满足期望状态
- en: Note the three Pods and that the Deployment object reports **3/3**. This is
    interpreted as 3 ready and 3 desired Pods, meaning that all desired Pods are ready
    to be used.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意有三个Pod，并且Deployment对象报告**3/3**。这表示有3个就绪的和3个期望的Pod，意味着所有期望的Pod都准备好使用。
- en: 'To enable external communication with the web servers, create a Service using
    the `kubernetes/first-attempts/nginx-service.yaml` file. It looks like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用与Web服务的外部通信，使用`kubernetes/first-attempts/nginx-service.yaml`文件创建一个服务。它看起来如下：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a `Service` object.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个`Service`对象。'
- en: 'The `metadata` section is used to describe the `Service` object, for example,
    to give it a name: `nginx-service`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述`Service`对象，例如，给它一个名称：`nginx-service`。'
- en: 'Next comes a `spec` section, which defines the desired state of the `Service`
    object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`spec`部分，它定义了`Service`对象的期望状态：
- en: With the `type` field, we specify that we want `NodePort`, that is, a Service
    that is accessible externally on a dedicated port on each node in the cluster.
    This means that an external caller can reach the Pods behind this Service using
    this port on any of the nodes in the cluster, independent of which nodes the Pods
    actually run on.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type`字段，我们指定我们想要`NodePort`，即一个在集群中每个节点上具有专用端口的可外部访问的服务。这意味着外部调用者可以通过集群中任何节点的此端口访问此服务背后的Pod，而不论Pod实际运行在哪些节点上。
- en: 'The selector is used by the Service to find available Pods, which, in our case,
    are Pods labeled with `app: nginx-app`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择器由Service用于查找可用的Pods，在我们的案例中，是标记为`app: nginx-app`的Pods。'
- en: 'Finally, `ports` are declared as follows:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ports`声明如下：
- en: '`port: 80` specifies which port the Service will be accessible on, that is,
    internally in the cluster.'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port: 80`指定了Service将在哪个端口上可访问，即在集群内部。'
- en: '`targetPort: 80` specifies the port in the Pod where the requests will be forwarded
    to.'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort: 80`指定了请求将被转发到的Pod中的端口。'
- en: '`nodePort: 30080` specifies which port the Service will be externally accessible
    on using any of the nodes in the cluster. By default, a node port must be in the
    range of `30000` to `32767`.'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodePort: 30080`指定了Service将通过集群中的任何节点在哪个端口上对外部可访问。默认情况下，节点端口必须在`30000`到`32767`的范围内。'
- en: This port range is used to minimize the risk of colliding with other ports in
    use. In a production system, a load balancer is typically placed in front of the
    Kubernetes cluster, shielding the external users both from the knowledge of these
    ports and the IP numbers of the nodes in the Kubernetes cluster. See *Chapter
    18*, *Using a Service Mesh to Improve Observability and Management*, specifically
    the *Setting up access to Istio Services* section, for more on the usage of a
    `LoadBalanced` Kubernetes Service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此端口范围用于最小化与其他正在使用的端口的冲突风险。在生产系统中，通常在Kubernetes集群前面放置一个负载均衡器，以保护外部用户免受这些端口的了解以及Kubernetes集群中节点的IP地址。有关使用`LoadBalanced`
    Kubernetes Service的更多信息，请参阅*第18章*，*使用服务网格来提高可观察性和管理*，特别是*设置对Istio服务的访问*部分。
- en: 'Create the Service with the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建Service：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To see what we got, run the `kubectl get svc` command. Expect a response like
    the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们得到的结果，请运行`kubectl get svc`命令。预期会收到以下类似响应：
- en: '![Graphical user interface  Description automatically generated](img/B19825_15_09.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，自动生成描述](img/B19825_15_09.png)'
- en: 'Figure 15.9: NodePort Service for our Deployment'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：我们的部署的NodePort服务
- en: '`kubectl` supports short names for many of the API objects as an alternative
    to their full name. For example, `svc` was used in the preceding command instead
    of the full name, `service`. Run the command `kubectl api-resources` to see all
    available short names.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`支持许多API对象的短名称，作为其全名称的替代。例如，在前面命令中使用的是`svc`，而不是全称`service`。运行`kubectl
    api-resources`命令以查看所有可用的短名称。'
- en: To access the web server through the Service’s node port, we need to know the
    IP address or hostname of the single node in our cluster. When using the Docker
    driver, the hostname is always `localhost`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过Service的节点端口访问Web服务器，我们需要知道我们集群中单个节点的IP地址或主机名。当使用Docker驱动时，主机名始终是`localhost`。
- en: The node port, `30080`, is forwarded from Docker Engine by the `–ports` option
    in the `minikube start` command. See the *Creating a Kubernetes cluster* section
    above for details. This means that the `Service` can be reached at the address
    `localhost:30080`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 节点端口`30080`通过`minikube start`命令中的`–ports`选项由Docker Engine转发。有关详细信息，请参阅上面的*创建Kubernetes集群*部分。这意味着`Service`可以通过地址`localhost:30080`访问。
- en: Ports opened in a WSL 2 instance are accessible in Windows on `localhost`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在WSL 2实例中打开的端口在Windows上可通过`localhost`访问。
- en: 'With this information, we can direct a web browser on macOS and Windows to
    the deployed web server using the address `http://localhost:30080`. Expect a response
    such as the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们可以将macOS和Windows上的网络浏览器指向部署的Web服务器，使用地址`http://localhost:30080`。预期会收到以下类似响应：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19825_15_10.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B19825_15_10.png)'
- en: 'Figure 15.10: NGINX default web page'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：NGINX默认网页
- en: Great! But what about the internal cluster IP address and port?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！但关于内部集群IP地址和端口怎么办？
- en: One way to verify that the web server is also reachable internally in the cluster
    is to launch a small Pod that we can use to run `curl` from the inside. The `curl`
    command will use the internal cluster IP address and port. We don’t need to use
    the internal IP address; instead, we can use a DNS name that is created for the
    Service in the internal DNS server. The short name of the DNS name is the same
    as the name of the Service, that is, `nginx-service`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 验证Web服务器是否也可以在集群内部访问的一种方法是通过启动一个小Pod，我们可以使用它从内部运行`curl`命令。`curl`命令将使用内部集群IP地址和端口。我们不需要使用内部IP地址；相反，我们可以使用为Service在内部DNS服务器中创建的DNS名称。DNS名称的简称与Service的名称相同，即`nginx-service`。
- en: The full DNS name of a Service is `<service-name>.<namespace>.svc.cluster.local`.
    The full name for this Service is `nginx-service.first-attempts.svc.cluster.local`.
    Since we will run the command below in the same namespace, we can use the short
    name.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的完整 DNS 名称是 `<service-name>.<namespace>.svc.cluster.local`。此服务的完整名称是 `nginx-service.first-attempts.svc.cluster.local`。由于我们将在相同的命名空间中运行以下命令，我们可以使用简短名称。
- en: 'Run the following command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The command looks a bit complex, but it will do the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 命令看起来有点复杂，但它将执行以下操作：
- en: Create a Pod with a small container based on the Docker image `curlimages/curl`,
    which contains the `curl` command.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于 Docker 镜像 `curlimages/curl` 的 Pod，该镜像包含 `curl` 命令。
- en: Run the `curl -s 'http://nginx-service:80'` command inside the container and
    redirect the output to the Terminal using the `-i` option.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行 `curl -s 'http://nginx-service:80'` 命令，并使用 `-i` 选项将输出重定向到终端。
- en: Delete the Pod using the `--rm` option.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `--rm` 选项删除 Pod。
- en: 'Expect the output from the preceding command to contain the following information
    (we are only showing parts of the response here):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 预期上一条命令的输出将包含以下信息（我们在这里只显示响应的部分）：
- en: '![Text  Description automatically generated](img/B19825_15_11.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B19825_15_11.png)'
- en: 'Figure 15.11: Accessing NGINX inside the Kubernetes cluster'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11：访问 Kubernetes 集群内的 NGINX
- en: This means that the web server is also accessible internally in the cluster!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Web 服务器也可以在集群内部访问！
- en: This is basically all we need to know to be able to deploy our system landscape.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们需要了解的所有内容，以便能够部署我们的系统景观。
- en: 'Wrap this up by removing the namespace containing the `nginx` Deployment:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除包含 `nginx` 部署的命名空间来结束这一切：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we end this introductory chapter on Kubernetes, we need to learn how
    to manage our Kubernetes cluster.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束关于 Kubernetes 的这一章介绍之前，我们需要学习如何管理我们的 Kubernetes 集群。
- en: Managing a local Kubernetes cluster
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理本地 Kubernetes 集群
- en: A running Kubernetes cluster consumes a lot of resources, mostly memory. So,
    when we are done working with a Kubernetes cluster in Minikube, we must be able
    to hibernate it in order to release the resources allocated to it. We also need
    to know how to resume the cluster when we want to continue working with it. Eventually,
    we must also be able to permanently remove the cluster when we don’t want to keep
    it on disk anymore.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的 Kubernetes 集群消耗大量资源，主要是内存。因此，当我们完成在 Minikube 中与 Kubernetes 集群的工作后，我们必须能够将其休眠以释放分配给它的资源。我们还需要知道如何在想要继续工作时恢复集群。最终，我们还需要能够永久删除集群，当我们不再希望将其保留在磁盘上时。
- en: Minikube comes with a `stop` command that can be used to hibernate a Kubernetes
    cluster. The `start` command we used to initially create the Kubernetes cluster
    can also be used to resume the cluster from its hibernated state. To permanently
    remove a cluster, we can use the `delete` command from Minikube.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 随带一个 `stop` 命令，可以用来休眠 Kubernetes 集群。我们用来最初创建 Kubernetes 集群的 `start`
    命令也可以用来从休眠状态恢复集群。要永久删除集群，我们可以使用 Minikube 的 `delete` 命令。
- en: Hibernating and resuming a Kubernetes cluster
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 休眠和恢复 Kubernetes 集群
- en: 'Run the following command to hibernate (that is, `stop`) the Kubernetes cluster:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来休眠（即 `stop`）Kubernetes 集群：
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following command to resume (that is, `start`) the Kubernetes cluster
    again:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令再次恢复（即 `start`）Kubernetes 集群：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `kubectl` commands directly after restarting the cluster might result
    in error messages like:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在重启集群后直接运行 `kubectl` 命令可能会导致错误信息，例如：
- en: '[PRE18]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is due to the `metrics-server` being a bit slow on starting up; the error
    message will disappear after a short while.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `metrics-server` 在启动时有点慢；错误信息会在一段时间后消失。
- en: When resuming an already existing cluster, the `start` command ignores switches
    that were used when you were creating the cluster.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当恢复一个已经存在的集群时，`start` 命令会忽略你在创建集群时使用的开关。
- en: 'After resuming the Kubernetes cluster, the `kubectl` context will be updated
    to use this cluster with the currently used namespace set to `default`. If you
    are working with another namespace, for example, the `hands-on` namespace that
    we will use in the upcoming chapter, *Chapter 16*, *Deploying Our Microservices
    to Kubernetes*, you can update the `kubectl` context with the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复 Kubernetes 集群后，`kubectl` 上下文将更新为使用此集群，当前使用的命名空间设置为 `default`。如果你正在使用另一个命名空间，例如，我们将在下一章“第
    16 章，将我们的微服务部署到 Kubernetes”中使用的 `hands-on` 命名空间，你可以使用以下命令更新 `kubectl` 上下文：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Subsequent `kubectl` commands will be applied to the `hands-on` namespace when
    applicable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的 `kubectl` 命令将在适用的情况下应用于 `hands-on` 命名空间。
- en: 'Minikube also comes with a more lightweight and faster alternative to the `stop`
    and `start` commands: the `pause` and `unpause` commands. In this case, the components
    in the control plane are paused, not stopped, reducing the CPU consumption of
    the cluster to a minimum. I have, however, seen issues with these commands when
    used in the recent chapters, so I recommend using the `start` and `stop` commands.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 还提供了一种比 `stop` 和 `start` 命令更轻量级和更快的替代方案：`pause` 和 `unpause` 命令。在这种情况下，控制平面的组件被暂停，而不是停止，将集群的
    CPU 消耗降至最低。然而，我在最近章节中使用这些命令时遇到了问题，因此我建议使用 `start` 和 `stop` 命令。
- en: Terminating a Kubernetes cluster
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止 Kubernetes 集群
- en: 'If you later want to terminate the Kubernetes cluster, you can run the following
    command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您稍后想终止 Kubernetes 集群，您可以运行以下命令：
- en: '[PRE20]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can actually run the `delete` command without specifying the profile, but
    I find it safer to be explicit about the profile. Otherwise, you may accidentally
    delete the wrong Kubernetes cluster!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以在不指定配置文件的情况下运行 `delete` 命令，但我发现明确指定配置文件更安全。否则，您可能会意外删除错误的 Kubernetes
    集群！
- en: We’ve successfully learned how to manage a Kubernetes cluster that runs in Minikube.
    We now know how to suspend and resume a cluster and, when no longer needed, we
    know how to permanently remove it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何管理在 Minikube 中运行的 Kubernetes 集群。现在我们知道如何挂起和恢复集群，以及当不再需要时，如何永久删除它。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to Kubernetes as a container orchestrator.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Kubernetes 作为容器编排器。
- en: Using Kubernetes, we can handle a cluster of servers as one big logical server
    that runs our containers. We declare a desired state for the Kubernetes cluster,
    and it ensures that the actual state is the same as the desired state at all times,
    provided that enough hardware resources are available in the cluster.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes，我们可以将服务器集群作为一个大型的逻辑服务器来处理，该服务器运行我们的容器。我们为 Kubernetes 集群声明一个所需状态，并且它确保只要集群中有足够的硬件资源，实际状态始终与所需状态相同。
- en: The desired state is declared by creating resources using the Kubernetes API
    server. The controller manager in Kubernetes and its controllers react to the
    various resources that were created by the API server and take actions to ensure
    that the current state meets the new desired state. The scheduler assigns nodes
    to newly created containers, that is, Pods that contain one or more containers.
    On each node, an agent, a `kubelet`, runs and ensures that the Pods that were
    scheduled to its node are up and running. The `kube-proxy` acts as a network proxy,
    enabling a Service abstraction by forwarding requests that are sent to the Service
    to available Pods in the cluster. External requests can be handled either by a
    Kubernetes-aware load balancer that can provision a public IP address and/or DNS
    name for the Service, a node port that’s available on all of the nodes in the
    cluster, or through a dedicated Ingress resource.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所需状态是通过使用 Kubernetes API 服务器创建资源来声明的。Kubernetes 中的控制器管理器和其控制器会对 API 服务器创建的各种资源做出反应，并采取行动确保当前状态符合新的所需状态。调度器将节点分配给新创建的容器，即包含一个或多个容器的
    Pods。在每个节点上，一个代理，一个 `kubelet` 运行，并确保已调度到其节点的 Pods 正在运行。`kube-proxy` 作为网络代理，通过将发送到服务的请求转发到集群中可用的
    Pods 来实现服务抽象。外部请求可以通过 Kubernetes 感知的负载均衡器来处理，该负载均衡器可以为服务提供公共 IP 地址和/或 DNS 名称，或者通过集群中所有节点上都可用的节点端口，或者通过一个专门的
    Ingress 资源。
- en: We have also tried out Kubernetes by creating a local single-node cluster using
    Minikube. The Minikube cluster runs as a Docker container using the Docker driver.
    To make ports accessible outside of Docker Engine, we can use the `--ports` option
    on the `minikube start` command. Using the Kubernetes CLI tool known as `kubectl`,
    we deployed a simple web server based on NGINX. We tried out resilience capabilities
    by deleting the web server, and we observed it being recreated automatically.
    We learned how to manually scale it by requesting that three Pods run on the web
    server. We created a Service with a node port and verified that we could access
    it both externally and from the inside of the cluster.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过使用 Minikube 创建本地单节点集群来尝试了 Kubernetes。Minikube 集群作为使用 Docker 驱动的 Docker
    容器运行。为了使端口在 Docker 引擎外部可访问，我们可以在 `minikube start` 命令上使用 `--ports` 选项。使用名为 `kubectl`
    的 Kubernetes CLI 工具，我们部署了一个基于 NGINX 的简单 Web 服务器。我们通过删除 Web 服务器来测试其弹性能力，并观察到它被自动重新创建。我们学习了如何通过请求在
    Web 服务器上运行三个 Pod 来手动扩展它。我们创建了一个具有节点端口的 Service，并验证了我们可以从集群外部和内部访问它。
- en: Finally, we learned how to manage a Kubernetes cluster running in Minikube in
    terms of how to hibernate, resume, and terminate the cluster.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何从休眠、恢复和终止集群的角度来管理在 Minikube 中运行的 Kubernetes 集群。
- en: We are now ready to deploy our system landscape from the earlier chapters in
    Kubernetes. Head over to the next chapter to find out how to do this!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好从前面章节中部署我们的系统架构到 Kubernetes 中。前往下一章了解如何进行此操作！
- en: Questions
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What happens if you run the same `kubectl create` command twice?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你两次运行相同的 `kubectl create` 命令会发生什么？
- en: What happens if you run the same `kubectl apply` command twice?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你两次运行相同的 `kubectl apply` 命令会发生什么？
- en: In terms of questions 1 and 2, why do they act differently the second time they
    are run?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在问题 1 和 2 的方面，为什么它们在第二次运行时表现不同？
- en: What is the purpose of a ReplicaSet, and what other resource creates a ReplicaSet?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet 的作用是什么，还有哪些资源可以创建 ReplicaSet？
- en: What is the purpose of `etcd` in a Kubernetes cluster?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中，`etcd` 的作用是什么？
- en: How can a container find out the IP address of another container that runs in
    the same Pod?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何让一个容器找出在同一 Pod 中运行的另一个容器的 IP 地址？
- en: What happens if you create two Deployments with the same name but in different
    namespaces?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你创建两个具有相同名称但位于不同命名空间中的 Deployment 会发生什么？
- en: What configuration of two Services with the same name can make them fail, even
    if they are created in two different namespaces?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个具有相同名称的 Service 的哪种配置会导致它们失败，即使它们是在两个不同的命名空间中创建的？
- en: Join our community on Discord
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
- en: '![](img/QR_Code1849216352344398875.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1849216352344398875.png)'
