- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start to learn about Kubernetes, the most popular and
    widely used container orchestrator at the time of writing this book. Since the
    subjects on container orchestrators in general and Kubernetes itself are too big
    to be covered in one chapter, I will focus on introducing the areas that I have
    found to be the most important in my use of Kubernetes over the last few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes API objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes runtime components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a local Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out a sample Deployment and getting used to the `kubectl` Kubernetes
    CLI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a local Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter15`.
    The source code for the sample Deployment on Kubernetes that will be performed
    in this chapter can be found in the folder `$BOOK_HOME/Chapter15/kubernetes/first-attempts`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At a high level, as a container orchestrator, Kubernetes makes a cluster of
    (physical or virtual) servers that runs containers appear to be one big logical
    server running containers.
  prefs: []
  type: TYPE_NORMAL
- en: As an operator, we declare a **desired state** to the Kubernetes cluster by
    creating objects using the Kubernetes API. Kubernetes continuously compares the
    desired state with the current state. If it detects differences, it takes action
    to ensure that the current state is the same as the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main purposes of a Kubernetes cluster is to deploy and run containers,
    but also to support zero-downtime rolling upgrades using techniques such as green/blue
    and canary Deployments. Kubernetes can schedule containers, that is, **Pods**
    that contain one or more co-located containers, to the available nodes in the
    cluster. To be able to monitor the health of running containers, Kubernetes assumes
    that containers implement a **liveness probe**. If a liveness probe reports an
    unhealthy container, Kubernetes will restart the container. Containers can be
    scaled in the cluster manually or automatically using a horizontal autoscaler.
    To optimize the use of the available hardware resources in a cluster, for example,
    memory and CPU, containers can be configured with **quotas** that specify the
    amount of resources a container needs. On the other hand, limits regarding how
    much a container is allowed to consume can be specified on the Pod or for a group
    of Pods at the **namespace** level. Namespaces will be introduced as we proceed
    through this chapter. This is of extra importance if several teams share a common
    Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Another main purpose of Kubernetes is to provide Service discovery of the running
    Pods and their containers. Kubernetes **Service** objects can be defined for Service
    discovery and will also load-balance incoming requests over the available Pods.
    Service objects can be exposed to the outside of a Kubernetes cluster. However,
    as we will see, an **Ingress** object is, in many cases, better suited to handling
    externally incoming traffic to a group of Services. To help Kubernetes find out
    whether a container is ready to accept incoming requests, a container can implement
    a **readiness probe**.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, a Kubernetes cluster provides one big flat IP network where each
    Pod gets its own IP address and can reach all the other Pods, independent of which
    node they run on. To support multiple network vendors, Kubernetes allows the use
    of network plugins that comply with the **Container Network Interface** (**CNI**)
    specification ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    Pods are not isolated by default; they accept all incoming requests. CNI plugins
    that support the use of network policy definitions can be used to lock down access
    to Pods, for example, only allowing traffic from Pods in the same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: To allow multiple teams to work on the same Kubernetes cluster in a safe way,
    **Role-Based Access Control** (**RBAC**, [https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/))
    can be applied. For example, administrators can be authorized to access resources
    at the cluster level, while the access of team members can be locked down to resources
    that are created in a namespace owned by the teams.
  prefs: []
  type: TYPE_NORMAL
- en: In total, these concepts provide a platform for running containers that is scalable,
    secure, highly available, and resilient.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look a bit further into the API objects that are available in Kubernetes
    and, after that, the runtime components that make up a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes API objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes defines an API that is used to manage different types of *objects*
    or *resources*, as they are also known. Some of the most commonly used types,
    or *kinds*, as referred to in the API, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node**: A node represents a server, virtual or physical, in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod**: A Pod represents the smallest possible deployable component in Kubernetes,
    consisting of one or more co-located containers. The containers share the same
    IP address and port range. This means that containers in the same Pod instance
    can talk to each other over localhost, but need to be aware of potential port
    collisions. Typically, a Pod consists of one container, but there are use cases
    for extending the functionality of the main container by running the second container
    in a Pod. In *Chapter 18*, *Using a Service Mesh to Improve Observability and
    Management*, a second container will be used in the Pods, running a sidecar that
    makes the main container join the Service mesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment**: A Deployment is used to deploy and upgrade Pods. The Deployment
    objects hand over the responsibility of creating and monitoring the Pods to a
    ReplicaSet. When creating a Deployment for the first time, the work performed
    by the Deployment object is not much more than creating the ReplicaSet object.
    When performing a rolling upgrade of a Deployment, the role of the Deployment
    object is more involved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ReplicaSet**: A ReplicaSet is used to ensure that a specified number of Pods
    is running at all times. If a Pod is deleted, it will be replaced with a new Pod
    by the ReplicaSet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service**: A Service is a stable network endpoint that you can use to connect
    to one or multiple Pods. A Service is assigned an IP address and a DNS name in
    the internal network of the Kubernetes cluster. The IP address of the Service
    will stay the same for the lifetime of the Service. Requests that are sent to
    a Service will be forwarded to one of the available Pods using round-robin-based
    load balancing. By default, a Service is only exposed inside the cluster using
    a cluster IP address. It is also possible to expose a Service outside the cluster,
    either on a dedicated port on each node in the cluster or – even better – through
    an external load balancer that is aware of Kubernetes; that is, it can automatically
    provision a public IP address and/or DNS name for the Service. Cloud providers
    that offer Kubernetes as a Service, in general, support this type of load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress**: Ingress can manage external access to Services in a Kubernetes
    cluster, typically using HTTP or HTTPS. For example, it can route traffic to the
    underlying Services based on URL paths or HTTP headers such as the hostname. Instead
    of exposing a number of Services externally, either using node ports or through
    load balancers, it is, in general, more convenient to set up an Ingress in front
    of the Services. To handle the actual communication defined by the Ingress objects,
    an Ingress controller must be running in the cluster. We will see an example of
    an Ingress controller as we proceed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespace**: A namespace is used to group and, on some levels, isolate resources
    in a Kubernetes cluster. The names of resources must be unique in their namespaces,
    but not between namespaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigMap**: A ConfigMap is used to store configuration that’s used by containers.
    ConfigMaps can be mapped into a running container as environment variables or
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret**: This is used to store sensitive data used by containers, such as
    credentials. Secrets can be made available to containers in the same way as ConfigMaps.
    Anyone with full read access to the API server can access the values of created
    Secrets, so they are not as safe as the name might imply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DaemonSet**: This ensures that one Pod is running on each node in a set of
    nodes in the cluster. In *Chapter 19*, *Centralized Logging with the EFK Stack*,
    we will see an example of a log collector, Fluentd, that will run on each worker
    node as a DaemonSet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a full list of resource objects that the Kubernetes API covers in v1.26,
    see [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the Kubernetes resources that are involved
    in handling incoming requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Overview of Kubernetes resources'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Two Deployments, **Deployment A** and **Deployment B**, have been deployed to
    a cluster with two nodes, **Node 1** and **Node 2**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment A** contains two Pods, **Pod A1** and **Pod A2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment B** contains one Pod, **Pod B1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod A1** is scheduled to **Node 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pod A2** and **Pod B1** are scheduled to **Node 2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Deployment has a corresponding Service deployed, **Service A** and **Service
    B**, and they are available on all nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Ingress** is defined to route incoming requests to the two Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client typically sends requests to the cluster via an **external load balancer**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These objects are not, by themselves, running components; instead, they are
    definitions of different types of desired states. To reflect the desired state
    in the cluster’s current state, Kubernetes comes with an architecture consisting
    of a number of runtime components, as described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes runtime components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster contains two types of nodes: **master nodes** and **worker
    nodes**. Master nodes manage the cluster, while the main purpose of worker nodes
    is to run the actual workload, for example, the containers we deploy in the cluster.
    Kubernetes is built up of a number of runtime components. The most important components
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are components that run on master nodes, constituting the **control plane**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **API server**, the entry point to the control plane. This exposes a RESTful
    API, which, for example, the Kubernetes CLI tool known as **kubectl** uses.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**, a highly available and distributed key-value store, used as a database
    for all cluster data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **controller manager**, which contains a number of controllers that continuously
    evaluate the desired state versus the current state for the objects defined in
    the etcd database. Whenever the desired or current state changes, a controller
    that’s responsible for that type of state takes action to move the current state
    to the desired state. For example, a replication controller that’s responsible
    for managing Pods will react if a new Pod is added through the API server or a
    running Pod is deleted and ensures that new Pods are started. Another example
    of a controller is the node controller. It is responsible for acting if a node
    becomes unavailable, ensuring that Pods running on a failing node are rescheduled
    on other nodes in the cluster.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A **scheduler**, which is responsible for assigning newly created Pods to a
    node with available capacity, for example, in terms of memory and CPU. **Affinity
    rules** can be used to control how Pods are assigned to nodes. For example, Pods
    that perform a lot of disk I/O operations can be assigned to a group of worker
    nodes that have fast SSD disks. Anti-affinity rules can be defined to separate
    Pods, for example, to avoid scheduling Pods from the same Deployment to the same
    worker node.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Components that run on all the nodes, constituting the **data plane**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubelet**, a node agent that executes as a process directly in the nodes’
    operating system and not as a container. A kubelet ensures that the Pods that
    are scheduled to its node have their containers up and running and that they are
    healthy. It acts as a conduit between the API server and the container runtime
    on its node.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kube-proxy**, a network proxy that enables the Service concept in Kubernetes
    and is capable of forwarding requests to the appropriate Pods, typically in a
    round-robin fashion if more than one Pod is available for the specific Service.
    `kube-proxy` is deployed as a DaemonSet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container runtime**, which is the software that runs the containers on a
    node. Historically, Kubernetes used Docker Engine, but today any implementation
    of the Kubernetes **Container Runtime Interface** (**CRI**) can be used, for example,
    **cri-o** ([https://cri-o.io](https://cri-o.io)) and **containerd** ([https://containerd.io/](https://containerd.io/)).
    Support for Docker Engine was removed in Kubernetes v1.24.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containerd` is actually the container engine of Docker. It was separated from
    Docker back in 2017 and is today a graduated CNCF project.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Kubernetes DNS**, which is a DNS server that’s used in the cluster’s internal
    network. Services and Pods are assigned a DNS name, and Pods are configured to
    use this DNS server to resolve the internal DNS names. The DNS server is deployed
    as a Deployment object and a Service object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the Kubernetes runtime components described
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B19825_15_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Overview of Kubernetes runtime components'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the diagram, we can imagine the following sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: An operator uses **kubectl** to send in a new desired state to Kubernetes, containing
    manifests declaring a new **Deployment**, **Service**, and **Ingress** object.
    The Ingress defines a route to the Service object and the Service object is defined
    to select Pods that are configured by the Deployment object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**kubectl** talks to the **API server** and it stores the new desired state
    as objects in the **etcd** database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Various **controllers** will react to the creation of the new objects and take
    the following actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the Deployment object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: New **ReplicaSet** and **Pod** objects will be registered in the API server.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The **scheduler** will see the new Pod(s) and schedule them to the appropriate
    worker nodes.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On each worker node, the **kubelet** agent will launch containers as described
    by the Pods. The kubelet will use the **container runtime** on the worker node
    to manage the containers.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the Service object:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A DNS name will be registered in the internal DNS server for the Service object
    and the **kube-proxy** will be able to route requests that use the DNS name to
    one of the available Pods.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that Pods are reachable from any node in the cluster, so the kube-proxy
    does not need to run on the same node as the Pod to be able to forward requests
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Ingress object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An **Ingress controller** will set up routes according to the Ingress object
    and be ready to accept requests from outside of the Kubernetes cluster. External
    requests that match the routes defined by the Ingress object will be forwarded
    by the Ingress controller to the Service object. These requests will be forwarded
    by the kube-proxy to a Pod as described above.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we understand the Kubernetes runtime components and what they support
    and run on, let’s move on to creating a Kubernetes cluster with Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster using Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to create a Kubernetes cluster! We will use Minikube to create
    a local single-node cluster. Minikube can be deployed in a VM, a container, or
    on bare metal using different drivers. We will use one of the preferred drivers,
    the Docker driver, where the Minikube instance runs in a container managed by
    Docker Desktop on macOS and Windows with **Windows Subsystem for Linux, v2** (WSL
    2).
  prefs: []
  type: TYPE_NORMAL
- en: For information on the available drivers in Minikube, see [https://minikube.sigs.k8s.io/docs/drivers/](https://minikube.sigs.k8s.io/docs/drivers/).
  prefs: []
  type: TYPE_NORMAL
- en: Docker and its containers are already running in a separate WSL 2 instance;
    see the *Installing Docker Desktop for Windows* section in *Chapter 22*, *Installation
    Instructions for Microsoft Windows with WSL 2 and Ubuntu*.
  prefs: []
  type: TYPE_NORMAL
- en: One drawback of running Minikube as a container on Docker is that ports exposed
    by Minikube are only accessible on the host that runs Docker. To make the ports
    available to Docker clients, for example, macOS or the Linux server we will use
    on WSL 2, we can specify port mappings when creating the Minikube cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the Kubernetes cluster, we need to learn a bit about Minikube
    profiles, the Kubernetes CLI tool known as `kubectl`, and its use of contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Minikube profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run multiple Kubernetes clusters locally, Minikube comes with the
    concept of **profiles**. For example, if you want to work with multiple versions
    of Kubernetes, you can create multiple Kubernetes clusters using Minikube. Each
    cluster will be assigned a separate Minikube profile. Most of the Minikube commands
    accept a `--profile` flag (or `-p` for short), which can be used to specify which
    of the Kubernetes clusters the command will be applied to. If you plan to work
    with one specific profile for a while, a more convenient alternative exists, where
    you specify the current profile with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will set the `my-profile` profile as the current profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the current profile, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If no profile is specified, either using the `minikube profile` command or the
    `--profile` switch, a default profile named `minikube` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Information regarding existing profiles can be found with the command `minikube
    profile` `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Kubernetes CLI, kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl` is the Kubernetes CLI tool. Once a cluster has been set up, this
    is usually the only tool you need to manage the cluster!'
  prefs: []
  type: TYPE_NORMAL
- en: For managing the API objects, as we described earlier in this chapter, the `kubectl`
    `apply` command is the only command you need to know about. It is a **declarative
    command**; that is, as an operator, we ask Kubernetes to apply the object definition
    we give to the command. It is then up to Kubernetes to figure out what actually
    needs to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a declarative command that’s hopefully familiar to many readers
    of this book is a `SQL SELECT` statement, which can join information from several
    database tables. We only declare the expected result in the SQL query, and it
    is up to the database query optimizer to figure out in what order the tables should
    be accessed and what indexes to use to retrieve the data in the most efficient
    way.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, **imperative statements** that explicitly tell Kubernetes what
    to do are preferred. One example is the `kubectl delete` command, where we explicitly
    tell Kubernetes to delete some API objects. Creating a namespace object can also
    be conveniently done with an explicit `kubectl create namespace` command.
  prefs: []
  type: TYPE_NORMAL
- en: Repetitive usage of the imperative statements will make them fail, for example,
    deleting the same API object twice using `kubectl delete` or creating the same
    namespace twice using `kubectl create`. A declarative command, that is, using
    `kubectl apply`, will not fail with repetitive usage – it will simply state that
    there is no change and exit without taking any action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commonly used commands for retrieving information about a Kubernetes cluster
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl get` shows information about the specified API object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl describe` gives more detail about the specified API object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl logs` displays log output from containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see a lot of examples of these and other `kubectl` commands in this
    and the upcoming chapters!
  prefs: []
  type: TYPE_NORMAL
- en: 'If in doubt about how to use the `kubectl` tool, the `kubectl help` and `kubectl`
    `<command> --help` commands are always available and provide very useful information.
    Another helpful command is `kubectl explain`, which can be used to show what fields
    are available when declaring a Kubernetes object. For example, run the following
    command if you need to look up the fields available to describe a container in
    the template of a Deployment object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Working with kubectl contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to work with more than one Kubernetes cluster, using either Minikube
    locally or Kubernetes clusters set up on on-premises servers or in the cloud,
    `kubectl` comes with the concept of **contexts**. A context is a combination of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication information for a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, contexts are saved in the `~/.kube/config` file, but the file can
    be changed using the `KUBECONFIG` environment variable. In this book, we will
    use the default location, so we will unset `KUBECONFIG` using the `unset KUBECONFIG`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: When a Kubernetes cluster is created in Minikube, a context is created with
    the same name as the Minikube profile and is then set as the current context.
    So, `kubectl` commands that are issued after the cluster is created in Minikube
    will be sent to that cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the available contexts, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B19825_15_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: List of kubectl contexts'
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard, *****, in the first column marks the current context.
  prefs: []
  type: TYPE_NORMAL
- en: You will only see the `handson-spring-boot-cloud` context in the preceding response
    once the cluster has been created, the process for which we will describe shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to switch the current context to another context, that is, work
    with another Kubernetes cluster, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the current context will be changed to `my-cluster`.
  prefs: []
  type: TYPE_NORMAL
- en: To update a context, for example, switching the default namespace used by `kubectl`,
    use the `kubectl config set-context` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to change the default namespace of the current context to `my-namespace`,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `kubectl config current-context` is used to get the name of
    the current context.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Kubernetes cluster using Minikube, we need to run a few commands:'
  prefs: []
  type: TYPE_NORMAL
- en: Unset the `KUBECONFIG` environment variable to ensure that the `kubectl` context
    is created in the default config file, `~/.kube/config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the cluster using the `minikube start` command, where we can also specify
    what version of Kubernetes to use and the amount of hardware resources we want
    to allocate to the cluster:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be able to complete the examples in the remaining chapters of this book,
    allocate 10 GB of memory, that is, 10,240 MB, to the cluster. The samples should
    also work if only 6 GB (6,144 MB) is allocated to the Minikube cluster, albeit
    more slowly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocate the number of CPU cores and disk space you find suitable; 4 CPU cores
    and 30 GB of disk space are used in the following example.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify what version of Kubernetes will be used. In this book, we will use v1.26.1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify that we will use the Docker driver as described above.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the required port mappings. The ports `8080` and `8443` will be used
    by the Ingress controller, and the ports `30080` and `30443` will be used by Services
    of type `NodePort`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See *Chapter 16**, Deploying Our Microservices to Kubernetes,* for information
    on how the Gateway server deploys a Service of type `NodePort`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Specify the Minikube profile to be used for the coming `minikube` commands.
    We will use `handson-spring-boot-cloud` as the profile name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the cluster has been created, we will use the add-on manager in Minikube
    to enable an Ingress controller and a metrics server that comes out of the box
    with Minikube. The Ingress controller and the metrics server will be used in the
    next chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following commands to create the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preceding commands complete, you should be able to communicate with
    the cluster. Try the `kubectl get nodes` command. It should respond with something
    that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_15_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: List of nodes in the Kubernetes cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, the cluster will initialize itself in the background, starting
    up a number of system Pods in the `kube-system` and the `ingress-nginx` namespace.
    We can monitor its progress by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the startup is complete, the preceding command should report the status
    for all Pods as **Running** and the **READY** count should be **1/1**, meaning
    that a single container in each Pod is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B19825_15_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: List of running system Pods'
  prefs: []
  type: TYPE_NORMAL
- en: Note that two Pods are reported as **Completed**, and not **Running**. They
    are Pods created by **Job** objects, used to execute a container a fixed number
    of times like a batch job. Run the command `kubectl get jobs --namespace=ingress-nginx`
    to reveal the two Job objects.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready for some action!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out a sample Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see how we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a simple web server based on NGINX in our Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apply some changes to the Deployment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the current state by deleting the Pod and verify that the `ReplicaSet`
    creates a new one
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the desired state by scaling the web server to three Pods and verify
    that the `ReplicaSet` fills the gap by starting up two new Pods
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Route external traffic to the web server using a Service with a node port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, create a namespace, `first-attempts`, and update the `kubectl` context
    to use this namespace by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a Deployment of NGINX in the namespace using the `kubernetes/first-attempts/nginx-deployment.yaml`
    file. This file looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain this source code in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a Deployment object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `metadata` section is used to describe the Deployment object. For example,
    we give it the name `nginx-deploy`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other commonly used metadata for a Kubernetes object includes the name of the
    `namespace` it belongs to, `label`s, and `annotation`s. We will see them used
    in this chapter and the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes a `spec` section that defines our desired state for the Deployment
    object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replicas: 1` specifies we want to have one Pod up and running.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `selector` section that specifies how the Deployment will find the Pods it
    manages. In this case, the Deployment will look for Pods that have the `app` label
    set to `nginx-app`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `template` section is used to specify how Pods will be created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `metadata` section specifies the `label`, `app: nginx-app`, which is used
    to identify the Pods, thereby matching the selector.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `spec` section specifies details for the creation of the single container
    in the Pod, that is, `name`, `image`, and what `ports` it uses.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the Deployment with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what we got with the `kubectl get all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_15_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: Kubernetes objects created by the sample deployment'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, we got a Deployment, ReplicaSet, and Pod object. After a short
    while, which mainly depends on the time it takes to download the NGINX Docker
    image, the Pod will be up and running, reported as **1/1** in the **READY** column,
    meaning that the desired state is equal to the current state!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will change the current state by deleting the Pod. Before deleting
    the Pod, run the command `kubectl get pod --watch` in another terminal. The use
    of the `--watch` option makes the command hang, waiting for state changes of Pods
    in the current namespace. Delete the Pod using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the Pod has a random name (`nginx-deploy-59b8c5f7cd-mt6pg` in the preceding
    example), the Pod is selected based on the `app` label, which is set to `nginx-app`
    in the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Note how `kubectl get pod --watch` reports how the current Pod is terminated
    and at the same time a new Pod is started up.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the ReplicaSet that detects the difference between the desired and current
    state and almost immediately starts up a new Pod to compensate for the deviation.
    The reported events should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B19825_15_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: kubectl get pod --watch reporting changes to the Pods'
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, we can see that the Pod with a name ending with `d69ln` was
    stopped by the `delete` command and that the ReplicaSet immediately started up
    a new Pod with a name ending with `ptbkf`.
  prefs: []
  type: TYPE_NORMAL
- en: Change the desired state by setting the number of desired Pods to three replicas
    in the `kubernetes/first-attempts/nginx-deployment.yaml` Deployment file. Apply
    the change in the desired state by simply repeating the `kubectl apply` command,
    as we mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that the `kubectl get pod --watch` command reports new Pods being
    launched by the ReplicaSet to get the current state equivalent to the new desired
    state, that is, three Pods. After a few seconds, two new NGINX Pods will be reported
    as up and running. Stop the command with *Ctrl + C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `kubectl get all` command and expect a response that looks similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_15_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: New Pods started up by Kubernetes to meet the desired state'
  prefs: []
  type: TYPE_NORMAL
- en: Note the three Pods and that the Deployment object reports **3/3**. This is
    interpreted as 3 ready and 3 desired Pods, meaning that all desired Pods are ready
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable external communication with the web servers, create a Service using
    the `kubernetes/first-attempts/nginx-service.yaml` file. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a `Service` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `metadata` section is used to describe the `Service` object, for example,
    to give it a name: `nginx-service`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes a `spec` section, which defines the desired state of the `Service`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `type` field, we specify that we want `NodePort`, that is, a Service
    that is accessible externally on a dedicated port on each node in the cluster.
    This means that an external caller can reach the Pods behind this Service using
    this port on any of the nodes in the cluster, independent of which nodes the Pods
    actually run on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The selector is used by the Service to find available Pods, which, in our case,
    are Pods labeled with `app: nginx-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, `ports` are declared as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port: 80` specifies which port the Service will be accessible on, that is,
    internally in the cluster.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetPort: 80` specifies the port in the Pod where the requests will be forwarded
    to.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodePort: 30080` specifies which port the Service will be externally accessible
    on using any of the nodes in the cluster. By default, a node port must be in the
    range of `30000` to `32767`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This port range is used to minimize the risk of colliding with other ports in
    use. In a production system, a load balancer is typically placed in front of the
    Kubernetes cluster, shielding the external users both from the knowledge of these
    ports and the IP numbers of the nodes in the Kubernetes cluster. See *Chapter
    18*, *Using a Service Mesh to Improve Observability and Management*, specifically
    the *Setting up access to Istio Services* section, for more on the usage of a
    `LoadBalanced` Kubernetes Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what we got, run the `kubectl get svc` command. Expect a response like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_15_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: NodePort Service for our Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` supports short names for many of the API objects as an alternative
    to their full name. For example, `svc` was used in the preceding command instead
    of the full name, `service`. Run the command `kubectl api-resources` to see all
    available short names.'
  prefs: []
  type: TYPE_NORMAL
- en: To access the web server through the Service’s node port, we need to know the
    IP address or hostname of the single node in our cluster. When using the Docker
    driver, the hostname is always `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: The node port, `30080`, is forwarded from Docker Engine by the `–ports` option
    in the `minikube start` command. See the *Creating a Kubernetes cluster* section
    above for details. This means that the `Service` can be reached at the address
    `localhost:30080`.
  prefs: []
  type: TYPE_NORMAL
- en: Ports opened in a WSL 2 instance are accessible in Windows on `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information, we can direct a web browser on macOS and Windows to
    the deployed web server using the address `http://localhost:30080`. Expect a response
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B19825_15_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: NGINX default web page'
  prefs: []
  type: TYPE_NORMAL
- en: Great! But what about the internal cluster IP address and port?
  prefs: []
  type: TYPE_NORMAL
- en: One way to verify that the web server is also reachable internally in the cluster
    is to launch a small Pod that we can use to run `curl` from the inside. The `curl`
    command will use the internal cluster IP address and port. We don’t need to use
    the internal IP address; instead, we can use a DNS name that is created for the
    Service in the internal DNS server. The short name of the DNS name is the same
    as the name of the Service, that is, `nginx-service`.
  prefs: []
  type: TYPE_NORMAL
- en: The full DNS name of a Service is `<service-name>.<namespace>.svc.cluster.local`.
    The full name for this Service is `nginx-service.first-attempts.svc.cluster.local`.
    Since we will run the command below in the same namespace, we can use the short
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The command looks a bit complex, but it will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Pod with a small container based on the Docker image `curlimages/curl`,
    which contains the `curl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `curl -s 'http://nginx-service:80'` command inside the container and
    redirect the output to the Terminal using the `-i` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Pod using the `--rm` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expect the output from the preceding command to contain the following information
    (we are only showing parts of the response here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_15_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: Accessing NGINX inside the Kubernetes cluster'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the web server is also accessible internally in the cluster!
  prefs: []
  type: TYPE_NORMAL
- en: This is basically all we need to know to be able to deploy our system landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap this up by removing the namespace containing the `nginx` Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before we end this introductory chapter on Kubernetes, we need to learn how
    to manage our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a local Kubernetes cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A running Kubernetes cluster consumes a lot of resources, mostly memory. So,
    when we are done working with a Kubernetes cluster in Minikube, we must be able
    to hibernate it in order to release the resources allocated to it. We also need
    to know how to resume the cluster when we want to continue working with it. Eventually,
    we must also be able to permanently remove the cluster when we don’t want to keep
    it on disk anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube comes with a `stop` command that can be used to hibernate a Kubernetes
    cluster. The `start` command we used to initially create the Kubernetes cluster
    can also be used to resume the cluster from its hibernated state. To permanently
    remove a cluster, we can use the `delete` command from Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: Hibernating and resuming a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to hibernate (that is, `stop`) the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to resume (that is, `start`) the Kubernetes cluster
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `kubectl` commands directly after restarting the cluster might result
    in error messages like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is due to the `metrics-server` being a bit slow on starting up; the error
    message will disappear after a short while.
  prefs: []
  type: TYPE_NORMAL
- en: When resuming an already existing cluster, the `start` command ignores switches
    that were used when you were creating the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'After resuming the Kubernetes cluster, the `kubectl` context will be updated
    to use this cluster with the currently used namespace set to `default`. If you
    are working with another namespace, for example, the `hands-on` namespace that
    we will use in the upcoming chapter, *Chapter 16*, *Deploying Our Microservices
    to Kubernetes*, you can update the `kubectl` context with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent `kubectl` commands will be applied to the `hands-on` namespace when
    applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube also comes with a more lightweight and faster alternative to the `stop`
    and `start` commands: the `pause` and `unpause` commands. In this case, the components
    in the control plane are paused, not stopped, reducing the CPU consumption of
    the cluster to a minimum. I have, however, seen issues with these commands when
    used in the recent chapters, so I recommend using the `start` and `stop` commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you later want to terminate the Kubernetes cluster, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can actually run the `delete` command without specifying the profile, but
    I find it safer to be explicit about the profile. Otherwise, you may accidentally
    delete the wrong Kubernetes cluster!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully learned how to manage a Kubernetes cluster that runs in Minikube.
    We now know how to suspend and resume a cluster and, when no longer needed, we
    know how to permanently remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were introduced to Kubernetes as a container orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes, we can handle a cluster of servers as one big logical server
    that runs our containers. We declare a desired state for the Kubernetes cluster,
    and it ensures that the actual state is the same as the desired state at all times,
    provided that enough hardware resources are available in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The desired state is declared by creating resources using the Kubernetes API
    server. The controller manager in Kubernetes and its controllers react to the
    various resources that were created by the API server and take actions to ensure
    that the current state meets the new desired state. The scheduler assigns nodes
    to newly created containers, that is, Pods that contain one or more containers.
    On each node, an agent, a `kubelet`, runs and ensures that the Pods that were
    scheduled to its node are up and running. The `kube-proxy` acts as a network proxy,
    enabling a Service abstraction by forwarding requests that are sent to the Service
    to available Pods in the cluster. External requests can be handled either by a
    Kubernetes-aware load balancer that can provision a public IP address and/or DNS
    name for the Service, a node port that’s available on all of the nodes in the
    cluster, or through a dedicated Ingress resource.
  prefs: []
  type: TYPE_NORMAL
- en: We have also tried out Kubernetes by creating a local single-node cluster using
    Minikube. The Minikube cluster runs as a Docker container using the Docker driver.
    To make ports accessible outside of Docker Engine, we can use the `--ports` option
    on the `minikube start` command. Using the Kubernetes CLI tool known as `kubectl`,
    we deployed a simple web server based on NGINX. We tried out resilience capabilities
    by deleting the web server, and we observed it being recreated automatically.
    We learned how to manually scale it by requesting that three Pods run on the web
    server. We created a Service with a node port and verified that we could access
    it both externally and from the inside of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to manage a Kubernetes cluster running in Minikube in
    terms of how to hibernate, resume, and terminate the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to deploy our system landscape from the earlier chapters in
    Kubernetes. Head over to the next chapter to find out how to do this!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens if you run the same `kubectl create` command twice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you run the same `kubectl apply` command twice?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In terms of questions 1 and 2, why do they act differently the second time they
    are run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of a ReplicaSet, and what other resource creates a ReplicaSet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of `etcd` in a Kubernetes cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a container find out the IP address of another container that runs in
    the same Pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you create two Deployments with the same name but in different
    namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What configuration of two Services with the same name can make them fail, even
    if they are created in two different namespaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1849216352344398875.png)'
  prefs: []
  type: TYPE_IMG
