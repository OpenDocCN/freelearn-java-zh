<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Saving Your Data" id="21PMQ1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Saving Your Data</h1></div></div></div><p class="calibre8">There are many types of Bukkit plugins. Some of them require you to save data. By saving data, I am referring to saving information to the system's hard drive. This is needed if the information must stay intact, even after the server restarts. At this point, none of the plugins that we created have this requirement. Examples of plugins that will save data are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Economy plugins<a id="id246" class="calibre1"/> must save information about how much money each player has</li><li class="listitem">Land protection plugins <a id="id247" class="calibre1"/>must save information about which plots of land are claimed and who their owner is</li><li class="listitem">Questing plugins <a id="id248" class="calibre1"/>must store all the information for each quest, such as who has completed it</li></ul></div><p class="calibre8">There are countless uses for saving data when a server is shut down. In this chapter, we will create a teleportation plugin that saves various warp locations to a file. Again, we will save these locations to a file so that we do not need to create them again after the server shuts down. You are already familiar with the YAML file format. Therefore, we will utilize the YAML configuration to save and load data. In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The type of data that you can save</li><li class="listitem">The data in a plugin that is worth saving and the frequency of saving it</li><li class="listitem">Expanding a prewritten teleportation plugin</li><li class="listitem">Creating and using a <code class="email">ConfigurationSerializable</code> object</li><li class="listitem">Saving data in a YAML configuration</li><li class="listitem">Loading the saved data from the YAML configuration</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Saving Your Data" id="21PMQ1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Types of data that can be saved"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec63" class="calibre1"/>Types of data that can be saved</h1></div></div></div><p class="calibre8">You may recall, as <a id="id249" class="calibre1"/>discussed in the previous chapter, that only certain data types can be stored in a YAML file. These include primitive types, such as <code class="email">int</code> and <code class="email">boolean</code>, strings, lists, and types that implement <code class="email">ConfigurationSerializable</code>, such as <code class="email">ItemStack</code>.</p><p class="calibre8">For this reason, we can only save these specific types of data.</p><p class="calibre8">You may find yourself wanting to save other types of data such as a <code class="email">Player</code> object, or in the case of the teleportation plugin, a <code class="email">Location</code> object. These may not be stored directly, but they can usually be broken down in order to save the important values that are needed to load it later. As an example, you cannot save a <code class="email">Player</code> object, but you can save the players' <a id="id250" class="calibre1"/>
<span class="strong"><strong class="calibre2">UUID</strong></span> (<span class="strong"><strong class="calibre2">Universal Unique Identifier</strong></span>), which can be converted into a string. Each <code class="email">Player</code> has one UUID. Hence, it is the only information that we need to be able to refer to that specific player later.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre8">Storing a Players name is not an adequate solution, since the name provided in the Minecraft account can be changed.</p></div><p class="calibre8">A <code class="email">Location</code> object also cannot be stored directly, but it can be broken down to its world, <code class="email">x</code>, <code class="email">y</code>, and <code class="email">z</code> coordinates, <code class="email">yaw</code>, and <code class="email">pitch</code>. The <code class="email">x, y, z, yaw</code>, and <code class="email">pitch</code> values are simply numbers that can be stored. As for the world, it also has a UUID that will never change. Therefore, a location is broken down into one string (<code class="email">world uuid</code>), three doubles (<code class="email">x</code>, <code class="email">y</code>, <code class="email">z</code>), and two floats (<code class="email">yaw</code> and <code class="email">pitch</code>).</p><p class="calibre8">As you create your own plugins, you may have classes that you wish to store in a file, such as a <code class="email">BankAccount</code> object. As mentioned earlier, we can do this with any class that implements <code class="email">ConfigurationSerializable</code>. <code class="email">ConfigurationSerializable</code> means that the object can be translated to a form that can be stored within a configuration. This configuration can then be written to a file. In the teleportation plugin, we will create a <code class="email">location</code> object that does exactly this.</p></div></div>
<div class="book" title="Which data to save and when" id="22O7C1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec64" class="calibre1"/>Which data to save and when</h1></div></div></div><p class="calibre8">We know what can be saved to a file, but what should we save? Writing data to a file uses disk space. Therefore, we want to save only what we need to. It is better to think, "Which information do I want to keep after the server shuts down?" For example, a banking plugin will want to keep the balance of each account. As another example, a <span class="strong"><strong class="calibre2">PvP</strong></span> arena plugin<a id="id251" class="calibre1"/> will not care about having information about an arena match. It is quite likely that the match will simply be canceled as the server is shutting down. When considering the teleportation plugin, we will want to still have the locations of each warp after the server is shut down.</p><p class="calibre8">Our next concern is when to save this information. Writing data to files has the potential to <span class="strong"><strong class="calibre2">lag </strong></span>a server if it is a large amount of data. If you are unfamiliar with the term "lag", it is a phrase that is used to indicate that the server is running slowly. You know when this happens because the game becomes very choppy and players and mobs seem to move around sporadically. This is an unpleasant experience for everyone. Hence, you want to save your data only when you have to. There are three typical options for how often you want to save your data:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Every time the data is modified</li><li class="listitem">Periodically, such as every hour</li><li class="listitem">When the server/plugin is shut down</li></ul></div><p class="calibre8">These options are ordered by <a id="id252" class="calibre1"/>how safe they are. For instance, if your data is saved only when the server is shut down, then you run the risk of losing unsaved data in case the server crashes. If data is saved every hour, then in the worst case, you will lose only one hour's worth of data. For this reason, the first option should always be used when possible. The second and third options should be considered only if the plugin handles a large amount of data and/or the data is modified very often, such as several times every minute. The data of the teleportation plugin will only be modified when someone creates/deletes a warp or sets their home warp location. Therefore, we will invoke the <code class="email">save</code> method every time the data is modified.</p></div>
<div class="book" title="A sample teleportation plugin" id="23MNU1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec65" class="calibre1"/>A sample teleportation plugin</h1></div></div></div><p class="calibre8">For this project, you will be<a id="id253" class="calibre1"/> given an incomplete teleportation plugin. You already know how to program most of this project. Therefore, we will discuss only the following three topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating a class that implements <code class="email">ConfigurationSerializable</code></li><li class="listitem">The <code class="email">save</code> method</li><li class="listitem">The <code class="email">load</code> method</li></ul></div><p class="calibre8">The rest of the plugin is provided and can be downloaded from <a class="calibre1" href="http://www.packtpub.com">www.packtpub.com</a>, as mentioned in the preface. The code that you will be working on is Version 0.1 of the plugin Warper. Go through the plugin and read the comments to try to understand everything that it does. Both <code class="email">Maps</code> and <code class="email">try/catch</code> blocks are used in this project. If you do not know what either of those are, that is okay. They will be explained when it is time to use them yourself. Note that the <code class="email">SerializableLocation</code> class is the location class, which implements <code class="email">ConfigurationSerializable</code>; we will discuss this next.</p></div>
<div class="book" title="Writing a ConfigurationSerializable class"><div class="book" id="24L8G2-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec66" class="calibre1"/>Writing a ConfigurationSerializable class</h1></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Serialization</strong></span> <a id="id254" class="calibre1"/>is the process of translating data or objects into a form that can be written to a file. In the plugin Warper, we will need to save the Bukkit locations. Locations cannot be serialized themselves. Therefore, we will make our own class that holds the Bukkit <code class="email">Location</code> object data and is able to convert it to and from a map. If you are new to maps, they are a very useful type of collection that we will use throughout this project. Maps have keys and values. Each key points to a specific value. The <code class="email">Warper</code> plugin is a good example of how maps can be used. When teleporting, a player will choose a<a id="id255" class="calibre1"/> specific location to warp to by name. If all the warp locations were in a list, we would have to iterate through the list until the warp location with the correct name was found. With a map, we can pass the key (the name of the warp) to the map, and it will return the value (the warp location).</p><p class="calibre8">Create a new class called <code class="email">SerializableLocation</code>, which contains a private variable that holds the Bukkit <code class="email">Location object</code>. The first constructor will require a <code class="email">Location</code> object. We will also include a <code class="email">getLocation</code> method. The following code is how the beginning of the new class looks:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.warper;

import org.bukkit.Location;

/**
 * A SerializableLocation represents a Bukkit Location object
 * This class is configuration serializable so that it may be
 * stored using Bukkit's configuration API
 */
public class SerializableLocation {
    private Location loc;

    public SerializableLocation(Location loc) {
        this.loc = loc;
    }

    /**
     * Returns the Location object in its full form
     *
     * @return The location of this object
     */
    public Location getLocation() {
        return loc;
    }
}</pre></div><p class="calibre8">Once you add <code class="email">implements ConfigurationSerializable</code>, your IDE should warn you about implementing all the abstract methods. The method that you must override is <code class="email">serialize</code>. This will return a map representation of your object. We already mentioned each piece of data that we will need. Now, we just have to assign each piece of data a name and put it in a map. To add data to a map, you can call the <code class="email">put</code> method. This method requires two parameters, namely a key and a value of the key. A key is simply a name for the piece of data that allows us to reference it later. The value is the serializable data. To find out more about <a id="id256" class="calibre1"/>maps, you can read the <span class="strong"><strong class="calibre2">Javadoc</strong></span><a id="id257" class="calibre1"/> at <a class="calibre1" href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html">https://docs.oracle.com/javase/8/docs/api/java/util/Map.html</a>. For the <code class="email">serialize</code> method, we <a id="id258" class="calibre1"/>will need to get all the data that we mentioned earlier and put it in a map, as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Returns a map representation of this object for use of serialization
 *
 * @return This location as a map of Strings to Objects
 */
@Override
public Map&lt;String, Object&gt; serialize() {
    Map map = new TreeMap();
    map.put("world", loc.getWorld().getUID().toString());
    map.put("x", loc.getX());
    map.put("y", loc.getY());
    map.put("z", loc.getZ());
    map.put("yaw", loc.getYaw());
    map.put("pitch", loc.getPitch());
    return map;
}</pre></div><p class="calibre8">This handles the saving portion, but we still have to handle the loading. The simplest way to do this is by adding a constructor that takes the map as a parameter, as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * This constructor is used by Bukkit to create this object
 *
 * @param map The map which matches the return value of the serialize() method
 */
public SerializableLocation(Map&lt;String, Object&gt; map) {
    //Check if the world for this location is loaded
    UUID uuid = UUID.fromString((String) map.get("world"));
    World world = Bukkit.getWorld(uuid);
    if (world != null) {
        //Each coordinate we cast to it's original type
        double x = (double) map.get("x");
        double y = (double) map.get("y");
        double z = (double) map.get("z");

        //Both yaw and pitch are loaded as type Double and then converted to float
        float yaw = ((Double) map.get("yaw")).floatValue();
        float pitch = ((Double) map.get("pitch")).floatValue();

        loc = new Location(world, x, y, z, yaw, pitch);
    } else {
        Warper.plugin.getLogger().severe("Invalid location, most likely due to missing world");
    }
}</pre></div><p class="calibre8">Loading is essentially the <a id="id259" class="calibre1"/>opposite of saving. We pull each value from the map and then use it to create the Bukkit <code class="email">Location</code> object. As a safeguard, we will first verify that the world is actually loaded. If the world is not loaded, the location will not exist. We do not want the plugin to crash because of this. There is also no reason why you need to try loading the location of a nonexistent world, because no one will be able to teleport to it anyway.</p><p class="calibre8">Each object that you get from the map will have to be cast to its original type, which was done in the previous code. The <code class="email">float</code> values are an exceptional case. Each of the <code class="email">float</code> values will be read as a <code class="email">double</code> value. The <code class="email">double value</code> is similar to <code class="email">float</code>, but it is more precise. Therefore, loading the <code class="email">float</code> values as the <code class="email">double</code> values and then converting them will not cause data loss.</p><p class="calibre8">Both of these methods will be used by Bukkit. As a programmer, you will only have to store this object in the YAML configuration. This can be done by simply using the following line of code:</p><div class="informalexample"><pre class="programlisting">config.set("location", serializableLoc);</pre></div><p class="calibre8">Then, you can retrieve the data later by using the following code:</p><div class="informalexample"><pre class="programlisting">SerializableLocation loc = (SerializableLocation)config.get("location");</pre></div><p class="calibre8">Bukkit uses the <code class="email">serialize</code> method and the constructor to handle the rest.</p><p class="calibre8">The class name and path are used to reference this class. To see an example of this, take a look at the <code class="email">ItemStack</code> object in the <code class="email">config.yml</code> file for the <code class="email">MobEnhancer</code> plugin. An example of this class has also been provided:</p><div class="informalexample"><pre class="programlisting">==: com.codisimus.warper.SerializableLocation</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre8">The path will of course have your own namespace, not <code class="email">com.codisimus</code>.</p></div><p class="calibre8">This works fine, but <a id="id260" class="calibre1"/>it may cause confusion, especially with long pathnames. However, there is a way to ask Bukkit to reference this class by using an alias. Perform the following two steps to complete this:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the <code class="email">@SerializableAs</code> annotation just above the class, as follows:<div class="informalexample"><pre class="programlisting">@SerializableAs("WarperLocation")
public class SerializableLocation implements ConfigurationSerializable {</pre></div></li><li class="listitem" value="2">Register your class within the <code class="email">ConfigurationSerialization class</code>:<div class="informalexample"><pre class="programlisting">ConfigurationSerialization.registerClass(SerializableLocation.class, "WarperLocation");</pre></div></li></ol><div class="calibre13"/></div><p class="calibre8">This can be done in the <code class="email">onEnable</code> method. Just ensure that it is executed before you attempt loading the data.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip29" class="calibre1"/>Tip</h3><p class="calibre8">The serializable name must be unique. Therefore, it is better to include your plugin name rather than simply <code class="email">Location</code>. That way, you can have a serializable location for another plugin without them conflicting.</p></div></div>
<div class="book" title="Saving data to a YAML configuration" id="25JP21-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>Saving data to a YAML configuration</h1></div></div></div><p class="calibre8">Now, we are ready to <a id="id261" class="calibre1"/>complete the <code class="email">save</code> method. We want to<a id="id262" class="calibre1"/> save data to a YAML file, much like how we did in <code class="email">config.yml</code>. However, we do not want to save it to <code class="email">config.yml</code>, because that serves a different purpose. The first thing that we will need to do is create a new YAML configuration, as follows:</p><div class="informalexample"><pre class="programlisting">YamlConfiguration config = new YamlConfiguration();</pre></div><p class="calibre8">Next, we will store all the information that we wish to save. This is done by setting objects to specific paths, as follows:</p><div class="informalexample"><pre class="programlisting">config.set(String path, Object value);</pre></div><p class="calibre8">The acceptable types for <code class="email">value</code> were mentioned earlier in this chapter. In the teleportation plugin, we have maps, which contain the <code class="email">SerializableLocation </code>method. Maps can be added to a YAML configuration as long as they are a map of strings to an object that is <code class="email">ConfigurationSerializable</code>. <span class="strong"><strong class="calibre2">Hashmaps</strong></span><a id="id263" class="calibre1"/> are added to a configuration in a different manner. You must create a configuration section using the map.</p><p class="calibre8">The following code shows how we will add the teleportation data to the configuration:</p><div class="informalexample"><pre class="programlisting">config.createSection("homes", homes);
config.createSection("warps", warps);</pre></div><p class="calibre8">Once all the data is stored, all that is left to do is write the configuration to the <code class="email">save</code> file. This is done by invoking the <code class="email">save</code> method on <code class="email">config</code> and passing the file that we wish to use. Calling the <code class="email">getDataFolder</code> method of the plugin will give us the directory in which we should store all the plugin data. This is also where <code class="email">config.yml</code> is located. We can use this directory to reference the file in which we will save the data, as follows:</p><div class="informalexample"><pre class="programlisting">File file = new File(plugin.getDataFolder(), "warps.yml");
config.save(file);</pre></div><p class="calibre8">We will put all of these<a id="id264" class="calibre1"/> lines of code inside a <code class="email">try</code> block to catch an <a id="id265" class="calibre1"/>exception that may occur. If you don't already know about exceptions, they are thrown when there is some sort of error or when something unexpected occurs. A <code class="email">try/catch</code> block can be used to prevent the error from causing your plugin to crash. In this case, an exception is thrown if the specified file cannot be written for some reason. This reason may be that the user has insufficient privileges or the file location cannot be found. Therefore, the <code class="email">save</code> method with the <code class="email">try</code> block is as follows:</p><div class="informalexample"><pre class="programlisting">/**
 * Saves our HashMaps of warp locations so that they may be loaded
 */
private static void save() {
    try {
        //Create a new YAML configuration
        YamlConfiguration config = new YamlConfiguration();

        //Add each of our hashmaps to the config by creating sections
        config.createSection("homes", homes);
        config.createSection("warps", warps);

        //Write the configuration to our save file
        config.save(new File(plugin.getDataFolder(), "warps.yml"));
    } catch (Exception saveFailed) {
        plugin.getLogger().log(Level.SEVERE, "Save Failed!", saveFailed);
    }
}</pre></div><p class="calibre8">The following is a sample <code class="email">warps.yml</code> file that will be created using the Warper plugin:</p><div class="informalexample"><pre class="programlisting">homes:
  18d6a045-cd24-451b-8e2e-b3fe09df46d3:
    ==: WarperLocation
    pitch: 6.1500483
    world: 89fd34ff-2c01-4d47-91c4-fa5d1e9fdb81
    x: -446.45572804715306
    y: 64.0
    yaw: 273.74963
    z: 224.9827566893271
warps:
  spawn:
    ==: WarperLocation
    pitch: 9.450012
    world: 89fd34ff-2c01-4d47-91c4-fa5d1e9fdb81
    x: -162.47507312961542
    y: 69.0
    yaw: -1.8000238
    z: 259.70096111857805
  Jungle:
    ==: WarperLocation
    pitch: 7.500037
    world: 35dafe89-3451-4c27-a626-3464e3856428
    x: -223.87850735096316
    y: 74.0
    yaw: 87.60001
    z: 382.482006630207
  frozen_lake:
    ==: WarperLocation
    pitch: 16.200054
    world: 53e7fab9-5f95-4e25-99d1-adce40d5447c
    x: -339.3448071127722
    y: 63.0
    yaw: 332.84973
    z: 257.9509874720554</pre></div></div>
<div class="book" title="Loading data from a YAML configuration" id="26I9K1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec68" class="calibre1"/>Loading data from a YAML configuration</h1></div></div></div><p class="calibre8">Now that the <code class="email">save</code> method <a id="id266" class="calibre1"/>is complete, we are ready to write the <code class="email">load</code> method. You are already familiar with loading data using the Bukkit configuration API. What<a id="id267" class="calibre1"/> we'll do now is similar to retrieving values from <code class="email">config.yml</code>, as discussed in the previous chapter. However, we must first manually load the configuration using the following code, which will be different. We should only do this if the file actually exists. The file will not exist the first time the plugin is used. Therefore, we do not want an error to occur in that situation:</p><div class="informalexample"><pre class="programlisting">File file = new File(plugin.getDataFolder(), "warps.yml");
if (file.exists()) {
    YamlConfiguration config = new YamlConfiguration();
    config.load(file);</pre></div><p class="calibre8">Now that we have the YAML configuration loaded, we can get values from it. The data has been placed into two unique configuration sections. We will loop through each key of both the sections in order to load all the locations. To get a specific object from a section, all that we need to do is <a id="id268" class="calibre1"/>call the <code class="email">get</code> method and cast it to the correct object. You can see how this is done in the <a id="id269" class="calibre1"/>completed <code class="email">load</code> method:</p><div class="informalexample"><pre class="programlisting">/**
 * Loads warp names/locations from warps.yml
 * 'warp' refers to both homes and public warps
 */
private static void load() {
    try {
        //Ensure that the file exists before attempting to load it
        File file = new File(plugin.getDataFolder(), "warps.yml");
        if (file.exists()) {
            //Load the file as a YAML Configuration
            YamlConfiguration config = new YamlConfiguration();
            config.load(file);

            //Get the homes section which is our saved hash map
            //Each key is the uuid of the Player
            //Each value is the location of their home
            ConfigurationSection section = config.getConfigurationSection("homes");
            for (String key: section.getKeys(false)) {
                //Get the location for each key
                SerializableLocation loc = (SerializableLocation)section.get(key);
                //Only add the warp location if it is valid
                if (loc.getLocation() != null) {
                    homes.put(key, loc);
                }
            }

            //Get the warps section which is our saved hash map
            //Each key is the name of the warp
            //Each value is the warp location
            section = config.getConfigurationSection("warps");
            for (String key: section.getKeys(false)) {
                //Get the location for each key
                SerializableLocation loc = (SerializableLocation) section.get(key);
                //Only add the warp location if it is valid
                if (loc.getLocation() != null) {
                    warps.put(key, loc);
                }
            }
        }
    } catch (Exception loadFailed) {
        plugin.getLogger().log(Level.SEVERE, "Load Failed!",loadFailed);
    }
}</pre></div><p class="calibre8">Now that the plugin is<a id="id270" class="calibre1"/> complete, you can test it on your <a id="id271" class="calibre1"/>server. Set a home location as well as some warp locations and then view the save file. Stop and then start the server again to verify that the plugin does indeed load the correct data.</p></div>
<div class="book" title="Summary" id="27GQ61-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec69" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">The plugin that we created in this chapter invokes the <code class="email">save</code> method whenever the data is modified. In the next chapter, you will learn how to periodically save data. If you wish to save data when the server is shut down, simply call the <code class="email">save</code> method from the <code class="email">onDisable</code> method of the plugin's <code class="email">main</code> class. You can use your programming skills to expand this plugin. You can add permission nodes, which is done by simply adding them to <code class="email">plugin.yml</code>. You can also add a <code class="email">config.yml</code> file to modify messages or perhaps the amount of time that needs to be set for the upcoming warp delay. If you wish to incorporate a listener, you can listen for a <code class="email">PlayerRespawnEvent</code>. Then, you can set a player's respawn location to their home. There are countless more ways to customize this plugin to your liking. Many teleportation plugins use a warp delay to prevent players from teleporting away from a fight. In the next chapter, we will expand this project by adding a warp delay using the Bukkit scheduler.</p></div></body></html>