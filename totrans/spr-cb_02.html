<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Defining Beans and Using Dependency Injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Defining Beans and Using Dependency Injection</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining a bean explicitly with @Bean</li><li class="listitem" style="list-style-type: disc">Defining a bean implicitly with @Component</li><li class="listitem" style="list-style-type: disc">Using a bean via dependency injection with @Autowired</li><li class="listitem" style="list-style-type: disc">Using a bean directly</li><li class="listitem" style="list-style-type: disc">Listing all beans</li><li class="listitem" style="list-style-type: disc">Using multiple configuration classes</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Introduction</h1></div></div></div><p><span class="strong"><strong>Beans</strong></span> are at the <a id="id98" class="indexterm"/>core of Spring. They are standard Java objects instantiated and managed by Spring.</p><p>Beans are mostly <a id="id99" class="indexterm"/>used to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configure Spring in some way (database connection parameters, security, and so on)</li><li class="listitem" style="list-style-type: disc">Avoid hardcoding<a id="id100" class="indexterm"/> dependencies using <span class="strong"><strong>dependency injection</strong></span>, so that our classes remain self-contained and unit testable</li></ul></div><p>In this chapter, you'll learn how to define beans and use them.</p></div></div>
<div class="section" title="Defining a bean explicitly with @Bean"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Defining a bean explicitly with @Bean</h1></div></div></div><p>The simplest<a id="id101" class="indexterm"/> way to define a bean is to create, in a<a id="id102" class="indexterm"/> Spring configuration class, a method annotated with <code class="literal">@Bean</code> returning an object (the actual bean). Such beans are usually used to configure Spring in some way (database, security, view resolver, and so on). In this recipe, we'll define a bean that contains the connection details of a database.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>How to do it…</h2></div></div></div><p>In a Spring configuration class, add a <code class="literal">dataSource()</code> method annotated with <code class="literal">@Bean</code> and return a <code class="literal">Datasource</code> object. In this method, create a <code class="literal">DriverManagerDataSource</code> object initialized with the connection details of a database:</p><div class="informalexample"><pre class="programlisting">@Bean
public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/db1");
        dataSource.setUsername("root");
        dataSource.setPassword("123");
         
        return dataSource;
}</pre></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>How it works…</h2></div></div></div><p>At startup, because of <code class="literal">@Bean</code>, the <code class="literal">dataSource()</code> method is automatically executed and returns a <code class="literal">Datasource</code> object which is stored by Spring (in a Spring object called <code class="literal">ApplicationContext</code>). The bean name is <code class="literal">dataSource</code>, which is the same as its methods name. From this point, any call to <code class="literal">dataSource()</code> will return the same cached <code class="literal">DataSource</code> object; <code class="literal">dataSource()</code> won't actually be executed again. This is done using aspect-oriented programming; any call to <code class="literal">dataSource()</code> is intercepted by Spring, which directly returns the object instead of executing the method.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>There's more…</h2></div></div></div><p>To <a id="id103" class="indexterm"/>customize the bean name, use the name parameter:</p><div class="informalexample"><pre class="programlisting">@Bean(name="theSource")
public DataSource dataSource() {
...</pre></div><p>To force <code class="literal">dataSource()</code> to be executed each time it's called (and return a different object each time), use the <code class="literal">@Scope</code> annotation with a <code class="literal">prototype</code> scope:</p><div class="informalexample"><pre class="programlisting">@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public DataSource dataSource() {
...</pre></div><p>It's possible to <a id="id104" class="indexterm"/>define beans using our own classes. For example, if we have a <code class="literal">UserService</code> class, we can define a <code class="literal">UserService</code> bean in a Spring configuration class:</p><div class="informalexample"><pre class="programlisting">@Bean
public UserService userService() {
        return new UserService();
}</pre></div><p>However, it's usually simpler to let Spring generate this kind of beans automatically using a <code class="literal">@Component</code> annotation on the <code class="literal">UserService</code> class, as explained in the <span class="emphasis"><em>Defining a bean implicitly with @Component</em></span> recipe.</p></div></div>
<div class="section" title="Defining a bean implicitly with @Component"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Defining a bean implicitly with @Component</h1></div></div></div><p>Beans don't have to be defined in a Spring configuration class. Spring will automatically generate a<a id="id105" class="indexterm"/> bean from any class annotated <a id="id106" class="indexterm"/>with <code class="literal">@Component</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Getting ready</h2></div></div></div><p>We will use the basic web application created in the <span class="emphasis"><em>Creating a Spring web application</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Creating a Spring Application">Chapter 1</a>, <span class="emphasis"><em>Creating a Spring Application</em></span>.</p><p>Create the <code class="literal">com.springcookbook.service</code> package and the following service class in it:</p><div class="informalexample"><pre class="programlisting">public class UserService {
  public int findNumberOfUsers() {
    return 10;
  }
}</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>How to do it…</h2></div></div></div><p>Here are the steps to define a bean by adding <code class="literal">@Component</code> to an existing class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the Spring configuration file, in the <code class="literal">@ComponentScan</code> class annotation, add the <code class="literal">com.springcookbook.service</code> base package:<div class="informalexample"><pre class="programlisting">@Configuration
@EnableWebMvc
@ComponentScan(basePackages = {"com.springcookbook.controller", <span class="strong"><strong>"</strong></span>com.springcookbook.service"})
public class AppConfig {  
}</pre></div></li><li class="listitem">In the <code class="literal">UserService</code> class, add <code class="literal">@Component</code>:<div class="informalexample"><pre class="programlisting">@Component
public class UserService {
  public int findNumberOfUsers() {
    return 10;
  }
}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>How it works…</h2></div></div></div><p>At startup, the <code class="literal">com.springcookbook.service</code> package will be scanned by Spring. The <code class="literal">UserService</code> class is annotated with <code class="literal">@Component</code>, so a bean is automatically instantiated<a id="id107" class="indexterm"/> from it. The bean's name will<a id="id108" class="indexterm"/> be <code class="literal">userService</code> by default, based on the class name.</p><p>To specify a custom name, use the following code:</p><div class="informalexample"><pre class="programlisting">@Component('anAmazingUserService')
public class UserService {</pre></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>There's more…</h2></div></div></div><p>If the <code class="literal">UserService</code> bean requires some custom initialization, for example, based on the current <a id="id109" class="indexterm"/>environment, it's possible to define and initialize the bean explicitly as explained in the previous recipe, <span class="emphasis"><em>Defining a bean explicitly with @Bean</em></span>.</p><p><code class="literal">@Controller</code>, <code class="literal">@Service</code>, and <code class="literal">@Repository</code> are also component annotations; Spring will automatically instantiate a bean at startup from the classes annotated with them. It's not strictly necessary to use these component annotations, but they make the role of the component class clearer; <code class="literal">@Controller</code> is used for controller classes, <code class="literal">@Service</code> is used for service classes (so that's the one we would actually use for our <code class="literal">UserService</code> class), and <code class="literal">@Repository</code> is used for persistence classes. They <a id="id110" class="indexterm"/>also add minor extra functionality to the component classes. Refer to <a class="ulink" href="http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-stereotype-annotations">http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/beans.html#beans-stereotype-annotations</a>.</p></div></div>
<div class="section" title="Using a bean via dependency injection with @Autowired"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Using a bean via dependency injection with @Autowired</h1></div></div></div><p>Spring configuration beans, such as the one in the <span class="emphasis"><em>Defining a bean explicitly with @Bean</em></span> recipe are <a id="id111" class="indexterm"/>automatically discovered and used by Spring. To<a id="id112" class="indexterm"/> use a bean (any kind of bean) in one of your<a id="id113" class="indexterm"/> classes, add the bean as a field and annotate it with <code class="literal">@Autowired</code>. Spring will automatically initialize the field with the bean. In this recipe, we'll use an existing bean in a controller class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Getting ready</h2></div></div></div><p>We will use the code from the <span class="emphasis"><em>Defining a bean implicitly with @Component</em></span> recipe, where we defined a <code class="literal">UserService</code> bean.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>How to do it…</h2></div></div></div><p>Here are the steps to use an existing bean in one of your classes:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the controller class, add a <code class="literal">UserService</code> field annotated with <code class="literal">@Autowired</code>:<div class="informalexample"><pre class="programlisting">@Autowired
UserService userService;</pre></div></li><li class="listitem">In a controller method, use the <code class="literal">UserService</code> field:<div class="informalexample"><pre class="programlisting">@RequestMapping("hi")
@ResponseBody
public String hi() {
  return "nb of users: " + <span class="strong"><strong>userService.findNumberOfUsers()</strong></span>;
}</pre></div></li><li class="listitem">In a web browser, go to <code class="literal">http://localhost:8080/hi</code> to check whether it's working.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec33"/>How it works…</h2></div></div></div><p>When the controller class is instantiated, Spring automatically initializes the <code class="literal">@Autowired</code> field with the existing <code class="literal">UserService</code> bean. This is called dependency injection; the controller class simply declares its dependency, a <code class="literal">UserService</code> field. It's Spring that initializes the field by injecting a <code class="literal">UserService</code> object into it.</p><p>If Spring is not able to find an existing bean for that dependency, an exception is thrown.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec34"/>There's more…</h2></div></div></div><p>It's possible to <a id="id114" class="indexterm"/>set the name of the bean to be used:</p><div class="informalexample"><pre class="programlisting">@Autowired("myUserService")
UserService userService;</pre></div><p>Dependency injection is useful when interfaces are used. For example, we could replace our <code class="literal">UserService</code> class by a <code class="literal">UserService</code> interface and its implementation <code class="literal">UserServiceImpl</code>. Everything would work the same, except that it's now simple to swap <code class="literal">UserServiceImpl</code> for another class, for example, for unit testing purposes.</p></div></div>
<div class="section" title="Using a bean directly"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using a bean directly</h1></div></div></div><p>It's possible to get a bean directly from Spring instead of using dependency injection by making Spring's <code class="literal">ApplicationContext</code>, which contains all the beans, a dependency of your class. In<a id="id115" class="indexterm"/> this recipe, we'll inject an existing bean into a controller class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Getting ready</h2></div></div></div><p>We will use the code from the <span class="emphasis"><em>Defining a bean implicitly with @Component</em></span> recipe, where we defined a <code class="literal">UserService</code> bean.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>How to do it…</h2></div></div></div><p>Here are the steps to get and use a bean directly:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the controller class, add an <code class="literal">ApplicationContext</code> field annotated with <code class="literal">@Autowired</code>:<div class="informalexample"><pre class="programlisting">@Autowired
private ApplicationContext applicationContext;</pre></div></li><li class="listitem">In a controller method, use the <code class="literal">ApplicationContext</code> object and its <code class="literal">getBean()</code> method to retrieve the <code class="literal">UserService</code> bean:<div class="informalexample"><pre class="programlisting">UserService userService = (UserService)applicationContext.<span class="strong"><strong>getBean(</strong></span>"userService"<span class="strong"><strong>)</strong></span>;        </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>How it works…</h2></div></div></div><p>When the controller class is instantiated, Spring automatically initializes the <code class="literal">@Autowired</code> field with its <code class="literal">ApplicationContext</code> object. The <code class="literal">ApplicationContext</code> object references all Spring beans, so we can get a bean directly using its name.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>There's more…</h2></div></div></div><p>It's possible to get a bean by its class, without knowing its name.</p><div class="informalexample"><pre class="programlisting">applicationContext.getBean(UserService.class);  </pre></div></div></div>
<div class="section" title="Listing all beans"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Listing all beans</h1></div></div></div><p>It can be <a id="id116" class="indexterm"/>useful, especially for debugging purposes, to list all the beans at a given moment.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>Getting ready</h2></div></div></div><p>We will use the code from the <span class="emphasis"><em>Defining a bean implicitly with @Component</em></span> recipe, where we defined a <code class="literal">UserService</code> bean.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How to do it…</h2></div></div></div><p>Here are the steps to retrieve the names of the beans currently in Spring's <code class="literal">ApplicationContext</code> object:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In your class, add an <code class="literal">ApplicationContext</code> field annotated with <code class="literal">@Autowired</code>:<div class="informalexample"><pre class="programlisting">@Autowired
private ApplicationContext applicationContext;</pre></div></li><li class="listitem">In a method of that class, use <code class="literal">ApplicationContext</code> and its <code class="literal">getBeanDefinitionNames()</code>method to get the list of bean names:<div class="informalexample"><pre class="programlisting">String[] beans = applicationContext.getBeanDefinitionNames();
for (String bean : beans) {
  System.out.println(bean);
}  </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How it works…</h2></div></div></div><p>When the controller class is instantiated, Spring automatically initializes the <code class="literal">@Autowired</code> field with its <code class="literal">ApplicationContext</code> object. The <code class="literal">ApplicationContext</code> object references<a id="id117" class="indexterm"/> all Spring beans, so we can get a list of all the beans that are using it.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>There's more…</h2></div></div></div><p>To retrieve<a id="id118" class="indexterm"/> the bean itself from its name, use the <code class="literal">getBean()</code> method:</p><div class="informalexample"><pre class="programlisting">applicationContext.getBean("aBeanName");</pre></div></div></div>
<div class="section" title="Using multiple configuration classes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Using multiple configuration classes</h1></div></div></div><p>A Spring configuration class can get quite long with many bean definitions. At this point, it can be <a id="id119" class="indexterm"/>convenient to break it into multiple classes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>Getting ready</h2></div></div></div><p>We will use the code from the <span class="emphasis"><em>Defining a bean explicitly with @Bean</em></span> recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How to do it…</h2></div></div></div><p>Here's how to add a second configuration class:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new configuration class, for example, <code class="literal">DatabaseConfig</code> in the <code class="literal">com.springcookbook.config</code> package:<div class="informalexample"><pre class="programlisting">@Configuration
public class DatabaseConfig {
…</pre></div></li><li class="listitem">In the <code class="literal">ServletInitializer</code> class, add the <code class="literal">DatabaseConfig</code> class in the <code class="literal">getServletConfigClasses()</code> method:<div class="informalexample"><pre class="programlisting">@Override
protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class&lt;?&gt;[]{AppConfig.class, DatabaseConfig.class};
}</pre></div></li><li class="listitem">Move the <code class="literal">Datasource</code> bean from the <code class="literal">AppConfig</code> class to <code class="literal">DatabaseConfig</code>.</li></ol></div></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>There's more…</h2></div></div></div><p>If you are<a id="id120" class="indexterm"/> using a Spring application without a <code class="literal">ServletInitializer</code> class, you can include other configuration classes from your primary configuration class:</p><div class="informalexample"><pre class="programlisting">@Configuration
@Import({ DatabaseConfig.class, SecurityConfig.class })
public class AppConfig {
…
}</pre></div></div></div></body></html>