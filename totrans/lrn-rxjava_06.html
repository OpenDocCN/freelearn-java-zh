<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Concurrency and Parallelization</h1>
                </header>
            
            <article>
                
<p>The need for concurrency has grown rapidly in the past 10 years and has become a necessity for every professional Java programmer. Concurrency (also called <strong>multithreading</strong>) is essentially multitasking, where you have several processes executing at the same time. If you want to fully utilize your hardware's computing power (whether it is a phone, server, laptop, or desktop computer), you need to learn how to multithread and leverage concurrency. Thankfully, RxJava makes concurrency much easier and safer to achieve.</p>
<p>In this chapter, we will cover the following:</p>
<ul>
<li>An overview of concurrency and its necessity</li>
<li><kbd>subscribeOn()</kbd></li>
<li><kbd>observeOn()</kbd></li>
<li>Parallelization</li>
<li><kbd>unsubscribeOn()</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why concurrency is necessary</h1>
                </header>
            
            <article>
                
<p>In simpler times, computers had only one CPU and this marginalized the need for concurrency. Hardware manufacturers successfully found ways to make CPUs faster, and this made single-threaded programs faster. But eventually, this had a diminishing return, and manufacturers found they could increase computational power by putting multiple CPUs in a device. From desktops and laptops to servers and smartphones, most hardware nowadays sports multiple CPUs, or cores.</p>
<p>For developers, this is a major disruption in building software and how coding is done. Single-threaded software is easier to code and works fine on a single-core device. But a single-threaded program on a multi-core device will only use one core, leaving the others not utilized. If you want your program to scale, it needs to be coded in a way that utilizes all cores available in a processor.</p>
<p>However, concurrency is traditionally not easy to implement. If you have several independent processes that do not interact with each other, it is easier to accomplish. But when resources, especially mutable objects, are shared across different threads and processes, chaos can ensue if locking and synchronization are not carefully implemented. Not only can threads race each other chaotically to read and change an object's properties, but a thread may simply not see a value changed by another thread! This is why you should strive to make your objects immutable and make as many properties and variables <kbd>final</kbd> as possible. This ensures that properties and variables are thread-safe and anything that is mutable should be synchronized or at least utilize the <kbd>volatile</kbd> keyword.</p>
<p>Thankfully, RxJava makes concurrency and multithreading much easier and safer. There are ways you can undermine the safety it provides, but generally, RxJava handles concurrency safely for you mainly using two operators: <kbd>subscribeOn()</kbd> and <kbd>observeOn()</kbd>.  As we will find out in this chapter, other operators such as <kbd>flatMap()</kbd> can be combined with these two operators to create powerful concurrency dataflows.</p>
<div class="packt_infobox">While RxJava can help you make safe and powerful concurrent applications with little effort, it can be helpful to be aware of the traps and pitfalls in multithreading. Joshua Bloch's famous book <em>Effective Java</em> is an excellent resource that every Java developer should have, and it succinctly covers best practices for concurrent applications. If you want deep knowledge in Java concurrency, ensure that you read Brian Goetz' <em>Java Concurrency in Practice</em> as well.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Concurrency in a nutshell</h1>
                </header>
            
            <article>
                
<p>Concurrency, also called <strong>multithreading</strong>, can be applied in a variety of ways. Usually, the motivation behind concurrency is to run more than one task simultaneously in order to get work done faster. As we discussed in the beginning of this book, concurrency can also help our code resemble the real world more, where multiple activities occur at the same time.</p>
<p>First, let's cover some fundamental concepts behind concurrency.</p>
<p>One common application of concurrency is to run different tasks simultaneously. Imagine that you have three yard chores: mow the lawn, trim the trees, and pull the weeds. If you do these three chores by yourself, you can only do one chore at a time. You cannot mow the lawn and trim the trees simultaneously. You have to sequentially mow the lawn first, then trim the trees, then pull the weeds. But if you have a friend to help you, one of you can mow the lawn while the other trims the trees. The first one of you to get done can then move on to the third task: pulling the weeds. This way, these three tasks get done much more quickly.</p>
<p>Metaphorically, you and your friend are <strong>threads</strong>. You do work together. Collectively, you both are a <strong>thread pool</strong> ready to execute tasks. The chores are tasks that are queued for the thread pool, which you can execute two at a time. If you have more threads, your thread pool will have more bandwidth to take on more tasks concurrently. However, depending on how many cores your computer has (as well as the nature of the tasks), you can only have so many threads. Threads are expensive to create, maintain, and destroy, and there is a diminishing return in performance as you create them excessively. That is why it is better to have a thread pool to <em>reuse</em> threads and have them work a queue of tasks. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding parallelization</h1>
                </header>
            
            <article>
                
<p>Parallelization (also called parallelism) is a broad term that could encompass the preceding scenario. In effect, you and your friend are executing two tasks at the same time and are thus processing in parallel. But let's apply parallelization to processing multiple identical tasks at the same time. Take, for example, a grocery store that has 10 customers waiting in a line for checkout. These 10 customers represent 10 tasks that are identical. They each need to check out their groceries. If a cashier represents a thread, we can have multiple cashiers to process these customers more quickly. But like threads, cashiers are expensive. We do not want to create a cashier for each customer, but rather pool a fixed number of cashiers and reuse them. If we have five cashiers, we can process five customers at a time while the rest wait in the queue. The moment a cashier finishes a customer, they can process the next one. </p>
<p>This is essentially what parallelization achieves. If you have 1000 objects and you need to perform an expensive calculation on each one, you can use five threads to process five objects at a time and potentially finish this process five times more quickly. It is critical to pool these threads and reuse them because creating 1000 threads to process these 1000 objects could overwhelm your memory and crash your program.</p>
<p>With a conceptual understanding of concurrency, we will move on to discussing how it is achieved in RxJava.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing RxJava concurrency</h1>
                </header>
            
            <article>
                
<p>Concurrency in RxJava is simple to execute, but somewhat abstract to understand. By default, Observables execute work on the immediate thread, which is the thread that declared the <kbd>Observer</kbd> and subscribed it. In many of our earlier examples, this was the main thread that kicked off our <kbd>main()</kbd> method.</p>
<p>But as hinted in a few other examples, not all Observables will fire on the immediate thread. Remember those times we used <kbd>Observable.interval()</kbd>, as shown in the following code? Let's take a look:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>i </span><span>+ </span><span>" Mississippi"</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">0 Mississippi<br/>1 Mississippi<br/>2 Mississippi<br/>3 Mississippi<br/>4 Mississippi</pre>
<p>This <kbd>Observable</kbd> will actually fire on a thread other than the main one. Effectively, the main thread will kick-off <kbd>Observable.interval(),</kbd> but not wait for it to complete because it is operating on its own separate thread now. This, in fact, makes it a concurrent application because it is leveraging two threads now. If we do not call a <kbd>sleep()</kbd> method to pause the main thread, it will charge to the end of the <kbd>main()</kbd> method and quit the application before the intervals have a chance to fire.</p>
<p>Usually, concurrency is useful only when you have long-running or calculation-intensive processes. To help us learn concurrency without creating noisy examples, we will create a helper method called <kbd>intenseCalculation()</kbd> to emulate a long-running process. It will simply accept any value and then sleep for 0-3 seconds and then return the same value.  Sleeping a thread, or pausing it, is a great way to simulate a busy thread doing work:</p>
<pre style="padding-left: 60px"><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>    </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>    </span><span>return </span><span>value</span><span>;<br/></span><span>}<br/></span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>    </span><span>try </span><span>{<br/></span><span>        </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>    } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>        </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Let's create two Observables with two Observers subscribing to them. In each operation. map each emission to the <kbd>intenseCalculation()</kbd> method in order to slow them down:</p>
<pre style="padding-left: 60px"><span>import </span><span>rx.Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/>import io.reactivex.Observable;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .map(s -&gt; intenseCalculation((s)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>6</span><span>)<br/></span><span>                </span><span>.map(s -&gt; intenseCalculation((s)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Epsilon<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6</pre>
<p>Note how both Observables fire emissions slowly as each one is slowed by 0-3 seconds in the <kbd>map()</kbd> operation. More importantly, note how the first <kbd>Observable</kbd> firing <kbd>Alpha</kbd>, <kbd>Beta</kbd>, <kbd>Gamma</kbd> must finish first and call <kbd>onComplete()</kbd> before firing the second <kbd>Observable</kbd> emitting the numbers <kbd>1</kbd> through <kbd>6</kbd>.  If we fire both Observables at the same time rather than waiting for one to complete before starting the other, we could get this operation done much more quickly.</p>
<p>We can achieve this using the <kbd>subscribeOn()</kbd> operator, which suggests to the source to fire emissions on a specified <kbd>Scheduler</kbd>. In this case, let us use <kbd>Schedulers.computation()</kbd>, which pools a fixed number of threads appropriate for computation operations. It will provide a thread to push emissions for each <kbd>Observer</kbd>. When <kbd>onComplete()</kbd> is called, the thread will be given back to <kbd>Scheduler</kbd> so it can be reused elsewhere:</p>
<pre style="padding-left: 60px"><span>import io.reactivex.Observable;<br/></span><span>import io.reactivex.schedulers.Schedulers;</span><span><br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                </span><span>.map(s -&gt; intenseCalculation((s)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>6</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                </span><span>.map(s -&gt; intenseCalculation((s)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>20000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(long</span><span> </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span><span><br/></span></pre>
<p><span>The output is as follows</span> (yours may be different):</p>
<pre style="padding-left: 60px">1<br/>2<br/>Alpha<br/>3<br/>4<br/>Beta<br/>5<br/>Gamma<br/>Delta<br/>6<br/>Epsilon</pre>
<p>Your output will likely be different from mine due to the random sleeping times. But note how both operations are firing simultaneously now, allowing the program to finish much more quickly. Rather than the main thread becoming occupied, executing emissions for the first <kbd>Observable</kbd> before moving onto the second, it will fire-off both Observables immediately and move on. It will not wait for either <kbd>Observable</kbd> to complete.</p>
<p>Having multiple processes occurring at the same time is what makes an application concurrent. It can result in much greater efficiency as it will utilize more cores and finish work more quickly. Concurrency also makes code models more powerful and more representative of how our world works, where multiple activities occur simultaneously.</p>
<p>Something else that is exciting about RxJava is its operators (at least the official ones and the custom ones built properly). They can work with Observables on different threads safely. Even operators and factories that combine multiple Observables, such as <kbd>merge()</kbd> and <kbd>zip()</kbd>, will safely combine emissions pushed by different threads. For instance, we can use  <kbd>zip()</kbd> on our two Observables in the preceding example even if they are emitting on two separate computation threads:</p>
<pre style="padding-left: 60px"><span>import io.reactivex.Observable;<br/></span><span>import io.reactivex.schedulers.Schedulers;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>source1 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                </span><span>.map(s -&gt; intenseCalculation((s)));<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>source2 </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>6</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                </span><span>.map(s -&gt; intenseCalculation((s)));<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>zip</span><span>(</span><span>source1</span><span>, </span><span>source2</span><span>, (</span><span>s</span><span>,</span><span>i</span><span>) </span>-&gt; <span>s </span><span>+ </span><span>"-" </span><span>+ </span><span>i</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>20000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span><span><br/></span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Alpha-1<br/>Beta-2<br/>Gamma-3<br/>Delta-4<br/>Epsilon-5</pre>
<p>Being able to split and combine Observables happening on different threads is powerful and eliminates the pain points of callbacks. Observables are agnostic to whatever thread they work on, making concurrency easy to implement, configure, and evolve at any time.</p>
<div class="packt_infobox">When you start making reactive applications concurrent, a subtle complication can creep in.  By default, a non-concurrent application will have one thread doing all the work from the source to the final <kbd>Observer</kbd>. But having multiple threads can cause emissions to be produced faster than an <kbd>Observer</kbd> can consume them (for instance, the <kbd>zip()</kbd> operator may have one source producing emissions faster than the other). This can overwhelm the program and memory can run out as backlogged emissions are cached by certain operators. When you are working with a high volume of emissions (more than 10,000) and leveraging concurrency, you will likely want to use Flowables instead of Observables, which we will cover in <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keeping an application alive</h1>
                </header>
            
            <article>
                
<p>Up until this point, we have used a <kbd>sleep()</kbd> method to keep concurrent reactive applications from quitting prematurely, just long enough for the Observables to fire. If you are using Android, JavaFX, or other frameworks that manage their own non-daemon threads, this is not a concern as the application will be kept alive for you. But if you are simply firing off a program with a <kbd>main()</kbd> method and you want to kick off long-running or infinite Observables, you may have to keep the main thread alive for a period longer than 5-20 seconds. Sometimes, you may want to keep it alive indefinitely.</p>
<p>One way to keep an application alive indefinitely is to simply pass <kbd>Long.MAX_VALUE</kbd> to the <kbd>Thread.sleep()</kbd> method, as shown in the following code, where we have <kbd>Observable.interval()</kbd> firing emissions forever:</p>
<pre style="padding-left: 60px"><span>import io.reactivex.Observable;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>l </span>-&gt; <span>intenseCalculation</span><span>((</span><span>l</span><span>)))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>Long</span><span>.</span><span>MAX_VALUE</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span><span><br/></span></pre>
<p>Okay, sleeping your main thread for 9,223,372,036,854,775,807 milliseconds is not forever, but that is the equivalent to  <span class="comment-copy">292,471,208.7</span> years. For the purposes of sleeping a thread, that might as well be forever!</p>
<p>There are ways to keep an application alive only long enough for a subscription to finish. With classical concurrency tools discussed in Brian Goetz' book <em>Java Concurrency in Practice</em>, you can keep an application alive using <kbd>CountDownLatch</kbd> to wait for two subscriptions to finish. But an easier way is to use blocking operators in RxJava.</p>
<p>You can use blocking operators to stop the declaring thread and wait for emissions. Usually, blocking operators are used for unit testing (as we will discuss in <a href="ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml">Chapter 10</a>, <em>Testing and Debugging</em>), and they can attract antipatterns if used improperly in production. However, keeping an application alive based on the life cycle of a finite <kbd>Observable</kbd> subscription is a valid case to use a blocking operator. As shown here, <kbd>blockingSubscribe()</kbd> can be used in place of <kbd>subscribe()</kbd> to stop and wait for <kbd>onComplete()</kbd> to be called before the main thread is allowed to proceed and exit the application:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>map</span><span>(</span><span>Launcher</span>::<span>intenseCalculation</span><span>)<br/></span><span>                .</span><span>blockingSubscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>,<br/></span><span>                        </span><span>Throwable</span>::<span>printStackTrace</span><span>,<br/></span><span>                        () </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Done!"</span><span>));<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Alpha<br/>Beta<br/>Gamma<br/>Delta<br/>Epsilon<br/>Done!</pre>
<p>We will discuss blocking operators in further detail in <a href="ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml">Chapter 10</a>, <em>Testing and Debugging</em>. For the remainder of this chapter, we will explore concurrency in detail using the <kbd>subscribeOn()</kbd> and <kbd>observeOn()</kbd> operators. But first, we will cover the different <kbd>Scheduler</kbd> types available in RxJava.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding Schedulers</h1>
                </header>
            
            <article>
                
<p>As discussed earlier, thread pools are a collection of threads. Depending on the policy of that thread pool, threads may be persisted and maintained so they can be reused. A queue of tasks is then executed by that thread pool.</p>
<p>Some thread pools hold a fixed number of threads (such as the  <kbd>computation()</kbd> one we used earlier), while others dynamically create and destroy threads as needed. Typically in Java, you use an <kbd>ExecutorService</kbd> as your thread pool. However, RxJava implements its own concurrency abstraction called <kbd>Scheduler</kbd>.  It define methods and rules that an actual concurrency provider such as an <kbd>ExecutorService</kbd> or actor system must obey. The construct flexibly makes RxJava non-opinionated on the source of concurrency.</p>
<p>Many of the default <kbd>Scheduler</kbd> implementations can be found in the <kbd>Schedulers</kbd> static factory class. For a given <kbd>Observer</kbd>, a <kbd>Scheduler</kbd> will provide a thread from its pool that will push the emissions. When <kbd>onComplete()</kbd> is called, the operation will be disposed of and the thread will be given back to the pool, where it may be persisted and reused by another <kbd>Observer</kbd>.</p>
<div class="packt_infobox">To keep this book practical, we will only look at Schedulers in their natural environment: being used with <kbd>subscribeOn()</kbd> and <kbd>observeOn()</kbd>. If you want to learn more about Schedulers and how they work in isolation, refer to Appendix X to learn more.</div>
<p>Here are a few Scheduler types in RxJava. There are also some common third-party ones available in other libraries such as RxAndroid (covered in <a href="4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml">Chapter 11</a>, <em>RxJava for Android</em>) and RxJavaFX (covered later in this chapter).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Computation</h1>
                </header>
            
            <article>
                
<p>We already saw the computation <kbd>Scheduler</kbd>, which you can get the global instance of by calling <kbd>Schedulers.computation()</kbd>. This will maintain a fixed number of threads based on the processor count available to your Java session, making it appropriate for computational tasks. Computational tasks (such as math, algorithms, and complex logic) may utilize cores to their fullest extent. Therefore, there is no benefit in having more worker threads than available cores to perform such work, and the computational <kbd>Scheduler</kbd> will ensure that:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>    .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>());</span></pre>
<p>When you are unsure how many tasks will be executed concurrently or are simply unsure which <kbd>Scheduler</kbd> is the right one to use, prefer the computation one by default.</p>
<div class="packt_infobox">A number of operators and factories will use the computation <kbd>Scheduler</kbd> by default unless you specify a different one as an argument. These include one or more overloads for <kbd>interval()</kbd>, <kbd>delay()</kbd>, <kbd>timer()</kbd>, <kbd>timeout()</kbd>, <kbd>buffer()</kbd>, <kbd>take()</kbd>, <kbd>skip()</kbd>, <kbd>takeWhile()</kbd>, <kbd>skipWhile()</kbd>, <kbd>window()</kbd>, and a few others.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IO</h1>
                </header>
            
            <article>
                
<p>IO tasks such as reading and writing databases, web requests, and disk storage are less expensive on the CPU and often have idle time waiting for the data to be sent or come back. This means you can create threads more liberally, and <kbd>Schedulers.io()</kbd> is appropriate for this. It will maintain as many threads as there are tasks and will dynamically grow, cache, and reduce the number of threads as needed. For instance, you may use <kbd>Schedulers.io()</kbd> to perform SQL operations using RxJava-JDBC (<a href="https://github.com/davidmoten/rxjava-jdbc">https://github.com/davidmoten/rxjava-jdbc</a>):</p>
<pre style="padding-left: 60px"><span> Database db = Database.from(conn);<br/><br/> Observable&lt;String&gt; customerNames = <br/>     db.select("SELECT NAME FROM CUSTOMER")<br/>         .getAs(String.class)<br/>         .subscribeOn(Schedulers.io());<br/></span></pre>
<p>But you have to be careful! As a rule of thumb, assume that each subscription will result in a new thread.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New thread</h1>
                </header>
            
            <article>
                
<p>The <kbd>Schedulers.newThread()</kbd> factory will return a <kbd>Scheduler</kbd> that does not pool threads at all. It will create a new thread for each <kbd>Observer</kbd> and then destroy the thread when it is done. This is different than <kbd>Schedulers.io()</kbd> because it does not attempt to persist and cache threads for reuse:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>  .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>newThread</span><span>());</span></pre>
<p>This may be helpful in cases where you want to create, use, and then destroy a thread immediately so it does not take up memory. But for complex applications generally, you will want to use <kbd>Schedulers.io()</kbd> so there is some attempt to reuse threads if possible.  You also have to be careful as  <kbd>Schedulers.newThread()</kbd> can run amok in complex applications (as can <kbd>Schedulers.io()</kbd>) and create a high volume of threads, which could crash your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single</h1>
                </header>
            
            <article>
                
<p>When you want to run tasks sequentially on a single thread, you can invoke <kbd>Schedulers.single()</kbd>. This is backed by a single-threaded implementation appropriate for event looping. It can also be helpful to isolate fragile, non-threadsafe operations to a single thread:</p>
<pre style="padding-left: 60px"><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span> .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>single</span><span>());</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trampoline</h1>
                </header>
            
            <article>
                
<p><kbd>Schedulers.trampoline()</kbd> is an interesting <kbd>Scheduler</kbd>. In practicality, you will not invoke it often as it is used primarily in RxJava's internal implementation. Its pattern is also borrowed for UI Schedulers such as RxJavaFX and RxAndroid. It is just like default scheduling on the immediate thread, but it prevents cases of recursive scheduling where a task schedules a task while on the same thread. Instead of causing a stack overflow error, it will allow the current task to finish and <em>then</em> execute that new scheduled task afterward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ExecutorService</h1>
                </header>
            
            <article>
                
<p>You can build a Scheduler off a standard Java <kbd>ExecutorService</kbd>. You may choose to do this in order to have more custom and fine-tuned control over your thread management policies. For example, say, we want to create a Scheduler that uses 20 threads. We can create a new fixed <kbd>ExecutorService</kbd> specified with this number of threads. Then, you can wrap it inside a <kbd>Scheduler</kbd> implementation by calling <kbd>Schedulers.from()</kbd>:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.</span><span>Scheduler</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>ExecutorService</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>Executors</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>int </span><span>numberOfThreads </span><span>= 20;</span><span><br/></span><span><br/></span><span>        </span><span>ExecutorService </span><span>executor </span><span>=<br/></span><span>                </span><span>Executors</span><span>.</span><span>newFixedThreadPool</span><span>(</span><span>numberOfThreads</span><span>);<br/></span><span><br/></span><span>        </span><span>Scheduler </span><span>scheduler </span><span>= </span><span>Schedulers</span><span>.</span><span>from</span><span>(</span><span>executor</span><span>);<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>scheduler</span><span>)<br/></span><span>                .</span><span>doFinally</span><span>(</span><span>executor</span>::<span>shutdown</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span>    }<br/></span><span>}</span></pre>
<p><kbd>ExecutorService</kbd> will likely keep your program alive indefinitely, so you have to manage its disposal if its life is supposed to be finite. If I only wanted to support the life cycle of one <kbd>Observable</kbd> subscription, I need to call its <kbd>shutdown()</kbd> method. That is why I called its <kbd>shutdown()</kbd> method after the operation terminates or disposes via the <kbd>doFinally()</kbd> operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Starting and shutting down Schedulers</h1>
                </header>
            
            <article>
                
<p>Each default <kbd>Scheduler</kbd> is lazily instantiated when you first invoke its usage. You can dispose the <kbd>computation()</kbd>, <kbd>io()</kbd>, <kbd>newThread()</kbd>, <kbd>single()</kbd>, and <kbd>trampoline()</kbd> Schedulers at any time by calling their <kbd>shutdown()</kbd> method or all of them by calling <kbd>Schedulers.shutdown()</kbd>. This will stop all their threads and forbid new tasks from coming in and will throw an error if you try otherwise. You can also call their <kbd>start()</kbd> method, or <kbd>Schedulersers.start()</kbd>, to reinitialize the Schedulers so they can accept tasks again.</p>
<div class="packt_tip">In desktop and mobile app environments, you should not run into many cases where you have to start and stop the Schedulers. On the server side, however, J2EE-based applications (for example, Servlets) may get unloaded and reloaded and use a different classloader, causing the old Schedulers instances to leak. To prevent this from occurring, the Servlet should shut down the <kbd>Schedulers</kbd> manually in its <kbd>destroy()</kbd> method.</div>
<p>Only manage the life cycle of your Schedulers if you absolutely have to. It is better to let the Schedulers dynamically manage their usage of resources and keep them initialized and available so tasks can quickly be executed at a moment's notice. Note carefully that it is better to ensure that all outstanding tasks are completed or disposed of before you shut down the Schedulers, or else you may leave the sequences in an inconsistent state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding subscribeOn()</h1>
                </header>
            
            <article>
                
<p>We kind of touched on using <kbd>subscribeOn()</kbd> already, but in this section, we will explore it in more detail and look at how it works.</p>
<p>The <kbd>subscribeOn()</kbd> operator will suggest to the source <kbd>Observable</kbd> upstream which <kbd>Scheduler</kbd> to use and how to execute operations on one of its threads. If that source is not already tied to a particular <kbd>Scheduler</kbd>, it will use the <kbd>Scheduler</kbd> you specify. It will then push emissions <em>all the way</em> to the final <kbd>Observer</kbd> using that thread (unless you add <kbd>observeOn()</kbd> calls, which we will cover later). You can put <kbd>subscribeOn()</kbd> anywhere in the <kbd>Observable</kbd> chain, and it will suggest to the upstream all the way to the origin <kbd>Observable</kbd> which thread to execute emissions with.</p>
<p>In the following example, it makes no difference whether you put this <kbd>subscribeOn()</kbd> right after <kbd>Observable.just()</kbd> or after one of the operators. The <kbd>subscribeOn()</kbd> will communicate upstream to the <kbd>Observable.just()</kbd> which <kbd>Scheduler</kbd> to use no matter where you put it. For clarity, though, you should place it as close to the source as possible:</p>
<pre style="padding-left: 60px"><span>//All three accomplish the same effect with subscribeOn()<br/><br/>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>        .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>()) //preferred<br/></span><span>        .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>        .</span><span>filter</span><span>(</span><span>i </span>-&gt; <span>i </span><span>&gt; </span><span>5</span><span>)<br/></span><span>        .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/><br/>Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")<br/>        .map(String::length)<br/>        .subscribeOn(Schedulers.computation())<br/>        .filter(i -&gt; i &gt; 5)<br/>        .subscribe(System.out::println);<br/><br/>Observable.just("Alpha", "Beta", "Gamma", "Delta", "Epsilon")<br/>        .map(String::length)<br/>        .filter(i -&gt; i &gt; 5)<br/>        .subscribeOn(Schedulers.computation())<br/>        .subscribe(System.out::println);<br/><br/></span></pre>
<p>Having multiple Observers to the same <kbd>Observable</kbd> with <kbd>subscribeOn()</kbd> will result in each one getting its own thread (or have them waiting for an available thread if none are available). In the <kbd>Observer</kbd>, you can print the executing thread's name by calling <kbd>Thread.currentThread().getName()</kbd>. We will print that with each emission to see that two threads, in fact, are being used for both Observers:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>lengths </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>map</span><span>(</span><span>Launcher</span>::<span>intenseCalculation</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>);<br/></span><span><br/></span><span>        </span><span>lengths</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt;<br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread " </span><span>+<br/></span><span>                        </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>lengths</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt;<br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread " </span><span>+<br/></span><span>                        </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>10000</span><span>);<br/></span><span><br/></span><span>    }<br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Received 5 on thread RxComputationThreadPool-2<br/>Received 4 on thread RxComputationThreadPool-2<br/>Received 5 on thread RxComputationThreadPool-2<br/>Received 5 on thread RxComputationThreadPool-2<br/>Received 5 on thread RxComputationThreadPool-1<br/>Received 7 on thread RxComputationThreadPool-2<br/>Received 4 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1</pre>
<p>Note how one <kbd>Observer</kbd> is using a thread named <kbd>RxComputationThreadPool-2</kbd>, while the other is using <kbd>RxComputationThreadPool-1</kbd>. These names indicate which <kbd>Scheduler</kbd> they came from (which is the <kbd>Computation</kbd> one) and what their index is. As shown here, if we want only one thread to serve both Observers, we can multicast this operation. Just make sure <kbd>subscribeOn()</kbd> is before the multicast operators:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Integer</span><span>&gt; </span><span>lengths </span><span>=<br/></span><span>                </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>map</span><span>(</span><span>Launcher</span>::<span>intenseCalculation</span><span>)<br/></span><span>                .</span><span>map</span><span>(</span><span>String</span>::<span>length</span><span>)<br/></span><span>                .</span><span>publish</span><span>()<br/></span><span>                .</span><span>autoConnect</span><span>(</span><span>2</span><span>);<br/></span><span><br/></span><span>        </span><span>lengths</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt;<br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread " </span><span>+<br/></span><span>                        </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>lengths</span><span>.</span><span>subscribe</span><span>(</span><span>i </span>-&gt;<br/><span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread " </span><span>+<br/></span><span>                        </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>10000</span><span>);<br/></span><span><br/></span><span>    }<br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Received 5 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1<br/>Received 4 on thread RxComputationThreadPool-1<br/>Received 4 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1<br/>Received 5 on thread RxComputationThreadPool-1</pre>
<p>Most <kbd>Observable</kbd> factories, such as <kbd>Observable.fromIterable()</kbd> and <kbd>Observable.just()</kbd>, will emit items on the <kbd>Scheduler</kbd> specified by <kbd>subscribeOn()</kbd>. For factories such as <kbd>Observable.fromCallable()</kbd> and <kbd>Observable.defer()</kbd>, the initialization of these sources will also run on the specified <kbd>Scheduler</kbd> when using <kbd>subscribeOn()</kbd>. For instance, if you use <kbd>Observable.fromCallable()</kbd> to wait on a URL response, you can actually do that work on the IO Scheduler so the main thread is not blocking and waiting for it:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.net.URL</span><span>;<br/></span><span>import </span><span>java.util.Scanner</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>fromCallable</span><span>(() </span>-&gt;<br/><span>getResponse</span><span>(</span><span>"https://api.github.com/users/thomasnield/starred"</span><span>)<br/></span><span>        ).</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>         .</span><span>subscribe</span><span>(</span><span>System</span><span>.</span><span>out</span>::<span>println</span><span>);<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>10000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>private static </span><span>String </span><span>getResponse</span><span>(</span><span>String </span><span>path</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>return new </span><span>Scanner</span><span>(</span><span>new </span><span>URL</span><span>(</span><span>path</span><span>).</span><span>openStream</span><span>(), </span><span>"UTF-8"</span><span>).</span><span>useDelimiter</span><span>(</span><span>"</span><span>\\</span><span>A"</span><span>).</span><span>next</span><span>();<br/></span><span>        } </span><span>catch </span><span>(</span><span>Exception </span><span>e</span><span>) {<br/></span><span>            </span><span>return </span><span>e</span><span>.</span><span>getMessage</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">[{"id":23095928,"name":"RxScala","full_name":"ReactiveX/RxScala","o ....</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nuances of subscribeOn()</h1>
                </header>
            
            <article>
                
<p>It is important to note that  <kbd>subscribeOn()</kbd> will have no practical effect with certain sources (and will keep a worker thread unnecessarily on standby until that operation terminates). This might be because these Observables already use a specific <kbd>Scheduler</kbd>, and if you want to change it, you can provide a <kbd>Scheduler</kbd> as an argument. For example, <kbd>Observable.interval()</kbd> will use <kbd>Schedulers.computation()</kbd> and will ignore any <kbd>subscribeOn()</kbd>you specify otherwise. But you can provide a third argument to specify a different <kbd>Scheduler</kbd> to use. Here, I specify <kbd>Observable.interval()</kbd> to use <kbd>Schedulers.newThread()</kbd>, as shown here:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>, </span><span>Schedulers</span><span>.</span><span>newThread</span><span>())<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+<br/></span><span>                        </span><span>" on thread " </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/></span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Received 0 on thread RxNewThreadScheduler-1<br/>Received 1 on thread RxNewThreadScheduler-1<br/>Received 2 on thread RxNewThreadScheduler-1<br/>Received 3 on thread RxNewThreadScheduler-1<br/>Received 4 on thread RxNewThreadScheduler-1</pre>
<p>This also brings up another point: if you have multiple <kbd>subscribeOn()</kbd> calls on a given <kbd>Observable</kbd> chain, the top-most one, or the one closest to the source, will win and cause any subsequent ones to have no practical effect (other than unnecessary resource usage). If I call <kbd>subscribeOn()</kbd> with <kbd>Schedulers.computation()</kbd> and then call <kbd>subscribeOn()</kbd> for  <kbd>Schedulers.io()</kbd>, <kbd>Schedulers.computation()</kbd> is the one that will be used:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, </span><span>"Epsilon"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>length</span><span>() </span><span>== </span><span>5</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+<br/></span><span>                       </span><span>" on thread " </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Received Alpha on thread RxComputationThreadPool-1<br/>Received Gamma on thread RxComputationThreadPool-1<br/>Received Delta on thread RxComputationThreadPool-1</pre>
<p>This can happen when an API returns an <kbd>Observable</kbd> already preapplied with a <kbd>Scheduler</kbd> via <kbd>subscribeOn()</kbd>, although the consumer of the API wants a different <kbd>Scheduler</kbd>. API designers are, therefore, encouraged to provide methods or overloads that allow parameterizing which <kbd>Scheduler</kbd> to use, just like RxJava's Scheduler-dependent operators (for example,  <kbd>Observable.interval()</kbd>).</p>
<p>In summary, <kbd>subscribeOn()</kbd> specifies which <kbd>Scheduler</kbd> the source <kbd>Observable</kbd> should use, and it will use a worker from this <kbd>Scheduler</kbd> to push emissions all the way to the final <kbd>Observer</kbd>. Next, we will learn about <kbd>observeOn()</kbd>, which switches to a different <kbd>Scheduler</kbd> at that point in the <kbd>Observable</kbd> chain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding observeOn()</h1>
                </header>
            
            <article>
                
<p>The <kbd>subscribeOn()</kbd> operator instructs the source <kbd>Observable</kbd> which <kbd>Scheduler</kbd> to emit emissions on. If <kbd>subscribeOn()</kbd> is the only concurrent operation in an <kbd>Observable</kbd> chain,  the thread from that <kbd>Scheduler</kbd> will work the entire <kbd>Observable</kbd> chain, pushing emissions from the source all the way to the final <kbd>Observer</kbd>. The <kbd>observeOn()</kbd> operator, however, will intercept emissions at that point in the <kbd>Observable</kbd> chain and switch them to a different <kbd>Scheduler</kbd> going forward.</p>
<p>Unlike <kbd>subscribeOn()</kbd>, the placement of <kbd>observeOn()</kbd> matters. It will leave all operations upstream on the default or <kbd>subscribeOn()</kbd>-defined <kbd>Scheduler</kbd>, but will switch to a different <kbd>Scheduler</kbd> downstream. Here, I can have an <kbd>Observable</kbd> emit a series of strings that are <kbd>/</kbd>-separated values and break them up on an IO <kbd>Scheduler</kbd>. But after that, I can switch to a computation <kbd>Scheduler</kbd> to filter only numbers and calculate their sum, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>//Happens on IO Scheduler<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"WHISKEY/27653/TANGO"</span><span>, </span><span>"6555/BRAVO"</span><span>, </span><span>"232352/5675675/FOXTROT"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                .</span><span>flatMap</span><span>(</span><span>s </span>-&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>"/"</span><span>)))<br/></span><span><br/></span><span>                </span><span>//Happens on Computation Scheduler<br/></span><span>                </span><span>.</span><span>observeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>matches</span><span>(</span><span>"[0-9]+"</span><span>))<br/></span><span>                .</span><span>map</span><span>(</span><span>Integer</span>::<span>valueOf</span><span>)<br/></span><span>                .</span><span>reduce</span><span>((</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread "<br/></span><span>                        </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>1000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows:</span></p>
<pre style="padding-left: 60px">Received 5942235 on thread RxComputationThreadPool-1</pre>
<p>Of course, this example is not computationally intensive, and in real life, it should be done on a single thread. The overhead of concurrency that we introduced is not warranted, but let's pretend it is a long-running process.</p>
<p>Again, use <kbd>observeOn()</kbd> to intercept each emission and push them forward on a different <kbd>Scheduler</kbd>.  In the preceding example, operators before <kbd>observeOn()</kbd> are executed on  <kbd>Scheduler.io()</kbd>, but the ones after it are executed by <kbd>Schedulers.computation()</kbd>. Upstream operators before <kbd>observeOn()</kbd> are not impacted, but downstream ones are.</p>
<p>You might use  <kbd>observeOn()</kbd> for a situation like the one emulated earlier. If you want to read one or more data sources and wait for the response to come back, you will want to do that part on <kbd>Schedulers.io()</kbd> and will likely leverage <kbd>subscribeOn()</kbd> since that is the initial operation. But once you have that data, you may want to do intensive computations with it, and <kbd>Scheduler.io()</kbd> may no longer be appropriate. You will want to constrain these operations to a few threads that will fully utilize the CPU. Therefore, you use <kbd>observeOn()</kbd> to redirect data to  <kbd>Schedulers.computation()</kbd>.</p>
<p>You can actually use multiple <kbd>observeOn()</kbd> operators to switch <kbd>Schedulers</kbd> more than once. Continuing with our earlier example, let's say we want to write our computed sum to a disk and write it in a file. Let's pretend this was a lot of data rather than a single number and we want to get this disk-writing operation off the computation <kbd>Scheduler</kbd> and put it back in the IO <kbd>Scheduler</kbd>. We can achieve this by introducing a second <kbd>observeOn()</kbd>. Let's also add some <kbd>doOnNext() </kbd> and <kbd>doOnSuccess()</kbd> (due to the <kbd>Maybe</kbd>) operators to peek at which thread each operation is using:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.io.BufferedWriter</span><span>;<br/></span><span>import </span><span>java.io.File</span><span>;<br/></span><span>import </span><span>java.io.FileWriter</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span><br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>        </span><span>//Happens on IO Scheduler<br/></span><span>        </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"WHISKEY/27653/TANGO"</span><span>, </span><span>"6555/BRAVO"</span><span>, </span><span>"232352/5675675/FOXTROT"</span><span>)<br/></span><span>                .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                .</span><span>flatMap</span><span>(</span><span>s </span>-&gt; <span>Observable</span><span>.</span><span>fromArray</span><span>(</span><span>s</span><span>.</span><span>split</span><span>(</span><span>"/"</span><span>)))<br/></span><span>                .</span><span>doOnNext</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Split out " </span><span>+ </span><span>s </span><span>+ </span><span>" on thread "<br/></span><span>                        </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()))<br/></span><span><br/></span><span>                </span><span>//Happens on Computation Scheduler<br/></span><span>                </span><span>.</span><span>observeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                .</span><span>filter</span><span>(</span><span>s </span>-&gt; <span>s</span><span>.</span><span>matches</span><span>(</span><span>"[0-9]+"</span><span>))<br/></span><span>                .</span><span>map</span><span>(</span><span>Integer</span>::<span>valueOf</span><span>)<br/></span><span>                .</span><span>reduce</span><span>((</span><span>total</span><span>, </span><span>next</span><span>) </span>-&gt; <span>total </span><span>+ </span><span>next</span><span>)<br/></span><span>                .</span><span>doOnSuccess</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Calculated sum " </span><span>+ </span><span>i </span><span>+ </span><span>" on thread "<br/></span><span>                        </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()))<br/></span><span><br/></span><span>                </span><span>//Switch back to IO Scheduler<br/></span><span>                </span><span>.</span><span>observeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>i</span><span>.</span><span>toString</span><span>())<br/></span><span>                .</span><span>doOnSuccess</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Writing " </span><span>+ </span><span>s </span><span>+ </span><span>" to file on thread "<br/></span><span>                        </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()))<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>write</span><span>(</span><span>s</span><span>,</span><span>"/home/thomas/Desktop/output.txt"</span><span>));<br/></span><span><br/></span><span>        </span><span>sleep</span><span>(</span><span>1000</span><span>);<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>write</span><span>(</span><span>String </span><span>text</span><span>, </span><span>String </span><span>path</span><span>) {<br/></span><span>        </span><span>BufferedWriter </span><span>writer </span><span>= </span><span>null</span><span>;<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>//create a temporary file<br/></span><span>            </span><span>File </span><span>file </span><span>= </span><span>new </span><span>File</span><span>(</span><span>path</span><span>);<br/></span><span>            </span><span>writer </span><span>= </span><span>new </span><span>BufferedWriter</span><span>(</span><span>new </span><span>FileWriter</span><span>(</span><span>file</span><span>));<br/></span><span>            </span><span>writer</span><span>.</span><span>append</span><span>(</span><span>text</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>Exception </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        } </span><span>finally </span><span>{<br/></span><span>            </span><span>try </span><span>{<br/></span><span>                </span><span>writer</span><span>.</span><span>close</span><span>();<br/></span><span>            } </span><span>catch </span><span>(</span><span>Exception </span><span>e</span><span>) {<br/></span><span>            }<br/></span><span>        }<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>int </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Split out WHISKEY on thread RxCachedThreadScheduler-1<br/>Split out 27653 on thread RxCachedThreadScheduler-1<br/>Split out TANGO on thread RxCachedThreadScheduler-1<br/>Split out 6555 on thread RxCachedThreadScheduler-1<br/>Split out BRAVO on thread RxCachedThreadScheduler-1<br/>Split out 232352 on thread RxCachedThreadScheduler-1<br/>Split out 5675675 on thread RxCachedThreadScheduler-1<br/>Split out FOXTROT on thread RxCachedThreadScheduler-1<br/>Calculated sum 5942235 on thread RxComputationThreadPool-1<br/>Writing 5942235 to file on thread RxCachedThreadSchedule</pre>
<p>If you look closely at the output, you will see that the <kbd>String</kbd> emissions were initially pushed and split on the IO <kbd>Scheduler</kbd> via the thread <kbd>RxCachedThreadScheduler-1</kbd>. After that, each emission was switched to the computation <kbd>Scheduler</kbd> and pushed into a sum calculation, which was all done on the thread <kbd>RxComputationThreadPool-1</kbd>. That sum was then switched to the IO <kbd>scheduler</kbd> to be written to a text file (which I specified to output on my Linux Mint desktop), and that work was done on <kbd>RxCachedThreadScheduler-1</kbd> (which happened to be the thread that pushed the initial emissions and was reused!).</p>
<p style="padding-left: 60px"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using observeOn() for UI event threads</h1>
                </header>
            
            <article>
                
<p>When it comes to building mobile apps, desktop applications, and other user experiences, users have little patience for interfaces that hang up or freeze while work is being done. The visual updating of user interfaces is often done by a single dedicated UI thread, and changes to the user interface must be done on that thread. User input events are typically fired on the UI thread as well. If a user input triggers work, and that work is not moved to another thread, that UI thread will become busy. This is what makes the user interface unresponsive, and today's users expect better than this. They want to still interact with the application while work is happening in the background, so concurrency is a must-have.</p>
<p>Thankfully, RxJava can come to the rescue! You can use <kbd>observeOn()</kbd> to move UI events to a computation or IO <kbd>Scheduler</kbd> to do the work, and when the result is ready, move it back to the UI thread with another <kbd>observeOn()</kbd>. This second usage of <kbd>observeOn()</kbd> will put emissions on a UI thread using a custom <kbd>Scheduler</kbd> that wraps around the UI thread. RxJava extension libraries such as RxAndroid (<a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a>), RxJavaFX (<a href="https://github.com/ReactiveX/RxJavaFX">https://github.com/ReactiveX/RxJavaFX</a>), and RxSwing (<a href="https://github.com/ReactiveX/RxSwing">https://github.com/ReactiveX/RxSwing</a>) come with these custom <kbd>Scheduler</kbd> implementations.</p>
<p>For instance, say we have a simple JavaFX application that displays a <kbd>ListView&lt;String&gt;</kbd> of the 50 U.S. states every time a button is clicked on. We can create <kbd>Observable&lt;ActionEvent&gt;</kbd> off the button and then switch to an IO <kbd>Scheduler</kbd> with <kbd>observeOn()</kbd> ( <kbd>subscribeOn()</kbd> will have no effect against UI event sources). We can load the 50 states from a text web response while on the IO <kbd>Scheduler</kbd>. Once the states are returned, we can use another <kbd>observeOn()</kbd> to put them back on <kbd>JavaFxScheduler</kbd>, and safely populate them into <kbd>ListView&lt;String&gt;</kbd> on the JavaFX UI thread:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>javafx.application.</span><span>Application</span><span>;<br/></span><span>import </span><span>javafx.scene.Scene</span><span>;<br/></span><span>import </span><span>javafx.scene.control.Button</span><span>;<br/></span><span>import </span><span>javafx.scene.control.ListView</span><span>;<br/></span><span>import </span><span>javafx.scene.layout.VBox</span><span>;<br/></span><span>import </span><span>javafx.stage.Stage</span><span>;<br/></span><span>import io.reactivex.Observable;<br/>import io.reactivex.rxjavafx.observables.JavaFxObservable;<br/>import io.reactivex.rxjavafx.schedulers.JavaFxScheduler;<br/>import io.reactivex.schedulers.Schedulers;</span><span><br/></span><span>public final class </span><span>JavaFxApp </span><span>extends </span><span>Application</span> <span>{<br/></span><span><br/></span><span>    </span><span>@Override<br/></span><span>    </span><span>public void </span><span>start</span><span>(</span><span>Stage </span><span>stage</span><span>) </span><span>throws </span><span>Exception </span><span>{<br/></span><span><br/></span><span>        </span><span>VBox </span><span>root </span><span>= </span><span>new </span><span>VBox</span><span>();<br/></span><span><br/></span><span>        </span><span>ListView</span><span>&lt;</span><span>String</span><span>&gt; </span><span>listView </span><span>= </span><span>new </span><span>ListView</span><span>&lt;&gt;</span><span>();<br/></span><span>        </span><span>Button </span><span>refreshButton </span><span>= </span><span>new </span><span>Button</span><span>(</span><span>"REFRESH"</span><span>);<br/></span><span><br/></span><span>        </span><span>JavaFxObservable</span><span>.</span><span>actionEventsOf</span><span>(</span><span>refreshButton</span><span>)<br/></span><span>                .</span><span>observeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                .flatMapSingle(a -&gt;<br/>          Observable.fromArray(getResponse("https://goo.gl/S0xuOi")<br/>         .split("\\r?\\n")<br/>          ).toList()</span><span><br/></span><span>                ).</span><span>observeOn</span><span>(</span><span>JavaFxScheduler</span><span>.platform()</span><span>)<br/></span><span>                .</span><span>subscribe</span><span>(</span><span>list </span>-&gt;<br/><span>listView</span><span>.</span><span>getItems</span><span>().</span><span>setAll</span><span>(</span><span>list</span><span>));<br/></span><span><br/></span><span>        </span><span>root</span><span>.</span><span>getChildren</span><span>().</span><span>addAll</span><span>(</span><span>listView</span><span>, </span><span>refreshButton</span><span>);</span><span><br/></span><span>        </span><span>stage</span><span>.</span><span>setScene</span><span>(</span><span>new </span><span>Scene</span><span>(</span><span>root</span><span>));</span><span><br/></span><span>        </span><span>stage</span><span>.</span><span>show</span><span>();<br/></span><span>}<br/></span><span><br/></span><span>    </span><span>private static </span><span>String </span><span>getResponse</span><span>(</span><span>String </span><span>path</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>return new </span><span>Scanner</span><span>(</span><span>new </span><span>URL</span><span>(</span><span>path</span><span>).</span><span>openStream</span><span>(), </span><span>"UTF-8"</span><span>).</span><span>useDelimiter</span><span>(</span><span>"</span><span>\\</span><span>A"</span><span>).</span><span>next</span><span>();<br/></span><span>        } </span><span>catch </span><span>(</span><span>Exception </span><span>e</span><span>) {<br/></span><span>            </span><span>return </span><span>e</span><span>.</span><span>getMessage</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}<br/><br/><br/></span></pre>
<p class="CDPAlignLeft CDPAlign">The code should run the JavaFX application shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="167" width="270" class="image-border" src="assets/cb3da1d9-e11e-47e3-a35a-86be88253a82.png"/></div>
<p> </p>
<p class="CDPAlignLeft CDPAlign"> The preceding screenshot demonstrates that hitting the <span class="packt_screen">REFRESH</span> button will emit an event but switch it to an IO <kbd>Scheduler</kbd> where the work is done to retrieve the U.S. states. When the response is ready, it will emit a <kbd>List&lt;String&gt;</kbd> and put it back on the JavaFX <kbd>Scheduler</kbd> to be displayed in a <kbd>ListView</kbd>.</p>
<p>These concepts apply to Android development as well, and you put all operations affecting the app user interface on <kbd>AndroidSchedulers.mainThread()</kbd> rather than <kbd>JavaFxScheduler.platform()</kbd>. We will cover Android development in <a href="4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml">Chapter 11</a>, <em>RxJava for Android</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Nuances of observeOn()</h1>
                </header>
            
            <article>
                
<p><kbd>observeOn()</kbd>comes with nuances to be aware of, especially when it comes to performance implications due to lack of backpressure, which we will cover in <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure</em>. </p>
<p>Say, you have an <kbd>Observable</kbd> chain with two sets of operations, Operation A and Operation B. Let's not worry what operators each one is using. If you do not have any <kbd>observeOn()</kbd>between them, the operation will pass emissions strictly one at a time from the source to Operation A, then Operation B, and finally to the <kbd>Observer</kbd>. Even with a <kbd>subscribeOn()</kbd>, the source will not pass the next emission down the chain until the current one is passed all the way to the <kbd>Observer</kbd>.</p>
<p>This changes when you introduce an <kbd>observeOn()</kbd> and say we put it between Operation A and Operation B. What happens is after Operation A hands an emission to the <kbd>observeOn(),</kbd> it will immediately start the next emission and not wait for the downstream to finish the current one, including Operation B and the <kbd>Observer</kbd>. This means that the source and Operation A can <em>produce</em> emissions faster than Operation B and the <kbd>Observer</kbd> can <em>consume</em> them. This is a classic producer/consumer scenario where the producer is producing emissions faster than the consumer can consume them. If this is the case, unprocessed emissions will be queued in <kbd>observeOn()</kbd> until the downstream is able to process them. But if you have a lot of emissions, you can potentially run into memory issues.</p>
<p>This is why when you have a flow of 10,000 emissions or more, you will definitely want to use a <kbd>Flowable</kbd> (which supports backpressure) instead of an <kbd>Observable</kbd>. Backpressure communicates upstream all the way to the source to slow down and only produce so many emissions at a time. It restores <em>pull-based</em> requesting of emissions even when complex concurrency operations are introduced. We will cover this in <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parallelization</h1>
                </header>
            
            <article>
                
<p>Parallelization, also called <strong>parallelism</strong> or <strong>parallel computing</strong>, is a broad term that can be used for any concurrent activity (including what we covered). But for the purposes of RxJava, let's define it as processing multiple emissions at a time for a given <kbd>Observable</kbd>. If we have 1000 emissions to process in a given <kbd>Observable</kbd> chain, we might be able to get work done faster if we process eight emissions at a time instead of one. If you recall, the <kbd>Observable</kbd> contract dictates that emissions must be pushed <em>serially</em> down an <kbd>Observable</kbd> chain and never race each other due to concurrency. As a matter of fact, pushing eight emissions down an <kbd>Observable</kbd> chain at a time would be downright catastrophic and wreak havoc. </p>
<p>This seems to put us at odds with what we want to accomplish, but thankfully, RxJava gives you enough operators and tools to be clever. While you cannot push items concurrently on the same <kbd>Observable</kbd>, you are allowed to have multiple Observables running at once, each having its own single thread pushing items through. As we have done throughout this chapter, we created several Observables running on different threads/schedulers and <em>even combined them</em>. You actually have the tools already, and the secret to achieving parallelization is in the <kbd>flatMap()</kbd> operator, which is, in fact, a powerful concurrency operator.</p>
<p>Here, we have an <kbd>Observable</kbd> emitting 10 integers, and we are performing <kbd>intenseCalculation()</kbd> on each one. This process can take a while due to the artificial processing we emulated with <kbd>sleep()</kbd>. Let's print each one with the time in the <kbd>Observer</kbd> so we can measure the performance, as shown in the following code:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.time.LocalTime</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>10</span><span>)<br/></span><span>               .</span><span>map</span><span>(</span><span>i </span>-&gt; <span>intenseCalculation</span><span>(</span><span>i</span><span>))<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" "<br/></span><span>                       </span><span>+ </span><span>LocalTime</span><span>.</span><span>now</span><span>()));<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows<strong> </strong>(yours will be different):</p>
<pre style="padding-left: 60px">Received 1 19:11:41.812<br/>Received 2 19:11:44.174<br/>Received 3 19:11:45.588<br/>Received 4 19:11:46.034<br/>Received 5 19:11:47.059<br/>Received 6 19:11:49.569<br/>Received 7 19:11:51.259<br/>Received 8 19:11:54.192<br/>Received 9 19:11:56.196<br/>Received 10 19:11:58.926</pre>
<p>The randomness causes some variability, of course, but in this instance, it took roughly 17 seconds to complete (although your time will likely vary). We will probably get better performance if we process emissions in parallel, so how do we do that?</p>
<p>Remember, serialization (emitting items one at a time) only needs to happen on the same <kbd>Observable</kbd>. The <kbd>flatMap()</kbd> operator will merge multiple Observables derived off each emission even if they are <em>concurrent</em>. If a light bulb has not gone off yet, read on. In <kbd>flatMap()</kbd>, let's wrap each emission into <kbd>Observable.just()</kbd>, use <kbd>subscribeOn()</kbd> to emit it on  <kbd>Schedulers.computation()</kbd>, and then <kbd>map</kbd> it to the <kbd>intenseCalculation()</kbd>. For good measure, let's print the current thread in the <kbd>Observer</kbd> as well, as shown in the following code:</p>
<pre style="padding-left: 60px"><span>import</span><span> </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.time.LocalTime</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>10</span><span>)<br/></span><span>               .</span><span>flatMap</span><span>(</span><span>i </span>-&gt; <span>Observable</span><span>.</span><span>just</span><span>(</span><span>i</span><span>)<br/></span><span>                       .</span><span>subscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>computation</span><span>())<br/></span><span>                       .</span><span>map</span><span>(</span><span>i2 </span>-&gt; <span>intenseCalculation</span><span>(</span><span>i2</span><span>))<br/></span><span>               )<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" "<br/></span><span>                       </span><span>+ </span><span>LocalTime</span><span>.</span><span>now</span><span>() </span><span>+ </span><span>" on thread "<br/></span><span>                       </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>20000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p><span>The output is as follows </span>(yours will be different):</p>
<pre style="padding-left: 60px">Received 1 19:28:11.163 on thread RxComputationThreadPool-1<br/>Received 7 19:28:11.381 on thread RxComputationThreadPool-7<br/>Received 9 19:28:11.534 on thread RxComputationThreadPool-1<br/>Received 6 19:28:11.603 on thread RxComputationThreadPool-6<br/>Received 8 19:28:11.629 on thread RxComputationThreadPool-8<br/>Received 3 19:28:12.214 on thread RxComputationThreadPool-3<br/>Received 4 19:28:12.961 on thread RxComputationThreadPool-4<br/>Received 5 19:28:13.274 on thread RxComputationThreadPool-5<br/>Received 2 19:28:13.374 on thread RxComputationThreadPool-2<br/>Received 10 19:28:14.335 on thread RxComputationThreadPool-2</pre>
<p>This took three seconds to complete, and you will find that this processes items much faster.  Of course, my computer has eight cores and that is why my output likely indicates that there are eight threads in use. If you have a computer with less cores, this process will take longer and use fewer threads. But it will likely still be faster than the single-threaded implementation we ran earlier.</p>
<p>What we did is we created a <kbd>Observable</kbd> off each emission, used <kbd>subscribeOn()</kbd> to emit it on the computation <kbd>Scheduler</kbd>, and then performed the <kbd>intenseCalculation()</kbd>, which will occur on one of the computation threads. Each instance will request its own thread from the computation <kbd>Scheduler</kbd>, and <kbd>flatMap()</kbd> will merge all of them safely back into a serialized stream.</p>
<div class="packt_infobox">The <kbd>flatMap()</kbd>will only let one thread out of it at a time to push emissions downstream, which maintains that the <kbd>Observable</kbd> contract demanding emissions stays serialized. A neat little behavior with <kbd>flatMap()</kbd> is that it will not use excessive synchronization or blocking to accomplish this. If a thread is already pushing an emission out of <kbd>flatMap()</kbd> downstream toward <kbd>Observer</kbd>, any threads also waiting to push emissions will simply leave their emissions for that occupying thread to take ownership of.</div>
<p>The example here is not necessarily optimal, however. Creating an <kbd>Observable</kbd> for each emission might create some unwanted overhead. There is a leaner way to achieve parallelization, although it has a few more moving parts. If we want to avoid creating excessive <kbd>Observable</kbd> instances, maybe we should split the source <kbd>Observable</kbd> into a fixed number of Observables where emissions are evenly divided and distributed through each one. Then, we can parallelize and merge them with <kbd>flatMap()</kbd>. Even better, since I have eight cores on my computer, maybe it would be ideal that I have <span>eight</span> Observables for <span>eight</span> streams of calculations.</p>
<p>We can achieve this using a <kbd>groupBy()</kbd> trick. If I have eight cores, I want to key each emission to a number in the range 0 through 7. This will yield me <span>eight</span> <kbd>GroupedObservables</kbd> that cleanly divide the emissions into <span>eight</span> streams. More specifically,  I want to cycle through these <span>eight</span> numbers and assign them as a key to each emission. <kbd>GroupedObservables</kbd> are not necessarily impacted by <kbd>subscribeOn()</kbd> (it will emit on the source's thread with the exception of the cached emissions), so I will need to use <kbd>observeOn()</kbd> to parallelize them instead. I can also use an <kbd>io()</kbd> or <kbd>newThread()</kbd> scheduler since I have already constrained the number of workers to the number of cores, simply by constraining the number of <kbd>GroupedObservables</kbd>.</p>
<p>Here is how I do this, but instead of hardcoding for eight cores, I dynamically query the number of cores available:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.time.LocalTime</span><span>;<br/></span><span>import </span><span>java.util.concurrent.ThreadLocalRandom</span><span>;<br/></span><span>import </span><span>java.util.concurrent.atomic.AtomicInteger</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>int </span><span>coreCount </span><span>= </span><span>Runtime</span><span>.</span><span>getRuntime</span><span>().</span><span>availableProcessors</span><span>();<br/></span><span>       </span><span>AtomicInteger </span><span>assigner </span><span>= </span><span>new </span><span>AtomicInteger</span><span>(</span><span>0</span><span>);<br/></span><span>        <br/></span><span>       </span><span>Observable</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span><span>10</span><span>)<br/></span><span>               .</span><span>groupBy</span><span>(</span><span>i </span>-&gt; <span>assigner</span><span>.</span><span>incrementAndGet</span><span>() </span><span>% </span><span>coreCount</span><span>)<br/></span><span>               .</span><span>flatMap</span><span>(</span><span>grp </span>-&gt; <span>grp</span><span>.</span><span>observeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>                       .</span><span>map</span><span>(</span><span>i2 </span>-&gt; <span>intenseCalculation</span><span>(</span><span>i2</span><span>))<br/></span><span>               )<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i </span><span>+ </span><span>" "<br/></span><span>                       </span><span>+ </span><span>LocalTime</span><span>.</span><span>now</span><span>() </span><span>+ </span><span>" on thread "<br/></span><span>                       </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()));<br/></span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>20000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static </span><span>&lt;</span><span>T</span><span>&gt; </span><span>T </span><span>intenseCalculation</span><span>(</span><span>T </span><span>value</span><span>) {<br/></span><span>        </span><span>sleep</span><span>(</span><span>ThreadLocalRandom</span><span>.</span><span>current</span><span>().</span><span>nextInt</span><span>(</span><span>3000</span><span>));<br/></span><span>        </span><span>return </span><span>value</span><span>;<br/></span><span>    }<br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>Here is the output (yours will be different):</p>
<pre style="padding-left: 60px">Received 8 20:27:03.291 on thread RxCachedThreadScheduler-8<br/>Received 6 20:27:03.446 on thread RxCachedThreadScheduler-6<br/>Received 5 20:27:03.495 on thread RxCachedThreadScheduler-5<br/>Received 4 20:27:03.681 on thread RxCachedThreadScheduler-4<br/>Received 7 20:27:03.989 on thread RxCachedThreadScheduler-7<br/>Received 2 20:27:04.797 on thread RxCachedThreadScheduler-2<br/>Received 1 20:27:05.172 on thread RxCachedThreadScheduler-1<br/>Received 9 20:27:05.327 on thread RxCachedThreadScheduler-1<br/>Received 10 20:27:05.913 on thread RxCachedThreadScheduler-2<br/>Received 3 20:27:05.957 on thread RxCachedThreadScheduler-3</pre>
<p>For each emission, I will need to increment the number it groups on, and after it reaches <kbd>7</kbd>, it will start over at <kbd>0</kbd>. This ensures that the emissions are distributed as evenly as possible. We achieve this using <kbd>AtomicInteger</kbd> with a modulus operation. If we keep incrementing <kbd>AtomicInteger</kbd> for each emission, we can divide that result by the numbers of cores, but return the remainder, which will always be a number between <kbd>0</kbd> and <kbd>7</kbd>. </p>
<div class="packt_infobox"><kbd>AtomicInteger</kbd> is just an integer protected inside a <kbd>threadsafe</kbd> container and has convenient <kbd>threadsafe</kbd> methods, such as <kbd>incrementAndGet()</kbd>. Typically, when you have an object or state existing outside an <kbd>Observable</kbd> chain but is modified by the <kbd>Observable</kbd> chain's operations (this is known as creating side effects), that object should be made <kbd>threadsafe</kbd>, especially when concurrency is involved. You can learn more about <kbd>AtomicInteger</kbd> and other utilities in Brian Goetz's <em>Java Concurrency in Practice</em>.</div>
<p>You do not have to use the processor count to control how many <kbd>GroupedObservables</kbd> are created. You can specify any number if you, for some reason, deem that more workers would result in better performance. If your concurrent operations are a mix between IO and computation, and you find that there is more IO, you might benefit from increasing the number of threads/<kbd>GroupedObservables</kbd> allowed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">unsubscribeOn()</h1>
                </header>
            
            <article>
                
<p>One last concurrency operator that we need to cover is  <kbd>unsubscribeOn()</kbd>. When you dispose an <kbd>Observable</kbd>, sometimes, that can be an expensive operation depending on the nature of the source. For instance, if your <kbd>Observable</kbd> is emitting the results of a database query using RxJava-JDBC, (<a href="https://github.com/davidmoten/rxjava-jdbc">https://github.com/davidmoten/rxjava-jdbc</a>) it can be expensive to stop and dispose that <kbd>Observable</kbd> because it needs to shut down the JDBC resources it is using.</p>
<p>This can cause the thread that calls <kbd>dispose()</kbd> to become busy, as it will be doing all the work stopping an <kbd>Observable</kbd> subscription and disposing it. If this is a UI thread in JavaFX or Android (for instance, because a <span class="packt_screen">CANCEL PROCESSING</span> button was clicked), this can cause undesirable UI freezing because the UI thread is working to stop and dispose the <kbd>Observable</kbd> operation.</p>
<p>Here is a simple <kbd>Observable</kbd> that is emitting every one second. We stop the main thread for three seconds, and then it will call <kbd>dispose()</kbd> to shut the operation down. Let's use <kbd>doOnDispose()</kbd> (which will be executed by the disposing thread) to see that the main thread is indeed disposing of the operation:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Disposable </span><span>d </span><span>= </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>               .</span><span>doOnDispose</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Disposing on thread "<br/></span><span>                       </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()))<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>3000</span><span>);</span><span><br/></span><span>       </span><span>d</span><span>.</span><span>dispose</span><span>();</span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Received 0<br/>Received 1<br/>Received 2<br/>Disposing on thread main</pre>
<p>Let's add <kbd>unsubscribeOn()</kbd> and specify to unsubscribe on <kbd>Schedulers.io()</kbd>. You should put <kbd>unsubscribeOn()</kbd> wherever you want all operations upstream to be affected:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>io.reactivex.disposables.</span><span>Disposable</span><span>;<br/></span><span>import </span><span>io.reactivex.schedulers.Schedulers</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>    </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span><br/></span><span>       </span><span>Disposable </span><span>d </span><span>= </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>)<br/></span><span>               .</span><span>doOnDispose</span><span>(() </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Disposing on thread "<br/></span><span>                       </span><span>+ </span><span>Thread</span><span>.</span><span>currentThread</span><span>().</span><span>getName</span><span>()))<br/></span><span>               .</span><span>unsubscribeOn</span><span>(</span><span>Schedulers</span><span>.</span><span>io</span><span>())<br/></span><span>               .</span><span>subscribe</span><span>(</span><span>i </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>"Received " </span><span>+ </span><span>i</span><span>));<br/></span><span><br/></span><span>       </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>       </span><span>d</span><span>.</span><span>dispose</span><span>();<br/></span><span>       </span><span>sleep</span><span>(</span><span>3000</span><span>);<br/></span><span>    }<br/></span><span><br/></span><span>    </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>            </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>            </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>    }<br/></span><span>}</span></pre>
<p>The output is as follows:</p>
<pre style="padding-left: 60px">Received 0<br/>Received 1<br/>Received 2<br/>Disposing on thread RxCachedThreadScheduler-1</pre>
<p>Now you will see that disposal is being done by the IO <kbd>Scheduler</kbd>, whose thread is identified by the name <kbd>RxCachedThreadScheduler-1</kbd>.  This allows the main thread to kick off disposal and continue without waiting for it to complete.</p>
<p>Like any concurrency operators, you really should not need to use <kbd>unsubscribeOn()</kbd> for lightweight operations such as this example, as it adds unnecessary overhead. But if you have <kbd>Observable</kbd> operations that are heavy with resources which are slow to dispose of, <kbd>unsubscribeOn()</kbd> can be a crucial tool if threads calling <kbd>dispose()</kbd> are sensitive to high workloads.</p>
<div class="packt_tip">You can use multiple <kbd>unsubscribeOn()</kbd> calls if you want to target specific parts of the <kbd>Observable</kbd> chain to be disposed of with different Schedulers. Everything upstream to an <kbd>unsubscribeOn()</kbd> will be disposed of with that <kbd>Scheduler</kbd> until another <kbd>unsubscribeOn()</kbd> is encountered, which will own the next upstream segment.</div>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This was probably our most intense chapter yet, but it provides a turning point in your proficiency as an RxJava developer as well as a master of concurrency! We covered the different Schedulers available in RxJava as well as ones available in other libraries such as RxJavaFX and RxAndroid. The <kbd>subscribeOn()</kbd> operator is used to suggest to the upstream in an <kbd>Observable</kbd> chain which <kbd>Scheduler</kbd> to push emissions on.  The <kbd>observeOn()</kbd>will switch emissions to a different <kbd>Scheduler</kbd> <em>at that point</em> in the <kbd>Observable</kbd> chain and use that <kbd>Scheduler</kbd> downstream. You can use these two operators in conjunction with <kbd>flatMap()</kbd> to create powerful parallelization patterns so you can fully utilize your multi-CPU power. We finally covered <kbd>unsubscribeOn()</kbd>, which helps us specify a different <kbd>Scheduler</kbd> to dispose operations on, preventing subtle hang-ups on threads we want to keep free and available even if they call the <kbd>dispose()</kbd> method.</p>
<p>It is important to note that when you start playing with concurrency, you need to become wary of how much data you are juggling between threads now. A lot of data can queue up in your <kbd>Observable</kbd> chain, and some threads will produce work faster than other threads can consume them. When you are dealing with 10,000+ elements, you will want to use Flowables to prevent memory issues, and we will cover this in <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure</em>.</p>
<p>The next chapter will look into this topic of dealing with Observables that produce emissions too quickly, and there are some operators that can help with this without backpressure. We will hit that next.</p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>