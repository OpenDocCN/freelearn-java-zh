<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects"><div class="book" id="I3QM2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Building Java Projects</h1></div></div></div><p class="calibre8">In the previous chapter, we saw a very basic build script, which just printed the customary <code class="literal">Hello World</code> on the console. Now that we are comfortable with the Gradle command line interface, it's a perfect time for us to jump-start our journey with a simple Java project.</p><p class="calibre8">In this chapter, we will see how to build and test simple Java projects with Gradle, how external dependencies are added to the classpath, and how building distributable binaries work.</p><p class="calibre8">We will try to keep the Java code as minimal as possible so that we can focus more on the build of the project. Along the way, we will learn some best practices that a Gradle-based project should follow. It's okay if we are not able to comprehend all the build script syntax in this chapter because we are going to see that in detail in <a class="calibre1" title="Chapter 4. Demystifying Build Scripts" href="part0028_split_000.html#QMFO2-e78ecbb3ac0544f19c59f96d594821c0">Chapter 4</a>, <span class="strong"><em class="calibre10">Demystifying Build Scripts</em></span>.</p></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects">
<div class="book" title="Building a simple Java project"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec12" class="calibre1"/>Building a simple Java project</h1></div></div></div><p class="calibre8">To demonstrate<a id="id31" class="calibre1"/> the Java project's build with Gradle, let's create a very simple Java application that will greet a user. Just a tad bit more than a <code class="literal">hello world</code> in terms of application logic.</p><p class="calibre8">Firstly, create a directory called <code class="literal">hello-java</code>. This is our project directory. For the following steps, feel free to choose an IDE/text editor of your choice for editing the files.</p></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects">
<div class="book" title="Building a simple Java project">
<div class="book" title="Creating a build file"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec14" class="calibre1"/>Creating a build file</h2></div></div></div><p class="calibre8">In the root of the project <a id="id32" class="calibre1"/>directory, let's create the <code class="literal">build.gradle</code> file and add the following code line to it:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'</pre></div><p class="calibre8">Yes, that's all that goes into the build file for now, a single line. We will soon see what it means.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects">
<div class="book" title="Building a simple Java project">
<div class="book" title="Adding source files"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec15" class="calibre1"/>Adding source files</h2></div></div></div><p class="calibre8">By default, like <a id="id33" class="calibre1"/>Maven, the Java source files are read from the <code class="literal">src/main/java</code> directory of the project. We can configure this, of course, but let's save that for later. Let's create this directory structure in our project.</p><p class="calibre8">Now, we need to create a Java class that would generate the greeting message. Also, we would create a <code class="literal">Main</code> class with a <code class="literal">main</code> method so that an app can be run from a command line. The Java files should be kept in a source root directory under a proper package structure. We will use the <code class="literal">com.packtpub.ge.hello</code> package for this example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-java</strong></span>
<span class="strong"><strong class="calibre9">├── build.gradle               // build file</strong></span>
<span class="strong"><strong class="calibre9">└── src</strong></span>
<span class="strong"><strong class="calibre9">    └── main</strong></span>
<span class="strong"><strong class="calibre9">        └── java               // source root</strong></span>
<span class="strong"><strong class="calibre9">            └── com</strong></span>
<span class="strong"><strong class="calibre9">                └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">                    └── ge</strong></span>
<span class="strong"><strong class="calibre9">                        └── hello</strong></span>
<span class="strong"><strong class="calibre9">                            ├── GreetingService.java</strong></span>
<span class="strong"><strong class="calibre9">                            └── Main.java    </strong></span>
</pre></div><p class="calibre8">As we can see in the preceding structure, we have created the package structure under the <code class="literal">src/main/java</code> source root.</p><p class="calibre8">Let's create the <code class="literal">GreetingService.java</code> file:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.hello;

public class GreetingService {
    public String greet(String user) {
        return "Hello " + user;
    }
}</pre></div><p class="calibre8">This class exposes just one method called <code class="literal">greet</code>, which we can use to generate a greeting message.</p><p class="calibre8">Here is how our <code class="literal">Main.java</code> looks:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.hello;

public class Main {
    public static void main(String[] args) {
        GreetingService service = new GreetingService();
        System.out.println(service.greet(args[0]));
    }
}</pre></div><p class="calibre8">This class has a <code class="literal">main</code> method, which will be invoked when a program is run. It instantiates <a id="id34" class="calibre1"/>the <code class="literal">GreetingService</code> and prints the output of the <code class="literal">greet</code> method on a console.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects">
<div class="book" title="Building a simple Java project">
<div class="book" title="Building the project"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec16" class="calibre1"/>Building the project</h2></div></div></div><p class="calibre8">After adding the Java<a id="id35" class="calibre1"/> files, we now want to compile the project and produce the class files. It can be simply done by calling the following task from a command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle compileJava</strong></span>
</pre></div><p class="calibre8">The compiled classes go into <code class="literal">build/classes/main</code> relative to the project root. You can confirm by checking the project tree again. We will ignore other files and directories for now:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-java</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">├── build</strong></span>
<span class="strong"><strong class="calibre9">│   ├── classes</strong></span>
<span class="strong"><strong class="calibre9">│   │   └── main</strong></span>
<span class="strong"><strong class="calibre9">│   │       └── com</strong></span>
<span class="strong"><strong class="calibre9">│   │           └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">│   │               └── ge</strong></span>
<span class="strong"><strong class="calibre9">│   │                   └── hello</strong></span>
<span class="strong"><strong class="calibre9">│   │                       ├── GreetingService.class</strong></span>
<span class="strong"><strong class="calibre9">│   │                       └── Main.class</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">At this point, we can directly run the class, but let's ask for more and generate the <code class="literal">.jar</code> file for our application. Let's run the following task:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle build</strong></span>
</pre></div><p class="calibre8">It produces a Jar for our project in the <code class="literal">build/libs</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-java</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">├── build</strong></span>
<span class="strong"><strong class="calibre9">│   ...</strong></span>
<span class="strong"><strong class="calibre9">│   ├── libs</strong></span>
<span class="strong"><strong class="calibre9">│   │   └── hello-java.jar</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">Let's test if the Jar works as expected. To run the Jar, issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ java -cp build/libs/hello-java.jar \ com.packtpub.ge.hello.Main Reader</strong></span>
</pre></div><p class="calibre8">We are passing the <code class="literal">Reader</code> as an argument to our java <code class="literal">Main</code> class 's <code class="literal">main</code> method. This will produce the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">Hello Reader</strong></span>
</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">When we run the <code class="literal">build</code> task, Gradle also invokes the <code class="literal">compileJava</code> and other dependent tasks before actually executing the build task. So, we don't need to explicitly call <code class="literal">compileJava</code> here to compile classes.</p></div><p class="calibre8">The name of the <code class="literal">.jar</code> file is the same as that of the project. This can be configured by setting the <code class="literal">archivesBaseName</code> property in the <code class="literal">build.gradle</code> file. For example, to generate the Jar named <code class="literal">my-app.jar</code>, add the following code line to the build file:</p><div class="informalexample"><pre class="programlisting">archivesBaseName = "my-app"</pre></div><p class="calibre8">Now, let's fire:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle clean</strong></span>
</pre></div><p class="calibre8">Also, check the directory tree again. No surprise, it's cleaned keeping the source files intact.</p><p class="calibre8">We know from our <a id="id36" class="calibre1"/>experiences with Ant that, even for the project of this size, we would have to define at least a handful of targets and this would be quite a few lines of XML. While Maven would have worked by convention, still the Maven's <code class="literal">pom.xml</code> needs some ceremony before it's even a valid <code class="literal">pom.xml</code> file. So, a minimal <code class="literal">pom.xml</code> file would still look like five to six lines of XML.</p><p class="calibre8">Compare that with the simplicity and carefully chosen sensible defaults by Gradle.</p><p class="calibre8">This is a good point where we should see what all tasks were brought into our build by the <code class="literal">java</code> plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle –q tasks</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre9">All tasks runnable from root project</strong></span>
<span class="strong"><strong class="calibre9">------------------------------------------------------------</strong></span>

<span class="strong"><strong class="calibre9">Build tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------</strong></span>
<span class="strong"><strong class="calibre9">assemble - Assembles the outputs of this project.</strong></span>
<span class="strong"><strong class="calibre9">build - Assembles and tests this project.</strong></span>
<span class="strong"><strong class="calibre9">buildDependents - Assembles and tests this project and all projects that depend on it.</strong></span>
<span class="strong"><strong class="calibre9">buildNeeded - Assembles and tests this project and all projects it depends on.</strong></span>
<span class="strong"><strong class="calibre9">classes - Assembles main classes.</strong></span>
<span class="strong"><strong class="calibre9">clean - Deletes the build directory.</strong></span>
<span class="strong"><strong class="calibre9">jar - Assembles a jar archive containing the main classes.</strong></span>
<span class="strong"><strong class="calibre9">testClasses - Assembles test classes.</strong></span>

<span class="strong"><strong class="calibre9">Build Setup tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------------</strong></span>
<span class="strong"><strong class="calibre9">init - Initializes a new Gradle build. [incubating]</strong></span>
<span class="strong"><strong class="calibre9">wrapper - Generates Gradle wrapper files. [incubating]</strong></span>

<span class="strong"><strong class="calibre9">Documentation tasks</strong></span>
<span class="strong"><strong class="calibre9">-------------------</strong></span>
<span class="strong"><strong class="calibre9">javadoc - Generates Javadoc API documentation for the main source code.</strong></span>
<span class="strong"><strong class="calibre9">Help tasks</strong></span>
<span class="strong"><strong class="calibre9">----------</strong></span>
<span class="strong"><strong class="calibre9">components - Displays the components produced by root project 'hello-java'. [incubating]</strong></span>
<span class="strong"><strong class="calibre9">dependencies - Displays all dependencies declared in root project 'hello-java'.</strong></span>
<span class="strong"><strong class="calibre9">dependencyInsight - Displays the insight into a specific dependency in root project 'hello-java'.</strong></span>
<span class="strong"><strong class="calibre9">help - Displays a help message.</strong></span>
<span class="strong"><strong class="calibre9">model - Displays the configuration model of root project 'hello-java'. [incubating]</strong></span>
<span class="strong"><strong class="calibre9">projects - Displays the sub-projects of root project 'hello-java'.</strong></span>
<span class="strong"><strong class="calibre9">properties - Displays the properties of root project 'hello-java'.</strong></span>
<span class="strong"><strong class="calibre9">tasks - Displays the tasks runnable from root project 'hello-java'.</strong></span>

<span class="strong"><strong class="calibre9">Verification tasks</strong></span>
<span class="strong"><strong class="calibre9">------------------</strong></span>
<span class="strong"><strong class="calibre9">check - Runs all checks.</strong></span>
<span class="strong"><strong class="calibre9">test - Runs the unit tests.</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">It is interesting to see so<a id="id37" class="calibre1"/> many useful tasks available on our build by merely applying the <code class="literal">java</code> plugin. Clearly, Gradle employs a very powerful plugin mechanism that can be leveraged to apply the <span class="strong"><strong class="calibre9">don't repeat yourself</strong></span> (<span class="strong"><strong class="calibre9">DRY</strong></span>) principle <a id="id38" class="calibre1"/>on build logic.</p></div></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Building Java Projects">
<div class="book" title="Building a simple Java project">
<div class="book" title="A brief introduction to plugins"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec17" class="calibre1"/>A brief introduction to plugins</h2></div></div></div><p class="calibre8">Gradle by itself is nothing more <a id="id39" class="calibre1"/>than a task runner. It does not know how to compile a Java file or where to read the source files. It means that these tasks are not there by default. As we saw in the last chapter, a Gradle build file, without any plugin applied, contained very few tasks.</p><p class="calibre8">A plugin adds relevant tasks and conventions to a Gradle build. In our current example, all the tasks such as <code class="literal">compileJava</code>, <code class="literal">build</code>, <code class="literal">clean</code>, and many more are essentially brought in by the <code class="literal">java</code> plugin that we applied to our build.</p><p class="calibre8">This means, Gradle does not force us to use a particular way to compile a Java project. It's completely up to us to choose the <code class="literal">java</code> plugin for our build. We can configure it to suite our needs. If we still don't like the way it works, we are free to add our own tasks directly to the build or through a custom plugin that will work the way we want.</p><p class="calibre8">There are number of <a id="id40" class="calibre1"/>plugins that come out of the box with Gradle. The <code class="literal">java</code> plugin is one such plugin. Throughout the course of this book, we will see many such plugins, which will bring in a lot of interesting functionality to our build.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Unit testing"><div class="book" id="J2B82-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Unit testing</h1></div></div></div><p class="calibre8">Unit testing<a id="id41" class="calibre1"/> is an indispensable aspect of software development. Testing gives us confidence that our code works fine and provides us a safety net when refactoring. Fortunately, Gradle's Java plugin makes it simple and easy to unit test your code.</p><p class="calibre8">We will write a simple test for the same example app we created above. We will create our first unit test now using JUnit (v4.12) library.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">More information about JUnit<a id="id42" class="calibre1"/> can be found at <a class="calibre1" href="http://junit.org">http://junit.org</a>.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Adding a unit test source"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec18" class="calibre1"/>Adding a unit test source</h2></div></div></div><p class="calibre8">Again, like Maven, Java <a id="id43" class="calibre1"/>test sources are kept in the <code class="literal">src/test/java</code> directory relative to the project root. We will create this directory and, as a good practice, the test package structure will reflect the same hierarchy as the source packages.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">src</strong></span>
<span class="strong"><strong class="calibre9">└── test</strong></span>
<span class="strong"><strong class="calibre9">    └── java        // test source root</strong></span>
<span class="strong"><strong class="calibre9">        └── com</strong></span>
<span class="strong"><strong class="calibre9">            └── packtpub</strong></span>
<span class="strong"><strong class="calibre9">                └── ge</strong></span>
<span class="strong"><strong class="calibre9">                    └── hello</strong></span>
<span class="strong"><strong class="calibre9">                        └── GreetingServiceTest.java</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div><p class="calibre8">We will add test for the <code class="literal">GreetingService</code>. By convention, the name of test will be <code class="literal">GreetingServiceTest.java</code>. The following is the code of this file:</p><div class="informalexample"><pre class="programlisting">package com.packtpub.ge.hello;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class GreetingServiceTest {

    GreetingService service;

    @Before
    public void setup() {
        service = new GreetingService();
    }

    @Test
    public void testGreet() {
        assertEquals("Hello Test", service.greet("Test"));
    }
}</pre></div><p class="calibre8">The test sets up an <a id="id44" class="calibre1"/>instance of <a id="id45" class="calibre1"/>
<span class="strong"><strong class="calibre9">System Under Test</strong></span> (<span class="strong"><strong class="calibre9">SUT</strong></span>), which is <code class="literal">GreetingService</code>, and the <code class="literal">testGreet</code> method checks the equality of the SUT's <code class="literal">greet</code> methods output to get the expected message.</p><p class="calibre8">Now, take a moment and try to compile tests by using the <code class="literal">compileTestJava</code> task, which is exactly the same as <code class="literal">compileJava</code>, but compiles the test source files. Did it compile just fine? If not, can we take a guess as to what could have gone wrong?</p><p class="calibre8">The task should have failed with a bunch of compilation errors because JUnit, which is an external library, was not on the classpath to compile the files.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Adding the JUnit to the classpath"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec19" class="calibre1"/>Adding the JUnit to the classpath</h2></div></div></div><p class="calibre8">To compile and run this <a id="id46" class="calibre1"/>test case, we need JUnit library on the classpath. It is <a id="id47" class="calibre1"/>important to remember that this dependency is only required while compiling and running the tests. Our application does not depend on JUnit for its compilation or on runtime. We also need to tell where to search for this artifact so that Gradle can download it if there is a need. To do this, we need to update the <code class="literal">build.gradle</code> file as follows:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

repositories {
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.12'
}</pre></div><p class="calibre8">There are two additions to this build file, from what we already know.</p><p class="calibre8">In the <code class="literal">dependencies</code> section, we list down all the dependencies of the project along with their scope. We declared JUnit to be made available in the <code class="literal">testCompile</code> scope.</p><p class="calibre8">In the <code class="literal">repositories</code> section, we configure the type and location of the repository where external dependencies will be found. In this example, we tell Gradle to get the dependencies from the Maven central repository. Since Maven central is a very commonly used repo, Gradle provides a <a id="id48" class="calibre1"/>shortcut to configure it thorough the <code class="literal">mavenCentral()</code> method call.</p><p class="calibre8">We will cover both the sections<a id="id49" class="calibre1"/> in greater depth in the next chapter.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Running the test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec20" class="calibre1"/>Running the test</h2></div></div></div><p class="calibre8">We are interested in running the tests<a id="id50" class="calibre1"/> to check whether everything is working as expected. Let's run the <code class="literal">test</code> task, which will also sequentially run all the tasks that the <code class="literal">test</code> task depends on. We can also verify this by looking at the output that lists all the tasks that have been run as part of this build:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle test</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses</strong></span>
<span class="strong"><strong class="calibre9">:test</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 1.662 secs</strong></span>
</pre></div><p class="calibre8">It looks like the tests passed. To see how Gradle tells us when a test fails, let's intentionally change the expected value in assertion to <code class="literal">Test Hello</code> so that the assertion fails:</p><div class="informalexample"><pre class="programlisting">@Test
public void testGreet() {
    assertEquals("Test Hello", service.greet("Guest"));
}</pre></div><p class="calibre8">Then run the command again to see the result when the test fails:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle test</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses</strong></span>
<span class="strong"><strong class="calibre9">:test</strong></span>

<span class="strong"><strong class="calibre9">com.packtpub.ge.hello.GreetingServiceTest &gt; testGreet FAILEDorg.junit.ComparisonFailure at GreetingServiceTest.java:18</strong></span>
<span class="strong"><strong class="calibre9">1 test completed, 1 failed</strong></span>
<span class="strong"><strong class="calibre9">:test FAILED</strong></span>

<span class="strong"><strong class="calibre9">FAILURE: Build failed with an exception.</strong></span>

<span class="strong"><strong class="calibre9">......</strong></span>
</pre></div><p class="calibre8">Yes, so the test failed and the output <a id="id51" class="calibre1"/>tells you about the file and the line number as well. Also, it points you to the report file, which includes more details of the test failure.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Viewing test reports"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec21" class="calibre1"/>Viewing test reports</h2></div></div></div><p class="calibre8">Whether the test passes or not, a <a id="id52" class="calibre1"/>nice HTML report is created with details of all the tests that are run. By default, this report is located at <code class="literal">build/reports/tests/index.html</code> relative to the project root. You can open this file in a browser.</p><p class="calibre8">For the above failure, the report looks something like this:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="Viewing test reports" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If we click on the failed test, we get to<a id="id53" class="calibre1"/> see the details of the failure:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Viewing test reports" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">We can <a id="id54" class="calibre1"/>see <code class="literal">org.junit.ComparisonFailure: expected:&lt;[Test Hello]&gt; but was:&lt;[Hello Test]&gt;</code> in the first line of the stack trace.</p></div></div>

<div class="book" title="Unit testing">
<div class="book" title="Fitting tests in the workflow"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec22" class="calibre1"/>Fitting tests in the workflow</h2></div></div></div><p class="calibre8">Now that we have tests in place, it <a id="id55" class="calibre1"/>makes sense to build our project binaries (<code class="literal">.jar</code>) only if the <a id="id56" class="calibre1"/>tests pass. For that, we need to define some kind of flow between the tasks such that, if a task fails, the pipeline is broken there and the subsequent tasks are not executed. So, in our examples, the build's execution should depend on the test's success.</p><p class="calibre8">Guess what, it has already been taken care by the <code class="literal">java</code> plugin for us. We just need to call the last task in the flow, and all the tasks that the called tasks depend on will be called sequentially and the build will not succeed if any of the tasks fails.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle build</strong></span>
</pre></div><p class="calibre8">Also, we don't need to call all the tasks that the build depends on explicitly because they will be called anyway.</p><p class="calibre8">Now let's fix the test and see the Jar getting created again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$gradle build</strong></span>
<span class="strong"><strong class="calibre9">:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:jar UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:assemble UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:compileTestJava</strong></span>
<span class="strong"><strong class="calibre9">:processTestResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:testClasses</strong></span>
<span class="strong"><strong class="calibre9">:test</strong></span>
<span class="strong"><strong class="calibre9">:check</strong></span>
<span class="strong"><strong class="calibre9">:build</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 1.617 secs</strong></span>
</pre></div><p class="calibre8">Yay! So the tests have <a id="id57" class="calibre1"/>passed and we can build binaries of our app again.</p><p class="calibre8">Notice how intelligently <a id="id58" class="calibre1"/>Gradle figures out that, if only tests were changed, it compiled only the tests. In the preceding output, <code class="literal">compileJava</code> shows <code class="literal">UP-TO-DATE</code>, means nothing was changed and, hence, Gradle didn't unnecessarily compile the source files again.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip09" class="calibre1"/>Tip</h3><p class="calibre8">If we need to force run task actions even if nothing has changed between the two runs, we can pass the <code class="literal">--rerun-tasks</code> flag on the command line so that all task actions can run.</p></div><p class="calibre8">If we see the test reports again, they will look as follows:</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="Fitting tests in the workflow" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">And the <a id="id59" class="calibre1"/>
<span class="strong"><strong class="calibre9">Test Summary</strong></span> will <a id="id60" class="calibre1"/>look something like this:</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="Fitting tests in the workflow" class="calibre11"/></div><p class="calibre12"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Bundling an application distributable"><div class="book" id="K0RQ2-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Bundling an application distributable</h1></div></div></div><p class="calibre8">In the first example, we <a id="id61" class="calibre1"/>ran our application by using the <code class="literal">java</code> command directly from the command line. Usually, such command-line applications are shipped with scripts to run the application so that the end user need not always write the whole command by hand. Also, while developing, we repeatedly need to run the app. It would be nicer if we could write a task in our build file such that an app can be run in one Gradle invocation.</p><p class="calibre8">The good news is that there already exists such a plugin called <code class="literal">application</code>, shipped with Gradle, which can do both for us. For this example, we will copy over the <code class="literal">hello-test</code> project as <code class="literal">hello-app</code>. Let's make simple modifications to our <code class="literal">build.gradle</code> as follows:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'application'

mainClassName = "com.packtpub.ge.hello.Main"
run.args = ["Reader"]

repositories {
    mavenCentral()
}

dependencies {
    testCompile 'junit:junit:4.11'
}</pre></div><p class="calibre8">The second line applies the <code class="literal">application</code> plugin to our build. To make this plugin work, we need to configure Gradle to use our <code class="literal">Main</code> entry point class, which has the static <code class="literal">main</code> method that needs to run when our application is run. We specified that on line <code class="literal">#4</code> by setting the <code class="literal">mainClassName</code> property that is added to the build by the <code class="literal">application</code> plugin. Finally, when we want to run the app using Gradle (that is, while developing), we need to provide some command-line arguments to our app. The <code class="literal">application</code> plugin adds the <code class="literal">run</code> task to our build. As we said earlier, tasks are objects and they have properties and methods just like any regular object. On line <code class="literal">#5</code>, we set the <code class="literal">args</code> property of the <code class="literal">run</code> task to a list with one element <code class="literal">Reader</code>, so whenever we execute the run task, <code class="literal">Reader</code> will be passed as a command-line argument to our main method. Those who have used IDEs to set <span class="strong"><strong class="calibre9">Run Configuration</strong></span> can easily relate to this. The rest of the file is the same as the last example.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">In the preceding example, as we are applying the <code class="literal">application</code> plugin, it is not necessary to explicitly apply the <code class="literal">java</code> plugin as an <code class="literal">application</code> plugin implicitly applies the <code class="literal">java</code> plugin to our build. </p><p class="calibre8">It also implicitly applies the <code class="literal">distribution</code> plugin so that we get the tasks to package the application as a ZIP or TAR archive and also gets the task to install the application distribution locally.</p><p class="calibre8">More information on the <code class="literal">application</code> plugin<a id="id62" class="calibre1"/> can be found at <a class="calibre1" href="https://docs.gradle.org/current/userguide/distribution_plugin.html">https://docs.gradle.org/current/userguide/distribution_plugin.html</a>.</p></div><p class="calibre8">Now, if we check the tasks that are available in our build, we see a few additions under the <code class="literal">Application tasks</code> and <code class="literal">Distribution tasks</code> groups:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle tasks</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
<span class="strong"><strong class="calibre9">Application tasks</strong></span>
<span class="strong"><strong class="calibre9">-----------------</strong></span>
<span class="strong"><strong class="calibre9">installApp - Installs the project as a JVM application along with libs and OS specific scripts.</strong></span>
<span class="strong"><strong class="calibre9">run - Runs this project as a JVM application</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>

<span class="strong"><strong class="calibre9">Distribution tasks</strong></span>
<span class="strong"><strong class="calibre9">------------------</strong></span>
<span class="strong"><strong class="calibre9">assembleDist - Assembles the main distributions</strong></span>
<span class="strong"><strong class="calibre9">distTar - Bundles the project as a distribution.</strong></span>
<span class="strong"><strong class="calibre9">distZip - Bundles the project as a distribution.</strong></span>
<span class="strong"><strong class="calibre9">installDist - Installs the project as a distribution as-is.</strong></span>
<span class="strong"><strong class="calibre9">...</strong></span>
</pre></div></div>

<div class="book" title="Bundling an application distributable">
<div class="book" title="Running the application with Gradle"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec23" class="calibre1"/>Running the application with Gradle</h2></div></div></div><p class="calibre8">Let's first look at the <code class="literal">run</code> task. We <a id="id63" class="calibre1"/>will call this task with the <code class="literal">–q</code> flag to <a id="id64" class="calibre1"/>suppress other messages by Gradle:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q run</strong></span>
<span class="strong"><strong class="calibre9">Hello Reader</strong></span>
</pre></div><p class="calibre8">As expected, we see the output on a console. This task really shines when we make changes and can run our app in one command as follows: </p><div class="informalexample"><pre class="programlisting">    public String greet(String user) {
        return "Hola " + user;
    }</pre></div><p class="calibre8">We changed our <code class="literal">GreetingService</code> for a moment to return "<code class="literal">Hola</code>" instead of "<code class="literal">Hello</code>" and see if run reflects the changes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q run</strong></span>
<span class="strong"><strong class="calibre9">Hola Reader</strong></span>
</pre></div><p class="calibre8">Yes, it did.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip10" class="calibre1"/>Tip</h3><p class="calibre8">One might wonder <a id="id65" class="calibre1"/>how to pass command-line arguments to run a task from the command line itself, instead of the build file, which is something as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle –q run Reader</strong></span>
</pre></div><p class="calibre8">However, it doesn't work this way. As Gradle can accept multiple task names from a command line, there is no way for Gradle to know whether <code class="literal">Reader</code> was an argument that needs to be passed to run a task, or it's a task name itself. For example, the following command calls two tasks:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle –q clean build</strong></span>
</pre></div><p class="calibre8">There are, of course, some <a id="id66" class="calibre1"/>workarounds if you really need to pass the command line to the program at every invocation of a run task. One such way is to use the <code class="literal">–Pproperty=value</code> command-line option and then extract the property's value in the <code class="literal">run</code> task to send it as <code class="literal">args</code> to the program. The <code class="literal">–P</code> adds properties to the Gradle <code class="literal">Project</code>.</p><p class="calibre8">To achieve this, update the <code class="literal">run.args</code> in <code class="literal">build.gradle</code> as follows:</p><div class="informalexample"><pre class="programlisting">run.args = [project.runArgs]</pre></div><p class="calibre8">Also, then from command line provide the property value by calling:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle -q run -PrunArgs=world</strong></span>
</pre></div><p class="calibre8">In the preceding example, we provided the value of a property at the time of calling the <code class="literal">gradle</code> command. </p><p class="calibre8">Alternatively, we could create a <code class="literal">gradle.properties</code> in project’s root parallel to the <code class="literal">build.gradle</code> file. In that case, for this example it would contain just <code class="literal">runArgs=world</code>. But it can declare more properties, which would be available in the build as properties on project object.</p><p class="calibre8">There are other ways to declare properties as well, which can be found at <a class="calibre1" href="https://docs.gradle.org/current/userguide/build_environment.html">https://docs.gradle.org/current/userguide/build_environment.html</a>.</p></div></div></div>

<div class="book" title="Bundling an application distributable">
<div class="book" title="Building the distribution archive"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec24" class="calibre1"/>Building the distribution archive</h2></div></div></div><p class="calibre8">Another <a id="id67" class="calibre1"/>interesting task is <code class="literal">distZip</code>, which packages the application along with OS-specific start scripts:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle distZip</strong></span>
<span class="strong"><strong class="calibre9">:compileJava</strong></span>
<span class="strong"><strong class="calibre9">:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong class="calibre9">:classes</strong></span>
<span class="strong"><strong class="calibre9">:jar</strong></span>
<span class="strong"><strong class="calibre9">:startScripts</strong></span>
<span class="strong"><strong class="calibre9">:distZip</strong></span>

<span class="strong"><strong class="calibre9">BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong class="calibre9">Total time: 1.29 secs</strong></span>
</pre></div><p class="calibre8">It would have generated the application distribution in ZIP format in the <code class="literal">build/distributions</code> relative to the project root. The name of the ZIP defaults to the project name. In this case, it would be <code class="literal">hello-app.zip</code>. This can be changed, if required, using the following property in <code class="literal">build.gradle</code>:</p><div class="informalexample"><pre class="programlisting">distributions.main.baseName = 'someName'</pre></div><p class="calibre8">Let's unzip the archive to see its contents:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">hello-app</strong></span>
<span class="strong"><strong class="calibre9">├── bin</strong></span>
<span class="strong"><strong class="calibre9">│   ├── hello-app</strong></span>
<span class="strong"><strong class="calibre9">│   └── hello-app.bat</strong></span>
<span class="strong"><strong class="calibre9">└── lib</strong></span>
<span class="strong"><strong class="calibre9">    └── hello-app.jar</strong></span>
</pre></div><p class="calibre8">We see a pretty <a id="id68" class="calibre1"/>standard directory structure inside the ZIP. It contains a shell script and windows BAT script to run our app. Also, it contains the JAR file of our application. The <code class="literal">lib</code> directory also contains the application's runtime dependencies. We can configure the <code class="literal">distribution</code> plugin to add more files in our distributions such as Javadoc, README, and so on.</p><p class="calibre8">We can run the script to verify that it works. Using command prompt, we can execute this command in Windows. For that use the <code class="literal">cd</code> command, and change the directory to the <code class="literal">bin</code> directory of the extracted ZIP file.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ hello-app Reader</strong></span>
<span class="strong"><strong class="calibre9">Hello Reader</strong></span>
</pre></div><p class="calibre8">On Mac OS X/Linux, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ./hello-app Reader</strong></span>
<span class="strong"><strong class="calibre9">Hello Reader</strong></span>
</pre></div></div></div>
<div class="book" title="Generating IDE project files" id="KVCC1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Generating IDE project files</h1></div></div></div><p class="calibre8">IDEs are an integral <a id="id69" class="calibre1"/>part of a Java developer's tool chain and workflow. However, manually setting up an IDE to correctly identify the project structure and dependencies for any moderately sized project is not an easy task.</p><p class="calibre8">Checking-in IDE-specific files or directories such as <code class="literal">.classpath</code>, <code class="literal">.project</code>, <code class="literal">.ipr</code>, <code class="literal">.iws</code>, <code class="literal">.nbproject</code>, <code class="literal">.idea</code>, <code class="literal">.settings</code>,<code class="literal"> .iml</code>, is not a good idea. We know that some still do it because it's hard to generate the IDE file manually every time someone checks the project out of the version control system. However, checking in such files creates problems as they eventually go out of sync from the main build file. Also, this forces the whole team to use the same IDE and manually update the IDE files whenever there is a change in the build.</p><p class="calibre8">How nice would it be if we could just check-in only those files that are necessary for a project to be built independent of IDE and let our build system generate a file specific to our favorite IDE? Our wish is granted. Also, here is the best part. The number of lines that you need to modify in your Gradle build file is only one. Gradle sports very nice plugins that can generate IDE-specific project files. Both IntelliJ IDEA and Eclipse are covered by their respective plugins. Depending on which IDE you want to support, you will either include <code class="literal">apply plugin: 'idea'</code> or <code class="literal">apply plugin: 'eclipse'</code>.</p><p class="calibre8">In fact, there is no harm in including both.</p><p class="calibre8">Now, from the command line, execute the following for Eclipse and IntelliJ IDEA, respectively:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ gradle eclipse</strong></span>
<span class="strong"><strong class="calibre9">$ gradle idea</strong></span>
</pre></div><p class="calibre8">It should generate <a id="id70" class="calibre1"/>IDE-specific files for you and now you can directly open a project in either of the IDEs.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre8">Make sure you ignore IDE-specific files in version control. For example, if you are using Git, consider adding the following entries in your <code class="literal">.gitignore</code> file to prevent someone from accidentally committing the IDE-specific files:</p><div class="informalexample"><pre class="programlisting">.idea/
*.iml
*.ipr
*.iws
.classpath
.project
.settings/</pre></div></div></div>
<div class="book" title="Summary" id="LTSU1-e78ecbb3ac0544f19c59f96d594821c0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">We started off this chapter by building a very simple Java project. We saw how the intelligent conventions of the <code class="literal">java</code> plugin helped us keep the build file concise. Then, we added unit tests to this project and included the JUnit library from the Maven central repository. We made the tests fail and checked the reports to see the explanation. Then, we saw how the application's distribution can be created using the <code class="literal">application</code> plugin. Finally, we saw the <code class="literal">idea</code> and <code class="literal">eclipse</code> plugins that help us generate the IDE-specific files for our project.</p><p class="calibre8">Overall, we realized how powerful the plugin system in Gradle is. Gradle, out-of-the-box, ships with many interesting plugins, but we are not forced to use any of them. We will build a web application in the next chapter and also learn how configurations and dependency management works..</p></div></body></html>