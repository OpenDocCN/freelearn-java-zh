<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Powerful Functional Constructs</h1>
                
            
            <article>
                
<div class="packt_quote">"We cannot solve our problems with the same thinking we used when we created them."</div>
<div class="packt_quote1">– Albert Einstein</div>
<p class="calibre2">When we try to solve problems by writing programs, our intention is to write better code. More precisely<em class="calibre18">,</em> we mean that code should be readable and efficient at compile time and runtime. Readability and efficiency are two major factors, along with other important concepts such as concurrency, asynchronous tasks, and so on. We can think of the first two as the building blocks for the next set of characteristics we want. Scala, as a multi-paradigm language, provides multiple constructs that ensure the code we write is optimized, and also provides syntactic sugar wherever required. Many of the functional constructs or concepts used in <em class="calibre18">functional programming</em> enable you to write <em class="calibre18">better</em> code that not only fulfills the first two requirements but also allows your code to run in <em class="calibre18">concurrent</em> and <em class="calibre18">distributed</em> environments.</p>
<p class="calibre2">Our intention in this chapter is to learn the ways we can make our code better. For that, we'll go through some of the syntactical constructs. Let's take a look at what we are going to go through in this chapter:</p>
<ul class="calibre7">
<li class="calibre8">For expressions</li>
<li class="calibre8">Pattern matching</li>
<li class="calibre8">Option type</li>
<li class="calibre8">Lazy declaration</li>
<li class="calibre8">Tail call optimization</li>
<li class="calibre8">Combinators</li>
<li class="calibre8">Type parameterization</li>
</ul>
<p class="calibre2">All these concepts are simple but very useful for when you write Scala code. Some of them we've already gone through, such as <em class="calibre18">for expressions.</em> Our intention here is to compare for expressions with the available higher-order functions, such as <kbd class="calibre11">map</kbd>, <kbd class="calibre11">flatMap</kbd>, and <kbd class="calibre11">withFilter</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">For expressions</h1>
                
            
            <article>
                
<p class="calibre2">We would not be wrong, if we say that the <kbd class="calibre11">for</kbd> expressions are powerful constructs in Scala. For expressions let you traverse through any collection and perform operations such as filtering and yielding out new collections. We have already gone through this concept in <a href="part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 3</a>, <em class="calibre18">Shaping Up our Scala Program.</em> Let's recall the example we saw:</p>
<pre class="calibre19">object ForExpressions extends App { 
 
  val person1 = Person("Albert", 21, 'm') 
  val person2 = Person("Bob", 25, 'm') 
  val person3 = Person("Cyril", 19, 'f') 
  val persons = List(person1, person2, person3) 
 
  val winners = for { 
    person &lt;- persons 
    age = person.age 
    name = person.name 
    if age &gt; 20 
  } yield name 
 
  winners.foreach(println) 
 
} 
 
case class Person(name: String, age: Int, gender: Char) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Albert 
Bob </pre>
<p class="calibre2">In the previous example, we have a collection of <kbd class="calibre11">Person</kbd> objects. We are performing a traversal on the collection and generating another collection consisting of names for all persons based on some condition. As we already know, for this we are using three constructs, or let's say expressions:</p>
<ul class="calibre7">
<li class="calibre8">Generator
<ul class="calibre28">
<li class="calibre8"><kbd class="calibre11">person &lt;- persons</kbd></li>
</ul>
</li>
<li class="calibre8">Definition
<ul class="calibre28">
<li class="calibre8"><kbd class="calibre11">age = person.age</kbd></li>
<li class="calibre8"><kbd class="calibre11">name = person.name</kbd></li>
</ul>
</li>
<li class="calibre8">Filter
<ul class="calibre28">
<li class="calibre8"><kbd class="calibre11">age &gt; 20</kbd></li>
</ul>
</li>
</ul>
<p class="calibre2">With these three expressions we were able to perform slightly complex logic with very little syntactical effort. We could have done a similar operation in the form of higher-order functions. Using <kbd class="calibre11">map</kbd> and <kbd class="calibre11">withFilter</kbd> we can perform such operations, let's take a look at an example:</p>
<pre class="calibre19">val winners1 = persons withFilter(_.age &gt; 20) map(_.name)
winners1.foreach(println)
<br class="title-page-name"/>case class Person(name: String, age: Int, gender: Char) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Albert 
Bob </pre>
<p class="calibre2">Here, we have used higher-order functions to implement the same logic we implemented using for expressions. We're already familiar with the <kbd class="calibre11">map</kbd> method from a collection. It's going to provide you a list of persons whose age is greater than 20. So now, we have the same logic implemented in two different ways. First, in the form of <em class="calibre18">for expressions</em>, and second, in the form of <em class="calibre18">higher-order functions.</em> So it's important for us to know how this happens. What the Scala compiler does is it internally breaks down for expressions into higher-order functions. Programmers tend to prefer using for expressions for readability but it's a matter of choice. Now that we know what <span>happens</span> internally, we can start thinking about the translation Scala does for slightly complex for expressions, can't we? Yes, so let's try it out.</p>
<p class="calibre2">Now, suppose we have a list of car brands, and each brand has many cars in it (in other words, each brand has a list of cars). The code will look something like the following:</p>
<pre class="calibre19">case class Car(name: String, brandName: String) 
case class Brand(name: String, cars: List[Car]) 
 
val brands = List( 
Brand("Toyota", List(Car("Corolla", "Toyota"))), 
Brand("Honda",  List(Car("Accord", "Honda"))), 
Brand("Tesla",  List(Car("Model S", "Tesla"), 
                                      Car("Model 3", "Tesla"), 
                                      Car("Model X", "Tesla"), 
                                      Car("New Model", "Tesla")))) </pre>
<p class="calibre2">You may want to yield a list of pairs for all the Tesla cars whose name starts with the <kbd class="calibre11">Model</kbd> <span>keyword</span> . You'll perform something like the following:</p>
<pre class="calibre19">val teslaCarsStartsWithModel = for { 
  brand &lt;- brands 
  car &lt;- brand.cars 
  if car.name.startsWith("Model") &amp;&amp; brand.name == "Tesla" 
} yield (brand.name, car.name) 
 
teslaCarsStartsWithModel foreach println </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">(Tesla,Model S) 
(Tesla,Model 3) 
(Tesla,Model X) </pre>
<p class="calibre2">We used for expressions for this task. This has two generator expressions, and we are also performing a filtering operation on it. While translating these kinds of for expressions into higher-order functions, Scala uses the <kbd class="calibre11">flatMap</kbd> method. Let's see how the same can be implemented using <kbd class="calibre11">flatMap</kbd>:</p>
<pre class="calibre19">val teslaCarsStartsWithModel2 = brands.flatMap(brand =&gt;  
  brand.cars withFilter(_.name.startsWith("Model") &amp;&amp; brand.name == "Tesla") map(car =&gt; (brand.name, car.name))) 
 
teslaCarsStartsWithModel2 foreach println </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">(Tesla,Model S) 
(Tesla,Model 3) 
(Tesla,Model X) </pre>
<p class="calibre2">We got a similar result with this definition. So let's try to break this <kbd class="calibre11">teslaCarsStartsWithModel2</kbd> down to understand how we implemented this. First, what we had was the following:</p>
<pre class="calibre19">For(gen1 &lt;- list, gen2 &lt;- gen1.list, filter1) </pre>
<p class="calibre2">In scenarios where we have two generators, we use <kbd class="calibre11">flatMap</kbd> functions instead of <kbd class="calibre11">map</kbd>. Let's go through the translation from for expressions to higher-order functions <span>step by step:</span></p>
<ol class="calibre13">
<li value="1" class="calibre8">We have the following:</li>
</ol>
<pre class="calibre36">for { 
  brand &lt;- brands 
  car &lt;- brand.cars 
  if car.name.startsWith("Model") &amp;&amp; brand.name == "Tesla" 
} yield (brand.name, car.name) </pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre8">We first <span>used</span> <kbd class="calibre11">flatMap</kbd>:</li>
</ol>
<pre class="calibre36">brands.flatMap{ brand =&gt; 
     for{ 
       car &lt;- brand.cars 
        if car.name.startsWith("Model") &amp;&amp; brand.name == "Tesla" 
     } yield (brand.name, car.name) 
} </pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre8">Now that we've got the brand, we have access to the cars list. We can proceed with a filtering predicate as follows:</li>
</ol>
<pre class="calibre36">brands.flatMap{ brand =&gt; 
      brand.cars withFilter{ car =&gt;  
         car.name.startsWith("Model") &amp;&amp; brand.name == "Tesla" 
      } map(car =&gt; (brand.name, car.name))  
} </pre>
<p class="calibre37">This is the final version of our implementation. What we have done here is we filtered out elements from our <kbd class="calibre11">cars</kbd> collection and finally transformed our collection to the intended form.</p>
<p class="calibre2">So this is the way the Scala compiler does translations of our for expressions into the provided functions. As programmers, we only have to deal with the implementation part. You may want to put your logic in the for expressions instead of writing nested higher-order functions, and Scala does the rest for you.</p>
<p class="calibre2">Here, we learned how you can add your logic in different forms in detail. Similarly, you'll also find cases that we will have to go through and then execute any logic applicable. <span>In this process of matching different cases, we can empower ourselves by matching through different patterns. For example, we may want to match <span>our list type</span> against the possible values. The options are going to be either an empty list or a list with certain values. Scala doesn't limit you to matching in these two ways, but you'll have more options to match against. All this is possible via a concept called</span> <em class="calibre18">pattern matching.</em> <span>The good thing is, we've already gone through the pattern matching concept so what we are going to do now is try to understand it further.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pattern matching</h1>
                
            
            <article>
                
<p class="calibre2">We use <strong class="calibre1">pattern matching</strong> to execute code on a case-by-case basis. Take a look at the following:</p>
<pre class="calibre19">val somelist = List(1,2,3) 
 
somelist match { 
  case Nil =&gt; Nil 
  case _ =&gt; ??? 
} </pre>
<p class="calibre2">By taking a look at the structure of our pattern match expression, we see a few things. First, we execute a match on some value followed by the <kbd class="calibre11">match</kbd> keyword and then we put cases. For each case we specify some patterns. Now, the pattern can be a constant value, a variable, or even a constructor. We'll soon have a look at all of these patterns. Pattern matching also allows us to put guards on our match in the form of a condition. In that case, the pattern will only match if the condition is applicable. If you take a look at the previous toy example about <kbd class="calibre11">somelist</kbd>, you'll see there's an <em class="calibre18"/><kbd class="calibre11"><em class="calibre18">_</em></kbd> underscore. It's called a <strong class="calibre1">wildcard pattern</strong>. It'll match all values or patterns against the case. Logically, you can't put another case after a wildcard. For example, the following does not make any sense and throws a warning:</p>
<pre class="calibre19">val somelist = 1 :: 2 :: 3 :: Nil 
 
val x = somelist match { 
  case Nil =&gt; Nil 
  case _ =&gt; println("anything") 
  case head :: tail =&gt; println("something with a head and a tail") 
} 
Warning:(21, 10) patterns after a variable pattern cannot match (SLS 8.1.1) 
    case _ =&gt; println("anything") 
Warning:(22, 33) unreachable code due to variable pattern on line 21 
    case head :: tail =&gt; println("something with a head and a tail") 
Warning:(22, 33) unreachable code 
    case head :: tail =&gt; println("something with a head and a tail") </pre>
<p class="calibre2">This is a pretty basic example of pattern matching in Scala. There are more ways we can pattern match. Why not take a look at all of them?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Different ways we can pattern match</h1>
                
            
            <article>
                
<p class="calibre2"><span>Pattern matching in Scala proves to be a very important concept. We can match on variables, constants, and even constructors. We'll take a look at all of them. Let's start with matching against a variable.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching a variable</h1>
                
            
            <article>
                
<p class="calibre2">At times, when we have to use the value after the pattern match is successful, we want to match against cases with variables. What this does is it assigns the value to the variable and then we can use that in our code for that particular case. It's better if we look at the following example:</p>
<pre class="calibre19">import scala.util.control.NonFatal<br class="title-page-name"/><br class="title-page-name"/>def safeToInt(canBeNumber: String): Option[Int] = { 
  try { 
    Some(canBeNumber.toInt) 
  } catch { 
    case NonFatal(e) =&gt; None 
  } 
} 
 
safeToInt("10") match { 
  case None =&gt; println("Got nothing") 
  case someValue =&gt;  println(s"Got ${someValue.get}") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Got 10 </pre>
<p class="calibre2">Here, we have defined a method which tries to convert a number represented by a string to an integer. Then, we call the method with a parameter and try to match the same using a variable named <kbd class="calibre11">someValue</kbd>. This <kbd class="calibre11">someValue</kbd> variable is going to be of the same type as the value's matched type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching a constant</h1>
                
            
            <article>
                
<p class="calibre2">We can also match cases against a constant, such as basic switch statements. Take a look at the following:</p>
<pre class="calibre19">def matchAgainst(i: Int) = i match { 
  case 1 =&gt; println("One") 
  case 2 =&gt; println("Two") 
  case 3 =&gt; println("Three") 
  case 4 =&gt; println("Four") 
  case _ =&gt; println("Not in Range 1 to 4") 
} 
 
matchAgainst(1)<br class="title-page-name"/> matchAgainst(5)</pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">One 
Not in Range 1 to 4 </pre>
<p class="calibre2">Here, we directly matched our expression against constant values. This can be any value, depending upon the type your method accepts. You are allowed to match against a Boolean, string, or any other constant value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching a constructor</h1>
                
            
            <article>
                
<p class="calibre2">Okay, what does a constructor pattern look like? It's about matching a constructor against a value, or we could say, extracting values of our choice. Let's take an example:</p>
<pre class="calibre19">def safeToInt(canBeNumber: String): Option[Int] = { 
  try { 
    Some(canBeNumber.toInt) 
  } catch { 
    case NonFatal(e) =&gt; None 
  } 
} 
 
safeToInt("10") match { 
  case None =&gt; println("Got nothing") 
  case Some(value) =&gt;  println(s"Got $value") 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Got 10 </pre>
<p class="calibre2">The only difference we can see here is, instead of providing a variable, we gave a constructor pattern. <kbd class="calibre11">Some(value)</kbd> lets you extract the <kbd class="calibre11">value</kbd> out of itself. Here in the given example, the <kbd class="calibre11">safeToInt</kbd> method returns an <kbd class="calibre11">Option</kbd> type. We're going to learn about types in subsequent sections. For now, the interesting information for us is that we have two subtypes of our <kbd class="calibre11">Option</kbd> type named <kbd class="calibre11">Some</kbd> and <kbd class="calibre11">None</kbd>, and as the names suggest, <kbd class="calibre11">Some</kbd> means some value and <kbd class="calibre11">None</kbd> means no value. The <kbd class="calibre11">Some</kbd> subtype expects a particular value as its constructor parameter. Hence it's possible for us to match on that. The following line does the exact thing we just mentioned:</p>
<pre class="calibre19">case Some(value) =&gt; println(s"Got $value") </pre>
<p class="calibre2">With this declaration we can extract a value, in our case the extracted parameter name is also <kbd class="calibre11">value</kbd>, hence we used it. This is an example of using a constructor for our pattern matching. We've learned about <kbd class="calibre11">case</kbd> classes in Scala and also mentioned that <kbd class="calibre11">case</kbd> classes provide us an exact structure, using which we can directly perform pattern matching. So let's take an example:</p>
<pre class="calibre19"> trait Employee 
 case class ContractEmp(id: String, name: String) extends Employee 
 case class Developer(id: String, name: String) extends Employee 
 case class Consultant(id: String, name: String) extends Employee 
 
/* 
 * Process joining bonus if 
 *     :&gt; Developer has ID Starting from "DL"  JB: 1L 
 *     :&gt; Consultant has  ID Starting from "CNL":  1L 
 */ 
 def processJoiningBonus(employee: Employee, amountCTC: Double) = employee match { 
   case ContractEmp(id, _) =&gt; amountCTC 
   case Developer(id, _) =&gt; if(id.startsWith("DL")) amountCTC + 10000.0 else amountCTC 
   case Consultant(id, _) =&gt; if(id.startsWith("CNL")) amountCTC + 10000.0 else amountCTC 
 } 
 
 val developerEmplEligibleForJB = Developer("DL0001", "Alex") 
 val consultantEmpEligibleForJB = Consultant("CNL0001","Henry") 
 val developer = Developer("DI0002", "Heith") 
 
 println(processJoiningBonus(developerEmplEligibleForJB, 55000)) 
 println(processJoiningBonus(consultantEmpEligibleForJB, 65000)) 
 println(processJoiningBonus(developer, 66000)) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">65000.0 
75000.0 
66000.0 </pre>
<p class="calibre2">Here in this example, we defined three categories of employees: <kbd class="calibre11">Developer</kbd>, <kbd class="calibre11">Consultant</kbd>, and <kbd class="calibre11">ContractEmp</kbd>. We've a problem to solve: we'll have to process the joining bonus amount for specific employees in a specific category with some conditions. The whole logic is very simple to implement in terms of <kbd class="calibre11">case</kbd> classes and pattern matching and that's what we have done here. Take a look at the following line from the previous solution:</p>
<pre class="calibre19">case Developer(id, _) =&gt; if(id.startsWith("DL")) amountCTC + 10000.0 else amountCTC </pre>
<p class="calibre2">Here we matched against a <kbd class="calibre11">case</kbd> class constructor. We gave some names to the required parameters, others we replaced with the wildcard <kbd class="calibre11">_</kbd> underscore. Here, we had to put a condition on the <kbd class="calibre11">id</kbd> parameter<em class="calibre18">,</em> hence we mentioned it in the constructor of the respective <kbd class="calibre11">case</kbd> class. You can see how <kbd class="calibre11">case</kbd> classes and pattern matching can make a slightly complex domain problem very easy to solve. Well, it doesn't end there, there's more. We can also put guards against our <kbd class="calibre11">case</kbd> expressions. Let's see the same example with guards:</p>
<pre class="calibre19">/* 
 * Process joining bonus if 
 *     :&gt; Developer has ID Starting from "DL"  JB: 1L 
 *     :&gt; Consultant has  ID Starting from "CNL":  1L 
 */ 
 def processJoiningBonus(employee: Employee, amountCTC: Double) = employee match { 
   case ContractEmp(id, _) =&gt; amountCTC 
   case Developer(id, _) if id.startsWith("DL") =&gt; amountCTC + 10000.0 
   case Consultant(id, _) if id.startsWith("CNL") =&gt;  amountCTC + 10000.0 
   case _ =&gt; amountCTC 
 } </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">65000.0 
75000.0 
66000.0 </pre>
<p class="calibre2">If we look at the following expression, we can see guards on our <kbd class="calibre11">case</kbd> patterns. So the value will only match if the guard allows it to:</p>
<pre class="calibre19">case Developer(id, _) if id.startsWith("DL") =&gt; amountCTC + 10000.0 </pre>
<p class="calibre2">So, before going to the right-hand side of the execution block, this expression checks if the <kbd class="calibre11">id</kbd> starts with <kbd class="calibre11">"DL"</kbd>, and based on that, it matches. This is how we can use a constructor directly to extract parameters and use them. You can also use patterns in some more ways. For example, we can perform a match against a sequence or a tuple. It's also possible for when we have to match some nested expression, or match a <kbd class="calibre11">case</kbd> class that has another <kbd class="calibre11">case</kbd> class inside. For our code to make more sense, and for readability purposes, we can bind the nesting <kbd class="calibre11">case</kbd> class using the <kbd class="calibre11">@</kbd> symbol and perform pattern matching. Let's take an example:</p>
<pre class="calibre19">case class Car(name: String, brand: CarBrand) 
case class CarBrand(name: String) 
 
val car = Car("Model X", CarBrand("Tesla")) 
val anyCar = Car("Model XYZ", CarBrand("XYZ")) 
 
def matchCar(c: Car) = c match { 
  case Car(_, brand @ CarBrand("Tesla")) =&gt; println("It's a Tesla Car!") 
  case _ =&gt; println("It's just a Carrr!!") 
} 
 
matchCar(car) 
matchCar(anyCar) </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">It's a Tesla Car! 
It's just a Carrr!! </pre>
<p class="calibre2">The preceding example is self-explanatory. We have a nested <kbd class="calibre11">case</kbd> class inside our <kbd class="calibre11">Car</kbd>, named <kbd class="calibre11">CarBrand</kbd>, and we performed a pattern match against that. We got access to that particular object using the <kbd class="calibre11">@</kbd> symbol. So, these are a few ways we can use pattern matching to perform all those tasks very easily. By now, you must have an idea about pattern matching; how powerful and important it is.</p>
<p class="calibre2">While performing all these pattern matches, we felt that there are counter cases where we don't want to perform matches, and use a wildcard so that we can provide any value in return. It's possible that there's no intended value for such cases, and we just want our code to make sense and at the same time return a meaningful response. In those cases, we can use our <kbd class="calibre11">Option</kbd> type. As the name suggests, when you define a type as <kbd class="calibre11">Option</kbd>, you may get either some value or no value. To make it more clear, let's recall our <kbd class="calibre11">safeToInt</kbd> function:</p>
<pre class="calibre19">def safeToInt(canBeNumber: String): Option[Int] = { 
  try { 
    Some(canBeNumber.toInt) 
  } catch { 
    case NonFatal(e) =&gt; None 
  } 
} 
 
safeToInt("10") match { 
  case None =&gt; println("Got nothing") 
  case Some(value) =&gt;  println(s"Got $value") 
} </pre>
<p class="calibre2">Here, in the definition of our <kbd class="calibre11">safeToInt</kbd> <span>function,</span> we defined our response type to be <kbd class="calibre11">Option</kbd> simply because we knew that it may or may not respond with a meaningful value. Now the reason for using an <kbd class="calibre11">Option</kbd> instead of using any type directly is clear, let's discuss the <kbd class="calibre11">Option</kbd> type.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Option type</h1>
                
            
            <article>
                
<p class="calibre2">Option is one of the type constructors that Scala provides. The question arises, what's a type constructor? The answer is simple; it lets you construct a type. We'll take two statements:</p>
<ol class="calibre13">
<li value="1" class="calibre8"><kbd class="calibre11">Option</kbd> is a type constructor</li>
<li value="2" class="calibre8"><kbd class="calibre11">Option[Int]</kbd> is a type</li>
</ol>
<p class="calibre2">Let's discuss these in detail. When I say <kbd class="calibre11">Foo</kbd> is a type constructor, it means that <kbd class="calibre11">Foo</kbd> expects you to provide a particular type in the form of a parameter. It looks like <kbd class="calibre11">Foo[T]</kbd>, where <kbd class="calibre11">T</kbd> is an actual type. We call them <strong class="calibre1">type parameters</strong> and we'll talk about them in the following few sections.</p>
<p class="calibre2">In the second statement, we saw that we gave an <kbd class="calibre11">Int</kbd> type to our <kbd class="calibre11">Option</kbd> type constructor in brackets and it formed a type. If you try this in the Scala REPL, it'll tell you exactly the same thing we discussed:</p>
<pre class="calibre19">scala&gt; val a: Option = Some(1) 
&lt;console&gt;:11: error: class Option takes type parameters 
       val a: Option = Some(1) 
 
scala&gt; val a: Option[Int] = Some(1) 
a: Option[Int] = Some(1) </pre>
<p class="calibre2">In simple words, the <kbd class="calibre11">Option[T]</kbd> <span>type</span> represents an optional value of any given type <kbd class="calibre11">T</kbd>. Now <kbd class="calibre11">T</kbd> can be any type you pass, in the previous example it was <kbd class="calibre11">Int</kbd>. The <kbd class="calibre11">Option[T]</kbd> type has two subtypes:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">Some(T)</kbd></li>
<li class="calibre8"><kbd class="calibre11">None</kbd></li>
</ul>
<p class="calibre2">When there's a value available, we'll get the <kbd class="calibre11">Some</kbd> value, otherwise <kbd class="calibre11">None</kbd>. The <kbd class="calibre11">Option</kbd> type also provides you a <kbd class="calibre11">map</kbd> method. The way you would want to use an option value is by calling the <kbd class="calibre11">map</kbd> method:</p>
<pre class="calibre19">scala&gt; a map println 
1 </pre>
<p class="calibre2">What happens here is the <kbd class="calibre11">map</kbd> method gives you the respective value if it's available. Otherwise, if the optional value is <kbd class="calibre11">None</kbd>, it's not going to do anything. Usually, you would want to use this type as an exception handling mechanism. How can we do this? We've already seen an example of it. Recall our <kbd class="calibre11">safeToInt</kbd> method, without <kbd class="calibre11">Option</kbd> it'll look like this (maybe):</p>
<pre class="calibre19">def safeToInt(canBeNumber: String): Int = { 
  try { 
     canBeNumber.toInt 
  } catch { 
    case NonFatal(e) =&gt; throw Exception 
  } 
} </pre>
<p class="calibre2">But if you take a look at the signature, the declaration tells you that the function is going to return you an <kbd class="calibre11">Int</kbd> but the function, in reality, may also throw an <kbd class="calibre11">Exception</kbd>. That's neither intended nor correct. The function should follow its own declaration. Hence, we can use our <kbd class="calibre11">Option</kbd> type, which as a savior, does what our declaration says. <kbd class="calibre11">Option</kbd> is one of the constructs <em class="calibre18">functional programming</em> provides for you.</p>
<p class="calibre2">There're more of these and they provide you with some ready-to-use constructs. Some of them are the types, <kbd class="calibre11">Either</kbd>, <kbd class="calibre11">Try</kbd>, and a few more. You may refer to the Scala API documentation (<a href="http://www.scala-lang.org/api/2.12.3/scala/util/Either.html" class="calibre10">http://www.scala-lang.org/api/2.12.3/scala/util/Either.html</a>) for more information about these types.</p>
<p class="calibre2">Next, we'll talk about one more functional construct. It's more than just a construct, it's a scheme of evaluation. Yes, we are talking about <em class="calibre18">lazy evaluation.</em> Scala allows you to use this scheme in more than one way. Let's talk about the <kbd class="calibre11">lazy</kbd> keyword.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lazy declaration</h1>
                
            
            <article>
                
<p class="calibre2">Before learning more about the <kbd class="calibre11">lazy</kbd> keyword or lazy evaluation, let's talk about why we need it and <span>exactly</span> what it is. Just how beneficial lazy evaluation is can be explained with a few lines, or a few pages, <span>but for our understanding let's have a one liner.</span></p>
<p class="calibre2"><strong class="calibre1">Lazy evaluation</strong> lets you write your code in a way where the order of evaluation doesn't matter. It also saves you some time, by only evaluating expressions that you need. It's like so many complex evaluations, that exists in your code, but never evaluation dues to a certain. The last line is only possible due to the concept of lazy evaluation. In Scala, you can declare a value as <kbd class="calibre11">lazy</kbd>. Let's take an example. Try the following in the Scala REPL:</p>
<pre class="calibre19">scala&gt; lazy val v = 1 
v: Int = &lt;lazy&gt; 
 
scala&gt; val z = 1 
z: Int = 1 </pre>
<p class="calibre2">Here, when we assigned a value of <kbd class="calibre11">1</kbd> to our <kbd class="calibre11">val v</kbd>, the REPL gave us the <kbd class="calibre11">Int</kbd> type and the value as <kbd class="calibre11">&lt;lazy&gt;</kbd>, and for the <kbd class="calibre11">val z</kbd> we got <kbd class="calibre11">1</kbd>. Why this happened is because of the <kbd class="calibre11">lazy</kbd> declaration. In Scala, when you declare a value as lazy, the compiler evaluates the value only when we use it for the first time. With this, you free yourself from the worry of putting the <kbd class="calibre11">val</kbd> declaration in any order. Each <kbd class="calibre11">lazy</kbd> value is evaluated when it's needed.</p>
<p class="calibre2">While we're talking about making our code optimized, let's look at another concept, <em class="calibre18">tail call optimization.</em> We first introduced <em class="calibre18">tail call optimization</em> in <a href="part0077.html#29DRA0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 3</a>, <em class="calibre18">Shaping Up our Scala Program</em> while discussing <em class="calibre18">recursion.</em> Let's talk about it in brief.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tail call optimization</h1>
                
            
            <article>
                
<p class="calibre2">We are familiar with the limitations recursion brings with it. We are aware that each function call, if not tail recursive, builds a new stack frame. For scenarios where we have to deal with a large number of function calls, this could possibly result in a stack overflow, which is undesirable. So, what's suggested in this kind of scenario is to make the recursive function call the last statement in your function definition, the Scala compiler then does the rest for you. Take a look at the following:</p>
<pre class="calibre19">import scala.annotation.tailrec<br class="title-page-name"/><br class="title-page-name"/>object TailRecursion { 
  def main(args: Array[String]): Unit = { 
      val list = List("Alex", "Bob", "Chris", "David", "Raven", "Stuart") 
    someRecursiveMethod(list) 
 
  } 
 
  /* 
      You have a sorted list of names of employees, within a company. 
      print all names until the name "Raven" comes 
  */ 
  @tailrec 
  def someRecursiveMethod(list: List[String]): Unit = { 
      list match { 
        case Nil =&gt; println("Can't continue. Either printed all names or encountered Raven") 
        case head :: tail =&gt; if(head != "Raven") { 
          println(s"Name: $head") 
          someRecursiveMethod(tail) 
        } else someRecursiveMethod(Nil) 
      }<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Name: Alex 
Name: Bob 
Name: Chris 
Name: David 
Can't continue. Either printed all names or encountered Raven </pre>
<p class="calibre2">In the preceding example, if you take a closer look, you'll see that wherever we made a recursive call, it's the last statement in that particular scope. It means that our call to <kbd class="calibre11">someRecursiveMethod</kbd> is a last call and there was no other call after that. If it isn't, the Scala compiler will alert you with a message saying the recursive call is not in the tail position:</p>
<pre class="calibre19">@tailrec 
def someRecursiveMethod(list: List[String]): Unit = { 
    list match { 
      case Nil =&gt; println(s"Can't continue. Either printed all names or encountered Raven") 
      case head :: tail =&gt; if(head != "Raven") { 
        println(s"Name: $head") 
        someRecursiveMethod(tail) 
        println("Won't happen") 
      } else someRecursiveMethod(Nil) 
 
    } 
} 
Error:(21, 30) could not optimize @tailrec annotated method someRecursiveMethod: it contains a recursive call not in tail position 
someRecursiveMethod(tail) </pre>
<p class="calibre2">Also, one thing to notice is that we're helping out the Scala compiler by providing the annotation as <kbd class="calibre11">tailrec</kbd>. When we provide this annotation, the compiler considers your function as a tail recursive function. Evaluation of such a function does not create separate stack frames on each call, but uses the ones already created. This is how we avoid stack overflow and use recursion. What we've tried to do in our example is match to a list of names. Yes, you're already familiar with the notion of pattern matching. If not <kbd class="calibre11">Nil</kbd>, we check for the name <kbd class="calibre11">Raven</kbd> in the list<em class="calibre18">,</em> and then we stop further calls. If you're missing <kbd class="calibre11">break</kbd> or <kbd class="calibre11">continue</kbd> statements in Scala, this is the way that you can implement them: by using recursion and checking for the condition.</p>
<p class="calibre2">So this was all about tail call optimization. We've also seen that the Scala compiler helps us when we provide the annotation. Well, recursion helps you avoid mutability and at the same time achieve complex logic, adding to the already powerful functional programming. Since we are learning about functional programming constructs, it's really important for us to know that they are rooted in <em class="calibre18">eternal mathematics.</em> Mathematics created the notion of functional programming, and almost all functional programming concepts come from some mathematical proof or concept. One of them is a combinator. Learning about combinators or understanding how they are related to mathematics is beyond the scope of this book but we will look at a short introduction and see a simple example. It'll be fun. Let's go through <em class="calibre18">combinators.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Combinators</h1>
                
            
            <article>
                
<p class="calibre2">Wikipedia says the following about <strong class="calibre1">combinators</strong>:</p>
<div class="packt_quote">"A Combinator is a higher-order function that uses only function application and earlier defined Combinators to define a result from its arguments."</div>
<p class="calibre2">As well as this definition, we could also say that a combinator is a closed <em class="calibre18">lambda</em> expression. We have already seen lambda applications in several places and defined them. A lambda is nothing more than an anonymous definition of any function. For example, when you pass an expression to our beloved <kbd class="calibre11">foreach</kbd> method, you pass it in the form of a lambda expression. Take a look at the following:</p>
<pre class="calibre19">val brands = List(Brand("Toyota", List(Car("Corolla", "Toyota"))), 
                  Brand("Honda", List(Car("Accord", "Honda"))), 
                  Brand("Tesla", List(Car("Model S", "Tesla"), 
                                      Car("Model 3", "Tesla"), 
                                      Car("Model X", "Tesla"), 
                                      Car("New Model", "Tesla")))) 
 
 
brands.foreach((b: Brand) =&gt; { 
  //Take the brand name, and check the number of Cars and print them.<br class="title-page-name"/>val brandName = b.name 
  println(s"Brand: $brandName || Total Cars:${b.cars.length}") 
  (brandName, b.cars) 
}) </pre>
<p class="calibre2">Here, the <kbd class="calibre11">foreach</kbd> method takes a lambda expression and executes it. To be more precise, <kbd class="calibre11">(b: Brand)</kbd> contained in the brackets is an example of a lambda. Now, let's ask some questions. What do lambdas have to do with combinators? Or let's ask, what's the working (functional) programmer's definition of a combinator? Well, to answer these kinds of questions, we'll use the first Wikipedia definition. If you take a closer look, there are a few things to notice. Firstly, it's a higher-order function and secondly, it's a closed lambda. Closed means it does not contain any <em class="calibre18">free</em> variables. For those of you who want to know what a free variable is, take a look at the following lambda:</p>
<pre class="calibre19">((x) =&gt; x * y) </pre>
<p class="calibre2">Here, <kbd class="calibre11">y</kbd> is a free variable. We've seen these kinds of higher-order functions with no free variables before: our <kbd class="calibre11">map</kbd> and <kbd class="calibre11">filter</kbd> functions. These are called combinators. In functional programming, we tend to use these a lot. You can also use these as transformations to already available data. If we use these combinators together, they're really helpful for forming data flow logic. This means, if you use <kbd class="calibre11">map</kbd>, <kbd class="calibre11">filter</kbd>, and <kbd class="calibre11">fold</kbd> as combinators together, you can create a domain logic out of your program. This way of writing programs is often used in functional programming. You'll find more of these when you check out the <span>written</span> libraries. Various combinators are used for all sorts of collections and other data structures. The reason for using these combinators is that they provide an abstract or, in other words, a generalized approach to perform some operations. Hence they're used everywhere. It's easy and fun to implement some logic that looks like the following:</p>
<pre class="calibre19">creditCards.filter(_.limit &lt; 55000)<br class="title-page-name"/>               .map(cc =&gt; cc.accounts(cc.holder))            .filter(_.isLinkedAccount) 
  .get 
  .info </pre>
<p class="calibre2">It's really a powerful construct and used a lot in functional programming.</p>
<p class="calibre2">Now that you've learned about combinators, and are also aware of higher-order functions, you're equipped to solve programming problems. So what now? It's time to take the next step. We'll dive into the abstract (sea) levels of Scala programming. If we can make our solutions abstract, it means the solutions we provide should satisfy more than just one problem statement. Let's start with learning about t<em class="calibre18">ype parameterization.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type parameterization</h1>
                
            
            <article>
                
<p class="calibre2">For an introduction to <strong class="calibre1">type parameterization</strong>, we'll refer to two examples we've already seen to try to make some sense of it. I know you're following the chapter with interest and you've gone through the examples and concepts we've talked about, so let's do an exercise. Think of our savior, <kbd class="calibre11">Option[T]</kbd> <span>type</span> and try to think why you would want to pass a type (as it requires <kbd class="calibre11">T</kbd> to be a type) to <kbd class="calibre11">Option</kbd>. What purpose can it serve?</p>
<p class="calibre2">I think you've come up with some idea. Maybe you thought that by passing a type of our choice, we can make our code with the <kbd class="calibre11">Option</kbd> type work in more than one scenario. If you thought so, great! Let's call it generalizing our solution. And moreover, let's call the approach a generic approach to programming. How does it look? Let's take a look at the following code:</p>
<pre class="calibre19">object TypeParameterization { 
 
  def main(args: Array[String]): Unit = { 
      val mayBeAnInteger = Some("101") 
      val mayBeADouble = Some("101.0") 
      val mayBeTrue = Some("true") 
 
    println(s"Calling mapToInt: ${mapToInt(mayBeAnInteger, (x: String) =&gt; x.toInt)}") 
    println(s"Calling mapToDouble: ${mapToDouble(mayBeADouble, (x: String) =&gt; x.toDouble)}") 
    println(s"Calling mapToBoolean: ${mapToBoolean(mayBeTrue, (x: String) =&gt; x.toBoolean)}") 
  } 
  def mapToInt(mayBeInt: Option[String], function: String =&gt; Int) = function(mayBeInt.get) 
 
  def mapToDouble(mayBeDouble: Option[String], function: String =&gt; Double) = function(mayBeDouble.get) 
 
  def mapToBoolean(mayBeBoolean: Option[String], function: String =&gt; Boolean) = function(mayBeBoolean.get) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Calling mapToInt: 101 
Calling mapToDouble: 101.0 
Calling mapToBoolean: true </pre>
<p class="calibre2">So as the code suggests, we have some optional strings, which can be of the <kbd class="calibre11">Int</kbd>, <kbd class="calibre11">String</kbd>, or <kbd class="calibre11">Boolean</kbd> type<em class="calibre18">.</em> Our intention was to convert them to their respective types. So we formed some functions, which take the optional string and then we convert them to their respective types, so we passed a function literal for that. If we can't think of a few counter cases, then it means it's working. However, the solution is bulky; it doesn't feel good. Plus, we can see that there's some repetitiveness in the code. We are doing an almost similar operation to <kbd class="calibre11">mapToXXX</kbd>, where we think of <kbd class="calibre11">XXX</kbd> as any type. It seems that we can generalize the solution. Let's think about it, how can we do this?</p>
<p class="calibre2">How can we tell the method about the types we are going to provide? One solution is to pass the types to the method as parameters and then use them in the declaration. Let's try the solution and see what the code looks like:</p>
<pre class="calibre19">object TypeParameterization { 
 
  def main(args: Array[String]): Unit = { 
      val mayBeAnInteger = Some("101") 
      val mayBeADouble = Some("101.0") 
      val mayBeTrue = Some("true") 
 
    println(s"Calling mapToValue: ${mapToValue(mayBeAnInteger, x =&gt; x.toInt)}") 
    println(s"Calling mapToValue: ${mapToValue(mayBeADouble, x =&gt; x.toDouble)}") 
    println(s"Calling mapToValue: ${mapToValue(mayBeTrue, x =&gt; x.toBoolean)}") 
  } 
 
  def mapToValue[T](mayBeValue: Option[String], function: String =&gt; T) = function(mayBeValue.get) 
} </pre>
<p class="calibre2">The result is as follows:</p>
<pre class="calibre19">Calling mapToValue: 101 
Calling mapToValue: 101.0 
Calling mapToValue: true </pre>
<p class="calibre2">After the generalization, we are able to perform the same logic with just one function. So, let's take a look at the change and the way we gave type parameters:</p>
<pre class="calibre19">def mapToValue[T](mayBeValue: Option[String], function: String =&gt; T) : T = function(mayBeValue.get) </pre>
<p class="calibre2">In the preceding <kbd class="calibre11">mapToValue</kbd> function, after giving the function name, that is, <kbd class="calibre11">mapToValue</kbd>, we gave <kbd class="calibre11">T</kbd> in braces as a type parameter. With this, we got the license to use this type parameter in the function declaration and definition. Hence, we used it as a type in a function literal and as return types. We're allowed to give any number of type parameters based on the use. For example, if you want to make it more generalized, the function may look like the following:</p>
<pre class="calibre19">def mapToValue[A, B](mayBeValue: Option[A], function: A =&gt; B) : B = function(mayBeValue.get) </pre>
<p class="calibre2">In this definition, we used two type parameters, <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd>, and hence made our method more generalized. If you take a look at the <kbd class="calibre11">map</kbd> method from <kbd class="calibre11">Option[T]</kbd>, it looks like the following:</p>
<pre class="calibre19">def map[B](f: A =&gt; B): Option[B] = if (isEmpty) 
     None 
 else 
     Some(f(this.get)) </pre>
<p class="calibre2">Here, we have used type parameters in the function definition of <kbd class="calibre11">map</kbd>. So, according to this, for <kbd class="calibre11">Option[A]</kbd>, we have a <kbd class="calibre11">map</kbd> method, which takes a function from <kbd class="calibre11">A</kbd> type to <kbd class="calibre11">B</kbd> type. So the compiler will infer the <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd> type when you give a call to this <kbd class="calibre11">map</kbd> method from the context.</p>
<p class="calibre2">This is just an introduction to type parameterization. In the next chapter, we'll get to see more of it along with some advanced concepts. With this, we can end our chapter, let's summarize what we've learned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter gave us insights into how we can implement logic with different flavors of implementation. We talked about for expressions and their translation into higher-order functions. We saw how <em class="calibre18">pattern matching</em> can make complex logic look very simple. We also talked about constructs such as <kbd class="calibre11">Option</kbd> and the <kbd class="calibre11">lazy</kbd> keyword. These enable us to write code that is meaningful and optimized. Then we discussed <em class="calibre18">tail call optimization</em>. We confronted <em class="calibre18">combinators</em>, and then finally we got an introduction to <em class="calibre18">type parameterization</em>.</p>
<p class="calibre2">In the next chapter, we'll start from where we ended this chapter. We'll talk more about types, parameterized types, and variance relationships, and let me tell you, that will be fun.</p>


            </article>

            
        </section>
    </body></html>