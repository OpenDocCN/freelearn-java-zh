- en: Getting Familiar with Scala Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The code that you write should absorb more meaning without becoming bloated
    or losing comprehensibility."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Anonymous'
  prefs: []
  type: TYPE_NORMAL
- en: 'In any programming language, one of the essential requirements is to have a
    way of working with a set of data, or, in other words, a collection of data. If
    you have worked with any programming language, you must already know the importance
    of its collection framework. Scala has a rich variety of collections; a rich set
    of helper functions makes it a lot easier to work with any Scala collection. In
    this chapter, we''ll go through all the essentials of Scala collections. We''ll
    be able to distinguish between several collection options, and also make efficient
    use of all collections. Along the way, we''ll learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and mutable Scala collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala's collection hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used collections in Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rich operations performed on collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversion from a Java to a Scala collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collection performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start learning about immutable and mutable collections in Scala,
    we''ll try to solve a simple problem using powerful methods provided by Scala
    collections. For that, let''s take a look at a scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: RESTful APIs
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding image, we have a set of APIs with method types such
    as `GET`, `POST`, and `PUT`, and their associated URIs. As these are two entities
    (method and URI), think of all these as a list of tuples*.* Now we want to segregate
    them, so we can create a map, as shown in the right column of the preceding image.
    A map is a collection that stores values in a key-value pair. Hence, on the right
    side you can see API information as key-value pairs, where key is the method name,
    and the value is a list of URIs for that particular request type. So, the idea
    is to convert `List[(String, String)]` to `Map[String, List[String]]`*.* You may
    want to think about the solution, and come up with your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, let''s see if Scala helps us in any way with our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have come up with a set of `for` loops or recursive methods to accomplish
    what can be done using a single method, you may want to rethink, or take a look
    at the solution we have here. Here, we used two utility methods that fulfill our
    purpose. The first one is `groupBy`*,* defined in the `TraversableLike` trait,
    which converts our `List[(String, String)]` to a `Map[String, List[String]]` grouped
    by the first element of the tuple, the method names. This `groupBy` operation
    gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter is the `mapValues` method from `MapLike` trait, which is used to
    wrap the given map with the same key. The value for each key is simply `f(this(key))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These two methods were enough to provide the solution, and helped us avoid many
    traversals using loops. This is just one example, and a lot can be done within
    only few lines of code that would otherwise have taken several lines. This really
    makes Scala collections powerful. Scala's collection framework is easy to use;
    most of the helper methods are universal, with a few exceptions. Also, there is
    no compromise with performance; these are performance-tuned methods. One can rely
    on these methods to accomplish any logic; it makes your code look nicer. But that's
    not all, it's just the beginning. Usually, collections are prone to code that
    is written with the current environment in mind. That usually makes it hard to
    debug what went wrong, specifically when mutable collections are in place. So,
    just to remove this complication, Scala has these immutable data collections.
    Once created, the immutable collections can't be updated. But how do they work,
    and how are they different from mutable collections? Let's go through and try
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable and mutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A collection is used to contain data that is used by the program later in time.
    In a multithreaded environment, if multiple threads try to access a collection
    at the same time, this can give you a hard time debugging what went wrong. That
    is a problem programmers usually face when working with collections in a multithreaded
    environment. But there''s a universal solution for that, which expects you to
    use an immutable collection. Immutable means you can''t change/mutate it. Scala
    provides you options to choose from: `root`, `mutable`, and `immutable` collections.
    These three are variants that exist in three separate packages: `scala.collection`*,*
    `scala.collection.mutable`, and `scala.collection.immutable`*.* If you don''t
    specify the collection and use one, it''ll be an immutable one by default. But
    how do these work, exactly? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A collection that does not allow us to update or delete its elements is of not
    much use. So, why do we say these are rich collections? The reason is that even
    though these are immutable collections, there are ways to add and remove elements,
    but these actions return a new collection altogether. We'll see how these are
    constructed and then how adding an element affects the collection later in this
    chapter; but for now, it's important to know that immutable collections can be
    updated, although doing so returns another collection with the same set of elements,
    along with the updated collection.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we have mutable collections, which work similar to most object-oriented
    programming languages. You can declare and instantiate a collection with a few
    elements. Then, based on any requirements afterwards, you can change its elements,
    or remove them. With these mutable collections, Scala gives you a choice to make
    when selecting a collection to work with. When you use mutable collections, you
    get an extra set of methods to mutate the collection. Be sure, though, about the
    instances where you may mutate collections. That'll make your program world free
    of mutability complications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third variant, root collections, resides in the `scala.collection`package*.*
    When you use a root collection, it can be mutable or immutable. What does that
    mean? It means that a particular collection is a superclass of a collection from
    the same family residing in both the `scala.collection.mutable` and `scala.collection.immutable`
    packages. To understand what we just said, take a look at the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `afunction` function can take both mutable and immutable collections, as
    long as they are Iterable, which is one of the traits available in Scala's collection
    hierarchy*.*
  prefs: []
  type: TYPE_NORMAL
- en: There are few extra methods that let you mutate your collection, and as we may
    expect, those are defined only for collections in the `scala.collection.mutable` package, not
    the `scala.collection` or `scala.collection.immutable` packages*.* In that case,
    it's clear that while writing your root collection, the Scala compiler is not
    going to allow you to update your collection. We talked about one of the use cases
    of root collections where, regardless of the type of your collection, you can
    define a function—that is, `afunction`, that takes all sorts of collections. There
    are more ways we can find the use cases, or differentiate root and immutable collections.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between the root and immutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The differences between the `root` and `immutable` collection use cases are
    easy to understand with the help of a scenario. Think of a scenario where:'
  prefs: []
  type: TYPE_NORMAL
- en: A function declaration expects a collection as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function is not going to mutate the collection as part of the definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function can work well, regardless of the fact that the collection values
    can be changed by other threads in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If these three scenarios are fulfilled, you''re welcome to use the `root` collection
    type as the parameter for your function definition. It means that the following
    declaration will work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the third scenario is not what you wish for, then use `scala.collection.immutable`*.*
    The scenario explains where we can use root collections. Just because you don't
    have access to methods that mutate collections, it doesn't put a constraint on
    the runtime modification of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: It's also important to know that even in these three packages, collections are
    present in a hierarchical manner. So, let's take a look at the hierarchy of collections
    in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchy of collections in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hierarchical structure of Scala collections is easy to understand. When
    you start working with collections, it becomes easy to use any method that is
    already defined in a super trait, and for specific implementations you can define
    your own versions. The structure has been classified in three distinct categories,
    that is: `root`*,* `mutable`*,* and `immutable`*.* We''ve discussed the differences
    between them. To strengthen our discussion, let''s take a look at the hierarchy
    of `root` package collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Root collection hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: The preceding hierarchy is for collections in the `root` package. All the collections
    inherited from the super trait are called **Traversable***.* Traversable defines
    the `foreach` abstract method, along with other helper methods that can relate
    to any collection in the hierarchy. So, it's clear that every other collection
    needs to give a definition of the `foreach` method in its implementation. We'll
    have a look at Traversable *trait* in the next few topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Traversable*,* there''s a *trait* named **Iterable**, which inherits
    *Traversable*, implements the `foreach` method from Traversable, and has its own
    *iterator* abstract method. From there, the hierarchy splits into three different
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Seq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three categories are different in implementation, context, and use cases.
    The first one is a sequence that's used to contain a sequence of elements, such
    as a sequence of numbers. Sequences are further classified as `LinearSeq` and
    `IndexedSeq`*.* The second one is a set, and it is a collection of distinct elements,
    which means elements can't be repeated. Sets are classified as `SortedSet` and
    `BitSet`*.* The last one is a map, which is a key-value-based collection that
    can have a `SortedMap`*.* These are all part of the `scala.collection` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the root package, let''s take a look at the collections hierarchy in the `scala.collection.mutable`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The scala.collection.mutable collections package
  prefs: []
  type: TYPE_NORMAL
- en: It may be frightening when you first see these, but it works as a utility when
    you use these collections wisely. Collections in the `scala.collection.mutable` package, as
    expected, contain methods that can be used to add/remove elements in the collection.
    The hierarchy of this package is similar to `Seq`, `Set`, and `Map` traits. Afterwards,
    more concrete implementations that are specific to some use cases are part of
    the package. The figure itself is self-explanatory; more and more implementations
    of these collection traits are there for us to use. `IndexedSeq` has more implementations
    now, such as `ArraySeq`*,* `StringBuilder`, and `ArrayBuffer`*.* Another trait,
    named `Buffer`, is introduced. A few implementations, such as `Stack`*,* `ArrayStack`,
    and `PriorityQueue` extend directly from `Seq` trait. In the same way, the other
    two traits, Set and Map, also have a few concrete implementations. HashSet and
    BitSet are for sets, and HashMap, LinkedHashMap, and ListMap extend Map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s take a look at the hierarchy of the `scala.collection.immutable`package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The scala.collection.immutable package
  prefs: []
  type: TYPE_NORMAL
- en: The collections hierarchy is similar to mutable collections apart from the fact
    that *immutable* collections, don't have the `Buffer` trait; the difference is
    that these collections do not have methods that let you mutate the same collection.
    Though it's possible to transform collections, it means that these collections
    have higher-order methods that can traverse and apply a function to each element,
    resulting in another collection. This is one of the ways to deal with immutable
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchy also has the *Traversable* and *Iterable* super traits*.* These
    traits consist of most helper methods. These are universal methods that can be
    used with almost any collection in Scala. By default, Scala assumes a collection
    to be of the `immutable` type. It's good if you use them. It's good to know that
    you can also create your own custom collections. For this, there's a sub-package
    named `generic` in the `scala.collection` package that consists of the helpers required to
    create a collection implementation.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement these collections, we assume there are ways to use and manipulate
    these collections, and indeed there are many higher-order helper functions that
    let you do so. Most of the basic and universal helpers are defined in super traits
    that other collections implement. Let's take a look at these traits.
  prefs: []
  type: TYPE_NORMAL
- en: Traversable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a super trait of all other implementations for collections in Scala. Traversable
    defines a few methods that help to access collection elements, or perform operations
    on them. These operations can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additions**: Methods that append two traversables together. For two traversable
    collections, such as `xs` and `ys`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs ++ ys`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformations**: Methods such as `map`, `flatMap`, and `collect` come in
    this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.map(elem => elem.toString + "default")`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversions**: Methods with a format such as `toXXX` *or* `mkString`*.* These
    are used to convert one collection to another suitable collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.toArray`, `xs.mkString`, and `` `xs.toStream` ``
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copying**: Helper methods that copy elements from a collection to another
    collection, such as an array or buffer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.copyToBuffer(arr)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Information retrievals**: Methods that retrieve information such as size,
    or whether the collection has elements or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.isEmpty`, `xs.isNonEmpty`, and `xs.hasDefiniteSize`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element retrievals**: Methods that retrieve an element from a collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.head` and `xs.find(elem => elem.toCharArray.length == 4)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub collections**: Methods that return a sub-collection, based on ordering,
    or a predicate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.tail`, `xs.init`, `xs.filter(elem => elem.toCharArray.length
    == 4)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Folding**: Methods that apply a binary operation on each of the successive
    elements of a collection. Also, there are some special forms of folding operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.foldLeft(z)(op)`, and `xs.product`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll go through implementation details of almost all these methods later
    in the chapter. For now, it''s important to know that the `Traversable` trait
    mixes in with `TraversableLike` and few other traits. If you don''t understand
    what a mix-in of traits is*,* we''ll discuss that when we talk about object-oriented
    programming in Scala in subsequent chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Traversable has an abstract `foreach`method*.* Any implementation that mixes
    in `Traversable` needs to define this abstract `foreach`method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the `foreach` method signature, it has a type parameter, `U`, which
    stands for the type of data that we'll impose when we'll use the method. The `foreach`
    method traverses the collection, applying a function to each of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Iterable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Iterable is also a trait that other collections mix in with. Iterable mixes
    in *Traversable*, and also defines the `foreach` abstract method. Iterable also
    has an abstract method named `iterator`*.* Implementations that mix in the *Iterable*
    trait have to define this abstract method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `iterator` method returns an `Iterator`*,* which has the `hasNext`
    and `next` methods. Using an Iterator, we can fetch all elements one by one, or
    perform an operation. A closer look will tell you that Traversable can traverse
    the whole collection in one go, while for an Iterable, the pull approach works
    well. Each iteration gives an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, Iterables support all methods from *Traversable*. Along with that,
    there are a few more methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sub-iterations**: Methods that return another chunked iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.grouped(size)`, and `xs.sliding(size)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub-collections**: Methods that return parts of collections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.takeRight(n)`, and `xs.dropRight(n)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zipping**: Methods that return iterable collection elements in pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.zip(ys)`, and `xs.zipWithIndex`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparisons**: Methods that compare two iterable collections according to
    the order of elements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs sameElements ys`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One possible declaration of `Iterable` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Iterable` trait mixes in `Traversable`, along with a few
    others. That's how it exists in the hierarchy. The following Iterables are three
    traits, named `Seq`*,* `Set`*,* and `Map`*.* Let's go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Seq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Seq` represents a sequence of elements. Its signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, `Seq` extends `PartialFunction`, but what does that mean? Remember,
    we discussed partial functions in the previous chapter. These functions are defined
    for a particular set of values from the domain. In the case of `Seq`, that domain
    is the `length -1`*.* It is clear from the signature that a `Seq` can take an
    `Int`, and responds with an element of type `A`*.* Here, `A` is the type of the
    collection element. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, when we define the sequence, it becomes a partial
    function of type `PartialFunction[Int, Int]`. It means that passing any value
    from its length - 1 as a parameter to our sequence will result in a value from
    the sequence of type A*,* which in our case, is also an `Int`*.* The reason that
    a `Seq` is defined for only some particular values from the domain is to show
    that if we pass an index for which `aSeq` does not have a value, it will give
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Seq`, being a `PartialFunction`, can prove a boon for us as developers,
    as there are many instances where very complex logic can become so easy to implement.
    There''s also a method, `isDefinedAt`*.* As you may be aware, we can use it to
    check whether the partial function is defined for the value. A sequence is said
    to have a length, and encompasses two variants, named `IndexedSeq` and `LinearSeq`*.*
    These names imply most of what these collections are there for. An indexed sequence
    is recommended to use when we access them via indexing; in other words, by calling
    the `length` or `apply` methods.  A linear sequence, however, is used where the
    performance of a subsection of a collection is important. It means that calling
    a method on a collection and breaking it into sub-sequences is important. Now,
    after knowing all this, let''s take a look at the categories of operations that
    can be performed on these sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Length and indexing**: Methods that depend on the length of the sequence,
    mainly via index or size:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.apply(1)`, `xs.length`, `xs.indices`, and`` ` xs.indexWhere(predicate)`
    ``
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additions**: Methods that add an element at the beginning or at the end of
    a sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `x+:(xs)` and `xs.:+(x)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updates**: Methods that update an element in a sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs(1) = 12` and `xs updated (1, 12)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting**: Methods that sort a given sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.sorted` and `xs sortWith op`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reversing**: Methods that reverse a sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.reverse`, and so on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparisons and checks**: Methods that reverse a sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.contains(x)` and `xs.endsWith(x)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-set operations**: Methods that results based on some set operations
    like union and distinct:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.union(ys)` and `xs.distinct`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll go through the implementation details of these methods in subsequent
    sections. Now, let''s take a look at different variants of sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's another form of sequences, named *Buffer*, that is mutable. It allows
    addition, update, removal, and other mutating operations on it. These mutations
    are done via methods such as +=, ++=, and *insert.* There's another sub-trait
    of *Iterable* which is called `Map`*.* Let's go through it.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Map` can be represented as a collection containing elements in the form
    of a key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve just shown, `Map` mixes in `Iterable` and `MapLike` traits, and `MapLike`
    extends the `PartialFunction` trait, so we can also use maps as a partial function.
    Also, it is worth noting the type parameters `K` and `V`*.* Here, type `K` binds
    a key to value `V`*.* Here''s how we can define a `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a map of type `string` to string, which means it maps
    a string key to a string value. As for any other collection, we need a few methods
    to access maps. There is more than one category for doing so. Let''s go through
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associations and lookups**: Methods that look up an element from a map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `as.get(key)`, and `as(key)`, `as` contains key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additions**: Methods that adds key-value pairs to an existing map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `as + (key -> value)` and `as ++ kvs`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removals**: Methods that remove a pair from a given map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `as - (key)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sub-collections**: Methods that return a sub-collection from a given map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `as.keys`, `as.keySet`, and `as.values`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transformations**: Methods that transform a map by applying a function to
    each value of a given map:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `as mapValues func`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `Map` can have several different variants based on the category, whether
    it''s mutable or immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Maps
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding image, we have a couple of variants of maps in Scala. Did you
    notice that we have the same `HashMap` available in both the versions in different
    packages, *mutable* as well as *immutable*? We use these different maps depending
    on our requirements. After `Seq` and `Map`, there's another sub-trait of `Iterable`,
    named `Set`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Set` is a collection that contains multiple elements with no duplication
    at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the `Set extends (A) => Boolean` expression*,*
    which means that passing a parameter of type A to a set of type A will result
    in a Boolean. The Boolean result shows whether the `Set` contains the element
    passed as a parameter or not. Let''s see this in an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be seen that the value 2 is present in `aSet`, and the values 5 and
    0 are not, so therefore passing 5 or 0 results in false. Let''s go through a few
    methods defined in `Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparisons and checks**: Methods that check for a condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs.contains(x)`, and `xs.subsetOf(x)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additions**: Methods that add an element or a collection of elements to a
    set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs + x` and `xs ++ ys`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removals**: Methods that remove an element or collection of elements from
    a set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs - x` and `xs -- ys`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary operations**: Methods that perform binary operations between two different
    sets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `xs | ys`, `xs & ys`, `xs` intersect `ys`, `xs` union `ys`, and
    so on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `Set` can have several different variants based on whether it''s mutable
    or immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sets
  prefs: []
  type: TYPE_NORMAL
- en: A few variants of sets contain different types, such as `HashSet`, `BitSet`,
    and `SynchronizedSet`, and based on the need, we can utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of some top-level collection traits in Scala, let's
    take a look at some concrete implementations of them. We'll talk about the common
    collections we use in Scala, the way they can be constructed, and how Scala treats
    a particular collection when we add or remove an element. It'll give you a brief
    idea of how Scala collections behave.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used collections in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start  by discussing a few immutable concrete collections.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is a linear sequence and can be defined simply, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax shown declares and instantiates the linear sequence with the elements
    provided. The runtime representation of the list constructed will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Nil` represents the end of the list. It''s normal to represent an empty
    list as `Nil`. The preceding representation is also a way to construct a list,
    and this is possible because of the "::" operator. This is called the *cons* operator,
    and it is used to construct a list. It''s a right-associative operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the *cons* operator on the list results in a list with the new element
    added at the beginning of the list. This is equivalent to calling the same, using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve mentioned that operations such as adding an element to a list don''t
    affect the list that was previously created, but it copies the same list to another,
    with an added element. The reason for this is that lists are immutable. A pictorial
    representation of how this might look will give you an insight into what is happening.
    So, let''s take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding an element to a List
  prefs: []
  type: TYPE_NORMAL
- en: The figure is self-explanatory, and represents the concept of adding an element
    to a list. Lists provide many higher-order functions, such as `map`, `flatMap`,
    and `filter`, which make it easy to work with. With this construction syntax and
    easier access to the list's head (the first element of the list) and tail (which
    represents every element in the list except the first), it is easy to create patterns
    of lists and use them in pattern matching based on your needs. Operations such
    as *fold* and *reduce* are also of higher importance, as they provide a mechanism
    to perform binary operations on elements within the sequence. These are high-performing
    data structures, and provide constant time access to their elements.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard immutable map can be instantiated as easily as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide as many key-value pairs as we want. We associate a key to its
    corresponding value by using the "-*>" *operator *.* It can be seen that the default
    implementation of a map corresponds to `scala.collection.immutable.Map[Int, String]`, and
    it''s not possible if we try to mutate the pairs. Though it''s possible to add
    new pairs to construct another map with updated elements using the *+ *method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But this will not change the map we declared `aMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also discussed that map and sequences are also a `PartialFunction`, so we
    can check whether a value has been defined for a particular key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Other versions of `Map` also exist, such as `ListMap`*,* and `SynchronizedMap`*.* These
    can be used if you need them. For example, you might prefer to use a `ListMap`
    when you need to traverse linearly on a map with better performance. Also, when
    mutable map implementation is needed in a thread-safe manner, one would prefer
    to use `SynchronizedMap`*.*
  prefs: []
  type: TYPE_NORMAL
- en: SortedSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `SortedSet` is a trait that represents a set of elements. It produces elements
    in a sorted manner based on ordering, because the default implementation stores
    elements in the form of a binary tree. One of the forms of `SortedSet` is a `TreeSet`*.*
    Creating a `TreeSet` expects you to provide an implicit `Ordering[A]` that takes
    care of the way elements will be ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to create a `TreeSet`, we''ll create an `Ordering` object in the current
    scope. Without `Ordering`*,* the compiler won''t allow you to create a `TreeSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncommenting the line where we define an implicit value for `Ordering` will
    work fine. So, uncomment that and try running it. This will result in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Streams** are powerful. Let''s see why. Streams can be of infinite length;
    it may sound impractical having a sequence of infinite length, but when the computation
    happens lazily, this works OK. Streams serve the same purpose and the computation
    happens lazily. Let''s see how we can create streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t do anything extraordinary, except replace the `List` keyword with
    `Stream`, but REPL gives us back something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here that `Stream` is computed only till the very first element,
    because there''s no need to go and compute other elements as of now. That''s what
    we call *lazy computation.* Streams can also be constructed using *cons* like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It's understandable that wherever we require our elements to compute lazily,
    we can use streams. One of the example use cases is when you require short-circuited
    evaluation from your function. You may pass a stream and evaluate. It's worth
    noting that a stream is not lazy with its head element, so your function will
    be evaluated for the first element.
  prefs: []
  type: TYPE_NORMAL
- en: Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The difference between the performance of a linear sequence and an indexed
    sequence starts to matter when our requirement is to manipulate elements in the
    middle of a sequence. And because of the linear performance of sequences such
    as a list, the performance degrades for them. Therefore, indexed sequences come
    to the rescue! Vector is an example of an immutable indexed sequence. The way
    to create a vector is to simply use the `Vector` keyword with its `apply` method,
    or to simply represent it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To add elements to `vector`, we can use methods such as ":+" and "+:":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These are indexed in order to retrieve a value by passing an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the value 3, because the index starts from 0\. It''s good that we can
    check whether a value is defined at a particular index, because it is a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible to update an element at a certain position by using the `updated`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'A call to this `updated` method with an index and an element replaces the element
    at the passed index with the element passed as a parameter. The good thing about
    this operation is that it takes constant time and doesn''t affect the original
    sequence. Hence, if you try to print the sequence we created, you''ll get the
    elements unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Immutable stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may need a collection with *last in first out* traversal. For that, Scala
    provides the `stack` implementation. It''s easy to create a stack, and `push`
    and `pop` elements in the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Stacks are immutable, so performing any operation will not change the elements
    from the stack that was created previously.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who don''t know it already, a queue is *first in first out* data
    structure. Two helper methods to put an element into a queue and remove them are
    `enqueue` and `dequeue`*.* Let''s create a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the method for enqueuing an element in a queue. It can
    be seen that `dequeue` returns the element removed along with the rest of the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Range describes a range of numbers. There are a few helper methods we can use
    to create a range in Scala. Let''s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We created two ranges. The first one simply contains numbers ranging from 1
    to 10, inclusive. Then we created numbers ranging from 1 to 10 with a step size
    of 2\. There''s also a way to create a range that does not include the last element.
    This can be done using the `util` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a range using the `Until` method containing numbers 1 to 5\.
    Printing this range yielded the numbers from 1 to 4, because `Until` does not
    include the last element. `Range` is also an immutable collection. Now, after
    going through these immutable collections, let's take a look at few mutable concrete
    collections. We'll start with the most common, `ArrayBuffer`*.*
  prefs: []
  type: TYPE_NORMAL
- en: ArrayBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ArrayBuffer` is only available as a mutable sequence in Scala. These are efficient
    collections; they make it easy to add an element at the end of a collection. `ArrayBuffer`
    is also an indexed sequence, so retrieving an element via an index doesn''t degrade
    the performance. Let''s see how we can create and use `ArrayBuffer` in Scala:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can create `ArrayBuffer` by first importing the `scala.collection.mutable`package. We
    can instantiate it by providing elements in the constructor. We can add and remove elements
    to the buffer using methods provided for `ArrayBuffer`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: ListBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ArrayBuffer` uses an array to store elements internally, whereas `ListBuffer`
    uses a linked list representation. Operations performed on these buffers are similar
    to that of `ArrayBuffers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that because of the internal linked list representation, it's
    recommended to use `ListBuffer` instead of `ArrayBuffer` if our requirement is
    to convert our collection to a list. It's applicable vice versa, if the requirement
    is to convert our collection to an array.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`StringBuilder` is used to build a sequence of strings. A simple call to `toString`
    will convert it to `String`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There're other mutable versions of stacks, queues, and maps. There are methods
    provided to update these mutable collections.
  prefs: []
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Array in Scala is defined as follows; it extends the `Serializable` and `Cloneable`
    traits from Java. Also, it can be seen that arrays are generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In Scala, arrays are mutable. Defining an array is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, it''s possible to perform the operations that we perform on sequences.
    Arrays are indexed and mutable as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It's also possible to perform map operations on an array, which makes Scala's
    arrays better than their Java counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have introduced all the common collections, and have a basic idea
    about how these collections can be declared and used. But what makes Scala collections
    powerful is the set of rich operations performed on these collections. There's
    a set of operations that can be performed using some higher-order methods available
    with these collections. It's time to go and take a look at those.
  prefs: []
  type: TYPE_NORMAL
- en: Rich operations performed on collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have quite a few methods for our collections, which we can use to simplify
    almost every problem regarding collections in Scala. We are going to take a look
    at some important methods. First, let''s set the stage: so consider a scenario
    where you have some structured data related to football players. and you have
    to perform manipulations based on that. We''ll perform a set of operations on
    the data using our collection. We''ll also learn about methods, their signatures,
    and use cases along the way. Here''s a simple code snippet that shows what we
    just said—nothing too interesting as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the thing—we have a CSV file that contains some data as comma-separated
    values. We can read the data in our program as a `BufferredSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will load the CSV file's contents. The first thing we can do is to convert
    the data into a readable format so that it gets easier for us to perform any operation
    on it. For that, we have a case class, `Player`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We'll try to read the content from the file and create a collection of players.
    The following expression reads from the buffered source, and converts each line
    to an element in a `List`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `getLines` method converts the buffered source to an `Iterator` object
    of string type. A call to the `toXXX` form of the method can be used to convert
    between *traversables.* We've made a call to the `toList` method on our `Iterator`
    object. This converts the *Iterable* of type string to a list of strings. There
    are other versions such as `toIterable`*,* `toSeq`*,* `toIndexedSeq`*,* `toBuffer`*,*
    `toSet`*,* and `toVector`*.* All these methods reside in a trait named `TraversableOnce`*.*
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `toXXX` method to convert into another Traversable of type `XXX`,
    where `XXX` is a placeholder for `Set`, `Vector`, `Buffer`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading the content from the CSV file, we now have a list of strings,
    with each string containing information about a player in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line has information such as the ranking of the player in the past few
    years, his/her name, nationality, club, points scored, and age. We''ll parse the
    string and map all the information to our `Player` object. Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this method, we see one important method that works for collections. Our
    `giveMePlayers` function parses the list of string, and as its name suggests,
    it returns a list of players. The function performs a pattern match on the list
    of strings. We have matched the list as `head :: tail`; it treats the head as
    the first element of the list, and the tail as the rest of the elements. It can
    also be seen that the list can be empty; in that case, the second scenario will
    be executed, and the function will return an empty list. As we know from the CSV,
    the first line contains the meta-information about the rest of the file. So we
    omit the `head` and perform a `map` operation on `tail`, that is, the rest of
    the list. The `map` method basically performs the given operation on each element
    and returns the collection with the resulting values. In our case, we''re splitting
    the comma-separated values from each line and converting values to the `Player`
    object. At the end of the call to the `map` method, we''ll get a list of players.'
  prefs: []
  type: TYPE_NORMAL
- en: The `map` method composes another collection, applying an operation passed to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the `map` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `map` method takes a function that converts type `A` to type `B`, and performs
    that operation to each element of the collection, and finally returns a collection
    of type B. In our case, types `A` and `B` were `String` and `Player`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a fully formed collection of `Players`, thanks to our `map` method.
    We can perform lots and lots of different operations. We can make a list of top
    10 players. How can this be done? By using our `filter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple; it''s just a call to filter, then we tell it what predicate
    to filter elements upon. It''ll do the filtering for you. We have checked the
    ranking for each player and preserved those for whom the value is less than 11:'
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` method filters the collection elements that satisfy the predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `filterNot` method filters the collection elements that do not satisfy the
    predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature of the `filter` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This `filter` method takes a predicate, based on the predicate. The method filters
    out the Traversable. Here, `Repr` is a type parameter for the collection, and
    our Traversable collection looks like `TraversableLike[+A, +Repr]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the method filters out the right players, you may want to
    print it and see. Why not print our players in some structured way? Take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined the `showPlayers` function, which takes a list and prints player
    information in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: I think you're keen enough to see that the filter traverses through the whole
    list to check whether the ranking is less than 11, bravo! Also, understand that
    this is not the way we would do this to our collection if the list were sorted.
    In that case, we've a few other methods, and one of them is `takeWhile`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This `takeWhile` method also takes a predicate, the same in our case, and returns
    a list of elements for which the predicate is true. In our case, it works, and
    we get the top 10 players:'
  prefs: []
  type: TYPE_NORMAL
- en: The `takeWhile` method takes the longest sub-collection of elements that satisfies
    the predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dropWhile` method drops the longest sub-collection of elements that satisfies
    the predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signature looks almost exactly like our `filter` method. It takes a predicate,
    and returns a Traversable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s also a `dropWhile` version of the method. Its intent is almost the
    same as `takeWhile`; the only thing that differs is that it drops those elements
    that satisfy the predicate. There can be more of this sort of method, based on
    the requirements we can use. One of them is the `partition` method, which splits
    apart our list into a tuple of two lists: one that satisfies the predicate, and
    other that doesn''t. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First, the `take`method selects 50 players from our list of *players.* Then,
    we call the `partition` method on our first 50 players, which splits our list
    into two sub-lists based on the predicate we pass. Here, we want to divide the
    first 50 players into two separate collections of 20 and 30 players. After calling
    this function, we get two new values, `top20` and `least30`, which have the top
    20 players and the bottom 30 players out of the first 50.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple one-liner can do this much with the collection of elements; that''s
    the power of Scala collections:'
  prefs: []
  type: TYPE_NORMAL
- en: The `take` method selects the first `n` elements from the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `drop` method drops the first `n` elements from the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `partition` method drops the first `n` elements from the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The signatures of these methods are simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `take` and `drop` methods take the number of elements to select or drop.
    The other method, `partition`, expects a predicate, splits the collection into
    two sub-collections, and returns a tuple of those two sub-collections. There are
    a few more of these methods; let''s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: The `slice` method selects an interval of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `span` method splits the collection into two collections based on the predicate,
    where the order of elements is not preserved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `splitAt` method splits a collection at a given position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods are simple, as they do exactly what their description implies.
    Their description also explains the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `slice` method takes the initial and last index, and returns that number
    of elements as a collection. The second method, `span`, works exactly the same
    as the `partition` method. It takes a predicate and returns a pair of collections:
    the first satisfies the predicate, and second does not. It''s possible that the
    order of elements has not been preserved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of the three, `splitAt`, takes a value `n` and returns a pair of sub-collections,
    split at `n`. These methods make it easy to implement scenarios such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at one more set of methods, using which we can check for
    a predicate in our collection:'
  prefs: []
  type: TYPE_NORMAL
- en: The `count` method counts the number of elements that satisfy a given predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exists` method checks whether a predicate holds true for even a single
    element in a given collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `forAll` method checks whether a predicate holds true for all elements in
    a given collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` method finds the first element that satisfies a predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can count the number of players from a particular country like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The partial function `isGermanPlayer` checks for a player''s nationality. We
    then passed this partial function as a predicate to the `count`method*,* which
    gives the number of players. We may also want to check whether there are any players
    with an age above 45, and we may check that using the `exists` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The are two other methods, `forAll` and `find`*.* We''ll check the top player
    with an age of more than 35 years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods are simple yet powerful, and composing them can bring down our
    solution approach to easy. Let''s find the top 5 players by ranking, with ages
    over 35:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the examples is where we first called the `filter` method on our list
    of players, then called take 5 to select first 5 from results. We''ve seen these
    examples, so let''s take a look at the definitions of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: All methods take a predicate and respond differently. The `find` method selects
    the very first element from a collection for which the predicate is satisfied.
    The next ones, `count` and `exists`, check for the total number of elements that
    satisfy the predicate, and whether any single element for which the predicate
    is satisfied exists, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `forAll` method checks whether the predicate is satisfied for
    all elements in the collection. We can also call for a check if there''s any element
    in our list using `isEmpty`, because it''s obvious your filter on a collection
    results is an empty list. There''re few methods to use to check information about
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `isEmpty` method counts the number of elements that satisfy a given predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hasDefiniteSize` method checks whether a predicate holds true for even
    a single element in a given collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `size` method checks whether a predicate holds true for all elements in
    a given collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These methods, as their names suggest, are simple to use and clear to understand
    as well. You remember we did a pattern match on a list using `head :: tail`? Well,
    we can also call these methods on our collection in the same way. There exists
    a few more utility methods to access list elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The `head` method returns the head element of the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tail` method returns all elements except the head element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `init` method returns all but the last element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `last` method returns the last element of the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reverse` method returns the list in reverse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use these methods while doing a pattern match, or whenever we may have
    to retrieve the first or last elements. Using the `init` or `tail` methods recursively
    is also a way to utilize list elements. Finally, one of the most important operations
    we can perform on a list of elements is to fold or reduce the list into a value—a
    single value. So, we can fold our list of players and construct another list of
    country names from that. How we can do this? Let''s take a look at how we can
    use `fold` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fold` method folds collections using a binary associative operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `foldLeft` method folds collections by applying a binary operation to the
    initial, and then each element going from left to right
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `foldRight` method folds collections by applying a binary operation to the
    initial, and then each element going from right to left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we want to construct a list of country names from our top 20 players''
    information. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get the following on running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done by going from right to left through the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get the following on running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the `fold` methods look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The method takes an initial value; in our case, it's a list. Then we pass a
    function that works on each element from our collection, and the value passed
    works as a seed to our operator function. The `foldLeft` and `foldRight` methods perform
    a binary operation on these two elements until it processes the last element in
    the collection, thus producing the final value for us. If you take a look at both
    of these methods, you'll be able to see that the order of parameters has changed.
    Also, the signatures of these `foldLeft` and `foldRight` methods are curried.
    The first curried parameter is the initial element, which works as an accumulator
    as we traverse through or fold our collection. The second parameter, which is
    a binary function, takes place and is applied to collection elements. This `fold` function
    results in one value over a collection that's an accumulated response for the
    whole collection.
  prefs: []
  type: TYPE_NORMAL
- en: After working with all these methods that make it easier to work with collections,
    let's take a look at a method that can convert our collection to a parallel collection,
    which can be processed in parallel. The method is `par`*:* when you call the method
    on our collection, it returns a `ParSeq`*, *that is, a parallel sequence. This
    parallel sequence is a parallel equivalent of our collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to print the elements from this sequence quite a few times, the
    order will not be preserved, because of the parallel nature of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get the following on running the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know we can convert our collections into their parallel equivalents,
    there should be other ways to build parallel collections. Let's go through parallel
    collections in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel collections in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's obvious that if the number of elements in a collection is very large, then
    you would want to minimize the time it takes to manipulate the collection data.
    That's where breaking down the tasks and executing them parallel is an option,
    and a good one. Scala provides parallelism in the form of parallel collections,
    which works like a charm in scenarios where we have to deal with a big chunk of
    data. The good thing is that our  `par` method can easily convert a normal sequential
    collection to its parallel counterpart implicitly, and the `map`*,* `fold`, and
    `filter` methods work great with parallel collections as well.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the architecture of parallel collections, or how these work on
    JVM, is out of the scope of this book. We'll keep our discussion limited to concrete
    implementations of parallel collections, and how we can use them in Scala. If
    you're into understanding parallel collections, Scala's documentation gives a
    brief overview at [http://docs.scala-lang.org/overviews/parallel-collections/overview](http://docs.scala-lang.org/overviews/parallel-collections/overview).
    Another resource is the book *Learning Concurrent Programming in Scala* by Aleksandar
    Prokopec*.* For now, let's start with the concrete implementations of parallel
    collections in Scala. There are a few parallel collection classes, such as `ParArray`*,*
    `ParVector`*,* and `ParRange`*,* and also a few `set` and `map` implementations
    such as `ParHashMap` and `ParHashSet`*.*
  prefs: []
  type: TYPE_NORMAL
- en: ParArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParArray` constructor is the parallel implementation of `ArraySeq`, and
    holds elements in a linear fashion. It resides in the `scala.collection.parallel.mutable`
    package. To create a parallel array, we can import this package as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a parallel array named `pararr` by simply using the `ParArray`
    constructor, with elements passed as arguments. For demonstration purposes, we''re
    using a limited number of elements in our implementation, but it''s obvious we
    would like parallel abstractions to contain a higher number of elements to really
    work effectively. It''s also possible to convert a parallel collection into its
    sequential counterpart using the `seq` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: A parallel array is a parallel mutable collection. We also have immutable versions
    of parallel collections. `ParVector` is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: ParVector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ParVector` is an immutable parallel sequence. We can create a parallel vector
    in a similar fashion to how we created a parallel array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform the same operations using methods such as `map`*,* which we
    can use from its sequential counterpart. Let''s take integers that are greater
    than 5 from our `parvec` parallel vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In a similar fashion, we can also create `ParHashSet` and `ParHashMap`*.* These
    are immutable parallel collections. `ParHashMap` avoids collision internally by
    using a chaining mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth knowing that the basic idea of parallelizing a collection is to split
    it into smaller parts using algorithms such as Divide and Conquer. These smaller
    parts are then operated upon using multiple tasks. Scala's parallel collection
    does this task scheduling through a `scala.collection.parallel.TaskSupport` object
    that is configurable. Also one should keep in mind that *side-effecting* operations
    are unpredictable, and when executed in parallel, they can produce deadlocks or
    race conditions. So as programmers, it's our responsibility to write code in a
    manner that avoids these race conditions. Parallel collections make it easier
    to solve problems where large amounts of data are to be processed. They make collections
    more powerful in Scala. You may also want to utilize this power when you use any
    Java collection from a library; in that case, you may want to read the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Java collection into a Scala collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala interoperates with a lot of Java libraries, so you may have to deal with
    Java code as well. It''s possible for you to encounter a situation where you''ve
    a Java collection and you''re expected to convert it into Scala. With this idea
    of converting a collection from Java to Scala, it may look a little bit scary
    that we''ve got to traverse through elements from Java''s collection, and then
    append them to a Scala collection. But here''s the catch: there''re already ways
    you can do this. It''s easy: we''ve a `JavaConverters` object in the `scala.collection` package, which
    takes care of this conversion. Actually, what happens behind the scenes when you
    call these conversion methods is that the implicit conversion takes place. Why
    not take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Here's the program. We've a Java list named `aJavaList`*,* which is a list of
    dates with a few date objects in it. Yes, it's not a complex problem; what we
    simply have to do is to convert this list into a Scala collection so that we can
    perform our higher order operations such as `map` or `flatMap`*.* For that, as
    we can see, we imported the `scala.collection.JavaConvertors` object. After importing
    this object, we now have access to a converter method, `asScala`, which converts
    your Java collection to a Scala counterpart, which internally checks for the suitable
    collection to convert in, and the conversion happens implicitly. Finally, after
    conversion, we're able to use the `map` function on the `scalaDates` object, which
    is not a Scala collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to convert a Scala collection to a Java counterpart using
    `asJava`*.* So it''ll be totally fine to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: It'll convert the Scala collection into a Java collection. It's good that when
    you perform one conversion from the source collection to the target collection
    and then reconvert it, you actually get the main real object. Now that you've
    seen all the collections from Scala, and also have an idea that Java collections
    can also be converted to Scala collections, you've so many options to choose from
    for any requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the problem: after learning so many ways to make a collection of elements
    in Scala, it appears that we''ve got a big dilemma. We have quite a few options
    to choose from. Almost every collection has higher order functions to operate
    with. These are high-performing, type parameterized, and immutable collections.
    So how do we decide which collection to use? Now, we''ve the answer for that.
    And the answer is, it depends. Yes, it depends on multiple factors; for example,
    in which format would you like to have the data. Is it a simple sequence or in
    pair format? It''s obvious that we''ve been talking about sequences, and maps
    up to now. In the majority of situations, we come up with `Map`, `Set`*,* `List`*,*
    `ArrayBuffer`, or a `Vector`*.* Let''s talk about the factors that matter:'
  prefs: []
  type: TYPE_NORMAL
- en: If the requirement is to have a key-value lookup, we use Maps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `HashMap` when order is of no importance, and `ListMap` when we want
    to store the key-value pairs in a sequence. `ListMap` operations take linear time,
    as the number of elements increases. So using a `Map` is recommended in normal
    cases; if, somehow, the requirement is that we've got to operate on the first
    of a few collection elements, then `ListMap` can become a better choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sets*,* as you know already, contain no duplicate elements, so to remove duplicates
    we may choose to use a `Set`, or convert our collection to a `Set`*.* In Scala,
    a `Set` also extends `(A) ⇒ Boolean`, and this means that we may use a set to
    check the presence of an element in our collection. So it''s simple: if you''re
    required to check the presence of an element often, or to remove duplicates, use
    a `Set`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to store finite elements, traverse through them, or perform some
    operation on them, please choose a `List`. An `ArrayBuffer` is also a good choice
    in case you need it to be mutable. A `List` is a linear sequence, so performing
    operations is costly when the number of elements increases due to linear performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requirement is random access, and traversal is not of much importance,
    an indexed sequence is recommended, so please give `ArrayBuffer` a chance*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want faster random access and a persistent sequence, use `Vector`*.*
    And yes, Vector is persistent, because it preserves the previous version of itself.
    That's not possible with an `ArrayBuffer`*,* because of mutability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation can be an asset when working with Streams*.* It's a wise choice
    when the requirement is to evaluate a collection element on a need basis. We've
    seen how the `Stream` is represented, because of elements being lazily computed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the immutables. We can create a *Range *on the go with some collection's
    size, or something of that sort. It's easy to create a `Range` with `in`*,* `until`,
    and `by` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it mostly all depends on what are we going to do with our collection elements.
    Of course, performance is of the utmost importance to us, because collections
    take up a big part of writing logic into our programs. We can start with a wrong
    choice of collection, then based on the need, we can convert those. It may look
    easy, but it's going to impact performance for sure. For example, it's wise to
    use a `ListBuffer` if later in the program you decide to convert it into a list.
    The reason is that a `ListBuffer` stores elements internally in a linked list
    format. So it's easy to convert to a list, rather than an array. Different operations,
    from instantiating a collection to updating, appending, or calling head or tail
    on your collection, all take different amounts of time, and thus can make your
    code less performant. So the idea is to choose wisely, based on what's of importance
    to your program. So why not compare the performance of several collections?
  prefs: []
  type: TYPE_NORMAL
- en: Collection performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are all the things you can do with a collection? Let''s think of some
    use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a collection object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform an operation on each element of a collection, which is only possible
    when you access each element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traverse through the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break it down into parts, perhaps one part with a single first element, and
    another with the rest of the collection (which are `head` and `tail`, obviously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly seek out a particular element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this covers pretty much everything you can do with a collection. The good
    thing is that if you're sure about the kinds of operations you're going to perform
    on your collection, you can make a performant program. The bad news is we hardly
    think about the operations we're going to perform later in programs, unless you're
    fortunate. But we've got an idea about all the collections and their performance.
    You may want to refer to the performance characteristics table in Scala's official
    documentation at [http://docs.scala-lang.org/overviews/collections/performance-characteristics.html.](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following observations will help with the idea of calling `apply`, `append`,
    `head`, or `tail` operations on a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List****:** List is a linear sequence, so methods such as `apply` and `append`
    take more time as the number of elements increases. But accessing `head` and `tail`
    elements takes a fixed amount of time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Linear` | `append => Linear` | `head => Constant` | `tail => Constant`
    |'
  prefs: []
  type: TYPE_TB
- en: The same goes for a `Stream` as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector:** Vector is more performant than a list on a few grounds, and `apply`
    and `append` operations are definitely more performant than a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Effectively Constant` | `append => Effectively Constant` |'
  prefs: []
  type: TYPE_TB
- en: '| `head => Effectively Constant` | `Tail => Effectively Constant` |'
  prefs: []
  type: TYPE_TB
- en: '**Range**: Range is a good option for those going for constant time access to `apply`*,*
    `head`, or `tail` operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Constant` | `head => Constant` | `tail => Constant` |'
  prefs: []
  type: TYPE_TB
- en: '**String**: String and Array work well for `apply` and `head` operations with
    a constant time response, but `tail` is a costly operation for these.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Constant` | `head => Constant` | `tail => Linear` |'
  prefs: []
  type: TYPE_TB
- en: '**Maps**: Maps are used to do value lookups based on keys or add/remove key-value
    pairs. `HashMap` effectively provides constant time for these operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `lookup => Effectively Constant` | `add => Effectively Constant` | `remove
    => Effectively Constant` |'
  prefs: []
  type: TYPE_TB
- en: Knowing the structure of a collection provides almost all the information about
    its performance. We now have an idea about all the collections in Scala, so it's
    time for you to practice more and experiment more with these collections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to the implementation of Scala's collections.
    We started learning about immutable and mutable collections. After that, we discussed
    Scala's collection hierarchy, where we learned about various super traits such
    as `Traversable` and `Iterable`*.* We also talked about three abstract collection
    types: `Seq`, `Set`, and `Map`. Then we took a look at the most commonly used
    collections in Scala. After that, we went the extra mile to learn about all the
    important functions used to work with collections. Then we learned about how we
    can convert collections from Java to Scala and vice versa, and found out that
    it was easy. After that, we discussed which collection to choose from all these
    options, which led us to consider the performance characteristics of collections.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've come to the end of part 1\. In the next part, we'll start with
    the object-oriented and functional constructs provided by Scala. The next chapter
    is about the basics of object-oriented constructs in Scala, such as classes, traits,
    and objects. Learning them will enable us to utilize functional constructs efficiently
    in later parts of this book.
  prefs: []
  type: TYPE_NORMAL
