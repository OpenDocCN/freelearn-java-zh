- en: Getting Familiar with Scala Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉Scala集合
- en: '"The code that you write should absorb more meaning without becoming bloated
    or losing comprehensibility."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"你编写的代码应该吸收更多的意义，而不会变得臃肿或失去可理解性。"'
- en: '- Anonymous'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 匿名'
- en: 'In any programming language, one of the essential requirements is to have a
    way of working with a set of data, or, in other words, a collection of data. If
    you have worked with any programming language, you must already know the importance
    of its collection framework. Scala has a rich variety of collections; a rich set
    of helper functions makes it a lot easier to work with any Scala collection. In
    this chapter, we''ll go through all the essentials of Scala collections. We''ll
    be able to distinguish between several collection options, and also make efficient
    use of all collections. Along the way, we''ll learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，一个基本要求是能够处理一组数据，换句话说，一组数据集合。如果你使用过任何编程语言，你肯定已经知道其集合框架的重要性。Scala拥有丰富的集合；一组丰富的辅助函数使得处理任何Scala集合变得容易得多。在本章中，我们将介绍Scala集合的所有基本知识。我们将能够区分几种集合选项，并有效地使用所有集合。在这个过程中，我们将学习：
- en: Immutable and mutable Scala collections
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变和可变Scala集合
- en: Scala's collection hierarchy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala的集合层次结构
- en: Commonly used collections in Scala
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala中常用的集合
- en: Rich operations performed on collections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在集合上执行丰富操作
- en: Parallel collections
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行集合
- en: Conversion from a Java to a Scala collection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Java到Scala集合的转换
- en: Choosing a collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个集合
- en: Collection performance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合性能
- en: Motivation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机
- en: 'Before we start learning about immutable and mutable collections in Scala,
    we''ll try to solve a simple problem using powerful methods provided by Scala
    collections. For that, let''s take a look at a scenario:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习Scala中的不可变和可变集合之前，我们将尝试使用Scala集合提供的强大方法解决一个简单的问题。为此，让我们看看一个场景：
- en: '![](img/00018.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: RESTful APIs
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API
- en: As shown in the preceding image, we have a set of APIs with method types such
    as `GET`, `POST`, and `PUT`, and their associated URIs. As these are two entities
    (method and URI), think of all these as a list of tuples*.* Now we want to segregate
    them, so we can create a map, as shown in the right column of the preceding image.
    A map is a collection that stores values in a key-value pair. Hence, on the right
    side you can see API information as key-value pairs, where key is the method name,
    and the value is a list of URIs for that particular request type. So, the idea
    is to convert `List[(String, String)]` to `Map[String, List[String]]`*.* You may
    want to think about the solution, and come up with your own.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有一组具有`GET`、`POST`和`PUT`等方法类型以及相关URI的API。由于这些是两个实体（方法和URI），将这些视为元组的列表。现在我们想要将它们分开，以便我们可以创建一个映射，如前图右侧所示。映射是一种存储键值对的集合。因此，在右侧你可以看到API信息作为键值对，其中键是方法名称，值是该特定请求类型的URI列表。所以，想法是将`List[(String,
    String)]`转换为`Map[String, List[String]]`*。你可能想要考虑解决方案，并提出你自己的。
- en: 'Meanwhile, let''s see if Scala helps us in any way with our solution:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们看看Scala是否以任何方式帮助我们解决我们的问题：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the result:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have come up with a set of `for` loops or recursive methods to accomplish
    what can be done using a single method, you may want to rethink, or take a look
    at the solution we have here. Here, we used two utility methods that fulfill our
    purpose. The first one is `groupBy`*,* defined in the `TraversableLike` trait,
    which converts our `List[(String, String)]` to a `Map[String, List[String]]` grouped
    by the first element of the tuple, the method names. This `groupBy` operation
    gives us this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经想出一组`for`循环或递归方法来完成可以用单一方法完成的事情，你可能需要重新思考，或者看看我们这里提供的解决方案。在这里，我们使用了两个满足我们目的的实用方法。第一个是定义在`TraversableLike`特质中的`groupBy`*，它将我们的`List[(String,
    String)]`转换为按元组的第一个元素（方法名称）分组的`Map[String, List[String]]`。这个`groupBy`操作给我们带来了以下内容：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The latter is the `mapValues` method from `MapLike` trait, which is used to
    wrap the given map with the same key. The value for each key is simply `f(this(key))`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 后者是来自`MapLike`特质的`mapValues`方法，它用于将给定的映射包装在相同的键上。每个键的值简单地是`f(this(key))`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These two methods were enough to provide the solution, and helped us avoid many
    traversals using loops. This is just one example, and a lot can be done within
    only few lines of code that would otherwise have taken several lines. This really
    makes Scala collections powerful. Scala's collection framework is easy to use;
    most of the helper methods are universal, with a few exceptions. Also, there is
    no compromise with performance; these are performance-tuned methods. One can rely
    on these methods to accomplish any logic; it makes your code look nicer. But that's
    not all, it's just the beginning. Usually, collections are prone to code that
    is written with the current environment in mind. That usually makes it hard to
    debug what went wrong, specifically when mutable collections are in place. So,
    just to remove this complication, Scala has these immutable data collections.
    Once created, the immutable collections can't be updated. But how do they work,
    and how are they different from mutable collections? Let's go through and try
    to understand.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法足以提供解决方案，并帮助我们避免使用循环进行多次遍历。这只是其中一个例子，仅用几行代码就能完成原本可能需要几行代码才能完成的工作。这确实使Scala集合变得强大。Scala的集合框架易于使用；大多数辅助方法都是通用的，只有少数例外。此外，性能上没有妥协；这些是经过性能优化的方法。人们可以依赖这些方法来完成任何逻辑；这使得你的代码看起来更美观。但不仅如此，这只是开始。通常，集合容易编写出针对当前环境的代码。这通常使得调试出错变得困难，特别是在有可变集合的情况下。因此，为了消除这种复杂性，Scala提供了这些不可变数据集合。一旦创建，不可变集合就不能更新。但它们是如何工作的，与可变集合有何不同？让我们逐一了解。
- en: Immutable and mutable collections
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变和可变集合
- en: 'A collection is used to contain data that is used by the program later in time.
    In a multithreaded environment, if multiple threads try to access a collection
    at the same time, this can give you a hard time debugging what went wrong. That
    is a problem programmers usually face when working with collections in a multithreaded
    environment. But there''s a universal solution for that, which expects you to
    use an immutable collection. Immutable means you can''t change/mutate it. Scala
    provides you options to choose from: `root`, `mutable`, and `immutable` collections.
    These three are variants that exist in three separate packages: `scala.collection`*,*
    `scala.collection.mutable`, and `scala.collection.immutable`*.* If you don''t
    specify the collection and use one, it''ll be an immutable one by default. But
    how do these work, exactly? Let''s take a look:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 集合用于存储程序在将来某个时间点使用的数据。在多线程环境中，如果多个线程同时尝试访问一个集合，这可能会让你在调试出错时遇到困难。这是程序员在多线程环境中处理集合时通常会遇到的问题。但有一个通用的解决方案，它期望你使用不可变集合。不可变意味着你不能改变/修改它。Scala提供了选择选项：`root`、`mutable`和`immutable`集合。这三个变体存在于三个不同的包中：`scala.collection`、`scala.collection.mutable`和`scala.collection.immutable`。如果你没有指定集合而使用了一个，它将默认为不可变集合。但它们究竟是如何工作的呢？让我们来看看：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A collection that does not allow us to update or delete its elements is of not
    much use. So, why do we say these are rich collections? The reason is that even
    though these are immutable collections, there are ways to add and remove elements,
    but these actions return a new collection altogether. We'll see how these are
    constructed and then how adding an element affects the collection later in this
    chapter; but for now, it's important to know that immutable collections can be
    updated, although doing so returns another collection with the same set of elements,
    along with the updated collection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不允许我们更新或删除其元素的集合几乎没有什么用处。那么，我们为什么说这些是丰富的集合呢？原因在于，尽管这些集合是不可变的，但仍然有方法可以添加和删除元素，但这些操作会返回一个新的集合。我们将在本章后面看到这些集合是如何构建的，以及添加一个元素是如何影响集合的；但就目前而言，重要的是要知道不可变集合是可以更新的，尽管这样做会返回另一个包含相同元素集的集合，以及更新后的集合。
- en: On the other hand, we have mutable collections, which work similar to most object-oriented
    programming languages. You can declare and instantiate a collection with a few
    elements. Then, based on any requirements afterwards, you can change its elements,
    or remove them. With these mutable collections, Scala gives you a choice to make
    when selecting a collection to work with. When you use mutable collections, you
    get an extra set of methods to mutate the collection. Be sure, though, about the
    instances where you may mutate collections. That'll make your program world free
    of mutability complications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有可变集合，它们的工作方式与大多数面向对象编程语言相似。你可以用几个元素声明并实例化一个集合。然后，根据后续的任何要求，你可以更改其元素，或者删除它们。使用这些可变集合，Scala为你选择要与之一起工作的集合时提供了一个选择。当你使用可变集合时，你会得到一组额外的用于更改集合的方法。不过，请确保你可能会更改集合的实例。这样，你的程序将不会出现可变性复杂性。
- en: 'The third variant, root collections, resides in the `scala.collection`package*.*
    When you use a root collection, it can be mutable or immutable. What does that
    mean? It means that a particular collection is a superclass of a collection from
    the same family residing in both the `scala.collection.mutable` and `scala.collection.immutable`
    packages. To understand what we just said, take a look at the following method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种变体，根集合，位于`scala.collection`包中*.* 当你使用根集合时，它可以是可变的或不可变的。这意味着什么？这意味着特定的集合是位于`scala.collection.mutable`和`scala.collection.immutable`包中的同一家族集合的超类。为了理解我们刚才说的，请看以下方法：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `afunction` function can take both mutable and immutable collections, as
    long as they are Iterable, which is one of the traits available in Scala's collection
    hierarchy*.*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`afunction`函数可以接受可变和不可变集合，只要它们是可迭代的，这是Scala集合层次结构中可用的特性之一*.*'
- en: There are few extra methods that let you mutate your collection, and as we may
    expect, those are defined only for collections in the `scala.collection.mutable` package, not
    the `scala.collection` or `scala.collection.immutable` packages*.* In that case,
    it's clear that while writing your root collection, the Scala compiler is not
    going to allow you to update your collection. We talked about one of the use cases
    of root collections where, regardless of the type of your collection, you can
    define a function—that is, `afunction`, that takes all sorts of collections. There
    are more ways we can find the use cases, or differentiate root and immutable collections.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些额外的允许你更改集合的方法，正如我们可能预期的，这些方法仅定义在`scala.collection.mutable`包中的集合，而不是`scala.collection`或`scala.collection.immutable`包中的集合*.*
    在这种情况下，很明显，在编写你的根集合时，Scala编译器不会允许你更新你的集合。我们讨论了根集合的一个用例，其中，无论你的集合类型如何，你都可以定义一个函数——即`afunction`，它接受各种集合。我们可以找到更多用例，或者区分根集合和不可变集合。
- en: Differences between the root and immutable collections
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根集合和不可变集合之间的区别
- en: 'The differences between the `root` and `immutable` collection use cases are
    easy to understand with the help of a scenario. Think of a scenario where:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个场景，我们可以很容易地理解`root`和`immutable`集合用例之间的区别。想象一个场景，其中：
- en: A function declaration expects a collection as a parameter
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数声明期望一个集合作为参数
- en: The function is not going to mutate the collection as part of the definition
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数不会作为定义的一部分更改集合
- en: The function can work well, regardless of the fact that the collection values
    can be changed by other threads in time
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以很好地工作，无论集合值是否可能被其他线程在时间上更改
- en: 'If these three scenarios are fulfilled, you''re welcome to use the `root` collection
    type as the parameter for your function definition. It means that the following
    declaration will work for you:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这三个场景都满足，你可以使用`root`集合类型作为函数定义的参数。这意味着以下声明将适用于你：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If the third scenario is not what you wish for, then use `scala.collection.immutable`*.*
    The scenario explains where we can use root collections. Just because you don't
    have access to methods that mutate collections, it doesn't put a constraint on
    the runtime modification of the collection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第三个场景不是你想要的，那么使用`scala.collection.immutable`*.* 该场景解释了我们可以使用根集合的地方。仅仅因为你没有访问更改集合的方法，这并不限制集合的运行时修改。
- en: It's also important to know that even in these three packages, collections are
    present in a hierarchical manner. So, let's take a look at the hierarchy of collections
    in Scala.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是要知道，即使在这三个包中，集合也是以层次结构的方式存在的。所以，让我们看看Scala中集合的层次结构。
- en: Hierarchy of collections in Scala
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala集合的层次结构
- en: 'The hierarchical structure of Scala collections is easy to understand. When
    you start working with collections, it becomes easy to use any method that is
    already defined in a super trait, and for specific implementations you can define
    your own versions. The structure has been classified in three distinct categories,
    that is: `root`*,* `mutable`*,* and `immutable`*.* We''ve discussed the differences
    between them. To strengthen our discussion, let''s take a look at the hierarchy
    of `root` package collections:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Scala集合的层次结构易于理解。当你开始使用集合时，使用在超特质中已定义的任何方法都变得容易，对于特定的实现，你可以定义自己的版本。结构已经被分为三个不同的类别，即：`root`*,*
    `mutable`*,* 和 `immutable`*.* 我们已经讨论了它们之间的区别。为了加强我们的讨论，让我们看看`root`包集合的层次结构：
- en: '![](img/00019.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.jpeg)'
- en: Root collection hierarchy
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根集合层次结构
- en: The preceding hierarchy is for collections in the `root` package. All the collections
    inherited from the super trait are called **Traversable***.* Traversable defines
    the `foreach` abstract method, along with other helper methods that can relate
    to any collection in the hierarchy. So, it's clear that every other collection
    needs to give a definition of the `foreach` method in its implementation. We'll
    have a look at Traversable *trait* in the next few topics.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述层次结构是针对`root`包中的集合。所有从超特质继承的集合都称为**Traversable***.* Traversable定义了`foreach`抽象方法，以及与其他集合相关的其他辅助方法。因此，很明显，其他每个集合都需要在其实现中定义`foreach`方法的定义。我们将在接下来的几个主题中查看Traversable
    *特质*。
- en: 'After Traversable*,* there''s a *trait* named **Iterable**, which inherits
    *Traversable*, implements the `foreach` method from Traversable, and has its own
    *iterator* abstract method. From there, the hierarchy splits into three different
    categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Traversable*之后，有一个名为**Iterable**的*特质*，它继承自Traversable，实现了从Traversable继承的`foreach`方法，并有自己的*迭代器*抽象方法。从这里开始，层次结构分为三个不同的类别：
- en: '`Seq`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Seq`'
- en: '`Set`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`'
- en: '`Map`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`'
- en: These three categories are different in implementation, context, and use cases.
    The first one is a sequence that's used to contain a sequence of elements, such
    as a sequence of numbers. Sequences are further classified as `LinearSeq` and
    `IndexedSeq`*.* The second one is a set, and it is a collection of distinct elements,
    which means elements can't be repeated. Sets are classified as `SortedSet` and
    `BitSet`*.* The last one is a map, which is a key-value-based collection that
    can have a `SortedMap`*.* These are all part of the `scala.collection` package.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类别在实现、上下文和使用场景上都有所不同。第一个是一个用于包含元素序列的序列，例如数字序列。序列进一步分为`LinearSeq`和`IndexedSeq`*.*
    第二个是一个集合，它是一组不同的元素，这意味着元素不能重复。集合分为`SortedSet`和`BitSet`*.* 最后一个是映射，它是一个基于键值对的集合，可以有一个`SortedMap`*.*
    这些都是`scala.collection`包的一部分。
- en: 'After the root package, let''s take a look at the collections hierarchy in the `scala.collection.mutable`
    package:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在根包之后，让我们来看看`scala.collection.mutable`包中的集合层次结构：
- en: '![](img/00020.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: The scala.collection.mutable collections package
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.mutable`集合包'
- en: It may be frightening when you first see these, but it works as a utility when
    you use these collections wisely. Collections in the `scala.collection.mutable` package, as
    expected, contain methods that can be used to add/remove elements in the collection.
    The hierarchy of this package is similar to `Seq`, `Set`, and `Map` traits. Afterwards,
    more concrete implementations that are specific to some use cases are part of
    the package. The figure itself is self-explanatory; more and more implementations
    of these collection traits are there for us to use. `IndexedSeq` has more implementations
    now, such as `ArraySeq`*,* `StringBuilder`, and `ArrayBuffer`*.* Another trait,
    named `Buffer`, is introduced. A few implementations, such as `Stack`*,* `ArrayStack`,
    and `PriorityQueue` extend directly from `Seq` trait. In the same way, the other
    two traits, Set and Map, also have a few concrete implementations. HashSet and
    BitSet are for sets, and HashMap, LinkedHashMap, and ListMap extend Map.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次看到这些时可能会感到害怕，但当你明智地使用这些集合时，它作为一个实用工具。`scala.collection.mutable`包中的集合，正如预期的那样，包含可以用来在集合中添加/删除元素的方法。这个包的层次结构与`Seq`、`Set`和`Map`特质相似。之后，更多针对某些特定用例的具体实现也成为了这个包的一部分。图本身是自解释的；越来越多的这些集合特质的实现供我们使用。`IndexedSeq`现在有更多的实现，例如`ArraySeq`*、*
    `StringBuilder`和`ArrayBuffer`*.* 另一个名为`Buffer`的特质被引入。一些实现，如`Stack`*、* `ArrayStack`和`PriorityQueue`直接扩展自`Seq`特质。同样，其他两个特质，Set和Map，也有一些具体实现。HashSet和BitSet用于集合，而HashMap、LinkedHashMap和ListMap扩展自Map。
- en: 'Finally, let''s take a look at the hierarchy of the `scala.collection.immutable`package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看`scala.collection.immutable`包的层次结构：
- en: '![](img/00021.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: The scala.collection.immutable package
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`scala.collection.immutable`包'
- en: The collections hierarchy is similar to mutable collections apart from the fact
    that *immutable* collections, don't have the `Buffer` trait; the difference is
    that these collections do not have methods that let you mutate the same collection.
    Though it's possible to transform collections, it means that these collections
    have higher-order methods that can traverse and apply a function to each element,
    resulting in another collection. This is one of the ways to deal with immutable
    collections.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了不可变集合没有`Buffer`特质之外，集合层次结构与可变集合相似；区别在于这些集合没有让你修改相同集合的方法。尽管可以转换集合，但这意味着这些集合有高阶方法可以遍历并应用一个函数到每个元素，从而得到另一个集合。这是处理不可变集合的一种方法。
- en: This hierarchy also has the *Traversable* and *Iterable* super traits*.* These
    traits consist of most helper methods. These are universal methods that can be
    used with almost any collection in Scala. By default, Scala assumes a collection
    to be of the `immutable` type. It's good if you use them. It's good to know that
    you can also create your own custom collections. For this, there's a sub-package
    named `generic` in the `scala.collection` package that consists of the helpers required to
    create a collection implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次结构也有`Traversable`和`Iterable`超级特质*。这些特质包含大多数辅助方法。这些是通用方法，可以与Scala中的几乎所有集合一起使用。默认情况下，Scala假设集合是`不可变`类型。如果你使用它们，那很好。了解你也可以创建自己的自定义集合是很好的。为此，`scala.collection`包中有一个名为`generic`的子包，它包含创建集合实现所需的辅助函数。
- en: When we implement these collections, we assume there are ways to use and manipulate
    these collections, and indeed there are many higher-order helper functions that
    let you do so. Most of the basic and universal helpers are defined in super traits
    that other collections implement. Let's take a look at these traits.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现这些集合时，我们假设有方法来使用和操作这些集合，实际上确实存在许多高阶辅助函数可以让你这样做。大多数基本和通用的辅助函数都定义在超级特质中，其他集合实现这些特质。让我们来看看这些特质。
- en: Traversable
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Traversable
- en: 'This is a super trait of all other implementations for collections in Scala. Traversable
    defines a few methods that help to access collection elements, or perform operations
    on them. These operations can be categorized as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Scala中所有其他集合实现的超级特质。`Traversable`定义了一些帮助访问集合元素或对它们进行操作的方法。这些操作可以按以下方式分类：
- en: '**Additions**: Methods that append two traversables together. For two traversable
    collections, such as `xs` and `ys`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**：将两个可遍历集合一起添加的方法。对于两个可遍历集合，例如`xs`和`ys`：'
- en: For example, `xs ++ ys`
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs ++ ys`
- en: '**Transformations**: Methods such as `map`, `flatMap`, and `collect` come in
    this category:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：如`map`、`flatMap`和`collect`之类的转换方法：'
- en: For example, `xs.map(elem => elem.toString + "default")`
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.map(elem => elem.toString + "default")`
- en: '**Conversions**: Methods with a format such as `toXXX` *or* `mkString`*.* These
    are used to convert one collection to another suitable collection:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：具有 `toXXX` 或 `mkString` 等格式的方法*.* 这些方法用于将一个集合转换为另一个合适的集合：'
- en: For example, `xs.toArray`, `xs.mkString`, and `` `xs.toStream` ``
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.toArray`，`xs.mkString` 和 `xs.toStream`
- en: '**Copying**: Helper methods that copy elements from a collection to another
    collection, such as an array or buffer:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制**：帮助方法，用于将集合中的元素复制到另一个集合中，例如数组或缓冲区：'
- en: For example, `xs.copyToBuffer(arr)`
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.copyToBuffer(arr)`
- en: '**Information retrievals**: Methods that retrieve information such as size,
    or whether the collection has elements or not:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息检索**：检索信息的方法，例如大小，或者集合是否有元素：'
- en: For example, `xs.isEmpty`, `xs.isNonEmpty`, and `xs.hasDefiniteSize`
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.isEmpty`，`xs.isNonEmpty` 和 `xs.hasDefiniteSize`
- en: '**Element retrievals**: Methods that retrieve an element from a collection:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素检索**：从集合中检索元素的方法：'
- en: For example, `xs.head` and `xs.find(elem => elem.toCharArray.length == 4)`
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.head` 和 `xs.find(elem => elem.toCharArray.length == 4)`
- en: '**Sub collections**: Methods that return a sub-collection, based on ordering,
    or a predicate:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合**：返回子集合的方法，基于排序或谓词：'
- en: For example, `xs.tail`, `xs.init`, `xs.filter(elem => elem.toCharArray.length
    == 4)`
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.tail`，`xs.init`，`xs.filter(elem => elem.toCharArray.length == 4)`
- en: '**Folding**: Methods that apply a binary operation on each of the successive
    elements of a collection. Also, there are some special forms of folding operations:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠**：对集合的连续元素应用二元操作的方法。此外，还有一些特殊的折叠操作形式：'
- en: For example, `xs.foldLeft(z)(op)`, and `xs.product`
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.foldLeft(z)(op)` 和 `xs.product`
- en: 'We''ll go through implementation details of almost all these methods later
    in the chapter. For now, it''s important to know that the `Traversable` trait
    mixes in with `TraversableLike` and few other traits. If you don''t understand
    what a mix-in of traits is*,* we''ll discuss that when we talk about object-oriented
    programming in Scala in subsequent chapters:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面详细讲解几乎所有这些方法的实现细节。现在，重要的是要知道 `Traversable` 特质与 `TraversableLike` 和少数其他特质混入。如果你不理解特质混入是什么*，*
    我们将在后续章节中讨论 Scala 中的面向对象编程时进行讨论：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Traversable has an abstract `foreach`method*.* Any implementation that mixes
    in `Traversable` needs to define this abstract `foreach`method:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Traversable 有一个抽象的 `foreach` 方法*.* 任何混入 `Traversable` 的实现都需要定义这个抽象的 `foreach`
    方法：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the `foreach` method signature, it has a type parameter, `U`, which
    stands for the type of data that we'll impose when we'll use the method. The `foreach`
    method traverses the collection, applying a function to each of its elements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `foreach` 方法签名所示，它有一个类型参数 `U`，代表我们将要使用该方法时施加的类型。`foreach` 方法遍历集合，对每个元素应用一个函数。
- en: Iterable
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Iterable
- en: 'Iterable is also a trait that other collections mix in with. Iterable mixes
    in *Traversable*, and also defines the `foreach` abstract method. Iterable also
    has an abstract method named `iterator`*.* Implementations that mix in the *Iterable*
    trait have to define this abstract method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Iterable 也是一个特质，其他集合可以混入其中。Iterable 混入了 *Traversable*，并定义了 `foreach` 抽象方法。Iterable
    还有一个名为 `iterator` 的抽象方法*.* 混入 *Iterable* 特质的实现必须定义这个抽象方法：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can see that the `iterator` method returns an `Iterator`*,* which has the `hasNext`
    and `next` methods. Using an Iterator, we can fetch all elements one by one, or
    perform an operation. A closer look will tell you that Traversable can traverse
    the whole collection in one go, while for an Iterable, the pull approach works
    well. Each iteration gives an element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `iterator` 方法返回一个 `Iterator`，它有 `hasNext` 和 `next` 方法。使用 Iterator，我们可以逐个获取所有元素，或者执行一个操作。仔细观察会发现，Traversable
    可以一次性遍历整个集合，而对于 Iterable，拉取方法效果很好。每次迭代都会提供一个元素。
- en: 'Of course, Iterables support all methods from *Traversable*. Along with that,
    there are a few more methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Iterables 支持所有来自 *Traversable* 的方法。除此之外，还有一些其他方法：
- en: '**Sub-iterations**: Methods that return another chunked iterator:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子迭代**：返回另一个分块迭代器的方法：'
- en: For example, `xs.grouped(size)`, and `xs.sliding(size)`
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.grouped(size)` 和 `xs.sliding(size)`
- en: '**Sub-collections**: Methods that return parts of collections:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合**：返回集合部分的方法：'
- en: For example, `xs.takeRight(n)`, and `xs.dropRight(n)`
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.takeRight(n)` 和 `xs.dropRight(n)`
- en: '**Zipping**: Methods that return iterable collection elements in pairs:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：返回可迭代集合元素对的方法：'
- en: For example, `xs.zip(ys)`, and `xs.zipWithIndex`
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.zip(ys)` 和 `xs.zipWithIndex`
- en: '**Comparisons**: Methods that compare two iterable collections according to
    the order of elements:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较**：根据元素顺序比较两个可迭代集合的方法：'
- en: For example, `xs sameElements ys`
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs sameElements ys`
- en: 'One possible declaration of `Iterable` is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable` 的一个可能声明如下：'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `Iterable` trait mixes in `Traversable`, along with a few
    others. That's how it exists in the hierarchy. The following Iterables are three
    traits, named `Seq`*,* `Set`*,* and `Map`*.* Let's go through them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Iterable` 特质混合了 `Traversable` 以及其他几个特质。这就是它在层次结构中的存在方式。以下可迭代的三个特质，分别命名为
    `Seq`*、* `Set`*、* 和 `Map`*.* 让我们逐一介绍。
- en: Seq
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Seq
- en: 'The `Seq` represents a sequence of elements. Its signature is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Seq` 代表元素序列。其签名如下：'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As shown, `Seq` extends `PartialFunction`, but what does that mean? Remember,
    we discussed partial functions in the previous chapter. These functions are defined
    for a particular set of values from the domain. In the case of `Seq`, that domain
    is the `length -1`*.* It is clear from the signature that a `Seq` can take an
    `Int`, and responds with an element of type `A`*.* Here, `A` is the type of the
    collection element. Let''s look at an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`Seq` 扩展了 `PartialFunction`，但这意味着什么呢？记住，我们在上一章讨论了部分函数。这些函数定义了域中特定的一组值。在
    `Seq` 的情况下，该域是 `length -1`*.* 从签名中可以清楚地看出，`Seq` 可以接受一个 `Int`，并响应类型为 `A`* 的元素。在这里，`A`
    是集合元素的类型。让我们看一个例子：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding example, when we define the sequence, it becomes a partial
    function of type `PartialFunction[Int, Int]`. It means that passing any value
    from its length - 1 as a parameter to our sequence will result in a value from
    the sequence of type A*,* which in our case, is also an `Int`*.* The reason that
    a `Seq` is defined for only some particular values from the domain is to show
    that if we pass an index for which `aSeq` does not have a value, it will give
    an exception:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们定义序列时，它变成了类型为 `PartialFunction[Int, Int]` 的部分函数。这意味着将长度减一的任何值作为参数传递给我们的序列将导致类型为
    A* 的序列值，在我们的情况下，它也是一个 `Int`*。定义 `Seq` 仅用于域中的一些特定值的原因是为了表明，如果我们传递一个 `aSeq` 没有值的索引，它将引发异常：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A `Seq`, being a `PartialFunction`, can prove a boon for us as developers,
    as there are many instances where very complex logic can become so easy to implement.
    There''s also a method, `isDefinedAt`*.* As you may be aware, we can use it to
    check whether the partial function is defined for the value. A sequence is said
    to have a length, and encompasses two variants, named `IndexedSeq` and `LinearSeq`*.*
    These names imply most of what these collections are there for. An indexed sequence
    is recommended to use when we access them via indexing; in other words, by calling
    the `length` or `apply` methods.  A linear sequence, however, is used where the
    performance of a subsection of a collection is important. It means that calling
    a method on a collection and breaking it into sub-sequences is important. Now,
    after knowing all this, let''s take a look at the categories of operations that
    can be performed on these sequences:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 `PartialFunction` 的 `Seq`，对我们开发者来说可能是一个福音，因为在许多情况下，非常复杂的逻辑可以变得非常容易实现。还有一个方法，`isDefinedAt`*.*
    如您所知，我们可以用它来检查部分函数是否为某个值定义。序列有一个长度，并包含两个变体，分别命名为 `IndexedSeq` 和 `LinearSeq`*.*
    这些名称暗示了这些集合的主要用途。当通过索引访问时，建议使用索引序列；换句话说，通过调用 `length` 或 `apply` 方法。然而，线性序列用于集合的子部分性能很重要。这意味着在集合上调用方法并将其分解为子序列是很重要的。现在，在了解所有这些之后，让我们看看可以在这些序列上执行的操作类别：
- en: '**Length and indexing**: Methods that depend on the length of the sequence,
    mainly via index or size:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长度和索引**：依赖于序列长度的方法，主要通过索引或大小：'
- en: For example, `xs.apply(1)`, `xs.length`, `xs.indices`, and`` ` xs.indexWhere(predicate)`
    ``
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.apply(1)`、`xs.length`、`xs.indices` 和 `xs.indexWhere(predicate)` ``
- en: '**Additions**: Methods that add an element at the beginning or at the end of
    a sequence:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**：在序列的开始或结束处添加元素的方法：'
- en: For example, `x+:(xs)` and `xs.:+(x)`
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`x+:(xs)` 和 `xs.:+(x)`
- en: '**Updates**: Methods that update an element in a sequence:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新序列中元素的方法：'
- en: For example, `xs(1) = 12` and `xs updated (1, 12)`
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs(1) = 12` 和 `xs updated (1, 12)`
- en: '**Sorting**: Methods that sort a given sequence:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序**：对给定序列进行排序的方法：'
- en: For example, `xs.sorted` and `xs sortWith op`
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.sorted` 和 `xs sortWith op`
- en: '**Reversing**: Methods that reverse a sequence:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反转**：反转序列的方法：'
- en: For example, `xs.reverse`, and so on
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.reverse` 等
- en: '**Comparisons and checks**: Methods that reverse a sequence:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较和检查**：反转序列的方法：'
- en: For example, `xs.contains(x)` and `xs.endsWith(x)`
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.contains(x)` 和 `xs.endsWith(x)`
- en: '**Multi-set operations**: Methods that results based on some set operations
    like union and distinct:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多集操作**：基于某些集合操作（如并集和distinct）的结果的方法：'
- en: For example, `xs.union(ys)` and `xs.distinct`
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.union(ys)` 和 `xs.distinct`
- en: 'We''ll go through the implementation details of these methods in subsequent
    sections. Now, let''s take a look at different variants of sequences:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中介绍这些方法的实现细节。现在，让我们看看序列的不同变体：
- en: '![](img/00022.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: Sequences
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: There's another form of sequences, named *Buffer*, that is mutable. It allows
    addition, update, removal, and other mutating operations on it. These mutations
    are done via methods such as +=, ++=, and *insert.* There's another sub-trait
    of *Iterable* which is called `Map`*.* Let's go through it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种序列形式，称为 *Buffer*，它是可变的。它允许对它进行添加、更新、移除和其他突变操作。这些突变是通过 +=、++= 和 *insert*
    等方法完成的。还有另一个名为 `Map` 的 *Iterable* 子特质。让我们来看看它。
- en: Map
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射
- en: 'A `Map` can be represented as a collection containing elements in the form
    of a key-value pair:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 可以表示为包含键值对形式的元素集合：'
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we''ve just shown, `Map` mixes in `Iterable` and `MapLike` traits, and `MapLike`
    extends the `PartialFunction` trait, so we can also use maps as a partial function.
    Also, it is worth noting the type parameters `K` and `V`*.* Here, type `K` binds
    a key to value `V`*.* Here''s how we can define a `Map`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才所展示的，`Map` 混合了 `Iterable` 和 `MapLike` 特质，而 `MapLike` 扩展了 `PartialFunction`
    特质，因此我们也可以将映射用作部分函数。此外，值得注意的是类型参数 `K` 和 `V`*.* 在这里，类型 `K` 将键绑定到值 `V`*.* 这是我们定义
    `Map` 的方法：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is a map of type `string` to string, which means it maps
    a string key to a string value. As for any other collection, we need a few methods
    to access maps. There is more than one category for doing so. Let''s go through
    them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个将字符串映射到字符串的映射，这意味着它将字符串键映射到字符串值。对于任何其他集合，我们都需要一些方法来访问映射。这样做有多种类别。让我们来看看它们：
- en: '**Associations and lookups**: Methods that look up an element from a map:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联和查找**：从映射中查找元素的方法：'
- en: For example, `as.get(key)`, and `as(key)`, `as` contains key
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`as.get(key)`、`as(key)`、`as` 包含键
- en: '**Additions**: Methods that adds key-value pairs to an existing map:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加**：向现有映射中添加键值对的方法：'
- en: For example, `as + (key -> value)` and `as ++ kvs`
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`as + (key -> value)` 和 `as ++ kvs`
- en: '**Removals**: Methods that remove a pair from a given map:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除**：从给定映射中移除一对元素的方法：'
- en: For example, `as - (key)`
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`as - (key)`
- en: '**Sub-collections**: Methods that return a sub-collection from a given map:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子集合**：从给定映射中返回子集合的方法：'
- en: For example, `as.keys`, `as.keySet`, and `as.values`
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`as.keys`、`as.keySet` 和 `as.values`
- en: '**Transformations**: Methods that transform a map by applying a function to
    each value of a given map:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：通过将函数应用于给定映射的每个值来转换映射的方法：'
- en: For example, `as mapValues func`
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`as.mapValues func`
- en: 'A `Map` can have several different variants based on the category, whether
    it''s mutable or immutable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 可以根据类别有几种不同的变体，无论是可变的还是不可变的：'
- en: '![](img/00023.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: Maps
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 映射
- en: In the preceding image, we have a couple of variants of maps in Scala. Did you
    notice that we have the same `HashMap` available in both the versions in different
    packages, *mutable* as well as *immutable*? We use these different maps depending
    on our requirements. After `Seq` and `Map`, there's another sub-trait of `Iterable`,
    named `Set`*.*
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们看到了 Scala 中映射的几种变体。你注意到我们在这两个版本的不同包中都有相同的 `HashMap`，既有可变的也有不可变的吗？我们根据需求使用这些不同的映射。在
    `Seq` 和 `Map` 之后，`Iterable` 另有一个子特质，名为 `Set`*.*
- en: Set
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A `Set` is a collection that contains multiple elements with no duplication
    at all:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set` 是一个包含多个元素且没有任何重复的集合：'
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding code, the `Set extends (A) => Boolean` expression*,*
    which means that passing a parameter of type A to a set of type A will result
    in a Boolean. The Boolean result shows whether the `Set` contains the element
    passed as a parameter or not. Let''s see this in an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，`Set extends (A) => Boolean` 表达式*，这意味着将类型 A 的参数传递给类型 A 的集合将得到一个布尔值。布尔结果表示
    `Set` 是否包含作为参数传递的元素。让我们通过一个例子来看看：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It can be seen that the value 2 is present in `aSet`, and the values 5 and
    0 are not, so therefore passing 5 or 0 results in false. Let''s go through a few
    methods defined in `Set`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到值 2 在 `aSet` 中，而值 5 和 0 不在，因此传递 5 或 0 会返回 false。让我们通过 `Set` 中定义的一些方法来了解一下：
- en: '**Comparisons and checks**: Methods that check for a condition:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较和检查**：检查条件的方法：'
- en: For example, `xs.contains(x)`, and `xs.subsetOf(x)`
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs.contains(x)` 和 `xs.subsetOf(x)`
- en: '**Additions**: Methods that add an element or a collection of elements to a
    set:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加操作**：向集合中添加一个元素或一组元素的方法：'
- en: For example, `xs + x` and `xs ++ ys`
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs + x` 和 `xs ++ ys`
- en: '**Removals**: Methods that remove an element or collection of elements from
    a set:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除操作**：从集合中移除一个元素或一组元素的方法：'
- en: For example, `xs - x` and `xs -- ys`
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs - x` 和 `xs -- ys`
- en: '**Binary operations**: Methods that perform binary operations between two different
    sets:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二元操作**：在两个不同集合之间执行二元操作的方法：'
- en: For example, `xs | ys`, `xs & ys`, `xs` intersect `ys`, `xs` union `ys`, and
    so on
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，`xs | ys`、`xs & ys`、`xs` 与 `ys` 交集、`xs` 与 `ys` 并集等等
- en: 'A `Set` can have several different variants based on whether it''s mutable
    or immutable:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Set` 可以有几种不同的变体，这取决于它是可变的还是不可变的：
- en: '![](img/00024.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00024.jpeg)'
- en: Sets
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: A few variants of sets contain different types, such as `HashSet`, `BitSet`,
    and `SynchronizedSet`, and based on the need, we can utilize them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的一些变体包含不同类型，例如 `HashSet`、`BitSet` 和 `SynchronizedSet`，根据需要，我们可以使用它们。
- en: Now that we have an idea of some top-level collection traits in Scala, let's
    take a look at some concrete implementations of them. We'll talk about the common
    collections we use in Scala, the way they can be constructed, and how Scala treats
    a particular collection when we add or remove an element. It'll give you a brief
    idea of how Scala collections behave.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Scala 中的一些顶级集合特性有了了解，让我们看看它们的具体实现。我们将讨论 Scala 中常用的集合，以及它们如何构建，Scala
    在我们添加或删除元素时如何处理特定的集合。这将给你一个关于 Scala 集合行为的简要了解。
- en: Commonly used collections in Scala
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scala 中常用的集合
- en: Let's start  by discussing a few immutable concrete collections.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论一些不可变的具体集合。
- en: List
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'A list is a linear sequence and can be defined simply, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个线性序列，可以简单地定义为如下：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The syntax shown declares and instantiates the linear sequence with the elements
    provided. The runtime representation of the list constructed will look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的语法声明并实例化了由提供的元素组成的线性序列。构建的列表的运行时表示将如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, `Nil` represents the end of the list. It''s normal to represent an empty
    list as `Nil`. The preceding representation is also a way to construct a list,
    and this is possible because of the "::" operator. This is called the *cons* operator,
    and it is used to construct a list. It''s a right-associative operator:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Nil` 代表列表的末尾。将空列表表示为 `Nil` 是正常的。前面的表示法也是一种构建列表的方法，这是由于 "::" 操作符的缘故。这被称为
    *cons* 操作符，它用于构建列表。它是一个右结合操作符：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Calling the *cons* operator on the list results in a list with the new element
    added at the beginning of the list. This is equivalent to calling the same, using
    the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表上调用 *cons* 操作符会在列表的开头添加新元素，这相当于使用以下代码调用相同的操作：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve mentioned that operations such as adding an element to a list don''t
    affect the list that was previously created, but it copies the same list to another,
    with an added element. The reason for this is that lists are immutable. A pictorial
    representation of how this might look will give you an insight into what is happening.
    So, let''s take a look at this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，像向列表中添加元素这样的操作不会影响之前创建的列表，而是将相同的列表复制到另一个带有添加元素的列表中。这是因为列表是不可变的。以下是如何呈现这种情况的图示，这将帮助你了解正在发生的事情。所以，让我们看看这个：
- en: '![](img/00025.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00025.jpeg)'
- en: Adding an element to a List
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表中添加元素
- en: The figure is self-explanatory, and represents the concept of adding an element
    to a list. Lists provide many higher-order functions, such as `map`, `flatMap`,
    and `filter`, which make it easy to work with. With this construction syntax and
    easier access to the list's head (the first element of the list) and tail (which
    represents every element in the list except the first), it is easy to create patterns
    of lists and use them in pattern matching based on your needs. Operations such
    as *fold* and *reduce* are also of higher importance, as they provide a mechanism
    to perform binary operations on elements within the sequence. These are high-performing
    data structures, and provide constant time access to their elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该图是自我解释的，它代表了向列表中添加元素的概念。列表提供了许多高阶函数，如`map`、`flatMap`和`filter`，这使得处理列表变得容易。有了这种构造语法和更容易访问列表的头部（列表的第一个元素）和尾部（代表列表中除了第一个元素之外的所有元素），就可以轻松创建列表模式并按需在模式匹配中使用它们。像`fold`和`reduce`这样的操作也很重要，因为它们提供了一种在序列中的元素上执行二元操作的方法。这些是高性能的数据结构，并且可以提供对它们元素的常数时间访问。
- en: Map
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map
- en: 'The standard immutable map can be instantiated as easily as this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 标准不可变映射可以像这样实例化：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can provide as many key-value pairs as we want. We associate a key to its
    corresponding value by using the "-*>" *operator *.* It can be seen that the default
    implementation of a map corresponds to `scala.collection.immutable.Map[Int, String]`, and
    it''s not possible if we try to mutate the pairs. Though it''s possible to add
    new pairs to construct another map with updated elements using the *+ *method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供尽可能多的键值对。我们通过使用"-*>" *运算符* 将键与其对应的值关联起来。可以看出，映射的默认实现对应于`scala.collection.immutable.Map[Int,
    String]`，如果我们尝试修改这些对，则不可能。尽管可以通过使用*+ *方法添加新对来构建另一个具有更新元素的映射，但这仍然是可能的：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But this will not change the map we declared `aMap`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不会改变我们声明的`aMap`映射：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also discussed that map and sequences are also a `PartialFunction`, so we
    can check whether a value has been defined for a particular key:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了映射和序列也是`PartialFunction`，因此我们可以检查是否为特定的键定义了值：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Other versions of `Map` also exist, such as `ListMap`*,* and `SynchronizedMap`*.* These
    can be used if you need them. For example, you might prefer to use a `ListMap`
    when you need to traverse linearly on a map with better performance. Also, when
    mutable map implementation is needed in a thread-safe manner, one would prefer
    to use `SynchronizedMap`*.*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`的其他版本也存在，例如`ListMap`*，* 和`SynchronizedMap`*.*。如果需要，可以使用它们。例如，当你需要以线性方式遍历具有更好性能的映射时，你可能更喜欢使用`ListMap`。另外，当需要以线程安全的方式实现可变映射时，人们更愿意使用`SynchronizedMap`*.*'
- en: SortedSet
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SortedSet
- en: 'A `SortedSet` is a trait that represents a set of elements. It produces elements
    in a sorted manner based on ordering, because the default implementation stores
    elements in the form of a binary tree. One of the forms of `SortedSet` is a `TreeSet`*.*
    Creating a `TreeSet` expects you to provide an implicit `Ordering[A]` that takes
    care of the way elements will be ordered:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedSet`是一个表示元素集合的特质。它根据排序顺序以排序方式生成元素，因为默认实现以二叉树的形式存储元素。`SortedSet`的一种形式是`TreeSet`*.*
    创建`TreeSet`时，需要提供一个隐式`Ordering[A]`，它负责元素的排序方式：'
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, to create a `TreeSet`, we''ll create an `Ordering` object in the current
    scope. Without `Ordering`*,* the compiler won''t allow you to create a `TreeSet`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建`TreeSet`，我们将在当前作用域中创建一个`Ordering`对象。没有`Ordering`*，* 编译器不会允许你创建`TreeSet`：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here is the result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Uncommenting the line where we define an implicit value for `Ordering` will
    work fine. So, uncomment that and try running it. This will result in the following
    output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释我们为`Ordering`定义隐式值的行将正常工作。所以，取消注释并尝试运行它。这将产生以下输出：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Streams
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Streams
- en: '**Streams** are powerful. Let''s see why. Streams can be of infinite length;
    it may sound impractical having a sequence of infinite length, but when the computation
    happens lazily, this works OK. Streams serve the same purpose and the computation
    happens lazily. Let''s see how we can create streams:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**很强大。让我们看看为什么。流可以是无限长的；无限长序列听起来可能不太实用，但当计算是惰性发生时，这就可以正常工作。流服务于相同的目的，计算也是惰性发生的。让我们看看我们如何创建流：'
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We didn''t do anything extraordinary, except replace the `List` keyword with
    `Stream`, but REPL gives us back something different:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有做任何非凡的事情，只是将`List`关键字替换为`Stream`，但REPL返回了不同的结果：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can see here that `Stream` is computed only till the very first element,
    because there''s no need to go and compute other elements as of now. That''s what
    we call *lazy computation.* Streams can also be constructed using *cons* like
    this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里，`Stream`只计算到第一个元素，因为目前没有必要去计算其他元素。这就是我们所说的*惰性计算*。流也可以使用*cons*来构建，如下所示：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It's understandable that wherever we require our elements to compute lazily,
    we can use streams. One of the example use cases is when you require short-circuited
    evaluation from your function. You may pass a stream and evaluate. It's worth
    noting that a stream is not lazy with its head element, so your function will
    be evaluated for the first element.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解，无论何时我们需要对元素进行惰性计算，我们都可以使用流。一个例子用例是当你需要从你的函数中获取短路评估。你可以传递一个流并评估。值得注意的是，流对其头元素不是惰性的，所以你的函数将针对第一个元素进行评估。
- en: Vector
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'The difference between the performance of a linear sequence and an indexed
    sequence starts to matter when our requirement is to manipulate elements in the
    middle of a sequence. And because of the linear performance of sequences such
    as a list, the performance degrades for them. Therefore, indexed sequences come
    to the rescue! Vector is an example of an immutable indexed sequence. The way
    to create a vector is to simply use the `Vector` keyword with its `apply` method,
    or to simply represent it as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的需求是操作序列中间的元素时，线性序列和索引序列的性能差异开始变得重要。由于列表等序列的线性性能，它们的性能会下降。因此，索引序列就派上用场了！向量是不可变索引序列的一个例子。创建向量的方法很简单，只需使用`Vector`关键字及其`apply`方法，或者简单地表示如下：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To add elements to `vector`, we can use methods such as ":+" and "+:":'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`vector`添加元素，我们可以使用`:+`和`+:`等方法：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These are indexed in order to retrieve a value by passing an index:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是按顺序索引的，以便通过传递索引来检索值：
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We got the value 3, because the index starts from 0\. It''s good that we can
    check whether a value is defined at a particular index, because it is a sequence:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了值3，因为索引从0开始。我们很高兴我们可以检查特定索引处的值是否已定义，因为它是一个序列：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It''s possible to update an element at a certain position by using the `updated`
    method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`updated`方法在某个位置更新一个元素：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A call to this `updated` method with an index and an element replaces the element
    at the passed index with the element passed as a parameter. The good thing about
    this operation is that it takes constant time and doesn''t affect the original
    sequence. Hence, if you try to print the sequence we created, you''ll get the
    elements unchanged:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引和元素调用此`updated`方法将替换传递的索引处的元素。这个操作的好处是它只需要常数时间，并且不会影响原始序列。因此，如果你尝试打印我们创建的序列，你会得到未更改的元素：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Immutable stack
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变栈
- en: 'You may need a collection with *last in first out* traversal. For that, Scala
    provides the `stack` implementation. It''s easy to create a stack, and `push`
    and `pop` elements in the stack:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要一个具有*后进先出*遍历的集合。为此，Scala提供了`stack`实现。创建栈很容易，可以在栈中`push`和`pop`元素：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stacks are immutable, so performing any operation will not change the elements
    from the stack that was created previously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是不可变的，所以执行任何操作都不会改变之前创建的栈中的元素。
- en: Immutable queue
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变队列
- en: 'For those who don''t know it already, a queue is *first in first out* data
    structure. Two helper methods to put an element into a queue and remove them are
    `enqueue` and `dequeue`*.* Let''s create a queue:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些还不知道的人来说，队列是一种*先进先出*数据结构。有两个辅助方法可以将元素放入队列并移除它们，即`enqueue`和`dequeue`*.* 让我们创建一个队列：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code is the method for enqueuing an element in a queue. It can
    be seen that `dequeue` returns the element removed along with the rest of the
    queue.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是向队列中入队元素的函数。可以看出`dequeue`返回了被移除的元素以及队列的其余部分。
- en: Ranges
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'Range describes a range of numbers. There are a few helper methods we can use
    to create a range in Scala. Let''s take a look at them:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 范围描述了一组数字。在Scala中，我们可以使用一些辅助方法来创建范围。让我们来看看它们：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We created two ranges. The first one simply contains numbers ranging from 1
    to 10, inclusive. Then we created numbers ranging from 1 to 10 with a step size
    of 2\. There''s also a way to create a range that does not include the last element.
    This can be done using the `util` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个范围。第一个简单地包含从1到10的数字，包括10。然后我们创建了从1到10，步长为2的数字。还有创建不包含最后一个元素的范围的方法。这可以通过使用`util`方法来完成：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we created a range using the `Until` method containing numbers 1 to 5\.
    Printing this range yielded the numbers from 1 to 4, because `Until` does not
    include the last element. `Range` is also an immutable collection. Now, after
    going through these immutable collections, let's take a look at few mutable concrete
    collections. We'll start with the most common, `ArrayBuffer`*.*
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用包含数字1到5的`Until`方法创建了一个范围。打印这个范围产生了从1到4的数字，因为`Until`不包括最后一个元素。"Range"也是一个不可变集合。现在，在了解了这些不可变集合之后，让我们看看几个可变的具体集合。我们将从最常见的一个开始，即`ArrayBuffer`：
- en: ArrayBuffer
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayBuffer
- en: '`ArrayBuffer` is only available as a mutable sequence in Scala. These are efficient
    collections; they make it easy to add an element at the end of a collection. `ArrayBuffer`
    is also an indexed sequence, so retrieving an element via an index doesn''t degrade
    the performance. Let''s see how we can create and use `ArrayBuffer` in Scala:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer`在Scala中仅作为可变序列可用。这些是高效的集合；它们使得在集合末尾添加元素变得容易。"ArrayBuffer"也是一个索引序列，因此通过索引检索元素不会降低性能。让我们看看如何在Scala中创建和使用`ArrayBuffer`：'
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can create `ArrayBuffer` by first importing the `scala.collection.mutable`package. We
    can instantiate it by providing elements in the constructor. We can add and remove elements
    to the buffer using methods provided for `ArrayBuffer`*:*
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过首先导入`scala.collection.mutable`包来创建`ArrayBuffer`。我们可以通过在构造函数中提供元素来实例化它。我们可以使用为`ArrayBuffer`提供的`add`和`remove`方法向缓冲区添加和移除元素：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ListBuffer
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ListBuffer
- en: '`ArrayBuffer` uses an array to store elements internally, whereas `ListBuffer`
    uses a linked list representation. Operations performed on these buffers are similar
    to that of `ArrayBuffers`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayBuffer`使用数组来存储元素，而`ListBuffer`使用链表表示。对这些缓冲区执行的操作与`ArrayBuffer`类似：'
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's worth noting that because of the internal linked list representation, it's
    recommended to use `ListBuffer` instead of `ArrayBuffer` if our requirement is
    to convert our collection to a list. It's applicable vice versa, if the requirement
    is to convert our collection to an array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于内部链表表示，如果我们的需求是将我们的集合转换为列表，则建议使用`ListBuffer`而不是`ArrayBuffer`。如果需求是将我们的集合转换为数组，则反之亦然。
- en: StringBuilder
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: StringBuilder
- en: '`StringBuilder` is used to build a sequence of strings. A simple call to `toString`
    will convert it to `String`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`用于构建字符串序列。简单的调用`toString`将将其转换为`String`：'
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There're other mutable versions of stacks, queues, and maps. There are methods
    provided to update these mutable collections.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可变的栈、队列和映射版本。提供了方法来更新这些可变集合。
- en: Array
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Array in Scala is defined as follows; it extends the `Serializable` and `Cloneable`
    traits from Java. Also, it can be seen that arrays are generic:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Scala中的数组定义如下；它扩展了Java中的`Serializable`和`Cloneable`特性。同时，我们可以看到数组是泛型的：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In Scala, arrays are mutable. Defining an array is simple:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，数组是可变的。定义数组很简单：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, it''s possible to perform the operations that we perform on sequences.
    Arrays are indexed and mutable as well:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以执行我们在序列上执行的操作。数组是索引和可变的：
- en: '[PRE49]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It's also possible to perform map operations on an array, which makes Scala's
    arrays better than their Java counterparts.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上也可以执行映射操作，这使得Scala的数组比它们的Java对应物更好。
- en: Up to now, we have introduced all the common collections, and have a basic idea
    about how these collections can be declared and used. But what makes Scala collections
    powerful is the set of rich operations performed on these collections. There's
    a set of operations that can be performed using some higher-order methods available
    with these collections. It's time to go and take a look at those.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了所有常见的集合，并对如何声明和使用这些集合有一个基本的了解。但使Scala集合强大的是对这些集合执行的一组丰富操作。有一组可以使用这些集合中的一些高阶方法执行的操作。是时候去看看那些了。
- en: Rich operations performed on collections
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集合上执行的丰富操作
- en: 'We have quite a few methods for our collections, which we can use to simplify
    almost every problem regarding collections in Scala. We are going to take a look
    at some important methods. First, let''s set the stage: so consider a scenario
    where you have some structured data related to football players. and you have
    to perform manipulations based on that. We''ll perform a set of operations on
    the data using our collection. We''ll also learn about methods, their signatures,
    and use cases along the way. Here''s a simple code snippet that shows what we
    just said—nothing too interesting as of now:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的集合提供了一些方法，我们可以使用这些方法简化Scala中几乎所有的集合问题。我们将查看一些重要方法。首先，让我们设定场景：假设你有一些与足球运动员相关的结构化数据，并且你必须基于这些数据进行操作。我们将使用我们的集合对数据进行一系列操作。我们还将了解方法、它们的签名和用例。以下是一个简单的代码片段，展示了我们刚才所说的——目前没有什么特别有趣的内容：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here''s the thing—we have a CSV file that contains some data as comma-separated
    values. We can read the data in our program as a `BufferredSource`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是——我们有一个包含一些以逗号分隔值的CSV文件。我们可以在程序中以`BufferredSource`的形式读取数据：
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will load the CSV file's contents. The first thing we can do is to convert
    the data into a readable format so that it gets easier for us to perform any operation
    on it. For that, we have a case class, `Player`*:*
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载CSV文件的全部内容。我们可以做的第一件事是将数据转换为可读格式，这样我们就可以更容易地对它进行任何操作。为此，我们有一个case类，`Player`：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We'll try to read the content from the file and create a collection of players.
    The following expression reads from the buffered source, and converts each line
    to an element in a `List`*:*
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试从文件中读取内容并创建一个球员集合。以下表达式从缓冲源中读取，并将每一行转换为`List`中的一个元素：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, the `getLines` method converts the buffered source to an `Iterator` object
    of string type. A call to the `toXXX` form of the method can be used to convert
    between *traversables.* We've made a call to the `toList` method on our `Iterator`
    object. This converts the *Iterable* of type string to a list of strings. There
    are other versions such as `toIterable`*,* `toSeq`*,* `toIndexedSeq`*,* `toBuffer`*,*
    `toSet`*,* and `toVector`*.* All these methods reside in a trait named `TraversableOnce`*.*
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`getLines`方法将缓冲源转换为字符串类型的`Iterator`对象。可以使用`toXXX`形式的调用在*traversables*之间进行转换。我们在`Iterator`对象上调用`toList`方法。这把字符串类型的*Iterable*转换为字符串列表。还有其他版本，如`toIterable`、`toSeq`、`toIndexedSeq`、`toBuffer`、`toSet`和`toVector`。所有这些方法都位于名为`TraversableOnce`的特质中。
- en: We can use the `toXXX` method to convert into another Traversable of type `XXX`,
    where `XXX` is a placeholder for `Set`, `Vector`, `Buffer`, and so on.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`toXXX`方法将数据转换为另一种类型的`Traversable`，其中`XXX`是一个占位符，代表`Set`、`Vector`、`Buffer`等。
- en: 'After reading the content from the CSV file, we now have a list of strings,
    with each string containing information about a player in the following format:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在从CSV文件读取内容后，我们现在有一个字符串列表，每个字符串都包含关于球员的信息，格式如下：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Each line has information such as the ranking of the player in the past few
    years, his/her name, nationality, club, points scored, and age. We''ll parse the
    string and map all the information to our `Player` object. Let''s do it:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都包含诸如过去几年球员排名、姓名、国籍、俱乐部、得分和年龄等信息。我们将解析字符串并将所有信息映射到我们的`Player`对象上。让我们来做这件事：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this method, we see one important method that works for collections. Our
    `giveMePlayers` function parses the list of string, and as its name suggests,
    it returns a list of players. The function performs a pattern match on the list
    of strings. We have matched the list as `head :: tail`; it treats the head as
    the first element of the list, and the tail as the rest of the elements. It can
    also be seen that the list can be empty; in that case, the second scenario will
    be executed, and the function will return an empty list. As we know from the CSV,
    the first line contains the meta-information about the rest of the file. So we
    omit the `head` and perform a `map` operation on `tail`, that is, the rest of
    the list. The `map` method basically performs the given operation on each element
    and returns the collection with the resulting values. In our case, we''re splitting
    the comma-separated values from each line and converting values to the `Player`
    object. At the end of the call to the `map` method, we''ll get a list of players.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种方法中，我们看到了一个适用于集合的重要方法。我们的`giveMePlayers`函数解析字符串列表，正如其名称所暗示的，它返回一个玩家列表。该函数对字符串列表执行模式匹配。我们将列表匹配为`head
    :: tail`；它将头视为列表的第一个元素，将尾视为其余元素。我们还可以看到列表可以为空；在这种情况下，将执行第二种情况，函数将返回一个空列表。正如我们从CSV中知道的那样，第一行包含关于文件其余部分的元信息。因此，我们省略了`head`并在`tail`上执行`map`操作，即列表的其余部分。`map`方法基本上对每个元素执行给定的操作，并返回包含结果的集合。在我们的情况下，我们正在分割每行的逗号分隔值，并将值转换为`Player`对象。在`map`方法的调用结束时，我们将得到一个玩家列表。'
- en: The `map` method composes another collection, applying an operation passed to
    it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法组合另一个集合，应用传递给它的操作。'
- en: 'The definition of the `map` method looks as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法的定义如下：'
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `map` method takes a function that converts type `A` to type `B`, and performs
    that operation to each element of the collection, and finally returns a collection
    of type B. In our case, types `A` and `B` were `String` and `Player`*.*
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法接受一个将类型`A`转换为类型`B`的函数，并对集合的每个元素执行该操作，最后返回类型为B的集合。在我们的情况下，类型`A`和`B`是`String`和`Player`*.*'
- en: 'At this point, our code looks like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码看起来是这样的：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we have a fully formed collection of `Players`, thanks to our `map` method.
    We can perform lots and lots of different operations. We can make a list of top
    10 players. How can this be done? By using our `filter` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了由我们的`map`方法完全形成的`Players`集合。我们可以执行许多不同的操作。我们可以制作一个前10名玩家的列表。这该如何做到？通过使用我们的`filter`方法：
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is simple; it''s just a call to filter, then we tell it what predicate
    to filter elements upon. It''ll do the filtering for you. We have checked the
    ranking for each player and preserved those for whom the value is less than 11:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；这只是一个对`filter`的调用，然后我们告诉它要基于什么谓词过滤元素。它会为你进行过滤。我们已经检查了每个玩家的排名，并保留了那些值小于11的玩家：
- en: The `filter` method filters the collection elements that satisfy the predicate
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`方法过滤掉满足谓词的集合元素'
- en: The `filterNot` method filters the collection elements that do not satisfy the
    predicate
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filterNot`方法过滤掉不满足谓词的集合元素'
- en: 'The signature of the `filter` method looks as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`方法的签名如下：'
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This `filter` method takes a predicate, based on the predicate. The method filters
    out the Traversable. Here, `Repr` is a type parameter for the collection, and
    our Traversable collection looks like `TraversableLike[+A, +Repr]`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`filter`方法接受一个基于谓词的方法。该方法过滤掉可遍历的。在这里，`Repr`是集合的类型参数，我们的可遍历集合看起来像`TraversableLike[+A,
    +Repr]`。
- en: 'To check whether the method filters out the right players, you may want to
    print it and see. Why not print our players in some structured way? Take a look
    at the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查该方法是否过滤出了正确的玩家，你可能想打印出来看看。为什么不以某种结构化的方式打印我们的玩家呢？看看以下代码：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have defined the `showPlayers` function, which takes a list and prints player
    information in the following manner:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`showPlayers`函数，它接受一个列表，并以以下方式打印玩家信息：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: I think you're keen enough to see that the filter traverses through the whole
    list to check whether the ranking is less than 11, bravo! Also, understand that
    this is not the way we would do this to our collection if the list were sorted.
    In that case, we've a few other methods, and one of them is `takeWhile`*:*
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '我想你已经足够敏锐地注意到，过滤会遍历整个列表来检查排名是否小于11，太棒了！也要理解，如果列表是有序的，我们不会以这种方式对我们的集合做这件事。在这种情况下，我们有几种其他方法，其中之一是`takeWhile`*:'
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This `takeWhile` method also takes a predicate, the same in our case, and returns
    a list of elements for which the predicate is true. In our case, it works, and
    we get the top 10 players:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`takeWhile`方法也接受一个谓词，在我们的情况下是相同的，并返回一个元素列表，这些元素的谓词为真。在我们的情况下，它工作得很好，我们得到了前10名玩家：
- en: The `takeWhile` method takes the longest sub-collection of elements that satisfies
    the predicate
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`takeWhile`方法取满足谓词的最长子集合元素'
- en: The `dropWhile` method drops the longest sub-collection of elements that satisfies
    the predicate
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dropWhile`方法丢弃满足谓词的最长子集合元素'
- en: 'The signature looks almost exactly like our `filter` method. It takes a predicate,
    and returns a Traversable:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 签名看起来几乎与我们的`filter`方法完全相同。它接受一个谓词，并返回一个可遍历的集合：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There''s also a `dropWhile` version of the method. Its intent is almost the
    same as `takeWhile`; the only thing that differs is that it drops those elements
    that satisfy the predicate. There can be more of this sort of method, based on
    the requirements we can use. One of them is the `partition` method, which splits
    apart our list into a tuple of two lists: one that satisfies the predicate, and
    other that doesn''t. Take a look at the following code snippet:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还有一个`dropWhile`版本。其意图几乎与`takeWhile`相同；唯一不同的是它丢弃满足谓词的元素。根据我们的需求，可能会有更多这类方法。其中之一是`partition`方法，它将我们的列表拆分为两个列表的元组：一个满足谓词，另一个不满足。请看以下代码片段：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: First, the `take`method selects 50 players from our list of *players.* Then,
    we call the `partition` method on our first 50 players, which splits our list
    into two sub-lists based on the predicate we pass. Here, we want to divide the
    first 50 players into two separate collections of 20 and 30 players. After calling
    this function, we get two new values, `top20` and `least30`, which have the top
    20 players and the bottom 30 players out of the first 50.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`take`方法从我们的玩家列表中选择50名玩家。然后，我们对前50名玩家调用`partition`方法，根据我们传递的谓词将我们的列表拆分为两个子列表。在这里，我们想要将前50名玩家分成两个单独的集合，每个集合有20名和30名玩家。调用此函数后，我们得到两个新值`top20`和`least30`，它们分别包含前20名玩家和前50名中的后30名玩家。
- en: 'A simple one-liner can do this much with the collection of elements; that''s
    the power of Scala collections:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一行简单的代码就可以用元素集合做到这么多；这就是Scala集合的力量：
- en: The `take` method selects the first `n` elements from the collection
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`take`方法从集合中选择前`n`个元素'
- en: The `drop` method drops the first `n` elements from the collection
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop`方法从集合中丢弃前`n`个元素'
- en: The `partition` method drops the first `n` elements from the collection
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`方法从集合中丢弃前`n`个元素'
- en: 'The signatures of these methods are simple:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的签名很简单：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `take` and `drop` methods take the number of elements to select or drop.
    The other method, `partition`, expects a predicate, splits the collection into
    two sub-collections, and returns a tuple of those two sub-collections. There are
    a few more of these methods; let''s take a look at them:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`take`和`drop`方法接受要选择或丢弃的元素数量。另一个方法`partition`期望一个谓词，将集合拆分为两个子集合，并返回这两个子集合的元组。还有一些其他的方法；让我们来看看它们：'
- en: The `slice` method selects an interval of elements
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice`方法选择元素的一个区间'
- en: The `span` method splits the collection into two collections based on the predicate,
    where the order of elements is not preserved
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`span`方法根据谓词将集合分割成两个集合，其中元素的顺序不被保留'
- en: The `splitAt` method splits a collection at a given position
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splitAt`方法在给定位置分割集合'
- en: 'These methods are simple, as they do exactly what their description implies.
    Their description also explains the same:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法很简单，因为它们确实做了它们描述中所说的。它们的描述也解释了同样的内容：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `slice` method takes the initial and last index, and returns that number
    of elements as a collection. The second method, `span`, works exactly the same
    as the `partition` method. It takes a predicate and returns a pair of collections:
    the first satisfies the predicate, and second does not. It''s possible that the
    order of elements has not been preserved.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice`方法接受初始和最后一个索引，并返回相应数量的元素作为集合。第二个方法`span`与`partition`方法的工作方式完全相同。它接受一个谓词并返回一对集合：第一个满足谓词，第二个不满足。元素的顺序可能没有被保留。'
- en: 'The last of the three, `splitAt`, takes a value `n` and returns a pair of sub-collections,
    split at `n`. These methods make it easy to implement scenarios such as this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法`splitAt`接受一个值`n`，并返回一对子集合，在`n`处分割。这些方法使得实现如下场景变得容易：
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s take a look at one more set of methods, using which we can check for
    a predicate in our collection:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一组方法，使用这些方法我们可以检查集合中的谓词：
- en: The `count` method counts the number of elements that satisfy a given predicate
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 方法计算满足给定谓词的元素数量'
- en: The `exists` method checks whether a predicate holds true for even a single
    element in a given collection
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exists` 方法检查给定集合中是否至少有一个元素满足谓词'
- en: The `forAll` method checks whether a predicate holds true for all elements in
    a given collection
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forAll` 方法检查给定集合中所有元素是否满足谓词'
- en: The `find` method finds the first element that satisfies a predicate
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find` 方法找到满足谓词的第一个元素'
- en: 'We can count the number of players from a particular country like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样计算来自特定国家的玩家数量：
- en: '[PRE68]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The partial function `isGermanPlayer` checks for a player''s nationality. We
    then passed this partial function as a predicate to the `count`method*,* which
    gives the number of players. We may also want to check whether there are any players
    with an age above 45, and we may check that using the `exists` method:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数 `isGermanPlayer` 检查球员的国籍。然后我们将这个部分函数作为谓词传递给 `count` 方法*，*它给出了球员的数量。我们可能还想检查是否有年龄超过45岁的球员，我们可以使用
    `exists` 方法来检查：
- en: '[PRE69]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The are two other methods, `forAll` and `find`*.* We''ll check the top player
    with an age of more than 35 years:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个方法，`forAll` 和 `find`*.* 我们将检查年龄超过35岁的顶级球员：
- en: '[PRE70]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'These methods are simple yet powerful, and composing them can bring down our
    solution approach to easy. Let''s find the top 5 players by ranking, with ages
    over 35:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法简单而强大，组合它们可以将我们的解决方案方法简化。让我们通过排名找出年龄超过35岁的顶级前5名球员：
- en: '[PRE71]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'One of the examples is where we first called the `filter` method on our list
    of players, then called take 5 to select first 5 from results. We''ve seen these
    examples, so let''s take a look at the definitions of these methods:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是我们首先在我们的球员列表上调用 `filter` 方法，然后调用 `take 5` 来从结果中选择前5个。我们已经看到了这些例子，那么让我们看看这些方法的定义：
- en: '[PRE72]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: All methods take a predicate and respond differently. The `find` method selects
    the very first element from a collection for which the predicate is satisfied.
    The next ones, `count` and `exists`, check for the total number of elements that
    satisfy the predicate, and whether any single element for which the predicate
    is satisfied exists, respectively.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法都接受一个谓词并作出不同的响应。`find` 方法从集合中选择满足谓词的第一个元素。接下来的 `count` 和 `exists` 方法分别检查满足谓词的元素总数以及是否存在满足谓词的单个元素。
- en: 'Finally, the `forAll` method checks whether the predicate is satisfied for
    all elements in the collection. We can also call for a check if there''s any element
    in our list using `isEmpty`, because it''s obvious your filter on a collection
    results is an empty list. There''re few methods to use to check information about
    the list:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`forAll` 方法检查集合中所有元素是否满足谓词。我们也可以使用 `isEmpty` 来检查列表中是否有任何元素，因为很明显，对集合结果的过滤将得到一个空列表。有一些方法可以用来检查列表信息：
- en: The `isEmpty` method counts the number of elements that satisfy a given predicate
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isEmpty` 方法计算满足给定谓词的元素数量'
- en: The `hasDefiniteSize` method checks whether a predicate holds true for even
    a single element in a given collection
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasDefiniteSize` 方法检查给定集合中是否至少有一个元素满足谓词'
- en: The `size` method checks whether a predicate holds true for all elements in
    a given collection
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` 方法检查给定集合中所有元素是否满足谓词'
- en: 'These methods, as their names suggest, are simple to use and clear to understand
    as well. You remember we did a pattern match on a list using `head :: tail`? Well,
    we can also call these methods on our collection in the same way. There exists
    a few more utility methods to access list elements:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '这些方法，正如它们的名称所暗示的，使用简单且易于理解。记得我们使用 `head :: tail` 在列表上进行了模式匹配吗？嗯，我们也可以以同样的方式在我们的集合上调用这些方法。还有一些额外的实用方法来访问列表元素：'
- en: The `head` method returns the head element of the collection
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head` 方法返回集合的头元素'
- en: The `tail` method returns all elements except the head element
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tail` 方法返回除了头元素之外的所有元素'
- en: The `init` method returns all but the last element
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` 方法返回除了最后一个元素之外的所有元素'
- en: The `last` method returns the last element of the collection
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last` 方法返回集合的最后一个元素'
- en: The `reverse` method returns the list in reverse
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse` 方法返回反转的列表'
- en: 'We can use these methods while doing a pattern match, or whenever we may have
    to retrieve the first or last elements. Using the `init` or `tail` methods recursively
    is also a way to utilize list elements. Finally, one of the most important operations
    we can perform on a list of elements is to fold or reduce the list into a value—a
    single value. So, we can fold our list of players and construct another list of
    country names from that. How we can do this? Let''s take a look at how we can
    use `fold` operations:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The `fold` method folds collections using a binary associative operation
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `foldLeft` method folds collections by applying a binary operation to the
    initial, and then each element going from left to right
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `foldRight` method folds collections by applying a binary operation to the
    initial, and then each element going from right to left
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose we want to construct a list of country names from our top 20 players''
    information. We can do this as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We''ll get the following on running the code:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This can also be done by going from right to left through the list:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We''ll get the following on running the code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The definition of the `fold` methods look as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The method takes an initial value; in our case, it's a list. Then we pass a
    function that works on each element from our collection, and the value passed
    works as a seed to our operator function. The `foldLeft` and `foldRight` methods perform
    a binary operation on these two elements until it processes the last element in
    the collection, thus producing the final value for us. If you take a look at both
    of these methods, you'll be able to see that the order of parameters has changed.
    Also, the signatures of these `foldLeft` and `foldRight` methods are curried.
    The first curried parameter is the initial element, which works as an accumulator
    as we traverse through or fold our collection. The second parameter, which is
    a binary function, takes place and is applied to collection elements. This `fold` function
    results in one value over a collection that's an accumulated response for the
    whole collection.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: After working with all these methods that make it easier to work with collections,
    let's take a look at a method that can convert our collection to a parallel collection,
    which can be processed in parallel. The method is `par`*:* when you call the method
    on our collection, it returns a `ParSeq`*, *that is, a parallel sequence. This
    parallel sequence is a parallel equivalent of our collection.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to print the elements from this sequence quite a few times, the
    order will not be preserved, because of the parallel nature of the sequence:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We''ll get the following on running the code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now that we know we can convert our collections into their parallel equivalents,
    there should be other ways to build parallel collections. Let's go through parallel
    collections in Scala.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Parallel collections in Scala
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's obvious that if the number of elements in a collection is very large, then
    you would want to minimize the time it takes to manipulate the collection data.
    That's where breaking down the tasks and executing them parallel is an option,
    and a good one. Scala provides parallelism in the form of parallel collections,
    which works like a charm in scenarios where we have to deal with a big chunk of
    data. The good thing is that our  `par` method can easily convert a normal sequential
    collection to its parallel counterpart implicitly, and the `map`*,* `fold`, and
    `filter` methods work great with parallel collections as well.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the architecture of parallel collections, or how these work on
    JVM, is out of the scope of this book. We'll keep our discussion limited to concrete
    implementations of parallel collections, and how we can use them in Scala. If
    you're into understanding parallel collections, Scala's documentation gives a
    brief overview at [http://docs.scala-lang.org/overviews/parallel-collections/overview](http://docs.scala-lang.org/overviews/parallel-collections/overview).
    Another resource is the book *Learning Concurrent Programming in Scala* by Aleksandar
    Prokopec*.* For now, let's start with the concrete implementations of parallel
    collections in Scala. There are a few parallel collection classes, such as `ParArray`*,*
    `ParVector`*,* and `ParRange`*,* and also a few `set` and `map` implementations
    such as `ParHashMap` and `ParHashSet`*.*
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: ParArray
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ParArray` constructor is the parallel implementation of `ArraySeq`, and
    holds elements in a linear fashion. It resides in the `scala.collection.parallel.mutable`
    package. To create a parallel array, we can import this package as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we have created a parallel array named `pararr` by simply using the `ParArray`
    constructor, with elements passed as arguments. For demonstration purposes, we''re
    using a limited number of elements in our implementation, but it''s obvious we
    would like parallel abstractions to contain a higher number of elements to really
    work effectively. It''s also possible to convert a parallel collection into its
    sequential counterpart using the `seq` method:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: A parallel array is a parallel mutable collection. We also have immutable versions
    of parallel collections. `ParVector` is one of them.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: ParVector
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ParVector` is an immutable parallel sequence. We can create a parallel vector
    in a similar fashion to how we created a parallel array:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can perform the same operations using methods such as `map`*,* which we
    can use from its sequential counterpart. Let''s take integers that are greater
    than 5 from our `parvec` parallel vector:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In a similar fashion, we can also create `ParHashSet` and `ParHashMap`*.* These
    are immutable parallel collections. `ParHashMap` avoids collision internally by
    using a chaining mechanism.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: It's worth knowing that the basic idea of parallelizing a collection is to split
    it into smaller parts using algorithms such as Divide and Conquer. These smaller
    parts are then operated upon using multiple tasks. Scala's parallel collection
    does this task scheduling through a `scala.collection.parallel.TaskSupport` object
    that is configurable. Also one should keep in mind that *side-effecting* operations
    are unpredictable, and when executed in parallel, they can produce deadlocks or
    race conditions. So as programmers, it's our responsibility to write code in a
    manner that avoids these race conditions. Parallel collections make it easier
    to solve problems where large amounts of data are to be processed. They make collections
    more powerful in Scala. You may also want to utilize this power when you use any
    Java collection from a library; in that case, you may want to read the next section.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Converting a Java collection into a Scala collection
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scala interoperates with a lot of Java libraries, so you may have to deal with
    Java code as well. It''s possible for you to encounter a situation where you''ve
    a Java collection and you''re expected to convert it into Scala. With this idea
    of converting a collection from Java to Scala, it may look a little bit scary
    that we''ve got to traverse through elements from Java''s collection, and then
    append them to a Scala collection. But here''s the catch: there''re already ways
    you can do this. It''s easy: we''ve a `JavaConverters` object in the `scala.collection` package, which
    takes care of this conversion. Actually, what happens behind the scenes when you
    call these conversion methods is that the implicit conversion takes place. Why
    not take a look at an example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following is the result:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Here's the program. We've a Java list named `aJavaList`*,* which is a list of
    dates with a few date objects in it. Yes, it's not a complex problem; what we
    simply have to do is to convert this list into a Scala collection so that we can
    perform our higher order operations such as `map` or `flatMap`*.* For that, as
    we can see, we imported the `scala.collection.JavaConvertors` object. After importing
    this object, we now have access to a converter method, `asScala`, which converts
    your Java collection to a Scala counterpart, which internally checks for the suitable
    collection to convert in, and the conversion happens implicitly. Finally, after
    conversion, we're able to use the `map` function on the `scalaDates` object, which
    is not a Scala collection.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to convert a Scala collection to a Java counterpart using
    `asJava`*.* So it''ll be totally fine to write something like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It'll convert the Scala collection into a Java collection. It's good that when
    you perform one conversion from the source collection to the target collection
    and then reconvert it, you actually get the main real object. Now that you've
    seen all the collections from Scala, and also have an idea that Java collections
    can also be converted to Scala collections, you've so many options to choose from
    for any requirement.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a collection
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the problem: after learning so many ways to make a collection of elements
    in Scala, it appears that we''ve got a big dilemma. We have quite a few options
    to choose from. Almost every collection has higher order functions to operate
    with. These are high-performing, type parameterized, and immutable collections.
    So how do we decide which collection to use? Now, we''ve the answer for that.
    And the answer is, it depends. Yes, it depends on multiple factors; for example,
    in which format would you like to have the data. Is it a simple sequence or in
    pair format? It''s obvious that we''ve been talking about sequences, and maps
    up to now. In the majority of situations, we come up with `Map`, `Set`*,* `List`*,*
    `ArrayBuffer`, or a `Vector`*.* Let''s talk about the factors that matter:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: If the requirement is to have a key-value lookup, we use Maps.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `HashMap` when order is of no importance, and `ListMap` when we want
    to store the key-value pairs in a sequence. `ListMap` operations take linear time,
    as the number of elements increases. So using a `Map` is recommended in normal
    cases; if, somehow, the requirement is that we've got to operate on the first
    of a few collection elements, then `ListMap` can become a better choice.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sets*,* as you know already, contain no duplicate elements, so to remove duplicates
    we may choose to use a `Set`, or convert our collection to a `Set`*.* In Scala,
    a `Set` also extends `(A) ⇒ Boolean`, and this means that we may use a set to
    check the presence of an element in our collection. So it''s simple: if you''re
    required to check the presence of an element often, or to remove duplicates, use
    a `Set`.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to store finite elements, traverse through them, or perform some
    operation on them, please choose a `List`. An `ArrayBuffer` is also a good choice
    in case you need it to be mutable. A `List` is a linear sequence, so performing
    operations is costly when the number of elements increases due to linear performance.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the requirement is random access, and traversal is not of much importance,
    an indexed sequence is recommended, so please give `ArrayBuffer` a chance*.*
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want faster random access and a persistent sequence, use `Vector`*.*
    And yes, Vector is persistent, because it preserves the previous version of itself.
    That's not possible with an `ArrayBuffer`*,* because of mutability.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy evaluation can be an asset when working with Streams*.* It's a wise choice
    when the requirement is to evaluate a collection element on a need basis. We've
    seen how the `Stream` is represented, because of elements being lazily computed.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the immutables. We can create a *Range *on the go with some collection's
    size, or something of that sort. It's easy to create a `Range` with `in`*,* `until`,
    and `by` methods.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, it mostly all depends on what are we going to do with our collection elements.
    Of course, performance is of the utmost importance to us, because collections
    take up a big part of writing logic into our programs. We can start with a wrong
    choice of collection, then based on the need, we can convert those. It may look
    easy, but it's going to impact performance for sure. For example, it's wise to
    use a `ListBuffer` if later in the program you decide to convert it into a list.
    The reason is that a `ListBuffer` stores elements internally in a linked list
    format. So it's easy to convert to a list, rather than an array. Different operations,
    from instantiating a collection to updating, appending, or calling head or tail
    on your collection, all take different amounts of time, and thus can make your
    code less performant. So the idea is to choose wisely, based on what's of importance
    to your program. So why not compare the performance of several collections?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Collection performance
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are all the things you can do with a collection? Let''s think of some
    use cases:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: First, create a collection object
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert an element
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform an operation on each element of a collection, which is only possible
    when you access each element
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traverse through the collection
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break it down into parts, perhaps one part with a single first element, and
    another with the rest of the collection (which are `head` and `tail`, obviously)
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomly seek out a particular element
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update an element
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse the collection
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, this covers pretty much everything you can do with a collection. The good
    thing is that if you're sure about the kinds of operations you're going to perform
    on your collection, you can make a performant program. The bad news is we hardly
    think about the operations we're going to perform later in programs, unless you're
    fortunate. But we've got an idea about all the collections and their performance.
    You may want to refer to the performance characteristics table in Scala's official
    documentation at [http://docs.scala-lang.org/overviews/collections/performance-characteristics.html.](http://docs.scala-lang.org/overviews/collections/performance-characteristics.html)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The following observations will help with the idea of calling `apply`, `append`,
    `head`, or `tail` operations on a collection:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '**List****:** List is a linear sequence, so methods such as `apply` and `append`
    take more time as the number of elements increases. But accessing `head` and `tail`
    elements takes a fixed amount of time:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Linear` | `append => Linear` | `head => Constant` | `tail => Constant`
    |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: The same goes for a `Stream` as well.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vector:** Vector is more performant than a list on a few grounds, and `apply`
    and `append` operations are definitely more performant than a list.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Effectively Constant` | `append => Effectively Constant` |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| `head => Effectively Constant` | `Tail => Effectively Constant` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '**Range**: Range is a good option for those going for constant time access to `apply`*,*
    `head`, or `tail` operations.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Constant` | `head => Constant` | `tail => Constant` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '**String**: String and Array work well for `apply` and `head` operations with
    a constant time response, but `tail` is a costly operation for these.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `apply => Constant` | `head => Constant` | `tail => Linear` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '**Maps**: Maps are used to do value lookups based on keys or add/remove key-value
    pairs. `HashMap` effectively provides constant time for these operations.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| `lookup => Effectively Constant` | `add => Effectively Constant` | `remove
    => Effectively Constant` |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: Knowing the structure of a collection provides almost all the information about
    its performance. We now have an idea about all the collections in Scala, so it's
    time for you to practice more and experiment more with these collections.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to the implementation of Scala's collections.
    We started learning about immutable and mutable collections. After that, we discussed
    Scala's collection hierarchy, where we learned about various super traits such
    as `Traversable` and `Iterable`*.* We also talked about three abstract collection
    types: `Seq`, `Set`, and `Map`. Then we took a look at the most commonly used
    collections in Scala. After that, we went the extra mile to learn about all the
    important functions used to work with collections. Then we learned about how we
    can convert collections from Java to Scala and vice versa, and found out that
    it was easy. After that, we discussed which collection to choose from all these
    options, which led us to consider the performance characteristics of collections.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've come to the end of part 1\. In the next part, we'll start with
    the object-oriented and functional constructs provided by Scala. The next chapter
    is about the basics of object-oriented constructs in Scala, such as classes, traits,
    and objects. Learning them will enable us to utilize functional constructs efficiently
    in later parts of this book.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
