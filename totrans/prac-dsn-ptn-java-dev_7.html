<html><head></head><body>
		<div id="_idContainer103">
			<h1 id="_idParaDest-303" class="chapter-number"><a id="_idTextAnchor481"/>7</h1>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor482"/>Understanding Common  Anti-Patterns</h1>
			<p>Throughout the previous chapters, we have explored the <em class="italic">green working paths</em> of imaginary vehicle-related applications. In this chapter, the abstraction of the vehicle will remain a supporting element, because one may imagine a vehicle-inspired application more easily than other abstractions. A vehicle, along with all of its parts, is an idea that’s easy <span class="No-Break">to grasp.</span></p>
			<p>Let’s quickly recap the importance of design patterns and how they contribute to the success of an <span class="No-Break">organization’s success.</span></p>
			<p>Melvin E. Conway said that the design and implementation of an application strongly reflect an organization’s internal communication. This statement is no less relevant today, especially now that many projects use agile approaches. Automated builds, continuous integration or testing, and subsequent automated deployment play a key role in delivering applications to production. Any overlooked or unexpected limitation can limit or damage an application’s <span class="No-Break">main objective<a id="_idTextAnchor483"/>.</span></p>
			<p>In this chapter, we will review some important areas for identifying signs of deviation from the main goal so that you can have functional, maintainable, and transparent applications. Not having those qualities can negatively affect application functionality on multiple levels. Runtime could be damaged, which might result in unpredictable costs. Faults could be hidden in application architecture, disallowing extendibility and maintainability. Such issues could also recur and require specialized attention in <span class="No-Break">each case.</span></p>
			<p>We will concentrate on the <span class="No-Break">following areas:</span></p>
			<ul>
				<li>What anti-patterns are and how to <span class="No-Break">identify them</span></li>
				<li>Examining typical <span class="No-Break">software anti-patterns</span></li>
				<li>Understanding software <span class="No-Break">architecture anti-patterns</span></li>
			</ul>
			<p>By the end of this chapter, you will be able to identify and understand some of the signs of anti-patterns that should be looked <span class="No-Break">out for.</span></p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor484"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor485"/>What anti-patterns are and how to identify them</h1>
			<p>One might define an anti-pattern<a id="_idIndexMarker576"/> as the exact opposite of a good design pattern or good practice. Though that might<a id="_idIndexMarker577"/> seem like the bottom line, it ignores the context and sequence of actions that led to a software practice being called an anti-pattern. In other words, it does not explain why an anti-pattern is a collection of highly risky, ineffective, and counterproductive steps. It is important to understand these steps as they allow creating a repeatable process to obtain a similar result, just to verify the ambiguity. The bottom line is that these steps may limit the ability to productively address the issues. Let us dive a bit deeper into <span class="No-Break">the theory.</span></p>
			<h2 id="_idParaDest-307">Theoretica<a id="_idTextAnchor486"/>l principles challenges</h2>
			<p>Anti-patterns can naturally<a id="_idIndexMarker578"/> appear during software development due to multiple reasons. They may be due to a shift in business logic, technology migration, or missing information. The fact remains that anti-patterns do occur and, simply put, can be part of the development process due to team size, communication issues, <span class="No-Break">and more.</span></p>
			<p>The key question is how to identify them. In <a href="B18884_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting into Software Design Patterns</em>, we touched on the negative impact of violating the APIE and SOLID design principles; this can be a symptom that can be a signal to consider a source code refactoring response. Another<a id="_idIndexMarker579"/> phenomenon would be not respecting the <strong class="bold">CAP</strong> theorem (<strong class="bold">Consistency</strong>, <strong class="bold">Availability</strong>, and <strong class="bold">Partition tolerance</strong>). Development time may have been invested in trying to achieve all three properties at the same time, which is impossible. Such attempts could be seen as a strong signal to rethink the <span class="No-Break">development strategies.</span></p>
			<p>Although the principles of APIE and SOLID tend to be considered common knowledge, the truth is different, especially in the area of creating agile approaches and completing tasks. Development can tend to create continuous technical debt. The word <em class="italic">continuous</em> is quite important because the accumulation<a id="_idIndexMarker580"/> of such debt may lead to very <span class="No-Break">unpleasant consequences.</span></p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor487"/>Collecting technical debt as a bottleneck</h2>
			<p>Technical debt<a id="_idIndexMarker581"/> is an interesting <a id="_idIndexMarker582"/>concept because it requires the context of the software application and its goal in order to understand it. Technical debt contains some properties that may not be obvious at first glance, but may lead to a serious application bottleneck. Let’s imagine a vehicle production line as a collection of multiple processes running under various dynamics in parallel. The production line should deliver the expected result in the form of a vehicle. If there were an accumulation of bottlenecks, though, the result would not be achieved. This abstraction of a vehicle production line is quite simple, but putting it into the context of running software may be more difficult, as software relies on underlying technologies, platforms, <span class="No-Break">and hardware.</span></p>
			<p>The Java platform comes with some caveats that must be accounted for. Basically, the rule is that the developer respects the platform and the platform does its best to serve a <span class="No-Break">running software.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor488"/>Inappropriately squeezing the capabilities of the Java platform</h2>
			<p>In <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>, we touched on important topics such as types<a id="_idIndexMarker583"/> and memory models; not accounting for these may be considered an anti-pattern. As a reminder of the multi-threaded nature of the Java platform, we can mention the Java memory model, which guarantees the visibility of values to the application in a multi-threaded environment. Another thing that may turn into an anti-pattern is a garbage collection algorithm running in a separate thread alongside the main application execution thread. Because a Java application works with the final allocated memory space (the heap), the garbage collector tries to ensure that there is still an appropriate amount of heap memory available <span class="No-Break">for use.</span></p>
			<p>The acquired knowledge helps us avoid one of the most common misconceptions relating to any anti-pattern: <strong class="bold">unwanted autoboxing</strong>, or the automatic conversion performed by the compiler between primitive types and the <span class="No-Break">wrapper classes.</span></p>
			<p>The impact of autoboxing<a id="_idIndexMarker584"/> is not visible at first glance<a id="_idIndexMarker585"/> and may go unnoticed until your application faces a critical load. Let us look at aggregating sensor values, where each sensor value needs to be validated to identify an alarm. The alarm is caused, of course, by the occurrence of a critical value. The alarm system starts multiple threads in parallel to verify the delivered values (<span class="No-Break"><em class="italic">Example 7.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
record Sensor(int value) {}
class SensorAlarmWorker implements Runnable {
    ...
    @Override
    public void run() {
        ....
        while (active) {
            ..
            Collection&lt;Sensor&gt; set = provider.values();
            for (Sensor e : set) {
                SensorAlarmSystemUtil.evaluateAlarm
                  (provider, e.value(), measurementCount);}
            ...
       }
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7.1 – The SensorAlarmWorker instance attempts to identify a warning signal by reading the Sensor instance value</p>
			<p>A vehicle sensor alarm system obviously has to analyze a huge amount of data delivered by its various sensors in order to identify a critical signal. An autoboxing issue tends to be very noticeable as it causes<a id="_idIndexMarker586"/> intensive and non-deterministic garbage collection (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18884_07_01.jpg" alt="Figure 7.1 – The intensive garbage collection causes noticeable delays"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The intensive garbage collection causes noticeable delays</p>
			<p>Although the root cause of the garbage collection seems to be resolved, it may appear unexpectedly. <em class="italic">Example 7.1</em> introduces the <strong class="source-inline">Sensor</strong> record class, holding an integer value as a primitive <strong class="source-inline">int</strong> type. The problem becomes apparent when the value of the primitive type is autoboxed while passing it to the <strong class="source-inline">evaluateAlarm</strong> method, which requires the use of the <strong class="source-inline">Integer</strong> wrapper class. Let us do a one-line correction to the <strong class="source-inline">Sensor</strong> value type (<span class="No-Break"><em class="italic">Example 7.2</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
....
static void evaluateAlarm(Map&lt;Integer, Sensor&gt; storage,
    Integer criticalValue, long measurementNumber) {
...
record Sensor(Integer value) {}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7.2 – The Sensor field value is changed to the Integer type and corresponds with the method input type</p>
			<p>This change has quite a significant impact on the whole application, causing very limited occurrences of garbage collection. In other words, eliminating unwanted delays due to stop-the-world events, as we learned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">,</em> <em class="italic">Discovering the Java Platform for Design Patterns</em> (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em>), speeds up the <span class="No-Break">entire application:</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18884_07_02.jpg" alt="Figure 7.2 – Garbage collection pressure disappeared because the application didn’t create unnecessary short-living objects"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Garbage collection pressure disappeared because the application didn’t create unnecessary short-living objects</p>
			<p>Autoboxing<a id="_idIndexMarker587"/> may sometimes be identified through code reviews, which play an essential role in removing the code <span class="No-Break">smell anti-pattern.</span></p>
			<p>The Java platform<a id="_idIndexMarker588"/> contains many useful tools, and using them incorrectly can result in an unwanted state. Let’s look at some of these tools in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor489"/>Selecting the right tool</h2>
			<p>The next example<a id="_idIndexMarker589"/> may seem, at first glance, far from being a code smell. The Java platform contains very useful tools that can serve an application well if they are properly selected and used. A good example of the importance of careful selection is presented by the collection framework. <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>, reviewed different aspects of commonly used collection types. This led us to see how a wrong collection selection may result in a bottleneck due to the consumption of underlying resources. This kind of issue may not be obvious with a small data amount but emerges under bigger loads and hits very<a id="_idIndexMarker590"/> specific parts<a id="_idIndexMarker591"/> of an application. This phenomenon can be called the <strong class="bold">busy method</strong>, or <strong class="bold">hot method</strong> (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B18884_07_03.jpg" alt="Figure 7.3 – The computation time is limited by busy method execution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The computation time is limited by busy method execution</p>
			<p>Here the computation work of the application<a id="_idIndexMarker592"/> is centralized with one extremely busy method execution. <strong class="bold">Java Flight Recorder</strong> (<strong class="bold">JFR</strong>) has highlighted the issue. The fix became trivial because it rethought the use of the collection type. More specifically, it took the approach of accessing stored elements and replacing the <strong class="source-inline">O(n)</strong> time complexity for <strong class="source-inline">ArrayList</strong> with the <strong class="source-inline">O(1)</strong> time complexity for <strong class="source-inline">HashSet</strong> instances (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18884_07_04.jpg" alt="Figure 7.4 – The collection exchange leads to the desired computation work distribution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The collection exchange leads to the desired computation work distribution</p>
			<p>The correction results in bigger application throughput, which would be desirable for a vehicle data analyzer that attempts to evaluate collected data on <span class="No-Break">a journey.</span></p>
			<p>Although the code smell<a id="_idIndexMarker593"/> was not obvious, it was found because we used the right tool. Let’s summarize what we can take from the <span class="No-Break">previous sections.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor490"/>Conclusion of the code smell anti-pattern</h2>
			<p>In this chapter, we discovered that any attempt<a id="_idIndexMarker594"/> to challenge theoretical principles<a id="_idIndexMarker595"/> leads to an anti-pattern known as a <span class="No-Break">code smell.</span></p>
			<p>We reviewed a case where unknown code smells posed a threat to an application’s goals. We talked about how each bottleneck needs to be understood in its context before we try to solve it. Removing such bottlenecks without understanding the important details may result in another anti-pattern and a never-ending cycle of refactoring, as the presented examples showed (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> and <span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></p>
			<p>Another counterproductive thing to do would be optimizing the code base without solving the underlying technical debt, which may result not only in questionable application throughput degradation but also <span class="No-Break">unwanted behavior.</span></p>
			<p>Before moving on to some of the most well-known software anti-patterns, let’s make some final considerations. Any anti-pattern can be caused by a migration where technical debts have been created, including incorrect information. Their appearance may be a side effect of incorrectly selected platform tools or a lack of awareness of the theory behind the Java programming language. Since this topic can become controversial, I'll leave you to draw your <span class="No-Break">own conclusions.</span></p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor491"/>Examining typical software anti-patterns</h1>
			<p>The literature on this topic is full of different kinds<a id="_idIndexMarker596"/> of anti-patterns, some of which have very funny names, even though their impact is anything but funny. Sometimes anti-patterns can be the result of a lack of discipline in providing tested, well-structured, and maintainable<a id="_idIndexMarker597"/> code to colleagues. An often-used term today in this field is <strong class="bold">clean code</strong>. The following sections will explore some common anti-patterns that can be found in code bases, more specifically in <span class="No-Break">method<a id="_idTextAnchor492"/> implementations.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor493"/>Spaghetti code</h2>
			<p>Multiple factors may contribute<a id="_idIndexMarker598"/> to an application code base appearing<a id="_idIndexMarker599"/> very unstr<a id="_idTextAnchor494"/>ucture<a id="_idTextAnchor495"/>d: that’s the first sign of a code sm<a id="_idTextAnchor496"/>ell. In such cases, one of the most famous anti-patterns, <strong class="bold">spaghetti code</strong>, tends to appear.<a id="_idTextAnchor497"/> Spaghetti code may re<a id="_idTextAnchor498"/>main overlooked due to the fact that inte<a id="_idTextAnchor499"/>rfaces still remain coherent, but their implementation will contain long methods with interconnected dependencies (<span class="No-Break"><em class="italic">Example 7.3</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class VehicleSpaghetti {
    void drive(){
        /*
          around 100 lines of code
          heavily using the if-else construct
         */
    ...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7.3 – An unclear drive() method that contains logic for everything from engine control to b<a id="_idTextAnchor500"/>rake checks</p>
			<p>In such a state, it is nearly impossible to extend the ap<a id="_idTextAnchor501"/>plication or verify its functionality. Sometimes, such code may become legacy code, which people will then use as an excuse. Such excuses will not contribute t<a id="_idTextAnchor502"/>o the application’s success; the solution lies<a id="_idTextAnchor503"/> in refactoring and cleaning up the <span class="No-Break">code base.</span></p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor504"/>Cut and paste programming</h2>
			<p>This anti-pattern is perhaps<a id="_idIndexMarker600"/> another of the most <a id="_idIndexMarker601"/>common ones, where previously developed code is used to address the next challenge. This may seem like a smart reuse of code, but it can very quickly turn into a maintenance nightmare because the initial implementation conditions are completely ignored. This is a problem especially when the initial code was already anti-pattern-prone and ignored the principles mentioned in the previous chapters. The reuse of already-generated code should be done wisely in order to provide <span class="No-Break">good protection.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor505"/>Blob</h2>
			<p>This pattern can be identified<a id="_idIndexMarker602"/> in many older monolithic systems<a id="_idIndexMarker603"/> and applications. Nowadays, developers will claim that the problem has been overcome. The truth is not so certain. Not even frameworks are resistant to this anti-pattern. An anti-pattern can also be presented by a package that contains the most essential collection of divine classes or just one, the God class. This anti-pattern<a id="_idIndexMarker604"/> can often reside in classes called controllers, which control the entire behavior of an application. Such controllers accumulate a large number of different methods with different functionalities, meaning that the separation of concerns can end up being forgotten (<span class="No-Break"><em class="italic">Example 7.4</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class VehicleBlob {
    void drive(){}
    void initEngine(){}
    ...
    void alarmOilLevel(){}
    void runCylinder() {}
    void checkCylinderHead(){}
    void checkWaterPump(){}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7.4 – The instance of VehicleBlob attempts to control each possible part</p>
			<p>A counterargument<a id="_idIndexMarker605"/> regarding the hypothetical maintainability of the code base could be considered invalid because such code might be difficult to test, perhaps even impossible. A similar problem can occur when the singleton design pattern is improperly overused. Once the blob anti-pattern is identified, it’s a great time to start thinking about creating simple diagrams supported by refactoring the source code before it’s <span class="No-Break">too late.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor506"/>Lava flow</h2>
			<p>Clean code is sometimes used<a id="_idIndexMarker606"/> as a deep term. Nowadays, it is becoming a common practice to push<a id="_idIndexMarker607"/> a proof-of-concept application directly into production without further thought. This anti-pattern arises when incompatibility or extensibility problems start to appear. The fact that the proof of concept verified a possible solution does not guarantee that it was prepared for production according to common development principles and techniques. This anti-pattern can be identified by the occurrences of long implementation classes whose purpose has been lost over time, but everyone is afraid to remove them because it might affect the system. This anti-pattern was named after lava, a hot liquid that flows down a volcano until it catches fire. In the era of microservices, distributed systems, and cloud solutions, an example of shared functionalities, such as libraries or solutions, can be considered. When such a pattern emerges in the development process, it may be a good time to re-evaluate the design of the code base, perhaps draw some diagrams, and apply conclusions to mitigate the possibility of <span class="No-Break">a fire.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor507"/>Functional decomposition</h2>
			<p>The functional dec<a id="_idTextAnchor508"/>omposition<a id="_idIndexMarker608"/> anti-pattern may seem outdated <a id="_idIndexMarker609"/>due to the use of modern<a id="_idTextAnchor509"/> frameworks and the fact that the anti-pattern is better known in the field of procedural languages. The reality may be slightly different, as many legacy systems were migrated without sufficient understanding of the code base and bu<a id="_idTextAnchor510"/>siness logic. Identifying the anti-pattern is trivial, as it’s impossible not to notice a code base containing many classes with a single responsibility, a<a id="_idTextAnchor511"/> lack of abstraction, and big cohesion. The ro<a id="_idTextAnchor512"/>ot cause of th<a id="_idTextAnchor513"/>is <a id="_idTextAnchor514"/>anti-pattern may be a<a id="_idTextAnchor515"/> lack of understanding of the basic principles of obj<a id="_idTextAnchor516"/>ect-oriented programming or a misunderstanding of the application’s goal. The solution is to refactor the code base according to the required abstraction level whil<a id="_idTextAnchor517"/>e keeping i<a id="_idTextAnchor518"/><a id="_idTextAnchor519"/><a id="_idTextAnchor520"/>n mind <span class="No-Break">programming principles.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor521"/>Boat anchor</h2>
			<p>Sometimes an application<a id="_idIndexMarker610"/> or a newly developed piece of software<a id="_idIndexMarker611"/> may inherit an outdated abstraction that becomes unnecessary. This abstraction can turn into a bottleneck not only because it requires maintenance but also because it can easily be replicated widely across a code base. The worst case can be the large utilization of this abstraction inside shared libraries or application modules. The anti-pattern can accelerate the degradation of the application code base at <span class="No-Break">various levels.</span></p>
			<p>One easy way to mitigate this is to keep in mind the SOLID design and APIE principles to allow for continuous refactoring. This enables<a id="_idIndexMarker612"/> the utilization of previously<a id="_idIndexMarker613"/> learned <span class="No-Break">design patterns.</span></p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor522"/>Conclusion</h2>
			<p>Being able to identify and describe some of the most common deviations from well-known principles and approaches brings value to any project. In this subsection, we have examined anti-patterns and proposed solutions to keep your code base maintainable and readable. The last point we want to make in this section is about the proper naming of methods, fields, and classes, which can significantly improve readability and maintainability and limit the misunderstanding of API use. Proper naming is also important as it allows a good understanding of UML diagrams. The next section takes us more into source <span class="No-Break">code architecture.</span></p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor523"/>Understanding software architecture anti-patterns</h1>
			<p>A clear understanding<a id="_idIndexMarker614"/> of classes, packages, and module composition can be seen as essential not only to the application itself, but, as we learned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>, to the platform as well. Thanks to the dynamic translation of the bytec<a id="_idTextAnchor524"/>ode that the JIT compiler pro<a id="_idTextAnchor525"/>cesses, the Java platform collects essential information about its optimization. Poor code quality and software architecture can cause latency, improper memory usage, or crashes. Let’s understand the <span class="No-Break">possible obstacles.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor526"/>Golden hammer</h2>
			<p>One proven approach<a id="_idIndexMarker615"/> applied over a period of time<a id="_idIndexMarker616"/> without exploration of alternatives can easily turn into legacy code. The fact that it is difficult to accept other proposals or migration may be due to a particular set of approaches, otherwise known as the golden hammer anti-pattern, where developers believe that there is no need to investigate whether changes to something would be beneficial when it has been working fine for several years. A great example would be a vendor-specific database or tool, and the problem arises when the application needs to migrate to microservices or a more <span class="No-Break">distributed design.</span></p>
			<p>Scalabil<a id="_idTextAnchor527"/>ity is penalized not only by the CAP theorem, as mentioned earlier, but may also suffer due to almost impossible usage across designed modules or <span class="No-Break">application parts.</span></p>
			<p>Using a particular vendor’s product in your application architecture is not necessarily an issue. The challenge is that the development of the application relies entirely on the capabilities and functions provided by the vendor without evaluating its <span class="No-Break">own capabilities.</span></p>
			<p>A possible solution<a id="_idIndexMarker617"/> could be to re-evaluate current development<a id="_idIndexMarker618"/> approaches and allow for improvement through effective research <span class="No-Break">of solutions.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor528"/>Continuous obsolescence</h2>
			<p>Improvements are inevitable. Today, products<a id="_idIndexMarker619"/> can take advantage of automated deployment or continuous integration support<a id="_idIndexMarker620"/> with a variety of different test scenarios. The rate of improvement is increasing rapidly. A good example is the Java platform, which recently reduced its release cadence to 6 months. This fact can contribute to the emergence of an anti-pattern, since refactoring is required, but on the other hand, it has a great effect on removing <span class="No-Break">previous shortcomings.</span></p>
			<p>The continuous obsolescence anti-pattern can be easily identified by an inability to move a project to the next phase using continuous integration and delivery (<span class="No-Break"><em class="italic">Example 7.5</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
interface VehicleCO {
    void checkEngine();
    void initSystem();
    void initRadio(); /* never used */
    void initCassettePlayer(); /* never used */
    void initMediaSystem(); /* actual logic */
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 7.5 – The VehicleCO abstraction contains outdated methods that still need to be tested</p>
			<p>Of course, the concepts of continuous delivery and integration do not give any guarantee of code base clarity<a id="_idIndexMarker621"/> as they need to be followed<a id="_idIndexMarker622"/> by development discipline. Continuous clean-code-focused reviews, object-oriented principles, and proper patterns can drastically reduce the incidence of continuous obsolescence and have a major impact on the entire <span class="No-Break">application architecture.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor529"/>Input kludge</h2>
			<p>It may not necessarily<a id="_idTextAnchor530"/> be obvious<a id="_idIndexMarker623"/> at first glance, but the input kludge anti-pattern<a id="_idIndexMarker624"/> is quite common. A good example would be several connected services that were tested until one bega<a id="_idTextAnchor531"/>n to deviate from its functionality. A quick ad hoc solution has more side effects that are recognized with a long delay due to disabled tests. Various services already had more patches applied than others, so even more tests were disabled. The fact remains that those disabled tests were critical to maintaining <span class="No-Break">application integrity.</span></p>
			<p>The solution might be to maintain discipline in testing and ensure that test inputs and outputs are valid and updated, rather than turning off <span class="No-Break">essential tests.</span></p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor532"/>Working in a minefield</h2>
			<p>Gone are the days of completely<a id="_idIndexMarker625"/> monolithic applications. The current distributed nature of applications creates an expectation for application testing to achieve continuous delivery and refactoring. Although an application might contain tests for known issues, full integrity cannot be ensured. What happens if some enhancements are made to an application but they aren't tested? Even a very small contribution to the code base can turn into a nightmare – working with such code bases can feel like being in a minefield. The solution to the problem is quite obvious: refactoring is required. Isolate the affected part with simplified tests to gain stability, apply all the knowledge learned,<a id="_idTextAnchor533"/> and slowly continue expanding the<a id="_idTextAnchor534"/> <span class="No-Break">test base.</span></p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor535"/>Ambiguous viewpoint</h2>
			<p>In the era of microservices <a id="_idIndexMarker626"/>and distributed system design approaches, this anti-pattern may significantly damage the final result. The continued presence of this anti-pattern can result in an onion architecture approach where the separation of concerns and other SOLID principles become theory rather than practice. One indicator of this anti-pattern would be the creation of unclear services followed by entities for passing redundant information between layers, making the general architecture unclear. It can be recognized in its early stages as the presented design models do not support any principles of SOLID application desig<a id="_idTextAnchor536"/>n due to incomplete information or unclear and overlapping pe<a id="_idTextAnchor537"/>rspectives in the model a<a id="_idTextAnchor538"/>nd potential software design. The solution may be effectively executed by the use of a mod<a id="_idTextAnchor539"/>eling technique, such as UML, to ensure visual clarity and source <span class="No-Break">code transparency.</span></p>
			<h2 id="_idParaDest-326"><a id="_idTextAnchor540"/>Poltergeists</h2>
			<p>This anti-pattern<a id="_idIndexMarker627"/> cannot be fully ignored. It can be recognized<a id="_idTextAnchor541"/> if you<a id="_idIndexMarker628"/> can spot features that are not expected but suddenly appear and disappear. This anti-pattern is the result of very complex abstractions and the im<a id="_idTextAnchor542"/>plementation of unnecessary classes. There are a couple of frameworks on the Java platform that can provide useless functionality. We can consider AspectJ and AOP as good examples as their usage may be directly responsible<a id="_idTextAnchor543"/> for mysterious side effects. The<a id="_idTextAnchor544"/><a id="_idTextAnchor545"/> solution is to revisit a<a id="_idTextAnchor546"/>nd understand the class hierarchy and <span class="No-Break">life cycles.</span></p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor547"/>Dead end</h2>
			<p>The growth<a id="_idIndexMarker629"/> of the IT industry seems<a id="_idIndexMarker630"/> to be unstoppable, as more and more approaches and procedures for technical improvements emerge. As such, dependencies on non-updated components that were previously built into a system’s architecture can be detrimental and may be more difficult to remove than you might expect. Take, for example, Java version migrations, where staying with the old version is penalized not only by losing support but also by increasing maintenance costs. Trying to scale an application can also result in many challeng<a id="_idTextAnchor548"/>es to do with <span class="No-Break">application testability.</span></p>
			<p>Even though this dead-end anti-pattern can be turned into an accepted software design, it is recommended to consider<a id="_idIndexMarker631"/> alternatives, because<a id="_idIndexMarker632"/> doing so may come with <span class="No-Break">significant costs.</span></p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor549"/>Conclusion</h2>
			<p>Not all of the anti-patterns listed are completely bad (see the golden hammer or dead end, for example), but generally, any anti-pattern should be re-evaluated before it is accepted <span class="No-Break">and documented.</span></p>
			<p>Java is a very powerful language and platform, not only because it allows using instance mutation, but also because it enables entities to hold their state and remain immutable. Special attention should be paid to the state of the code base in the case of concurrent applications, because such applications must be transparent not only to software engineers but also to the Java platform, as we learned in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for Design Patterns</em>. A concurrent environment brings many possibilities and performance improvements on the one hand, but on the other hand, it can cause the misuse of certain design patterns, such as the double-checked locking pattern, thanks to a poor understanding of the platform (rather than the framework that uses <span class="No-Break">the platform).</span></p>
			<p>A lack of test coverage, code writing discipline, information, or capability can also contribute significantly to the occurrence of anti-patterns. From a code base architecture perspective, verifying a correctly implemented function can become an impossible task or cause additional complications for mocking or debugging. Generally speaking, a transparent code architecture is one of the keys to a successful application. Let’s recap everything <span class="No-Break">we’ve learned.</span></p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor550"/>Summary</h1>
			<p>Knowing about anti-patterns and their identification can have a big impact on the viability of an application, especially when it comes to distributed systems. This chapter has shown that not knowing the Java platform and its tools well enough can lead to unexpected results, such as intense pressure on garbage collection algorithms running on side threads and missing out on optimization opportunities. Realizing the multi-threaded nature of the Java platform can lead to proper code composition, but also to proper use of immutability to enable continuous application development, that <span class="No-Break">is, refactoring.</span></p>
			<p>Since most anti-patterns have a lack of testing as one of their root causes, a test environment might be the best starting place to determine the occurrence of anti-patterns or the need for refactoring. Compiled test code does not reside in deployed code, which makes test code the best place to start for future exploration and understanding your <span class="No-Break">application’s behavior.</span></p>
			<p>The Java platform and other used libraries change rapidly, and one of the keys to maintaining an application code base is the correct use of the open-close principle. It enables continuous refactoring, which is essential for the evolution of a healthy <span class="No-Break">code base.</span></p>
			<p>Anti-patterns are part of the application life cycle. They are present and can remain present in various forms for the sake of progress. It may not be worth the effort to remove them entirely; perhaps a better approach would be to understand them and get the code base to the desired state with known limitations being addressed on an ongoing basis. Improvements will be made throughout the entire development cycle of the application, and writing code will become a pleasant experience with many <span class="No-Break">challenges solved.</span></p>
			<p>While the Java platform still has challenges, it remains a beautiful piece of software that uses mathematics, statistics, and probability science all <span class="No-Break">at once!</span></p>
			<p>Congratulations on successfully reaching the end of this book. Because every ending brings a new beginning, I encourage you to stay inspired and hungry and to have a lot of fun with coding or designing software! Keep your mind open and make it a source of <span class="No-Break">valuable information.</span></p>
			<p>Sincerely, <span class="No-Break">Miro Wengner!</span></p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor551"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <span class="No-Break">Addison-Wesley, 1995</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, Object <span class="No-Break">Mentor, 2000</span></li>
				<li><em class="italic">AntiPatterns: Refactoring Software, Architectures, and Project in Crisis</em> by William J. Brown, Raphael C. Malveau, Hays W. McCormick III, and Thomas J. Mowbray, John Wiley &amp; Sons, <span class="No-Break">Inc, 1998</span></li>
				<li><em class="italic">CAP Twelve Years Later: How the “Rules” Have Changed</em>, <a href="https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed"><span class="No-Break">https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed</span></a><span class="No-Break">, 2012</span></li>
				<li><em class="italic">Phoenix Project: A Novel About IT, DevOps, and Helping Your Business Win</em> by Gene Kim, Kevin Behr, and George Spafford, IT Revolution <span class="No-Break">Press, 2016</span></li>
				<li><em class="italic">How do Committees Invent?</em> by Melvin Edward Conway, Datamation 14, site 5, pages <span class="No-Break">28-31, 1968</span></li>
				<li><em class="italic">Mission Control </em><span class="No-Break"><em class="italic">Project</em></span><span class="No-Break">, </span><a href="https://github.com/openjdk/jmc"><span class="No-Break">https://github.com/openjdk/jmc</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer104">
			<h1 id="_idParaDest-331"><a id="_idTextAnchor552"/>Assessments</h1>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor553"/>Chapter 1 – Getting into Software Design Patterns</h1>
			<ol>
				<li>The compiler compiles Java code into bytecode, which is executed by the JVM and JRE, respectively (refer to <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">).</span></li>
				<li>It refers to abstraction, polymorphism, inheritance, <span class="No-Break">and encapsulation.</span></li>
				<li>Method overriding and <span class="No-Break">method overloading.</span></li>
				<li>SOLID principles: The single-responsibility principle, open-closed principle, Liskov substitution principle, interface segregation principle, and dependency <span class="No-Break">inversion principle.</span></li>
				<li>The program should be open for extension and closed <span class="No-Break">for modification.</span></li>
				<li>Design patterns represent the collection of commonly used problems and solutions to produce <span class="No-Break">maintainable software.</span></li>
			</ol>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor554"/>Chapter 2 – Discovering the Java Platform for Design Patterns</h1>
			<ol>
				<li value="1">The <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), <strong class="bold">Java Runtime Environment</strong> (<strong class="bold">JRE</strong>), and <strong class="bold">Java Development </strong><span class="No-Break"><strong class="bold">Kit</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JDK</strong></span><span class="No-Break">).</span></li>
				<li>Java is a statically typed language, which means any value needs to be declared before it can be assigned to <span class="No-Break">the value.</span></li>
				<li>3. Primitive types: <strong class="source-inline">boolean</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">char</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">long</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">double</strong></span><span class="No-Break">.</span></li>
				<li><span class="No-Break">Garbage collector.</span></li>
				<li><strong class="source-inline">Queue</strong>, <strong class="source-inline">Set</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">.</span></li>
				<li><span class="No-Break">Key-value pairs.</span></li>
				<li>In <span class="No-Break">O-notation O(1).</span></li>
				<li>In <span class="No-Break">O-notation O(n).</span></li>
				<li><strong class="source-inline">Predicate&lt;T&gt;</strong>, the return type is a primitive <span class="No-Break">type, </span><span class="No-Break"><strong class="source-inline">boolean</strong></span><span class="No-Break">.</span></li>
				<li>Element streams in the Java Stream API are <span class="No-Break">lazily evaluated.</span></li>
			</ol>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor555"/>Chapter 3 – Working with Creational Design Patterns</h1>
			<ol>
				<li value="1">Creational design patterns help abstract the object instantiation process by delegating it to the responsible part of <span class="No-Break">the application.</span></li>
				<li>2. To reduce new object creation costs, the dependency injection, lazy initiation, and object pool patterns may be taken <span class="No-Break">into consideration.</span></li>
				<li>Only one instance is required to be present <span class="No-Break">in JVM.</span></li>
				<li>The builder pattern helps create configurations of a similar object type while reducing the number <span class="No-Break">of constructors.</span></li>
				<li>The factory method or abstract factory patterns should be considered, as both can compose complex objects without exposing the logic to <span class="No-Break">the clients.</span></li>
				<li>The object pool design pattern introduces a cache of already created and reusable objects instead of allocating and destroying <span class="No-Break">new instances.</span></li>
				<li>The most useful pattern for creating objects of a specific family is the factory <span class="No-Break">method pattern.</span></li>
			</ol>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor556"/>Chapter 4 – Applying Structural Design Patterns</h1>
			<ol>
				<li value="1">1. Structural design patterns define communication between objects. These patterns support implementation flexibility <span class="No-Break">and transparency.</span></li>
				<li>The structural design patterns described by the GoF author group are the adapter, bridge, composite, proxy, flyweight, facade, and <span class="No-Break">decorator patterns.</span></li>
				<li>The composite structural design pattern, which also guarantees uniform <span class="No-Break">object handling.</span></li>
				<li>The marker pattern, with full awareness of <span class="No-Break">its drawbacks.</span></li>
				<li>The proxy pattern needs to be taken into account because the adapter and facade patterns have slightly <span class="No-Break">different purposes.</span></li>
				<li>The <span class="No-Break">bridge pattern.</span></li>
			</ol>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor557"/>Chapter 5 – Behavioral Design Patterns</h1>
			<ol>
				<li value="1">The Liskov substitution principle explored in <a href="B18884_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting into Software </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></li>
				<li>The <span class="No-Break">iterator pattern.</span></li>
				<li>Yes – the <span class="No-Break">strategy pattern.</span></li>
				<li>It is the null object pattern, which provides the type of such a state and limits the causes of null <span class="No-Break">pointer exceptions.</span></li>
				<li>This can be the pipeline pattern, the strategy pattern for the <strong class="source-inline">map()</strong> and <strong class="source-inline">filter()</strong> methods, or the null <span class="No-Break">object pattern.</span></li>
				<li>All clients can be alerted by employing the observer pattern, which also transparently <span class="No-Break">controls conditions.</span></li>
				<li>The command pattern can be used. A command is represented by a unique object. An object allows a client to pass parameters and can easily call a <span class="No-Break">callback function.</span></li>
			</ol>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor558"/>Chapter 6 – Concurrency Design Patterns</h1>
			<ol>
				<li value="1">The challenge solved by the double-checked singleton pattern is ensuring that only one class instance is present in the running JVM to avoid <span class="No-Break">possible leaks</span></li>
				<li>The usage of the <strong class="source-inline">Executors</strong> utility that resides in the <strong class="source-inline">java.base</strong> module and <span class="No-Break"><strong class="source-inline">java.util.concurrent</strong></span><span class="No-Break"> package</span></li>
				<li>The balking pattern depends on the <span class="No-Break">instance stat</span></li>
				<li>The <span class="No-Break">scheduler pattern</span></li>
				<li>The producer-consumer pattern is one of the most common concurrent design patterns, with clearly separated and <span class="No-Break">addressed logic</span></li>
			</ol>
		</div>
	</body></html>