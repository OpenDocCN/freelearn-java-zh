<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Test Doubles"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Test Doubles</h1></div></div></div><p class="calibre9">This chapter covers the concept of test doubles and explains various test double types, such as mock, fake, dummy, stub, and spy. Sometimes, it is not possible to unit test a piece of code because of unavailability of collaborator objects or the cost of instantiation for the collaborator. Test doubles alleviate the need for a collaborator.</p><p class="calibre9">We know about stunt doubles—a trained replacement used for dangerous action sequences in movies, such as jumping out of the Empire State building, a fight sequence on top of a burning train, jumping from an airplane, or similar actions. Stunt doubles are used to protect the real actors or chip in when the actor is not available.</p><p class="calibre9">While testing a class that communicates with an API, you don't want to hit the API for every single test; for example, when a piece of code is dependent on database access, it is not possible to unit test the code unless the database is accessible. Similarly, while testing a class that communicates with a payment gateway, you can't submit payments to a real payment gateway to run tests.</p><p class="calibre9">Test doubles act as stunt doubles. They are<a id="id308" class="calibre1"/> skilled replacements for collaborator objects. Gerard Meszaros coined the term test doubles and explained test doubles in his book <span class="strong"><em class="calibre11">xUnit Test Patterns</em></span>, <span class="strong"><em class="calibre11">Pearson Education</em></span>.</p><p class="calibre9">Test doubles are<a id="id309" class="calibre1"/> categorized into five types. The following diagram shows these types:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Test Doubles" class="calibre12"/></div><p class="calibre13"> </p></div>

<div class="book" title="Chapter&#xA0;3.&#xA0;Test Doubles">
<div class="book" title="Dummy"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec16" class="calibre1"/>Dummy</h1></div></div></div><p class="calibre9">An example of a dummy would be a movie scene where the double doesn't perform anything but is only present <a id="id310" class="calibre1"/>on the screen. They are used when the actual actor is not present, but their presence is needed for a scene, such as watching the tennis<a id="id311" class="calibre1"/> finale of a US Open match.</p><p class="calibre9">Similarly, dummy objects are passed to avoid <code class="literal">NullPointerException</code> for mandatory parameter objects as follows:</p><div class="informalexample"><pre class="programlisting">Book javaBook = new Book("Java 101", "123456");
<span class="strong"><strong class="calibre10">Member dummyMember = new DummyMember());</strong></span>
javaBook.issueTo(<span class="strong"><strong class="calibre10">dummyMember</strong></span>);
assertEquals(javaBook.numberOfTimesIssued(),1);</pre></div><p class="calibre9">In the preceding code snippet, a dummy member was created and passed to a book object to test whether a book can report the number of times it was issued. Here, a member object is not used anywhere but it's needed to issue a book.</p></div></div>
<div class="book" title="Stub"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec17" class="calibre1"/>Stub</h1></div></div></div><p class="calibre9">A stub delivers indirect inputs to the caller when the stub's methods are called. Stubs are programmed only for<a id="id312" class="calibre1"/> the test scope. Stubs may record other information such as the number of times the methods were invoked and so on.</p><p class="calibre9">Account transactions should be rolled back if the ATM's money dispenser fails to dispense money. How can we test this when we don't have the ATM machine, or how can we simulate a scenario where the dispenser fails? We can do this using the following code:</p><div class="informalexample"><pre class="programlisting">public interface Dispenser {
  void dispense(BigDecimal amount) throws DispenserFailed;
}
public class AlwaysFailingDispenserStub implements Dispenser{
  public void dispense(BigDecimal amount) throws DispenserFailed{
    throw new DispenserFailed (ErrorType.HARDWARE,"not  responding");
  }
}
class <span class="strong"><strong class="calibre10">ATMTest</strong></span>...
  @Test
  public void transaction_is_rolledback_when_hardware_fails() {
    Account myAccount = new Account("John", 2000.00);
    TransactionManager txMgr = TransactionManager.forAccount(myAccount);
    txMgr.registerMoneyDispenser(new AlwaysFailingDispenserStub());
    WithdrawalResponse response = txMgr.withdraw(500.00);
    assertEquals(false, response.wasSuccess());
    assertEquals(2000.00, myAccount.remainingAmount());
  }</pre></div><p class="calibre9">In the preceding code, <code class="literal">AlwaysFailingDispenserStub</code> raises an error whenever the <code class="literal">dispense()</code> method is invoked. It allows<a id="id313" class="calibre1"/> us to test the transactional behavior when the hardware is not present.</p><p class="calibre9">Mockito allows us to mock<a id="id314" class="calibre1"/> interfaces and concrete classes. Using Mockito, you can stub the <code class="literal">dispense()</code> method to throw an exception.</p></div>
<div class="book" title="Fake"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Fake</h1></div></div></div><p class="calibre9">Fake objects are working implementations; mostly, the fake class extends the original class, but it usually <a id="id315" class="calibre1"/>hacks the performance, which makes it unsuitable for production. The following <a id="id316" class="calibre1"/>example demonstrates the fake object:</p><div class="informalexample"><pre class="programlisting">public class AddressDao extends SimpleJdbcDaoSupport{

  public void batchInsertOrUpdate(List&lt;AddressDTO&gt; addressList, User user){
    List&lt;AddressDTO&gt; insertList = buildListWhereLastChangeTimeMissing(addressList);

    List&lt;AddressDTO&gt; updateList = buildListWhereLastChangeTimeValued(addressList);
    int rowCount =  0;

    if (!insertList.isEmpty()) {
      rowCount = getSimpleJdbcTemplate().batchUpdate(INSERT_SQL,…);
    }

    if (!updateList.isEmpty()){
      rowCount += getSimpleJdbcTemplate().batchUpdate(UPDATE_SQL,…);
    }

    if (addressList.size() != rowCount){
      raiseErrorForDataInconsistency(…); 
    }
}</pre></div><p class="calibre9">
<code class="literal">AddressDAO</code> extends from a Spring framework class and provides an API for mass update. The same method is used to create a <a id="id317" class="calibre1"/>new address and update an existing one; if the count doesn't match, then an error is raised. This class cannot be tested directly, and it needs <code class="literal">getSimpleJdbcTemplate()</code>. So, to test this class, we need to bypass the JDBC collaborator; we can do this by extending the original DAO class but by<a id="id318" class="calibre1"/> overriding the collaborator method. The following <code class="literal">FakeAddressDao</code> class is a fake implementation of <code class="literal">AddressDao</code>:</p><div class="informalexample"><pre class="programlisting">public class FakeAddressDao extends AddressDao{
  <span class="strong"><strong class="calibre10">@Override</strong></span>
  public SimpleJdbcTemplate getSimpleJdbcTemplate() {
    return jdbcTemplate;
  } 
}</pre></div><p class="calibre9">
<code class="literal">FakeAddressDao</code> extends <code class="literal">AddressDao</code> but only overrides <code class="literal">getSimpleJdbcTemplate()</code> and returns a JDBC template stub. We can use Mockito to create a mock version of the <code class="literal">JdbcTemplate</code> and return it from the fake implementation. This class cannot be used in production as it uses a mock <code class="literal">JdbcTemplate</code>; however, the fake class inherits all functionalities of the DAO, so this can be used for testing. The fake classes are very useful for legacy code.</p></div>
<div class="book" title="Mock"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Mock</h1></div></div></div><p class="calibre9">Mock objects have expectations; a test expects a value from a mock object, and during execution, a mock object<a id="id319" class="calibre1"/> returns the expected result. Also, mock objects can keep track of the invocation count, that is, the number of times a method on a mock object is invoked.</p><p class="calibre9">The following <a id="id320" class="calibre1"/>example is a continuation of the ATM example with a mock version. In the previous example, we stubbed the dispense method of the <code class="literal">Dispenser</code> interface to throw an exception; here, we'll use a mock object to replicate the same behavior. We'll explain the syntax in <a class="calibre1" title="Chapter 4. Progressive Mockito" href="part0027_split_000.html#page">Chapter 4</a>, <span class="strong"><em class="calibre11">Progressive Mockito</em></span>.</p><div class="informalexample"><pre class="programlisting">public class ATMTest {
  @Mock Dispenser failingDispenser;

  @Before  public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
  }

  @Test  public void transaction_is_rolledback_when_hardware_fails() throws DispenserFailed {
    Account myAccount = new Account(2000.00, "John");
    TransactionManager txMgr = TransactionManager.forAccount(myAccount);
    txMgr.registerMoneyDispenser(failingDispenser);
     
    doThrow(new  DispenserFailed()).when(failingDispenser).dispense(isA(BigDecimal.class));
    
    txMgr.withdraw(500);
      assertEquals(2000.00, myAccount.getRemainingBalance());

    verify(failingDispenser, new Times(1)).dispense(isA(BigDecimal.class));
}
}</pre></div><p class="calibre9">The preceding code is the mock (Mockito) version of the ATM test. The same object can be used in <a id="id321" class="calibre1"/>different tests; just the<a id="id322" class="calibre1"/> expectation needs to be set. Here, <code class="literal">doThrow()</code> raises an error whenever the mock object is called with any <code class="literal">BigDecimal</code> value.</p></div>
<div class="book" title="Spy"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Spy</h1></div></div></div><p class="calibre9">Spy is a variation of a mock/stub, but instead <a id="id323" class="calibre1"/>of only setting <a id="id324" class="calibre1"/>expectations, spy records the calls made to the collaborator. The following example explains this concept:</p><div class="informalexample"><pre class="programlisting">class ResourceAdapter{  
  void print(String userId, String document, Object settings) {
    if(securityService.canAccess("lanPrinter1", userId)) {
      printer.print(document, settings);
    }
  }
}</pre></div><p class="calibre9">To test the <code class="literal">print</code> behavior of the <code class="literal">ResourceAdapter</code> class, we need to know whether the <code class="literal">printer.print()</code> method gets invoked when a user has permissions. Here, the <code class="literal">printer</code> collaborator doesn't do anything; it is just used to verify the <code class="literal">ResourceAdapter</code> behavior.</p><p class="calibre9">Now, consider the following code:</p><div class="informalexample"><pre class="programlisting">class SpyPrinter implements Printer{
  private int noOfTimescalled = 0;
   @Override
  public void print(Object document, Object settings) {
    <span class="strong"><strong class="calibre10">noOfTimescalled++;</strong></span>
  }
  public int getInvocationCount() {
    return noOfTimescalled;
  }
}</pre></div><p class="calibre9">
<code class="literal">SpyPrinter</code> implements the <code class="literal">Printer.print()</code> call, increments a <code class="literal">noOfTimescalled</code> counter, and <code class="literal">getInvocationCount</code> returns<a id="id325" class="calibre1"/> the count. Create a fake<a id="id326" class="calibre1"/> implementation of the <code class="literal">SecurityService</code> class to return <code class="literal">true</code> from the <code class="literal">canAccess(String printerName, String userId)</code> method. The following is the fake implementation of the <code class="literal">SecurityService</code> class:</p><div class="informalexample"><pre class="programlisting">class FakeSecurityService implements SecurityService{
  public boolean canAccess(String printerName, String userId){
    return true;
  }
}</pre></div><p class="calibre9">The following code snippet verifies the <code class="literal">print</code> behavior of the <code class="literal">ResourceAdapter</code> class:</p><div class="informalexample"><pre class="programlisting">@Test public void verify() throws Exception {
  <span class="strong"><strong class="calibre10">SpyPrinter spyPrinter = new SpyPrinter();</strong></span>
  adapter = new ResourceAdapter(<span class="strong"><strong class="calibre10">new FakeSecurityService(), spyPrinter</strong></span>);
  adapter.print("john", "helloWorld.txt", "all pages");
  <span class="strong"><strong class="calibre10">assertEquals(1, spyPrinter.getInvocationCount());</strong></span>
}</pre></div><p class="calibre9">Fake <code class="literal">SecurityService</code> and a <code class="literal">SpyPrinter</code> objects are created and passed to the <code class="literal">ResourceAdapter</code> class and then <code class="literal">adapter.print</code> is called. In turn, it is expected that the <code class="literal">securityService</code> object will return <code class="literal">true</code> and the printer will be accessed, and <code class="literal">spyPrinter.print(…)</code> will increment the <code class="literal">noOfTimescalled</code> counter. Finally, in the preceding code, we verified that the count is 1.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec21" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">This chapter provided an overview of test doubles with examples. The following topics covered dummy, stub, mock, fake, and spy. This chapter is a prerequisite for Mockito.</p><p class="calibre9">The next chapter will cover the Mockito framework and its advanced uses. Mockito is a mocking framework for Java. It provides the API for mock, spy, and stub creation.</p></div></body></html>