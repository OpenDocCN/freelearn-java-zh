<html><head></head><body>
  <div id="_idContainer235" class="Basic-Text-Frame">
    <h1 class="chapterNumber">8</h1>
    <h1 id="_idParaDest-378" class="chapterTitle">Sealed and Hidden Classes</h1>
    <p class="normal">This chapter includes 13 problems covering sealed and hidden classes. The first 11 recipes will cover sealed classes, a very cool feature introduced in JDK 17 (JEP 409) to sustain <em class="italic">closed hierarchies</em>. The last two problems cover hidden classes, a JDK 15 (JEP 371) feature that allows frameworks to create and use runtime (dynamic) classes hidden in the JVM’s internal linkages of bytecode, and to the explicit usage of class loaders.</p>
    <p class="normal">You’ll be skilled in both topics by the end of this chapter.</p>
    <h1 id="_idParaDest-379" class="heading-1">Problems</h1>
    <p class="normal">Use the following <a id="_idIndexMarker951"/>problems to test your programming prowess in manipulating sealed classes and hidden classes in Java. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="172"><strong class="keyWord">Creating an electrical panel (hierarchy of classes)</strong>: Write the stub of a Java application that shapes an electrical panel. You can assume that the electrical panel is made of several types of electrical components (for instance, resistors, transistors, and so on), and electrical circuits (for instance, parallel circuits, series circuits, and so on).</li>
      <li class="numberedList"><strong class="keyWord">Closing the electrical panel before JDK 17</strong>: Use the Java features (for instance, the <code class="inlineCode">final</code> keyword and <em class="italic">package-private</em> hacks) to close this hierarchy (close to extension).</li>
      <li class="numberedList"><strong class="keyWord">Introducing JDK 17 sealed classes</strong>: Provide a brief introduction to JDK 17 sealed classes. Exemplify how to write closed hierarchies in a single source file via sealed classes.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the permits clause</strong>: Explain and exemplify the role of the <code class="inlineCode">permits</code> clause in sealed classes. Exemplify sealed classes in different source files (same package) and in different packages.</li>
      <li class="numberedList"><strong class="keyWord">Closing the electrical panel after JDK 17</strong>: Use sealed classes to completely close the electrical panel hierarchy developed in problems 172 and 173.</li>
      <li class="numberedList"><strong class="keyWord">Combining sealed classes and records</strong>: Exemplify the usage of Java records in combination with sealed classes.</li>
      <li class="numberedList"><strong class="keyWord">Hooking sealed classes and instanceof</strong>: Write an application that highlights how sealed classes help the compiler to better handle the <code class="inlineCode">instanceof</code> operator.</li>
      <li class="numberedList"><strong class="keyWord">Hooking sealed classes in switch</strong>: Write an application that exemplifies how sealed classes help the compiler to sustain exhaustive switch expressions/statements.</li>
      <li class="numberedList"><strong class="keyWord">Reinterpreting the Visitor pattern via sealed classes and type pattern matching for switch</strong>: Provide a quick sample of the traditional Visitor pattern implementation and transform it via sealed classes into simpler and more accessible code.</li>
      <li class="numberedList"><strong class="keyWord">Getting info about sealed classes (using reflection)</strong>: Explain and exemplify how we can access sealed classes via Java Reflection.</li>
      <li class="numberedList"><strong class="keyWord">Listing the top three benefits of sealed classes</strong>: Provide what you think are the top three benefits of sealed classes with a few explanations and arguments.</li>
      <li class="numberedList"><strong class="keyWord">Briefly introducing hidden classes</strong>: Provide a brief, crystal-clear, and meaningful explanation of hidden classes. List their main characteristics.</li>
      <li class="numberedList"><strong class="keyWord">Creating a hidden class</strong>: Provide a regular example of creating and using a hidden class.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter08</span></a>.</p>
    <h1 id="_idParaDest-380" class="heading-1">172. Creating an electrical panel (hierarchy of classes)</h1>
    <p class="normal">Let’s assume <a id="_idIndexMarker952"/>that we want to model in code lines an electrical panel. Of course, we are not electricians, so for our purposes, an electric panel means a box with some internal circuits made of electrical components and a breaker that turns on/off the electrical panel.</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_01.png" alt="Figure 8.1.png"/></figure>
    <p class="packt_figref">Figure 8.1: Electrical panel components</p>
    <p class="normal">Everything in an electrical panel can be considered an electrical component, so we can start our code by defining an interface that must be implemented by everything in this panel:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">Before <a id="_idIndexMarker953"/>continuing, let’s look at a diagram of the electric panel interfaces and classes that will help you to follow what comes after more easily:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_02.png" alt="Figure 8.2.png"/></figure>
    <p class="packt_figref">Figure 8.2: A model of the electrical panel</p>
    <p class="normal">An electrical panel consists of more electrical circuits that interact (or do not interact) with each other. We can represent such a circuit via an <code class="inlineCode">abstract</code> class as follows (this acts as a base class for its subclasses):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricCircuit</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span>;
}
</code></pre>
    <p class="normal">Let’s assume that our electrical panel is made of three types of circuits. We have short circuits, series circuits, and parallel circuits. So, we can define the proper class for each type of circuit <a id="_idIndexMarker954"/>by extending the <code class="inlineCode">abstract ElectricCircuit</code> (we’ll show here only the <code class="inlineCode">ShortCircuit</code>, while the <code class="inlineCode">ParallelCircuit</code> and <code class="inlineCode">SeriesCircuit</code> are available in the bundled code):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShortCircuit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricCircuit</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-title">ShortCircuit</span><span class="hljs-params">(ElectricComponent... comp)</span> {}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> {}
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> {}
}
</code></pre>
    <p class="normal">Check out the constructor of the <code class="inlineCode">ShortCircuit</code> class. It gets a <code class="inlineCode">varargs</code> argument of the type <code class="inlineCode">ElectricComponent</code>. This means that we can build a bigger circuit from smaller circuits and other components such as capacitors, transistors, resistors, and so on. Each such electrical component can be shaped via an <code class="inlineCode">abstract</code> class. For instance, a capacitor is a base class that can be expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Capacitor</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">We need two types of capacitors (ceramic capacitors and electrolytic capacitors). A ceramic capacitor can be shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CeramicCapacitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Capacitor</span> {}
</code></pre>
    <p class="normal">Following the same logic, we can express other electrical components such as transistors (<code class="inlineCode">Transistor</code> (<code class="inlineCode">abstract</code>), <code class="inlineCode">BipolarTransistor</code>, and <code class="inlineCode">FieldEffectTransistor</code>) and resistors (<code class="inlineCode">Resistor</code> (<code class="inlineCode">abstract</code>), <code class="inlineCode">CarbonResistor</code>, and <code class="inlineCode">MetalResistor</code>, and its two subtypes, <code class="inlineCode">MetalFilmResistor</code> and <code class="inlineCode">MetalOxideResistor</code>).</p>
    <p class="normal">We almost have all the electrical components required for building our panel. We just need the breaker, which is just another electrical component with the particularity that it exposes two methods for turning on/off the electrical panel:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricBreaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricComponent</span> {
  <span class="hljs-keyword">void</span> <span class="hljs-title">switchOn</span><span class="hljs-params">()</span>;
  <span class="hljs-keyword">void</span> <span class="hljs-title">switchOff</span><span class="hljs-params">()</span>;
}
</code></pre>
    <p class="normal">And, finally, we can materialize the electrical panel as follows (we assume that we have three circuits, a<a id="_idIndexMarker955"/> central circuit, a peripheral circuit, and an auxiliary circuit):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricPanel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricBreaker</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ElectricCircuit centralCircuit;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ElectricCircuit peripheralCircuit;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ElectricCircuit auxiliaryCircuit;
  <span class="hljs-keyword">public</span> <span class="hljs-title">ElectricPanel</span><span class="hljs-params">()</span> {
    peripheralCircuit = <span class="hljs-keyword">new</span> <span class="hljs-title">SeriesCircuit</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-title">ElectrolyticCapacitor</span>(),<span class="hljs-keyword">new</span> <span class="hljs-title">ElectrolyticCapacitor</span>(), 
      <span class="hljs-keyword">new</span> <span class="hljs-title">MetalFilmResistor</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">CarbonResistor</span>());
    auxiliaryCircuit = <span class="hljs-keyword">new</span> <span class="hljs-title">ShortCircuit</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-title">CeramicCapacitor</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">ElectrolyticCapacitor</span>(), 
      <span class="hljs-keyword">new</span> <span class="hljs-title">MetalResistor</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">FieldEffectTransistor</span>(), 
      <span class="hljs-keyword">new</span> <span class="hljs-title">FieldEffectTransistor</span>());
    centralCircuit = <span class="hljs-keyword">new</span> <span class="hljs-title">ParallelCircuit</span>(
      peripheralCircuit, auxiliaryCircuit,
      <span class="hljs-keyword">new</span> <span class="hljs-title">CeramicCapacitor</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title">BipolarTransistor</span>(), 
      <span class="hljs-keyword">new</span> <span class="hljs-title">MetalOxideResistor</span>()); 
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">switchOn</span><span class="hljs-params">()</span> {
    auxiliaryCircuit.off();
    peripheralCircuit.on();
    centralCircuit.on();
  }
  <span class="hljs-meta">@Override</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">switchOff</span><span class="hljs-params">()</span> {
    auxiliaryCircuit.on();
    peripheralCircuit.off();
    centralCircuit.off(); 
  }
}
</code></pre>
    <p class="normal">Done! Now, a client of our panel can operate it via the <code class="inlineCode">switchOn()</code>/<code class="inlineCode">switchOff()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ElectricPanel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ElectricPanel</span>();
panel.switchOn();
</code></pre>
    <p class="normal">In the next problem, we will see how we can close this hierarchy of classes in order to increase encapsulation and avoid accidental/non-accidental extensions.</p>
    <h1 id="_idParaDest-381" class="heading-1">173. Closing the electrical panel before JDK 17</h1>
    <p class="normal">By its nature, an <a id="_idIndexMarker956"/>electrical panel is a closed unit of work. But our code from the previous problem is far from being a closed hierarchy. We can extend and implement almost any class/interface from inside or outside the hierarchy.</p>
    <p class="normal">Using anything before JDK 17, closing a hierarchy of classes and interfaces can be done using several tools.</p>
    <h2 id="_idParaDest-382" class="heading-2">Applying the final modifier</h2>
    <p class="normal">For instance, we <a id="_idIndexMarker957"/>have the powerful <code class="inlineCode">final</code> modifier. Once we declare a class as <code class="inlineCode">final</code>, it cannot be extended, so it is completely closed to extension. Obviously, we cannot apply this technique consistently across a hierarchical model because it will lead to a non-hierarchical model.</p>
    <p class="normal">If we scan our electrical panel model, then we can use the <code class="inlineCode">final</code> modifier in several places. First, we eliminate interfaces (<code class="inlineCode">ElectricComponent</code> and <code class="inlineCode">ElectricBreaker</code>) since interfaces cannot be declared as <code class="inlineCode">final</code>. Next, we can look at the <code class="inlineCode">ElectricCircuit</code> class and its subclasses (<code class="inlineCode">ParallelCircuit</code>, <code class="inlineCode">SeriesCircuit</code>, and <code class="inlineCode">ShortCircuit</code>). Obviously, since <code class="inlineCode">ElectricCircuit</code> has subclasses, it cannot be <code class="inlineCode">final</code>. However, its subclasses are modeling notions that shouldn’t be extended, so they can be <code class="inlineCode">final</code>. This is our first step in obtaining a closed hierarchical model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">ParallelCircuit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricCircuit</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">SeriesCircuit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricCircuit</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShortCircuit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricCircuit</span> {}
</code></pre>
    <p class="normal">Other classes that model well-defined notions that shouldn’t be extended are the classes that model capacitors, transistors, and resistors. So, the following classes can be <code class="inlineCode">final</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">CeramicCapacitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Capacitor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectrolyticCapacitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Capacitor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">FieldEffectTransistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Transistor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">BipolarTransistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Transistor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">CarbonResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Resistor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalFilmResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetalResistor</span> {}
<span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalOxideResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetalResistor</span> {}
</code></pre>
    <p class="normal">Finally, we<a id="_idIndexMarker958"/> have the <code class="inlineCode">ElectricPanel</code> class. It doesn’t make sense to derive something from an electrical panel, so this class can be <code class="inlineCode">final</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">final</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricPanel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricBreaker</span> {}
</code></pre>
    <p class="normal">So far, we managed to close some parts of the hierarchy. There are no other places where the <code class="inlineCode">final</code> modifier can help us, so we can go further and try another technique.</p>
    <h2 id="_idParaDest-383" class="heading-2">Defining package-private constructors</h2>
    <p class="normal">Next, we <a id="_idIndexMarker959"/>can use the hack of defining <em class="italic">package-private</em> constructors (a constructor with no visible modifier). The classes having <em class="italic">package-private</em> constructors can be instantiated and extended only inside that package – from a readability point of view, this technique is far away from expressing its intentions. However, in complex designs, we can apply this technique sporadically since we cannot simply put everything in a single package. Nevertheless, it can be considered as a solution for increasing the hierarchical model closing level.</p>
    <p class="normal">For instance, we can focus on our <code class="inlineCode">abstract</code> classes. They cannot be instantiated (being <code class="inlineCode">abstract</code>) but they can be extended from anywhere. However, some of them should be extended only in the package where they are defined. The <code class="inlineCode">ElectricCircuit</code> class is <code class="inlineCode">abstract</code> and it should be extended only by <code class="inlineCode">ParallelCircuit</code>, <code class="inlineCode">SeriesCircuit</code>, and <code class="inlineCode">ShortCircuit</code>. These subclasses live in the same package as <code class="inlineCode">ElectricCircuit</code>, so it makes sense to use this hack of declaring a <em class="italic">package-private</em> constructor:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricCircuit</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span> {
  <span class="code-highlight"><strong class="hljs-slc">ElectricCircuit() {}</strong></span>
  ...
}
</code></pre>
    <p class="normal">Now, the <code class="inlineCode">ElectricCircuit</code> class is closed to any extension attempt coming from outside of its package. Of course, it is still open to extension attempts from inside of its package.</p>
    <h2 id="_idParaDest-384" class="heading-2">Declaring classes/interfaces as non-public</h2>
    <p class="normal">Going <a id="_idIndexMarker960"/>further, we can declare interfaces/classes as non-public (by skipping the <code class="inlineCode">public</code> keyword from the class/interface definition, it becomes non-public and is set by default in the so-called <em class="italic">package-private</em> access mode). This way, those classes and interfaces are visible (can be used/extended) only inside their packages. We cannot apply this technique to the <code class="inlineCode">ElectricComponent</code> interface. This interface has to be <code class="inlineCode">public</code> because it is implemented by most of our classes. However, we can apply this technique to the <code class="inlineCode">ElectricBreaker</code> interface, since this interface should be implemented only by the <code class="inlineCode">ElectricPanel</code> class, which is in the same package as it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricBreaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">Now, <code class="inlineCode">ElectricBreaker</code> cannot be extended/implemented outside its package. Moreover, we can apply<a id="_idIndexMarker961"/> this technique to the <code class="inlineCode">abstract</code> classes <code class="inlineCode">Transistor</code>, <code class="inlineCode">Resistor</code>, and <code class="inlineCode">Capacitor</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Capacitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Resistor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span> {}
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Transistor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">Notice that we cannot apply this technique to the <code class="inlineCode">ElectricCircuit</code> class. This class is <code class="inlineCode">abstract</code> but it is used in the <code class="inlineCode">ElectricPanel</code> class, so it cannot be non-public. However, it cannot be extended thanks to the <em class="italic">package-private</em> constructor added previously.</p>
    <h2 id="_idParaDest-385" class="heading-2">Throwing everything in a module</h2>
    <p class="normal">In addition, we can place the whole hierarchy inside a Java module and export/expose to our client only a small part of it. However, this practice will not affect the closing level from inside the module, so we will skip it (that is, we will not exemplify it).</p>
    <p class="normal">At this moment almost the entire hierarchy is closed to extension/implementation. The exceptions are the <code class="inlineCode">MetalResistor</code> class and the <code class="inlineCode">ElectricComponent</code> interface, which can be extended/implemented from anywhere inside/outside the model, and the <code class="inlineCode">ElectricCircuit</code>, <code class="inlineCode">Capacitor</code>, <code class="inlineCode">Transistor</code>, and <code class="inlineCode">Resistor</code> classes, which can be extended from inside of their packages. By placing the model in a Java module, we can block these actions from outside the module, but they are still possible from inside the module.</p>
    <h2 id="_idParaDest-386" class="heading-2">Conclusion</h2>
    <p class="normal">From this point forward (prior to JDK 17), there are no more techniques, tricks, or hacks that we can apply. We can reconsider the model design, but this will be too costly and will basically mean redesigning the model entirely, which may affect the model structure and logic.</p>
    <p class="normal">For the sake of discussion and in the context of redesigning, we may consider Java enums. Java enums give us a nice closed hierarchy and are transformed internally in regular Java classes. Nevertheless, using enums to design a closed model and shape arbitrary classes can be really weird, unwieldy, and inconvenient.</p>
    <p class="normal">In conclusion, before JDK 17, we had the radical <code class="inlineCode">final</code> modifier and some control at the package level via <em class="italic">package-private</em> access.</p>
    <p class="normal">It is obvious that what’s missing here is something in between, something to give us more granularity and control. Fortunately, JDK 17 can help us to achieve a 100% closed hierarchy via sealed classes. This is the topic of some of the next problems.</p>
    <h1 id="_idParaDest-387" class="heading-1">174. Introducing JDK 17 sealed classes</h1>
    <p class="normal">Among<a id="_idIndexMarker962"/> the cool features of JDK 17, we have JEP 409 (sealed classes). This JEP provides an explicit, intuitive, crystal-clear solution for nominating who will extend a class/interface or will implement an interface. In other words, sealed classes can control inheritance at a finer level. Sealed classes can affect classes, <code class="inlineCode">abstract</code> classes, and interfaces and sustain the readability of the code – you have an easy and expressive solution to tell your colleagues who can extend/implement your code.</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_03.png" alt="Figure 8.3.png"/></figure>
    <p class="packt_figref">Figure 8.3: JDK 17, JEP 409</p>
    <p class="normal">Via sealed classes, we have finer control over a hierarchy of classes. As you can see from the previous figure, sealed classes are the missing piece of the puzzle sitting between <code class="inlineCode">final</code> and <em class="italic">package-private</em>. In other words, sealed classes provide a granularity that we cannot obtain via the <code class="inlineCode">final</code> modifier and <em class="italic">package-private</em> access.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Sealed classes don’t affect the semantics of the <code class="inlineCode">final</code> and <code class="inlineCode">abstract</code> keywords. They still act exactly as they have for years. A sealed class cannot be <code class="inlineCode">final</code> and vice versa.</p>
    </div>
    <p class="normal">Let’s consider the following class (<code class="inlineCode">Truck.java</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Truck</span> {}
</code></pre>
    <p class="normal">We know that, in principle, this class can be extended by any other class. But we have only three types of trucks: semi-trailer, tautliner, and refrigerated. So, only three classes should extend the <code class="inlineCode">Truck</code> class. Any other extension should not be allowed. In order to achieve this goal, we seal the class <code class="inlineCode">Truck</code> by adding in its declaration the <code class="inlineCode">sealed</code> keyword, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="code-highlight"><strong class="hljs-keyword-slc">sealed</strong></span> <span class="hljs-keyword">class</span> <span class="hljs-title">Truck</span> {}
</code></pre>
    <p class="normal">By <a id="_idIndexMarker963"/>adding the <code class="inlineCode">sealed</code> keyword, the compiler will automatically scan for all the extensions of <code class="inlineCode">Truck</code> predefined in <code class="inlineCode">Truck.java</code>.</p>
    <p class="normal">Next, we have to specify the subclasses of <code class="inlineCode">Truck</code> (<code class="inlineCode">SemiTrailer</code>, <code class="inlineCode">Tautliner</code>, and <code class="inlineCode">Refrigerated</code>). </p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A <code class="inlineCode">sealed</code> class (<code class="inlineCode">abstract</code> or not) must have at least a subclass (otherwise there is no point in declaring it <code class="inlineCode">sealed</code>). A <code class="inlineCode">sealed</code> interface must have at least a subinterface or an implementation (again, otherwise there is no point declaring it <code class="inlineCode">sealed</code>). If we don’t follow these rules, then the code will not compile.</p>
    </div>
    <p class="normal">If we declare the subclasses of <code class="inlineCode">Truck</code> in the same source file (<code class="inlineCode">Truck.java</code>), then we can do so as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SemiTrailer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Truck</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Tautliner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Truck</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Refrigerated</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Truck</span> {}
</code></pre>
    <p class="normal">After checking this code, we have to push another important note.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A subclass of a <code class="inlineCode">sealed</code> class must be declared <code class="inlineCode">final</code>, <code class="inlineCode">sealed</code>, or <code class="inlineCode">non-sealed</code>. A subinterface of a <code class="inlineCode">sealed</code> interface must be declared <code class="inlineCode">sealed</code> or <code class="inlineCode">non-sealed</code>. If the subclass (subinterface) of a <code class="inlineCode">sealed</code> class (interface) is declared as <code class="inlineCode">sealed</code>, then it must have its own subclasses (subinterfaces). The <code class="inlineCode">non-sealed</code> keyword indicates that the subclass (subinterface) can be freely extended further with no restrictions (the hierarchy containing a <code class="inlineCode">non-sealed</code> class/interface is not closed). And, a <code class="inlineCode">final</code> subclass cannot be extended.</p>
    </div>
    <p class="normal">Since our subclasses (<code class="inlineCode">SemiTrailer</code>, <code class="inlineCode">Tautliner</code>, and <code class="inlineCode">Refrigerated</code>) are declared <code class="inlineCode">final</code>, they cannot be extended further. So, the <code class="inlineCode">Truck</code> class can be extended only by <code class="inlineCode">SemiTrailer</code>, <code class="inlineCode">Tautliner</code>, and <code class="inlineCode">Refrigerated</code>, and these classes are non-extendable.</p>
    <p class="normal">In the case of interfaces, we do the same. For instance, a <code class="inlineCode">sealed</code> interface looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Melon</span> {}
</code></pre>
    <p class="normal">By adding the <code class="inlineCode">sealed</code> keyword, the compiler will automatically scan for all the implementations/extensions of <code class="inlineCode">Melon</code> predefined in <code class="inlineCode">Melon.java</code>. So, in the same source file (<code class="inlineCode">Melon.java</code>), we declare the extensions and implementations of this interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">non-sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Pumpkin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Melon</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Gac</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Melon</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cantaloupe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Melon</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hami</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Melon</span> {}
</code></pre>
    <p class="normal">The <code class="inlineCode">Pumpkin</code> interface <a id="_idIndexMarker964"/>can be further freely implemented/extended since it is declared as <code class="inlineCode">non-sealed</code>. The implementations/extensions of <code class="inlineCode">Pumpkin</code> don’t need to be declared <code class="inlineCode">sealed</code>, <code class="inlineCode">non-sealed</code>, or <code class="inlineCode">final</code> (but we can still make this declaration).</p>
    <p class="normal">Next, let’s look at a more complex example. Let’s name this model the <em class="italic">Fuel</em> model. Here, all classes and interfaces are placed in the same source file, <code class="inlineCode">Fuel.java</code> (the <code class="inlineCode">com.refinery.fuel</code> package). Take your time and analyze each class/interface to understand how <code class="inlineCode">sealed</code>, <code class="inlineCode">non-sealed</code>, and <code class="inlineCode">final</code> work together in this hierarchal model:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_04.png" alt="Figure 8.4.png"/></figure>
    <p class="packt_figref">Figure 8.4: A hierarchical model using sealed, non-sealed, and final</p>
    <p class="normal">In code lines, this model can be expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Fuel</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">SolidFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiquidFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">GaseousFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Coke</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Charcoal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Petroleum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiquidFuel</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Diesel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Gasoline</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ethanol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Propane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GaseousFuel</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">NaturalGas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GaseousFuel</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hydrogen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaturalGas</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Methane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaturalGas</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Chloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Methane</span> {}
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dichloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Methane</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Trichloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dichloromethane</span> {}
</code></pre>
    <p class="normal">Placing all the<a id="_idIndexMarker965"/> classes/interfaces in the same source file allows us to express closed hierarchical models like the previous one. However, placing all classes and interfaces in the same file is rarely a useful approach – maybe when the model contains a few small classes/interfaces.</p>
    <p class="normal">In reality, we like to separate classes and interfaces into their own source files. It is more natural and intuitive to have each class/interface in its own source file. This way, we avoid large sources and it is much easier to follow the best practices of OOP. So, the goal of our next problem is to rewrite the <em class="italic">Fuel</em> hierarchical model by using a source file per class/interface.</p>
    <h1 id="_idParaDest-388" class="heading-1">175. Introducing the permits clause</h1>
    <p class="normal">In the <a id="_idIndexMarker966"/>previous problem, you saw how to write a closed hierarchical model in a single source file. Next, let’s use the <code class="inlineCode">Fuel.java</code> source file to rewrite this model by using separate sources and separate packages.</p>
    <h2 id="_idParaDest-389" class="heading-2">Working with sealed classes in separate sources (same package)</h2>
    <p class="normal">Let’s <a id="_idIndexMarker967"/>consider the <code class="inlineCode">sealed Fuel</code> interface from <code class="inlineCode">Fuel.java</code> in package <code class="inlineCode">com.refinery.fuel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Fuel </span>{}   <span class="hljs-comment">// Fuel.java</span>
</code></pre>
    <p class="normal">We know that this interface is extended by three other interfaces: <code class="inlineCode">SolidFuel</code>, <code class="inlineCode">LiquidFuel</code>, and <code class="inlineCode">SolidFuel</code>. Let’s define <code class="inlineCode">SolidFuel</code> in the <code class="inlineCode">SolidFuel.java</code> source (same package), as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">SolidFuel</span> {} <span class="hljs-comment">// SolidFuel.java</span>
</code></pre>
    <p class="normal">As you’ll see, this code will not compile (it is like the compiler is asking: <em class="italic">hey, what’s the point of a sealed interface without any implementation/extension?</em>). This time, we have to explicitly <a id="_idIndexMarker968"/>nominate the interfaces that can extend/implement the <code class="inlineCode">Fuel</code> interface. For this, we use the <code class="inlineCode">permits</code> keyword. Since <code class="inlineCode">Fuel</code> is implemented by three interfaces, we just list their names via <code class="inlineCode">permits</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Fuel</span> 
<span class="hljs-keyword">  permits</span> SolidFuel, LiquidFuel, GaseousFuel {}
</code></pre>
    <p class="normal">The list provided via <code class="inlineCode">permits</code> is exhaustive. The <code class="inlineCode">SolidFuel</code> is also a <code class="inlineCode">sealed</code> interface, so it has to define its <code class="inlineCode">permits</code> as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">SolidFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span>
<span class="hljs-keyword">  permits</span> Coke, Charcoal {}
</code></pre>
    <p class="normal"><code class="inlineCode">LiquidFuel</code> and <code class="inlineCode">GaseousFuel</code> work the same way as <code class="inlineCode">SolidFuel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// LiquidFuel.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">LiquidFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span>
<span class="hljs-keyword">  permits</span> Petroleum {}
<span class="hljs-comment">// GaseousFuel.java</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">GaseousFuel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fuel</span>
<span class="hljs-keyword">  permits</span> NaturalGas, Propane {}
</code></pre>
    <p class="normal">The <code class="inlineCode">Coke</code> (<code class="inlineCode">Coke.java</code>) and <code class="inlineCode">Charcoal</code> (<code class="inlineCode">Charcoal.java</code>) are <code class="inlineCode">final</code> implementations of <code class="inlineCode">SolidFuel</code>, so they don’t use the <code class="inlineCode">permits</code> keyword:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Coke</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Charcoal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
</code></pre>
    <p class="normal">The <code class="inlineCode">Petroleum</code> class (<code class="inlineCode">Petroleum.java</code>) is <code class="inlineCode">sealed</code> and allows three extensions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Petroleum</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LiquidFuel</span>
<span class="hljs-keyword">  permits</span> Diesel, Gasoline, Ethanol {}
</code></pre>
    <p class="normal">The <code class="inlineCode">Diesel</code> (<code class="inlineCode">Diesel.java</code>), <code class="inlineCode">Gasoline</code> (<code class="inlineCode">Gasoline.java</code>), and <code class="inlineCode">Ethanol</code> (<code class="inlineCode">Ethanol.java</code>) classes are <code class="inlineCode">final</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Diesel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Gasoline</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ethanol</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Petroleum</span> {}
</code></pre>
    <p class="normal">The <code class="inlineCode">NaturalGas</code> interface (<code class="inlineCode">NaturalGas.java</code>) is a <code class="inlineCode">sealed</code> extension of <code class="inlineCode">GaseousFuel</code>, while <code class="inlineCode">Propane</code> (<code class="inlineCode">Propane.java</code>) is a <code class="inlineCode">final</code> implementation of <code class="inlineCode">GaseousFuel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">NaturalGas</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GaseousFuel</span>
<span class="hljs-keyword">  permits</span> Hydrogen, Methane {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Propane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GaseousFuel</span> {}
</code></pre>
    <p class="normal">As you <a id="_idIndexMarker969"/>can see, the <code class="inlineCode">NaturalGas</code> interface permits two extensions. The <code class="inlineCode">Hydrogen</code> class is a <code class="inlineCode">final</code> extension, while <code class="inlineCode">Methane</code> is a <code class="inlineCode">sealed</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hydrogen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaturalGas</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Methane</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaturalGas</span>
<span class="hljs-keyword">  permits</span> Chloromethane, Dichloromethane {}
</code></pre>
    <p class="normal">The <code class="inlineCode">Chloromethane</code> class is <code class="inlineCode">final</code>, and <code class="inlineCode">Dichloromethane</code> is <code class="inlineCode">sealed</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Chloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Methane</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dichloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Methane</span>
<span class="hljs-keyword">  permits</span> Trichloromethane {}
</code></pre>
    <p class="normal">Finally, we have the <code class="inlineCode">Trichloromethane</code> class. This is a <code class="inlineCode">final</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Trichloromethane</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Dichloromethane</span> {}
</code></pre>
    <p class="normal">Done! The hierarchical model is closed and complete. Any attempt to extend/implement any member of this hierarchy will lead to an exception. If we want to add a new extension/implementation to a <code class="inlineCode">sealed</code> class/interface, then we have to add it to the <code class="inlineCode">permits</code> list as well.</p>
    <h2 id="_idParaDest-390" class="heading-2">Working with sealed classes in separate packages</h2>
    <p class="normal">In the <a id="_idIndexMarker970"/>previous example, we expressed the classes/interfaces in separate sources but in the same package, <code class="inlineCode">com.refinery.fuel</code>. Next, let’s consider that we spread these classes and interfaces across different packages as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_05.png" alt="Figure 8.4.png"/></figure>
    <p class="packt_figref">Figure 8.5: Sealed hierarchy in different packages</p>
    <p class="normal">As long as <a id="_idIndexMarker971"/>the related <code class="inlineCode">sealed</code> classes/interfaces live in the same package, we can use the JDK 9 <em class="italic">unnamed</em> special module (no explicit module). Otherwise, we have to use a <em class="italic">named</em> module. For instance, if we express our model as in <em class="italic">Figure 8.5</em>, then we have to add everything in a module via <code class="inlineCode">module-info.java</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">module</span> P175_SealedHierarchySeparatePackages {}
</code></pre>
    <p class="normal">Without a <em class="italic">named</em> module, the code will not compile. In the bundled code, you can find both examples from this problem.</p>
    <h1 id="_idParaDest-391" class="heading-1">176. Closing the electrical panel after JDK 17</h1>
    <p class="normal">Do you<a id="_idIndexMarker972"/> remember our electrical panel model introduced earlier in <em class="italic">Problems 172</em> and <em class="italic">173</em>? In <em class="italic">Problem 173</em>, we closed this model as much as possible by using the Java capabilities available before JDK 17. Now, we can revisit that model (<em class="italic">Problem 173</em>) and close it completely via JDK 17 sealed classes.</p>
    <p class="normal">We start with the <code class="inlineCode">ElectricComponent</code> interface, which is declared as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">At this moment, this interface is not closed. It can be extended/implemented from any other point of the application. But we can close it by transforming it into a <code class="inlineCode">sealed</code> interface with the proper <code class="inlineCode">permits</code> clause, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> ElectricCircuit, ElectricBreaker, 
          Capacitor, Resistor, Transistor {}
</code></pre>
    <p class="normal">Next, let’s <a id="_idIndexMarker973"/>focus on the semi-closed <code class="inlineCode">ElectricCircuit</code> class. This is an <code class="inlineCode">abstract</code> class that uses a <em class="italic">package-private</em> constructor to block any extension from outside its package. However, it can still be extended from inside the package. We can close it completely by transforming it into a <code class="inlineCode">sealed</code> class with the proper <code class="inlineCode">permits</code> clause (the <em class="italic">package-private</em> constructor can be safely removed):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricCircuit</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> ParallelCircuit, SeriesCircuit, ShortCircuit {}
</code></pre>
    <p class="normal">The <code class="inlineCode">ParallelCircuit</code>, <code class="inlineCode">SeriesCircuit</code>, and <code class="inlineCode">ShortCircuit</code> were declared as <code class="inlineCode">final</code>, so they remain unchanged. We don’t want to permit any extension of these classes.</p>
    <p class="normal">Next, let’s focus on the <code class="inlineCode">Capacitor</code>, <code class="inlineCode">Transistor</code>, and <code class="inlineCode">Resistor</code> classes. These classes are also <code class="inlineCode">abstract</code> and use <em class="italic">package-private</em> constructors to avoid any extension attempts coming from outside of their packages. So, we can remove these constructors and transform them into <code class="inlineCode">sealed</code> classes exactly as we did with <code class="inlineCode">ElectricCircuit</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Capacitor</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> CeramicCapacitor, ElectrolyticCapacitor {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Transistor</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> FieldEffectTransistor, BipolarTransistor {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Resistor</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> MetalResistor, CarbonResistor {}
</code></pre>
    <p class="normal">Check out the <code class="inlineCode">Resistor</code> class. It permits only <code class="inlineCode">MetalResistor</code> and <code class="inlineCode">CarbonResistor</code> classes. Next, the <code class="inlineCode">MetalResistor</code> class needs special attention. So far, this class is <code class="inlineCode">public</code> and can be extended from any other point of the application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Resistor</span> {}
</code></pre>
    <p class="normal">Closing this class can be done by sealing it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Resistor</span>
  <span class="hljs-keyword">permits</span> MetalFilmResistor, MetalOxideResistor {}
</code></pre>
    <p class="normal">The <code class="inlineCode">MetalFilmResistor</code> and <code class="inlineCode">MetalOxideResistor</code> classes are <code class="inlineCode">final</code> and remain unchanged:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalFilmResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetalResistor</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MetalOxideResistor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetalResistor</span> {}
</code></pre>
    <p class="normal">The same statement applies to the <code class="inlineCode">CeramicCapacitor</code>, <code class="inlineCode">ElectrolyticCapacitor</code>, <code class="inlineCode">BipolarTransistor</code>, and <code class="inlineCode">FieldEffectTransistor</code> classes.</p>
    <p class="normal">Next, let’s focus on the <code class="inlineCode">ElectricBreaker</code> interface. This interface lives in the <code class="inlineCode">modern.circuit.panel</code> package and was implemented only by <code class="inlineCode">ElectricPanel</code>, so it was declared <em class="italic">package-private</em> (it cannot be extended/implemented from outside the package):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricBreaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricComponent</span> {}
</code></pre>
    <p class="normal">In order <a id="_idIndexMarker974"/>to completely close this interface, we transform it into a <code class="inlineCode">sealed</code> interface, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricBreaker</span>
  <span class="hljs-keyword">extends</span> <span class="hljs-title">ElectricComponent</span> <span class="hljs-keyword">permits</span> ElectricPanel {}
</code></pre>
    <p class="normal">Notice that we added the <code class="inlineCode">public</code> modifier as well. This is needed because <code class="inlineCode">ElectricBreaker</code> must occur in the <code class="inlineCode">permits</code> list of the <code class="inlineCode">ElectricComponent</code> interface, so it has to be available outside its package.</p>
    <p class="normal">Finally, the <code class="inlineCode">ElectricPanel</code> remains unchanged (a <code class="inlineCode">final</code> class implementing <code class="inlineCode">ElectricBreaker</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ElectricPanel</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ElectricBreaker</span> {}
</code></pre>
    <p class="normal">Mission accomplished! The electric panel hierarchical model is completely closed to extension. We put everything in a <em class="italic">named</em> module (since we have <code class="inlineCode">sealed</code> artifacts that interact across different packages) and we are done.</p>
    <h1 id="_idParaDest-392" class="heading-1">177. Combining sealed classes and records</h1>
    <p class="normal">As you <a id="_idIndexMarker975"/>know from <em class="italic">Chapter 4</em>, Java records are <code class="inlineCode">final</code> classes that cannot be extended and cannot extend other classes. This means that records and <code class="inlineCode">sealed</code> classes/interfaces can team up to obtain a closed hierarchy. </p>
    <p class="normal">For instance, in the following figure, we can identify the classes that can be good candidates to become Java records in the <em class="italic">Fuel</em> model:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_06.png" alt="Figure 8.6.png"/></figure>
    <p class="packt_figref">Figure 8.6: Identify classes that can become Java records</p>
    <p class="normal">As you can<a id="_idIndexMarker976"/> see, we have four classes that can become Java records: <code class="inlineCode">Coke</code>, <code class="inlineCode">Charcoal</code>, <code class="inlineCode">Hydrogen</code>, and <code class="inlineCode">Propane</code>. Technically speaking, these classes can be Java records since they are <code class="inlineCode">final</code> classes and don’t extend other classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Coke</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Charcoal</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SolidFuel</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Hydrogen</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaturalGas</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Propane</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GaseousFuel</span> {}
</code></pre>
    <p class="normal">Of course, the technical aspect is important but it is not enough. In other words, you don’t have to transform all classes into Java records just because it works and the code compiles. You also have to take into account the logic and the context of the application. Sometimes, a <code class="inlineCode">final</code> class is all you need; otherwise, you may need an esoteric model made of a <code class="inlineCode">sealed</code> interface with a few records and classes in the same source file (<code class="inlineCode">A.java</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> {
  <span class="hljs-keyword">record</span> <span class="hljs-title">A1</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
  <span class="hljs-keyword">record</span> <span class="hljs-title">A2</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
  <span class="hljs-keyword">non-sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">B2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
}
<span class="hljs-keyword">record</span> <span class="hljs-title">A3</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
<span class="hljs-keyword">record</span> <span class="hljs-title">A4</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> {}
</code></pre>
    <p class="normal">If you want to add the <code class="inlineCode">permits</code> clause to <code class="inlineCode">A</code>, then you can do it as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> 
<span class="hljs-keyword">  permits</span> A.A1, A.A2, A.B1, A.B2, A3, A4 {…}
</code></pre>
    <p class="normal">Done! Next, let’s see how sealed classes can help the compiler to better handle <code class="inlineCode">instanceof</code> checks.</p>
    <h1 id="_idParaDest-393" class="heading-1">178. Hooking sealed classes and instanceof</h1>
    <p class="normal">Sealed classes<a id="_idIndexMarker977"/> influence how the compiler understands the <code class="inlineCode">instanceof</code> operator and, implicitly, how it performs internal cast and conversion operations.</p>
    <p class="normal">Let’s consider the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Quadrilateral</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> {}
</code></pre>
    <p class="normal">So, we have here an interface (<code class="inlineCode">Quadrilateral</code>) and a class that doesn’t implement this interface. In this context, does the following code compile?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawTriangle</span><span class="hljs-params">(Triangle t)</span> {
  <span class="hljs-keyword">if</span> (<span class="code-highlight"><strong class="hljs-slc">t </strong><strong class="hljs-keyword-slc">instanceof</strong><strong class="hljs-slc"> Quadrilateral</strong></span>) {
    System.out.println(<span class="hljs-string">"This is not a triangle"</span>);
  } <span class="hljs-keyword">else</span> {
    System.out.println(<span class="hljs-string">"Drawing a triangle"</span>);
  }
}
</code></pre>
    <p class="normal">We wrote <code class="inlineCode">if (t instanceof Quadrilateral) {…}</code> but we know that <code class="inlineCode">Triangle</code> doesn’t implement <code class="inlineCode">Quadrilateral</code>, so at first sight, we may think that the compiler will complain about this. But, actually, the code compiles because, at runtime, we may have a class <code class="inlineCode">Rectangle</code> that extends <code class="inlineCode">Triangle</code> and implements <code class="inlineCode">Quadrilateral</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Triangle</span>
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Quadrilateral</span> {}
</code></pre>
    <p class="normal">So, our <code class="inlineCode">instanceof</code> makes sense and is perfectly legal. Next, let’s close the <code class="inlineCode">Triangle</code> class via the <code class="inlineCode">final</code> keyword:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> {}
</code></pre>
    <p class="normal">Since <code class="inlineCode">Triangle</code> is <code class="inlineCode">final</code>, <code class="inlineCode">Rectangle</code> cannot extend it, but it can still implement <code class="inlineCode">Quadrilateral</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quadrilateral</span> {}
</code></pre>
    <p class="normal">This time, the <code class="inlineCode">if (t instanceof Quadrilateral) {…}</code> code will not compile. The compiler knows that a <code class="inlineCode">final</code> class cannot be extended, so a <code class="inlineCode">Triangle</code> will never be a <code class="inlineCode">Quadrilateral</code>.</p>
    <p class="normal">So far, so good! Now, let’s restore the <code class="inlineCode">Triangle</code> class as a non-<code class="inlineCode">final</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> {}
</code></pre>
    <p class="normal">And let’s seal the <code class="inlineCode">Quadrilateral</code> interface to permit only <code class="inlineCode">Rectangle</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Quadrilateral</span> <span class="hljs-keyword">permits</span> Rectangle {}
</code></pre>
    <p class="normal">And, the <code class="inlineCode">Rectangle</code> class is <code class="inlineCode">final</code>, as follows (this time, it doesn’t extend <code class="inlineCode">Triangle</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quadrilateral</span> {}
</code></pre>
    <p class="normal">Again, the<a id="_idIndexMarker978"/> compiler will complain about this check, <code class="inlineCode">if (t instanceof Quadrilateral) {…}</code>. It is obvious that <code class="inlineCode">Triangle</code> cannot be an instance of <code class="inlineCode">Quadrilateral</code> since <code class="inlineCode">Quadrilateral</code> is <code class="inlineCode">sealed</code> and <code class="inlineCode">permits</code> only <code class="inlineCode">Rectangle</code>, not <code class="inlineCode">Triangle</code>. However, if we modify the <code class="inlineCode">Rectangle</code> to extend <code class="inlineCode">Triangle</code>, then the code compiles:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Triangle</span>
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Quadrilateral</span> {}
</code></pre>
    <p class="normal">So, in conclusion, sealed classes can help the compiler to better understand <code class="inlineCode">instanceof</code> checks and to signal us when it doesn’t make sense.</p>
    <h1 id="_idParaDest-394" class="heading-1">179. Hooking sealed classes in switch</h1>
    <p class="normal">This is not <a id="_idIndexMarker979"/>the first time in this book that we’ve presented an example of sealed classes and <code class="inlineCode">switch</code> expressions. In <em class="chapterRef">Chapter 2</em>, <em class="italic">Problem 66</em>, we briefly introduced such an example via the <code class="inlineCode">sealed Player</code> interface with the goal of covering completeness (type coverage) in pattern labels for <code class="inlineCode">switch</code>.</p>
    <p class="normal">If, at that time, you found this example confusing, I’m pretty sure that now it is clear. However, let’s keep things fresh and see another example starting from this <code class="inlineCode">abstract</code> base class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextConverter</span> {}
</code></pre>
    <p class="normal">And, we have three converters available, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf8</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextConverter</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf16</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextConverter</span> {}
<span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf32</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextConverter</span> {}
</code></pre>
    <p class="normal">Now, we can write a <code class="inlineCode">switch</code> expression to match these <code class="inlineCode">TextConverter</code> instances, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">convert</span><span class="hljs-params">(</span>
<span class="hljs-params">  TextConverter converter, String text)</span> { 
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (converter) {
    <span class="hljs-keyword">case</span> Utf8 c8 -&gt; <span class="hljs-string">"Converting text to UTF-8: "</span> + c8;
    <span class="hljs-keyword">case</span> Utf16 c16 -&gt; <span class="hljs-string">"Converting text to UTF-16: "</span> + c16;
    <span class="hljs-keyword">case</span> Utf32 c32 -&gt; <span class="hljs-string">"Converting text to UTF-32: "</span> + c32;
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">case</strong><strong class="hljs-slc"> TextConverter tc -&gt; </strong><strong class="hljs-string-slc">"Converting text: "</strong><strong class="hljs-slc"> + tc;</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">default</strong><strong class="hljs-slc"> -&gt; </strong><strong class="hljs-string-slc">"Unrecognized converter type"</strong><strong class="hljs-slc">;</strong></span>
  };
}
</code></pre>
    <p class="normal">Check out the<a id="_idIndexMarker980"/> highlighted lines of code. After the three cases (<code class="inlineCode">case Utf8</code>, <code class="inlineCode">case Utf16</code>, and <code class="inlineCode">case Utf32</code>), we must have one of the <code class="inlineCode">case TextConverter</code> or the <code class="inlineCode">default</code> case. In other words, after matching <code class="inlineCode">Utf8</code>, <code class="inlineCode">Utf16</code>, and <code class="inlineCode">Utf32</code>, we must have a total type pattern (unconditional pattern) to match any other <code class="inlineCode">TextConverter</code> or a <code class="inlineCode">default</code> case, which typically means that we are facing an unknown converter.</p>
    <p class="normal">If both the total type pattern and the <code class="inlineCode">default</code> label are missing, then the code doesn’t compile. The <code class="inlineCode">switch</code> expression doesn’t cover all the possible cases (input values), therefore it is not exhaustive. This is not allowed, since <code class="inlineCode">switch</code> expressions and <code class="inlineCode">switch</code> statements that use <code class="inlineCode">null</code> and/or pattern labels should be exhaustive.</p>
    <p class="normal">The compiler will consider our <code class="inlineCode">switch</code> as non-exhaustive because we can freely extend the base class (<code class="inlineCode">TextConverter</code>) with uncovered cases. An elegant solution is to seal the base class (<code class="inlineCode">TextConverter</code>) as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TextConverter</span>
<span class="hljs-keyword">  permits</span> Utf8, Utf16, Utf32 {}
</code></pre>
    <p class="normal">And now the <code class="inlineCode">switch</code> can be expressed as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (converter) {
  <span class="hljs-keyword">case</span> Utf8 c8 -&gt; <span class="hljs-string">"Converting text to UTF-8: "</span> + c8;
  <span class="hljs-keyword">case</span> Utf16 c16 -&gt; <span class="hljs-string">"Converting text to UTF-16: "</span> + c16;
  <span class="hljs-keyword">case</span> Utf32 c32 -&gt; <span class="hljs-string">"Converting text to UTF-32: "</span> + c32;
};
</code></pre>
    <p class="normal">This time, the compiler knows all the possible <code class="inlineCode">TextConverter</code> types and sees that they are all covered in the <code class="inlineCode">switch</code>. Since <code class="inlineCode">TextConverter</code> is <code class="inlineCode">sealed</code>, there are no surprises; no uncovered cases can occur. Nevertheless, if we later decide to add a new <code class="inlineCode">TextConverter</code> (for instance, we add <code class="inlineCode">Utf7</code> by extending <code class="inlineCode">TextConverter</code> and adding this extension in the <code class="inlineCode">permits</code> clause), then the compiler will immediately complain that the <code class="inlineCode">switch</code> is non-exhaustive, so we must take action and add the proper <code class="inlineCode">case</code> for it.</p>
    <p class="normal">At this moment, <code class="inlineCode">Utf8</code>, <code class="inlineCode">Utf16</code>, and <code class="inlineCode">Utf32</code> are declared as <code class="inlineCode">final</code>, so they cannot be extended. Let’s assume that <code class="inlineCode">Utf16</code> is modified to become <code class="inlineCode">non-sealed</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">non-sealed</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf16</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TextConverter</span> {}
</code></pre>
    <p class="normal">Now, we can extend <code class="inlineCode">Utf16</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf16be</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Utf16</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Utf16le</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Utf16</span> {}
</code></pre>
    <p class="normal">Even if we<a id="_idIndexMarker981"/> added two subclasses to the <code class="inlineCode">Utf16</code> class, our <code class="inlineCode">switch</code> is still exhaustive because the case <code class="inlineCode">Utf16</code> will cover <code class="inlineCode">Utf16be</code> and <code class="inlineCode">Utf16le</code> as well. Nevertheless, we can explicitly add cases for them, as long as we add these cases before <code class="inlineCode">case Utf16</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (converter) {
  <span class="hljs-keyword">case</span> Utf8 c8 -&gt; <span class="hljs-string">"Converting text to UTF-8: "</span> + c8;
  <span class="hljs-keyword">case</span> Utf16be c16 -&gt; <span class="hljs-string">"Converting text to UTF-16BE: "</span> + c16;
  <span class="hljs-keyword">case</span> Utf16le c16 -&gt; <span class="hljs-string">"Converting text to UTF-16LE: "</span> + c16;
  <span class="hljs-keyword">case</span> Utf16 c16 -&gt; <span class="hljs-string">"Converting text to UTF-16: "</span> + c16;
  <span class="hljs-keyword">case</span> Utf32 c32 -&gt; <span class="hljs-string">"Converting text to UTF-32: "</span> + c32;
};
</code></pre>
    <p class="normal">We have to add <code class="inlineCode">case Utf16be</code> and <code class="inlineCode">case Utf16le</code> before <code class="inlineCode">case Utf16</code> to avoid dominance errors (see <em class="chapterRef">Chapter 2</em>, <em class="italic">Problem 65</em>). </p>
    <p class="normal">Here is another example of combining sealed classes, pattern matching for switch, and Java records to compute the sum of nodes in a binary tree of integers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">BinaryTree</span> {
  <span class="hljs-keyword">record</span> <span class="hljs-title">Leaf</span><span class="hljs-params">()</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryTree</span> {}
  <span class="hljs-keyword">record</span> <span class="hljs-title">Node</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params"> value, BinaryTree left, BinaryTree right)</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">BinaryTree</span> {} 
}
<span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sumNode</span><span class="hljs-params">(BinaryTree t)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (t) {
    <span class="hljs-keyword">case</span> Leaf nl -&gt; <span class="hljs-number">0</span>;
    <span class="hljs-keyword">case</span> Node nv -&gt; nv.value() + sumNode(nv.left()) 
                                + sumNode(nv.right());
  };
}
</code></pre>
    <p class="normal">And here is an example of calling <code class="inlineCode">sumNode()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">BinaryTree</span> <span class="hljs-variable">leaf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Leaf</span>();
<span class="hljs-type">BinaryTree</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(<span class="hljs-number">5</span>, leaf, leaf);
<span class="hljs-type">BinaryTree</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(<span class="hljs-number">10</span>, leaf, leaf);
<span class="hljs-type">BinaryTree</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Node</span>(<span class="hljs-number">4</span>, s1, s2);
<span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> sumNode(s);
</code></pre>
    <p class="normal">In this example, the <a id="_idIndexMarker982"/>result is <code class="inlineCode">19</code>.</p>
    <h1 id="_idParaDest-395" class="heading-1">180. Reinterpreting the Visitor pattern via sealed classes and type pattern matching for switch</h1>
    <p class="normal">The<a id="_idIndexMarker983"/> Visitor pattern is part of the <strong class="keyWord">Gang of Four</strong> (<strong class="keyWord">GoF</strong>) design patterns and its goal is to define a new operation on certain classes without the need to modify those classes. You can find many excellent resources on this topic on the Internet, so for the classical implementation, we will provide here only the class diagram of our example, while the code is available on GitHub:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_07.png" alt="Figure 8.7.png"/></figure>
    <p class="packt_figref">Figure 8.7: Visitor pattern class diagram (use case)</p>
    <p class="normal">In a nutshell, we have a bunch of classes (<code class="inlineCode">Capacitor</code>, <code class="inlineCode">Transistor</code>, <code class="inlineCode">Resistor</code>, and <code class="inlineCode">ElectricCircuit</code>) that are used to create electrical circuits. Our operation is shaped in <code class="inlineCode">XmlExportVisitor</code> (an implementation of <code class="inlineCode">ElectricComponentVisitor</code>) and consists of printing an XML document containing the electrical circuit specifications and parameters.</p>
    <p class="normal">Before<a id="_idIndexMarker984"/> continuing, consider getting familiar with the traditional implementation and output of this example available in the bundled code.</p>
    <p class="normal">Next, let’s assume that we want to transform this traditional implementation via sealed classes and type pattern matching for <code class="inlineCode">switch</code>. The expected class diagram is simpler (has fewer classes) and it looks as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_08_08.png" alt="Figure 8.8.png"/></figure>
    <p class="packt_figref">Figure 8.8: Visitor pattern reinterpreted via sealed classes and switch patterns</p>
    <p class="normal">Let’s start the transformation with the <code class="inlineCode">ElectricComponent</code> interface. We know that this interface is implemented only by <code class="inlineCode">Capacitor</code>, <code class="inlineCode">Resistor</code>, <code class="inlineCode">Transistor</code>, and <code class="inlineCode">ElectricCircuit</code>. So, this interface is a good candidate to become <code class="inlineCode">sealed</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">ElectricComponent</span>
  <span class="hljs-keyword">permits</span> Capacitor, Transistor, Resistor, ElectricCircuit {}
</code></pre>
    <p class="normal">Notice that we deleted the <code class="inlineCode">accept()</code> method from this interface. We no longer need this method. Next, the <code class="inlineCode">Capacitor</code>, <code class="inlineCode">Resistor</code>, <code class="inlineCode">Transistor</code>, and <code class="inlineCode">ElectricCircuit</code> become <code class="inlineCode">final</code> classes and the <code class="inlineCode">accept()</code> implementation is deleted as well.</p>
    <p class="normal">Since we don’t rely on the traditional Visitor pattern, we can safely remove its specific artifacts such as <code class="inlineCode">ElectricComponentVisitor</code> and <code class="inlineCode">XmlComponentVisitor</code>.</p>
    <p class="normal">Pretty clean, right? We remained with a <code class="inlineCode">sealed</code> interface and four <code class="inlineCode">final</code> classes. Next, we can write a <code class="inlineCode">switch</code> that visits each component of a circuit, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">export</span><span class="hljs-params">(ElectricComponent circuit)</span> {
  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>();
  sb.append(<span class="hljs-string">"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"</span>);
  export(sb, circuit);
  System.out.println(sb);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">export(StringBuilder sb, ElectricComponent... comps)</code> is the<a id="_idIndexMarker985"/> effective visitor:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">export</span><span class="hljs-params">(StringBuilder sb, </span>
<span class="hljs-params">    ElectricComponent... comps)</span> {
 <span class="hljs-keyword">for</span> (ElectricComponent comp : comps) {
  <span class="hljs-keyword">switch</span> (comp) {
   <span class="hljs-keyword">case</span> Capacitor c -&gt;
    sb.append(<span class="hljs-string">"""</span>
        <span class="hljs-string">&lt;capacitor&gt;</span>
          <span class="hljs-string">&lt;maxImpedance&gt;%s&lt;/maxImpedance&gt;</span>
          <span class="hljs-string">&lt;dielectricResistance&gt;%s&lt;/dielectricResistance&gt;</span>
          <span class="hljs-string">&lt;coreTemperature&gt;%s&lt;/coreTemperature&gt;</span>
        <span class="hljs-string">&lt;/capacitor&gt;</span>
<span class="hljs-string">     """</span>.formatted(c.getMaxImpedance(), 
                   c.getDielectricResistance(), 
                   c.getCoreTemperature())).toString();
<span class="hljs-keyword">   case</span> Transistor t -&gt;
    sb.append(<span class="hljs-string">"""</span>
<span class="hljs-string">        &lt;transistor&gt;</span>
          <span class="hljs-string">&lt;length&gt;%s&lt;/length&gt;</span>
          <span class="hljs-string">&lt;width&gt;%s&lt;/width&gt;</span>
          <span class="hljs-string">&lt;threshholdVoltage&gt;%s&lt;/threshholdVoltage&gt;</span>
        <span class="hljs-string">&lt;/transistor&gt;</span>
<span class="hljs-string">     """</span>.formatted(t.getLength(), t.getWidth(), 
                   t.getThreshholdVoltage())).toString();
   <span class="hljs-keyword">case</span> Resistor r -&gt;
    sb.append(<span class="hljs-string">"""</span>
        <span class="hljs-string">&lt;resistor&gt;</span>
          <span class="hljs-string">&lt;resistance&gt;%s&lt;/resistance&gt;</span>
          <span class="hljs-string">&lt;clazz&gt;%s&lt;/clazz&gt;</span>
          <span class="hljs-string">&lt;voltage&gt;%s&lt;/voltage&gt;</span>
          <span class="hljs-string">&lt;current&gt;%s&lt;/current&gt;</span>
          <span class="hljs-string">&lt;power&gt;%s&lt;/power&gt;</span>
        <span class="hljs-string">&lt;/resistor&gt;</span>
<span class="hljs-string">     """</span>.formatted(r.getResistance(), r.getClazz(),
                   r.getVoltage(), r.getCurrent(), 
                   r.getPower())).toString();
   <span class="hljs-keyword">case</span> ElectricCircuit ec -&gt;
    sb.append(<span class="hljs-string">"""</span>
<span class="hljs-string">        &lt;electric_circuit_%s&gt;</span>
<span class="hljs-string">        %s\</span>
<span class="hljs-string">        &lt;/electric_circuit_%s&gt;</span>
<span class="hljs-string">     """</span>.formatted(ec.getId(),
          export(<span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>(), 
            ec.getComps().toArray(ElectricComponent[]::<span class="hljs-keyword">new</span>)),
            ec.getId()).indent(<span class="hljs-number">3</span>)).toString();
  }
 }
 <span class="hljs-keyword">return</span> sb.toString();
}
</code></pre>
    <p class="normal">Mission<a id="_idIndexMarker986"/> accomplished! You can find the complete example in the bundled code.</p>
    <h1 id="_idParaDest-396" class="heading-1">181. Getting info about sealed classes (using reflection)</h1>
    <p class="normal">We <a id="_idIndexMarker987"/>can inspect <code class="inlineCode">sealed</code> classes via two methods added as part of the Java Reflection API. First, we have <code class="inlineCode">isSealed()</code>, which is a flag method useful to check if a class is or isn’t <code class="inlineCode">sealed</code>. Second, we have <code class="inlineCode">getPermittedSubclasses()</code>, which returns an array containing the permitted classes. Based on these two methods, we can write the following helper to return the permitted classes of a <code class="inlineCode">sealed</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Class&gt; permittedClasses(Class clazz) {
  <span class="hljs-keyword">if</span> (clazz != <span class="hljs-literal">null</span> &amp;&amp; clazz.isSealed()) {
    <span class="hljs-keyword">return</span> Arrays.asList(clazz.getPermittedSubclasses());
  }
  <span class="hljs-keyword">return</span> Collections.emptyList();
}
</code></pre>
    <p class="normal">We can easily test our helper via the <code class="inlineCode">Fuel</code> model as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Coke</span> <span class="hljs-variable">coke</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Coke</span>();
<span class="hljs-type">Methane</span> <span class="hljs-variable">methane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Methane</span>();
<span class="hljs-comment">// [interface com.refinery.fuel.SolidFuel, </span>
<span class="hljs-comment">//  interface com.refinery.fuel.LiquidFuel, </span>
<span class="hljs-comment">//  interface com.refinery.fuel.GaseousFuel]           </span>
System.out.println(<span class="hljs-string">"Fuel subclasses: "</span> 
  + Inspector.permittedClasses(Fuel.class));
<span class="hljs-comment">// [class com.refinery.fuel.Coke, </span>
<span class="hljs-comment">//  class com.refinery.fuel.Charcoal]</span>
System.out.println(<span class="hljs-string">"SolidFuel subclasses: "</span> 
  + Inspector.permittedClasses(SolidFuel.class));
<span class="hljs-comment">// []</span>
System.out.println(<span class="hljs-string">"Coke subclasses: "</span> 
  + Inspector.permittedClasses(coke.getClass()));
<span class="hljs-comment">// [class com.refinery.fuel.Chloromethane, </span>
<span class="hljs-comment">//  class com.refinery.fuel.Dichloromethane]</span>
System.out.println(<span class="hljs-string">"Methane subclasses: "</span> 
  + Inspector.permittedClasses(methane.getClass()));
</code></pre>
    <p class="normal">I think you<a id="_idIndexMarker988"/> got the idea!</p>
    <h1 id="_idParaDest-397" class="heading-1">182. Listing the top three benefits of sealed classes </h1>
    <p class="normal">Maybe you have<a id="_idIndexMarker989"/> your own top three sealed <a id="_idIndexMarker990"/>class benefits that don’t match the following list. That’s OK, they are still benefits after all!</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Sealed classes sustain better design and clearly expose their intentions</strong>:<strong class="keyWord"> </strong>Before using sealed classes, we have to rely only on the <code class="inlineCode">final</code> keyword (which is expressive enough), and <em class="italic">package-private</em> classes/constructors. Obviously, <em class="italic">package-private</em> code requires some reading between the lines to understand its intention since it is not easy to spot a closed hierarchy modeled via this hack. On the other hand, sealed classes expose their intentions very clearly and expressively.</li>
      <li class="bulletList"><strong class="keyWord">The compiler can rely on sealed classes to perform finer checks on our behalf</strong>: Nobody can sneak a class into a hierarchy closed via sealed classes. Any such attempt is rejected via a clear and meaningful message. The compiler is guarding for us and acts as the first line of defense against any accidental/non-accidental attempt to use our closed hierarchies in an improper way.</li>
      <li class="bulletList"><strong class="keyWord">Sealed classes help the compiler to provide better pattern matching: </strong>You experimented with this benefit in <em class="italic">Problem 179</em>. The compiler can rely on sealed classes to determine if a <code class="inlineCode">switch</code> is covering all the possible input values and therefore is exhaustive. And this is just the beginning of what sealed classes can do for pattern matching.</li>
    </ul>
    <h1 id="_idParaDest-398" class="heading-1">183. Briefly introducing hidden classes</h1>
    <p class="normal">Hidden classes were introduced in JDK 15 under JEP 371. Their main goal is to be used by frameworks as dynamically generated classes. They are runtime-generated classes with a short lifespan that are used by frameworks via reflection.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Hidden classes cannot be used directly by bytecode or other classes. They are not created via a class loader. Basically, a hidden class has the class loader of the lookup class.</p>
    </div>
    <p class="normal">Among other <a id="_idIndexMarker991"/>characteristics<a id="_idIndexMarker992"/> of hidden classes, we should consider that:</p>
    <ul>
      <li class="bulletList">They are not discoverable by the JVM internal linkage of bytecode or by the explicit usage of class loaders (they are invisible to methods such as <code class="inlineCode">Class.forName()</code>, <code class="inlineCode">Lookup.findClass()</code>, or <code class="inlineCode">ClassLoader.findLoadedClass()</code>). They don’t appear in stack traces.</li>
      <li class="bulletList">They extend <strong class="keyWord">Access Control Nest</strong> (<strong class="keyWord">ACN</strong>) with classes that cannot be discovered.</li>
      <li class="bulletList">Frameworks can define hidden classes, as many as needed, since they benefit from aggressive unloading. This way, a large number of hidden classes shouldn’t have a negative impact on performance. They sustain efficiency and flexibility.</li>
      <li class="bulletList">They cannot be used as a field/return/parameter type. They cannot be superclasses.</li>
      <li class="bulletList">They can access their code directly without the presence of a class object.</li>
      <li class="bulletList">They can have <code class="inlineCode">final</code> fields, and those fields cannot be modified regardless of their accessible flags.</li>
      <li class="bulletList">They deprecated the <code class="inlineCode">misc.Unsafe::defineAnonymousClass</code>, which is a non-standard API. Starting with JDK 15, lambda expressions use hidden classes instead of anonymous classes.</li>
    </ul>
    <p class="normal">Next, let’s see how we can create and use a hidden class.</p>
    <h1 id="_idParaDest-399" class="heading-1">184. Creating a hidden class</h1>
    <p class="normal">Let’s assume that<a id="_idIndexMarker993"/> our hidden class <a id="_idIndexMarker994"/>is named <code class="inlineCode">InternalMath</code> and is as simple, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InternalMath</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(</span><span class="hljs-type">int</span><span class="hljs-params">[] nr)</span> {
    <span class="hljs-keyword">return</span> IntStream.of(nr).sum();
  }
}
</code></pre>
    <p class="normal">As we mentioned in the previous problem, hidden classes have the same class loader as the lookup class, which can be obtained via <code class="inlineCode">MethodHandles.lookup()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">MethodHandles.<span class="hljs-type">Lookup</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> MethodHandles.lookup();
</code></pre>
    <p class="normal">Next, we must know that <code class="inlineCode">Lookup</code> contains a method named <code class="inlineCode">defineHiddenClass(byte[] bytes, boolean initialize, ClassOption... options)</code>. The most important argument is represented<a id="_idIndexMarker995"/> by the array of bytes that contain the class data. The <code class="inlineCode">initialize</code> argument is a flag specifying if the hidden class should be initialized or not, while the <code class="inlineCode">options</code> argument can be <code class="inlineCode">NESTMATE</code> (the created hidden class becomes a nestmate of the lookup class and has access to all the private members in the same nest) or <code class="inlineCode">STRONG</code> (the created hidden class can be <a id="_idIndexMarker996"/>unloaded only if its defining loader is not reachable).</p>
    <p class="normal">So, our goal is to obtain the array of bytes that contains the class data. For this, we rely on <code class="inlineCode">getResourceAsStream()</code> and JDK 9’s <code class="inlineCode">readAllBytes()</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Class&lt;?&gt; clazz = InternalMath.class;
<span class="hljs-type">String</span> <span class="hljs-variable">clazzPath</span> <span class="hljs-operator">=</span> clazz.getName()
    .replace(<span class="hljs-string">'.'</span>, <span class="hljs-string">'/'</span>) + <span class="hljs-string">".class"</span>;
<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> clazz.getClassLoader()
    .getResourceAsStream(clazzPath);        
<span class="hljs-type">byte</span>[] clazzBytes = stream.readAllBytes();
</code></pre>
    <p class="normal">Having <code class="inlineCode">clazzBytes</code> in our hands, we can create the hidden class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Class&lt;?&gt; hiddenClass = lookup.defineHiddenClass(clazzBytes,
  <span class="hljs-literal">true</span>, ClassOption.NESTMATE).lookupClass();
</code></pre>
    <p class="normal">Done! Next, we can use the hidden class from inside our framework, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> hiddenClass.getConstructor().newInstance();
<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> obj.getClass()
    .getDeclaredMethod(<span class="hljs-string">"sum"</span>, <span class="hljs-type">int</span>[].class);
System.out.println(method.invoke(
    obj, <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[] {<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>})); <span class="hljs-comment">// 18</span>
</code></pre>
    <p class="normal">As you can see, we use the hidden class via reflection. The interesting part here is represented by the fact that we cannot cast the hidden class to <code class="inlineCode">InternalMath</code>, so we use <code class="inlineCode">Object obj = …</code>. So, this will not work:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">InternalMath</span> <span class="hljs-variable">obj</span> = (InternalMath) hiddenClass
    .getConstructor().newInstance();
</code></pre>
    <p class="normal">However, we<a id="_idIndexMarker997"/> can define an interface implemented by the hidden class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Math</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InternalMath</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Math</span> {…}
</code></pre>
    <p class="normal">And, now we can cast to <code class="inlineCode">Math</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Math</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> (Math) hiddenClass.getConstructor().newInstance();
</code></pre>
    <p class="normal">Starting <a id="_idIndexMarker998"/>with JDK 16, the <code class="inlineCode">Lookup</code> class was enriched with another method for defining a hidden class named <code class="inlineCode">defineHiddenClassWithClassData(byte[] bytes, Object classData, boolean initialize, ClassOption... options)</code>. This method needs the class data obtained via <code class="inlineCode">MethodHandles.classData(Lookup caller, String name, Class&lt;T&gt; type)</code> or <code class="inlineCode">MethodHandles.classDataAt(Lookup caller, String name, Class&lt;T&gt; type, int index)</code>. Take your time to explore this further.</p>
    <h1 id="_idParaDest-400" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 13 problems. Most of them were focused on the sealed classes feature. The last two problems provided brief coverage of hidden classes.</p>
    <h1 class="heading-1">Leave a review!</h1>
    <p class="normal">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
    <p class="normal"><img src="../Images/Leave_Reivew_QR.png" style="width:10em;" alt="" role="presentation"/></p>
    <p class="normal" style="font-size:0.75em;"><em class="italic">*Limited Offer</em></p>
  </div>
</body></html>