<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Scala Type System"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Scala Type System</h1></div></div></div><p>In the previous chapter, we covered how to work with lists, which made us familiar with some design principles of the whole collections library. We also covered how to generalize to sequences and covered some more relevant data structures. Finally, we also covered how collections relate to monads and how we can use that knowledge to use some powerful abstractions in our code.</p><p>In this chapter, we will 
<a class="indexterm" id="id231"/>cover the 
<code class="literal">type</code> system and polymorphism. We will also cover the different types of variance, which provides a way to constrain parameterized types. Finally, we will cover some advanced 
<code class="literal">types</code> such as abstract type members, option, and so on.
</p><p>Scala is statically typed. This 
<a class="indexterm" id="id232"/>means that the type of variables are known at compile time. The main advantage of statically typed languages is that a lot of checks can be done by the compiler, thus increasing the number of trivial bugs that are caught at an early stage. Statically typed languages are also friendlier to refactoring, as the programmer can feel safer about their changes as long as the code compiles.
</p><p>However, Scala is more than statically typed. In this chapter, we will see how Scala's expressive type system enables and enforces statically typed sound abstractions. The ability to infer types reduces the programmers' workload of annotating the program with redundant type information. This chapter will build upon the fundamentals required for the next chapter, where will be talking about type classes and a type of polymorphism they enable: ad hoc polymorphism.</p><p>By the end of this chapter, you will be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the Scala type hierarchy</li><li class="listitem" style="list-style-type: disc">Use the features the Scala type system provides</li><li class="listitem" style="list-style-type: disc">Identify abstractions that the Scala type system enables</li></ul></div><div class="section" title="Type Basics and Polymorphism"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Type Basics and Polymorphism</h1></div></div></div><p>In this section, we'll look at different types and polymorphism. We'll start with the unified type system of Scala and end with existential types.</p><div class="section" title="A Unified Type System"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>A Unified Type System</h2></div></div></div><p>Scala has a unified
<a class="indexterm" id="id233"/> type system. What this 
<a class="indexterm" id="id234"/>means is that all types, including "primitive" types, inherit from
<a class="indexterm" id="id235"/> a common type. 
<code class="literal">Any</code> is a supertype of all types. It is often
<a class="indexterm" id="id236"/> called the top type, and defines universal
<a class="indexterm" id="id237"/> methods such as 
<code class="literal">equals</code>, 
<code class="literal">hashCode,</code> and 
<code class="literal">toString</code>. 
<code class="literal">Nothing</code> is
<a class="indexterm" id="id238"/> a subtype of all types, and is often called the 
<a class="indexterm" id="id239"/>bottom type. There is no value that has a type of 
<code class="literal">Nothing</code>, so a common use case for it is to signal non-termination: a thrown exception, a program exit, or an infinite loop.
</p><p>
<code class="literal">Any</code> has two direct subclasses: 
<code class="literal">AnyVal</code> and 
<code class="literal">AnyRef</code>. Value types are represented by 
<code class="literal">AnyVal.  AnyRef</code>
<a class="indexterm" id="id240"/> represents the reference types. There are
<a class="indexterm" id="id241"/> nine
<a class="indexterm" id="id242"/> non-nullable predefined value types: 
<code class="literal">Double</code>, 
<code class="literal">Float</code>, 
<code class="literal">Long</code>, 
<code class="literal">Boolean</code>, 
<code class="literal">Unit</code>, 
<code class="literal">Byte</code>, 
<code class="literal">Char</code>, 
<code class="literal">Short,</code> and 
<code class="literal">Int</code>. All of these types are similar in other programming languages, except Unit. There is one instance of 
<code class="literal">Unit</code>, which is declared like 
<code class="literal">()</code>. Unit is an important return type as all the functions in Scala must return something. All non-value types are defined as reference types. Every user-defined type in Scala
<a class="indexterm" id="id243"/> is a subtype of 
<code class="literal">AnyRef</code>. Comparing
<a class="indexterm" id="id244"/> AnyRef to a Java runtime environment, 
<code class="literal">AnyRef</code> is similar to 
<code class="literal">java.lang.Object</code>.
</p><p>Null is a 
<a class="indexterm" id="id245"/>subtype of all reference types. It contains a 
<a class="indexterm" id="id246"/>single value identified by the literal 
<code class="literal">null</code>. Null is used for operating between other programming languages but it is not recommended to use it in Scala. Scala provides other safer options to 
<code class="literal">null,</code> which we shall cover later in the chapter.
</p></div><div class="section" title="Parametric Polymorphism"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Parametric Polymorphism</h2></div></div></div><p>
<span class="strong"><strong>Parametric polymorphism</strong></span>
<a class="indexterm" id="id247"/> is what allows 
<a class="indexterm" id="id248"/>you to write generic code for values of different types without losing the advantages of static typing.
</p><p>Without polymorphism, a generic list type structure would always look like this:</p><div class="informalexample"><pre class="programlisting">scala&gt; 2 :: 1 :: "bar" :: "foo" :: Nil
res0: List[Any] = List(2, 1, bar, foo)</pre></div><p>Having to deal with the 
<code class="literal">Any</code> type in these cases means that we can't recover any type information about the individual members:
</p><div class="informalexample"><pre class="programlisting">scala&gt; res0.head
res1: Any = 2</pre></div><p>Without polymorphism, we would be forced to use casts and thus would lack type safety (since casts are dynamic and happen at runtime).</p><p>Scala enables
<a class="indexterm" id="id249"/> polymorphism through the specification of 
<code class="literal">type</code> variables, which you probably already came across when implementing generic functions:
</p><div class="informalexample"><pre class="programlisting">scala&gt; def drop1[A](l: List[A]) = l.tail
drop1: [A](l: List[A])List[A]

scala&gt; drop1(List(1, 2, 3))
res1: List[Int] = List(2, 3)</pre></div></div><div class="section" title="Type Inference"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Type Inference</h2></div></div></div><p>A common 
<a class="indexterm" id="id250"/>problem of statically typed languages is that they provide too much "syntactic overhead". Scala rectifies this issue by introducing type interface. In Scala, type inference is local and it will consider one expression at a time.
</p><p>Type inference
<a class="indexterm" id="id251"/> reduces the need for most type annotations. For example, declaring the type of variable is not necessary in Scala, as the compiler can identify the type from the initialization expression. Return types of methods are also successfully identified by the compiler, as they resemble to the body type:
</p><div class="informalexample"><pre class="programlisting">val x = 3 + 4 * 5         // the type of x is Int
val y = x.toString()      // the type of y is String
def succ(x: Int) = x + 2  // method succ returns Int values</pre></div><p>The compiler is not able to infer a result type from recursive methods, though. The following declaration will not compile:</p><div class="informalexample"><pre class="programlisting">def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)</pre></div><p>The error message is enough to identify
<a class="indexterm" id="id252"/> the issue:
</p><div class="informalexample"><pre class="programlisting">&lt;console&gt;:11: error: recursive method fac needs result type
       def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)</pre></div></div><div class="section" title="Parameterized Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Parameterized Types</h2></div></div></div><p>
<span class="strong"><strong>Parameterized types</strong></span>
<a class="indexterm" id="id253"/>are the same as generic types
<a class="indexterm" id="id254"/> in Java. A generic type is a generic class or interface that is parameterized over types. For example:
</p><div class="informalexample"><pre class="programlisting">class Stack[T] {
  var elems: List[T] = Nil
  def push(x: T) { elems = x :: elems }
  def top: T = elems.head
  def pop() {elems = elems.tail }
}</pre></div><p>Generic types can interact with type checking using bounds or variance. We'll cover variance in the next section.</p></div><div class="section" title="Bounds"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Bounds</h2></div></div></div><p>Scala allows 
<a class="indexterm" id="id255"/>programmers to restrict polymorphic 
<a class="indexterm" id="id256"/>variables using bounds. These bounds express subtype (
<code class="literal">&lt;:</code>) or supertype (
<code class="literal">:&gt;</code>) relationships. For example, if we've defined our 
<code class="literal">drop1</code> method before as the following:
</p><div class="informalexample"><pre class="programlisting">scala&gt; def drop1[A &lt;: AnyRef](l: List[A]) = l.tail
drop1: [A &lt;: AnyRef](l: List[A])List[A]</pre></div><p>The following wouldn't compile:</p><div class="informalexample"><pre class="programlisting">scala&gt; drop1(List(1, 2, 3))
&lt;console&gt;:13: error: inferred type arguments [Int] do not conform to method drop1's type parameter bounds [A &lt;: AnyRef]
       drop1(List(1, 2, 3))
       ^
&lt;console&gt;:13: error: type mismatch;
 found   : List[Int]
 required: List[A]
       drop1(List(1, 2, 3))</pre></div></div><div class="section" title="Existential Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Existential Types</h2></div></div></div><p>An
<a class="indexterm" id="id257"/> existential type
<a class="indexterm" id="id258"/> in Scala is a type with some unknown parts in it. For example:
</p><div class="informalexample"><pre class="programlisting">Foo[T] forSome { type T }</pre></div><p>An existential type includes references to type members that we know exist, but whose concrete values we don't care about. In the preceding code, 
<code class="literal">T</code> is a type we don't know concretely, but that we know exists. Using existential types, we can leave some parts of your program unknown, and still typecheck it with different implementations for those unknown parts.
</p><p>Imagine that you have
<a class="indexterm" id="id259"/> the following method:
</p><div class="informalexample"><pre class="programlisting">scala&gt; def foo(x: Array[Any]) = x.length
foo: (x: Array[Any])Int</pre></div><p>If you try the following, it won't compile, because an 
<code class="literal">Array[String]</code> is not an 
<code class="literal">Array[Any]</code> (will see why in the next section):
</p><div class="informalexample"><pre class="programlisting">scala&gt; val a = Array("foo", "bar", "baz")
a: Array[String] = Array(foo, bar, baz)

scala&gt; foo(a)
&lt;console&gt;:14: error: type mismatch;
 found   : Array[String]
 required: Array[Any]
We can fix this by adding a type parameter:
scala&gt; def foo[T](x: Array[T]) = x.length
foo: [T](x: Array[T])Int
scala&gt; foo(a)
res0: Int = 3</pre></div><p>Now, 
<code class="literal">foo</code> is 
<a class="indexterm" id="id260"/>parameterized to accept any 
<code class="literal">T</code>. But now we have to carry around this 
<code class="literal">type</code> parameter, and we only care about 
<a class="indexterm" id="id261"/>methods on 
<code class="literal">Array</code> and not what the 
<code class="literal">Array</code> contains. We can therefore use existential types to get around this.
</p><div class="informalexample"><pre class="programlisting">scala&gt; def foo(x: Array[T] forSome { type T }) = x.length
foo: (x: Array[_])Int

scala&gt; foo(a)
res0: Int = 3</pre></div><p>This pattern is common, so Scala provides us with "wildcards" for when we don't want to name a type variable:</p><div class="informalexample"><pre class="programlisting">scala&gt; def foo(x: Array[_]) = x.length
foo: (x: Array[_])Int

scala&gt; foo(a)
res0: Int = 3</pre></div></div><div class="section" title="Activity: Generalizing the Implementation of the Binary Tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Activity: Generalizing the Implementation of the Binary Tree</h2></div></div></div><p>In this activity, we'll be generalizing an implementation of a binary search tree. Let's 
<a class="indexterm" id="id262"/>assume you have the following definition for a binary search tree of integers. We want to generalize our implementation of a binary search tree from an 
<code class="literal">IntTree</code> to a 
<code class="literal">Tree[A]</code>. Perform the necessary modifications to the code to support the new definition and also have the 
<code class="literal">insert</code> and 
<code class="literal">search</code> methods work on the new definition. You may need to modify the 
<code class="literal">insert</code> and 
<code class="literal">search</code> definitions to provide a generic comparison function. We would like to use this new generic data structure to store information about the users that visit our website, which are being modeled as the 
<code class="literal">User(username: String, country: String) </code>case class:
</p><div class="informalexample"><pre class="programlisting">trait IntTree
case class IntNode(value: Int, left: IntTree, right: IntTree) extends IntTree
case object IntEmpty extends IntTree</pre></div><p>The previous definition supports these methods:</p><div class="informalexample"><pre class="programlisting">def insert(value: Int, tree: IntTree): IntTree =
  tree match {
    case IntEmpty =&gt; IntNode(value, IntEmpty, IntEmpty)
    case IntNode(currentValue, left, right) =&gt;
      if (value &lt; currentValue)
        IntNode(currentValue, insert(value, left), right)
      else
        IntNode(currentValue, left, insert(value, right))
  }

def search(value: Int, tree: IntTree): Boolean =
  tree match {
    case IntEmpty =&gt; false
    case IntNode(currentValue, left, right) =&gt;
      value == currentValue ||
        (value &lt; currentValue &amp;&amp; search(value, left)) ||
       (value &gt;= currentValue &amp;&amp; search(value, right))
  }</pre></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by modifying the ADT for trees from <code class="literal">IntTree</code> to a <code class="literal">Tree[A]</code>. Perform<a class="indexterm" id="id263"/> the necessary modifications to <code class="literal">IntNode</code> (to become Node[A] and <code class="literal">IntEmpty</code> to become <code class="literal">Empty</code>).<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>Note that 
<code class="literal">IntEmpty</code> is an object, so there's a single instance for the type 
<code class="literal">IntEmpty</code>.type. What should 
<code class="literal">Empty</code> be a subtype of? For now, transform 
<code class="literal">Empty</code> into a case class: case class 
<code class="literal">Empty[A]() extends Tree[A]</code>. We'll look at a better way to define this type later.
</p></div></div></li><li class="listitem">Modify the <code class="literal">insert</code> definition to accept an extra comparison function as a function parameter:<div class="informalexample"><pre class="programlisting">insert[A](value: A, tree: Tree[A], comp: (A, A) =&gt; Boolean).</pre></div></li><li class="listitem">Modify the code accordingly to take the new <code class="literal">comp</code> parameter into account.</li><li class="listitem">Modify the <code class="literal">search</code> definition to accept an extra <code class="literal">comparison</code> function as a function parameter:<div class="informalexample"><pre class="programlisting">search[A](value: A, tree: Tree[A], comp: (A, A) =&gt; Boolean)</pre></div></li><li class="listitem">Modify the code accordingly to take the new <code class="literal">comp</code> parameter into account.</li><li class="listitem">Create a <a class="indexterm" id="id264"/>comparison function for <code class="literal">User</code> and use it to populate a <code class="literal">Tree[User]</code>.</li><li class="listitem">Implement the <code class="literal">def usersOfCountry(country: String, tree: Tree[User])</code>: <code class="literal">Int</code> function that returns the number of users of a given country in a <code class="literal">Tree[User]</code>.</li></ol></div><p>In this section, we covered the unified type system of Scala and how Scala achieves polymorphism. We also introduced type inference and the basic rules of when it's applied. Bounds were also introduced as a convenient way to restrict polymorphic types.</p></div></div></div>
<div class="section" title="Variance"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Variance</h1></div></div></div><p>Variance 
<a class="indexterm" id="id265"/>provides a way to constrain parameterized types. It defines a subtyping relationship between parameterized types based on the subtyping relationship of their component types.
</p><p>Imagine that you have the following class hierarchy:</p><div class="informalexample"><pre class="programlisting">class Tool
class HandTool extends Tool
class PowerTool extends Tool
class Hammer extends HandTool
class Screwdriver extends HandTool
class Driller extends PowerTool
If we define a generic box:
trait Box[T] {
  def get: T
}</pre></div><p>How can 
<code class="literal">Box</code> of 
<code class="literal">Tools</code> relate to one another? Scala provides three ways:
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Covariant: <code class="literal">Box[Hammer] &lt;: Box[Tool] if Hammer &lt;: Tool</code></li><li class="listitem" style="list-style-type: disc">Contravariant: <code class="literal">Box[Tool] &lt;: Box[Hammer] if Tool &lt;: Hammer</code></li><li class="listitem" style="list-style-type: disc">Invariant: There's no subtyping relationship between <code class="literal">Box[Tool]</code> and <code class="literal">Box[Hammer]</code> independently of the subtyping relationship of <code class="literal">Tool</code> and <code class="literal">Hammer</code></li></ul></div><div class="section" title="Covariance"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Covariance</h2></div></div></div><p>Let's assume 
<a class="indexterm" id="id266"/>that we want to define a function called 
<code class="literal">isSuitable</code>, which 
<a class="indexterm" id="id267"/>takes a 
<code class="literal">Box[HandTool]</code> and tests if the box is suitable to accommodate
<a class="indexterm" id="id268"/> the tool it attempts to box:
</p><div class="informalexample"><pre class="programlisting">def isSuitable(box: Box[HandTool]) = ???</pre></div><p>Can you pass a box of hammers to the function? After all, a hammer is a 
<code class="literal">HandTool</code>, so if the function wants to determine the suitability of the box based on the underlying tool, it should accept a 
<code class="literal">Box[Hammer]</code>. However, if you run the code as it is, you'll get a compilation error:
</p><div class="informalexample"><pre class="programlisting">&lt;console&gt;:14: error: type mismatch;
 found   : Box[Hammer]
 required: Box[HandTool]</pre></div><p>The problem here is that 
<code class="literal">Box[Hammer]</code> is not a subtype of 
<code class="literal">Box[HandTool]</code>, despite 
<code class="literal">Hammer</code> being a subtype of 
<code class="literal">HandTool</code>. In this case, we want 
<code class="literal">Box[B]</code> to be a subtype of 
<code class="literal">Box[A]</code> if 
<code class="literal">B</code> is a subtype of 
<code class="literal">A</code>. This is what covariance is. We can then tell the Scala compiler that 
<code class="literal">Box[A]</code> is a covariant on 
<code class="literal">A</code> as:
</p><div class="informalexample"><pre class="programlisting">trait Box[+T] {
  def get: T
}</pre></div></div><div class="section" title="Contravariance"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Contravariance</h2></div></div></div><p>Now, let's 
<a class="indexterm" id="id269"/>assume that we have operators that 
<a class="indexterm" id="id270"/>specialize on specific tools, so you have something like this:
</p><div class="informalexample"><pre class="programlisting">trait Operator[A] {
  def operate(t: A)
}</pre></div><p>You have a problem which requires an operator to be capable of working with hammers:</p><div class="informalexample"><pre class="programlisting">def fix(operator: Operator[Hammer]) = ???</pre></div><p>Can you pass an operator of 
<code class="literal">HandTool</code> to fix this? After all, a hammer is a 
<code class="literal">HandTool</code>, so if the operator is capable of working with hand tools, they should be able to work with hammers.
</p><p>However, if you try the code, you get a compilation error:</p><div class="informalexample"><pre class="programlisting">&lt;console&gt;:14: error: type mismatch;
 found   : Operator[HandTool]
 required: Operator[Hammer]</pre></div><p>The problem here is that 
<code class="literal">Operator[HandTool]</code> is not a subtype of 
<code class="literal">Operator[Hammer]</code>, despite 
<code class="literal">Hammer</code> being a subtype of 
<code class="literal">HandTool</code>. In this case, we want 
<code class="literal">Operator[A]</code> to be a subtype of 
<code class="literal">Operator[B]</code> if 
<code class="literal">B</code> is a subtype of 
<code class="literal">A</code>. This is what contravariance is. We can tell the Scala compiler that 
<code class="literal">Operator[A]</code> is a contravariant on 
<code class="literal">A</code> as:
</p><div class="informalexample"><pre class="programlisting">trait Operator[-A] {
  def operate(t: A)
}</pre></div></div><div class="section" title="Invariance"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Invariance</h2></div></div></div><p>By default, type
<a class="indexterm" id="id271"/> parameters are invariant because the compiler has no way of guessing 
<a class="indexterm" id="id272"/>what you intend to model with a given type. On the other hand, the compiler helps you by forbidding the definition of types that may be unsound. For example, if you declare the 
<code class="literal">Operator</code> class as a covariant, you get a compilation error:
</p><div class="informalexample"><pre class="programlisting">scala&gt; trait Operator[+A] { def operate(t: A) }
&lt;console&gt;:11: error: covariant type A occurs in contravariant position in type A of value t
       trait Operator[+A] { def operate(t: A) }</pre></div><p>By defining 
<code class="literal">Operator</code> to be covariant, you would say that an 
<code class="literal">Operator[Hammer]</code> could be used in place of an 
<code class="literal">Operator[HandTool]</code>. So, an operator capable of only using a 
<code class="literal">Hammer</code> would be able to operate on any 
<code class="literal">HandTool</code>.
</p><p>Looking at the definitions of 
<code class="literal">Box[+A]</code> and 
<code class="literal">Operator[-A]</code>, notice that type 
<code class="literal">A</code> only appears in the return type of methods of 
<code class="literal">Box[+A]</code> and only in the parameters of methods of 
<code class="literal">Operator[-A]</code>. So, a type that only produces values of type 
<code class="literal">A</code> can be made covariant on 
<code class="literal">A</code>, and a type that consumes values of type 
<code class="literal">A</code> can be made contravariant on 
<code class="literal">A</code>.
</p><p>You can deduce by the previous points that mutable data types are necessarily invariant (they have 
<code class="literal">getters</code> and 
<code class="literal">setters</code>, so they both produce and consume values).
</p><p>In fact, Java has an issue with this, as Java arrays are covariant. This means that some code that is valid at compile time can fail at runtime. For example:</p><div class="informalexample"><pre class="programlisting">String[] strings = new String[1];
Object[] objects = strings;
objects[0] = new Integer(1); // RUN-TIME FAILURE</pre></div><p>In Scala, most
<a class="indexterm" id="id273"/> collections are covariant (for example, 
<code class="literal">List[+A]</code>). However, you may be wondering how the 
<code class="literal">::</code> methods and similar are
<a class="indexterm" id="id274"/> implemented, since they may have a type in a contravariant position:
</p><div class="informalexample"><pre class="programlisting">trait List[+A] {
  def ::(a: A): List[A]
}</pre></div><p>Actually, methods such as 
<code class="literal">::</code> are implemented as follows:
</p><div class="informalexample"><pre class="programlisting">def ::[B &gt;: A](a: B): List[B]</pre></div><p>This actually allows collections to always get parameterized on the more specific type they're able to. Notice how the following list gets lifted to a list of 
<code class="literal">HandTool</code>:
</p><div class="informalexample"><pre class="programlisting">scala&gt; val l = List(new Hammer {}, new Hammer {}, new Hammer {})
l: List[Hammer] = List($anon$1@79dd6dfe, $anon$2@2f478dcf, $anon$3@3b88adb0)

scala&gt; val l2 = new Screwdriver {} :: l
l2: List[HandTool] = List($anon$1@7065daac, $anon$1@79dd6dfe, $anon$2@2f478dcf, $anon$3@3b88adb0)</pre></div></div><div class="section" title="Activity: Implementing Covariance and the Database for Tools"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Activity: Implementing Covariance and the Database for Tools</h2></div></div></div><p>In this activity, we'll be
<a class="indexterm" id="id275"/> making our previous implementation of 
<code class="literal">Tree[A]</code> covariant on 
<code class="literal">A</code>. We also want to start building a database for the tools we've defined so far. We have extended the definition of tools to now have a weight and a price: 
</p><div class="informalexample"><pre class="programlisting">trait Tool {
  def weight: Long
  def price: Long
}

trait HandTool extends Tool
trait PowerTool extends Tool
case class Hammer(weight: Long, price: Long) extends HandTool
case class Screwdriver(weight: Long, price: Long) extends HandTool
case class Driller(weight: Long, price: Long) extends PowerTool</pre></div><p>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start by defining <code class="literal">Tree</code> as <code class="literal">Tree[+A]</code>. You can now define <code class="literal">Empty</code> as a case object extending <code class="literal">Tree[Nothing]</code>.</li><li class="listitem">Define some comparison function for tools. For instance, you can compare tools by weight, by price, or by a combination of both. Experiment with the different comparison functions when creating trees.</li><li class="listitem">Implement the <code class="literal">def merge[A](tree1: Tree[A], tree2: Tree[A], comp: (A, A) =&gt; Boolean): Tr</code><code class="literal">ee[A]</code> function, which merges two trees into one.</li></ol></div><p>In this section, we've
<a class="indexterm" id="id276"/> covered variance as a way to define subtyping relationships on types based on their component types.
</p></div></div>
<div class="section" title="Advanced Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Advanced Types</h1></div></div></div><p>If you have 
<a class="indexterm" id="id277"/>come from Java, most of these things may not be surprising. As such, let's look at some other features of Scala's type system.
</p><div class="section" title="Abstract Type Members"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Abstract Type Members</h2></div></div></div><p>Abstract type members 
<a class="indexterm" id="id278"/>are type members of an
<a class="indexterm" id="id279"/> object or class that are left abstract. They can provide some abstraction without the verbosity of type parameters. If a type is intended to be used existentially in most cases, we can cut some verbosity by using a type member instead of a parameter.
</p><div class="informalexample"><pre class="programlisting">class Operator {
  type ToolOfChoice
}

class Susan extends Operator {
  type ToolOfChoice = Hammer
}

class Operator[ToolOfChoice]
class Susan extends Operator[ToolOfChoice]</pre></div><p>You can refer to an abstract type variable using the hash operator:</p><div class="informalexample"><pre class="programlisting">scala&gt; val tool: Susan#ToolOfChoice = new Hammer
tool: Hammer = Hammer@d8756ac</pre></div></div><div class="section" title="Structural Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec81"/>Structural Types</h2></div></div></div><p>Scala 
<a class="indexterm" id="id280"/>supports structural types: type requirements
<a class="indexterm" id="id281"/> that are expressed by an interface structure instead of a concrete type. Structural typing provides a feature similar to what dynamic languages allow you to do when they support duck typing, but in a static typed implementation checked up at compile time. However, bear in mind that Scala uses reflection to call methods on structural types, and that this has a cost on performance:
</p><div class="informalexample"><pre class="programlisting">def quacker(duck: { def quack(value: String): String }) {
  println(duck.quack("Quack"))
}

object BigDuck {
  def quack(value: String) = value.toUpperCase
}

object SmallDuck {
  def quack(value: String) = value.toLowerCase
}
…
…
 required: AnyRef{def quack(value: String): String}
       quacker(NotADuck)</pre></div><p>Structural types are not
<a class="indexterm" id="id282"/> very common in Scala codebases.
</p></div><div class="section" title="Option"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec82"/>Option</h2></div></div></div><p>We previously 
<a class="indexterm" id="id283"/>visited the 
<code class="literal">Null</code> type in the Scala hierarchy, but commented that null is rarely seen in Scala code. The reason behind this is the existence of the 
<code class="literal">Option</code> type in Scala's standard library. If you have worked with Java in the past, chances are you came across a 
<code class="literal">NullPointerException</code> at some point. That usually happens when some method returns 
<code class="literal">null</code> when the programmer was not expecting it to and not dealing with that possibility in the client code. Scala tries to solve the problem by making optional types explicit via the 
<code class="literal">Option[A]</code> trait. 
<code class="literal">Option[A]</code> is a container for an optional value of type 
<code class="literal">A</code>. If the value is present, then 
<code class="literal">Option[A]</code> is an instance of 
<code class="literal">Some[A]</code>, otherwise it is the 
<code class="literal">None o</code>bject. By making optional values explicit at the type level, there's no way to accidentally rely on the presence of a value that is really optional.
</p><p>You can create an 
<code class="literal">Option</code> using the 
<code class="literal">Some</code> case class or by assigning the 
<code class="literal">None</code> object. When working with Java libraries, you can use the factory method of the 
<code class="literal">Option</code> companion object that creates 
<code class="literal">None</code> if the given parameter is null, and wraps the parameter in a Some otherwise:
</p><div class="informalexample"><pre class="programlisting">val intOption1: Option[Int] = Some(2)
val intOption2: Option[Int] = None
val strOption: Option[String] = Option(null)</pre></div><p>The 
<code class="literal">Option</code> trait 
<a class="indexterm" id="id284"/>defines a get method that returns the wrapped value in case of a Some, and throws a 
<code class="literal">NoSuchElementException</code> in case of a 
<code class="literal">None</code>. A safer method is 
<code class="literal">getOrElse</code>, which returns the wrapped value in case of a Some, but a default value in case of a None. Do note that the default value in the 
<code class="literal">getOrElse</code> method is a by-name-parameter, so it will only be evaluated in case of a 
<code class="literal">None</code>.
</p><p>A convenient way to work with Options is by using pattern matching:</p><div class="informalexample"><pre class="programlisting">def foo(v: Option[Int]) = v match {
  case Some(value) =&gt; println(s"I have a value and it's $value.")
  case None =&gt; println("I have no value.")
}</pre></div><p>A nice feature of 
<code class="literal">Option</code> is that it extends 
<code class="literal">Traversable</code>, so you have all the 
<code class="literal">map</code>, 
<code class="literal">flatMap</code>, 
<code class="literal">fold</code>, 
<code class="literal">reduce</code>, and other methods we visited in the previous chapter.
</p></div><div class="section" title="Higher Kind Types"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec83"/>Higher Kind Types</h2></div></div></div><p>Scala can abstract 
<a class="indexterm" id="id285"/>over types of a higher kind
<a class="indexterm" id="id286"/>. You can think of it as types of types. A common use case for it is if you want to abstract over several types of containers for several types of data. You may want to define an interface for these containers 
<a class="indexterm" id="id287"/>without nailing down
<a class="indexterm" id="id288"/> the value's type:
</p><div class="informalexample"><pre class="programlisting">trait Container[M[_]] {
  def put[A](x: A): M[A]
  def get[A](m: M[A]): A
}

val listContainer = new Container[List] {
  def put[A](x: A) = List(x)
  def get[A](m: List[A]) = m.head
}

scala&gt; listContainer.put("str")
res0: List[String] = List(str)

scala&gt; listContainer.put(123)
res1: List[Int] = List(123)</pre></div></div><div class="section" title="Type Erasure"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec84"/>Type Erasure</h2></div></div></div><p>To incur in no runtime overhead, the Java Virtual Machine performs type erasure. Among
<a class="indexterm" id="id289"/> other things, type erasure 
<a class="indexterm" id="id290"/>replaces all type parameters in generic types with their bounds or 
<code class="literal">Object</code> if the type parameters are unbounded. This results in bytecode that only contains ordinary classes, interfaces, and methods, and makes sure that no new classes are created for parameterized types. This leads to some pitfalls when we attempt to match on generic type parameters:
</p><div class="informalexample"><pre class="programlisting">def optMatch[A](opt: Any) = opt match {
  case opt: Option[Int] =&gt; println(s"Got Option[Int]: $opt.")
  case opt: Option[String] =&gt; println(s"Got Option[String]: $opt.")
  case other =&gt; println(s"Got something else: $other.")
}

scala&gt; optMatch(Some(123))
Got Option[Int]: Some(123).

scala&gt; optMatch(Some("str"))
Got Option[Int]: Some(str).</pre></div><p>As such, you 
<a class="indexterm" id="id291"/>should always avoid matching on generic type parameters. If it is impossible to refactor the method that
<a class="indexterm" id="id292"/> performs the pattern matching, try to control the type of value passed into the function by boxing the input which has a type parameter with a container that specifies the type parameter:
</p><div class="informalexample"><pre class="programlisting">case class IntOption(v: Option[Int])
case class StringOption(v: Option[String])</pre></div></div><div class="section" title="Activity: Finding an Element Based on a Given Predicate"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec85"/>Activity: Finding an Element Based on a Given Predicate</h2></div></div></div><p>In this 
<a class="indexterm" id="id293"/>activity, we want to provide our 
<code class="literal">Tree</code> with functionality to find an element in it based on a given predicate. More concretely, we want to implement the 
<code class="literal">def find[A](tree: Tree[A], predicate: A =&gt; Boolean): Option[A]</code> function. The function should return 
<code class="literal">None</code> if no element is found that satisfies the predicate, or 
<code class="literal">Some</code> with the first element (in order) that satisfies it.
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We want to return the first element in order, so we need to assume that the tree is a search tree and traverse it in order. Implement the <code class="literal">def inOrder[A](tree: Tree[A]): Iterator[A]</code> method that returns an <code class="literal">Iterator</code> with the in-order traversal of elements in the <code class="literal">Tree</code>.</li><li class="listitem">Using the previously implemented method, now rely on the <code class="literal">find</code> method of <code class="literal">Iterator</code> to implement the <code class="literal">target</code> function.</li><li class="listitem">We want to find the cheapest tool with a weight below 100. Implement the function that should be used when creating the tree, and the predicate to be used in the <code class="literal">find</code> method.</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Summary</h1></div></div></div><p>In this 
<a class="indexterm" id="id294"/>chapter, we covered the 
<code class="literal">type</code> system and polymorphism. We also covered the different types of variance which provide a way to constrain parameterized types. Finally, we covered some advanced 
<code class="literal">types</code> such as abstract type members, option, and so on.
</p><p>In the next chapter, we will cover 
<code class="literal">implicits,</code> which will make working with external libraries more pleasant. We will cover implicit conversions and finally cover ad hoc polymorphism through the use of type classes.
</p></div></body></html>