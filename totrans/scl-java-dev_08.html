<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Essential Properties of Modern Applications &#x2013; Asynchrony and Concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Essential Properties of Modern Applications – Asynchrony and Concurrency</h1></div></div></div><p>Availability and performance are two words that often characterize the requirements found behind most commercial software. As the volume of processed information continues to grow together with the rise of social networks and added complexity of online services, web servers are now increasingly confronted with heavy loads and higher numbers of concurrent requests. In this chapter, we will explore different ways to deal with better performance and scalability by covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Async library, a new way to simplify asynchronous code, including examples of web services composition</li><li class="listitem" style="list-style-type: disc">Akka, a toolkit and runtime that simplifies the building of concurrent, distributed, and fault-tolerant applications based on the actor paradigm</li></ul></div><div class="section" title="The pillars of Concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec44"/>The pillars of Concurrency</h1></div></div></div><p>Concurrency and <a id="id427" class="indexterm"/>asynchrony are the techniques that most programming languages use to enhance response time and scalability, and Java is no exception. Asynchronous method calls is a technique by which the caller of a potentially time-consuming computation does not wait for a response, but rather continues to proceed with other code while the computation is ongoing. The caller will be notified once running has completed, receiving notification of either a successful result or a failure message.</p><p>The traditional way to deal with asynchronous code in Java has mostly been through the registration of callbacks, that is, placeholders that are called upon completion. Complexity tends to increase when working with asynchronous code as the sequence of execution is not deterministic, that is, the order of execution is not guaranteed. Executing code concurrently is, therefore, more difficult to test since it may not produce the same result on successive invocations. Furthermore, as callbacks are not composable (which means that they can't be chained and combined in a flexible way), it can be cumbersome to mix several asynchronous computations together to achieve more advanced scenarios, resulting in the well-known problem of callback hell when such projects increase in size (cases where the complexity is at such a high level that it is difficult to maintain and guarantee the proper execution of a piece of code).</p><p>Concurrency is also encountered when code is executed on multiple cores. Recent hardware architectures are now embedding several cores into the same machine as a way to continue achieving better performance when the minimal physical size of transistors has been reached.</p><p>Another consequence of dealing <a id="id428" class="indexterm"/>with concurrent code is that multiple threads of execution can get into conflicts when trying to access the same resources. Mutable state in a program, which is not protected against shared access, has a higher risk of being incorrect. Making sure that the concurrent code executes correctly often comes at the cost of increased complexity. Java thread synchronization mechanisms, for example, using locks, have led to solutions that are difficult to understand and maintain.</p><p>The functional approach of Scala striving for immutability is a first step towards easier concurrency. <span class="strong"><strong>Scala Improvement </strong></span><a id="id429" class="indexterm"/>
<span class="strong"><strong>Process</strong></span> (<span class="strong"><strong>SIP</strong></span>), which can be seen as the equivalent to the Java JSR process in Scala, has proposed an SIP concerning <span class="emphasis"><em>SIP-14-Futures and Promises</em></span>. These notions are not new as they have already been used in many other languages when writing concurrent code, but the new proposal tries to merge the various Scala implementations of Futures.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Futures and Promises are objects <a id="id430" class="indexterm"/>through which you can later retrieve the result of some asynchronous execution after it finishes. To learn more, visit <a class="ulink" href="http://en.wikipedia.org/wiki/Futures_and_promises">http://en.wikipedia.org/wiki/Futures_and_promises</a>.</p></div></div><p>As stated in <span class="emphasis"><em>SIP-14-Futures and Promises</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p>Futures provide a nice way to reason about performing many operations in parallel—in an efficient and non-blocking way.</p></blockquote></div><p>From this proposal, an implementation has been created, which is now the basis of many Scala libraries that deal with concurrent and asynchronous code.</p></div></div>
<div class="section" title="The Async library &#x2013; SIP-22-Async"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec45"/>The Async library – SIP-22-Async</h1></div></div></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Working with Integration and Web Services">Chapter 7</a>, <span class="emphasis"><em>Working with Integration and Web Services</em></span>, we have briefly seen how to call asynchronous web services that <a id="id431" class="indexterm"/>return a <code class="literal">Future</code> object. The aim of Async is to simplify asynchronous code by providing a couple of powerful constructs to deal with asynchronous code blocks and, in particular, combining several such blocks. It consists of only two constructs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">async { &lt;expression&gt; }</code>: <a id="id432" class="indexterm"/>In this construct, <code class="literal">&lt;expression&gt;</code> is the code to be executed asynchronously.</li><li class="listitem" style="list-style-type: disc"><code class="literal">await { &lt;expression returning a Future&gt; }</code>: This construct is included in an <code class="literal">async</code> block. <a id="id433" class="indexterm"/>It suspends the execution of the enclosing <code class="literal">async</code> block until the argument <code class="literal">Future</code> is completed.</li></ul></div><p>An interesting characteristic of the <a id="id434" class="indexterm"/>whole <code class="literal">async</code>/<code class="literal">await</code> mechanism is that it is totally nonblocking. Although it is not really required to understand how <code class="literal">async</code>/<code class="literal">await</code> works, the exact signature of the two methods <code class="literal">async[]</code> and <code class="literal">await[]</code> are given for reference, as follows:</p><div class="informalexample"><pre class="programlisting">def async[T](body: =&gt; T) : Future[T]
def await[T](future:Future[T]):T</pre></div><p>
<code class="literal">T</code> refers to arbitrary types (such as <code class="literal">Int</code> or <code class="literal">String</code>) or container types (such as <code class="literal">List</code> or <code class="literal">Map</code>), which is how we describe generic types in Scala. Although we will not cover too much programming with generic types, which has already been extensively described in other books such as <span class="emphasis"><em>Programming in Scala,</em></span> <span class="emphasis"><em>Artima</em></span> by <span class="emphasis"><em>Martin Odersky</em></span>, <span class="emphasis"><em>Lex Spoon</em></span> and <span class="emphasis"><em>Bill Venners</em></span>, it is important to understand that they exist and they form part of the core of the Scala language.</p><p>To better understand what Async is all about, we will use the examples that we can run in the REPL. Create a new <code class="literal">Play</code> project by running the command <code class="literal">&gt; play new ch8samples</code> and choose, of course, Scala as the language used for the project. Once the project is created, add the Async library as a dependency by adding one line inside the <code class="literal">build.sbt</code> file, which now looks like the following lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>name := "ch8samples"</strong></span>

<span class="strong"><strong>version := "1.0-SNAPSHOT"</strong></span>

<span class="strong"><strong>libraryDependencies ++= Seq(</strong></span>
<span class="strong"><strong>  jdbc,</strong></span>
<span class="strong"><strong>  anorm,</strong></span>
<span class="strong"><strong>  cache,</strong></span>
<span class="strong"><strong>  "org.scala-lang.modules" %% "scala-async" % "0.9.0"</strong></span>
<span class="strong"><strong>)     </strong></span>

<span class="strong"><strong>play.Project.playScalaSettings</strong></span>
</pre></div><p>We can run the REPL console, as usual, in a terminal window by entering the following command from the root directory of the project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play console</strong></span>
</pre></div><p>First, we need to perform some imports, which are as shown in the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import scala.async.Async.{async, await}</strong></span>
<span class="strong"><strong>import scala.async.Async.{async, await}</strong></span>
<span class="strong"><strong>scala&gt; import scala.concurrent.ExecutionContext.Implicits.global</strong></span>
<span class="strong"><strong>import scala.concurrent.ExecutionContext.Implicits.global</strong></span>
</pre></div><p>Similarly, for a thread pool, an <a id="id435" class="indexterm"/>execution context is needed to handle how and when the asynchronous computation should be executed.</p><p>Second, we can specify an asynchronous computation by enclosing the computation into an <code class="literal">async</code> block:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val computation = async { 3 * 2 }</strong></span>
<span class="strong"><strong>computation: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@545c484c</strong></span>
<span class="strong"><strong>scala&gt; computation.value</strong></span>
<span class="strong"><strong>res0: Option[scala.util.Try[Int]] = Some(Success(6))</strong></span>
</pre></div><p>As you can see that the type of the result is <code class="literal">Option[scala.util.Try[Int]]</code>, recollect the brief discussion on the <code class="literal">Try</code> class in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>. We learned that it builds upon an <code class="literal">Either</code> class <a id="id436" class="indexterm"/>that can take the value <code class="literal">Success</code> or <code class="literal">Failure</code> that corresponds respectively to the <code class="literal">Left</code> and <code class="literal">Right</code> values of the <code class="literal">Either</code> class.</p><p>In our case, the computation was quite immediate and resulted in the success value of <code class="literal">6</code>.</p><p>Let us make the computation that takes a longer time (for example, 10 seconds), as shown in the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val longComputation = async { Thread.sleep(10000); 3*2 }</strong></span>
<span class="strong"><strong>longComputation: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@7b5ab834</strong></span>
</pre></div><p>Also, during those 10 seconds, we access its result value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; longComputation.value</strong></span>
<span class="strong"><strong>res1: Option[scala.util.Try[Int]] = None</strong></span>
</pre></div><p>We will get the answer <code class="literal">None</code>, which is what we expect, as the computation is not completed yet.</p><p>If we wait for 10 seconds and perform the same query again, we'll get our result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; longComputation.value</strong></span>
<span class="strong"><strong>res2: Option[scala.util.Try[Int]] = Some(Success(6))</strong></span>
</pre></div><p>Note that once a Future is completed and given a value, it cannot be modified.</p><p>An alternative to polling for the result is to be informed or execute some code when the Future is completed. We can do <a id="id437" class="indexterm"/>that by invoking the <code class="literal">onComplete</code> method, immediately <a id="id438" class="indexterm"/>after rerunning our computation, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val longComputation = async { Thread.sleep(10000); 3*2 }</strong></span>
<span class="strong"><strong>longComputation: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@1c6b985a</strong></span>
<span class="strong"><strong>scala&gt; longComputation.onComplete(println)</strong></span>
<span class="strong"><strong>scala&gt;   (no immediate result)</strong></span>
</pre></div><p>In other words, while the computation is not finished, we can proceed executing other statements:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val hello = "Hello"</strong></span>
</pre></div><p>Eventually, we will see the value <code class="literal">6</code> on the screen, once the time of 10 seconds elapses:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; Success(6)</strong></span>
</pre></div><p>So far, we've seen that the <code class="literal">async</code> method<a id="id439" class="indexterm"/> performs the same way as the <code class="literal">future</code> <a id="id440" class="indexterm"/>method, which is part of the <code class="literal">scala.concurrent</code> package; for this reason, we could just replace <code class="literal">async</code> with <code class="literal">future</code>.</p><p>The preferred way is to use <code class="literal">async</code> in <a id="id441" class="indexterm"/>conjunction with <code class="literal">await</code>. The <code class="literal">await </code>method is taking a <code class="literal">Future</code> object as an input argument. It wraps the rest of the <code class="literal">async,</code> blocks in a closure and passes it as a callback on completion of the <code class="literal">Future</code> object we're waiting on (the one we passed as argument). Although <code class="literal">await</code> will wait for the invoked <code class="literal">Future</code> object until it is completed, the whole <code class="literal">async</code>/<code class="literal">await</code> execution is nonblocking, which means we can compose the <code class="literal">Future</code> objects in a totally nonblocking way.</p><p>Let's illustrate composing two computations where the input of one depends on the output of the other. A typical example is the invocation of two web services to query a weather forecast service: one that returns our current geo location and the other that needs our position (coordinates or the city name). The following lines of command explain the invocation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; import play.api.libs.json._</strong></span>
<span class="strong"><strong>import play.api.libs.json._</strong></span>
<span class="strong"><strong>scala&gt; import play.api.libs.ws._</strong></span>
<span class="strong"><strong>import play.api.libs.ws._</strong></span>
<span class="strong"><strong>scala&gt; import play.api.libs.functional.syntax._</strong></span>
<span class="strong"><strong>import play.api.libs.functional.syntax._</strong></span>
<span class="strong"><strong>scala&gt; import scala.util.{Success, Failure}</strong></span>
<span class="strong"><strong>import scala.util.{Success, Failure}</strong></span>
<span class="strong"><strong>scala&gt; val locationURL = "http://freegeoip.net/xml/www.aftonbladet.se"</strong></span>
<span class="strong"><strong>locationURL: String = http://freegeoip.net/xml/www.aftonbladet.se</strong></span>
<span class="strong"><strong>scala&gt; val futureLocation = WS.url(locationURL).get().map { response =&gt; </strong></span>
<span class="strong"><strong>         (response.xml \ "City").text</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>futureLocation: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@6039c183</strong></span>
</pre></div><p>Wait for a couple of seconds to make sure that the web service <code class="literal">Future</code> gets completed, then press <span class="emphasis"><em>Enter</em></span>; you'll see the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val location = futureLocation.value</strong></span>
<span class="strong"><strong>location: Option[scala.util.Try[String]] = Some(Success(Stockholm))</strong></span>
</pre></div><p>The first service returns the XML text where we extracted only the <code class="literal">City</code> element.</p><p>Now, let's try a second service from the <a class="ulink" href="http://openweathermap.org">http://openweathermap.org</a> website, a useful resource for testing web service <a id="id442" class="indexterm"/>code in general. The following web service call returns the weather as a JSON message, given a particular location (we will use a hardcoded <code class="literal">Paris</code> city here to first experiment with this service alone without composing the two services):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val weatherURL = "http://api.openweathermap.org/data/2.5/weather?q="</strong></span>
<span class="strong"><strong>weatherURL: String = http://api.openweathermap.org/data/2.5/weather?q=</strong></span>
<span class="strong"><strong>scala&gt; val futureWeather = WS.url(weatherURL+"Paris").get().map{ response =&gt; </strong></span>
<span class="strong"><strong>         response.json</strong></span>
<span class="strong"><strong>       }</strong></span>
<span class="strong"><strong>futureWeather: scala.concurrent.Future[play.api.libs.json.JsValue] = scala.concurrent.impl.Promise$DefaultPromise@4dd5dc9f</strong></span>
</pre></div><p>Wait for a couple of seconds to <a id="id443" class="indexterm"/>make sure that the web service <code class="literal">Future</code> gets completed, then enter the following statement:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; val weather = futureWeather.value</strong></span>
<span class="strong"><strong>weather: Option[scala.util.Try[play.api.libs.json.JsValue]] = Some(Success({"coord":{"lon":2.35,"lat":48.85},"sys":{"message":0.0052,"country":"FR","sunrise":1389166933,"sunset":1389197566},"weather":[{"id":803,"main":"Clouds","description":"broken clouds","icon":"04n"}],"base":"cmc stations","main":{"temp":284.36,"pressure":1013,"temp_min":284.15,"temp_max":284.82,"humidity":86},"wind":{"speed":5.37,"deg":193},"clouds":{"all":80},"dt":1389221871,"id":2988507,"name":"Paris","cod":200}))</strong></span>
</pre></div><div class="section" title="Combining web services"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Combining web services</h2></div></div></div><p>We are now <a id="id444" class="indexterm"/>ready to combine two services <a id="id445" class="indexterm"/>using <code class="literal">async</code>/<code class="literal">await</code>.</p><p>Let's copy and paste the following lines at once in the REPL. To do this, we can use the convenient <code class="literal">:paste</code> command of <a id="id446" class="indexterm"/>the REPL, as shown in the following command lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; :paste</strong></span>
<span class="strong"><strong>// Entering paste mode (ctrl-D to finish)</strong></span>

<span class="strong"><strong>val futureLocation = </strong></span>
<span class="strong"><strong>  WS.url(locationURL).get().map(resp =&gt; (resp.xml \ "City").text)</strong></span>
<span class="strong"><strong>val futureWeather2 = async {</strong></span>
<span class="strong"><strong>  await(WS.url(weatherURL+await(futureLocation)).get()).body </strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>futureWeather2.onComplete(println)</strong></span>

<span class="strong"><strong>// once the block is copied from somewhere using ctrl-C/ctrl-D, press ctrl-D</strong></span>

<span class="strong"><strong>// Exiting paste mode, now interpreting.</strong></span>
<span class="strong"><strong>futureLocation: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@1e111066</strong></span>
<span class="strong"><strong>futureWeather2: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@724ba7f5</strong></span>
<span class="strong"><strong>scala&gt; Success({"coord":{"lon":18.06,"lat":59.33},"sys":{"message":0.0251,"country":"SE","sunrise":1395808197,"sunset":1395854197},"weather":[{"id":800,"main":"Clear","description":"Sky is Clear","icon":"01d"}],"base":"cmc stations","main":{"temp":277.29,"pressure":1028,"humidity":69,"temp_min":276.15,"temp_max":278.15},"wind":{"speed":5.1,"deg":60},"rain":{"3h":0},"clouds":{"all":0},"dt":1395852600,"id":2673730,"name":"Stockholm","cod":200})</strong></span>
</pre></div><p>What happens in this code is <a id="id447" class="indexterm"/>that the <a id="id448" class="indexterm"/>
<code class="literal">await</code> construct ensures that the location city will be available to the weather service.</p></div><div class="section" title="Combining services without await"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Combining services without await</h2></div></div></div><p>If we do not put an <code class="literal">await </code><a id="id449" class="indexterm"/>method around the <code class="literal">futureLocation</code> web service call while defining the <code class="literal">futureWeather2</code> variable, <a id="id450" class="indexterm"/>we get a different answer. This is because, in such a case, the <code class="literal">Future</code> object that contains the location service answer is not yet populated when querying for the weather service. You can verify this behavior by copying and pasting the three following statements at once into the REPL (assuming the <code class="literal">locationURL</code> variable is still valid, it was created earlier while introducing the location service):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>scala&gt; :paste</strong></span>
<span class="strong"><strong>// Entering paste mode (ctrl-D to finish)</strong></span>

<span class="strong"><strong>val futureLocation = </strong></span>
<span class="strong"><strong>  WS.url(locationURL).get().map(resp =&gt; (resp.xml \ "City").text)</strong></span>
<span class="strong"><strong>val futureWeather2 = async {</strong></span>
<span class="strong"><strong>  await(WS.url(weatherURL + futureLocation).get()).body </strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>futureWeather2.onComplete(println)</strong></span>

<span class="strong"><strong>// once the block is copied from somewhere using ctrl-C/ctrl-D, press ctrl-D</strong></span>
<span class="strong"><strong>// Exiting paste mode, now interpreting.</strong></span>
<span class="strong"><strong>futureLocation: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@705a7c28</strong></span>
<span class="strong"><strong>futureWeather2: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@448d5fb8</strong></span>
<span class="strong"><strong>scala&gt; Success({"message":"Error: Not found city","cod":"404"}</strong></span>
<span class="strong"><strong>)</strong></span>
</pre></div><p>This time, the output shows that <a id="id451" class="indexterm"/>the city was not entered correctly into the weather service.</p></div></div>
<div class="section" title="Getting started with Akka"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Getting started with Akka</h1></div></div></div><p>
<span class="strong"><strong>Akka</strong></span> is a toolkit to simplify writing <a id="id452" class="indexterm"/>concurrent and distributed applications, tasks that can be complex to achieve, as we described at the beginning of this chapter. As Akka is largely documented both by a number of books as well as extensive online documentation, our goal here is mostly to experiment with the technology. We will see how to elegantly write Scala code to solve problems that might otherwise be error-prone and hard to understand if written in more conventional ways such as thread synchronization and other languages such as Java. Akka is written in Scala, but provides to both Java and Scala APIs.</p><div class="section" title="Understanding the Actor model"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Understanding the Actor model</h2></div></div></div><p>Akka relies on the Actor <a id="id453" class="indexterm"/>paradigm to create concurrent applications. The Actor model has already been introduced decades ago in the original paper of Carl Hewitt, Peter Bishop, and Richard Steiger entitled <span class="emphasis"><em>A Universal Modular Actor Formalism for Artificial Intelligence</em></span>, <span class="emphasis"><em>1973</em></span>, <span class="emphasis"><em>IJCAI</em></span>. Erlang is an example of language that has been made famous using this model of computation and achieved very good scalability and reliability figures (the well-known nine nines of availability).</p><p>Without going too much into <a id="id454" class="indexterm"/>details, we can say that the Actor model is a model based on message passing rather than method calls. Each unit of computation, called <span class="strong"><strong>actor</strong></span>, <a id="id455" class="indexterm"/>encapsulates its own behavior and communicates with other actors through asynchronous immutable messages. It is quite straightforward to reason about actor systems since they mimic the way humans communicate, exchanging immutable messages between each other. Since the footprint of actors is very minimal compared to threads, and state is not shared, they are very suited to writing concurrent and distributed applications.</p><p>In the gold mine of Typesafe activator templates, a number of projects concerning Akka are available. Let's dig into a couple of them to better understand how to make programs using Akka actors. First, we can take a look at the <code class="literal">hello-akka</code> project to get an idea on how to run a simple actor.</p><p>If you haven't got the Typesafe activator in place, follow the instructions from <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, to <a id="id456" class="indexterm"/>create the sample project associated with the <code class="literal">hello-akka</code> template. Once imported into Eclipse, we may start looking at the main class <code class="literal">HelloAkkaScala.scala</code> in the default package of the <code class="literal">Scala src</code> directory.</p><p>It starts with the following lines (skipping the imports):</p><div class="informalexample"><pre class="programlisting">case object Greet
case class WhoToGreet(who: String)
case class Greeting(message: String)

class Greeter extends Actor {
  var greeting = ""

  def receive = {
    case WhoToGreet(who) =&gt; greeting = s"hello, $who"
    case Greet           =&gt; sender ! Greeting(greeting) 
    // Send the current greeting back to the sender
  }
}</pre></div><p>As you see, defining an actor consists of extending an <code class="literal">Actor</code> trait and requires only implementing the abstract <code class="literal">receive</code> <a id="id457" class="indexterm"/>method. This method represents the actor's behavior when it receives a message. It does not need to handle all types of messages, which is why it is a partial function.</p><p>The declared mutable variable, <code class="literal">greeting</code>, shows that you can safely add some mutable state to your actor since the processing of the <code class="literal">receive</code> method is single threaded.</p><p>It is convenient to model the immutable messages sent between actors as case classes, and the <code class="literal">Greeter</code> actor uses the two messages, <code class="literal">Greet</code> and <code class="literal">WhoToGreet(who:String)</code>. Whenever the <code class="literal">Greeter</code> actor receives a <code class="literal">WhoToGreet(who)</code> message, it simply updates its state but does not reply anything. In contrast, when this same actor receives a <code class="literal">Greet</code> message, it uses the saved state to answer the actor that sent the message. The <code class="literal">!</code> method is also called <code class="literal">tell</code> (which, by the way, is the name used in the Akka Java API) and represents the sending of a message to an actor, with the signature <code class="literal">actor ! message</code>.</p><p>Also, note the presence of the <code class="literal">sender</code> variable that is made implicitly available as part of the <code class="literal">Actor</code> trait, since it is a common <a id="id458" class="indexterm"/>pattern that an actor replies to the sender. However, we could have added an <code class="literal">ActorRef</code> argument to the <code class="literal">Greet</code> message containing the address of the receiver instead, that is, declared a <code class="literal">case Greet(someone:ActorRef)</code> class and <a id="id459" class="indexterm"/>implemented the processing of <code class="literal">Greet</code>, as follows:</p><div class="informalexample"><pre class="programlisting">def receive = {
  ...
  case Greet(someone) =&gt; someone ! Greeting(greeting)
}</pre></div><p>The <code class="literal">HelloAkkaScala</code> <a id="id460" class="indexterm"/>object defines <a id="id461" class="indexterm"/>the main routine, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">object HelloAkkaScala extends App {

  // Create the 'helloakka' actor system
  val system = ActorSystem("helloakka")

  // Create the 'greeter' actor
  val greeter = system.actorOf(Props[Greeter], "greeter")

  // Create an "actor-in-a-box"
  val inbox = Inbox.create(system)

  // Tell the 'greeter' to change its 'greeting' message
  greeter.tell(WhoToGreet("akka"), ActorRef.noSender)

  // Ask the 'greeter for the latest 'greeting'
  // Reply should go to the "actor-in-a-box"
  inbox.send(greeter, Greet)

  // Wait 5 seconds for the reply with the 'greeting' message
  val Greeting(message1) = inbox.receive(5.seconds)
  println(s"Greeting: $message1")

  // Change the greeting and ask for it again
  greeter.tell(WhoToGreet("typesafe"), ActorRef.noSender)
  inbox.send(greeter, Greet)
  val Greeting(message2) = inbox.receive(5.seconds)
  println(s"Greeting: $message2")
  val greetPrinter = system.actorOf(Props[GreetPrinter])
  // after zero seconds, send a Greet message every second to the greeter with a sender of the greetPrinter
  system.scheduler.schedule(0.seconds, 1.second, greeter, Greet)(system.dispatcher, greetPrinter)
}</pre></div><p>A system running actors needs a runtime environment; this is what the <code class="literal">system</code> variable declares. Creating an actor consists of <a id="id462" class="indexterm"/>invoking the <code class="literal">system.actorOf</code> method with a configuration argument as well as an optional name. This method gives you back an <code class="literal">ActorRef</code> (actor reference) object, which is the actor address, that is, where messages can <a id="id463" class="indexterm"/>be sent. An <code class="literal">ActorRef</code> object is an immutable and serializable handle to an actor, which may or may not reside on the local host or within the same <a id="id464" class="indexterm"/>
<code class="literal">ActorSystem</code> object. As actors only communicate through messages in an asynchronous fashion, each actor has a mailbox where messages can be <a id="id465" class="indexterm"/>enqueued if the actor cannot handle them as quickly as they arrive.</p><p>The remaining part of the main routine essentially sends orders in the form of <code class="literal">Greet</code> or <code class="literal">WhoToGreet</code> messages to the <code class="literal">Greeter</code> actor. These messages are sent from an <code class="literal">Inbox</code> object that also expects answers. This <a id="id466" class="indexterm"/>
<code class="literal">Inbox</code> object, also referred to as "actor-in-a-box", is a <a id="id467" class="indexterm"/>convenient way to write code outside actors that will communicate with actors. <a id="id468" class="indexterm"/>Finally, the last actor, <code class="literal">greetPrinter</code>, sends <code class="literal">Greet</code> messages (that are scheduled by the environment) to the <code class="literal">Greeter</code> actor repetitively every second.</p><p>You can execute the example code <a id="id469" class="indexterm"/>within the project by running the command <code class="literal">&gt; ./activator run</code> and choosing the <code class="literal">[2] HelloAkkaScala</code> program. You should see something as is shown in the following code:</p><div class="informalexample"><pre class="programlisting">Multiple main classes detected, select one to run:

 [1] HelloAkkaJava
 [2] HelloAkkaScala

Enter number: 2

[info] Running HelloAkkaScala 
Greeting: hello, akka
Greeting: hello, typesafe
hello, typesafe
hello, typesafe
hello, typesafe
… [press CTRL-C to interrupt]</pre></div></div><div class="section" title="Switching behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>Switching behavior</h2></div></div></div><p>Actors have the ability to <a id="id470" class="indexterm"/>switch their behavior before handling the next message. To illustrate this, let's consider an example of a travel agent actor that needs to reserve both a seat in a flight and a hotel room for its customer. The travel agent is responsible for making sure the booking is transactional, that is, it is only successful if both transport and accommodation are booked, which is illustrated in the following figure:</p><div class="mediaobject"><img src="graphics/3637OS_08_01.jpg" alt="Switching behavior"/></div><p>As it is a recognized best practice to <a id="id471" class="indexterm"/>declare the messages concerning an actor into its companion object, we will express a <code class="literal">Flight</code> actor in the following way:</p><div class="informalexample"><pre class="programlisting">package se.sfjd.ch8

import akka.actor.Actor
import akka.event.LoggingReceive

object Flight {
  case class BookSeat(number:Int) {
    require(number &gt; 0)
  }
  case object Done
  case object Failed
}
class Flight extends Actor {
  import Flight._
  var seatsLeft = 50
  def receive = LoggingReceive {
    case BookSeat(nb) if nb &lt;= seatsLeft =&gt;
      seatsLeft -= nb
      sender ! Done
    case _ =&gt; sender ! Failed
  }
}</pre></div><p>Notice the <code class="literal">require</code> assertion <a id="id472" class="indexterm"/>found in the <code class="literal">BookSeat</code> message declaration. This method is part of <code class="literal">Predef</code>, a global object that includes many useful functionalities imported by default. It enables to do some <span class="emphasis"><em>design-by-contract</em></span> style specification by checking pre- and post-conditions on methods. The <code class="literal">receive</code> method of the <code class="literal">Flight</code> actor is handling one type of message only, <code class="literal">BookSeat(n:Int)</code>, which means reserving <span class="emphasis"><em>n</em></span> seats as long as there are enough seats left for the flight. The <code class="literal">Flight</code> actor updates its state and replies with a <code class="literal">Done</code> message to the sender if there are enough seats left; it replies <code class="literal">Failed</code> otherwise.</p><p>Notice the <code class="literal">LoggingReceive</code> class that surrounds the block handling the actor messages. It is part of the <code class="literal">akka.event</code> package <a id="id473" class="indexterm"/>and is a convenient way of logging information that reaches this block. We will see later on, while executing the sample code, what these messages look like.</p><p>In a similar manner, a <code class="literal">Hotel</code> actor that takes care of reserving a room for <span class="emphasis"><em>n</em></span> persons can be written as follows:</p><div class="informalexample"><pre class="programlisting">object Hotel {
  case class BookRoom(number:Int) {
    require(number &gt; 0)
  }
  case object Done
  case object Failed
}

class Hotel extends Actor {
  import Hotel._
  var roomsLeft = 15
  def receive = LoggingReceive {
    case BookRoom(nb) if nb &lt;= roomsLeft =&gt;
      roomsLeft -= nb
      sender ! Done
    case _ =&gt; sender ! Failed
  }
}</pre></div><p>The travel agent actor is the one that is going to switch its behavior. Once it has sent orders to book plane seats and hotel rooms for a number of people, it will successively change state while expecting answers. Since the messages sent to both <code class="literal">Flight</code> and <code class="literal">Hotel</code> are asynchronous, that is, nonblocking, we do not know which answer will come back first. Furthermore, answers might not come back at all as there is no guarantee at this point that the messages have been delivered or <a id="id474" class="indexterm"/>correctly handled. The code for the <code class="literal">TravelAgent</code> <a id="id475" class="indexterm"/>actor is given as follows:</p><div class="informalexample"><pre class="programlisting">object TravelAgent {
  case class BookTrip(transport: ActorRef, accomodation: ActorRef, nbOfPersons: Int)
  case object Done
  case object Failed
}
class TravelAgent extends Actor {
  import TravelAgent._
  
  def receive = LoggingReceive {
    case BookTrip(flightAgent, hotelAgent, persons) =&gt;
      flightAgent ! Flight.BookSeat(persons)
      hotelAgent ! Hotel.BookRoom(persons)
      context.become(awaitTransportOrAccomodation(flightAgent, hotelAgent,sender))
  }
  
  def awaitTransportOrAccomodation(transport: ActorRef, accomodation: ActorRef, customer:ActorRef): Receive = LoggingReceive {
    case Flight.Done =&gt;
      context.become(awaitAccomodation(customer))
    case Hotel.Done =&gt;
      context.become(awaitTransport(customer))
    case Flight.Failed | Hotel.Failed =&gt;
      customer ! Failed
      context.stop(self) 
  }
  
  def awaitTransport(customer: ActorRef): Receive = LoggingReceive {
    case Flight.Done =&gt;
      customer ! Done
      context.stop(self)
    case Flight.Failed =&gt; 
      customer ! Failed
      context.stop(self)
  }
  
  def awaitAccomodation(customer: ActorRef): Receive = LoggingReceive {
    case Hotel.Done =&gt;
      customer ! Done
      context.stop(self)
    case Hotel.Failed =&gt;
      customer ! Failed
      context.stop(self)
  }
}</pre></div><p>The invocation <code class="literal">context.become(&lt;new behavior method&gt;)</code> switches the behavior of the actor. In the case of this simple travel agent, the behavior will be switched to the expected messages that can be received in any order from the <code class="literal">Flight</code> and <code class="literal">Hotel</code> actors, respectively. If a successful answer is received from either the <code class="literal">Flight</code> or <code class="literal">Hotel</code> actors, the <code class="literal">TravelAgent</code> actor will switch its behavior to expect only the remaining answer.</p><p>Now, we only need a main routine to <a id="id476" class="indexterm"/>create our initial actors and initiate communication with the <code class="literal">TravelAgent</code> actor, as exhibited in the following code:</p><div class="informalexample"><pre class="programlisting">package se.sfjd.ch8

import akka.actor.Actor
import akka.actor.Props
import akka.event.LoggingReceive

class BookingMain extends Actor {
  val flight = context.actorOf(Props[Flight], "Stockholm-Nassau")
  val hotel = context.actorOf(Props[Hotel], "Atlantis")
  val travelAgent = context.actorOf(Props[TravelAgent], "ClubMed")
  travelAgent ! TravelAgent.BookTrip(flight,hotel,10)
    
  def receive = LoggingReceive {
      case TravelAgent.Done =&gt;
        println("Booking Successful")
        context.stop(self)
      case TravelAgent.Failed =&gt;
        println("Booking Failed")
        context.stop(self)
  }
}</pre></div><p>Once the four actor classes involved in the use case have been written in Eclipse, running the program can be done by running an Eclipse configuration. Navigate to <span class="strong"><strong>Run</strong></span> | <span class="strong"><strong>Run Configuration…</strong></span> and edit a new <span class="strong"><strong>Java Application configuration</strong></span> window knowing that the main class to run is the <code class="literal">akka.Main</code> <a id="id477" class="indexterm"/>class of the Akka runtime, as specified in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_08_02.jpg" alt="Switching behavior"/></div><p>The actual main routine we want to run is passed as an argument. To do that, edit the <span class="strong"><strong>Arguments</strong></span> tab of the same window, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_08_03.jpg" alt="Switching behavior"/></div><p>For the debug messages produced by <a id="id478" class="indexterm"/>the <code class="literal">LoggingReceive</code> object to be active, you need to add the VM arguments as specified in the previous screenshot. Clicking on the <span class="strong"><strong>Run</strong></span> button will execute the <code class="literal">BookingMain</code> class within the Akka runtime environment and display the following flow of messages:</p><div class="mediaobject"><img src="graphics/3637OS_08_05.jpg" alt="Switching behavior"/></div><p>If you want to test an alternative scenario, for example, to see the booking failed while reserving the hotel, just put a higher number of persons, that is, <code class="literal">20</code> in <code class="literal">travelAgent ! TravelAgent.BookTrip(flight,hotel,20)</code>, instead of <code class="literal">10</code>.</p></div><div class="section" title="Supervising actors to handle failure"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Supervising actors to handle failure</h2></div></div></div><p>In applications that are running <a id="id479" class="indexterm"/>actors concurrently, there might sometimes be exceptions that are thrown and those make an actor die eventually. As other actors are still running, it might be difficult to notice partial failures. In traditional architectures, where an object calls methods on other objects, the caller is the one receiving the exception. Since it usually blocks waiting for a response, it is also the one responsible to handle the failure. With actors, as all messages are being handled asynchronously without knowing the time it will take before receiving an answer (if any), the context in regards to the sent messages is usually not around anymore to handle the failure; so, it might be more difficult to react on an exception. In any case, something must be done about the failing actor for the application to function properly as its whole.</p><p>This is why Akka embraces the "let it crash" philosophy by providing support to monitor and eventually restart an actor or a group of dependent actors. As actors are normally created by other actors, they can be organized as hierarchies where an actor's parent is also its supervisor. Handling partial failure, therefore, consists of defining some strategies to restart part of the actor hierarchy simultaneously, depending on the situation.</p><p>If we go back to our small travel booking application, we can refactor the <code class="literal">TravelAgent</code> actor to be the supervisor of the <code class="literal">Flight</code> and <code class="literal">Hotel</code> booking actors. Therefore, we can declare the following supervisor strategy within the <code class="literal">TravelAgent</code> class:</p><div class="informalexample"><pre class="programlisting">override val supervisorStrategy = OneForOneStrategy(loggingEnabled = false) {
    case _: Flight.FlightBookingException =&gt;
      log.warning("Flight Service Failed. Restarting")
      Restart
    case _: Hotel.HotelBookingException =&gt;
      log.warning("Hotel Service Failed. Restarting")
      Restart
    case e =&gt;
      log.error("Unexpected failure", e.getMessage)
      Stop
  }</pre></div><p>The two possible strategies are <code class="literal">OneForOneStrategy</code> and <code class="literal">AllForOneStrategy</code>. In the first case, each child of the supervisor will be handled separately, whereas in the second case, all children of the given supervisor will be handled simultaneously.</p><p>The <code class="literal">Flight</code> companion object now contains an additional message that reflects the failure, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">object Flight {
  case class BookSeat(number:Int) {
    require(number &gt; 0)
  }
  case object Done
  case object Failed
  class <span class="strong"><strong>FlightBookingException</strong></span> extends Exception("Unavailable Flight Booking Service")
}</pre></div><p>To simulate the fact that booking the seats on a flight might fail at times, we can introduce the following method call <a id="id480" class="indexterm"/>when handling the <code class="literal">receive</code> method of <a id="id481" class="indexterm"/>the <code class="literal">Flight</code> actor, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">class Flight extends Actor {
  import Flight._
  var seatsLeft = 50
  def receive = LoggingReceive {
    case BookSeat(nb) if nb &lt;= seatsLeft =&gt;
      <span class="strong"><strong>unreliable()</strong></span>
      seatsLeft -= nb
      sender ! Done
    case _ =&gt; sender ! Failed
  }
 
private def <span class="strong"><strong>unreliable()</strong></span>: Unit =
    // the service is only working 75 percent of the time
    if (ThreadLocalRandom.current().nextDouble() &lt; 0.25)
      throw new FlightBookingException
}</pre></div><p>Relaunching the booking scenario with the <code class="literal">Run</code> configuration will display (since the failure happens only 25 percent of the time) the failing message at times, as shown in the following lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>[WARN] [01/24/2014 00:23:50.098] [Main-akka.actor.default-dispatcher-3] [akka://Main/user/app/ClubMed] Flight Service Failed. Restarting</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>For interested readers who want to elaborate more on the topic of supervision, there is a complete and consistent sample called <code class="literal">akka-supervision</code> that is part of the activator templates. It demonstrates the computation of arithmetic expressions, so that nodes that represent subparts of the total computation may fail and be restarted.</p></div><div class="section" title="Testing actor systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Testing actor systems</h2></div></div></div><p>Because of their nondeterministic <a id="id482" class="indexterm"/>nature, concurrent systems require some special care when testing them in contrast to traditional single-threaded architectures. Actor systems are no exceptions; the messages being sent and received asynchronously, there are multiple paths a program flow can follow. Fortunately, Akka provides a lot of support defined in the <code class="literal">akka-testkit</code> module for dealing with tests.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Testing Tools">Chapter 4</a>, <span class="emphasis"><em>Testing Tools</em></span>, we have <a id="id483" class="indexterm"/>already covered a number of examples involving the <code class="literal">scalatest</code> framework by looking at the <code class="literal">test-patterns-scala</code> activator template project. It contains a basic use case regarding the testing of Akka actors through the <code class="literal">testkit</code> module. You can reimport this template project into Eclipse or just open it if it is still in the IDE. The <code class="literal">Test09.scala</code> file exhibits the usage of a testing actor by providing an <code class="literal">ImplicitSender</code> trait that fakes the sending of messages to two actors under test. The first actor under test is a simple echo actor, whereas the second is calling a location service asynchronously that calculates the latitude and longitude of a given address. The syntax of the <code class="literal">GeoActor</code> object, given in the following test, should look familiar since it uses the dispatch libraries in the same way as we have seen in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>:</p><div class="informalexample"><pre class="programlisting">package scalatest

import akka.actor.ActorSystem
import akka.actor.Actor
import akka.actor.Props
import akka.testkit.TestKit
import org.scalatest.WordSpecLike
import org.scalatest.matchers.MustMatchers
import org.scalatest.BeforeAndAfterAll
import akka.testkit.ImplicitSender

//http://doc.akka.io/docs/akka/snapshot/scala/testing.html
object Setup {
  class EchoActor extends Actor {
    def receive = {
      case x =&gt; sender ! x
    }
  }

  case class Address(street: String,
                      city: String,
                      state: String,
                      zip: String)
//see https://developers.google.com/maps/documentation/geocoding/#Limits
class GeoActor extends Actor {
  def receive = {
    case Address(street,city,state,zip) =&gt; {
      import dispatch._, Defaults._
      val svc = url(s"http://maps.googleapis.com/maps/api/geocode/xml?address=${street},${city},${state},${zip}&amp;sensor=true".replace(" ","+"))
      val response = Http(svc OK as.xml.Elem)
      val lat = (for {
        elem &lt;- response() \\ "geometry" \ "location" \ "lat"
      } yield elem.text).head
      val lng = (for {
        elem &lt;- response() \\ "geometry" \ "location" \ "lng"
      } yield elem.text).head
      sender ! s"${lat},${lng}"
    }
    case _ =&gt; sender ! "none"
  }
 }
}</pre></div><p>In the main routine of the test case, <a id="id484" class="indexterm"/>we mix in the <code class="literal">ImplicitSender</code> <a id="id485" class="indexterm"/>trait and then <a id="id486" class="indexterm"/>invoke the <code class="literal">expectMsg</code> method :</p><div class="informalexample"><pre class="programlisting">class Test09(asys: ActorSystem) extends TestKit(asys) with ImplicitSender with WordSpecLike with MustMatchers with BeforeAndAfterAll {
  import Setup._
  def this() = this(ActorSystem("Setup"))

  override def afterAll {
    TestKit.shutdownActorSystem(system)
  }

  "An Echo actor" must {
    "return messages" in {
      val echo = system.actorOf(Props[EchoActor])
      echo ! "hello world"
      expectMsg("hello world")
    }
  }
  
  "Geo actor" must {
    "send back lat,lon" in {
      val geo = system.actorOf(Props[GeoActor])
      geo ! Address("27 South Park Avenue","San Francisco","CA","94107")
      expectMsg("37.7822991,-122.3930776")
      }
    }
  }</pre></div><p>The <code class="literal">expectMsg()</code> method has <a id="id487" class="indexterm"/>the <a id="id488" class="indexterm"/>role of an assertion that takes duration as a parameter, so that it does not wait forever for the reply to come back. Instead, it will throw an exception if the specified time has <a id="id489" class="indexterm"/>passed and it has not yet received the answer it was waiting for.</p></div><div class="section" title="Exploring further with Akka"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Exploring further with Akka</h2></div></div></div><p>In addition to the useful functionalities of actor messaging and supervision, Akka includes support for many other, more advanced features. Among them are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It monitors the lifecycle of actors through the <code class="literal">DeathWatch</code> API.</li><li class="listitem" style="list-style-type: disc">It persists actor state for recovery after failure.</li><li class="listitem" style="list-style-type: disc">It remotes with actors, that is, communicates with actors in a distributed environment and in a transparent way.</li><li class="listitem" style="list-style-type: disc">It clusters to handle failure in a distributed environment. A sample of the clustering features is also available as the <code class="literal">akka-clustering</code> activator template.</li></ul></div><p>These features are <a id="id490" class="indexterm"/>out of the scope of this book, but they are extensively documented on the Akka site and available at <a class="ulink" href="http://akka.io/docs/">http://akka.io/docs/</a>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Summary</h1></div></div></div><p>In this chapter, we have first studied how to deal with asynchronous Scala code using the Async toolkit, which simplifies writing nonblocking code using Futures and Promises. We then moved to the concurrency topic by introducing the Akka framework based on the actor paradigm.</p><p>Concurrent and distributed systems is such a large topic that we have only introduced some basic usage scenarios of actor systems. We have learned that since the behavior and state of actors are encapsulated, actor systems are easy to reason about. Moreover, the supervision and clustering support in Akka makes the handling of failure and distribution very robust. The material covered in this chapter is just a glimpse of what the toolkit can achieve; the very extended and well-written documentation of the Akka project will guide you through creating scalable and distributed applications. Programming asynchronous, concurrent, and distributed systems is often a complex task, and the actor model makes it more manageable.</p><p>Since Akka is also the foundation of the <code class="literal">Play</code> Framework, we will continue to use it through the next chapter. We will build reactive web applications in <code class="literal">Play</code> to illustrate how to create modern applications that need to handle streams of data and push information into the browser.</p></div></body></html>