- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating Adapters to Interact with the Outside World
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建适配器以与外部世界交互
- en: There is a time in software development at which we need to decide which technologies
    will be supported by a system. We’ve discussed in previous chapters how technological
    choices should not be the primary driver for developing hexagonal applications.
    In fact, applications based on this architecture present a high degree of changeability,
    enabling a system to be integrated with different technologies with as little
    friction as possible. This is because the **hexagonal architecture** establishes
    a clear frontier between which part of the code is related to business and which
    is related to technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发过程中，存在一个时刻我们需要决定哪些技术将被系统所支持。在前面的章节中，我们讨论了技术选择不应该是开发六边形应用的主要驱动因素。实际上，基于这种架构的应用具有高度的可变性，使得系统可以尽可能少地摩擦与不同技术集成。这是因为**六边形架构**在代码的哪些部分与业务相关以及哪些部分与技术相关之间建立了一个清晰的边界。
- en: In this chapter, we’re going to explore the hexagonal approach to establishing
    this frontier. We’ll learn about the role adapters play when we need to set up
    technologies or protocols to enable a hexagonal application to communicate with
    the outside world.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨建立这种边界的六边形方法。我们将学习在需要设置技术或协议以使六边形应用能够与外部世界通信时，适配器所扮演的角色。
- en: 'We’ll learn about the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Understanding adapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解适配器
- en: Using input adapters to allow driving operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入适配器以允许驱动操作
- en: Using output adapters to speak with different data sources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输出适配器与不同的数据源进行通信
- en: By the end of this chapter, you’ll know how input adapters, in conjunction with
    input ports, can be used to expose the same software features to work with different
    technologies. In the same vein, you will learn how output adapters are powerful
    in making your application more versatile when it needs to talk to different data
    source technologies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何使用输入适配器，结合输入端口，将相同的软件功能暴露给不同的技术进行工作。同样，你将学习到输出适配器在使应用在与不同的数据源技术通信时更加灵活方面的强大作用。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: To compile and run the code examples presented in this chapter, you need the
    latest `curl` and `jq`. All those tools are available for **Linux**, **Mac**,
    and **Windows** operating systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，你需要最新的`curl`和`jq`。所有这些工具都可在**Linux**、**Mac**和**Windows**操作系统上使用。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter04)。
- en: Understanding adapters
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解适配器
- en: 'In hexagonal architecture, adapters have a different role from those employed
    as a design pattern in object-oriented languages. As a design pattern, we use
    adapters to make the interfaces of two diverging classes compatible. In the hexagonal
    architecture, we use adapters to allow a system to be compatible with different
    technologies or protocols. Although the adapter’s role as a hexagonal architecture
    concept or as a design pattern may differ, it would be correct to state that both
    approaches share the same purpose: to adapt something to fit correctly into another
    thing.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在六边形架构中，适配器的作用与在面向对象语言中作为设计模式所使用的适配器不同。作为一个设计模式，我们使用适配器使两个不同类的接口兼容。在六边形架构中，我们使用适配器使系统能够与不同的技术或协议兼容。尽管适配器作为六边形架构概念或作为设计模式的作用可能不同，但可以正确地说，这两种方法具有相同的目的：使某物适应正确地嵌入到另一物中。
- en: A practical analogy to understand the role adapters play in hexagonal architecture
    is about remote connections to a computer. Every modern operating system is compatible
    with remote connection protocols. In the past (and even today in certain situations),
    it was common to use **Telnet** to open a remote connection to a computer. Over
    time, other protocols emerged, such as **SSH** for console connections, **RDP**,
    and **Virtual Network Computing** (**VNC**) for a graphical alternative.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解适配器在六边形架构中扮演的角色，一个实用的类比是关于计算机的远程连接。每个现代操作系统都兼容远程连接协议。在过去（甚至在某些情况下，今天），使用**Telnet**打开到计算机的远程连接是常见的。随着时间的推移，出现了其他协议，如用于控制台连接的**SSH**、**RDP**以及用于图形替代的**虚拟网络计算**（**VNC**）。
- en: Those protocols only define how you’re going to access the operating system,
    and once you’re there, you can execute commands and have access to the features
    that an operating system provides. It’s not uncommon for an operating system to
    offer more than one protocol to allow remote connection. That’s good because it
    widens the communication possibilities. There may be situations in which it’s
    necessary to support both Telnet and SSH connections simultaneously, maybe because
    there is an unusual client that works only with Telnet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议仅定义了您如何访问操作系统，一旦您进入其中，您就可以执行命令并访问操作系统提供的功能。操作系统提供多个协议以允许远程连接并不罕见。这是好事，因为它扩大了通信的可能性。可能存在需要同时支持Telnet和SSH连接的情况，可能是因为有一个不寻常的客户，它只使用Telnet。
- en: 'By using the preceding analogy, we can replace the operating system with an
    application developed using **Java**, or any other programming language, and we
    can replace remote connection protocols such as SSH and Telnet with HTTP-based
    communication protocols, such as **REST** and **gRPC**. Assuming our Java application
    is a hexagonal one, the features offered by such applications are organized into
    use cases, ports, and business rules from the **Application** and **Domain** hexagons.
    If you want to make those features available for both REST and gRPC clients, you
    need to create REST and gRPC adapters. Adapters used to expose application features
    are called **input adapters**. To connect those input adapters to the rest of
    our system, we associate input ports with input adapters, as illustrated in the
    following figure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用前面的类比，我们可以将操作系统替换为使用**Java**（或任何其他编程语言）开发的程序，并将远程连接协议（如SSH和Telnet）替换为基于HTTP的通信协议，如**REST**和**gRPC**。假设我们的Java应用程序是六边形的，这些应用程序提供的功能被组织为用例、端口和业务规则，这些规则来自**应用程序**和**领域**六边形。如果您想使这些功能对REST和gRPC客户端都可用，您需要创建REST和gRPC适配器。用于公开应用程序功能的适配器称为**输入适配器**。为了将这些输入适配器连接到我们系统的其余部分，我们将输入端口与输入适配器关联，如下图所示：
- en: '![Figure 4.1 – The relationship between adapters and ports](img/B19777_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 适配器与端口之间的关系](img/B19777_04_01.jpg)'
- en: Figure 4.1 – The relationship between adapters and ports
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 适配器与端口之间的关系
- en: 'We can define input adapters to allow users and other systems to interact with
    the application. In the same way, we can also define output adapters to translate
    data generated by the hexagonal application and communicate with external systems.
    Here we can see that both input and output adapters live in the extremities of
    the **Framework** hexagon:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义输入适配器，以便用户和其他系统与应用程序进行交互。同样，我们也可以定义输出适配器，以将六边形应用程序生成的数据转换为外部系统可理解的形式。在这里，我们可以看到输入和输出适配器都位于**框架**六边形的端点：
- en: '![Figure 4.2 – The location of input and output adapters](img/B19777_04_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 输入和输出适配器的位置](img/B19777_04_02.jpg)'
- en: Figure 4.2 – The location of input and output adapters
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 输入和输出适配器的位置
- en: Let’s explore in the next section how we can work with input adapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用输入适配器。
- en: Using input adapters to allow driving operations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入适配器来允许驱动操作
- en: You may have heard before that if there’s something we can always count on,
    it’s that things will always change. And when we talk about technological changes,
    that statement is even stronger. We live in an era where computers are not as
    expensive as they used to be in the past. No matter whether we’re dealing with
    desktops, mobile, or cloud computing, year by year, computer resources, in general,
    become cheaper and more accessible to everyone. This accessibility means that
    more people tend to be involved and can collaborate with software development
    initiatives.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前听说过，如果我们能始终依赖的东西，那就是事情总是会变化。当我们谈论技术变革时，这个说法就更加明显了。我们生活在一个计算机不再像过去那样昂贵的时代。无论我们是在处理台式机、移动设备还是云计算，每年，计算机资源总体上变得更加便宜，并且对每个人来说都更加容易获得。这种可访问性意味着更多的人倾向于参与，并且可以参与软件开发项目。
- en: That growing collaboration results in newer programming languages, tools, and
    development frameworks to support the creative effort to solve people’s problems
    with better and modern solutions. In this innovative and technological heterogeneous
    context, a good amount of current software development is made. One of the concerns
    that arises when developing software in this context is how a system will stay
    relevant and profitable in the face of constant technological changes. If a system
    is designed to intertwine business rules with technological details, it won’t
    be easy to incorporate new technology without significant refactoring. In hexagonal
    architecture, input adapters are the elements that help us to make the software
    compatible with different technologies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不断增长的协作导致了新的编程语言、工具和开发框架的产生，以支持用更好和更现代的解决方案来解决人们问题的创造性努力。在这个创新和技术异构的背景下，大量的当前软件开发工作得以进行。在这种背景下开发软件时出现的一个问题是，面对不断的技术变革，一个系统将如何保持相关性和盈利性。如果一个系统被设计成将业务规则与技术细节交织在一起，那么在不进行重大重构的情况下，很难融入新技术。在六边形架构中，输入适配器是帮助我们使软件与不同技术兼容的元素。
- en: Input adapters are like the remote communication protocols mentioned in the
    example presented in the previous section. That comparison is valid because input
    adapters work like protocols, defining which technologies are supported as a means
    to access the features provided by a hexagonal system. Input adapters mark a clear
    frontier between what is inside the hexagon and what is outside, and perform what
    we call driving operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输入适配器就像在前一节中提到的示例中提到的远程通信协议。这种比较是有效的，因为输入适配器的工作方式就像协议一样，定义了哪些技术被支持，作为访问六边形系统提供的功能的一种手段。输入适配器在六边形内部和外部之间划定了明确的边界，并执行我们所说的驱动操作。
- en: From outside the hexagon, there may be users or other systems interacting with
    the hexagonal application. We have learned that these users and systems are also
    known as primary actors, playing a pivotal role in shaping application use cases.
    The interaction between primary actors and the hexagonal application occurs through
    input adapters. Such interaction is defined by driving operations. We call them
    driving because primary actors drive, in the sense that they initiate and influence
    the state and behavior of hexagonal systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从六边形外部来看，可能有用户或其他系统与六边形应用程序进行交互。我们已经了解到，这些用户和系统也被称为主要演员，在塑造应用程序用例方面发挥着关键作用。主要演员与六边形应用程序之间的交互是通过输入适配器进行的。这种交互由驱动操作定义。我们称它们为驱动操作，因为在六边形系统中，主要演员驱动着，即它们启动并影响系统的状态和行为。
- en: Input adapters, when put together, form the hexagonal application’s API. Because
    input adapters are in this boundary that exposes the hexagonal system to the outside
    world, they naturally become the interface for anyone interested in interacting
    with the system. As we progress in the book, we’ll see how to leverage the input
    adapters’ arrangement to structure and expose the application APIs, using tools
    such as **Swagger**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入适配器组合在一起时，就形成了六边形应用程序的API。因为输入适配器处于这个边界，它将六边形系统暴露给外部世界，因此它们自然成为任何希望与系统交互的人的接口。随着我们在本书的进展，我们将看到如何利用输入适配器的布局来结构和暴露应用程序API，使用诸如**Swagger**等工具。
- en: We have emphasized the adapters’ characteristics to make a system compatible
    with different technologies or protocols. A more **Domain-Driven Design** (**DDD**)
    approach suggests other purposes for using an adapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了适配器的特性，以使系统与不同的技术或协议兼容。一种更**领域驱动设计（DDD**）的方法建议使用适配器的其他目的。
- en: 'A prevalent concern in DDD-based architectures is about integrating the elements
    of a legacy system into a new one. This occurs in scenarios where a legacy system
    with relevant knowledge crunched into its domain model solves some important problems
    but also shows inconsistencies in its design. You don’t want to give up the legacy
    system, but you also don’t want the new system design to be influenced by the
    legacy system’s design. To tackle this situation, you can employ what *Implementing
    Domain-Driven Design* by Vaughn Vernon and *Domain-Driven Design: Tackling Complexity
    in the Heart of Software* by Eric Evans call an **anti-corruption layer**. This
    layer is based on the adapters used to integrate bounded contexts from both the
    legacy and the new systems. In such a scenario, the adapters are responsible for
    preventing the new system’s design from being contaminated by the legacy system’s
    design.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 DDD 的架构中，一个普遍关注的问题是关于将遗留系统的元素集成到新系统中。这种情况发生在遗留系统（其中包含相关知识的领域模型）解决了某些重要问题但同时也显示出其设计的不一致性时。你不想放弃遗留系统，但也不想让新系统的设计受到遗留系统设计的影响。为了应对这种情况，你可以采用
    Vaughn Vernon 的 *实现领域驱动设计* 和 Eric Evans 的 *领域驱动设计：软件核心的复杂性处理* 中所提到的 **反腐败层**。这个层基于用于将遗留系统和新系统的有界上下文集成的适配器。在这种情况下，适配器负责防止新系统的设计受到遗留系统设计的影响。
- en: Although we’re not applying this kind of usage of adapters in the hexagonal
    architecture, it’s important to be aware that we can use this DDD-based adapter
    approach for a hexagonal system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不在六边形架构中应用这种适配器的使用方式，但重要的是要意识到我们可以使用这种基于 DDD 的适配器方法来构建六边形系统。
- en: We learned that the connection between primary actors and the hexagonal application
    occurs through input adapters. Let’s see now how to make input adapters connect
    to other hexagons in the system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到主要演员与六边形应用程序之间的连接是通过输入适配器实现的。现在让我们看看如何使输入适配器连接到系统中的其他六边形。
- en: Creating input adapters
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输入适配器
- en: '**Input ports** are the means through which we implement use cases, specifying
    how an input port performs the operations to achieve use case goals. The input
    port object needs to receive what Jacobson (1992) called a *stimulus* to perform
    its operations. This stimulus is nothing more than an object calling another.
    The input port object receives all the necessary data to conduct its operations
    through the stimulus sent by an input adapter. However, it’s at this stage that
    eventual transformations may take place to convert input data into a format that’s
    compatible with the Domain hexagon.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入端口**是我们实现用例的手段，它指定了输入端口如何执行操作以实现用例目标。输入端口对象需要接收 Jacobson (1992) 所称的 *刺激*
    来执行其操作。这种刺激不过是一个对象调用另一个对象。输入端口对象通过输入适配器发送的刺激接收执行其操作所需的所有必要数据。然而，正是在这个阶段，可能会发生最终的转换，将输入数据转换为与领域六边形兼容的格式。'
- en: 'In the previous chapter, we created a use case to add networks to a router.
    To achieve the use case goals, we’ll create two input adapters: an adapter for
    communication through HTTP REST and another for command-line execution. In the
    following UML diagram, we have **RouterNetworkAdapter** as an abstract parent
    class extended by the **RouterNetworkRestAdapter** and **RouterNetworkCLIAdapter**
    classes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个用例来向路由器添加网络。为了实现用例目标，我们将创建两个输入适配器：一个用于通过 HTTP REST 进行通信的适配器，另一个用于命令行执行。在下面的
    UML 图中，我们有一个 **RouterNetworkAdapter** 作为抽象父类，由 **RouterNetworkRestAdapter** 和
    **RouterNetworkCLIAdapter** 类扩展：
- en: '![Figure 4.3 – UML representation of input adapters](img/B19777_04_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 输入适配器的 UML 表示](img/B19777_04_03.jpg)'
- en: Figure 4.3 – UML representation of input adapters
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 输入适配器的 UML 表示
- en: We will define an adapter abstract base class, followed by two implementations,
    one for an adapter to receive data from HTTP REST connections and another for
    the console `STDIN` connection. To simulate access to these two adapters, we’ll
    create a client class to bootstrap the application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个适配器抽象基类，随后是两个实现，一个用于适配器从 HTTP REST 连接接收数据，另一个用于控制台 `STDIN` 连接。为了模拟对这些两个适配器的访问，我们将创建一个客户端类来启动应用程序。
- en: The base adapter
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础适配器
- en: 'Let’s start by defining the `RouterNetworkAdapter` abstract base class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义 `RouterNetworkAdapter` 抽象基类：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The idea of this base adapter is to provide standard operations for communicating
    with the adapter’s correspondent input port. In that case, we use the `addNetworkToRouter`
    adapter method to receive the parameters required to build the `RouterID` and
    `Network` objects, which are utilized to start the use case operation to add the
    network to a router. These parameters may come from different sources, either
    via an HTTP request or via the shell/console with `STDIN`, but they are treated
    the same way once they arrive at the `addNetworkToRouter` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础适配器的想法是提供与适配器的对应输入端口通信的标准操作。在这种情况下，我们使用`addNetworkToRouter`适配器方法来接收构建`RouterID`和`Network`对象所需的参数，这些参数被用来启动用例操作，将网络添加到路由器。这些参数可能来自不同的来源，无论是通过HTTP请求还是通过shell控制台中的`STDIN`，但一旦到达`addNetworkToRouter`方法，它们都被以相同的方式处理。
- en: We don’t refer to input ports directly. Instead, we utilize a use case interface
    reference. This use case reference is passed and initialized by the input adapter’s
    constructor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接引用输入端口。相反，我们利用用例接口引用。这个用例引用由输入适配器的构造函数传递和初始化。
- en: The REST input adapter
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: REST输入适配器
- en: 'Now that we have defined the base `RouterNetworkAdapter` abstract class, we
    can proceed to create the REST adapter. We start by defining the `RouterNetworkRestAdapter`
    constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了基础的`RouterNetworkAdapter`抽象类，我们可以继续创建REST适配器。我们首先定义`RouterNetworkRestAdapter`构造函数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use the `RouterNetworkRestAdapter` constructor to receive and initialize
    the `RouterNetworkUseCase` use case reference.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`RouterNetworkRestAdapter`构造函数来接收和初始化`RouterNetworkUseCase`用例引用。
- en: 'The following code shows us how a client could call-initialize this `RouterNetworkRestAdapter`
    input adapter:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了客户端如何调用初始化这个`RouterNetworkRestAdapter`输入适配器：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The intent here is to express that the REST input adapter requires an H2 in-memory
    database output adapter. Here, we’re explicitly stating which output adapter object
    the input adapter needs to perform its activities. That can be considered a vanilla
    approach, where we don’t use framework-based dependency injection techniques such
    as **CDI beans**. Later on, all those adapter constructors can be removed to use
    dependency injection annotations from frameworks such as **Quarkus** or **Spring**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的意图是表达REST输入适配器需要一个H2内存数据库输出适配器。在这里，我们明确指出输入适配器需要哪个输出适配器对象来执行其活动。这可以被认为是一种纯方法，其中我们不使用基于框架的依赖注入技术，如**CDI
    beans**。稍后，所有这些适配器构造函数都可以移除，以使用来自框架如**Quarkus**或**Spring**的依赖注入注解。
- en: 'After defining the `RouterNetworkAdapter` constructor, we then implement the
    `processRequest` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`RouterNetworkAdapter`构造函数之后，我们接着实现`processRequest`方法：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This method receives an `httpServer` object, which is used to create the HTTP
    endpoint to receive `GET` requests at `/network/add`. The client code that calls
    `processRequest` is similar to the following excerpt:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个`httpServer`对象，用于创建接收`/network/add`路径的`GET`请求的HTTP端点。调用`processRequest`的客户端代码类似于以下摘录：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The REST adapter receives user data via an HTTP request, parses request parameters,
    and uses them to call `addNetworkToRouter` defined in the `RouterNetworkAdapter`
    parent class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: REST适配器通过HTTP请求接收用户数据，解析请求参数，并使用它们来调用定义在`RouterNetworkAdapter`父类中的`addNetworkToRouter`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Remember that the input adapter is responsible for converting user data into
    suitable parameters used to trigger an input port by using its use case reference:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，输入适配器负责将用户数据转换为触发输入端口所需的适当参数，这是通过使用其用例引用来完成的：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At this moment, the data leaves the Framework hexagon and goes to the `STDIN`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时候，数据离开框架六边形，并进入`STDIN`。
- en: The CLI input adapter
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CLI输入适配器
- en: 'To create the second input adapter, we again extend the base adapter class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建第二个输入适配器，我们再次扩展基础适配器类：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We define the `RouterNetworkCLIAdapter` constructor to receive and initialize
    the `RouterNetworkUseCase` use case that this input adapter needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`RouterNetworkCLIAdapter`构造函数，用于接收和初始化这个输入适配器所需的`RouterNetworkUseCase`用例。
- en: For the CLI input adapter, we use a different output adapter. Instead of persisting
    an in-memory database, this output adapter uses the filesystem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CLI输入适配器，我们使用不同的输出适配器。而不是持久化内存数据库，这个输出适配器使用文件系统。
- en: 'The following code shows us how a client could initialize the `RouterNetworkCLIAdapter`
    input adapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了客户端如何初始化`RouterNetworkCLIAdapter`输入适配器：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we get a `RouterNetworkOutputPort` output port reference. Then, with
    that reference, we retrieve a `RouterNetworkUseCase` use case. Finally, we get
    `RouterNetworkAdapter` using the use case defined previously.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取一个 `RouterNetworkOutputPort` 输出端口引用。然后，使用该引用，我们检索一个 `RouterNetworkUseCase`
    用例。最后，我们使用之前定义的用例获取 `RouterNetworkAdapter`。
- en: 'The following is how we implement the `processRequest` method for the CLI adapter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们为 CLI 适配器实现 `processRequest` 方法的步骤：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the REST adapter, we have the `httpParams` method to retrieve data from an
    HTTP request. Now, in `processRequest` from the CLI adapter, we have a `stdinParams`
    method to retrieve data from the console.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REST 适配器中，我们有 `httpParams` 方法从 HTTP 请求中检索数据。现在，在 CLI 适配器的 `processRequest`
    中，我们有 `stdinParams` 方法从控制台检索数据。
- en: 'The `processRequest` methods from the REST and CLI adapters have differences
    in how they handle input data, but both have one thing in common. Once they capture
    input data into the `params` variable, they both call the `addNetworkToRouter`
    method inherited from the adapter base class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 REST 和 CLI 适配器的 `processRequest` 方法在处理输入数据方面存在差异，但它们有一个共同点。一旦它们将输入数据捕获到 `params`
    变量中，它们都会调用从适配器基类继承的 `addNetworkToRouter` 方法：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From this point on, the data follows the same flow as the one described in the
    REST adapter scenario, where the input adapter calls the input port through a
    use case interface reference.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，数据遵循与 REST 适配器场景中描述的相同流程，其中输入适配器通过用例接口引用调用输入端口。
- en: Now that we’ve finished creating the REST and CLI input adapters, let’s see
    how to call these adapters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 REST 和 CLI 输入适配器的创建，让我们看看如何调用这些适配器。
- en: Calling the input adapters
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用输入适配器
- en: 'Here is the client code to control which adapter to choose:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是控制选择哪个适配器的客户端代码：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we pass `rest` as a parameter when executing the program, the `switch`-`case`
    condition will create a REST adapter instance and call the `rest` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在执行程序时传递 `rest` 作为参数，`switch`-`case` 条件将创建一个 REST 适配器实例并调用 `rest` 方法：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `rest` method, in turn, calls the `processRequest` method from the REST
    input adapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`rest` 方法反过来调用 REST 输入适配器的 `processRequest` 方法。
- en: 'Otherwise, if we pass the `cli` parameter when executing the program, `switch`-`case`
    will, by default, create a CLI adapter and call the `cli` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果我们在执行程序时传递 `cli` 参数，`switch`-`case` 将默认创建一个 CLI 适配器并调用 `cli` 方法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `cli` method then calls the `processRequest` method from the CLI input adapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli` 方法随后调用 CLI 输入适配器的 `processRequest` 方法。'
- en: 'Here are the steps for calling the input adapters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用输入适配器的步骤如下：
- en: 'With the code sample from GitHub within the `chapter4` directory, you can compile
    the application by running the following command:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `chapter4` 目录中的 GitHub 代码示例中，你可以通过运行以下命令来编译应用程序：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar rest
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar rest
- en: 'GET request to create and add a network:'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发送 GET 请求以创建和添加网络：
- en: '[PRE15]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar cli
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ java -jar target/chapter04-1.0-SNAPSHOT-jar-with-dependencies.jar cli
- en: 'Please inform the Router ID:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请告知路由器 ID：
- en: ca23800e-9b5a-11eb-a8b3-0242ac130003
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ca23800e-9b5a-11eb-a8b3-0242ac130003
- en: 'Please inform the IP address:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请告知 IP 地址：
- en: 40.0.0.0
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 40.0.0.0
- en: 'Please inform the Network Name:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请告知网络名称：
- en: Finance
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 金融
- en: 'Please inform the CIDR:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请告知 CIDR：
- en: '8'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The application will ask you to specify the router ID and other network additional
    details for calling the CLI adapter. Here, we gave the same data as used to call
    the REST adapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将要求你指定路由器 ID 和其他网络附加详细信息以调用 CLI 适配器。在这里，我们使用了与调用 REST 适配器相同的数据。
- en: In this section, we learned how to use input adapters to expose hexagonal application
    features. By defining first a base input adapter, we extended it to create a REST
    adapter for HTTP requests and a CLI adapter for console/`STDIN` requests. This
    arrangement helped us grasp the fundamental role input adapters play in exploring
    different ways to access the same functionality in the hexagonal system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用输入适配器来公开六边形应用程序功能。通过首先定义一个基本输入适配器，我们扩展了它以创建用于 HTTP 请求的 REST 适配器和用于控制台/`STDIN`
    请求的 CLI 适配器。这种安排帮助我们理解输入适配器在探索以不同方式访问六边形系统中相同功能的基本作用。
- en: Input adapters are the front doors through which we access all the features
    a hexagonal application can provide. With input adapters, we can easily make the
    system accessible through different technologies without disturbing business logic.
    By the same token, we can make the hexagonal application speak to varying data
    sources. We accomplish that with output adapters, which we’ll see in the next
    section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输入适配器是我们进入所有六边形应用程序可以提供的功能的门户。通过输入适配器，我们可以轻松地使系统通过不同的技术变得可访问，而不会干扰业务逻辑。同样地，我们可以使六边形应用程序与不同的数据源进行通信。我们将在下一节中看到，这是通过输出适配器实现的。
- en: "Using output adapters to speak with different \Ldata sources"
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输出适配器与不同的数据源进行通信
- en: What characterizes an object-oriented system is its ability to treat data and
    behavior as closely related things. This proximity happens to mimic the way things
    are in the real world. Both animate and inanimate beings have attributes and can
    perform or be the target of some action. For people starting to learn object-oriented
    programming, we present examples such as a car, which has four wheels and can
    drive – wheels being the data and driving the behavior. Examples such as this
    express the fundamental principle that data and behavior should not be treated
    as separate things but should be united inside what we call objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象系统的特点在于其将数据和行为视为紧密相关的事物。这种紧密性恰好模仿了现实世界中的事物。无论是生物还是非生物，都具有属性，并能执行或成为某些动作的目标。对于刚开始学习面向对象编程的人来说，我们提供了例如汽车这样的例子，它有四个轮子并能驾驶——轮子是数据，驾驶是行为。这样的例子表达了这样一个基本原理：数据和行为不应被视为独立的事物，而应在我们所说的对象内部统一。
- en: This object idea has laid the ground for the development of vast and complex
    systems over the last decades. A good part of those systems is business applications
    running on enterprise environments. The object paradigm has conquered enterprise
    development because its high-level approach has allowed people to be more productive
    and precise when creating software to solve business problems. The procedural
    paradigm was cumbersome and too low-level for the demands of enterprises.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象理念为过去几十年中庞大而复杂的系统的发展奠定了基础。这些系统中的很大一部分是在企业环境中运行的商业应用程序。面向对象范式征服了企业开发，因为其高级方法使得人们在创建软件以解决商业问题时更加高效和精确。过程范式对于企业的需求来说既繁琐又过于底层。
- en: In addition to object-oriented languages, enterprise software also relies on
    ways to obtain and persist data. It’s hard to imagine a system that is not integrated
    with data sources such as databases, message queues, or file servers, for example.
    The need to store things has always been present in computation. The problem,
    though, has been how this need has influenced and dictated the whole software
    structure. With the advent of **RDBMSs**, there comes the requirement to formalize
    data through **schemas** as well. These schemas, then, serve as a reference for
    establishing data relationships and how the application deals with such relationships.
    After some time, people started to look for alternatives to avoid the formalism
    and strict normalization principles imposed by RDBMSs. The problem is not in the
    formalism per se but in using RDBMSs where there’s no need for that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向对象的语言之外，企业软件还依赖于获取和持久化数据的方法。很难想象一个没有与数据库、消息队列或文件服务器等数据源集成的系统，例如。存储东西的需求始终存在于计算中。然而，问题在于这种需求如何影响和决定了整个软件结构。随着**关系数据库管理系统（RDBMS**）的出现，也出现了通过**模式**正式化数据的要求。然后，这些模式作为建立数据关系以及应用程序如何处理这些关系的参考。过了一段时间，人们开始寻找替代方案以避免RDBMSs强加的正式化和严格的规范化原则。问题本身并不在于正式化，而在于在不必要的情况下使用RDBMSs。
- en: As an alternative to RDBMSs, there came **NoSQL** databases, proposing a way
    to store data that didn’t rely on tables, columns, and schemas as a means of data
    organization. The NoSQL approach offers different data storage techniques, based
    on documents, key-value stores, wide-column stores, and graphs. Not constrained
    solely by the RDBMS approach, software developers then started using these NoSQL
    techniques to meet business requirements in a better way and avoid cumbersome
    solutions that relied on RDBMSs because there were no alternatives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为关系型数据库管理系统（RDBMS）的替代，出现了**NoSQL**数据库，提出了一种不依赖于表、列和模式作为数据组织手段的数据存储方式。NoSQL方法提供了基于文档、键值存储、宽列存储和图的不同数据存储技术。不受RDBMS方法的限制，软件开发者开始使用这些NoSQL技术以更好地满足业务需求，并避免依赖于RDBMS的繁琐解决方案，因为当时没有替代品。
- en: Aside from databases, other data sources have been used to fulfill software
    needs to handle data. Filesystems, message brokers, directory-based storage (**LDAP**),
    and mainframe storage, to name a few, are some of the ways software can handle
    data. In the world of cloud computing, it’s becoming more natural to integrate
    a system with different technologies to send or receive data. This integration
    presents some challenges in software development because the system now needs
    to understand and make itself understandable in a heterogeneous technological
    context. That situation is even more exacerbated by architectures such as microservices
    that promote this heterogeneity. To tackle this challenge, we need techniques
    to overcome the challenges of technologically heterogeneous environments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数据库之外，其他数据源也被用来满足软件处理数据的需求。文件系统、消息代理、基于目录的存储（**LDAP**）和主机存储，仅举几例，这些都是软件可以处理数据的方式。在云计算的世界里，将系统与不同的技术集成以发送或接收数据变得越来越自然。这种集成在软件开发中带来了一些挑战，因为系统现在需要理解并使自己在异构技术环境中易于理解。这种情况在如微服务这样的架构中变得更加严重，这些架构促进了这种异构性。为了应对这一挑战，我们需要克服技术异构环境挑战的技术。
- en: We saw in the previous section that we can plug multiple input adapters into
    the same input port. This also applies to output adapters and ports. Next, we’ll
    see how to create output adapters and plug them into the hexagon system output
    ports.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了我们可以将多个输入适配器插入到同一个输入端口。这也适用于输出适配器和端口。接下来，我们将看到如何创建输出适配器并将它们插入到六边形系统的输出端口。
- en: Creating output adapters
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输出适配器
- en: Together with input adapters, output adapters are the second component that
    comprises the Framework hexagon. The output adapter’s role in a hexagonal architecture
    is to deal with driven operations. Remember, driven operations are those initiated
    by the hexagonal application itself to interact with external systems to send
    or receive some data. These driven operations are described through use cases
    and are triggered by operations present in the use case’s input port implementations.
    Whenever a use case states the need to deal with data that lives in external systems,
    this means the hexagonal application will require at least one output adapter
    and port to meet such requirements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入适配器一起，输出适配器是构成框架六边形的第二个组件。在六边形架构中，输出适配器的角色是处理驱动操作。记住，驱动操作是由六边形应用程序本身发起的，以与外部系统交互发送或接收一些数据。这些驱动操作通过用例来描述，并由用例输入端口实现中的操作触发。每当用例声明需要处理存在于外部系统中的数据时，这意味着六边形应用程序至少需要一个输出适配器和端口来满足这些要求。
- en: We learned that output ports present in the Application hexagon express interactions
    with external systems in abstract ways. Output adapters, in turn, have the responsibility
    to describe, in concrete terms, how these interactions will occur. With output
    adapters, we make up our minds about which technologies the system will use to
    allow data persistence and other types of external integration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，存在于应用程序六边形中的输出端口以抽象的方式表达与外部系统的交互。反过来，输出适配器有责任具体描述这些交互将如何发生。通过输出适配器，我们决定系统将使用哪些技术来实现数据持久性和其他类型的外部集成。
- en: Until now, we have talked about data based solely on the requirements expressed
    by the domain model we created in the Domain hexagon. After all, it’s the domain
    model from the Domain hexagon that drives the shape of the whole hexagonal system.
    Technological concerns are just mere details that must adhere to the domain model
    and not the other way around.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了基于我们在领域六边形中创建的领域模型表达的需求的数据。毕竟，是来自领域六边形的领域模型驱动了整个六边形系统的形状。技术问题只是必须遵守领域模型的细节，而不是相反。
- en: By using the output port as an interface in the Application hexagon and the
    output adapter as the implementation of that interface in the Framework hexagon,
    we are structuring the hexagonal system to support different technologies. In
    this structure, the output adapter in the Framework hexagon must conform to the
    output port interface in the Application hexagon, which, in turn, must rely on
    the domain model from the Domain hexagon.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在应用六边形中使用输出端口作为接口，以及在框架六边形中使用输出适配器作为该接口的实现，我们正在构建一个支持不同技术的六边形系统。在这个结构中，框架六边形中的输出适配器必须符合应用六边形中的输出端口接口，而应用六边形反过来必须依赖于来自领域六边形的领域模型。
- en: 'In the previous section, you may have noticed the usage of two different output
    adapters – the `RouterNetworkH2Adapter` adapter to deal with data from in-memory
    databases and the `RouterNetworkFileAdapter` adapter to read and persist files
    from a local filesystem. These two output adapters are implementations of the
    output ports we created in the Application hexagon:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你可能已经注意到了两种不同的输出适配器的使用 – `RouterNetworkH2Adapter` 适配器用于处理内存数据库中的数据，以及
    `RouterNetworkFileAdapter` 适配器用于从本地文件系统中读取和持久化文件。这两个输出适配器是我们创建在应用六边形中的输出端口的实现：
- en: '![Figure 4.4 – UML representation of output adapters](img/B19777_04_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 输出适配器的 UML 表示](img/B19777_04_04.jpg)'
- en: Figure 4.4 – UML representation of output adapters
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 输出适配器的 UML 表示
- en: 'We’ll start by implementing `RouterNetworkH2Adapter`. It uses an H2 in-memory
    database to set up all the required tables and relationships. This adapter implementation
    shows us how to adapt the domain model data to a relational database. Then, we
    proceed to implement `RouterNetworkFileAdapter`, which uses a **JSON** file-backed
    data structure. Both H2 and JSON file implementations are based on the data provided
    by the topology and inventory sample system we’ve been working on. These two adapters
    will allow two ways to attach an additional network to an existing switch:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现 `RouterNetworkH2Adapter`。它使用 H2 内存数据库来设置所有必需的表和关系。这个适配器实现展示了如何将领域模型数据适配到关系型数据库中。然后，我们继续实现
    `RouterNetworkFileAdapter`，它使用基于 **JSON** 文件的数据库结构。H2 和 JSON 文件实现都是基于我们一直在工作的拓扑和库存样本系统提供的数据。这两个适配器将允许以两种方式将附加网络连接到现有的交换机：
- en: '![Figure 4.5 – Topology and inventory system with a finance network](img/B19777_04_05.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 带有财务网络的拓扑和库存系统](img/B19777_04_05.jpg)'
- en: Figure 4.5 – Topology and inventory system with a finance network
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 带有财务网络的拓扑和库存系统
- en: Using the same input data from the previous section, we’ll attach **Finance
    Network** to **Layer 3 Switch** from **Edge Router** using one of the available
    two output adapters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节中相同的输入数据，我们将使用两种可用的输出适配器之一，将 **Finance Network** 连接到来自 **Edge Router**
    的 **Layer 3 Switch**。
- en: The H2 output adapter
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: H2 输出适配器
- en: 'Before implementing the H2 output adapter, we first need to define the database
    structure of the topology and inventory system. To determine that structure, we
    create the `resources/inventory.sql` file with the following SQL statements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 H2 输出适配器之前，我们首先需要定义拓扑和库存系统的数据库结构。为了确定这个结构，我们创建了一个包含以下 SQL 语句的 `resources/inventory.sql`
    文件：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although `switches` and `networks` have primary keys, we treat switches as entities
    and `networks` as value objects that are part of the `Router` entity in the domain
    model. We are imposing our model on the technological arrangement and not the
    other way around.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `switches` 和 `networks` 有主键，但我们把交换机视为实体，而 `networks` 视为领域模型中 `Router` 实体的组成部分。我们正在将我们的模型强加于技术安排，而不是相反。
- en: We don’t use these primary keys from the `switches` and `networks` tables as
    references in the domain model. Instead, we use the `router_id` value to correlate
    the `Router` entity with its `Switch` and `Network` value objects and their respective
    database tables. This correlation enables the formation of an aggregate where
    `Router` is the aggregate root, and `Switch` and `Network` are the objects used
    to compose the aggregate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在领域模型中不使用来自`switches`和`networks`表的这些主键作为参考。相反，我们使用`router_id`值来关联`Router`实体与其`Switch`和`Network`值对象及其相应的数据库表。这种关联使得可以形成一个聚合，其中`Router`是聚合根，而`Switch`和`Network`是用于组成聚合的对象。
- en: 'Now, we can proceed to implement `RouterNetworkOutputPort` to create the `RouterNetworkH2Adapter`
    class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续实现`RouterNetworkOutputPort`来创建`RouterNetworkH2Adapter`类：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first method we override is `fetchRouterById`, where we receive `routerId`
    to fetch a router from the H2 database using our entity manager reference. We
    cannot use the `Router` domain entity class to map directly to the database. Also,
    we cannot use the database entity as a domain entity. That’s why we use the `toDomain`
    method on `fetchRouterById` to map data from the H2 database to the domain.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先重写的方法是`fetchRouterById`，在这里我们接收`routerId`来使用我们的实体管理器引用从H2数据库中获取一个路由器。我们不能直接使用`Router`领域实体类映射到数据库。同样，我们也不能使用数据库实体作为领域实体。这就是为什么我们在`fetchRouterById`上使用`toDomain`方法来将H2数据库中的数据映射到领域。
- en: 'We do the same mapping procedure, using the `toH2` method on `persistRouter`
    to convert it from a domain model entity into an H2 database entity. The `setUpH2Database`
    method initiates the database when the application starts. To create only one
    instance of the H2 adapter, we define a singleton using the `getInstance` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行相同的映射过程，使用`persistRouter`上的`toH2`方法将数据从领域模型实体转换为H2数据库实体。`setUpH2Database`方法在应用程序启动时初始化数据库。为了创建H2适配器的单个实例，我们使用`getInstance`方法定义一个单例：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `instance` field is used to provide a singleton object of the H2 output
    adapter. Note that the constructor calls the `setUpH2Database` method to create
    a database connection using `EntityManagerFactory`. To properly configure the
    entity manager, we create the `resources/META-INF/persistence.xml` file with a
    property to set up the H2 database:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance`字段用于提供一个H2输出适配器的单例对象。请注意，构造函数调用`setUpH2Database`方法使用`EntityManagerFactory`创建数据库连接。为了正确配置实体管理器，我们创建一个包含设置H2数据库属性的`resources/META-INF/persistence.xml`文件：'
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Remember, our domain model comes first, so we don’t want to couple the system
    with database technology. That’s why we need to create a `RouterData` **ORM**
    class to map directly to the database types. Here, we are using **EclipseLink**,
    but you can use any **JPA-compliant** implementation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的领域模型是首要的，所以我们不想将系统与数据库技术耦合。这就是为什么我们需要创建一个直接映射到数据库类型的`RouterData` **ORM**类。在这里，我们使用**EclipseLink**，但你也可以使用任何**JPA兼容**的实现：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We use `@Getter`, `@NoArgsConstructor`, and `@AllArgsConstructor` annotations
    to diminish the verbosity of the class. We will use the getters and constructor
    later to convert the data class into a domain model class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Getter`、`@NoArgsConstructor`和`@AllArgsConstructor`注解来减少类的冗长性。我们将在以后使用获取器和构造函数将数据类转换为领域模型类。
- en: The usage of the `@Table` and `@SecondaryTable` annotations serves to represent
    the relationship between the `routers` and `switches` tables. This relationship
    is mapped using the `@OntToOne` and `@JoinColumn` annotations, specifying that
    both tables must be linked through the `router_id` attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@Table`和`@SecondaryTable`注解的目的是表示`routers`和`switches`表之间的关系。这种关系通过`@OntToOne`和`@JoinColumn`注解进行映射，指定两个表必须通过`router_id`属性相互链接。
- en: 'To use `UUID` as an ID in EclipseLink, we need to create the following converter
    class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在EclipseLink中使用`UUID`作为ID，我们需要创建以下转换类：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the class we use inside the `@Converter` annotation at the top of the
    `RouterData` class. Without this converter, there will be an exception stating
    a problem in mapping the `routerId` attribute. Following the declaration of `routerId`,
    there is a `RouterTypeData` attribute called `routerType`. For every ORM attribute,
    we add the `Data` suffix to the class name. Aside from `RouterData`, we do that
    with `RouterTypeData` and `SwitchData`. Remember that in the domain model, the
    equivalent types are `Router`, `RouterType`, and `Switch`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 `RouterData` 类顶部的 `@Converter` 注解中使用的类。如果没有这个转换器，将会抛出一个异常，指出在映射 `routerId`
    属性时存在问题。在 `routerId` 声明之后，有一个名为 `routerType` 的 `RouterTypeData` 属性。对于每个 ORM 属性，我们都在类名后添加
    `Data` 后缀。除了 `RouterData` 之外，我们还将 `RouterTypeData` 和 `SwitchData` 做同样处理。记住，在领域模型中，等效的类型是
    `Router`、`RouterType` 和 `Switch`。
- en: '`RouterTypeData` is the `enum` in which we store the router type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterTypeData` 是我们存储路由类型的枚举：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `@Embeddable` annotation allows the `enum` data to be mapped to the `router_type`
    field in the database using the `@``Embedded` annotation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Embeddable` 注解允许使用 `@Embedded` 注解将枚举数据映射到数据库中的 `router_type` 字段：'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the last `RouterData` field, we refer to `SwitchData` in the `networkSwitch`
    variable, which we use to create the relationship between a router and switch.
    Let’s see how the `SwitchData` class is implemented:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个 `RouterData` 字段，我们在 `networkSwitch` 变量中引用 `SwitchData`，我们使用它来创建路由和交换机之间的关系。让我们看看
    `SwitchData` 类是如何实现的：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We apply the same techniques to `SwitchData` that we applied to `RouterData`.
    There is a subtle difference though, which is the relationship established between
    the `switches` and `networks` tables. To create this relationship, we use the
    `@OneToMany` and `@JoinColumn` annotations to create a link between the `SwitchData`
    and `NetworkData` types using the `switch_id` attribute. A reference to a list
    of `NetworkData` objects is required because of the `@``OneToMany` annotation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用于 `RouterData` 的相同技术也应用于 `SwitchData`。不过，有一个细微的差别，那就是 `switches` 和 `networks`
    表之间建立的关系。为了创建这种关系，我们使用 `@OneToMany` 和 `@JoinColumn` 注解，通过 `switch_id` 属性在 `SwitchData`
    和 `NetworkData` 类型之间创建链接。由于 `@OneToMany` 注解，需要一个 `NetworkData` 对象列表的引用。
- en: 'Similar to `RouterDataType`, we have `SwitchDataType`, which is an `enum` equivalent
    of `SwitchType` from the domain model:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `RouterDataType` 类似，我们有 `SwitchDataType`，它是领域模型中 `SwitchType` 的枚举等效：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the topology and inventory system, we attach networks directly to a switch.
    To map the domain value object to the H2 database entity, we implement the `NetworkData`
    class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在拓扑和库存系统中，我们直接将网络附加到交换机上。要将领域值对象映射到 H2 数据库实体，我们实现 `NetworkData` 类：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All attributes we have in `NetworkData` are the same ones present in its domain
    value object counterpart. The only difference is the annotations we add to turn
    it into a database entity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NetworkData` 中我们拥有的所有属性都与它的领域值对象对应物中存在的属性相同。唯一的区别是我们添加的注解，将其转换为数据库实体。
- en: 'Both the `SwitchData` and `NetworkData` classes declare the `IPData` field.
    We encounter a similar behavior in the domain model, where `Switch` and `Network`
    classes have an `IP` attribute. Here is how we should implement the `IPData` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwitchData` 和 `NetworkData` 类都声明了 `IPData` 字段。在领域模型中，我们遇到类似的行为，其中 `Switch`
    和 `Network` 类有一个 `IP` 属性。以下是实现 `IPData` 类的方法：'
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ProtocolData` follows the same pattern used by other `enum`-based types:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProtocolData` 遵循其他基于枚举的类型所使用的相同模式：'
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We could argue that there is some repetition in creating all those classes to
    integrate the system with a database. That’s true. It’s a trade-off where we give
    up reusability in favor of changeability, making the application capable of better
    integration with RDBMSes and other data sources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以争论说，创建所有这些类以将系统与数据库集成存在一些重复。这是真的。这是一个权衡，我们牺牲了可重用性以换取可变性，使应用程序能够更好地与 RDBMS
    和其他数据源集成。
- en: 'Now that we have created all the ORM classes to allow integration with the
    H2 database, we need to translate database objects into domain model objects and
    vice versa. We accomplish this by creating a mapper class with mapper methods.
    Let’s start with the methods we use to convert database entities into domain entities:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有 ORM 类以允许与 H2 数据库集成，我们需要将数据库对象转换为领域模型对象，反之亦然。我们通过创建一个具有映射方法的映射类来完成此操作。让我们从我们将数据库实体转换为领域实体的方法开始：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `toDomain` method receives a `RouterData` type representing the database
    entity and returns a `Router` domain entity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`toDomain` 方法接收一个表示数据库实体的 `RouterData` 类型，并返回一个 `Router` 领域实体。'
- en: 'To convert a list of `NetworkData` database entity objects into a list of `Network`
    domain value objects, we use the `getNetworksFromData` method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `NetworkData` 数据库实体对象列表转换为 `Network` 领域值对象列表时，我们使用 `getNetworksFromData` 方法：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It receives a list of `NetworkData` database entity objects and returns a list
    of `Network` domain entity objects. Then, to convert from a domain model entity
    into an H2 database entity, we create the `toH2` mapper method:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收一个 `NetworkData` 数据库实体对象列表并返回一个 `Network` 领域实体对象列表。然后，为了将领域模型实体转换为 H2 数据库实体，我们创建
    `toH2` 映射方法：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `toH2` method receives a `Router` domain entity object as a parameter, to
    do the proper mapping, and then it returns a `RouterData` object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`toH2` 方法接收一个 `Router` 领域实体对象作为参数，以进行适当的映射，然后返回一个 `RouterData` 对象。'
- en: 'Finally, to convert a list of `Network` domain value objects into a list of
    `NetworkData` database entity objects, we have the `getNetworksFromDomain` method:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了将 `Network` 领域值对象列表转换为 `NetworkData` 数据库实体对象列表，我们有 `getNetworksFromDomain`
    方法：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `getNetworksFromDomain` method receives a list of `Network` domain value
    objects and a `UUID`-type switch ID as parameters. With that data, this method
    is able to do the proper mapping, returning a list of `NetworkData` database entity
    objects.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNetworksFromDomain` 方法接收一个 `Network` 领域值对象列表和一个 `UUID` 类型的开关 ID 作为参数。有了这些数据，该方法能够进行适当的映射，返回一个
    `NetworkData` 数据库实体对象列表。'
- en: 'The `toDomain` static method is used when we need to convert the H2 database
    object into its domain model counterpart:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将 H2 数据库对象转换为它的领域模型对应物时，使用 `toDomain` 静态方法：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When persisting the domain model entity as the H2 database entity, we use the
    `toH2` static method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当将领域模型实体作为 H2 数据库实体持久化时，我们使用 `toH2` 静态方法：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `fetchRouterById` and `persistRouter` methods are called from the `RouterNetworkInputPort`
    object, using a `RouterNetworkOutputPort` interface reference:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchRouterById` 和 `persistRouter` 方法是通过 `RouterNetworkInputPort` 对象调用的，使用
    `RouterNetworkOutputPort` 接口引用：'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that `RouterNetworkOutputPort` is resolved at runtime based on the
    parameter we pass to the `RouterNetworkInputPort` constructor. With this technique,
    we blind the hexagonal system regarding where it needs to go to get data. It can
    be a relational database or a `.json` file, as we’ll see in the next section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`RouterNetworkOutputPort` 是根据我们传递给 `RouterNetworkInputPort` 构造函数的参数在运行时解析的。使用这种技术，我们使六边形系统对它需要去哪里获取数据一无所知。它可以是关系数据库或
    `.json` 文件，我们将在下一节中看到。
- en: The file adapter
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件适配器
- en: 'To create the file adapter, we can apply the same ideas used to create the
    H2 database adapter, with just some minor adjustments to accommodate the file-backed
    data source. This data source is a `.json` file containing the same data used
    to create the previous database. So, to start, you can create a `.json` file at
    `resources/inventory.json` with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件适配器，我们可以应用创建 H2 数据库适配器时使用的相同想法，只需对适应基于文件的数据库源进行一些小的调整。这个数据源是一个包含用于创建先前数据库的相同数据的
    `.json` 文件。因此，首先，你可以在 `resources/inventory.json` 创建一个 `.json` 文件，其内容如下：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The purpose of adding a network to fulfill our use case goals remains the same,
    so again we will implement the `RouterNetworkOutputPort` interface to create `RouterNetworkFileAdapter`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加网络以满足我们的用例目标的目的保持不变，因此我们再次实现 `RouterNetworkOutputPort` 接口以创建 `RouterNetworkFileAdapter`：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `fetchRouterById` method returns a `Router` object by parsing a `.json`
    file using the `RouterId` parameter. The `persistRouter` method persists changes
    in the `inventory.json` file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchRouterById` 方法通过使用 `RouterId` 参数解析 `.json` 文件来返回一个 `Router` 对象。`persistRouter`
    方法将 `inventory.json` 文件中的更改持久化。'
- en: 'Instead of using an entity manager and EclipseLink, we use the `Jackson` libraries
    to serialize and deserialize the JSON data. To load the `inventory.json` file
    into memory, we use the adapter constructor to call the `readJsonFile` method
    to load the `inventory.json` file into a list of `RouterJson` objects:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用实体管理器和 EclipseLink，而是使用 `Jackson` 库来序列化和反序列化 JSON 数据。为了将 `inventory.json`
    文件加载到内存中，我们使用适配器构造函数调用 `readJsonFile` 方法将 `inventory.json` 文件加载到一个 `RouterJson`
    对象列表中：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As in the H2 case, with JSON, we also need to create special classes to map
    between JSON objects and domain model objects. The classes’ structure is similar
    to the H2 ORM classes, with differences mainly in the annotations used to create
    adequate mapping. Let’s see how to implement the `RouterJson` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H2 的情况下，与 JSON 一样，我们还需要创建特殊类来在 JSON 对象和领域模型对象之间进行映射。这些类的结构类似于 H2 ORM 类，主要区别在于用于创建适当映射的注解。让我们看看如何实现
    `RouterJson` 类：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `@JsonInclude` and `@JsonProperty` annotations to map class attributes
    to JSON fields. These JSON mappings are much more straightforward than H2 mappings
    because we don’t need to deal with database relationships. `RouterTypeJson`, `SwitchJson`,
    and all other JSON map classes are similar in that they use the same annotations
    to convert JSON and domain model objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@JsonInclude` 和 `@JsonProperty` 注解将类属性映射到 JSON 字段。这些 JSON 映射比 H2 映射更直接，因为我们不需要处理数据库关系。`RouterTypeJson`、`SwitchJson`
    以及所有其他 JSON 映射类都类似，它们使用相同的注解来转换 JSON 和领域模型对象。
- en: 'To convert `RouterJson` into `Router`, we use the `toDomain` method from the
    `RouterJsonFileMapper` mapper class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `RouterJson` 转换为 `Router`，我们使用 `RouterJsonFileMapper` 映射器类中的 `toDomain` 方法：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We use the `toJson` method to convert from `Router` into `RouterJson`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `toJson` 方法将 `Router` 转换为 `RouterJson`：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`RouterJsonFileMapper` is similar to its H2 counterpart but simpler because
    we don’t need to deal with **one-to-many** or **one-to-one** relationships. Let’s
    start with the methods used to convert JSON objects into domain objects:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterJsonFileMapper` 与其 H2 对应物类似，但更简单，因为我们不需要处理 **一对多** 或 **一对一** 的关系。让我们从将
    JSON 对象转换为领域对象的方法开始：'
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `toDomain` method here receives a `RouterJson` object as a parameter, performs
    the proper mapping, and then returns a `Router` object. A similar procedure occurs
    when we need to convert a list of `NetworkJson` JSON objects into a list of `Network`
    domain objects:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `toDomain` 方法接收一个 `RouterJson` 对象作为参数，执行适当的映射，然后返回一个 `Router` 对象。当我们需要将一系列
    `NetworkJson` JSON 对象转换为一系列 `Network` 领域对象时，发生类似的流程：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `getNetworksFromJson` method receives a list of `NetworkJson` objects as
    parameters and returns an adequately mapped list of `Network` objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNetworksFromJson` 方法接收一系列 `NetworkJson` 对象作为参数，并返回一个适当映射的 `Network` 对象列表。'
- en: 'Let’s see the methods used to convert domain objects into JSON objects:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将领域对象转换为 JSON 对象所使用的方法：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `toJson` method does the opposite of what `toDomain` does. Instead of a
    JSON object as a parameter, the `toJson` method here receives a `Router` domain
    object, performs the proper mapping, and returns a `RouterJson` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`toJson` 方法与 `toDomain` 方法相反。这里 `toJson` 方法接收一个 `Router` 领域对象作为参数，执行适当的映射，并返回一个
    `RouterJson` 对象。'
- en: 'Finally, we have a situation where it’s necessary to convert a list of `Network`
    domain objects into a list of `NetworkJson` JSON objects:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个需要将一系列 `Network` 领域对象转换为一系列 `NetworkJson` JSON 对象的情况：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By receiving a list of `Network` objects as parameters, the `getNetworksFromDomain`
    method can proceed to map the needed attributes and return a list of `NetworkJson`
    objects.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNetworksFromDomain` 方法通过接收一系列 `Network` 对象作为参数，可以继续映射所需的属性，并返回一系列 `NetworkJson`
    对象。'
- en: Now that we have completed the file output adapter implementation, let’s play
    around, calling both the file and H2 output adapters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了文件输出适配器的实现，让我们尝试调用文件和 H2 输出适配器。
- en: Calling the output adapters
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用输出适配器
- en: 'Before calling the adapter, let’s compile the application. Navigate to the
    `Chapter04` directory and run the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用适配器之前，让我们编译应用程序。导航到 `Chapter04` 目录并运行以下命令：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To call the H2 output adapter, we need to use the REST input adapter. We can
    do that by providing the `rest` parameter when executing the `.``jar` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 H2 输出适配器，我们需要使用 REST 输入适配器。我们可以在执行 `.jar` 文件时提供 `rest` 参数：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The file output adapter is accessible through the CLI input adapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输出适配器可以通过 CLI 输入适配器访问：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result of calling both the H2 and file output adapters will be the same:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 H2 和文件输出适配器的结果将是相同的：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note the `Finance` network block at the end of the output, which confirms that
    the data was correctly persisted.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出末尾的 `Finance` 网络块，这确认了数据已被正确持久化。
- en: By creating these two output adapters, we enabled the hexagonal application
    to speak with different data sources. The best part was that we didn’t need to
    change anything in the Domain or Application hexagons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建这两个输出适配器，我们使六边形应用程序能够与不同的数据源进行通信。最好的部分是，我们不需要在领域或应用程序六边形中做任何更改。
- en: The only requirement for creating an output adapter is implementing an output
    port interface from the Application hexagon. These output adapter examples showed
    how a hexagonal approach protects the business logic from technological concerns.
    Of course, there is a trade-off when we decide to follow this path. However, if
    we aim to make change-tolerant systems centered in the domain model, the hexagonal
    architecture provides the necessary techniques needed for that.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 创建输出适配器的唯一要求是从应用程序六边形实现一个输出端口接口。这些输出适配器示例展示了六边形方法如何保护业务逻辑不受技术问题的干扰。当然，当我们决定走这条路时，会有一定的权衡。然而，如果我们旨在创建以领域模型为中心的容变系统，六边形架构提供了实现这一目标的必要技术。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned in this chapter that adapters are used to define the technologies
    that are supported by a hexagonal application. We created two input adapters to
    allow driving operations, that is, a REST adapter to receive data from HTTP connections
    and a CLI adapter to receive data from `STDIN`. Both input adapters were attached
    to the same input port, allowing the hexagonal system to use the same logic to
    process requests coming in distinct formats.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到适配器用于定义六边形应用程序支持的技术。我们创建了两个输入适配器以允许驱动操作，即一个REST适配器用于接收来自HTTP连接的数据，一个CLI适配器用于接收来自`STDIN`的数据。这两个输入适配器连接到相同的输入端口，允许六边形系统使用相同的逻辑来处理以不同格式传入的请求。
- en: Then, we created an H2 database output adapter and a JSON file output adapter
    to allow the hexagonal application to communicate with different data sources.
    These two output adapters were attached to the same output port, enabling the
    hexagonal system to persist and obtain data from external sources so that the
    data source technology did not influence the business logic.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个H2数据库输出适配器和JSON文件输出适配器，以便六边形应用程序能够与不同的数据源进行通信。这两个输出适配器连接到相同的输出端口，使得六边形系统能够从外部源持久化和获取数据，这样数据源技术就不会影响业务逻辑。
- en: By knowing the purpose of input and output adapters and understanding how to
    implement them, we can now create systems that can tolerate significant technological
    changes without substantial refactoring. This benefit is achieved because all
    the system components, including the adapters, are developed around the domain
    model.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解输入和输出适配器的目的，并理解如何实现它们，我们现在可以创建能够容忍重大技术变化而无需大量重构的系统。这种好处是通过所有系统组件，包括适配器，都是围绕领域模型开发的来实现的。
- en: To fully understand the dynamic between adapters and other hexagonal architecture
    elements, we’re going to look into the life cycle of driving and driven operations
    in the next chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面理解适配器与其他六边形架构元素之间的动态关系，我们将在下一章探讨驱动和被驱动操作的生命周期。
- en: Questions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: When should we create an input adapter?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么时候创建输入适配器？
- en: What is the benefit of connecting multiple input adapters to the same input
    port?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多个输入适配器连接到同一输入端口的好处是什么？
- en: What interface must we implement to create output adapters?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须实现哪个接口来创建输出适配器？
- en: Which hexagon do the input and output adapters belong to?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入和输出适配器属于哪个六边形？
- en: Answers
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We create an input adapter when we need to expose software features to be accessed
    by driving actors. These actors can access the hexagonal application using different
    technologies or protocols, such as HTTP REST or via the command line.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们需要将软件功能暴露给驱动操作者访问时，我们会创建输入适配器。这些操作者可以使用不同的技术或协议，如HTTP REST或通过命令行，来访问六边形应用程序。
- en: The main benefit is that the same logic, contained in an input port, can be
    used to treat data that comes from different input adapters.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要好处是，包含在输入端口中的相同逻辑可以用来处理来自不同输入适配器的数据。
- en: Output adapters must always implement output ports. By doing that, we are sure
    that the adapters are in line with the requirements expressed by the domain model.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出适配器必须始终实现输出端口。通过这样做，我们可以确保适配器符合领域模型所表达的要求。
- en: They are both from the Framework hexagon.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们都来自框架六边形。
- en: Further reading
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Get Your Hands Dirty on Clean Architecture: A hands-on guide to creating clean
    web applications with code examples in Java*, Tom Hombergs, Packt Publishing Ltd.,
    2019'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《动手实践清洁架构：使用Java代码示例创建清洁Web应用程序的实用指南》，Tom Hombergs，Packt Publishing Ltd.，2019
- en: '*Object-Oriented Software Engineering: A Use Case Driven Approach*, Ivar Jacobson,
    Pearson Education, 1992'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《面向对象软件工程：一种用例驱动的方法》，Ivar Jacobson，Pearson Education，1992
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software*, Eric
    Evans, Pearson Education, 2003'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域驱动设计：软件核心的复杂性处理*，埃里克·埃文斯，Pearson Education，2003'
- en: '*Implementing Domain-Driven Design*, Vaughn Vernon, Pearson Education, 2013'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现领域驱动设计*，沃恩·弗农，Pearson Education，2013'
- en: '*Hexagonal architecture* ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/)),
    Alistair Cockburn'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*六边形架构* ([https://alistair.cockburn.us/hexagonal-architecture/](https://alistair.cockburn.us/hexagonal-architecture/))，阿利斯泰尔·科克本'
